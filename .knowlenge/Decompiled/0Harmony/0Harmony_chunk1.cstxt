using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
internal sealed class RefSafetyRulesAttribute : Attribute
{
	public readonly int Version;

	public RefSafetyRulesAttribute(int P_0)
	{
		Version = P_0;
	}
}


using System;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

public class DelegateTypeFactory
{
	private readonly ModuleBuilder module;

	private static int counter;

	public DelegateTypeFactory()
	{
		counter++;
		string name = $"HarmonyDTFAssembly{counter}";
		AssemblyBuilder assemblyBuilder = PatchTools.DefineDynamicAssembly(name);
		module = assemblyBuilder.DefineDynamicModule($"HarmonyDTFModule{counter}");
	}

	public Type CreateDelegateType(MethodInfo method)
	{
		TypeAttributes attr = TypeAttributes.Public | TypeAttributes.Sealed;
		TypeBuilder typeBuilder = module.DefineType($"HarmonyDTFType{counter}", attr, typeof(MulticastDelegate));
		ConstructorBuilder constructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName, CallingConventions.Standard, new Type[2]
		{
			typeof(object),
			typeof(IntPtr)
		});
		constructorBuilder.SetImplementationFlags(MethodImplAttributes.CodeTypeMask);
		ParameterInfo[] parameters = method.GetParameters();
		MethodBuilder methodBuilder = typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig, method.ReturnType, parameters.Types());
		methodBuilder.SetImplementationFlags(MethodImplAttributes.CodeTypeMask);
		for (int i = 0; i < parameters.Length; i++)
		{
			methodBuilder.DefineParameter(i + 1, ParameterAttributes.None, parameters[i].Name);
		}
		return typeBuilder.CreateType();
	}
}


using System;

[Obsolete("Use AccessTools.FieldRefAccess<T, S> for fields and AccessTools.MethodDelegate<Func<T, S>> for property getters")]
public delegate S GetterHandler<in T, out S>(T source);


using System;

[Obsolete("Use AccessTools.FieldRefAccess<T, S> for fields and AccessTools.MethodDelegate<Action<T, S>> for property setters")]
public delegate void SetterHandler<in T, in S>(T source, S value);


public delegate T InstantiationHandler<out T>();


using System;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.Utils;

public static class FastAccess
{
	public static InstantiationHandler<T> CreateInstantiationHandler<T>()
	{
		ConstructorInfo constructor = typeof(T).GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Array.Empty<Type>(), null);
		if ((object)constructor == null)
		{
			throw new ApplicationException($"The type {typeof(T)} must declare an empty constructor (the constructor may be private, internal, protected, protected internal, or public).");
		}
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("InstantiateObject_" + typeof(T).Name, typeof(T), null);
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Newobj, constructor);
		iLGenerator.Emit(OpCodes.Ret);
		return (InstantiationHandler<T>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(InstantiationHandler<T>));
	}

	[Obsolete("Use AccessTools.MethodDelegate<Func<T, S>>(PropertyInfo.GetGetMethod(true))")]
	public static GetterHandler<T, S> CreateGetterHandler<T, S>(PropertyInfo propertyInfo)
	{
		MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
		DynamicMethodDefinition dynamicMethodDefinition = CreateGetDynamicMethod<T, S>(propertyInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Call, getMethod);
		iLGenerator.Emit(OpCodes.Ret);
		return (GetterHandler<T, S>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(GetterHandler<T, S>));
	}

	[Obsolete("Use AccessTools.FieldRefAccess<T, S>(fieldInfo)")]
	public static GetterHandler<T, S> CreateGetterHandler<T, S>(FieldInfo fieldInfo)
	{
		DynamicMethodDefinition dynamicMethodDefinition = CreateGetDynamicMethod<T, S>(fieldInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldfld, fieldInfo);
		iLGenerator.Emit(OpCodes.Ret);
		return (GetterHandler<T, S>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(GetterHandler<T, S>));
	}

	[Obsolete("Use AccessTools.FieldRefAccess<T, S>(name) for fields and AccessTools.MethodDelegate<Func<T, S>>(AccessTools.PropertyGetter(typeof(T), name)) for properties")]
	public static GetterHandler<T, S> CreateFieldGetter<T, S>(params string[] names)
	{
		foreach (string name in names)
		{
			FieldInfo field = typeof(T).GetField(name, AccessTools.all);
			if ((object)field != null)
			{
				return CreateGetterHandler<T, S>(field);
			}
			PropertyInfo property = typeof(T).GetProperty(name, AccessTools.all);
			if ((object)property != null)
			{
				return CreateGetterHandler<T, S>(property);
			}
		}
		return null;
	}

	[Obsolete("Use AccessTools.MethodDelegate<Action<T, S>>(PropertyInfo.GetSetMethod(true))")]
	public static SetterHandler<T, S> CreateSetterHandler<T, S>(PropertyInfo propertyInfo)
	{
		MethodInfo setMethod = propertyInfo.GetSetMethod(nonPublic: true);
		DynamicMethodDefinition dynamicMethodDefinition = CreateSetDynamicMethod<T, S>(propertyInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldarg_1);
		iLGenerator.Emit(OpCodes.Call, setMethod);
		iLGenerator.Emit(OpCodes.Ret);
		return (SetterHandler<T, S>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(SetterHandler<T, S>));
	}

	[Obsolete("Use AccessTools.FieldRefAccess<T, S>(fieldInfo)")]
	public static SetterHandler<T, S> CreateSetterHandler<T, S>(FieldInfo fieldInfo)
	{
		DynamicMethodDefinition dynamicMethodDefinition = CreateSetDynamicMethod<T, S>(fieldInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldarg_1);
		iLGenerator.Emit(OpCodes.Stfld, fieldInfo);
		iLGenerator.Emit(OpCodes.Ret);
		return (SetterHandler<T, S>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(SetterHandler<T, S>));
	}

	private static DynamicMethodDefinition CreateGetDynamicMethod<T, S>(Type type)
	{
		return new DynamicMethodDefinition("DynamicGet_" + type.Name, typeof(S), new Type[1] { typeof(T) });
	}

	private static DynamicMethodDefinition CreateSetDynamicMethod<T, S>(Type type)
	{
		return new DynamicMethodDefinition("DynamicSet_" + type.Name, typeof(void), new Type[2]
		{
			typeof(T),
			typeof(S)
		});
	}
}


public delegate object FastInvokeHandler(object target, params object[] parameters);


using System;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.Utils;

public static class MethodInvoker
{
	public static FastInvokeHandler GetHandler(MethodInfo methodInfo, bool directBoxValueAccess = false)
	{
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("FastInvoke_" + methodInfo.Name + "_" + (directBoxValueAccess ? "direct" : "indirect"), typeof(object), new Type[2]
		{
			typeof(object),
			typeof(object[])
		});
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		if (!methodInfo.IsStatic)
		{
			Emit(iLGenerator, OpCodes.Ldarg_0);
			EmitUnboxIfNeeded(iLGenerator, methodInfo.DeclaringType);
		}
		bool flag = true;
		ParameterInfo[] parameters = methodInfo.GetParameters();
		for (int i = 0; i < parameters.Length; i++)
		{
			Type type = parameters[i].ParameterType;
			bool isByRef = type.IsByRef;
			if (isByRef)
			{
				type = type.GetElementType();
			}
			bool isValueType = type.IsValueType;
			if (isByRef && isValueType && !directBoxValueAccess)
			{
				Emit(iLGenerator, OpCodes.Ldarg_1);
				EmitFastInt(iLGenerator, i);
			}
			Emit(iLGenerator, OpCodes.Ldarg_1);
			EmitFastInt(iLGenerator, i);
			if (isByRef && !isValueType)
			{
				Emit(iLGenerator, OpCodes.Ldelema, typeof(object));
				continue;
			}
			Emit(iLGenerator, OpCodes.Ldelem_Ref);
			if (!isValueType)
			{
				continue;
			}
			if (!isByRef || !directBoxValueAccess)
			{
				Emit(iLGenerator, OpCodes.Unbox_Any, type);
				if (isByRef)
				{
					Emit(iLGenerator, OpCodes.Box, type);
					Emit(iLGenerator, OpCodes.Dup);
					if (flag)
					{
						flag = false;
						iLGenerator.DeclareLocal(typeof(object), pinned: false);
					}
					Emit(iLGenerator, OpCodes.Stloc_0);
					Emit(iLGenerator, OpCodes.Stelem_Ref);
					Emit(iLGenerator, OpCodes.Ldloc_0);
					Emit(iLGenerator, OpCodes.Unbox, type);
				}
			}
			else
			{
				Emit(iLGenerator, OpCodes.Unbox, type);
			}
		}
		if (methodInfo.IsStatic)
		{
			EmitCall(iLGenerator, OpCodes.Call, methodInfo);
		}
		else
		{
			EmitCall(iLGenerator, OpCodes.Callvirt, methodInfo);
		}
		if (methodInfo.ReturnType == typeof(void))
		{
			Emit(iLGenerator, OpCodes.Ldnull);
		}
		else
		{
			EmitBoxIfNeeded(iLGenerator, methodInfo.ReturnType);
		}
		Emit(iLGenerator, OpCodes.Ret);
		return (FastInvokeHandler)dynamicMethodDefinition.Generate().CreateDelegate(typeof(FastInvokeHandler));
	}

	internal static void Emit(ILGenerator il, OpCode opcode)
	{
		il.Emit(opcode);
	}

	internal static void Emit(ILGenerator il, OpCode opcode, Type type)
	{
		il.Emit(opcode, type);
	}

	internal static void EmitCall(ILGenerator il, OpCode opcode, MethodInfo methodInfo)
	{
		il.EmitCall(opcode, methodInfo, null);
	}

	private static void EmitUnboxIfNeeded(ILGenerator il, Type type)
	{
		if (type.IsValueType)
		{
			Emit(il, OpCodes.Unbox_Any, type);
		}
	}

	private static void EmitBoxIfNeeded(ILGenerator il, Type type)
	{
		if (type.IsValueType)
		{
			Emit(il, OpCodes.Box, type);
		}
	}

	internal static void EmitFastInt(ILGenerator il, int value)
	{
		switch (value)
		{
		case -1:
			il.Emit(OpCodes.Ldc_I4_M1);
			return;
		case 0:
			il.Emit(OpCodes.Ldc_I4_0);
			return;
		case 1:
			il.Emit(OpCodes.Ldc_I4_1);
			return;
		case 2:
			il.Emit(OpCodes.Ldc_I4_2);
			return;
		case 3:
			il.Emit(OpCodes.Ldc_I4_3);
			return;
		case 4:
			il.Emit(OpCodes.Ldc_I4_4);
			return;
		case 5:
			il.Emit(OpCodes.Ldc_I4_5);
			return;
		case 6:
			il.Emit(OpCodes.Ldc_I4_6);
			return;
		case 7:
			il.Emit(OpCodes.Ldc_I4_7);
			return;
		case 8:
			il.Emit(OpCodes.Ldc_I4_8);
			return;
		}
		if (value > -129 && value < 128)
		{
			il.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
		}
		else
		{
			il.Emit(OpCodes.Ldc_I4, value);
		}
	}
}


public delegate ref T RefResult<T>();


using System;
using System.Collections.Generic;
using System.Reflection;
using HarmonyLib;

internal class AccessCache
{
	internal enum MemberType
	{
		Any,
		Static,
		Instance
	}

	private const BindingFlags BasicFlags = BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty;

	private static readonly Dictionary<MemberType, BindingFlags> declaredOnlyBindingFlags = new Dictionary<MemberType, BindingFlags>
	{
		{
			MemberType.Any,
			BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty
		},
		{
			MemberType.Instance,
			BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty
		},
		{
			MemberType.Static,
			BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty
		}
	};

	private readonly Dictionary<Type, Dictionary<string, FieldInfo>> declaredFields = new Dictionary<Type, Dictionary<string, FieldInfo>>();

	private readonly Dictionary<Type, Dictionary<string, PropertyInfo>> declaredProperties = new Dictionary<Type, Dictionary<string, PropertyInfo>>();

	private readonly Dictionary<Type, Dictionary<string, Dictionary<int, MethodBase>>> declaredMethods = new Dictionary<Type, Dictionary<string, Dictionary<int, MethodBase>>>();

	private readonly Dictionary<Type, Dictionary<string, FieldInfo>> inheritedFields = new Dictionary<Type, Dictionary<string, FieldInfo>>();

	private readonly Dictionary<Type, Dictionary<string, PropertyInfo>> inheritedProperties = new Dictionary<Type, Dictionary<string, PropertyInfo>>();

	private readonly Dictionary<Type, Dictionary<string, Dictionary<int, MethodBase>>> inheritedMethods = new Dictionary<Type, Dictionary<string, Dictionary<int, MethodBase>>>();

	private static T Get<T>(Dictionary<Type, Dictionary<string, T>> dict, Type type, string name, Func<T> fetcher)
	{
		lock (dict)
		{
			if (!dict.TryGetValue(type, out var value))
			{
				value = (dict[type] = new Dictionary<string, T>());
			}
			if (!value.TryGetValue(name, out var value2))
			{
				value2 = (value[name] = fetcher());
			}
			return value2;
		}
	}

	private static T Get<T>(Dictionary<Type, Dictionary<string, Dictionary<int, T>>> dict, Type type, string name, Type[] arguments, Func<T> fetcher)
	{
		lock (dict)
		{
			if (!dict.TryGetValue(type, out var value))
			{
				value = (dict[type] = new Dictionary<string, Dictionary<int, T>>());
			}
			if (!value.TryGetValue(name, out var value2))
			{
				value2 = (value[name] = new Dictionary<int, T>());
			}
			int key = AccessTools.CombinedHashCode(arguments);
			if (!value2.TryGetValue(key, out var value3))
			{
				value3 = (value2[key] = fetcher());
			}
			return value3;
		}
	}

	internal FieldInfo GetFieldInfo(Type type, string name, MemberType memberType = MemberType.Any, bool declaredOnly = false)
	{
		FieldInfo fieldInfo = Get(declaredFields, type, name, () => type.GetField(name, declaredOnlyBindingFlags[memberType]));
		if ((object)fieldInfo == null && !declaredOnly)
		{
			fieldInfo = Get(inheritedFields, type, name, () => AccessTools.FindIncludingBaseTypes(type, (Type t) => t.GetField(name, AccessTools.all)));
		}
		return fieldInfo;
	}

	internal PropertyInfo GetPropertyInfo(Type type, string name, MemberType memberType = MemberType.Any, bool declaredOnly = false)
	{
		PropertyInfo propertyInfo = Get(declaredProperties, type, name, () => type.GetProperty(name, declaredOnlyBindingFlags[memberType]));
		if ((object)propertyInfo == null && !declaredOnly)
		{
			propertyInfo = Get(inheritedProperties, type, name, () => AccessTools.FindIncludingBaseTypes(type, (Type t) => t.GetProperty(name, AccessTools.all)));
		}
		return propertyInfo;
	}

	internal MethodBase GetMethodInfo(Type type, string name, Type[] arguments, MemberType memberType = MemberType.Any, bool declaredOnly = false)
	{
		MethodBase methodBase = Get(declaredMethods, type, name, arguments, () => type.GetMethod(name, declaredOnlyBindingFlags[memberType], null, arguments, null));
		if ((object)methodBase == null && !declaredOnly)
		{
			methodBase = Get(inheritedMethods, type, name, arguments, () => AccessTools.Method(type, name, arguments));
		}
		return methodBase;
	}
}


internal enum MemberType
{
	Any,
	Static,
	Instance
}


using System;

internal class ByteBuffer
{
	internal byte[] buffer;

	internal int position;

	internal ByteBuffer(byte[] buffer)
	{
		this.buffer = buffer;
	}

	internal byte ReadByte()
	{
		CheckCanRead(1);
		return buffer[position++];
	}

	internal byte[] ReadBytes(int length)
	{
		CheckCanRead(length);
		byte[] array = new byte[length];
		Buffer.BlockCopy(buffer, position, array, 0, length);
		position += length;
		return array;
	}

	internal short ReadInt16()
	{
		CheckCanRead(2);
		short result = (short)(buffer[position] | (buffer[position + 1] << 8));
		position += 2;
		return result;
	}

	internal int ReadInt32()
	{
		CheckCanRead(4);
		int result = buffer[position] | (buffer[position + 1] << 8) | (buffer[position + 2] << 16) | (buffer[position + 3] << 24);
		position += 4;
		return result;
	}

	internal long ReadInt64()
	{
		CheckCanRead(8);
		uint num = (uint)(buffer[position] | (buffer[position + 1] << 8) | (buffer[position + 2] << 16) | (buffer[position + 3] << 24));
		uint num2 = (uint)(buffer[position + 4] | (buffer[position + 5] << 8) | (buffer[position + 6] << 16) | (buffer[position + 7] << 24));
		long result = (long)(((ulong)num2 << 32) | num);
		position += 8;
		return result;
	}

	internal float ReadSingle()
	{
		if (!BitConverter.IsLittleEndian)
		{
			byte[] array = ReadBytes(4);
			Array.Reverse((Array)array);
			return BitConverter.ToSingle(array, 0);
		}
		CheckCanRead(4);
		float result = BitConverter.ToSingle(buffer, position);
		position += 4;
		return result;
	}

	internal double ReadDouble()
	{
		if (!BitConverter.IsLittleEndian)
		{
			byte[] array = ReadBytes(8);
			Array.Reverse((Array)array);
			return BitConverter.ToDouble(array, 0);
		}
		CheckCanRead(8);
		double result = BitConverter.ToDouble(buffer, position);
		position += 8;
		return result;
	}

	private void CheckCanRead(int count)
	{
		if (position + count > buffer.Length)
		{
			throw new ArgumentOutOfRangeException("count", $"position({position}) + count({count}) > buffer.Length({buffer.Length})");
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

internal class CodeTranspiler
{
	private readonly IEnumerable<CodeInstruction> codeInstructions;

	private readonly List<MethodInfo> transpilers = new List<MethodInfo>();

	private static readonly Dictionary<OpCode, OpCode> allJumpCodes = new Dictionary<OpCode, OpCode>
	{
		{
			OpCodes.Beq_S,
			OpCodes.Beq
		},
		{
			OpCodes.Bge_S,
			OpCodes.Bge
		},
		{
			OpCodes.Bge_Un_S,
			OpCodes.Bge_Un
		},
		{
			OpCodes.Bgt_S,
			OpCodes.Bgt
		},
		{
			OpCodes.Bgt_Un_S,
			OpCodes.Bgt_Un
		},
		{
			OpCodes.Ble_S,
			OpCodes.Ble
		},
		{
			OpCodes.Ble_Un_S,
			OpCodes.Ble_Un
		},
		{
			OpCodes.Blt_S,
			OpCodes.Blt
		},
		{
			OpCodes.Blt_Un_S,
			OpCodes.Blt_Un
		},
		{
			OpCodes.Bne_Un_S,
			OpCodes.Bne_Un
		},
		{
			OpCodes.Brfalse_S,
			OpCodes.Brfalse
		},
		{
			OpCodes.Brtrue_S,
			OpCodes.Brtrue
		},
		{
			OpCodes.Br_S,
			OpCodes.Br
		},
		{
			OpCodes.Leave_S,
			OpCodes.Leave
		}
	};

	internal CodeTranspiler(List<ILInstruction> ilInstructions)
	{
		codeInstructions = ilInstructions.Select((ILInstruction ilInstruction) => ilInstruction.GetCodeInstruction()).ToList().AsEnumerable();
	}

	internal void Add(MethodInfo transpiler)
	{
		transpilers.Add(transpiler);
	}

	internal static object ConvertInstruction(Type type, object instruction, out Dictionary<string, object> unassigned)
	{
		Dictionary<string, object> nonExisting = new Dictionary<string, object>();
		object result = AccessTools.MakeDeepCopy(instruction, type, delegate(string namePath, Traverse trvSrc, Traverse trvDest)
		{
			object value = trvSrc.GetValue();
			if (!trvDest.FieldExists())
			{
				nonExisting[namePath] = value;
				return (object)null;
			}
			return (namePath == "opcode") ? ((object)ReplaceShortJumps((OpCode)value)) : value;
		});
		unassigned = nonExisting;
		return result;
	}

	internal static bool ShouldAddExceptionInfo(object op, int opIndex, List<object> originalInstructions, List<object> newInstructions, Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		int num = originalInstructions.IndexOf(op);
		if (num == -1)
		{
			return false;
		}
		if (!unassignedValues.TryGetValue(op, out var unassigned))
		{
			return false;
		}
		if (!unassigned.TryGetValue("blocks", out var blocksObject))
		{
			return false;
		}
		List<ExceptionBlock> blocks = blocksObject as List<ExceptionBlock>;
		int num2 = newInstructions.Count((object instr) => instr == op);
		if (num2 <= 1)
		{
			return true;
		}
		ExceptionBlock exceptionBlock = blocks.FirstOrDefault((ExceptionBlock block) => block.blockType != ExceptionBlockType.EndExceptionBlock);
		ExceptionBlock exceptionBlock2 = blocks.FirstOrDefault((ExceptionBlock block) => block.blockType == ExceptionBlockType.EndExceptionBlock);
		if (exceptionBlock != null && exceptionBlock2 == null)
		{
			object obj = originalInstructions.Skip(num + 1).FirstOrDefault(delegate(object instr)
			{
				if (!unassignedValues.TryGetValue(instr, out unassigned))
				{
					return false;
				}
				if (!unassigned.TryGetValue("blocks", out blocksObject))
				{
					return false;
				}
				blocks = blocksObject as List<ExceptionBlock>;
				return blocks.Count > 0;
			});
			if (obj != null)
			{
				int num3 = num + 1;
				int num4 = num3 + originalInstructions.Skip(num3).ToList().IndexOf(obj) - 1;
				IEnumerable<object> first = originalInstructions.GetRange(num3, num4 - num3).Intersect(newInstructions);
				obj = newInstructions.Skip(opIndex + 1).FirstOrDefault(delegate(object instr)
				{
					if (!unassignedValues.TryGetValue(instr, out unassigned))
					{
						return false;
					}
					if (!unassigned.TryGetValue("blocks", out blocksObject))
					{
						return false;
					}
					blocks = blocksObject as List<ExceptionBlock>;
					return blocks.Count > 0;
				});
				if (obj != null)
				{
					num3 = opIndex + 1;
					num4 = num3 + newInstructions.Skip(opIndex + 1).ToList().IndexOf(obj) - 1;
					List<object> range = newInstructions.GetRange(num3, num4 - num3);
					List<object> list = first.Except(range).ToList();
					return list.Count == 0;
				}
			}
		}
		if (exceptionBlock == null && exceptionBlock2 != null)
		{
			object obj2 = originalInstructions.GetRange(0, num).LastOrDefault(delegate(object instr)
			{
				if (!unassignedValues.TryGetValue(instr, out unassigned))
				{
					return false;
				}
				if (!unassigned.TryGetValue("blocks", out blocksObject))
				{
					return false;
				}
				blocks = blocksObject as List<ExceptionBlock>;
				return blocks.Count > 0;
			});
			if (obj2 != null)
			{
				int num5 = originalInstructions.GetRange(0, num).LastIndexOf(obj2);
				int num6 = num;
				IEnumerable<object> first2 = originalInstructions.GetRange(num5, num6 - num5).Intersect(newInstructions);
				obj2 = newInstructions.GetRange(0, opIndex).LastOrDefault(delegate(object instr)
				{
					if (!unassignedValues.TryGetValue(instr, out unassigned))
					{
						return false;
					}
					if (!unassigned.TryGetValue("blocks", out blocksObject))
					{
						return false;
					}
					blocks = blocksObject as List<ExceptionBlock>;
					return blocks.Count > 0;
				});
				if (obj2 != null)
				{
					num5 = newInstructions.GetRange(0, opIndex).LastIndexOf(obj2);
					num6 = opIndex;
					List<object> range2 = newInstructions.GetRange(num5, num6 - num5);
					IEnumerable<object> source = first2.Except(range2);
					return !source.Any();
				}
			}
		}
		return true;
	}

	internal static IEnumerable ConvertInstructionsAndUnassignedValues(Type type, IEnumerable enumerable, out Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		Assembly assembly = type.GetGenericTypeDefinition().Assembly;
		Type type2 = assembly.GetType(typeof(List<>).FullName);
		Type type3 = type.GetGenericArguments()[0];
		Type type4 = type2.MakeGenericType(type3);
		Type type5 = assembly.GetType(type4.FullName);
		object obj = Activator.CreateInstance(type5);
		MethodInfo method = obj.GetType().GetMethod("Add");
		unassignedValues = new Dictionary<object, Dictionary<string, object>>();
		foreach (object item in enumerable)
		{
			Dictionary<string, object> unassigned;
			object obj2 = ConvertInstruction(type3, item, out unassigned);
			unassignedValues.Add(obj2, unassigned);
			method.Invoke(obj, new object[1] { obj2 });
		}
		return obj as IEnumerable;
	}

	internal static IEnumerable ConvertToOurInstructions(IEnumerable instructions, Type codeInstructionType, List<object> originalInstructions, Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		List<object> newInstructions = instructions.Cast<object>().ToList();
		int index = -1;
		foreach (object item in newInstructions)
		{
			index++;
			object obj = AccessTools.MakeDeepCopy(item, codeInstructionType);
			if (unassignedValues.TryGetValue(item, out var value))
			{
				bool flag = ShouldAddExceptionInfo(item, index, originalInstructions, newInstructions, unassignedValues);
				Traverse traverse = Traverse.Create(obj);
				foreach (KeyValuePair<string, object> item2 in value)
				{
					if (flag || item2.Key != "blocks")
					{
						traverse.Field(item2.Key).SetValue(item2.Value);
					}
				}
			}
			yield return obj;
		}
	}

	private static bool IsCodeInstructionsParameter(Type type)
	{
		if (type.IsGenericType)
		{
			return type.GetGenericTypeDefinition().Name.StartsWith("IEnumerable", StringComparison.Ordinal);
		}
		return false;
	}

	internal static IEnumerable ConvertToGeneralInstructions(MethodInfo transpiler, IEnumerable enumerable, out Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		Type type = (from p in transpiler.GetParameters()
			select p.ParameterType).FirstOrDefault((Type t) => IsCodeInstructionsParameter(t));
		if (type == typeof(IEnumerable<CodeInstruction>))
		{
			unassignedValues = null;
			return (enumerable as IList<CodeInstruction>) ?? ((enumerable as IEnumerable<CodeInstruction>) ?? enumerable.Cast<CodeInstruction>()).ToList();
		}
		return ConvertInstructionsAndUnassignedValues(type, enumerable, out unassignedValues);
	}

	internal static List<object> GetTranspilerCallParameters(ILGenerator generator, MethodInfo transpiler, MethodBase method, IEnumerable instructions)
	{
		List<object> parameter = new List<object>();
		(from param in transpiler.GetParameters()
			select param.ParameterType).Do(delegate(Type type)
		{
			if (type.IsAssignableFrom(typeof(ILGenerator)))
			{
				parameter.Add(generator);
			}
			else if (type.IsAssignableFrom(typeof(MethodBase)))
			{
				parameter.Add(method);
			}
			else if (IsCodeInstructionsParameter(type))
			{
				parameter.Add(instructions);
			}
		});
		return parameter;
	}

	internal List<CodeInstruction> GetResult(ILGenerator generator, MethodBase method)
	{
		IEnumerable instructions = codeInstructions;
		transpilers.ForEach(delegate(MethodInfo transpiler)
		{
			instructions = ConvertToGeneralInstructions(transpiler, instructions, out var unassignedValues);
			List<object> originalInstructions = null;
			if (unassignedValues != null)
			{
				originalInstructions = instructions.Cast<object>().ToList();
			}
			List<object> transpilerCallParameters = GetTranspilerCallParameters(generator, transpiler, method, instructions);
			if (transpiler.Invoke(null, transpilerCallParameters.ToArray()) is IEnumerable enumerable)
			{
				instructions = enumerable;
			}
			if (unassignedValues != null)
			{
				instructions = ConvertToOurInstructions(instructions, typeof(CodeInstruction), originalInstructions, unassignedValues);
			}
		});
		return (instructions as List<CodeInstruction>) ?? instructions.Cast<CodeInstruction>().ToList();
	}

	private static OpCode ReplaceShortJumps(OpCode opcode)
	{
		foreach (KeyValuePair<OpCode, OpCode> allJumpCode in allJumpCodes)
		{
			if (opcode == allJumpCode.Key)
			{
				return allJumpCode.Value;
			}
		}
		return opcode;
	}
}


internal class LeaveTry
{
	public override string ToString()
	{
		return "(autogenerated)";
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using HarmonyLib;
using Mono.Cecil.Cil;
using MonoMod.Utils.Cil;

internal class Emitter
{
	private readonly CecilILGenerator il;

	private readonly Dictionary<int, CodeInstruction> instructions = new Dictionary<int, CodeInstruction>();

	private readonly bool debug;

	internal Emitter(ILGenerator il, bool debug)
	{
		this.il = il.GetProxiedShim<CecilILGenerator>();
		this.debug = debug;
	}

	internal Dictionary<int, CodeInstruction> GetInstructions()
	{
		return instructions;
	}

	internal void AddInstruction(System.Reflection.Emit.OpCode opcode, object operand)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, operand));
	}

	internal int CurrentPos()
	{
		return il.ILOffset;
	}

	internal static string CodePos(int offset)
	{
		return $"IL_{offset:X4}: ";
	}

	internal string CodePos()
	{
		return CodePos(CurrentPos());
	}

	internal void LogComment(string comment)
	{
		if (debug)
		{
			string str = $"{CodePos()}// {comment}";
			FileLog.LogBuffered(str);
		}
	}

	internal void LogIL(System.Reflection.Emit.OpCode opcode)
	{
		if (debug)
		{
			FileLog.LogBuffered($"{CodePos()}{opcode}");
		}
	}

	internal void LogIL(System.Reflection.Emit.OpCode opcode, object arg, string extra = null)
	{
		if (debug)
		{
			string text = FormatArgument(arg, extra);
			string text2 = ((text.Length > 0) ? " " : "");
			string text3 = opcode.ToString();
			if (opcode.FlowControl == System.Reflection.Emit.FlowControl.Branch || opcode.FlowControl == System.Reflection.Emit.FlowControl.Cond_Branch)
			{
				text3 += " =>";
			}
			text3 = text3.PadRight(10);
			FileLog.LogBuffered($"{CodePos()}{text3}{text2}{text}");
		}
	}

	internal void LogAllLocalVariables()
	{
		if (debug)
		{
			il.IL.Body.Variables.Do(delegate(VariableDefinition v)
			{
				string str = string.Format("{0}Local var {1}: {2}{3}", CodePos(0), v.Index, v.VariableType.FullName, v.IsPinned ? "(pinned)" : "");
				FileLog.LogBuffered(str);
			});
		}
	}

	internal static string FormatArgument(object argument, string extra = null)
	{
		if (argument == null)
		{
			return "NULL";
		}
		Type type = argument.GetType();
		if (argument is MethodBase member)
		{
			return member.FullDescription() + ((extra != null) ? (" " + extra) : "");
		}
		if (argument is FieldInfo fieldInfo)
		{
			return $"{fieldInfo.FieldType.FullDescription()} {fieldInfo.DeclaringType.FullDescription()}::{fieldInfo.Name}";
		}
		if (type == typeof(Label))
		{
			return $"Label{((Label)argument/*cast due to .constrained prefix*/).GetHashCode()}";
		}
		if (type == typeof(Label[]))
		{
			return "Labels" + string.Join(",", ((Label[])argument).Select((Label l) => l.GetHashCode().ToString()).ToArray());
		}
		if (type == typeof(LocalBuilder))
		{
			return $"{((LocalBuilder)argument).LocalIndex} ({((LocalBuilder)argument).LocalType})";
		}
		if (type == typeof(string))
		{
			return argument.ToString().ToLiteral();
		}
		return argument.ToString().Trim();
	}

	internal void MarkLabel(Label label)
	{
		if (debug)
		{
			FileLog.LogBuffered(CodePos() + FormatArgument(label));
		}
		il.MarkLabel(label);
	}

	internal void MarkBlockBefore(ExceptionBlock block, out Label? label)
	{
		label = null;
		switch (block.blockType)
		{
		case ExceptionBlockType.BeginExceptionBlock:
			if (debug)
			{
				FileLog.LogBuffered(".try");
				FileLog.LogBuffered("{");
				FileLog.ChangeIndent(1);
			}
			label = il.BeginExceptionBlock();
			break;
		case ExceptionBlockType.BeginCatchBlock:
			if (debug)
			{
				LogIL(System.Reflection.Emit.OpCodes.Leave, new LeaveTry());
				FileLog.ChangeIndent(-1);
				FileLog.LogBuffered("} // end try");
				FileLog.LogBuffered($".catch {block.catchType}");
				FileLog.LogBuffered("{");
				FileLog.ChangeIndent(1);
			}
			il.BeginCatchBlock(block.catchType);
			break;
		case ExceptionBlockType.BeginExceptFilterBlock:
			if (debug)
			{
				LogIL(System.Reflection.Emit.OpCodes.Leave, new LeaveTry());
				FileLog.ChangeIndent(-1);
				FileLog.LogBuffered("} // end try");
				FileLog.LogBuffered(".filter");
				FileLog.LogBuffered("{");
				FileLog.ChangeIndent(1);
			}
			il.BeginExceptFilterBlock();
			break;
		case ExceptionBlockType.BeginFaultBlock:
			if (debug)
			{
				LogIL(System.Reflection.Emit.OpCodes.Leave, new LeaveTry());
				FileLog.ChangeIndent(-1);
				FileLog.LogBuffered("} // end try");
				FileLog.LogBuffered(".fault");
				FileLog.LogBuffered("{");
				FileLog.ChangeIndent(1);
			}
			il.BeginFaultBlock();
			break;
		case ExceptionBlockType.BeginFinallyBlock:
			if (debug)
			{
				LogIL(System.Reflection.Emit.OpCodes.Leave, new LeaveTry());
				FileLog.ChangeIndent(-1);
				FileLog.LogBuffered("} // end try");
				FileLog.LogBuffered(".finally");
				FileLog.LogBuffered("{");
				FileLog.ChangeIndent(1);
			}
			il.BeginFinallyBlock();
			break;
		}
	}

	internal void MarkBlockAfter(ExceptionBlock block)
	{
		ExceptionBlockType blockType = block.blockType;
		if (blockType == ExceptionBlockType.EndExceptionBlock)
		{
			if (debug)
			{
				LogIL(System.Reflection.Emit.OpCodes.Leave, new LeaveTry());
				FileLog.ChangeIndent(-1);
				FileLog.LogBuffered("} // end handler");
			}
			il.EndExceptionBlock();
		}
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode));
		LogIL(opcode);
		il.Emit(opcode);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, LocalBuilder local)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, local));
		LogIL(opcode, local);
		il.Emit(opcode, local);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, FieldInfo field)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, field));
		LogIL(opcode, field);
		il.Emit(opcode, field);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, Label[] labels)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, labels));
		LogIL(opcode, labels);
		il.Emit(opcode, labels);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, Label label)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, label));
		LogIL(opcode, label);
		il.Emit(opcode, label);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, string str)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, str));
		LogIL(opcode, str);
		il.Emit(opcode, str);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, float arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, byte arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, sbyte arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, double arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, int arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, MethodInfo meth)
	{
		if (opcode.Equals(System.Reflection.Emit.OpCodes.Call) || opcode.Equals(System.Reflection.Emit.OpCodes.Callvirt) || opcode.Equals(System.Reflection.Emit.OpCodes.Newobj))
		{
			EmitCall(opcode, meth, null);
			return;
		}
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, meth));
		LogIL(opcode, meth);
		il.Emit(opcode, meth);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, short arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, SignatureHelper signature)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, signature));
		LogIL(opcode, signature);
		il.Emit(opcode, signature);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, ConstructorInfo con)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, con));
		LogIL(opcode, con);
		il.Emit(opcode, con);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, Type cls)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, cls));
		LogIL(opcode, cls);
		il.Emit(opcode, cls);
	}

	internal void Emit(System.Reflection.Emit.OpCode opcode, long arg)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, arg));
		LogIL(opcode, arg);
		il.Emit(opcode, arg);
	}

	internal void EmitCall(System.Reflection.Emit.OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, methodInfo));
		string extra = ((optionalParameterTypes != null && optionalParameterTypes.Length != 0) ? optionalParameterTypes.Description() : null);
		LogIL(opcode, methodInfo, extra);
		il.EmitCall(opcode, methodInfo, optionalParameterTypes);
	}

	internal void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, unmanagedCallConv));
		string extra = returnType.FullName + " " + parameterTypes.Description();
		LogIL(opcode, unmanagedCallConv, extra);
		il.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
	}

	internal void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
	{
		instructions.Add(CurrentPos(), new CodeInstruction(opcode, callingConvention));
		string extra = returnType.FullName + " " + parameterTypes.Description() + " " + optionalParameterTypes.Description();
		LogIL(opcode, callingConvention, extra);
		il.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using HarmonyLib;
using Mono.Cecil;
using MonoMod.Utils;

internal static class HarmonySharedState
{
	private const string name = "HarmonySharedState";

	internal const int internalVersion = 102;

	private static readonly Dictionary<MethodBase, byte[]> state;

	private static readonly Dictionary<MethodInfo, MethodBase> originals;

	internal static readonly int actualVersion;

	static HarmonySharedState()
	{
		Type orCreateSharedStateType = GetOrCreateSharedStateType();
		FieldInfo field = orCreateSharedStateType.GetField("version");
		if ((int)field.GetValue(null) == 0)
		{
			field.SetValue(null, 102);
		}
		actualVersion = (int)field.GetValue(null);
		FieldInfo field2 = orCreateSharedStateType.GetField("state");
		if (field2.GetValue(null) == null)
		{
			field2.SetValue(null, new Dictionary<MethodBase, byte[]>());
		}
		FieldInfo field3 = orCreateSharedStateType.GetField("originals");
		if (field3 != null && field3.GetValue(null) == null)
		{
			field3.SetValue(null, new Dictionary<MethodInfo, MethodBase>());
		}
		state = (Dictionary<MethodBase, byte[]>)field2.GetValue(null);
		originals = new Dictionary<MethodInfo, MethodBase>();
		if (field3 != null)
		{
			originals = (Dictionary<MethodInfo, MethodBase>)field3.GetValue(null);
		}
	}

	private static Type GetOrCreateSharedStateType()
	{
		Type type = Type.GetType("HarmonySharedState", throwOnError: false);
		if (type != null)
		{
			return type;
		}
		using ModuleDefinition moduleDefinition = ModuleDefinition.CreateModule("HarmonySharedState", new ModuleParameters
		{
			Kind = ModuleKind.Dll,
			ReflectionImporterProvider = MMReflectionImporter.Provider
		});
		Mono.Cecil.TypeAttributes attributes = Mono.Cecil.TypeAttributes.Public | Mono.Cecil.TypeAttributes.Abstract | Mono.Cecil.TypeAttributes.Sealed;
		TypeDefinition typeDefinition = new TypeDefinition("", "HarmonySharedState", attributes)
		{
			BaseType = moduleDefinition.TypeSystem.Object
		};
		moduleDefinition.Types.Add(typeDefinition);
		typeDefinition.Fields.Add(new FieldDefinition("state", Mono.Cecil.FieldAttributes.Public | Mono.Cecil.FieldAttributes.Static, moduleDefinition.ImportReference(typeof(Dictionary<MethodBase, byte[]>))));
		typeDefinition.Fields.Add(new FieldDefinition("originals", Mono.Cecil.FieldAttributes.Public | Mono.Cecil.FieldAttributes.Static, moduleDefinition.ImportReference(typeof(Dictionary<MethodInfo, MethodBase>))));
		typeDefinition.Fields.Add(new FieldDefinition("version", Mono.Cecil.FieldAttributes.Public | Mono.Cecil.FieldAttributes.Static, moduleDefinition.ImportReference(typeof(int))));
		return ReflectionHelper.Load(moduleDefinition).GetType("HarmonySharedState");
	}

	internal static PatchInfo GetPatchInfo(MethodBase method)
	{
		byte[] valueSafe;
		lock (state)
		{
			valueSafe = state.GetValueSafe(method);
		}
		if (valueSafe == null)
		{
			return null;
		}
		return PatchInfoSerialization.Deserialize(valueSafe);
	}

	internal static IEnumerable<MethodBase> GetPatchedMethods()
	{
		lock (state)
		{
			return state.Keys.ToArray();
		}
	}

	internal static void UpdatePatchInfo(MethodBase original, MethodInfo replacement, PatchInfo patchInfo)
	{
		byte[] value = patchInfo.Serialize();
		lock (state)
		{
			state[original] = value;
		}
		lock (originals)
		{
			originals[replacement] = original;
		}
	}

	internal static MethodBase GetOriginal(MethodInfo replacement)
	{
		lock (originals)
		{
			return originals.GetValueSafe(replacement);
		}
	}

	internal static MethodBase FindReplacement(StackFrame frame)
	{
		MethodInfo methodInfo = frame.GetMethod() as MethodInfo;
		if (methodInfo == null)
		{
			return null;
		}
		return GetOriginal(methodInfo);
	}
}


using System;
using System.Collections.Generic;
using System.Reflection.Emit;
using HarmonyLib;

internal class ILInstruction
{
	internal int offset;

	internal OpCode opcode;

	internal object operand;

	internal object argument;

	internal List<Label> labels = new List<Label>();

	internal List<ExceptionBlock> blocks = new List<ExceptionBlock>();

	internal ILInstruction(OpCode opcode, object operand = null)
	{
		this.opcode = opcode;
		this.operand = operand;
		argument = operand;
	}

	internal CodeInstruction GetCodeInstruction()
	{
		CodeInstruction codeInstruction = new CodeInstruction(opcode, argument);
		if (opcode.OperandType == OperandType.InlineNone)
		{
			codeInstruction.operand = null;
		}
		codeInstruction.labels = labels;
		codeInstruction.blocks = blocks;
		return codeInstruction;
	}

	internal int GetSize()
	{
		int num = opcode.Size;
		switch (opcode.OperandType)
		{
		case OperandType.InlineSwitch:
			num += (1 + ((Array)operand).Length) * 4;
			break;
		case OperandType.InlineI8:
		case OperandType.InlineR:
			num += 8;
			break;
		case OperandType.InlineBrTarget:
		case OperandType.InlineField:
		case OperandType.InlineI:
		case OperandType.InlineMethod:
		case OperandType.InlineSig:
		case OperandType.InlineString:
		case OperandType.InlineTok:
		case OperandType.InlineType:
		case OperandType.ShortInlineR:
			num += 4;
			break;
		case OperandType.InlineVar:
			num += 2;
			break;
		case OperandType.ShortInlineBrTarget:
		case OperandType.ShortInlineI:
		case OperandType.ShortInlineVar:
			num++;
			break;
		}
		return num;
	}

	public override string ToString()
	{
		string str = "";
		AppendLabel(ref str, this);
		str = str + ": " + opcode.Name;
		if (operand == null)
		{
			return str;
		}
		str += " ";
		switch (opcode.OperandType)
		{
		case OperandType.InlineBrTarget:
		case OperandType.ShortInlineBrTarget:
			AppendLabel(ref str, operand);
			break;
		case OperandType.InlineSwitch:
		{
			ILInstruction[] array = (ILInstruction[])operand;
			for (int i = 0; i < array.Length; i++)
			{
				if (i > 0)
				{
					str += ",";
				}
				AppendLabel(ref str, array[i]);
			}
			break;
		}
		case OperandType.InlineString:
			str += $"\"{operand}\"";
			break;
		default:
			str += operand;
			break;
		}
		return str;
	}

	private static void AppendLabel(ref string str, object argument)
	{
		ILInstruction iLInstruction = argument as ILInstruction;
		str += $"IL_{iLInstruction?.offset.ToString("X4") ?? argument}";
	}
}


using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using HarmonyLib;
using Mono.Cecil;

internal static class InlineSignatureParser
{
	internal static InlineSignature ImportCallSite(Module moduleFrom, byte[] data)
	{
		InlineSignature inlineSignature = new InlineSignature();
		BinaryReader reader;
		using (MemoryStream input = new MemoryStream(data, writable: false))
		{
			reader = new BinaryReader(input);
			try
			{
				ReadMethodSignature(inlineSignature);
				return inlineSignature;
			}
			finally
			{
				if (reader != null)
				{
					((IDisposable)reader).Dispose();
				}
			}
		}
		Type GetTypeDefOrRef()
		{
			uint num4 = ReadCompressedUInt32();
			uint num5 = num4 >> 2;
			return moduleFrom.ResolveType((num4 & 3) switch
			{
				0u => (int)(0x2000000 | num5), 
				1u => (int)(0x1000000 | num5), 
				2u => (int)(0x1B000000 | num5), 
				_ => 0, 
			});
		}
		int ReadCompressedInt32()
		{
			byte b3 = reader.ReadByte();
			reader.BaseStream.Seek(-1L, SeekOrigin.Current);
			int num6 = (int)ReadCompressedUInt32();
			int num7 = num6 >> 1;
			if ((num6 & 1) == 0)
			{
				return num7;
			}
			switch (b3 & 0xC0)
			{
			case 0:
			case 64:
				return num7 - 64;
			case 128:
				return num7 - 8192;
			default:
				return num7 - 268435456;
			}
		}
		uint ReadCompressedUInt32()
		{
			byte b2 = reader.ReadByte();
			if ((b2 & 0x80) == 0)
			{
				return b2;
			}
			if ((b2 & 0x40) == 0)
			{
				return (uint)(((b2 & -129) << 8) | reader.ReadByte());
			}
			return (uint)(((b2 & -193) << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | reader.ReadByte());
		}
		void ReadMethodSignature(InlineSignature method)
		{
			byte b = reader.ReadByte();
			if ((b & 0x20) != 0)
			{
				method.HasThis = true;
				b = (byte)(b & -33);
			}
			if ((b & 0x40) != 0)
			{
				method.ExplicitThis = true;
				b = (byte)(b & -65);
			}
			method.CallingConvention = (CallingConvention)(b + 1);
			if ((b & 0x10) != 0)
			{
				ReadCompressedUInt32();
			}
			uint num = ReadCompressedUInt32();
			method.ReturnType = ReadTypeSignature();
			for (int i = 0; i < num; i++)
			{
				method.Parameters.Add(ReadTypeSignature());
			}
		}
		object ReadTypeSignature()
		{
			MetadataType metadataType = (MetadataType)reader.ReadByte();
			switch (metadataType)
			{
			case MetadataType.ValueType:
			case MetadataType.Class:
				return GetTypeDefOrRef();
			case MetadataType.Pointer:
				return ((Type)ReadTypeSignature()).MakePointerType();
			case MetadataType.FunctionPointer:
			{
				InlineSignature inlineSignature2 = new InlineSignature();
				ReadMethodSignature(inlineSignature2);
				return inlineSignature2;
			}
			case MetadataType.ByReference:
				return ((Type)ReadTypeSignature()).MakePointerType();
			case (MetadataType)29:
				return ((Type)ReadTypeSignature()).MakeArrayType();
			case MetadataType.Array:
			{
				Type type2 = (Type)ReadTypeSignature();
				uint rank = ReadCompressedUInt32();
				uint num2 = ReadCompressedUInt32();
				for (int j = 0; j < num2; j++)
				{
					ReadCompressedUInt32();
				}
				uint num3 = ReadCompressedUInt32();
				for (int k = 0; k < num3; k++)
				{
					ReadCompressedInt32();
				}
				return type2.MakeArrayType((int)rank);
			}
			case MetadataType.OptionalModifier:
				return new InlineSignature.ModifierType
				{
					IsOptional = true,
					Modifier = GetTypeDefOrRef(),
					Type = ReadTypeSignature()
				};
			case MetadataType.RequiredModifier:
				return new InlineSignature.ModifierType
				{
					IsOptional = false,
					Modifier = GetTypeDefOrRef(),
					Type = ReadTypeSignature()
				};
			case MetadataType.Var:
			case MetadataType.MVar:
				throw new NotSupportedException($"Unsupported generic callsite element: {metadataType}");
			case MetadataType.GenericInstance:
			{
				reader.ReadByte();
				Type type = GetTypeDefOrRef();
				int count = (int)ReadCompressedUInt32();
				return type.MakeGenericType((from _ in Enumerable.Range(0, count)
					select (Type)ReadTypeSignature()).ToArray());
			}
			case MetadataType.Object:
				return typeof(object);
			case MetadataType.Void:
				return typeof(void);
			case MetadataType.TypedByReference:
				return typeof(TypedReference);
			case MetadataType.IntPtr:
				return typeof(IntPtr);
			case MetadataType.UIntPtr:
				return typeof(UIntPtr);
			case MetadataType.Boolean:
				return typeof(bool);
			case MetadataType.Char:
				return typeof(char);
			case MetadataType.SByte:
				return typeof(sbyte);
			case MetadataType.Byte:
				return typeof(byte);
			case MetadataType.Int16:
				return typeof(short);
			case MetadataType.UInt16:
				return typeof(ushort);
			case MetadataType.Int32:
				return typeof(int);
			case MetadataType.UInt32:
				return typeof(uint);
			case MetadataType.Int64:
				return typeof(long);
			case MetadataType.UInt64:
				return typeof(ulong);
			case MetadataType.Single:
				return typeof(float);
			case MetadataType.Double:
				return typeof(double);
			case MetadataType.String:
				return typeof(string);
			default:
				throw new NotSupportedException($"Unsupported callsite element: {metadataType}");
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

internal class MethodCopier
{
	private readonly MethodBodyReader reader;

	private readonly List<MethodInfo> transpilers = new List<MethodInfo>();

	internal MethodCopier(MethodBase fromMethod, ILGenerator toILGenerator, LocalBuilder[] existingVariables = null)
	{
		if ((object)fromMethod == null)
		{
			throw new ArgumentNullException("fromMethod");
		}
		reader = new MethodBodyReader(fromMethod, toILGenerator);
		reader.DeclareVariables(existingVariables);
		reader.GenerateInstructions();
	}

	internal void SetDebugging(bool debug)
	{
		reader.SetDebugging(debug);
	}

	internal void AddTranspiler(MethodInfo transpiler)
	{
		transpilers.Add(transpiler);
	}

	internal List<CodeInstruction> Finalize(Emitter emitter, List<Label> endLabels, out bool hasReturnCode, out bool methodEndsInDeadCode)
	{
		return reader.FinalizeILCodes(emitter, transpilers, endLabels, out hasReturnCode, out methodEndsInDeadCode);
	}

	internal static List<CodeInstruction> GetInstructions(ILGenerator generator, MethodBase method, int maxTranspilers)
	{
		if (generator == null)
		{
			throw new ArgumentNullException("generator");
		}
		if ((object)method == null)
		{
			throw new ArgumentNullException("method");
		}
		LocalBuilder[] existingVariables = MethodPatcher.DeclareOriginalLocalVariables(generator, method);
		MethodCopier methodCopier = new MethodCopier(method, generator, existingVariables);
		Patches patchInfo = Harmony.GetPatchInfo(method);
		if (patchInfo != null)
		{
			ReadOnlyCollection<Patch> readOnlyCollection = patchInfo.Transpilers;
			int num = 0;
			Patch[] array = new Patch[readOnlyCollection.Count];
			foreach (Patch item in readOnlyCollection)
			{
				array[num] = item;
				num++;
			}
			List<MethodInfo> sortedPatchMethods = PatchFunctions.GetSortedPatchMethods(method, array, debug: false);
			for (int i = 0; i < maxTranspilers && i < sortedPatchMethods.Count; i++)
			{
				methodCopier.AddTranspiler(sortedPatchMethods[i]);
			}
		}
		bool hasReturnCode;
		bool methodEndsInDeadCode;
		return methodCopier.Finalize(null, null, out hasReturnCode, out methodEndsInDeadCode);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HarmonyLib;
using MonoMod.Utils;
using MonoMod.Utils.Cil;

internal class MethodBodyReader
{
	private class ThisParameter : ParameterInfo
	{
		internal ThisParameter(MethodBase method)
		{
			MemberImpl = method;
			ClassImpl = method.DeclaringType;
			NameImpl = "this";
			PositionImpl = -1;
		}
	}

	private readonly ILGenerator generator;

	private readonly MethodBase method;

	private bool debug;

	private readonly Module module;

	private readonly Type[] typeArguments;

	private readonly Type[] methodArguments;

	private readonly ByteBuffer ilBytes;

	private readonly ParameterInfo this_parameter;

	private readonly ParameterInfo[] parameters;

	private readonly IList<ExceptionHandlingClause> exceptions;

	private readonly List<ILInstruction> ilInstructions;

	private readonly List<LocalVariableInfo> localVariables;

	private LocalBuilder[] variables;

	private static readonly Dictionary<OpCode, OpCode> shortJumps;

	private static readonly OpCode[] one_byte_opcodes;

	private static readonly OpCode[] two_bytes_opcodes;

	internal static List<ILInstruction> GetInstructions(ILGenerator generator, MethodBase method)
	{
		if ((object)method == null)
		{
			throw new ArgumentNullException("method");
		}
		MethodBodyReader methodBodyReader = new MethodBodyReader(method, generator);
		methodBodyReader.DeclareVariables(null);
		methodBodyReader.GenerateInstructions();
		return methodBodyReader.ilInstructions;
	}

	internal MethodBodyReader(MethodBase method, ILGenerator generator)
	{
		this.generator = generator;
		this.method = method;
		module = method.Module;
		MethodBody methodBody = method.GetMethodBody();
		if ((methodBody?.GetILAsByteArray()?.Length).GetValueOrDefault() == 0)
		{
			ilBytes = new ByteBuffer(Array.Empty<byte>());
			ilInstructions = new List<ILInstruction>();
		}
		else
		{
			byte[] iLAsByteArray = methodBody.GetILAsByteArray();
			if (iLAsByteArray == null)
			{
				throw new ArgumentException("Can not get IL bytes of method " + method.FullDescription());
			}
			ilBytes = new ByteBuffer(iLAsByteArray);
			ilInstructions = new List<ILInstruction>((iLAsByteArray.Length + 1) / 2);
		}
		Type declaringType = method.DeclaringType;
		if ((object)declaringType != null && declaringType.IsGenericType)
		{
			try
			{
				typeArguments = declaringType.GetGenericArguments();
			}
			catch
			{
				typeArguments = null;
			}
		}
		if (method.IsGenericMethod)
		{
			try
			{
				methodArguments = method.GetGenericArguments();
			}
			catch
			{
				methodArguments = null;
			}
		}
		if (!method.IsStatic)
		{
			this_parameter = new ThisParameter(method);
		}
		parameters = method.GetParameters();
		localVariables = methodBody?.LocalVariables?.ToList() ?? new List<LocalVariableInfo>();
		exceptions = methodBody?.ExceptionHandlingClauses ?? new List<ExceptionHandlingClause>();
	}

	internal void SetDebugging(bool debug)
	{
		this.debug = debug;
	}

	internal void GenerateInstructions()
	{
		while (ilBytes.position < ilBytes.buffer.Length)
		{
			int position = ilBytes.position;
			ILInstruction iLInstruction = new ILInstruction(ReadOpCode())
			{
				offset = position
			};
			ReadOperand(iLInstruction);
			ilInstructions.Add(iLInstruction);
		}
		HandleNativeMethod();
		ResolveBranches();
		ParseExceptions();
	}

	internal void HandleNativeMethod()
	{
		if (!(method is MethodInfo methodInfo))
		{
			return;
		}
		DllImportAttribute dllImportAttribute = methodInfo.GetCustomAttributes(inherit: false).OfType<DllImportAttribute>().FirstOrDefault();
		if (dllImportAttribute != null)
		{
			string assemblyName = (methodInfo.DeclaringType?.FullName ?? "").Replace(".", "_") + "_" + methodInfo.Name;
			AssemblyName assemblyName2 = new AssemblyName(assemblyName);
			AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName2, AssemblyBuilderAccess.Run);
			ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName2.Name);
			TypeBuilder typeBuilder = moduleBuilder.DefineType("NativeMethodHolder", TypeAttributes.Public | TypeAttributes.UnicodeClass);
			MethodBuilder methodBuilder = typeBuilder.DefinePInvokeMethod(methodInfo.Name, dllImportAttribute.Value, MethodAttributes.Public | MethodAttributes.Static | MethodAttributes.PinvokeImpl, CallingConventions.Standard, methodInfo.ReturnType, (from x in methodInfo.GetParameters()
				select x.ParameterType).ToArray(), dllImportAttribute.CallingConvention, dllImportAttribute.CharSet);
			methodBuilder.SetImplementationFlags(methodBuilder.GetMethodImplementationFlags() | MethodImplAttributes.PreserveSig);
			Type type = typeBuilder.CreateType();
			MethodInfo operand = type.GetMethod(methodInfo.Name);
			int num = method.GetParameters().Length;
			for (int i = 0; i < num; i++)
			{
				ilInstructions.Add(new ILInstruction(OpCodes.Ldarg, i)
				{
					offset = 0
				});
			}
			ilInstructions.Add(new ILInstruction(OpCodes.Call, operand)
			{
				offset = num
			});
			ilInstructions.Add(new ILInstruction(OpCodes.Ret)
			{
				offset = num + 5
			});
		}
	}

	internal void DeclareVariables(LocalBuilder[] existingVariables)
	{
		if (generator == null)
		{
			return;
		}
		if (existingVariables != null)
		{
			variables = existingVariables;
			return;
		}
		variables = localVariables.Select((LocalVariableInfo lvi) => generator.DeclareLocal(lvi.LocalType, lvi.IsPinned)).ToArray();
	}

	private void ResolveBranches()
	{
		foreach (ILInstruction ilInstruction in ilInstructions)
		{
			switch (ilInstruction.opcode.OperandType)
			{
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				ilInstruction.operand = GetInstruction((int)ilInstruction.operand, isEndOfInstruction: false);
				break;
			case OperandType.InlineSwitch:
			{
				int[] array = (int[])ilInstruction.operand;
				ILInstruction[] array2 = new ILInstruction[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array2[i] = GetInstruction(array[i], isEndOfInstruction: false);
				}
				ilInstruction.operand = array2;
				break;
			}
			}
		}
	}

	private void ParseExceptions()
	{
		foreach (ExceptionHandlingClause exception in exceptions)
		{
			int tryOffset = exception.TryOffset;
			int handlerOffset = exception.HandlerOffset;
			int offset = exception.HandlerOffset + exception.HandlerLength - 1;
			ILInstruction instruction = GetInstruction(tryOffset, isEndOfInstruction: false);
			instruction.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginExceptionBlock));
			ILInstruction instruction2 = GetInstruction(offset, isEndOfInstruction: true);
			instruction2.blocks.Add(new ExceptionBlock(ExceptionBlockType.EndExceptionBlock));
			switch (exception.Flags)
			{
			case ExceptionHandlingClauseOptions.Filter:
			{
				ILInstruction instruction6 = GetInstruction(exception.FilterOffset, isEndOfInstruction: false);
				instruction6.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginExceptFilterBlock));
				break;
			}
			case ExceptionHandlingClauseOptions.Finally:
			{
				ILInstruction instruction5 = GetInstruction(handlerOffset, isEndOfInstruction: false);
				instruction5.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginFinallyBlock));
				break;
			}
			case ExceptionHandlingClauseOptions.Clause:
			{
				ILInstruction instruction4 = GetInstruction(handlerOffset, isEndOfInstruction: false);
				instruction4.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginCatchBlock, exception.CatchType));
				break;
			}
			case ExceptionHandlingClauseOptions.Fault:
			{
				ILInstruction instruction3 = GetInstruction(handlerOffset, isEndOfInstruction: false);
				instruction3.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginFaultBlock));
				break;
			}
			}
		}
	}

	private bool EndsInDeadCode(List<CodeInstruction> list)
	{
		int count = list.Count;
		if (count < 2 || list.Last().opcode != OpCodes.Throw)
		{
			return false;
		}
		return list.GetRange(0, count - 1).All((CodeInstruction code) => code.opcode != OpCodes.Ret);
	}

	internal List<CodeInstruction> FinalizeILCodes(Emitter emitter, List<MethodInfo> transpilers, List<Label> endLabels, out bool hasReturnCode, out bool methodEndsInDeadCode)
	{
		hasReturnCode = false;
		methodEndsInDeadCode = false;
		if (generator == null)
		{
			return null;
		}
		foreach (ILInstruction ilInstruction in ilInstructions)
		{
			switch (ilInstruction.opcode.OperandType)
			{
			case OperandType.InlineSwitch:
				if (ilInstruction.operand is ILInstruction[] array)
				{
					List<Label> list = new List<Label>();
					ILInstruction[] array2 = array;
					foreach (ILInstruction iLInstruction2 in array2)
					{
						Label item = generator.DefineLabel();
						iLInstruction2.labels.Add(item);
						list.Add(item);
					}
					ilInstruction.argument = list.ToArray();
				}
				break;
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				if (ilInstruction.operand is ILInstruction iLInstruction)
				{
					Label label2 = generator.DefineLabel();
					iLInstruction.labels.Add(label2);
					ilInstruction.argument = label2;
				}
				break;
			}
		}
		CodeTranspiler codeTranspiler = new CodeTranspiler(ilInstructions);
		transpilers.Do(delegate(MethodInfo transpiler)
		{
			codeTranspiler.Add(transpiler);
		});
		List<CodeInstruction> result = codeTranspiler.GetResult(generator, method);
		if (emitter == null)
		{
			return result;
		}
		emitter.LogComment("start original");
		if (debug)
		{
			List<string> buffer = FileLog.GetBuffer(clear: true);
			emitter.LogAllLocalVariables();
			FileLog.LogBuffered(buffer);
		}
		hasReturnCode = result.Any((CodeInstruction code) => code.opcode == OpCodes.Ret);
		methodEndsInDeadCode = EndsInDeadCode(result);
		while (true)
		{
			CodeInstruction codeInstruction2 = result.LastOrDefault();
			if (codeInstruction2 == null || codeInstruction2.opcode != OpCodes.Ret)
			{
				break;
			}
			endLabels.AddRange(codeInstruction2.labels);
			result.RemoveAt(result.Count - 1);
		}
		result.Do(delegate(CodeInstruction codeInstruction)
		{
			codeInstruction.labels.Do(delegate(Label label)
			{
				emitter.MarkLabel(label);
			});
			codeInstruction.blocks.Do(delegate(ExceptionBlock block)
			{
				emitter.MarkBlockBefore(block, out var _);
			});
			OpCode opCode = codeInstruction.opcode;
			object obj = codeInstruction.operand;
			if (opCode == OpCodes.Ret)
			{
				Label label4 = generator.DefineLabel();
				opCode = OpCodes.Br;
				obj = label4;
				endLabels.Add(label4);
			}
			if (shortJumps.TryGetValue(opCode, out var value))
			{
				opCode = value;
			}
			switch (opCode.OperandType)
			{
			case OperandType.InlineNone:
				emitter.Emit(opCode);
				break;
			case OperandType.InlineSig:
			{
				CecilILGenerator proxiedShim = generator.GetProxiedShim<CecilILGenerator>();
				if (proxiedShim == null)
				{
					throw new NotSupportedException();
				}
				if (obj == null)
				{
					throw new Exception($"Wrong null argument: {codeInstruction}");
				}
				if (!(obj is ICallSiteGenerator))
				{
					throw new Exception($"Wrong Emit argument type {obj.GetType()} in {codeInstruction}");
				}
				emitter.AddInstruction(opCode, obj);
				emitter.LogIL(opCode, obj);
				proxiedShim.Emit(opCode, (ICallSiteGenerator)obj);
				break;
			}
			default:
				if (obj == null)
				{
					throw new Exception($"Wrong null argument: {codeInstruction}");
				}
				emitter.AddInstruction(opCode, obj);
				emitter.LogIL(opCode, obj);
				generator.DynEmit(opCode, obj);
				break;
			}
			codeInstruction.blocks.Do(delegate(ExceptionBlock block)
			{
				emitter.MarkBlockAfter(block);
			});
		});
		emitter.LogComment("end original" + (methodEndsInDeadCode ? " (has dead code end)" : ""));
		return result;
	}

	private static void GetMemberInfoValue(MemberInfo info, out object result)
	{
		result = null;
		switch (info.MemberType)
		{
		case MemberTypes.Constructor:
			result = (ConstructorInfo)info;
			break;
		case MemberTypes.Event:
			result = (EventInfo)info;
			break;
		case MemberTypes.Field:
			result = (FieldInfo)info;
			break;
		case MemberTypes.Method:
			result = (MethodInfo)info;
			break;
		case MemberTypes.TypeInfo:
		case MemberTypes.NestedType:
			result = (Type)info;
			break;
		case MemberTypes.Property:
			result = (PropertyInfo)info;
			break;
		}
	}

	private void ReadOperand(ILInstruction instruction)
	{
		switch (instruction.opcode.OperandType)
		{
		case OperandType.InlineNone:
			instruction.argument = null;
			break;
		case OperandType.InlineSwitch:
		{
			int num3 = ilBytes.ReadInt32();
			int num4 = ilBytes.position + 4 * num3;
			int[] array2 = new int[num3];
			for (int i = 0; i < num3; i++)
			{
				array2[i] = ilBytes.ReadInt32() + num4;
			}
			instruction.operand = array2;
			break;
		}
		case OperandType.ShortInlineBrTarget:
		{
			sbyte b2 = (sbyte)ilBytes.ReadByte();
			instruction.operand = b2 + ilBytes.position;
			break;
		}
		case OperandType.InlineBrTarget:
		{
			int num5 = ilBytes.ReadInt32();
			instruction.operand = num5 + ilBytes.position;
			break;
		}
		case OperandType.ShortInlineI:
			if (instruction.opcode == OpCodes.Ldc_I4_S)
			{
				sbyte b4 = (sbyte)ilBytes.ReadByte();
				instruction.operand = b4;
				instruction.argument = (sbyte)instruction.operand;
			}
			else
			{
				byte b5 = ilBytes.ReadByte();
				instruction.operand = b5;
				instruction.argument = (byte)instruction.operand;
			}
			break;
		case OperandType.InlineI:
		{
			int num8 = ilBytes.ReadInt32();
			instruction.operand = num8;
			instruction.argument = (int)instruction.operand;
			break;
		}
		case OperandType.ShortInlineR:
		{
			float num2 = ilBytes.ReadSingle();
			instruction.operand = num2;
			instruction.argument = (float)instruction.operand;
			break;
		}
		case OperandType.InlineR:
		{
			double num7 = ilBytes.ReadDouble();
			instruction.operand = num7;
			instruction.argument = (double)instruction.operand;
			break;
		}
		case OperandType.InlineI8:
		{
			long num6 = ilBytes.ReadInt64();
			instruction.operand = num6;
			instruction.argument = (long)instruction.operand;
			break;
		}
		case OperandType.InlineSig:
		{
			int metadataToken3 = ilBytes.ReadInt32();
			byte[] array3 = module.ResolveSignature(metadataToken3);
			InlineSignature value = (InlineSignature)(instruction.argument = (instruction.operand = InlineSignatureParser.ImportCallSite(module, array3)));
			Debugger.Log(0, "TEST", "METHOD " + method.FullDescription() + "\n");
			Debugger.Log(0, "TEST", "Signature Blob = " + array3.Select((byte b) => $"0x{b:x02}").Aggregate((string a, string b) => a + " " + b) + "\n");
			Debugger.Log(0, "TEST", $"Signature = {value}\n");
			Debugger.Break();
			break;
		}
		case OperandType.InlineString:
		{
			int metadataToken6 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveString(metadataToken6);
			instruction.argument = (string)instruction.operand;
			break;
		}
		case OperandType.InlineTok:
		{
			int metadataToken5 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveMember(metadataToken5, typeArguments, methodArguments);
			((MemberInfo)instruction.operand).DeclaringType?.FixReflectionCacheAuto();
			GetMemberInfoValue((MemberInfo)instruction.operand, out instruction.argument);
			break;
		}
		case OperandType.InlineType:
		{
			int metadataToken4 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveType(metadataToken4, typeArguments, methodArguments);
			((Type)instruction.operand).FixReflectionCacheAuto();
			instruction.argument = (Type)instruction.operand;
			break;
		}
		case OperandType.InlineMethod:
		{
			int metadataToken2 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveMethod(metadataToken2, typeArguments, methodArguments);
			((MemberInfo)instruction.operand).DeclaringType?.FixReflectionCacheAuto();
			if (instruction.operand is ConstructorInfo)
			{
				instruction.argument = (ConstructorInfo)instruction.operand;
			}
			else
			{
				instruction.argument = (MethodInfo)instruction.operand;
			}
			break;
		}
		case OperandType.InlineField:
		{
			int metadataToken = ilBytes.ReadInt32();
			instruction.operand = module.ResolveField(metadataToken, typeArguments, methodArguments);
			((MemberInfo)instruction.operand).DeclaringType?.FixReflectionCacheAuto();
			instruction.argument = (FieldInfo)instruction.operand;
			break;
		}
		case OperandType.ShortInlineVar:
		{
			byte b3 = ilBytes.ReadByte();
			if (TargetsLocalVariable(instruction.opcode))
			{
				LocalVariableInfo localVariable2 = GetLocalVariable(b3);
				if (localVariable2 == null)
				{
					instruction.argument = b3;
					break;
				}
				instruction.operand = localVariable2;
				LocalBuilder[] array4 = variables;
				instruction.argument = ((array4 != null) ? array4[localVariable2.LocalIndex] : null) ?? localVariable2;
			}
			else
			{
				instruction.operand = GetParameter(b3);
				instruction.argument = b3;
			}
			break;
		}
		case OperandType.InlineVar:
		{
			short num = ilBytes.ReadInt16();
			if (TargetsLocalVariable(instruction.opcode))
			{
				LocalVariableInfo localVariable = GetLocalVariable(num);
				if (localVariable == null)
				{
					instruction.argument = num;
					break;
				}
				instruction.operand = localVariable;
				LocalBuilder[] array = variables;
				instruction.argument = ((array != null) ? array[localVariable.LocalIndex] : null) ?? localVariable;
			}
			else
			{
				instruction.operand = GetParameter(num);
				instruction.argument = num;
			}
			break;
		}
		default:
			throw new NotSupportedException();
		}
	}

	private ILInstruction GetInstruction(int offset, bool isEndOfInstruction)
	{
		if (offset < 0)
		{
			throw new ArgumentOutOfRangeException("offset", offset, $"Instruction offset {offset} is less than 0");
		}
		int num = ilInstructions.Count - 1;
		ILInstruction iLInstruction = ilInstructions[num];
		if (offset > iLInstruction.offset + iLInstruction.GetSize() - 1)
		{
			throw new ArgumentOutOfRangeException("offset", offset, $"Instruction offset {offset} is outside valid range 0 - {iLInstruction.offset + iLInstruction.GetSize() - 1}");
		}
		int num2 = 0;
		int num3 = num;
		while (num2 <= num3)
		{
			int num4 = num2 + (num3 - num2) / 2;
			iLInstruction = ilInstructions[num4];
			if (isEndOfInstruction)
			{
				if (offset == iLInstruction.offset + iLInstruction.GetSize() - 1)
				{
					return iLInstruction;
				}
			}
			else if (offset == iLInstruction.offset)
			{
				return iLInstruction;
			}
			if (offset < iLInstruction.offset)
			{
				num3 = num4 - 1;
			}
			else
			{
				num2 = num4 + 1;
			}
		}
		throw new Exception($"Cannot find instruction for {offset:X4}");
	}

	private static bool TargetsLocalVariable(OpCode opcode)
	{
		return opcode.Name.Contains("loc");
	}

	private LocalVariableInfo GetLocalVariable(int index)
	{
		return localVariables?[index];
	}

	private ParameterInfo GetParameter(int index)
	{
		if (index == 0)
		{
			return this_parameter;
		}
		return parameters[index - 1];
	}

	private OpCode ReadOpCode()
	{
		byte b = ilBytes.ReadByte();
		if (b == 254)
		{
			return two_bytes_opcodes[ilBytes.ReadByte()];
		}
		return one_byte_opcodes[b];
	}

	[MethodImpl(MethodImplOptions.Synchronized)]
	static MethodBodyReader()
	{
		shortJumps = new Dictionary<OpCode, OpCode>
		{
			{
				OpCodes.Leave_S,
				OpCodes.Leave
			},
			{
				OpCodes.Brfalse_S,
				OpCodes.Brfalse
			},
			{
				OpCodes.Brtrue_S,
				OpCodes.Brtrue
			},
			{
				OpCodes.Beq_S,
				OpCodes.Beq
			},
			{
				OpCodes.Bge_S,
				OpCodes.Bge
			},
			{
				OpCodes.Bgt_S,
				OpCodes.Bgt
			},
			{
				OpCodes.Ble_S,
				OpCodes.Ble
			},
			{
				OpCodes.Blt_S,
				OpCodes.Blt
			},
			{
				OpCodes.Bne_Un_S,
				OpCodes.Bne_Un
			},
			{
				OpCodes.Bge_Un_S,
				OpCodes.Bge_Un
			},
			{
				OpCodes.Bgt_Un_S,
				OpCodes.Bgt_Un
			},
			{
				OpCodes.Ble_Un_S,
				OpCodes.Ble_Un
			},
			{
				OpCodes.Br_S,
				OpCodes.Br
			},
			{
				OpCodes.Blt_Un_S,
				OpCodes.Blt_Un
			}
		};
		one_byte_opcodes = new OpCode[225];
		two_bytes_opcodes = new OpCode[31];
		FieldInfo[] fields = typeof(OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public);
		FieldInfo[] array = fields;
		foreach (FieldInfo fieldInfo in array)
		{
			OpCode opCode = (OpCode)fieldInfo.GetValue(null);
			if (opCode.OpCodeType != OpCodeType.Nternal)
			{
				if (opCode.Size == 1)
				{
					one_byte_opcodes[opCode.Value] = opCode;
				}
				else
				{
					two_bytes_opcodes[opCode.Value & 0xFF] = opCode;
				}
			}
		}
	}
}


using System.Reflection;

private class ThisParameter : ParameterInfo
{
	internal ThisParameter(MethodBase method)
	{
		MemberImpl = method;
		ClassImpl = method.DeclaringType;
		NameImpl = "this";
		PositionImpl = -1;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using Mono.Cecil;
using MonoMod.Utils;

internal class MethodPatcher
{
	private const string INSTANCE_PARAM = "__instance";

	private const string ORIGINAL_METHOD_PARAM = "__originalMethod";

	private const string ARGS_ARRAY_VAR = "__args";

	private const string RESULT_VAR = "__result";

	private const string RESULT_REF_VAR = "__resultRef";

	private const string STATE_VAR = "__state";

	private const string EXCEPTION_VAR = "__exception";

	private const string RUN_ORIGINAL_VAR = "__runOriginal";

	private const string PARAM_INDEX_PREFIX = "__";

	private const string INSTANCE_FIELD_PREFIX = "___";

	private readonly bool debug;

	private readonly MethodBase original;

	private readonly MethodBase source;

	private readonly List<MethodInfo> prefixes;

	private readonly List<MethodInfo> postfixes;

	private readonly List<MethodInfo> transpilers;

	private readonly List<MethodInfo> finalizers;

	private readonly int idx;

	private readonly Type returnType;

	private readonly DynamicMethodDefinition patch;

	private readonly ILGenerator il;

	private readonly Emitter emitter;

	private static readonly MethodInfo m_GetMethodFromHandle1 = typeof(MethodBase).GetMethod("GetMethodFromHandle", new Type[1] { typeof(RuntimeMethodHandle) });

	private static readonly MethodInfo m_GetMethodFromHandle2 = typeof(MethodBase).GetMethod("GetMethodFromHandle", new Type[2]
	{
		typeof(RuntimeMethodHandle),
		typeof(RuntimeTypeHandle)
	});

	internal MethodPatcher(MethodBase original, MethodBase source, List<MethodInfo> prefixes, List<MethodInfo> postfixes, List<MethodInfo> transpilers, List<MethodInfo> finalizers, bool debug)
	{
		if ((object)original == null)
		{
			throw new ArgumentNullException("original");
		}
		this.debug = debug;
		this.original = original;
		this.source = source;
		this.prefixes = prefixes;
		this.postfixes = postfixes;
		this.transpilers = transpilers;
		this.finalizers = finalizers;
		if (debug)
		{
			FileLog.LogBuffered("### Patch: " + original.FullDescription());
			FileLog.FlushBuffer();
		}
		idx = prefixes.Count + postfixes.Count + finalizers.Count;
		returnType = AccessTools.GetReturnedType(original);
		patch = CreateDynamicMethod(original, $"_Patch{idx}", debug);
		if (patch == null)
		{
			throw new Exception("Could not create replacement method");
		}
		il = patch.GetILGenerator();
		emitter = new Emitter(il, debug);
	}

	internal MethodInfo CreateReplacement(out Dictionary<int, CodeInstruction> finalInstructions)
	{
		LocalBuilder[] existingVariables = DeclareOriginalLocalVariables(il, source ?? original);
		Dictionary<string, LocalBuilder> privateVars = new Dictionary<string, LocalBuilder>();
		List<MethodInfo> list = prefixes.Union(postfixes).Union(finalizers).ToList();
		LocalBuilder localBuilder = null;
		if (idx > 0)
		{
			localBuilder = DeclareLocalVariable(returnType, isReturnValue: true);
			privateVars["__result"] = localBuilder;
		}
		if (list.Any((MethodInfo fix) => fix.GetParameters().Any((ParameterInfo p) => p.Name == "__resultRef")) && returnType.IsByRef)
		{
			LocalBuilder localBuilder2 = il.DeclareLocal(typeof(RefResult<>).MakeGenericType(returnType.GetElementType()));
			emitter.Emit(OpCodes.Ldnull);
			emitter.Emit(OpCodes.Stloc, localBuilder2);
			privateVars["__resultRef"] = localBuilder2;
		}
		LocalBuilder localBuilder3 = null;
		if (list.Any((MethodInfo fix) => fix.GetParameters().Any((ParameterInfo p) => p.Name == "__args")))
		{
			PrepareArgumentArray();
			localBuilder3 = il.DeclareLocal(typeof(object[]));
			emitter.Emit(OpCodes.Stloc, localBuilder3);
			privateVars["__args"] = localBuilder3;
		}
		Label? label = null;
		LocalBuilder localBuilder4 = null;
		bool flag = prefixes.Any((MethodInfo fix) => PrefixAffectsOriginal(fix));
		bool flag2 = list.Any((MethodInfo fix) => fix.GetParameters().Any((ParameterInfo p) => p.Name == "__runOriginal"));
		if (flag || flag2)
		{
			localBuilder4 = DeclareLocalVariable(typeof(bool));
			emitter.Emit(OpCodes.Ldc_I4_1);
			emitter.Emit(OpCodes.Stloc, localBuilder4);
			if (flag)
			{
				label = il.DefineLabel();
			}
		}
		list.ForEach(delegate(MethodInfo fix)
		{
			if ((object)fix.DeclaringType != null && !privateVars.ContainsKey(fix.DeclaringType.AssemblyQualifiedName))
			{
				(from patchParam in fix.GetParameters()
					where patchParam.Name == "__state"
					select patchParam).Do(delegate(ParameterInfo patchParam)
				{
					LocalBuilder value = DeclareLocalVariable(patchParam.ParameterType);
					privateVars[fix.DeclaringType.AssemblyQualifiedName] = value;
				});
			}
		});
		LocalBuilder local = null;
		if (finalizers.Count > 0)
		{
			local = DeclareLocalVariable(typeof(bool));
			privateVars["__exception"] = DeclareLocalVariable(typeof(Exception));
			emitter.MarkBlockBefore(new ExceptionBlock(ExceptionBlockType.BeginExceptionBlock), out var _);
		}
		AddPrefixes(privateVars, localBuilder4);
		if (label.HasValue)
		{
			emitter.Emit(OpCodes.Ldloc, localBuilder4);
			emitter.Emit(OpCodes.Brfalse, label.Value);
		}
		MethodCopier methodCopier = new MethodCopier(source ?? original, il, existingVariables);
		methodCopier.SetDebugging(debug);
		foreach (MethodInfo transpiler in transpilers)
		{
			methodCopier.AddTranspiler(transpiler);
		}
		methodCopier.AddTranspiler(PatchTools.m_GetExecutingAssemblyReplacementTranspiler);
		List<Label> list2 = new List<Label>();
		methodCopier.Finalize(emitter, list2, out var hasReturnCode, out var methodEndsInDeadCode);
		foreach (Label item in list2)
		{
			emitter.MarkLabel(item);
		}
		if (localBuilder != null && hasReturnCode)
		{
			emitter.Emit(OpCodes.Stloc, localBuilder);
		}
		if (label.HasValue)
		{
			emitter.MarkLabel(label.Value);
		}
		AddPostfixes(privateVars, localBuilder4, passthroughPatches: false);
		if (localBuilder != null && (hasReturnCode || (methodEndsInDeadCode && label.HasValue)))
		{
			emitter.Emit(OpCodes.Ldloc, localBuilder);
		}
		bool flag3 = AddPostfixes(privateVars, localBuilder4, passthroughPatches: true);
		bool flag4 = finalizers.Count > 0;
		if (flag4)
		{
			if (flag3)
			{
				emitter.Emit(OpCodes.Stloc, localBuilder);
				emitter.Emit(OpCodes.Ldloc, localBuilder);
			}
			AddFinalizers(privateVars, localBuilder4, catchExceptions: false);
			emitter.Emit(OpCodes.Ldc_I4_1);
			emitter.Emit(OpCodes.Stloc, local);
			Label label3 = il.DefineLabel();
			emitter.Emit(OpCodes.Ldloc, privateVars["__exception"]);
			emitter.Emit(OpCodes.Brfalse, label3);
			emitter.Emit(OpCodes.Ldloc, privateVars["__exception"]);
			emitter.Emit(OpCodes.Throw);
			emitter.MarkLabel(label3);
			emitter.MarkBlockBefore(new ExceptionBlock(ExceptionBlockType.BeginCatchBlock), out var _);
			emitter.Emit(OpCodes.Stloc, privateVars["__exception"]);
			emitter.Emit(OpCodes.Ldloc, local);
			Label label5 = il.DefineLabel();
			emitter.Emit(OpCodes.Brtrue, label5);
			bool flag5 = AddFinalizers(privateVars, localBuilder4, catchExceptions: true);
			emitter.MarkLabel(label5);
			Label label6 = il.DefineLabel();
			emitter.Emit(OpCodes.Ldloc, privateVars["__exception"]);
			emitter.Emit(OpCodes.Brfalse, label6);
			if (flag5)
			{
				emitter.Emit(OpCodes.Rethrow);
			}
			else
			{
				emitter.Emit(OpCodes.Ldloc, privateVars["__exception"]);
				emitter.Emit(OpCodes.Throw);
			}
			emitter.MarkLabel(label6);
			emitter.MarkBlockAfter(new ExceptionBlock(ExceptionBlockType.EndExceptionBlock));
			if (localBuilder != null)
			{
				emitter.Emit(OpCodes.Ldloc, localBuilder);
			}
		}
		if (!methodEndsInDeadCode || label.HasValue || flag4 || postfixes.Count > 0)
		{
			emitter.Emit(OpCodes.Ret);
		}
		finalInstructions = emitter.GetInstructions();
		if (debug)
		{
			FileLog.LogBuffered("DONE");
			FileLog.LogBuffered("");
			FileLog.FlushBuffer();
		}
		return patch.Generate();
	}

	internal static DynamicMethodDefinition CreateDynamicMethod(MethodBase original, string suffix, bool debug)
	{
		if ((object)original == null)
		{
			throw new ArgumentNullException("original");
		}
		string text = (original.DeclaringType?.FullName ?? "GLOBALTYPE") + "." + original.Name + suffix;
		text = text.Replace("<>", "");
		ParameterInfo[] parameters = original.GetParameters();
		List<Type> list = new List<Type>();
		list.AddRange(parameters.Types());
		if (!original.IsStatic)
		{
			if (AccessTools.IsStruct(original.DeclaringType))
			{
				list.Insert(0, original.DeclaringType.MakeByRefType());
			}
			else
			{
				list.Insert(0, original.DeclaringType);
			}
		}
		Type returnedType = AccessTools.GetReturnedType(original);
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(text, returnedType, list.ToArray());
		int num = ((!original.IsStatic) ? 1 : 0);
		if (!original.IsStatic)
		{
			dynamicMethodDefinition.Definition.Parameters[0].Name = "this";
		}
		for (int i = 0; i < parameters.Length; i++)
		{
			ParameterDefinition parameterDefinition = dynamicMethodDefinition.Definition.Parameters[i + num];
			parameterDefinition.Attributes = (Mono.Cecil.ParameterAttributes)parameters[i].Attributes;
			parameterDefinition.Name = parameters[i].Name;
		}
		if (debug)
		{
			List<string> list2 = list.Select((Type p) => p.FullDescription()).ToList();
			if (list.Count == dynamicMethodDefinition.Definition.Parameters.Count)
			{
				for (int j = 0; j < list.Count; j++)
				{
					List<string> list3 = list2;
					int index = j;
					list3[index] = list3[index] + " " + dynamicMethodDefinition.Definition.Parameters[j].Name;
				}
			}
			FileLog.Log($"### Replacement: static {returnedType.FullDescription()} {original.DeclaringType?.FullName ?? "GLOBALTYPE"}::{text}({list2.Join()})");
		}
		return dynamicMethodDefinition;
	}

	internal static LocalBuilder[] DeclareOriginalLocalVariables(ILGenerator il, MethodBase member)
	{
		IList<LocalVariableInfo> list = member.GetMethodBody()?.LocalVariables;
		if (list == null)
		{
			return Array.Empty<LocalBuilder>();
		}
		return list.Select((LocalVariableInfo lvi) => il.DeclareLocal(lvi.LocalType, lvi.IsPinned)).ToArray();
	}

	private LocalBuilder DeclareLocalVariable(Type type, bool isReturnValue = false)
	{
		if (type.IsByRef)
		{
			if (isReturnValue)
			{
				LocalBuilder localBuilder = il.DeclareLocal(type);
				emitter.Emit(OpCodes.Ldc_I4_1);
				emitter.Emit(OpCodes.Newarr, type.GetElementType());
				emitter.Emit(OpCodes.Ldc_I4_0);
				emitter.Emit(OpCodes.Ldelema, type.GetElementType());
				emitter.Emit(OpCodes.Stloc, localBuilder);
				return localBuilder;
			}
			type = type.GetElementType();
		}
		if (type.IsEnum)
		{
			type = Enum.GetUnderlyingType(type);
		}
		if (AccessTools.IsClass(type))
		{
			LocalBuilder localBuilder2 = il.DeclareLocal(type);
			emitter.Emit(OpCodes.Ldnull);
			emitter.Emit(OpCodes.Stloc, localBuilder2);
			return localBuilder2;
		}
		if (AccessTools.IsStruct(type))
		{
			LocalBuilder localBuilder3 = il.DeclareLocal(type);
			emitter.Emit(OpCodes.Ldloca, localBuilder3);
			emitter.Emit(OpCodes.Initobj, type);
			return localBuilder3;
		}
		if (AccessTools.IsValue(type))
		{
			LocalBuilder localBuilder4 = il.DeclareLocal(type);
			if (type == typeof(float))
			{
				emitter.Emit(OpCodes.Ldc_R4, 0f);
			}
			else if (type == typeof(double))
			{
				emitter.Emit(OpCodes.Ldc_R8, 0.0);
			}
			else if (type == typeof(long) || type == typeof(ulong))
			{
				emitter.Emit(OpCodes.Ldc_I8, 0L);
			}
			else
			{
				emitter.Emit(OpCodes.Ldc_I4, 0);
			}
			emitter.Emit(OpCodes.Stloc, localBuilder4);
			return localBuilder4;
		}
		return null;
	}

	private static OpCode LoadIndOpCodeFor(Type type)
	{
		if (type.IsEnum)
		{
			return OpCodes.Ldind_I4;
		}
		if (type == typeof(float))
		{
			return OpCodes.Ldind_R4;
		}
		if (type == typeof(double))
		{
			return OpCodes.Ldind_R8;
		}
		if (type == typeof(byte))
		{
			return OpCodes.Ldind_U1;
		}
		if (type == typeof(ushort))
		{
			return OpCodes.Ldind_U2;
		}
		if (type == typeof(uint))
		{
			return OpCodes.Ldind_U4;
		}
		if (type == typeof(ulong))
		{
			return OpCodes.Ldind_I8;
		}
		if (type == typeof(sbyte))
		{
			return OpCodes.Ldind_I1;
		}
		if (type == typeof(short))
		{
			return OpCodes.Ldind_I2;
		}
		if (type == typeof(int))
		{
			return OpCodes.Ldind_I4;
		}
		if (type == typeof(long))
		{
			return OpCodes.Ldind_I8;
		}
		return OpCodes.Ldind_Ref;
	}

	private static OpCode StoreIndOpCodeFor(Type type)
	{
		if (type.IsEnum)
		{
			return OpCodes.Stind_I4;
		}
		if (type == typeof(float))
		{
			return OpCodes.Stind_R4;
		}
		if (type == typeof(double))
		{
			return OpCodes.Stind_R8;
		}
		if (type == typeof(byte))
		{
			return OpCodes.Stind_I1;
		}
		if (type == typeof(ushort))
		{
			return OpCodes.Stind_I2;
		}
		if (type == typeof(uint))
		{
			return OpCodes.Stind_I4;
		}
		if (type == typeof(ulong))
		{
			return OpCodes.Stind_I8;
		}
		if (type == typeof(sbyte))
		{
			return OpCodes.Stind_I1;
		}
		if (type == typeof(short))
		{
			return OpCodes.Stind_I2;
		}
		if (type == typeof(int))
		{
			return OpCodes.Stind_I4;
		}
		if (type == typeof(long))
		{
			return OpCodes.Stind_I8;
		}
		return OpCodes.Stind_Ref;
	}

	private void InitializeOutParameter(int argIndex, Type type)
	{
		if (type.IsByRef)
		{
			type = type.GetElementType();
		}
		emitter.Emit(OpCodes.Ldarg, argIndex);
		if (AccessTools.IsStruct(type))
		{
			emitter.Emit(OpCodes.Initobj, type);
		}
		else if (AccessTools.IsValue(type))
		{
			if (type == typeof(float))
			{
				emitter.Emit(OpCodes.Ldc_R4, 0f);
				emitter.Emit(OpCodes.Stind_R4);
			}
			else if (type == typeof(double))
			{
				emitter.Emit(OpCodes.Ldc_R8, 0.0);
				emitter.Emit(OpCodes.Stind_R8);
			}
			else if (type == typeof(long))
			{
				emitter.Emit(OpCodes.Ldc_I8, 0L);
				emitter.Emit(OpCodes.Stind_I8);
			}
			else
			{
				emitter.Emit(OpCodes.Ldc_I4, 0);
				emitter.Emit(OpCodes.Stind_I4);
			}
		}
		else
		{
			emitter.Emit(OpCodes.Ldnull);
			emitter.Emit(OpCodes.Stind_Ref);
		}
	}

	private bool EmitOriginalBaseMethod()
	{
		if (original is MethodInfo meth)
		{
			emitter.Emit(OpCodes.Ldtoken, meth);
		}
		else
		{
			if (!(original is ConstructorInfo con))
			{
				return false;
			}
			emitter.Emit(OpCodes.Ldtoken, con);
		}
		Type reflectedType = original.ReflectedType;
		if (reflectedType.IsGenericType)
		{
			emitter.Emit(OpCodes.Ldtoken, reflectedType);
		}
		emitter.Emit(OpCodes.Call, reflectedType.IsGenericType ? m_GetMethodFromHandle2 : m_GetMethodFromHandle1);
		return true;
	}

	private void EmitCallParameter(MethodInfo patch, Dictionary<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool allowFirsParamPassthrough, out LocalBuilder tmpInstanceBoxingVar, out LocalBuilder tmpObjectVar, out bool refResultUsed, List<KeyValuePair<LocalBuilder, Type>> tmpBoxVars)
	{
		tmpInstanceBoxingVar = null;
		tmpObjectVar = null;
		refResultUsed = false;
		bool flag = !original.IsStatic;
		ParameterInfo[] parameters = original.GetParameters();
		string[] originalParameterNames = parameters.Select((ParameterInfo p) => p.Name).ToArray();
		Type declaringType = original.DeclaringType;
		List<ParameterInfo> list = patch.GetParameters().ToList();
		if (allowFirsParamPassthrough && patch.ReturnType != typeof(void) && list.Count > 0 && list[0].ParameterType == patch.ReturnType)
		{
			list.RemoveRange(0, 1);
		}
		foreach (ParameterInfo item in list)
		{
			if (item.Name == "__originalMethod")
			{
				if (!EmitOriginalBaseMethod())
				{
					emitter.Emit(OpCodes.Ldnull);
				}
				continue;
			}
			if (item.Name == "__runOriginal")
			{
				if (runOriginalVariable != null)
				{
					emitter.Emit(OpCodes.Ldloc, runOriginalVariable);
				}
				else
				{
					emitter.Emit(OpCodes.Ldc_I4_0);
				}
				continue;
			}
			if (item.Name == "__instance")
			{
				if (original.IsStatic)
				{
					emitter.Emit(OpCodes.Ldnull);
					continue;
				}
				Type parameterType = item.ParameterType;
				bool isByRef = parameterType.IsByRef;
				bool flag2 = parameterType == typeof(object) || parameterType == typeof(object).MakeByRefType();
				if (AccessTools.IsStruct(declaringType))
				{
					if (flag2)
					{
						if (isByRef)
						{
							emitter.Emit(OpCodes.Ldarg_0);
							emitter.Emit(OpCodes.Ldobj, declaringType);
							emitter.Emit(OpCodes.Box, declaringType);
							tmpInstanceBoxingVar = il.DeclareLocal(typeof(object));
							emitter.Emit(OpCodes.Stloc, tmpInstanceBoxingVar);
							emitter.Emit(OpCodes.Ldloca, tmpInstanceBoxingVar);
						}
						else
						{
							emitter.Emit(OpCodes.Ldarg_0);
							emitter.Emit(OpCodes.Ldobj, declaringType);
							emitter.Emit(OpCodes.Box, declaringType);
						}
					}
					else if (isByRef)
					{
						emitter.Emit(OpCodes.Ldarg_0);
					}
					else
					{
						emitter.Emit(OpCodes.Ldarg_0);
						emitter.Emit(OpCodes.Ldobj, declaringType);
					}
				}
				else if (isByRef)
				{
					emitter.Emit(OpCodes.Ldarga, 0);
				}
				else
				{
					emitter.Emit(OpCodes.Ldarg_0);
				}
				continue;
			}
			if (item.Name == "__args")
			{
				if (variables.TryGetValue("__args", out var value))
				{
					emitter.Emit(OpCodes.Ldloc, value);
				}
				else
				{
					emitter.Emit(OpCodes.Ldnull);
				}
				continue;
			}
			if (item.Name.StartsWith("___", StringComparison.Ordinal))
			{
				string text = item.Name.Substring("___".Length);
				FieldInfo fieldInfo;
				if (text.All(char.IsDigit))
				{
					fieldInfo = AccessTools.DeclaredField(declaringType, int.Parse(text));
					if ((object)fieldInfo == null)
					{
						throw new ArgumentException("No field found at given index in class " + (declaringType?.AssemblyQualifiedName ?? "null"), text);
					}
				}
				else
				{
					fieldInfo = AccessTools.Field(declaringType, text);
					if ((object)fieldInfo == null)
					{
						throw new ArgumentException("No such field defined in class " + (declaringType?.AssemblyQualifiedName ?? "null"), text);
					}
				}
				if (fieldInfo.IsStatic)
				{
					emitter.Emit(item.ParameterType.IsByRef ? OpCodes.Ldsflda : OpCodes.Ldsfld, fieldInfo);
					continue;
				}
				emitter.Emit(OpCodes.Ldarg_0);
				emitter.Emit(item.ParameterType.IsByRef ? OpCodes.Ldflda : OpCodes.Ldfld, fieldInfo);
				continue;
			}
			if (item.Name == "__state")
			{
				OpCode opcode = (item.ParameterType.IsByRef ? OpCodes.Ldloca : OpCodes.Ldloc);
				if (variables.TryGetValue(patch.DeclaringType?.AssemblyQualifiedName ?? "null", out var value2))
				{
					emitter.Emit(opcode, value2);
				}
				else
				{
					emitter.Emit(OpCodes.Ldnull);
				}
				continue;
			}
			if (item.Name == "__result")
			{
				if (returnType == typeof(void))
				{
					throw new Exception("Cannot get result from void method " + original.FullDescription());
				}
				Type type = item.ParameterType;
				if (type.IsByRef && !returnType.IsByRef)
				{
					type = type.GetElementType();
				}
				if (!type.IsAssignableFrom(returnType))
				{
					throw new Exception($"Cannot assign method return type {returnType.FullName} to {"__result"} type {type.FullName} for method {original.FullDescription()}");
				}
				OpCode opcode2 = ((item.ParameterType.IsByRef && !returnType.IsByRef) ? OpCodes.Ldloca : OpCodes.Ldloc);
				if (returnType.IsValueType && item.ParameterType == typeof(object).MakeByRefType())
				{
					opcode2 = OpCodes.Ldloc;
				}
				emitter.Emit(opcode2, variables["__result"]);
				if (returnType.IsValueType)
				{
					if (item.ParameterType == typeof(object))
					{
						emitter.Emit(OpCodes.Box, returnType);
					}
					else if (item.ParameterType == typeof(object).MakeByRefType())
					{
						emitter.Emit(OpCodes.Box, returnType);
						tmpObjectVar = il.DeclareLocal(typeof(object));
						emitter.Emit(OpCodes.Stloc, tmpObjectVar);
						emitter.Emit(OpCodes.Ldloca, tmpObjectVar);
					}
				}
				continue;
			}
			if (item.Name == "__resultRef")
			{
				if (!returnType.IsByRef)
				{
					throw new Exception($"Cannot use {"__resultRef"} with non-ref return type {returnType.FullName} of method {original.FullDescription()}");
				}
				Type parameterType2 = item.ParameterType;
				Type type2 = typeof(RefResult<>).MakeGenericType(returnType.GetElementType()).MakeByRefType();
				if (parameterType2 != type2)
				{
					throw new Exception($"Wrong type of {"__resultRef"} for method {original.FullDescription()}. Expected {type2.FullName}, got {parameterType2.FullName}");
				}
				emitter.Emit(OpCodes.Ldloca, variables["__resultRef"]);
				refResultUsed = true;
				continue;
			}
			if (variables.TryGetValue(item.Name, out var value3))
			{
				OpCode opcode3 = (item.ParameterType.IsByRef ? OpCodes.Ldloca : OpCodes.Ldloc);
				emitter.Emit(opcode3, value3);
				continue;
			}
			int result;
			if (item.Name.StartsWith("__", StringComparison.Ordinal))
			{
				string s = item.Name.Substring("__".Length);
				if (!int.TryParse(s, out result))
				{
					throw new Exception("Parameter " + item.Name + " does not contain a valid index");
				}
				if (result < 0 || result >= parameters.Length)
				{
					throw new Exception($"No parameter found at index {result}");
				}
			}
			else
			{
				result = patch.GetArgumentIndex(originalParameterNames, item);
				if (result == -1)
				{
					HarmonyMethod mergedFromType = HarmonyMethodExtensions.GetMergedFromType(item.ParameterType);
					HarmonyMethod harmonyMethod = mergedFromType;
					MethodType valueOrDefault = harmonyMethod.methodType.GetValueOrDefault();
					if (!harmonyMethod.methodType.HasValue)
					{
						valueOrDefault = MethodType.Normal;
						harmonyMethod.methodType = valueOrDefault;
					}
					MethodBase originalMethod = mergedFromType.GetOriginalMethod();
					if (originalMethod is MethodInfo methodInfo)
					{
						ConstructorInfo constructor = item.ParameterType.GetConstructor(new Type[2]
						{
							typeof(object),
							typeof(IntPtr)
						});
						if ((object)constructor != null)
						{
							if (methodInfo.IsStatic)
							{
								emitter.Emit(OpCodes.Ldnull);
							}
							else
							{
								emitter.Emit(OpCodes.Ldarg_0);
								if (declaringType != null && declaringType.IsValueType)
								{
									emitter.Emit(OpCodes.Ldobj, declaringType);
									emitter.Emit(OpCodes.Box, declaringType);
								}
							}
							if (!methodInfo.IsStatic && !mergedFromType.nonVirtualDelegate)
							{
								emitter.Emit(OpCodes.Dup);
								emitter.Emit(OpCodes.Ldvirtftn, methodInfo);
							}
							else
							{
								emitter.Emit(OpCodes.Ldftn, methodInfo);
							}
							emitter.Emit(OpCodes.Newobj, constructor);
							continue;
						}
					}
					throw new Exception("Parameter \"" + item.Name + "\" not found in method " + original.FullDescription());
				}
			}
			Type parameterType3 = parameters[result].ParameterType;
			Type type3 = (parameterType3.IsByRef ? parameterType3.GetElementType() : parameterType3);
			Type parameterType4 = item.ParameterType;
			Type type4 = (parameterType4.IsByRef ? parameterType4.GetElementType() : parameterType4);
			bool flag3 = !parameters[result].IsOut && !parameterType3.IsByRef;
			bool flag4 = !item.IsOut && !parameterType4.IsByRef;
			bool flag5 = type3.IsValueType && !type4.IsValueType;
			int arg = result + (flag ? 1 : 0);
			if (flag3 == flag4)
			{
				emitter.Emit(OpCodes.Ldarg, arg);
				if (flag5)
				{
					if (flag4)
					{
						emitter.Emit(OpCodes.Box, type3);
						continue;
					}
					emitter.Emit(OpCodes.Ldobj, type3);
					emitter.Emit(OpCodes.Box, type3);
					LocalBuilder localBuilder = il.DeclareLocal(type4);
					emitter.Emit(OpCodes.Stloc, localBuilder);
					emitter.Emit(OpCodes.Ldloca_S, localBuilder);
					tmpBoxVars.Add(new KeyValuePair<LocalBuilder, Type>(localBuilder, type3));
				}
			}
			else if (flag3 && !flag4)
			{
				if (flag5)
				{
					emitter.Emit(OpCodes.Ldarg, arg);
					emitter.Emit(OpCodes.Box, type3);
					LocalBuilder local = il.DeclareLocal(type4);
					emitter.Emit(OpCodes.Stloc, local);
					emitter.Emit(OpCodes.Ldloca_S, local);
				}
				else
				{
					emitter.Emit(OpCodes.Ldarga, arg);
				}
			}
			else
			{
				emitter.Emit(OpCodes.Ldarg, arg);
				if (flag5)
				{
					emitter.Emit(OpCodes.Ldobj, type3);
					emitter.Emit(OpCodes.Box, type3);
				}
				else if (type3.IsValueType)
				{
					emitter.Emit(OpCodes.Ldobj, type3);
				}
				else
				{
					emitter.Emit(LoadIndOpCodeFor(parameters[result].ParameterType));
				}
			}
		}
	}

	private static bool PrefixAffectsOriginal(MethodInfo fix)
	{
		if (fix.ReturnType == typeof(bool))
		{
			return true;
		}
		return fix.GetParameters().Any(delegate(ParameterInfo p)
		{
			string name = p.Name;
			Type parameterType = p.ParameterType;
			switch (name)
			{
			case "__instance":
				return false;
			case "__originalMethod":
				return false;
			case "__state":
				return false;
			default:
				if (p.IsOut || p.IsRetval)
				{
					return true;
				}
				if (parameterType.IsByRef)
				{
					return true;
				}
				if (!AccessTools.IsValue(parameterType) && !AccessTools.IsStruct(parameterType))
				{
					return true;
				}
				return false;
			}
		});
	}

	private void AddPrefixes(Dictionary<string, LocalBuilder> variables, LocalBuilder runOriginalVariable)
	{
		prefixes.Do(delegate(MethodInfo fix)
		{
			Label? label = (PrefixAffectsOriginal(fix) ? new Label?(il.DefineLabel()) : ((Label?)null));
			if (label.HasValue)
			{
				emitter.Emit(OpCodes.Ldloc, runOriginalVariable);
				emitter.Emit(OpCodes.Brfalse, label.Value);
			}
			List<KeyValuePair<LocalBuilder, Type>> list = new List<KeyValuePair<LocalBuilder, Type>>();
			EmitCallParameter(fix, variables, runOriginalVariable, allowFirsParamPassthrough: false, out var tmpInstanceBoxingVar, out var tmpObjectVar, out var refResultUsed, list);
			emitter.Emit(OpCodes.Call, fix);
			if (fix.GetParameters().Any((ParameterInfo p) => p.Name == "__args"))
			{
				RestoreArgumentArray(variables);
			}
			if (tmpInstanceBoxingVar != null)
			{
				emitter.Emit(OpCodes.Ldarg_0);
				emitter.Emit(OpCodes.Ldloc, tmpInstanceBoxingVar);
				emitter.Emit(OpCodes.Unbox_Any, original.DeclaringType);
				emitter.Emit(OpCodes.Stobj, original.DeclaringType);
			}
			if (refResultUsed)
			{
				Label label2 = il.DefineLabel();
				emitter.Emit(OpCodes.Ldloc, variables["__resultRef"]);
				emitter.Emit(OpCodes.Brfalse_S, label2);
				emitter.Emit(OpCodes.Ldloc, variables["__resultRef"]);
				emitter.Emit(OpCodes.Callvirt, AccessTools.Method(variables["__resultRef"].LocalType, "Invoke"));
				emitter.Emit(OpCodes.Stloc, variables["__result"]);
				emitter.Emit(OpCodes.Ldnull);
				emitter.Emit(OpCodes.Stloc, variables["__resultRef"]);
				emitter.MarkLabel(label2);
				emitter.Emit(OpCodes.Nop);
			}
			else if (tmpObjectVar != null)
			{
				emitter.Emit(OpCodes.Ldloc, tmpObjectVar);
				emitter.Emit(OpCodes.Unbox_Any, AccessTools.GetReturnedType(original));
				emitter.Emit(OpCodes.Stloc, variables["__result"]);
			}
			list.Do(delegate(KeyValuePair<LocalBuilder, Type> tmpBoxVar)
			{
				emitter.Emit(original.IsStatic ? OpCodes.Ldarg_0 : OpCodes.Ldarg_1);
				emitter.Emit(OpCodes.Ldloc, tmpBoxVar.Key);
				emitter.Emit(OpCodes.Unbox_Any, tmpBoxVar.Value);
				emitter.Emit(OpCodes.Stobj, tmpBoxVar.Value);
			});
			Type type = fix.ReturnType;
			if (type != typeof(void))
			{
				if (type != typeof(bool))
				{
					throw new Exception($"Prefix patch {fix} has not \"bool\" or \"void\" return type: {fix.ReturnType}");
				}
				emitter.Emit(OpCodes.Stloc, runOriginalVariable);
			}
			if (label.HasValue)
			{
				emitter.MarkLabel(label.Value);
				emitter.Emit(OpCodes.Nop);
			}
		});
	}

	private bool AddPostfixes(Dictionary<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool passthroughPatches)
	{
		bool result = false;
		postfixes.Where((MethodInfo fix) => passthroughPatches == (fix.ReturnType != typeof(void))).Do(delegate(MethodInfo fix)
		{
			List<KeyValuePair<LocalBuilder, Type>> list = new List<KeyValuePair<LocalBuilder, Type>>();
			EmitCallParameter(fix, variables, runOriginalVariable, allowFirsParamPassthrough: true, out var tmpInstanceBoxingVar, out var tmpObjectVar, out var refResultUsed, list);
			emitter.Emit(OpCodes.Call, fix);
			if (fix.GetParameters().Any((ParameterInfo p) => p.Name == "__args"))
			{
				RestoreArgumentArray(variables);
			}
			if (tmpInstanceBoxingVar != null)
			{
				emitter.Emit(OpCodes.Ldarg_0);
				emitter.Emit(OpCodes.Ldloc, tmpInstanceBoxingVar);
				emitter.Emit(OpCodes.Unbox_Any, original.DeclaringType);
				emitter.Emit(OpCodes.Stobj, original.DeclaringType);
			}
			if (refResultUsed)
			{
				Label label = il.DefineLabel();
				emitter.Emit(OpCodes.Ldloc, variables["__resultRef"]);
				emitter.Emit(OpCodes.Brfalse_S, label);
				emitter.Emit(OpCodes.Ldloc, variables["__resultRef"]);
				emitter.Emit(OpCodes.Callvirt, AccessTools.Method(variables["__resultRef"].LocalType, "Invoke"));
				emitter.Emit(OpCodes.Stloc, variables["__result"]);
				emitter.Emit(OpCodes.Ldnull);
				emitter.Emit(OpCodes.Stloc, variables["__resultRef"]);
				emitter.MarkLabel(label);
				emitter.Emit(OpCodes.Nop);
			}
			else if (tmpObjectVar != null)
			{
				emitter.Emit(OpCodes.Ldloc, tmpObjectVar);
				emitter.Emit(OpCodes.Unbox_Any, AccessTools.GetReturnedType(original));
				emitter.Emit(OpCodes.Stloc, variables["__result"]);
			}
			list.Do(delegate(KeyValuePair<LocalBuilder, Type> tmpBoxVar)
			{
				emitter.Emit(original.IsStatic ? OpCodes.Ldarg_0 : OpCodes.Ldarg_1);
				emitter.Emit(OpCodes.Ldloc, tmpBoxVar.Key);
				emitter.Emit(OpCodes.Unbox_Any, tmpBoxVar.Value);
				emitter.Emit(OpCodes.Stobj, tmpBoxVar.Value);
			});
			if (fix.ReturnType != typeof(void))
			{
				ParameterInfo parameterInfo = fix.GetParameters().FirstOrDefault();
				if (parameterInfo == null || !(fix.ReturnType == parameterInfo.ParameterType))
				{
					if (parameterInfo != null)
					{
						throw new Exception($"Return type of pass through postfix {fix} does not match type of its first parameter");
					}
					throw new Exception($"Postfix patch {fix} must have a \"void\" return type");
				}
				result = true;
			}
		});
		return result;
	}

	private bool AddFinalizers(Dictionary<string, LocalBuilder> variables, LocalBuilder runOriginalVariable, bool catchExceptions)
	{
		bool rethrowPossible = true;
		finalizers.Do(delegate(MethodInfo fix)
		{
			if (catchExceptions)
			{
				emitter.MarkBlockBefore(new ExceptionBlock(ExceptionBlockType.BeginExceptionBlock), out var _);
			}
			List<KeyValuePair<LocalBuilder, Type>> list = new List<KeyValuePair<LocalBuilder, Type>>();
			EmitCallParameter(fix, variables, runOriginalVariable, allowFirsParamPassthrough: false, out var tmpInstanceBoxingVar, out var tmpObjectVar, out var refResultUsed, list);
			emitter.Emit(OpCodes.Call, fix);
			if (fix.GetParameters().Any((ParameterInfo p) => p.Name == "__args"))
			{
				RestoreArgumentArray(variables);
			}
			if (tmpInstanceBoxingVar != null)
			{
				emitter.Emit(OpCodes.Ldarg_0);
				emitter.Emit(OpCodes.Ldloc, tmpInstanceBoxingVar);
				emitter.Emit(OpCodes.Unbox_Any, original.DeclaringType);
				emitter.Emit(OpCodes.Stobj, original.DeclaringType);
			}
			if (refResultUsed)
			{
				Label label2 = il.DefineLabel();
				emitter.Emit(OpCodes.Ldloc, variables["__resultRef"]);
				emitter.Emit(OpCodes.Brfalse_S, label2);
				emitter.Emit(OpCodes.Ldloc, variables["__resultRef"]);
				emitter.Emit(OpCodes.Callvirt, AccessTools.Method(variables["__resultRef"].LocalType, "Invoke"));
				emitter.Emit(OpCodes.Stloc, variables["__result"]);
				emitter.Emit(OpCodes.Ldnull);
				emitter.Emit(OpCodes.Stloc, variables["__resultRef"]);
				emitter.MarkLabel(label2);
				emitter.Emit(OpCodes.Nop);
			}
			else if (tmpObjectVar != null)
			{
				emitter.Emit(OpCodes.Ldloc, tmpObjectVar);
				emitter.Emit(OpCodes.Unbox_Any, AccessTools.GetReturnedType(original));
				emitter.Emit(OpCodes.Stloc, variables["__result"]);
			}
			list.Do(delegate(KeyValuePair<LocalBuilder, Type> tmpBoxVar)
			{
				emitter.Emit(original.IsStatic ? OpCodes.Ldarg_0 : OpCodes.Ldarg_1);
				emitter.Emit(OpCodes.Ldloc, tmpBoxVar.Key);
				emitter.Emit(OpCodes.Unbox_Any, tmpBoxVar.Value);
				emitter.Emit(OpCodes.Stobj, tmpBoxVar.Value);
			});
			if (fix.ReturnType != typeof(void))
			{
				emitter.Emit(OpCodes.Stloc, variables["__exception"]);
				rethrowPossible = false;
			}
			if (catchExceptions)
			{
				emitter.MarkBlockBefore(new ExceptionBlock(ExceptionBlockType.BeginCatchBlock), out var _);
				emitter.Emit(OpCodes.Pop);
				emitter.MarkBlockAfter(new ExceptionBlock(ExceptionBlockType.EndExceptionBlock));
			}
		});
		return rethrowPossible;
	}

	private void PrepareArgumentArray()
	{
		ParameterInfo[] parameters = original.GetParameters();
		int num = 0;
		ParameterInfo[] array = parameters;
		foreach (ParameterInfo parameterInfo in array)
		{
			int argIndex = num++ + ((!original.IsStatic) ? 1 : 0);
			if (parameterInfo.IsOut || parameterInfo.IsRetval)
			{
				InitializeOutParameter(argIndex, parameterInfo.ParameterType);
			}
		}
		emitter.Emit(OpCodes.Ldc_I4, parameters.Length);
		emitter.Emit(OpCodes.Newarr, typeof(object));
		num = 0;
		int num2 = 0;
		ParameterInfo[] array2 = parameters;
		foreach (ParameterInfo parameterInfo2 in array2)
		{
			int arg = num++ + ((!original.IsStatic) ? 1 : 0);
			Type type = parameterInfo2.ParameterType;
			bool isByRef = type.IsByRef;
			if (isByRef)
			{
				type = type.GetElementType();
			}
			emitter.Emit(OpCodes.Dup);
			emitter.Emit(OpCodes.Ldc_I4, num2++);
			emitter.Emit(OpCodes.Ldarg, arg);
			if (isByRef)
			{
				if (AccessTools.IsStruct(type))
				{
					emitter.Emit(OpCodes.Ldobj, type);
				}
				else
				{
					emitter.Emit(LoadIndOpCodeFor(type));
				}
			}
			if (type.IsValueType)
			{
				emitter.Emit(OpCodes.Box, type);
			}
			emitter.Emit(OpCodes.Stelem_Ref);
		}
	}

	private void RestoreArgumentArray(Dictionary<string, LocalBuilder> variables)
	{
		ParameterInfo[] parameters = original.GetParameters();
		int num = 0;
		int num2 = 0;
		ParameterInfo[] array = parameters;
		foreach (ParameterInfo parameterInfo in array)
		{
			int arg = num++ + ((!original.IsStatic) ? 1 : 0);
			Type parameterType = parameterInfo.ParameterType;
			if (parameterType.IsByRef)
			{
				parameterType = parameterType.GetElementType();
				emitter.Emit(OpCodes.Ldarg, arg);
				emitter.Emit(OpCodes.Ldloc, variables["__args"]);
				emitter.Emit(OpCodes.Ldc_I4, num2);
				emitter.Emit(OpCodes.Ldelem_Ref);
				if (parameterType.IsValueType)
				{
					emitter.Emit(OpCodes.Unbox_Any, parameterType);
					if (AccessTools.IsStruct(parameterType))
					{
						emitter.Emit(OpCodes.Stobj, parameterType);
					}
					else
					{
						emitter.Emit(StoreIndOpCodeFor(parameterType));
					}
				}
				else
				{
					emitter.Emit(OpCodes.Castclass, parameterType);
					emitter.Emit(OpCodes.Stind_Ref);
				}
			}
			else
			{
				emitter.Emit(OpCodes.Ldloc, variables["__args"]);
				emitter.Emit(OpCodes.Ldc_I4, num2);
				emitter.Emit(OpCodes.Ldelem_Ref);
				if (parameterType.IsValueType)
				{
					emitter.Emit(OpCodes.Unbox_Any, parameterType);
				}
				else
				{
					emitter.Emit(OpCodes.Castclass, parameterType);
				}
				emitter.Emit(OpCodes.Starg, arg);
			}
			num2++;
		}
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

internal static class PatchArgumentExtensions
{
	private static HarmonyArgument[] AllHarmonyArguments(object[] attributes)
	{
		return (from attr in attributes
			select (attr.GetType().Name != "HarmonyArgument") ? null : AccessTools.MakeDeepCopy<HarmonyArgument>(attr) into harg
			where harg != null
			select harg).ToArray();
	}

	private static HarmonyArgument GetArgumentAttribute(this ParameterInfo parameter)
	{
		object[] customAttributes = parameter.GetCustomAttributes(inherit: false);
		return AllHarmonyArguments(customAttributes).FirstOrDefault();
	}

	private static HarmonyArgument[] GetArgumentAttributes(this MethodInfo method)
	{
		if ((object)method == null || method is DynamicMethod)
		{
			return null;
		}
		object[] customAttributes = method.GetCustomAttributes(inherit: false);
		return AllHarmonyArguments(customAttributes);
	}

	private static HarmonyArgument[] GetArgumentAttributes(this Type type)
	{
		object[] customAttributes = type.GetCustomAttributes(inherit: false);
		return AllHarmonyArguments(customAttributes);
	}

	private static string GetOriginalArgumentName(this ParameterInfo parameter, string[] originalParameterNames)
	{
		HarmonyArgument argumentAttribute = parameter.GetArgumentAttribute();
		if (argumentAttribute == null)
		{
			return null;
		}
		if (!string.IsNullOrEmpty(argumentAttribute.OriginalName))
		{
			return argumentAttribute.OriginalName;
		}
		if (argumentAttribute.Index >= 0 && argumentAttribute.Index < originalParameterNames.Length)
		{
			return originalParameterNames[argumentAttribute.Index];
		}
		return null;
	}

	private static string GetOriginalArgumentName(HarmonyArgument[] attributes, string name, string[] originalParameterNames)
	{
		if (((attributes != null && attributes.Length != 0) ? 1 : 0) <= (false ? 1 : 0))
		{
			return null;
		}
		HarmonyArgument harmonyArgument = attributes.SingleOrDefault((HarmonyArgument p) => p.NewName == name);
		if (harmonyArgument == null)
		{
			return null;
		}
		if (!string.IsNullOrEmpty(harmonyArgument.OriginalName))
		{
			return harmonyArgument.OriginalName;
		}
		if (originalParameterNames != null && harmonyArgument.Index >= 0 && harmonyArgument.Index < originalParameterNames.Length)
		{
			return originalParameterNames[harmonyArgument.Index];
		}
		return null;
	}

	private static string GetOriginalArgumentName(this MethodInfo method, string[] originalParameterNames, string name)
	{
		string originalArgumentName = GetOriginalArgumentName(((object)method != null) ? method.GetArgumentAttributes() : null, name, originalParameterNames);
		if (originalArgumentName != null)
		{
			return originalArgumentName;
		}
		object attributes;
		if ((object)method == null)
		{
			attributes = null;
		}
		else
		{
			Type? declaringType = method.DeclaringType;
			attributes = (((object)declaringType != null) ? declaringType.GetArgumentAttributes() : null);
		}
		originalArgumentName = GetOriginalArgumentName((HarmonyArgument[])attributes, name, originalParameterNames);
		if (originalArgumentName != null)
		{
			return originalArgumentName;
		}
		return name;
	}

	internal static int GetArgumentIndex(this MethodInfo patch, string[] originalParameterNames, ParameterInfo patchParam)
	{
		if (patch is DynamicMethod)
		{
			return Array.IndexOf<string>(originalParameterNames, patchParam.Name);
		}
		string originalArgumentName = patchParam.GetOriginalArgumentName(originalParameterNames);
		if (originalArgumentName != null)
		{
			return Array.IndexOf(originalParameterNames, originalArgumentName);
		}
		originalArgumentName = patch.GetOriginalArgumentName(originalParameterNames, patchParam.Name);
		if (originalArgumentName != null)
		{
			return Array.IndexOf(originalParameterNames, originalArgumentName);
		}
		return -1;
	}
}


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Reflection;
using HarmonyLib;

internal static class PatchFunctions
{
	internal static List<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches, bool debug)
	{
		return new PatchSorter(patches, debug).Sort(original);
	}

	internal static MethodInfo UpdateWrapper(MethodBase original, PatchInfo patchInfo)
	{
		bool debug = patchInfo.Debugging || Harmony.DEBUG;
		List<MethodInfo> sortedPatchMethods = GetSortedPatchMethods(original, patchInfo.prefixes, debug);
		List<MethodInfo> sortedPatchMethods2 = GetSortedPatchMethods(original, patchInfo.postfixes, debug);
		List<MethodInfo> sortedPatchMethods3 = GetSortedPatchMethods(original, patchInfo.transpilers, debug);
		List<MethodInfo> sortedPatchMethods4 = GetSortedPatchMethods(original, patchInfo.finalizers, debug);
		MethodPatcher methodPatcher = new MethodPatcher(original, null, sortedPatchMethods, sortedPatchMethods2, sortedPatchMethods3, sortedPatchMethods4, debug);
		Dictionary<int, CodeInstruction> finalInstructions;
		MethodInfo methodInfo = methodPatcher.CreateReplacement(out finalInstructions);
		if ((object)methodInfo == null)
		{
			throw new MissingMethodException("Cannot create replacement for " + original.FullDescription());
		}
		try
		{
			PatchTools.DetourMethod(original, methodInfo);
			return methodInfo;
		}
		catch (Exception ex)
		{
			throw HarmonyException.Create(ex, finalInstructions);
		}
	}

	internal static MethodInfo ReversePatch(HarmonyMethod standin, MethodBase original, MethodInfo postTranspiler)
	{
		if (standin == null)
		{
			throw new ArgumentNullException("standin");
		}
		if ((object)standin.method == null)
		{
			throw new ArgumentNullException("standin", "standin.method is NULL");
		}
		bool debug = standin.debug == true || Harmony.DEBUG;
		List<MethodInfo> list = new List<MethodInfo>();
		if (standin.reversePatchType == HarmonyReversePatchType.Snapshot)
		{
			Patches patchInfo = Harmony.GetPatchInfo(original);
			List<MethodInfo> list2 = list;
			ReadOnlyCollection<Patch> transpilers = patchInfo.Transpilers;
			int num = 0;
			Patch[] array = new Patch[transpilers.Count];
			foreach (Patch item in transpilers)
			{
				array[num] = item;
				num++;
			}
			list2.AddRange(GetSortedPatchMethods(original, array, debug));
		}
		if ((object)postTranspiler != null)
		{
			list.Add(postTranspiler);
		}
		List<MethodInfo> list3 = new List<MethodInfo>();
		MethodPatcher methodPatcher = new MethodPatcher(standin.method, original, list3, list3, list, list3, debug);
		Dictionary<int, CodeInstruction> finalInstructions;
		MethodInfo methodInfo = methodPatcher.CreateReplacement(out finalInstructions);
		if ((object)methodInfo == null)
		{
			throw new MissingMethodException("Cannot create replacement for " + standin.method.FullDescription());
		}
		try
		{
			PatchTools.DetourMethod(standin.method, methodInfo);
			return methodInfo;
		}
		catch (Exception ex)
		{
			throw HarmonyException.Create(ex, finalInstructions);
		}
	}
}


using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

internal class PatchJobs<T>
{
	internal class Job
	{
		internal MethodBase original;

		internal T replacement;

		internal List<HarmonyMethod> prefixes = new List<HarmonyMethod>();

		internal List<HarmonyMethod> postfixes = new List<HarmonyMethod>();

		internal List<HarmonyMethod> transpilers = new List<HarmonyMethod>();

		internal List<HarmonyMethod> finalizers = new List<HarmonyMethod>();

		internal void AddPatch(AttributePatch patch)
		{
			HarmonyPatchType? type = patch.type;
			if (type.HasValue)
			{
				switch (type.GetValueOrDefault())
				{
				case HarmonyPatchType.Prefix:
					prefixes.Add(patch.info);
					break;
				case HarmonyPatchType.Postfix:
					postfixes.Add(patch.info);
					break;
				case HarmonyPatchType.Transpiler:
					transpilers.Add(patch.info);
					break;
				case HarmonyPatchType.Finalizer:
					finalizers.Add(patch.info);
					break;
				}
			}
		}
	}

	internal Dictionary<MethodBase, Job> state = new Dictionary<MethodBase, Job>();

	internal Job GetJob(MethodBase method)
	{
		if ((object)method == null)
		{
			return null;
		}
		if (!state.TryGetValue(method, out var value))
		{
			value = new Job
			{
				original = method
			};
			state[method] = value;
		}
		return value;
	}

	internal List<Job> GetJobs()
	{
		return state.Values.Where((Job job) => job.prefixes.Count + job.postfixes.Count + job.transpilers.Count + job.finalizers.Count > 0).ToList();
	}

	internal List<T> GetReplacements()
	{
		return state.Values.Select((Job job) => job.replacement).ToList();
	}
}


using System.Collections.Generic;
using System.Reflection;

internal class Job
{
	internal MethodBase original;

	internal T replacement;

	internal List<HarmonyMethod> prefixes = new List<HarmonyMethod>();

	internal List<HarmonyMethod> postfixes = new List<HarmonyMethod>();

	internal List<HarmonyMethod> transpilers = new List<HarmonyMethod>();

	internal List<HarmonyMethod> finalizers = new List<HarmonyMethod>();

	internal void AddPatch(AttributePatch patch)
	{
		HarmonyPatchType? type = patch.type;
		if (type.HasValue)
		{
			switch (type.GetValueOrDefault())
			{
			case HarmonyPatchType.Prefix:
				prefixes.Add(patch.info);
				break;
			case HarmonyPatchType.Postfix:
				postfixes.Add(patch.info);
				break;
			case HarmonyPatchType.Transpiler:
				transpilers.Add(patch.info);
				break;
			case HarmonyPatchType.Finalizer:
				finalizers.Add(patch.info);
				break;
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

internal class AttributePatch
{
	private static readonly HarmonyPatchType[] allPatchTypes = new HarmonyPatchType[5]
	{
		HarmonyPatchType.Prefix,
		HarmonyPatchType.Postfix,
		HarmonyPatchType.Transpiler,
		HarmonyPatchType.Finalizer,
		HarmonyPatchType.ReversePatch
	};

	internal HarmonyMethod info;

	internal HarmonyPatchType? type;

	internal static AttributePatch Create(MethodInfo patch)
	{
		if ((object)patch == null)
		{
			throw new NullReferenceException("Patch method cannot be null");
		}
		object[] customAttributes = patch.GetCustomAttributes(inherit: true);
		string name = patch.Name;
		HarmonyPatchType? patchType = GetPatchType(name, customAttributes);
		if (!patchType.HasValue)
		{
			return null;
		}
		if (patchType != HarmonyPatchType.ReversePatch && !patch.IsStatic)
		{
			throw new ArgumentException("Patch method " + patch.FullDescription() + " must be static");
		}
		List<HarmonyMethod> attributes = (from harmonyInfo in customAttributes.Where((object attr) => attr.GetType().BaseType.FullName == PatchTools.harmonyAttributeFullName).Select(delegate(object attr)
			{
				FieldInfo fieldInfo = AccessTools.Field(attr.GetType(), "info");
				return fieldInfo.GetValue(attr);
			})
			select AccessTools.MakeDeepCopy<HarmonyMethod>(harmonyInfo)).ToList();
		HarmonyMethod harmonyMethod = HarmonyMethod.Merge(attributes);
		harmonyMethod.method = patch;
		return new AttributePatch
		{
			info = harmonyMethod,
			type = patchType
		};
	}

	private static HarmonyPatchType? GetPatchType(string methodName, object[] allAttributes)
	{
		HashSet<string> hashSet = new HashSet<string>(from attr in allAttributes
			select attr.GetType().FullName into name
			where name.StartsWith("Harmony")
			select name);
		HarmonyPatchType? result = null;
		HarmonyPatchType[] array = allPatchTypes;
		for (int i = 0; i < array.Length; i++)
		{
			HarmonyPatchType value = array[i];
			string text = value.ToString();
			if (text == methodName || hashSet.Contains("HarmonyLib.Harmony" + text))
			{
				result = value;
				break;
			}
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

internal class PatchSorter
{
	private class PatchSortingWrapper : IComparable
	{
		internal readonly HashSet<PatchSortingWrapper> after;

		internal readonly HashSet<PatchSortingWrapper> before;

		internal readonly Patch innerPatch;

		internal PatchSortingWrapper(Patch patch)
		{
			innerPatch = patch;
			before = new HashSet<PatchSortingWrapper>();
			after = new HashSet<PatchSortingWrapper>();
		}

		public int CompareTo(object obj)
		{
			return PatchInfoSerialization.PriorityComparer((obj is PatchSortingWrapper patchSortingWrapper) ? patchSortingWrapper.innerPatch : null, innerPatch.index, innerPatch.priority);
		}

		public override bool Equals(object obj)
		{
			if (obj is PatchSortingWrapper patchSortingWrapper)
			{
				return innerPatch.PatchMethod == patchSortingWrapper.innerPatch.PatchMethod;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return innerPatch.PatchMethod.GetHashCode();
		}

		internal void AddBeforeDependency(IEnumerable<PatchSortingWrapper> dependencies)
		{
			foreach (PatchSortingWrapper dependency in dependencies)
			{
				before.Add(dependency);
				dependency.after.Add(this);
			}
		}

		internal void AddAfterDependency(IEnumerable<PatchSortingWrapper> dependencies)
		{
			foreach (PatchSortingWrapper dependency in dependencies)
			{
				after.Add(dependency);
				dependency.before.Add(this);
			}
		}

		internal void RemoveAfterDependency(PatchSortingWrapper afterNode)
		{
			after.Remove(afterNode);
			afterNode.before.Remove(this);
		}

		internal void RemoveBeforeDependency(PatchSortingWrapper beforeNode)
		{
			before.Remove(beforeNode);
			beforeNode.after.Remove(this);
		}
	}

	internal class PatchDetailedComparer : IEqualityComparer<Patch>
	{
		public bool Equals(Patch x, Patch y)
		{
			if (y != null && x != null && x.owner == y.owner && x.PatchMethod == y.PatchMethod && x.index == y.index && x.priority == y.priority && x.before.Length == y.before.Length && x.after.Length == y.after.Length && x.before.All(((IEnumerable<string>)y.before).Contains<string>))
			{
				return x.after.All(((IEnumerable<string>)y.after).Contains<string>);
			}
			return false;
		}

		public int GetHashCode(Patch obj)
		{
			return obj.GetHashCode();
		}
	}

	private List<PatchSortingWrapper> patches;

	private HashSet<PatchSortingWrapper> handledPatches;

	private List<PatchSortingWrapper> result;

	private List<PatchSortingWrapper> waitingList;

	internal Patch[] sortedPatchArray;

	private readonly bool debug;

	internal PatchSorter(Patch[] patches, bool debug)
	{
		this.patches = patches.Select((Patch x) => new PatchSortingWrapper(x)).ToList();
		this.debug = debug;
		foreach (PatchSortingWrapper node in this.patches)
		{
			node.AddBeforeDependency(this.patches.Where((PatchSortingWrapper x) => node.innerPatch.before.Contains(x.innerPatch.owner)));
			node.AddAfterDependency(this.patches.Where((PatchSortingWrapper x) => node.innerPatch.after.Contains(x.innerPatch.owner)));
		}
		this.patches.Sort();
	}

	internal List<MethodInfo> Sort(MethodBase original)
	{
		if (sortedPatchArray != null)
		{
			return sortedPatchArray.Select((Patch x) => x.GetMethod(original)).ToList();
		}
		handledPatches = new HashSet<PatchSortingWrapper>();
		waitingList = new List<PatchSortingWrapper>();
		result = new List<PatchSortingWrapper>(patches.Count);
		Queue<PatchSortingWrapper> queue = new Queue<PatchSortingWrapper>(patches);
		while (queue.Count != 0)
		{
			foreach (PatchSortingWrapper item in queue)
			{
				if (item.after.All((PatchSortingWrapper x) => handledPatches.Contains(x)))
				{
					AddNodeToResult(item);
					if (item.before.Count != 0)
					{
						ProcessWaitingList();
					}
				}
				else
				{
					waitingList.Add(item);
				}
			}
			CullDependency();
			queue = new Queue<PatchSortingWrapper>(waitingList);
			waitingList.Clear();
		}
		sortedPatchArray = result.Select((PatchSortingWrapper x) => x.innerPatch).ToArray();
		handledPatches = null;
		waitingList = null;
		patches = null;
		return sortedPatchArray.Select((Patch x) => x.GetMethod(original)).ToList();
	}

	internal bool ComparePatchLists(Patch[] patches)
	{
		if (sortedPatchArray == null)
		{
			Sort(null);
		}
		if (patches != null && sortedPatchArray.Length == patches.Length)
		{
			return sortedPatchArray.All((Patch x) => patches.Contains(x, new PatchDetailedComparer()));
		}
		return false;
	}

	private void CullDependency()
	{
		for (int num = waitingList.Count - 1; num >= 0; num--)
		{
			foreach (PatchSortingWrapper item in waitingList[num].after)
			{
				if (!handledPatches.Contains(item))
				{
					waitingList[num].RemoveAfterDependency(item);
					if (debug)
					{
						string text = item.innerPatch.PatchMethod.FullDescription();
						string text2 = waitingList[num].innerPatch.PatchMethod.FullDescription();
						FileLog.LogBuffered("Breaking dependance between " + text + " and " + text2);
					}
					return;
				}
			}
		}
	}

	private void ProcessWaitingList()
	{
		int num = waitingList.Count;
		int num2 = 0;
		while (num2 < num)
		{
			PatchSortingWrapper patchSortingWrapper = waitingList[num2];
			if (patchSortingWrapper.after.All(handledPatches.Contains))
			{
				waitingList.Remove(patchSortingWrapper);
				AddNodeToResult(patchSortingWrapper);
				num--;
				num2 = 0;
			}
			else
			{
				num2++;
			}
		}
	}

	private void AddNodeToResult(PatchSortingWrapper node)
	{
		result.Add(node);
		handledPatches.Add(node);
	}
}


using System;
using System.Collections.Generic;

private class PatchSortingWrapper : IComparable
{
	internal readonly HashSet<PatchSortingWrapper> after;

	internal readonly HashSet<PatchSortingWrapper> before;

	internal readonly Patch innerPatch;

	internal PatchSortingWrapper(Patch patch)
	{
		innerPatch = patch;
		before = new HashSet<PatchSortingWrapper>();
		after = new HashSet<PatchSortingWrapper>();
	}

	public int CompareTo(object obj)
	{
		return PatchInfoSerialization.PriorityComparer((obj is PatchSortingWrapper patchSortingWrapper) ? patchSortingWrapper.innerPatch : null, innerPatch.index, innerPatch.priority);
	}

	public override bool Equals(object obj)
	{
		if (obj is PatchSortingWrapper patchSortingWrapper)
		{
			return innerPatch.PatchMethod == patchSortingWrapper.innerPatch.PatchMethod;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return innerPatch.PatchMethod.GetHashCode();
	}

	internal void AddBeforeDependency(IEnumerable<PatchSortingWrapper> dependencies)
	{
		foreach (PatchSortingWrapper dependency in dependencies)
		{
			before.Add(dependency);
			dependency.after.Add(this);
		}
	}

	internal void AddAfterDependency(IEnumerable<PatchSortingWrapper> dependencies)
	{
		foreach (PatchSortingWrapper dependency in dependencies)
		{
			after.Add(dependency);
			dependency.before.Add(this);
		}
	}

	internal void RemoveAfterDependency(PatchSortingWrapper afterNode)
	{
		after.Remove(afterNode);
		afterNode.before.Remove(this);
	}

	internal void RemoveBeforeDependency(PatchSortingWrapper beforeNode)
	{
		before.Remove(beforeNode);
		beforeNode.after.Remove(this);
	}
}


using System.Collections.Generic;
using System.Linq;

internal class PatchDetailedComparer : IEqualityComparer<Patch>
{
	public bool Equals(Patch x, Patch y)
	{
		if (y != null && x != null && x.owner == y.owner && x.PatchMethod == y.PatchMethod && x.index == y.index && x.priority == y.priority && x.before.Length == y.before.Length && x.after.Length == y.after.Length && x.before.All(((IEnumerable<string>)y.before).Contains<string>))
		{
			return x.after.All(((IEnumerable<string>)y.after).Contains<string>);
		}
		return false;
	}

	public int GetHashCode(Patch obj)
	{
		return obj.GetHashCode();
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.Core;
using MonoMod.Utils;

internal static class PatchTools
{
	private static readonly Dictionary<MethodBase, ICoreDetour> detours = new Dictionary<MethodBase, ICoreDetour>();

	internal static readonly string harmonyMethodFullName = typeof(HarmonyMethod).FullName;

	internal static readonly string harmonyAttributeFullName = typeof(HarmonyAttribute).FullName;

	internal static readonly string harmonyPatchAllFullName = typeof(HarmonyPatchAll).FullName;

	internal static readonly MethodInfo m_GetExecutingAssemblyReplacementTranspiler = SymbolExtensions.GetMethodInfo(() => GetExecutingAssemblyTranspiler(null));

	internal static readonly MethodInfo m_GetExecutingAssembly = SymbolExtensions.GetMethodInfo(() => Assembly.GetExecutingAssembly());

	internal static readonly MethodInfo m_GetExecutingAssemblyReplacement = SymbolExtensions.GetMethodInfo(() => GetExecutingAssemblyReplacement());

	internal static void DetourMethod(MethodBase method, MethodBase replacement)
	{
		lock (detours)
		{
			if (detours.TryGetValue(method, out var value))
			{
				value.Dispose();
			}
			detours[method] = DetourFactory.Current.CreateDetour(method, replacement);
		}
	}

	private static Assembly GetExecutingAssemblyReplacement()
	{
		StackFrame stackFrame = new StackTrace().GetFrames()?.Skip(1).FirstOrDefault();
		if (stackFrame != null)
		{
			MethodBase originalMethodFromStackframe = Harmony.GetOriginalMethodFromStackframe(stackFrame);
			if ((object)originalMethodFromStackframe != null)
			{
				return originalMethodFromStackframe.Module.Assembly;
			}
		}
		return Assembly.GetExecutingAssembly();
	}

	internal static IEnumerable<CodeInstruction> GetExecutingAssemblyTranspiler(IEnumerable<CodeInstruction> instructions)
	{
		return instructions.MethodReplacer(m_GetExecutingAssembly, m_GetExecutingAssemblyReplacement);
	}

	public static MethodInfo CreateMethod(string name, Type returnType, List<KeyValuePair<string, Type>> parameters, Action<ILGenerator> generator)
	{
		Type[] parameterTypes = parameters.Select((KeyValuePair<string, Type> p) => p.Value).ToArray();
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(name, returnType, parameterTypes);
		for (int i = 0; i < parameters.Count; i++)
		{
			dynamicMethodDefinition.Definition.Parameters[i].Name = parameters[i].Key;
		}
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		generator(iLGenerator);
		return dynamicMethodDefinition.Generate();
	}

	internal static MethodInfo GetPatchMethod(Type patchType, string attributeName)
	{
		MethodInfo methodInfo = patchType.GetMethods(AccessTools.all).FirstOrDefault((MethodInfo m) => m.GetCustomAttributes(inherit: true).Any((object a) => a.GetType().FullName == attributeName));
		if ((object)methodInfo == null)
		{
			string name = attributeName.Replace("HarmonyLib.Harmony", "");
			methodInfo = patchType.GetMethod(name, AccessTools.all);
		}
		return methodInfo;
	}

	internal static AssemblyBuilder DefineDynamicAssembly(string name)
	{
		AssemblyName assemblyName = new AssemblyName(name);
		return AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
	}

	internal static List<AttributePatch> GetPatchMethods(Type type)
	{
		return (from method in AccessTools.GetDeclaredMethods(type)
			select AttributePatch.Create(method) into attributePatch
			where attributePatch != null
			select attributePatch).ToList();
	}

	internal static MethodBase GetOriginalMethod(this HarmonyMethod attr)
	{
		try
		{
			MethodType? methodType = attr.methodType;
			if (methodType.HasValue)
			{
				switch (methodType.GetValueOrDefault())
				{
				case MethodType.Normal:
					if (attr.methodName == null)
					{
						return null;
					}
					return AccessTools.DeclaredMethod(attr.declaringType, attr.methodName, attr.argumentTypes);
				case MethodType.Getter:
					if (attr.methodName == null)
					{
						return AccessTools.DeclaredIndexer(attr.declaringType, attr.argumentTypes).GetGetMethod(nonPublic: true);
					}
					return AccessTools.DeclaredProperty(attr.declaringType, attr.methodName).GetGetMethod(nonPublic: true);
				case MethodType.Setter:
					if (attr.methodName == null)
					{
						return AccessTools.DeclaredIndexer(attr.declaringType, attr.argumentTypes).GetSetMethod(nonPublic: true);
					}
					return AccessTools.DeclaredProperty(attr.declaringType, attr.methodName).GetSetMethod(nonPublic: true);
				case MethodType.Constructor:
					return AccessTools.DeclaredConstructor(attr.declaringType, attr.argumentTypes);
				case MethodType.StaticConstructor:
					return (from c in AccessTools.GetDeclaredConstructors(attr.declaringType, null)
						where c.IsStatic
						select c).FirstOrDefault();
				case MethodType.Enumerator:
				{
					if (attr.methodName == null)
					{
						return null;
					}
					MethodInfo method2 = AccessTools.DeclaredMethod(attr.declaringType, attr.methodName, attr.argumentTypes);
					return AccessTools.EnumeratorMoveNext(method2);
				}
				case MethodType.Async:
				{
					if (attr.methodName == null)
					{
						return null;
					}
					MethodInfo method = AccessTools.DeclaredMethod(attr.declaringType, attr.methodName, attr.argumentTypes);
					return AccessTools.AsyncMoveNext(method);
				}
				}
			}
		}
		catch (AmbiguousMatchException ex)
		{
			throw new HarmonyException("Ambiguous match for HarmonyMethod[" + attr.Description() + "]", ex.InnerException ?? ex);
		}
		return null;
	}
}


public enum MethodType
{
	Normal,
	Getter,
	Setter,
	Constructor,
	StaticConstructor,
	Enumerator,
	Async
}


public enum ArgumentType
{
	Normal,
	Ref,
	Out,
	Pointer
}


public enum HarmonyPatchType
{
	All,
	Prefix,
	Postfix,
	Transpiler,
	Finalizer,
	ReversePatch
}


public enum HarmonyReversePatchType
{
	Original,
	Snapshot
}


public enum MethodDispatchType
{
	VirtualCall,
	Call
}


using System;
using HarmonyLib;

public class HarmonyAttribute : Attribute
{
	public HarmonyMethod info = new HarmonyMethod();
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public class HarmonyPatchCategory : HarmonyAttribute
{
	public HarmonyPatchCategory(string category)
	{
		info.category = category;
	}
}


using System;
using System.Collections.Generic;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Delegate, AllowMultiple = true)]
public class HarmonyPatch : HarmonyAttribute
{
	public HarmonyPatch()
	{
	}

	public HarmonyPatch(Type declaringType)
	{
		info.declaringType = declaringType;
	}

	public HarmonyPatch(Type declaringType, Type[] argumentTypes)
	{
		info.declaringType = declaringType;
		info.argumentTypes = argumentTypes;
	}

	public HarmonyPatch(Type declaringType, string methodName)
	{
		info.declaringType = declaringType;
		info.methodName = methodName;
	}

	public HarmonyPatch(Type declaringType, string methodName, params Type[] argumentTypes)
	{
		info.declaringType = declaringType;
		info.methodName = methodName;
		info.argumentTypes = argumentTypes;
	}

	public HarmonyPatch(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
	{
		info.declaringType = declaringType;
		info.methodName = methodName;
		ParseSpecialArguments(argumentTypes, argumentVariations);
	}

	public HarmonyPatch(Type declaringType, MethodType methodType)
	{
		info.declaringType = declaringType;
		info.methodType = methodType;
	}

	public HarmonyPatch(Type declaringType, MethodType methodType, params Type[] argumentTypes)
	{
		info.declaringType = declaringType;
		info.methodType = methodType;
		info.argumentTypes = argumentTypes;
	}

	public HarmonyPatch(Type declaringType, MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations)
	{
		info.declaringType = declaringType;
		info.methodType = methodType;
		ParseSpecialArguments(argumentTypes, argumentVariations);
	}

	public HarmonyPatch(Type declaringType, string methodName, MethodType methodType)
	{
		info.declaringType = declaringType;
		info.methodName = methodName;
		info.methodType = methodType;
	}

	public HarmonyPatch(string methodName)
	{
		info.methodName = methodName;
	}

	public HarmonyPatch(string methodName, params Type[] argumentTypes)
	{
		info.methodName = methodName;
		info.argumentTypes = argumentTypes;
	}

	public HarmonyPatch(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
	{
		info.methodName = methodName;
		ParseSpecialArguments(argumentTypes, argumentVariations);
	}

	public HarmonyPatch(string methodName, MethodType methodType)
	{
		info.methodName = methodName;
		info.methodType = methodType;
	}

	public HarmonyPatch(MethodType methodType)
	{
		info.methodType = methodType;
	}

	public HarmonyPatch(MethodType methodType, params Type[] argumentTypes)
	{
		info.methodType = methodType;
		info.argumentTypes = argumentTypes;
	}

	public HarmonyPatch(MethodType methodType, Type[] argumentTypes, ArgumentType[] argumentVariations)
	{
		info.methodType = methodType;
		ParseSpecialArguments(argumentTypes, argumentVariations);
	}

	public HarmonyPatch(Type[] argumentTypes)
	{
		info.argumentTypes = argumentTypes;
	}

	public HarmonyPatch(Type[] argumentTypes, ArgumentType[] argumentVariations)
	{
		ParseSpecialArguments(argumentTypes, argumentVariations);
	}

	public HarmonyPatch(string typeName, string methodName, MethodType methodType = MethodType.Normal)
	{
		info.declaringType = AccessTools.TypeByName(typeName);
		info.methodName = methodName;
		info.methodType = methodType;
	}

	private void ParseSpecialArguments(Type[] argumentTypes, ArgumentType[] argumentVariations)
	{
		if (argumentVariations == null || argumentVariations.Length == 0)
		{
			info.argumentTypes = argumentTypes;
			return;
		}
		if (argumentTypes.Length < argumentVariations.Length)
		{
			throw new ArgumentException("argumentVariations contains more elements than argumentTypes", "argumentVariations");
		}
		List<Type> list = new List<Type>();
		for (int i = 0; i < argumentTypes.Length; i++)
		{
			Type type = argumentTypes[i];
			switch (argumentVariations[i])
			{
			case ArgumentType.Ref:
			case ArgumentType.Out:
				type = type.MakeByRefType();
				break;
			case ArgumentType.Pointer:
				type = type.MakePointerType();
				break;
			}
			list.Add(type);
		}
		info.argumentTypes = list.ToArray();
	}
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Delegate, AllowMultiple = true)]
public class HarmonyDelegate : HarmonyPatch
{
	public HarmonyDelegate(Type declaringType)
		: base(declaringType)
	{
	}

	public HarmonyDelegate(Type declaringType, Type[] argumentTypes)
		: base(declaringType, argumentTypes)
	{
	}

	public HarmonyDelegate(Type declaringType, string methodName)
		: base(declaringType, methodName)
	{
	}

	public HarmonyDelegate(Type declaringType, string methodName, params Type[] argumentTypes)
		: base(declaringType, methodName, argumentTypes)
	{
	}

	public HarmonyDelegate(Type declaringType, string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
		: base(declaringType, methodName, argumentTypes, argumentVariations)
	{
	}

	public HarmonyDelegate(Type declaringType, MethodDispatchType methodDispatchType)
		: base(declaringType, MethodType.Normal)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(Type declaringType, MethodDispatchType methodDispatchType, params Type[] argumentTypes)
		: base(declaringType, MethodType.Normal, argumentTypes)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(Type declaringType, MethodDispatchType methodDispatchType, Type[] argumentTypes, ArgumentType[] argumentVariations)
		: base(declaringType, MethodType.Normal, argumentTypes, argumentVariations)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(Type declaringType, string methodName, MethodDispatchType methodDispatchType)
		: base(declaringType, methodName, MethodType.Normal)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(string methodName)
		: base(methodName)
	{
	}

	public HarmonyDelegate(string methodName, params Type[] argumentTypes)
		: base(methodName, argumentTypes)
	{
	}

	public HarmonyDelegate(string methodName, Type[] argumentTypes, ArgumentType[] argumentVariations)
		: base(methodName, argumentTypes, argumentVariations)
	{
	}

	public HarmonyDelegate(string methodName, MethodDispatchType methodDispatchType)
		: base(methodName, MethodType.Normal)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(MethodDispatchType methodDispatchType)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(MethodDispatchType methodDispatchType, params Type[] argumentTypes)
		: base(MethodType.Normal, argumentTypes)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(MethodDispatchType methodDispatchType, Type[] argumentTypes, ArgumentType[] argumentVariations)
		: base(MethodType.Normal, argumentTypes, argumentVariations)
	{
		info.nonVirtualDelegate = methodDispatchType == MethodDispatchType.Call;
	}

	public HarmonyDelegate(Type[] argumentTypes)
		: base(argumentTypes)
	{
	}

	public HarmonyDelegate(Type[] argumentTypes, ArgumentType[] argumentVariations)
		: base(argumentTypes, argumentVariations)
	{
	}
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]
public class HarmonyReversePatch : HarmonyAttribute
{
	public HarmonyReversePatch(HarmonyReversePatchType type = HarmonyReversePatchType.Original)
	{
		info.reversePatchType = type;
	}
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class)]
public class HarmonyPatchAll : HarmonyAttribute
{
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class HarmonyPriority : HarmonyAttribute
{
	public HarmonyPriority(int priority)
	{
		info.priority = priority;
	}
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class HarmonyBefore : HarmonyAttribute
{
	public HarmonyBefore(params string[] before)
	{
		info.before = before;
	}
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class HarmonyAfter : HarmonyAttribute
{
	public HarmonyAfter(params string[] after)
	{
		info.after = after;
	}
}


using System;
using HarmonyLib;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class HarmonyDebug : HarmonyAttribute
{
	public HarmonyDebug()
	{
		info.debug = true;
	}
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyPrepare : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyCleanup : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyTargetMethod : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyTargetMethods : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyPrefix : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyPostfix : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyTranspiler : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class HarmonyFinalizer : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Parameter, AllowMultiple = true)]
public class HarmonyArgument : Attribute
{
	public string OriginalName { get; private set; }

	public int Index { get; private set; }

	public string NewName { get; private set; }

	public HarmonyArgument(string originalName)
		: this(originalName, null)
	{
	}

	public HarmonyArgument(int index)
		: this(index, null)
	{
	}

	public HarmonyArgument(string originalName, string newName)
	{
		OriginalName = originalName;
		Index = -1;
		NewName = newName;
	}

	public HarmonyArgument(int index, string name)
	{
		OriginalName = null;
		Index = index;
		NewName = name;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.Utils;

public class CodeInstruction
{
	internal static class State
	{
		internal static readonly Dictionary<int, Delegate> closureCache = new Dictionary<int, Delegate>();
	}

	public OpCode opcode;

	public object operand;

	public List<Label> labels = new List<Label>();

	public List<ExceptionBlock> blocks = new List<ExceptionBlock>();

	internal CodeInstruction()
	{
	}

	public CodeInstruction(OpCode opcode, object operand = null)
	{
		this.opcode = opcode;
		this.operand = operand;
	}

	public CodeInstruction(CodeInstruction instruction)
	{
		opcode = instruction.opcode;
		operand = instruction.operand;
		List<Label> list = instruction.labels;
		List<Label> list2 = new List<Label>(list.Count);
		list2.AddRange(list);
		labels = list2;
		List<ExceptionBlock> list3 = instruction.blocks;
		List<ExceptionBlock> list4 = new List<ExceptionBlock>(list3.Count);
		list4.AddRange(list3);
		blocks = list4;
	}

	public CodeInstruction Clone()
	{
		return new CodeInstruction(this)
		{
			labels = new List<Label>(),
			blocks = new List<ExceptionBlock>()
		};
	}

	public CodeInstruction Clone(OpCode opcode)
	{
		CodeInstruction codeInstruction = Clone();
		codeInstruction.opcode = opcode;
		return codeInstruction;
	}

	public CodeInstruction Clone(object operand)
	{
		CodeInstruction codeInstruction = Clone();
		codeInstruction.operand = operand;
		return codeInstruction;
	}

	public static CodeInstruction Call(Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		MethodInfo methodInfo = AccessTools.Method(type, name, parameters, generics);
		if ((object)methodInfo == null)
		{
			throw new ArgumentException($"No method found for type={type}, name={name}, parameters={parameters.Description()}, generics={generics.Description()}");
		}
		return new CodeInstruction(OpCodes.Call, methodInfo);
	}

	public static CodeInstruction Call(string typeColonMethodname, Type[] parameters = null, Type[] generics = null)
	{
		MethodInfo methodInfo = AccessTools.Method(typeColonMethodname, parameters, generics);
		if ((object)methodInfo == null)
		{
			throw new ArgumentException($"No method found for {typeColonMethodname}, parameters={parameters.Description()}, generics={generics.Description()}");
		}
		return new CodeInstruction(OpCodes.Call, methodInfo);
	}

	public static CodeInstruction Call(Expression<Action> expression)
	{
		return new CodeInstruction(OpCodes.Call, SymbolExtensions.GetMethodInfo(expression));
	}

	public static CodeInstruction Call<T>(Expression<Action<T>> expression)
	{
		return new CodeInstruction(OpCodes.Call, SymbolExtensions.GetMethodInfo(expression));
	}

	public static CodeInstruction Call<T, TResult>(Expression<Func<T, TResult>> expression)
	{
		return new CodeInstruction(OpCodes.Call, SymbolExtensions.GetMethodInfo(expression));
	}

	public static CodeInstruction Call(LambdaExpression expression)
	{
		return new CodeInstruction(OpCodes.Call, SymbolExtensions.GetMethodInfo(expression));
	}

	public static CodeInstruction CallClosure<T>(T closure) where T : Delegate
	{
		if (closure.Method.IsStatic && closure.Target == null)
		{
			return new CodeInstruction(OpCodes.Call, closure.Method);
		}
		Type[] array = (from x in closure.Method.GetParameters()
			select x.ParameterType).ToArray();
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(closure.Method.Name, closure.Method.ReturnType, array);
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		Type type = closure.Target.GetType();
		if (closure.Target != null && type.GetFields().Any((FieldInfo x) => !x.IsStatic))
		{
			int count = State.closureCache.Count;
			State.closureCache[count] = closure;
			iLGenerator.Emit(OpCodes.Ldsfld, AccessTools.Field(typeof(Transpilers), "closureCache"));
			iLGenerator.Emit(OpCodes.Ldc_I4, count);
			iLGenerator.Emit(OpCodes.Callvirt, AccessTools.PropertyGetter(typeof(Dictionary<int, Delegate>), "Item"));
		}
		else
		{
			if (closure.Target == null)
			{
				iLGenerator.Emit(OpCodes.Ldnull);
			}
			else
			{
				iLGenerator.Emit(OpCodes.Newobj, AccessTools.FirstConstructor(type, (ConstructorInfo x) => !x.IsStatic && x.GetParameters().Length == 0));
			}
			iLGenerator.Emit(OpCodes.Ldftn, closure.Method);
			iLGenerator.Emit(OpCodes.Newobj, AccessTools.Constructor(typeof(T), new Type[2]
			{
				typeof(object),
				typeof(IntPtr)
			}));
		}
		for (int i = 0; i < array.Length; i++)
		{
			iLGenerator.Emit(OpCodes.Ldarg, i);
		}
		iLGenerator.Emit(OpCodes.Callvirt, AccessTools.Method(typeof(T), "Invoke"));
		iLGenerator.Emit(OpCodes.Ret);
		return new CodeInstruction(OpCodes.Call, dynamicMethodDefinition.Generate());
	}

	public static CodeInstruction LoadField(Type type, string name, bool useAddress = false)
	{
		FieldInfo fieldInfo = AccessTools.Field(type, name);
		if ((object)fieldInfo == null)
		{
			throw new ArgumentException($"No field found for {type} and {name}");
		}
		return new CodeInstruction((!useAddress) ? (fieldInfo.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld) : (fieldInfo.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda), fieldInfo);
	}

	public static CodeInstruction StoreField(Type type, string name)
	{
		FieldInfo fieldInfo = AccessTools.Field(type, name);
		if ((object)fieldInfo == null)
		{
			throw new ArgumentException($"No field found for {type} and {name}");
		}
		return new CodeInstruction(fieldInfo.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fieldInfo);
	}

	public static CodeInstruction LoadLocal(int index, bool useAddress = false)
	{
		if (useAddress)
		{
			if (index < 256)
			{
				return new CodeInstruction(OpCodes.Ldloca_S, Convert.ToByte(index));
			}
			return new CodeInstruction(OpCodes.Ldloca, index);
		}
		if (index == 0)
		{
			return new CodeInstruction(OpCodes.Ldloc_0);
		}
		if (index == 1)
		{
			return new CodeInstruction(OpCodes.Ldloc_1);
		}
		if (index == 2)
		{
			return new CodeInstruction(OpCodes.Ldloc_2);
		}
		if (index == 3)
		{
			return new CodeInstruction(OpCodes.Ldloc_3);
		}
		if (index < 256)
		{
			return new CodeInstruction(OpCodes.Ldloc_S, Convert.ToByte(index));
		}
		return new CodeInstruction(OpCodes.Ldloc, index);
	}

	public static CodeInstruction StoreLocal(int index)
	{
		if (index == 0)
		{
			return new CodeInstruction(OpCodes.Stloc_0);
		}
		if (index == 1)
		{
			return new CodeInstruction(OpCodes.Stloc_1);
		}
		if (index == 2)
		{
			return new CodeInstruction(OpCodes.Stloc_2);
		}
		if (index == 3)
		{
			return new CodeInstruction(OpCodes.Stloc_3);
		}
		if (index < 256)
		{
			return new CodeInstruction(OpCodes.Stloc_S, Convert.ToByte(index));
		}
		return new CodeInstruction(OpCodes.Stloc, index);
	}

	public static CodeInstruction LoadArgument(int index, bool useAddress = false)
	{
		if (useAddress)
		{
			if (index < 256)
			{
				return new CodeInstruction(OpCodes.Ldarga_S, Convert.ToByte(index));
			}
			return new CodeInstruction(OpCodes.Ldarga, index);
		}
		if (index == 0)
		{
			return new CodeInstruction(OpCodes.Ldarg_0);
		}
		if (index == 1)
		{
			return new CodeInstruction(OpCodes.Ldarg_1);
		}
		if (index == 2)
		{
			return new CodeInstruction(OpCodes.Ldarg_2);
		}
		if (index == 3)
		{
			return new CodeInstruction(OpCodes.Ldarg_3);
		}
		if (index < 256)
		{
			return new CodeInstruction(OpCodes.Ldarg_S, Convert.ToByte(index));
		}
		return new CodeInstruction(OpCodes.Ldarg, index);
	}

	public static CodeInstruction StoreArgument(int index)
	{
		if (index < 256)
		{
			return new CodeInstruction(OpCodes.Starg_S, Convert.ToByte(index));
		}
		return new CodeInstruction(OpCodes.Starg, index);
	}

	public override string ToString()
	{
		List<string> list = new List<string>();
		foreach (Label label in labels)
		{
			list.Add($"Label{label.GetHashCode()}");
		}
		foreach (ExceptionBlock block in blocks)
		{
			list.Add("EX_" + block.blockType.ToString().Replace("Block", ""));
		}
		string text = ((list.Count > 0) ? (" [" + string.Join(", ", list.ToArray()) + "]") : "");
		string text2 = Emitter.FormatArgument(operand);
		if (text2.Length > 0)
		{
			text2 = " " + text2;
		}
		OpCode opCode = opcode;
		return opCode.ToString() + text2 + text;
	}
}


using System;
using System.Collections.Generic;

internal static class State
{
	internal static readonly Dictionary<int, Delegate> closureCache = new Dictionary<int, Delegate>();
}


public enum ExceptionBlockType
{
	BeginExceptionBlock,
	BeginCatchBlock,
	BeginExceptFilterBlock,
	BeginFaultBlock,
	BeginFinallyBlock,
	EndExceptionBlock
}


using System;
using HarmonyLib;

public class ExceptionBlock
{
	public ExceptionBlockType blockType = blockType;

	public Type catchType = catchType ?? typeof(object);

	public ExceptionBlock(ExceptionBlockType blockType, Type catchType = null)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using HarmonyLib;
using MonoMod.Core.Platforms;

public class Harmony
{
	public static bool DEBUG;

	public string Id { get; private set; }

	public Harmony(string id)
	{
		if (string.IsNullOrEmpty(id))
		{
			throw new ArgumentException("id cannot be null or empty");
		}
		try
		{
			string environmentVariable = Environment.GetEnvironmentVariable("HARMONY_DEBUG");
			if (environmentVariable != null && environmentVariable.Length > 0)
			{
				environmentVariable = environmentVariable.Trim();
				DEBUG = environmentVariable == "1" || bool.Parse(environmentVariable);
			}
		}
		catch
		{
		}
		if (DEBUG)
		{
			Assembly assembly = typeof(Harmony).Assembly;
			Version version = assembly.GetName().Version;
			string value = assembly.Location;
			string value2 = Environment.Version.ToString();
			string value3 = Environment.OSVersion.Platform.ToString();
			if (string.IsNullOrEmpty(value))
			{
				value = new Uri(assembly.CodeBase).LocalPath;
			}
			FileLog.Log($"### Harmony id={id}, version={version}, location={value}, env/clr={value2}, platform={value3}");
			MethodBase outsideCaller = AccessTools.GetOutsideCaller();
			if ((object)outsideCaller.DeclaringType != null)
			{
				Assembly assembly2 = outsideCaller.DeclaringType.Assembly;
				value = assembly2.Location;
				if (string.IsNullOrEmpty(value))
				{
					value = new Uri(assembly2.CodeBase).LocalPath;
				}
				FileLog.Log("### Started from " + outsideCaller.FullDescription() + ", location " + value);
				FileLog.Log($"### At {DateTime.Now:yyyy-MM-dd hh.mm.ss}");
			}
		}
		Id = id;
	}

	public void PatchAll()
	{
		MethodBase method = new StackTrace().GetFrame(1).GetMethod();
		Assembly assembly = method.ReflectedType.Assembly;
		PatchAll(assembly);
	}

	public PatchProcessor CreateProcessor(MethodBase original)
	{
		return new PatchProcessor(this, original);
	}

	public PatchClassProcessor CreateClassProcessor(Type type)
	{
		return new PatchClassProcessor(this, type);
	}

	public ReversePatcher CreateReversePatcher(MethodBase original, HarmonyMethod standin)
	{
		return new ReversePatcher(this, original, standin);
	}

	public void PatchAll(Assembly assembly)
	{
		AccessTools.GetTypesFromAssembly(assembly).Do(delegate(Type type)
		{
			CreateClassProcessor(type).Patch();
		});
	}

	public void PatchAllUncategorized()
	{
		MethodBase method = new StackTrace().GetFrame(1).GetMethod();
		Assembly assembly = method.ReflectedType.Assembly;
		PatchAllUncategorized(assembly);
	}

	public void PatchAllUncategorized(Assembly assembly)
	{
		PatchClassProcessor[] sequence = AccessTools.GetTypesFromAssembly(assembly).Select(CreateClassProcessor).ToArray();
		sequence.DoIf((PatchClassProcessor patchClass) => string.IsNullOrEmpty(patchClass.Category), delegate(PatchClassProcessor patchClass)
		{
			patchClass.Patch();
		});
	}

	public void PatchCategory(string category)
	{
		MethodBase method = new StackTrace().GetFrame(1).GetMethod();
		Assembly assembly = method.ReflectedType.Assembly;
		PatchCategory(assembly, category);
	}

	public void PatchCategory(Assembly assembly, string category)
	{
		AccessTools.GetTypesFromAssembly(assembly).Where(delegate(Type type)
		{
			List<HarmonyMethod> fromType = HarmonyMethodExtensions.GetFromType(type);
			HarmonyMethod harmonyMethod = HarmonyMethod.Merge(fromType);
			return harmonyMethod.category == category;
		}).Do(delegate(Type type)
		{
			CreateClassProcessor(type).Patch();
		});
	}

	public MethodInfo Patch(MethodBase original, HarmonyMethod prefix = null, HarmonyMethod postfix = null, HarmonyMethod transpiler = null, HarmonyMethod finalizer = null)
	{
		PatchProcessor patchProcessor = CreateProcessor(original);
		patchProcessor.AddPrefix(prefix);
		patchProcessor.AddPostfix(postfix);
		patchProcessor.AddTranspiler(transpiler);
		patchProcessor.AddFinalizer(finalizer);
		return patchProcessor.Patch();
	}

	public static MethodInfo ReversePatch(MethodBase original, HarmonyMethod standin, MethodInfo transpiler = null)
	{
		return PatchFunctions.ReversePatch(standin, original, transpiler);
	}

	public void UnpatchAll(string harmonyID = null)
	{
		List<MethodBase> list = GetAllPatchedMethods().ToList();
		foreach (MethodBase original in list)
		{
			bool flag = original.HasMethodBody();
			Patches patchInfo2 = GetPatchInfo(original);
			if (flag)
			{
				patchInfo2.Postfixes.DoIf(IDCheck, delegate(Patch patchInfo)
				{
					Unpatch(original, patchInfo.PatchMethod);
				});
				patchInfo2.Prefixes.DoIf(IDCheck, delegate(Patch patchInfo)
				{
					Unpatch(original, patchInfo.PatchMethod);
				});
			}
			patchInfo2.Transpilers.DoIf(IDCheck, delegate(Patch patchInfo)
			{
				Unpatch(original, patchInfo.PatchMethod);
			});
			if (flag)
			{
				patchInfo2.Finalizers.DoIf(IDCheck, delegate(Patch patchInfo)
				{
					Unpatch(original, patchInfo.PatchMethod);
				});
			}
		}
		bool IDCheck(Patch patchInfo)
		{
			if (harmonyID != null)
			{
				return patchInfo.owner == harmonyID;
			}
			return true;
		}
	}

	public void Unpatch(MethodBase original, HarmonyPatchType type, string harmonyID = "*")
	{
		PatchProcessor patchProcessor = CreateProcessor(original);
		patchProcessor.Unpatch(type, harmonyID);
	}

	public void Unpatch(MethodBase original, MethodInfo patch)
	{
		PatchProcessor patchProcessor = CreateProcessor(original);
		patchProcessor.Unpatch(patch);
	}

	public static bool HasAnyPatches(string harmonyID)
	{
		return (from original in GetAllPatchedMethods()
			select GetPatchInfo(original)).Any((Patches info) => info.Owners.Contains(harmonyID));
	}

	public static Patches GetPatchInfo(MethodBase method)
	{
		return PatchProcessor.GetPatchInfo(method);
	}

	public IEnumerable<MethodBase> GetPatchedMethods()
	{
		return from original in GetAllPatchedMethods()
			where GetPatchInfo(original).Owners.Contains(Id)
			select original;
	}

	public static IEnumerable<MethodBase> GetAllPatchedMethods()
	{
		return PatchProcessor.GetAllPatchedMethods();
	}

	public static MethodBase GetOriginalMethod(MethodInfo replacement)
	{
		if (replacement == null)
		{
			throw new ArgumentNullException("replacement");
		}
		MethodInfo replacement2 = PlatformTriple.Current.GetIdentifiable(replacement) as MethodInfo;
		return HarmonySharedState.GetOriginal(replacement2);
	}

	public static MethodBase GetMethodFromStackframe(StackFrame frame)
	{
		if (frame == null)
		{
			throw new ArgumentNullException("frame");
		}
		return HarmonySharedState.FindReplacement(frame) ?? frame.GetMethod();
	}

	public static MethodBase GetOriginalMethodFromStackframe(StackFrame frame)
	{
		MethodBase methodBase = GetMethodFromStackframe(frame);
		if (methodBase is MethodInfo replacement)
		{
			methodBase = GetOriginalMethod(replacement) ?? methodBase;
		}
		return methodBase;
	}

	public static Dictionary<string, Version> VersionInfo(out Version currentVersion)
	{
		return PatchProcessor.VersionInfo(out currentVersion);
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using HarmonyLib;

[Serializable]
public class HarmonyException : Exception
{
	private Dictionary<int, CodeInstruction> instructions;

	private int errorOffset;

	internal HarmonyException()
	{
	}

	internal HarmonyException(string message)
		: base(message)
	{
	}

	internal HarmonyException(string message, Exception innerException)
		: base(message, innerException)
	{
	}

	protected HarmonyException(SerializationInfo serializationInfo, StreamingContext streamingContext)
	{
		throw new NotImplementedException();
	}

	internal HarmonyException(Exception innerException, Dictionary<int, CodeInstruction> instructions, int errorOffset)
		: base("IL Compile Error", innerException)
	{
		this.instructions = instructions;
		this.errorOffset = errorOffset;
	}

	internal static Exception Create(Exception ex, Dictionary<int, CodeInstruction> finalInstructions)
	{
		Match match = Regex.Match(ex.Message.TrimEnd(Array.Empty<char>()), "Reason: Invalid IL code in.+: IL_(\\d{4}): (.+)$");
		if (!match.Success)
		{
			return ex;
		}
		int num = int.Parse(match.Groups[1].Value, NumberStyles.HexNumber);
		Regex.Replace(match.Groups[2].Value, " {2,}", " ");
		if (ex is HarmonyException ex2)
		{
			ex2.instructions = finalInstructions;
			ex2.errorOffset = num;
			return ex2;
		}
		return new HarmonyException(ex, finalInstructions, num);
	}

	public List<KeyValuePair<int, CodeInstruction>> GetInstructionsWithOffsets()
	{
		List<KeyValuePair<int, CodeInstruction>> list = new List<KeyValuePair<int, CodeInstruction>>();
		list.AddRange(instructions.OrderBy((KeyValuePair<int, CodeInstruction> ins) => ins.Key));
		return list;
	}

	public List<CodeInstruction> GetInstructions()
	{
		return (from ins in instructions
			orderby ins.Key
			select ins.Value).ToList();
	}

	public int GetErrorOffset()
	{
		return errorOffset;
	}

	public int GetErrorIndex()
	{
		if (instructions.TryGetValue(errorOffset, out var value))
		{
			return GetInstructions().IndexOf(value);
		}
		return -1;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

public class HarmonyMethod
{
	public MethodInfo method;

	public string category;

	public Type declaringType;

	public string methodName;

	public MethodType? methodType;

	public Type[] argumentTypes;

	public int priority = -1;

	public string[] before;

	public string[] after;

	public HarmonyReversePatchType? reversePatchType;

	public bool? debug;

	public bool nonVirtualDelegate;

	public HarmonyMethod()
	{
	}

	private void ImportMethod(MethodInfo theMethod)
	{
		method = theMethod;
		if ((object)method != null)
		{
			List<HarmonyMethod> fromMethod = HarmonyMethodExtensions.GetFromMethod(method);
			if (fromMethod != null)
			{
				Merge(fromMethod).CopyTo(this);
			}
		}
	}

	public HarmonyMethod(MethodInfo method)
	{
		if ((object)method == null)
		{
			throw new ArgumentNullException("method");
		}
		ImportMethod(method);
	}

	public HarmonyMethod(Delegate @delegate)
		: this(@delegate.Method)
	{
	}

	public HarmonyMethod(MethodInfo method, int priority = -1, string[] before = null, string[] after = null, bool? debug = null)
	{
		if ((object)method == null)
		{
			throw new ArgumentNullException("method");
		}
		ImportMethod(method);
		this.priority = priority;
		this.before = before;
		this.after = after;
		this.debug = debug;
	}

	public HarmonyMethod(Delegate @delegate, int priority = -1, string[] before = null, string[] after = null, bool? debug = null)
		: this(@delegate.Method, priority, before, after, debug)
	{
	}

	public HarmonyMethod(Type methodType, string methodName, Type[] argumentTypes = null)
	{
		MethodInfo methodInfo = AccessTools.Method(methodType, methodName, argumentTypes);
		if ((object)methodInfo == null)
		{
			throw new ArgumentException($"Cannot not find method for type {methodType} and name {methodName} and parameters {argumentTypes?.Description()}");
		}
		ImportMethod(methodInfo);
	}

	public static List<string> HarmonyFields()
	{
		return (from s in AccessTools.GetFieldNames(typeof(HarmonyMethod))
			where s != "method"
			select s).ToList();
	}

	public static HarmonyMethod Merge(List<HarmonyMethod> attributes)
	{
		HarmonyMethod harmonyMethod = new HarmonyMethod();
		if (attributes == null || attributes.Count == 0)
		{
			return harmonyMethod;
		}
		Traverse resultTrv = Traverse.Create(harmonyMethod);
		attributes.ForEach(delegate(HarmonyMethod attribute)
		{
			Traverse trv = Traverse.Create(attribute);
			HarmonyFields().ForEach(delegate(string f)
			{
				object value = trv.Field(f).GetValue();
				if (value != null && (f != "priority" || (int)value != -1))
				{
					HarmonyMethodExtensions.SetValue(resultTrv, f, value);
				}
			});
		});
		return harmonyMethod;
	}

	public override string ToString()
	{
		string result = "";
		Traverse trv = Traverse.Create(this);
		HarmonyFields().ForEach(delegate(string f)
		{
			if (result.Length > 0)
			{
				result += ", ";
			}
			result += $"{f}={trv.Field(f).GetValue()}";
		});
		return "HarmonyMethod[" + result + "]";
	}

	internal string Description()
	{
		string value = (((object)declaringType != null) ? declaringType.FullName : "undefined");
		string value2 = methodName ?? "undefined";
		string value3 = (methodType.HasValue ? methodType.Value.ToString() : "undefined");
		string value4 = ((argumentTypes != null) ? argumentTypes.Description() : "undefined");
		return $"(class={value}, methodname={value2}, type={value3}, args={value4})";
	}

	public static implicit operator HarmonyMethod(MethodInfo method)
	{
		return new HarmonyMethod(method);
	}

	public static implicit operator HarmonyMethod(Delegate @delegate)
	{
		return new HarmonyMethod(@delegate);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

public static class HarmonyMethodExtensions
{
	internal static void SetValue(Traverse trv, string name, object val)
	{
		if (val != null)
		{
			Traverse traverse = trv.Field(name);
			if (name == "methodType" || name == "reversePatchType")
			{
				Type underlyingType = Nullable.GetUnderlyingType(traverse.GetValueType());
				val = Enum.ToObject(underlyingType, (int)val);
			}
			traverse.SetValue(val);
		}
	}

	public static void CopyTo(this HarmonyMethod from, HarmonyMethod to)
	{
		if (to == null)
		{
			return;
		}
		Traverse fromTrv = Traverse.Create(from);
		Traverse toTrv = Traverse.Create(to);
		HarmonyMethod.HarmonyFields().ForEach(delegate(string f)
		{
			object value = fromTrv.Field(f).GetValue();
			if (value != null)
			{
				SetValue(toTrv, f, value);
			}
		});
	}

	public static HarmonyMethod Clone(this HarmonyMethod original)
	{
		HarmonyMethod harmonyMethod = new HarmonyMethod();
		original.CopyTo(harmonyMethod);
		return harmonyMethod;
	}

	public static HarmonyMethod Merge(this HarmonyMethod master, HarmonyMethod detail)
	{
		if (detail == null)
		{
			return master;
		}
		HarmonyMethod harmonyMethod = new HarmonyMethod();
		Traverse resultTrv = Traverse.Create(harmonyMethod);
		Traverse masterTrv = Traverse.Create(master);
		Traverse detailTrv = Traverse.Create(detail);
		HarmonyMethod.HarmonyFields().ForEach(delegate(string f)
		{
			object value = masterTrv.Field(f).GetValue();
			object value2 = detailTrv.Field(f).GetValue();
			if (f != "priority" || (int)value2 != -1)
			{
				SetValue(resultTrv, f, value2 ?? value);
			}
		});
		return harmonyMethod;
	}

	private static HarmonyMethod GetHarmonyMethodInfo(object attribute)
	{
		FieldInfo field = attribute.GetType().GetField("info", AccessTools.all);
		if ((object)field == null)
		{
			return null;
		}
		if (field.FieldType.FullName != PatchTools.harmonyMethodFullName)
		{
			return null;
		}
		object value = field.GetValue(attribute);
		return AccessTools.MakeDeepCopy<HarmonyMethod>(value);
	}

	public static List<HarmonyMethod> GetFromType(Type type)
	{
		return (from attr in type.GetCustomAttributes(inherit: true)
			select GetHarmonyMethodInfo(attr) into info
			where info != null
			select info).ToList();
	}

	public static HarmonyMethod GetMergedFromType(Type type)
	{
		return HarmonyMethod.Merge(GetFromType(type));
	}

	public static List<HarmonyMethod> GetFromMethod(MethodBase method)
	{
		return (from attr in method.GetCustomAttributes(inherit: true)
			select GetHarmonyMethodInfo(attr) into info
			where info != null
			select info).ToList();
	}

	public static HarmonyMethod GetMergedFromMethod(MethodBase method)
	{
		return HarmonyMethod.Merge(GetFromMethod(method));
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using HarmonyLib;
using Mono.Cecil;
using MonoMod.Utils;

internal class InlineSignature : ICallSiteGenerator
{
	public class ModifierType
	{
		public bool IsOptional;

		public Type Modifier;

		public object Type;

		public override string ToString()
		{
			return $"{((Type is Type type) ? type.FullDescription() : Type?.ToString())} mod{(IsOptional ? "opt" : "req")}({Modifier?.FullDescription()})";
		}

		internal TypeReference ToTypeReference(ModuleDefinition module)
		{
			if (IsOptional)
			{
				return new OptionalModifierType(module.ImportReference(Modifier), GetTypeReference(module, Type));
			}
			return new RequiredModifierType(module.ImportReference(Modifier), GetTypeReference(module, Type));
		}
	}

	public bool HasThis { get; set; }

	public bool ExplicitThis { get; set; }

	public CallingConvention CallingConvention { get; set; } = CallingConvention.Winapi;

	public List<object> Parameters { get; set; } = new List<object>();

	public object ReturnType { get; set; } = typeof(void);

	public override string ToString()
	{
		return ((ReturnType is Type type) ? type.FullDescription() : ReturnType?.ToString()) + " (" + Parameters.Join((object p) => (!(p is Type type2)) ? p?.ToString() : type2.FullDescription()) + ")";
	}

	internal static TypeReference GetTypeReference(ModuleDefinition module, object param)
	{
		if (!(param is Type type))
		{
			if (!(param is InlineSignature inlineSignature))
			{
				if (param is ModifierType modifierType)
				{
					return modifierType.ToTypeReference(module);
				}
				throw new NotSupportedException($"Unsupported inline signature parameter type: {param} ({param?.GetType().FullDescription()})");
			}
			return inlineSignature.ToFunctionPointer(module);
		}
		return module.ImportReference(type);
	}

	CallSite ICallSiteGenerator.ToCallSite(ModuleDefinition module)
	{
		CallSite callSite = new CallSite(GetTypeReference(module, ReturnType))
		{
			HasThis = HasThis,
			ExplicitThis = ExplicitThis,
			CallingConvention = (MethodCallingConvention)((byte)CallingConvention - 1)
		};
		foreach (object parameter in Parameters)
		{
			callSite.Parameters.Add(new ParameterDefinition(GetTypeReference(module, parameter)));
		}
		return callSite;
	}

	private FunctionPointerType ToFunctionPointer(ModuleDefinition module)
	{
		FunctionPointerType functionPointerType = new FunctionPointerType
		{
			ReturnType = GetTypeReference(module, ReturnType),
			HasThis = HasThis,
			ExplicitThis = ExplicitThis,
			CallingConvention = (MethodCallingConvention)((byte)CallingConvention - 1)
		};
		foreach (object parameter in Parameters)
		{
			functionPointerType.Parameters.Add(new ParameterDefinition(GetTypeReference(module, parameter)));
		}
		return functionPointerType;
	}
}


using System;
using Mono.Cecil;

public class ModifierType
{
	public bool IsOptional;

	public Type Modifier;

	public object Type;

	public override string ToString()
	{
		return $"{((Type is Type type) ? type.FullDescription() : Type?.ToString())} mod{(IsOptional ? "opt" : "req")}({Modifier?.FullDescription()})";
	}

	internal TypeReference ToTypeReference(ModuleDefinition module)
	{
		if (IsOptional)
		{
			return new OptionalModifierType(module.ImportReference(Modifier), GetTypeReference(module, Type));
		}
		return new RequiredModifierType(module.ImportReference(Modifier), GetTypeReference(module, Type));
	}
}


using System;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using HarmonyLib;

internal static class PatchInfoSerialization
{
	private class Binder : SerializationBinder
	{
		public override Type BindToType(string assemblyName, string typeName)
		{
			Type[] array = new Type[3]
			{
				typeof(PatchInfo),
				typeof(Patch[]),
				typeof(Patch)
			};
			Type[] array2 = array;
			foreach (Type type in array2)
			{
				if (typeName == type.FullName)
				{
					return type;
				}
			}
			return Type.GetType($"{typeName}, {assemblyName}");
		}
	}

	internal static readonly BinaryFormatter binaryFormatter = new BinaryFormatter
	{
		Binder = new Binder()
	};

	internal static byte[] Serialize(this PatchInfo patchInfo)
	{
		using MemoryStream memoryStream = new MemoryStream();
		binaryFormatter.Serialize(memoryStream, patchInfo);
		return memoryStream.GetBuffer();
	}

	internal static PatchInfo Deserialize(byte[] bytes)
	{
		using MemoryStream serializationStream = new MemoryStream(bytes);
		return (PatchInfo)binaryFormatter.Deserialize(serializationStream);
	}

	internal static int PriorityComparer(object obj, int index, int priority)
	{
		Traverse traverse = Traverse.Create(obj);
		int value = traverse.Field("priority").GetValue<int>();
		int value2 = traverse.Field("index").GetValue<int>();
		if (priority != value)
		{
			return -priority.CompareTo(value);
		}
		return index.CompareTo(value2);
	}
}


using System;
using System.Runtime.Serialization;

private class Binder : SerializationBinder
{
	public override Type BindToType(string assemblyName, string typeName)
	{
		Type[] array = new Type[3]
		{
			typeof(PatchInfo),
			typeof(Patch[]),
			typeof(Patch)
		};
		Type[] array2 = array;
		foreach (Type type in array2)
		{
			if (typeName == type.FullName)
			{
				return type;
			}
		}
		return Type.GetType($"{typeName}, {assemblyName}");
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

[Serializable]
public class PatchInfo
{
	public Patch[] prefixes = Array.Empty<Patch>();

	public Patch[] postfixes = Array.Empty<Patch>();

	public Patch[] transpilers = Array.Empty<Patch>();

	public Patch[] finalizers = Array.Empty<Patch>();

	public bool Debugging
	{
		get
		{
			if (!prefixes.Any((Patch p) => p.debug) && !postfixes.Any((Patch p) => p.debug) && !transpilers.Any((Patch p) => p.debug))
			{
				return finalizers.Any((Patch p) => p.debug);
			}
			return true;
		}
	}

	internal void AddPrefixes(string owner, params HarmonyMethod[] methods)
	{
		prefixes = Add(owner, methods, prefixes);
	}

	[Obsolete("This method only exists for backwards compatibility since the class is public.")]
	public void AddPrefix(MethodInfo patch, string owner, int priority, string[] before, string[] after, bool debug)
	{
		AddPrefixes(owner, new HarmonyMethod(patch, priority, before, after, debug));
	}

	public void RemovePrefix(string owner)
	{
		prefixes = Remove(owner, prefixes);
	}

	internal void AddPostfixes(string owner, params HarmonyMethod[] methods)
	{
		postfixes = Add(owner, methods, postfixes);
	}

	[Obsolete("This method only exists for backwards compatibility since the class is public.")]
	public void AddPostfix(MethodInfo patch, string owner, int priority, string[] before, string[] after, bool debug)
	{
		AddPostfixes(owner, new HarmonyMethod(patch, priority, before, after, debug));
	}

	public void RemovePostfix(string owner)
	{
		postfixes = Remove(owner, postfixes);
	}

	internal void AddTranspilers(string owner, params HarmonyMethod[] methods)
	{
		transpilers = Add(owner, methods, transpilers);
	}

	[Obsolete("This method only exists for backwards compatibility since the class is public.")]
	public void AddTranspiler(MethodInfo patch, string owner, int priority, string[] before, string[] after, bool debug)
	{
		AddTranspilers(owner, new HarmonyMethod(patch, priority, before, after, debug));
	}

	public void RemoveTranspiler(string owner)
	{
		transpilers = Remove(owner, transpilers);
	}

	internal void AddFinalizers(string owner, params HarmonyMethod[] methods)
	{
		finalizers = Add(owner, methods, finalizers);
	}

	[Obsolete("This method only exists for backwards compatibility since the class is public.")]
	public void AddFinalizer(MethodInfo patch, string owner, int priority, string[] before, string[] after, bool debug)
	{
		AddFinalizers(owner, new HarmonyMethod(patch, priority, before, after, debug));
	}

	public void RemoveFinalizer(string owner)
	{
		finalizers = Remove(owner, finalizers);
	}

	public void RemovePatch(MethodInfo patch)
	{
		prefixes = prefixes.Where((Patch p) => p.PatchMethod != patch).ToArray();
		postfixes = postfixes.Where((Patch p) => p.PatchMethod != patch).ToArray();
		transpilers = transpilers.Where((Patch p) => p.PatchMethod != patch).ToArray();
		finalizers = finalizers.Where((Patch p) => p.PatchMethod != patch).ToArray();
	}

	private static Patch[] Add(string owner, HarmonyMethod[] add, Patch[] current)
	{
		if (add.Length == 0)
		{
			return current;
		}
		int initialIndex = current.Length;
		List<Patch> list = new List<Patch>();
		list.AddRange(current);
		list.AddRange(add.Where((HarmonyMethod method) => method != null).Select((HarmonyMethod method, int i) => new Patch(method, i + initialIndex, owner)));
		return list.ToArray();
	}

	private static Patch[] Remove(string owner, Patch[] current)
	{
		if (!(owner == "*"))
		{
			return current.Where((Patch patch) => patch.owner != owner).ToArray();
		}
		return Array.Empty<Patch>();
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

[Serializable]
public class Patch : IComparable
{
	public readonly int index;

	public readonly string owner;

	public readonly int priority;

	public readonly string[] before;

	public readonly string[] after;

	public readonly bool debug;

	[NonSerialized]
	private MethodInfo patchMethod;

	private int methodToken;

	private string moduleGUID;

	public MethodInfo PatchMethod
	{
		get
		{
			if ((object)patchMethod == null)
			{
				Module module = (from a in AppDomain.CurrentDomain.GetAssemblies()
					where !a.FullName.StartsWith("Microsoft.VisualStudio")
					select a).SelectMany((Assembly a) => a.GetLoadedModules()).First((Module m) => m.ModuleVersionId.ToString() == moduleGUID);
				patchMethod = (MethodInfo)module.ResolveMethod(methodToken);
			}
			return patchMethod;
		}
		set
		{
			patchMethod = value;
			methodToken = patchMethod.MetadataToken;
			moduleGUID = patchMethod.Module.ModuleVersionId.ToString();
		}
	}

	public Patch(MethodInfo patch, int index, string owner, int priority, string[] before, string[] after, bool debug)
	{
		if (patch is DynamicMethod)
		{
			throw new Exception("Cannot directly reference dynamic method \"" + patch.FullDescription() + "\" in Harmony. Use a factory method instead that will return the dynamic method.");
		}
		this.index = index;
		this.owner = owner;
		this.priority = ((priority == -1) ? 400 : priority);
		this.before = before ?? Array.Empty<string>();
		this.after = after ?? Array.Empty<string>();
		this.debug = debug;
		PatchMethod = patch;
	}

	public Patch(HarmonyMethod method, int index, string owner)
		: this(method.method, index, owner, method.priority, method.before, method.after, method.debug == true)
	{
	}

	internal Patch(int index, string owner, int priority, string[] before, string[] after, bool debug, int methodToken, string moduleGUID)
	{
		this.index = index;
		this.owner = owner;
		this.priority = ((priority == -1) ? 400 : priority);
		this.before = before ?? Array.Empty<string>();
		this.after = after ?? Array.Empty<string>();
		this.debug = debug;
		this.methodToken = methodToken;
		this.moduleGUID = moduleGUID;
	}

	public MethodInfo GetMethod(MethodBase original)
	{
		MethodInfo methodInfo = PatchMethod;
		if (methodInfo.ReturnType != typeof(DynamicMethod) && methodInfo.ReturnType != typeof(MethodInfo))
		{
			return methodInfo;
		}
		if (!methodInfo.IsStatic)
		{
			return methodInfo;
		}
		ParameterInfo[] parameters = methodInfo.GetParameters();
		if (parameters.Length != 1)
		{
			return methodInfo;
		}
		if (parameters[0].ParameterType != typeof(MethodBase))
		{
			return methodInfo;
		}
		return methodInfo.Invoke(null, new object[1] { original }) as MethodInfo;
	}

	public override bool Equals(object obj)
	{
		if (obj != null && obj is Patch)
		{
			return PatchMethod == ((Patch)obj).PatchMethod;
		}
		return false;
	}

	public int CompareTo(object obj)
	{
		return PatchInfoSerialization.PriorityComparer(obj, index, priority);
	}

	public override int GetHashCode()
	{
		return PatchMethod.GetHashCode();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

public class PatchClassProcessor
{
	private readonly Harmony instance;

	private readonly Type containerType;

	private readonly HarmonyMethod containerAttributes;

	private readonly Dictionary<Type, MethodInfo> auxilaryMethods;

	private readonly List<AttributePatch> patchMethods;

	private static readonly List<Type> auxilaryTypes = new List<Type>(4)
	{
		typeof(HarmonyPrepare),
		typeof(HarmonyCleanup),
		typeof(HarmonyTargetMethod),
		typeof(HarmonyTargetMethods)
	};

	public string Category { get; set; }

	public PatchClassProcessor(Harmony instance, Type type)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		this.instance = instance;
		containerType = type;
		List<HarmonyMethod> fromType = HarmonyMethodExtensions.GetFromType(type);
		if (fromType == null || fromType.Count == 0)
		{
			return;
		}
		containerAttributes = HarmonyMethod.Merge(fromType);
		HarmonyMethod harmonyMethod = containerAttributes;
		MethodType valueOrDefault = harmonyMethod.methodType.GetValueOrDefault();
		if (!harmonyMethod.methodType.HasValue)
		{
			valueOrDefault = MethodType.Normal;
			harmonyMethod.methodType = valueOrDefault;
		}
		Category = containerAttributes.category;
		auxilaryMethods = new Dictionary<Type, MethodInfo>();
		foreach (Type auxilaryType in auxilaryTypes)
		{
			MethodInfo patchMethod = PatchTools.GetPatchMethod(containerType, auxilaryType.FullName);
			if ((object)patchMethod != null)
			{
				auxilaryMethods[auxilaryType] = patchMethod;
			}
		}
		patchMethods = PatchTools.GetPatchMethods(containerType);
		foreach (AttributePatch patchMethod2 in patchMethods)
		{
			MethodInfo method = patchMethod2.info.method;
			patchMethod2.info = containerAttributes.Merge(patchMethod2.info);
			patchMethod2.info.method = method;
		}
	}

	public List<MethodInfo> Patch()
	{
		if (containerAttributes == null)
		{
			return null;
		}
		Exception exception = null;
		if (!RunMethod<HarmonyPrepare, bool>(defaultIfNotExisting: true, defaultIfFailing: false, null, Array.Empty<object>()))
		{
			RunMethod<HarmonyCleanup>(ref exception, Array.Empty<object>());
			ReportException(exception, null);
			return new List<MethodInfo>();
		}
		List<MethodInfo> result = new List<MethodInfo>();
		MethodBase lastOriginal = null;
		try
		{
			List<MethodBase> bulkMethods = GetBulkMethods();
			if (bulkMethods.Count == 1)
			{
				lastOriginal = bulkMethods[0];
			}
			ReversePatch(ref lastOriginal);
			result = ((bulkMethods.Count > 0) ? BulkPatch(bulkMethods, ref lastOriginal) : PatchWithAttributes(ref lastOriginal));
		}
		catch (Exception ex)
		{
			exception = ex;
		}
		RunMethod<HarmonyCleanup>(ref exception, new object[1] { exception });
		ReportException(exception, lastOriginal);
		return result;
	}

	private void ReversePatch(ref MethodBase lastOriginal)
	{
		for (int i = 0; i < patchMethods.Count; i++)
		{
			AttributePatch attributePatch = patchMethods[i];
			if (attributePatch.type == HarmonyPatchType.ReversePatch)
			{
				MethodBase originalMethod = attributePatch.info.GetOriginalMethod();
				if ((object)originalMethod != null)
				{
					lastOriginal = originalMethod;
				}
				ReversePatcher reversePatcher = instance.CreateReversePatcher(lastOriginal, attributePatch.info);
				lock (PatchProcessor.locker)
				{
					reversePatcher.Patch();
				}
			}
		}
	}

	private List<MethodInfo> BulkPatch(List<MethodBase> originals, ref MethodBase lastOriginal)
	{
		PatchJobs<MethodInfo> patchJobs = new PatchJobs<MethodInfo>();
		for (int i = 0; i < originals.Count; i++)
		{
			lastOriginal = originals[i];
			PatchJobs<MethodInfo>.Job job = patchJobs.GetJob(lastOriginal);
			foreach (AttributePatch patchMethod in patchMethods)
			{
				string text = "You cannot combine TargetMethod, TargetMethods or [HarmonyPatchAll] with individual annotations";
				HarmonyMethod info = patchMethod.info;
				if (info.methodName != null)
				{
					throw new ArgumentException(text + " [" + info.methodName + "]");
				}
				if (info.methodType.HasValue && info.methodType.Value != 0)
				{
					throw new ArgumentException($"{text} [{info.methodType}]");
				}
				if (info.argumentTypes != null)
				{
					throw new ArgumentException(text + " [" + info.argumentTypes.Description() + "]");
				}
				job.AddPatch(patchMethod);
			}
		}
		foreach (PatchJobs<MethodInfo>.Job job2 in patchJobs.GetJobs())
		{
			lastOriginal = job2.original;
			ProcessPatchJob(job2);
		}
		return patchJobs.GetReplacements();
	}

	private List<MethodInfo> PatchWithAttributes(ref MethodBase lastOriginal)
	{
		PatchJobs<MethodInfo> patchJobs = new PatchJobs<MethodInfo>();
		foreach (AttributePatch patchMethod in patchMethods)
		{
			lastOriginal = patchMethod.info.GetOriginalMethod();
			if ((object)lastOriginal == null)
			{
				throw new ArgumentException("Undefined target method for patch method " + patchMethod.info.method.FullDescription());
			}
			PatchJobs<MethodInfo>.Job job = patchJobs.GetJob(lastOriginal);
			job.AddPatch(patchMethod);
		}
		foreach (PatchJobs<MethodInfo>.Job job2 in patchJobs.GetJobs())
		{
			lastOriginal = job2.original;
			ProcessPatchJob(job2);
		}
		return patchJobs.GetReplacements();
	}

	private void ProcessPatchJob(PatchJobs<MethodInfo>.Job job)
	{
		MethodInfo replacement = null;
		bool flag = RunMethod<HarmonyPrepare, bool>(defaultIfNotExisting: true, defaultIfFailing: false, null, new object[1] { job.original });
		Exception exception = null;
		if (flag)
		{
			lock (PatchProcessor.locker)
			{
				try
				{
					PatchInfo patchInfo = HarmonySharedState.GetPatchInfo(job.original) ?? new PatchInfo();
					patchInfo.AddPrefixes(instance.Id, job.prefixes.ToArray());
					patchInfo.AddPostfixes(instance.Id, job.postfixes.ToArray());
					patchInfo.AddTranspilers(instance.Id, job.transpilers.ToArray());
					patchInfo.AddFinalizers(instance.Id, job.finalizers.ToArray());
					replacement = PatchFunctions.UpdateWrapper(job.original, patchInfo);
					HarmonySharedState.UpdatePatchInfo(job.original, replacement, patchInfo);
				}
				catch (Exception ex)
				{
					exception = ex;
				}
			}
		}
		RunMethod<HarmonyCleanup>(ref exception, new object[2] { job.original, exception });
		ReportException(exception, job.original);
		job.replacement = replacement;
	}

	private List<MethodBase> GetBulkMethods()
	{
		if (containerType.GetCustomAttributes(inherit: true).Any((object a) => a.GetType().FullName == PatchTools.harmonyPatchAllFullName))
		{
			Type declaringType = containerAttributes.declaringType;
			if ((object)declaringType == null)
			{
				throw new ArgumentException("Using " + PatchTools.harmonyPatchAllFullName + " requires an additional attribute for specifying the Class/Type");
			}
			List<MethodBase> list = new List<MethodBase>();
			list.AddRange(AccessTools.GetDeclaredConstructors(declaringType, null).Cast<MethodBase>());
			list.AddRange(AccessTools.GetDeclaredMethods(declaringType).Cast<MethodBase>());
			List<PropertyInfo> declaredProperties = AccessTools.GetDeclaredProperties(declaringType);
			list.AddRange((from prop in declaredProperties
				select prop.GetGetMethod(nonPublic: true) into method
				where (object)method != null
				select method).Cast<MethodBase>());
			list.AddRange((from prop in declaredProperties
				select prop.GetSetMethod(nonPublic: true) into method
				where (object)method != null
				select method).Cast<MethodBase>());
			return list;
		}
		List<MethodBase> list2 = new List<MethodBase>();
		IEnumerable<MethodBase> enumerable = RunMethod<HarmonyTargetMethods, IEnumerable<MethodBase>>(null, null, null, Array.Empty<object>());
		if (enumerable != null)
		{
			string text = null;
			list2 = enumerable.ToList();
			if (list2 == null)
			{
				text = "null";
			}
			else if (list2.Any((MethodBase m) => (object)m == null))
			{
				text = "some element was null";
			}
			if (text != null)
			{
				if (auxilaryMethods.TryGetValue(typeof(HarmonyTargetMethods), out var value))
				{
					throw new Exception("Method " + value.FullDescription() + " returned an unexpected result: " + text);
				}
				throw new Exception("Some method returned an unexpected result: " + text);
			}
			return list2;
		}
		MethodBase methodBase = RunMethod<HarmonyTargetMethod, MethodBase>(null, null, (MethodBase method) => ((object)method != null) ? null : "null", Array.Empty<object>());
		if ((object)methodBase != null)
		{
			list2.Add(methodBase);
		}
		return list2;
	}

	private void ReportException(Exception exception, MethodBase original)
	{
		if (exception == null)
		{
			return;
		}
		if (containerAttributes.debug == true || Harmony.DEBUG)
		{
			Harmony.VersionInfo(out var currentVersion);
			FileLog.indentLevel = 0;
			FileLog.Log($"### Exception from user \"{instance.Id}\", Harmony v{currentVersion}");
			FileLog.Log("### Original: " + (original?.FullDescription() ?? "NULL"));
			FileLog.Log("### Patch class: " + containerType.FullDescription());
			Exception ex = exception;
			if (ex is HarmonyException ex2)
			{
				ex = ex2.InnerException;
			}
			string text = ex.ToString();
			while (text.Contains("\n\n"))
			{
				text = text.Replace("\n\n", "\n");
			}
			text = text.Split(new char[1] { '\n' }).Join((string line) => "### " + line, "\n");
			FileLog.Log(text.Trim());
		}
		if (exception is HarmonyException)
		{
			throw exception;
		}
		throw new HarmonyException("Patching exception in method " + original.FullDescription(), exception);
	}

	private T RunMethod<S, T>(T defaultIfNotExisting, T defaultIfFailing, Func<T, string> failOnResult = null, params object[] parameters)
	{
		if (auxilaryMethods.TryGetValue(typeof(S), out var value))
		{
			object[] inputs = (parameters ?? Array.Empty<object>()).Union(new object[1] { instance }).ToArray();
			object[] parameters2 = AccessTools.ActualParameters(value, inputs);
			if (value.ReturnType != typeof(void) && !typeof(T).IsAssignableFrom(value.ReturnType))
			{
				throw new Exception($"Method {value.FullDescription()} has wrong return type (should be assignable to {typeof(T).FullName})");
			}
			T val = defaultIfFailing;
			try
			{
				if (value.ReturnType == typeof(void))
				{
					value.Invoke(null, parameters2);
					val = defaultIfNotExisting;
				}
				else
				{
					val = (T)value.Invoke(null, parameters2);
				}
				if (failOnResult != null)
				{
					string text = failOnResult(val);
					if (text != null)
					{
						throw new Exception("Method " + value.FullDescription() + " returned an unexpected result: " + text);
					}
				}
			}
			catch (Exception exception)
			{
				ReportException(exception, value);
			}
			return val;
		}
		return defaultIfNotExisting;
	}

	private void RunMethod<S>(ref Exception exception, params object[] parameters)
	{
		if (!auxilaryMethods.TryGetValue(typeof(S), out var value))
		{
			return;
		}
		object[] inputs = (parameters ?? Array.Empty<object>()).Union(new object[1] { instance }).ToArray();
		object[] parameters2 = AccessTools.ActualParameters(value, inputs);
		try
		{
			object obj = value.Invoke(null, parameters2);
			if (value.ReturnType == typeof(Exception))
			{
				exception = obj as Exception;
			}
		}
		catch (Exception exception2)
		{
			ReportException(exception2, value);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using HarmonyLib;

public class Patches
{
	public readonly ReadOnlyCollection<Patch> Prefixes;

	public readonly ReadOnlyCollection<Patch> Postfixes;

	public readonly ReadOnlyCollection<Patch> Transpilers;

	public readonly ReadOnlyCollection<Patch> Finalizers;

	public ReadOnlyCollection<string> Owners
	{
		get
		{
			HashSet<string> hashSet = new HashSet<string>();
			hashSet.UnionWith(Prefixes.Select((Patch p) => p.owner));
			hashSet.UnionWith(Postfixes.Select((Patch p) => p.owner));
			hashSet.UnionWith(Transpilers.Select((Patch p) => p.owner));
			hashSet.UnionWith(Finalizers.Select((Patch p) => p.owner));
			return hashSet.ToList().AsReadOnly();
		}
	}

	public Patches(Patch[] prefixes, Patch[] postfixes, Patch[] transpilers, Patch[] finalizers)
	{
		if (prefixes == null)
		{
			prefixes = Array.Empty<Patch>();
		}
		if (postfixes == null)
		{
			postfixes = Array.Empty<Patch>();
		}
		if (transpilers == null)
		{
			transpilers = Array.Empty<Patch>();
		}
		if (finalizers == null)
		{
			finalizers = Array.Empty<Patch>();
		}
		Prefixes = prefixes.ToList().AsReadOnly();
		Postfixes = postfixes.ToList().AsReadOnly();
		Transpilers = transpilers.ToList().AsReadOnly();
		Finalizers = finalizers.ToList().AsReadOnly();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.Utils;

public class PatchProcessor(Harmony instance, MethodBase original)
{
	private readonly Harmony instance = instance;

	private readonly MethodBase original = original;

	private HarmonyMethod prefix;

	private HarmonyMethod postfix;

	private HarmonyMethod transpiler;

	private HarmonyMethod finalizer;

	internal static readonly object locker = new object();

	public PatchProcessor AddPrefix(HarmonyMethod prefix)
	{
		this.prefix = prefix;
		return this;
	}

	public PatchProcessor AddPrefix(MethodInfo fixMethod)
	{
		prefix = new HarmonyMethod(fixMethod);
		return this;
	}

	public PatchProcessor AddPostfix(HarmonyMethod postfix)
	{
		this.postfix = postfix;
		return this;
	}

	public PatchProcessor AddPostfix(MethodInfo fixMethod)
	{
		postfix = new HarmonyMethod(fixMethod);
		return this;
	}

	public PatchProcessor AddTranspiler(HarmonyMethod transpiler)
	{
		this.transpiler = transpiler;
		return this;
	}

	public PatchProcessor AddTranspiler(MethodInfo fixMethod)
	{
		transpiler = new HarmonyMethod(fixMethod);
		return this;
	}

	public PatchProcessor AddFinalizer(HarmonyMethod finalizer)
	{
		this.finalizer = finalizer;
		return this;
	}

	public PatchProcessor AddFinalizer(MethodInfo fixMethod)
	{
		finalizer = new HarmonyMethod(fixMethod);
		return this;
	}

	public static IEnumerable<MethodBase> GetAllPatchedMethods()
	{
		lock (locker)
		{
			return HarmonySharedState.GetPatchedMethods();
		}
	}

	public MethodInfo Patch()
	{
		if ((object)original == null)
		{
			throw new NullReferenceException("Null method for " + instance.Id);
		}
		if (!original.IsDeclaredMember())
		{
			MethodBase declaredMember = AccessTools.GetDeclaredMember(original);
			throw new ArgumentException("You can only patch implemented methods/constructors. Patch the declared method " + declaredMember.FullDescription() + " instead.");
		}
		lock (locker)
		{
			PatchInfo patchInfo = HarmonySharedState.GetPatchInfo(original) ?? new PatchInfo();
			patchInfo.AddPrefixes(instance.Id, prefix);
			patchInfo.AddPostfixes(instance.Id, postfix);
			patchInfo.AddTranspilers(instance.Id, transpiler);
			patchInfo.AddFinalizers(instance.Id, finalizer);
			MethodInfo methodInfo = PatchFunctions.UpdateWrapper(original, patchInfo);
			HarmonySharedState.UpdatePatchInfo(original, methodInfo, patchInfo);
			return methodInfo;
		}
	}

	public PatchProcessor Unpatch(HarmonyPatchType type, string harmonyID)
	{
		lock (locker)
		{
			PatchInfo patchInfo = HarmonySharedState.GetPatchInfo(original);
			if (patchInfo == null)
			{
				patchInfo = new PatchInfo();
			}
			if (type == HarmonyPatchType.All || type == HarmonyPatchType.Prefix)
			{
				patchInfo.RemovePrefix(harmonyID);
			}
			if (type == HarmonyPatchType.All || type == HarmonyPatchType.Postfix)
			{
				patchInfo.RemovePostfix(harmonyID);
			}
			if (type == HarmonyPatchType.All || type == HarmonyPatchType.Transpiler)
			{
				patchInfo.RemoveTranspiler(harmonyID);
			}
			if (type == HarmonyPatchType.All || type == HarmonyPatchType.Finalizer)
			{
				patchInfo.RemoveFinalizer(harmonyID);
			}
			MethodInfo replacement = PatchFunctions.UpdateWrapper(original, patchInfo);
			HarmonySharedState.UpdatePatchInfo(original, replacement, patchInfo);
			return this;
		}
	}

	public PatchProcessor Unpatch(MethodInfo patch)
	{
		lock (locker)
		{
			PatchInfo patchInfo = HarmonySharedState.GetPatchInfo(original);
			if (patchInfo == null)
			{
				patchInfo = new PatchInfo();
			}
			patchInfo.RemovePatch(patch);
			MethodInfo replacement = PatchFunctions.UpdateWrapper(original, patchInfo);
			HarmonySharedState.UpdatePatchInfo(original, replacement, patchInfo);
			return this;
		}
	}

	public static Patches GetPatchInfo(MethodBase method)
	{
		PatchInfo patchInfo;
		lock (locker)
		{
			patchInfo = HarmonySharedState.GetPatchInfo(method);
		}
		if (patchInfo == null)
		{
			return null;
		}
		return new Patches(patchInfo.prefixes, patchInfo.postfixes, patchInfo.transpilers, patchInfo.finalizers);
	}

	public static List<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches)
	{
		return PatchFunctions.GetSortedPatchMethods(original, patches, debug: false);
	}

	public static Dictionary<string, Version> VersionInfo(out Version currentVersion)
	{
		currentVersion = typeof(Harmony).Assembly.GetName().Version;
		Dictionary<string, Assembly> assemblies = new Dictionary<string, Assembly>();
		GetAllPatchedMethods().Do(delegate(MethodBase method)
		{
			PatchInfo patchInfo;
			lock (locker)
			{
				patchInfo = HarmonySharedState.GetPatchInfo(method);
			}
			patchInfo.prefixes.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.PatchMethod.DeclaringType.Assembly;
			});
			patchInfo.postfixes.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.PatchMethod.DeclaringType.Assembly;
			});
			patchInfo.transpilers.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.PatchMethod.DeclaringType.Assembly;
			});
			patchInfo.finalizers.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.PatchMethod.DeclaringType.Assembly;
			});
		});
		Dictionary<string, Version> result = new Dictionary<string, Version>();
		assemblies.Do(delegate(KeyValuePair<string, Assembly> info)
		{
			AssemblyName assemblyName = info.Value.GetReferencedAssemblies().FirstOrDefault((AssemblyName a) => a.FullName.StartsWith("0Harmony, Version", StringComparison.Ordinal));
			if (assemblyName != null)
			{
				result[info.Key] = assemblyName.Version;
			}
		});
		return result;
	}

	public static ILGenerator CreateILGenerator()
	{
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition($"ILGenerator_{Guid.NewGuid()}", typeof(void), Array.Empty<Type>());
		return dynamicMethodDefinition.GetILGenerator();
	}

	public static ILGenerator CreateILGenerator(MethodBase original)
	{
		Type returnType = ((original is MethodInfo methodInfo) ? methodInfo.ReturnType : typeof(void));
		List<Type> list = (from pi in original.GetParameters()
			select pi.ParameterType).ToList();
		if (!original.IsStatic)
		{
			list.Insert(0, original.DeclaringType);
		}
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("ILGenerator_" + original.Name, returnType, list.ToArray());
		return dynamicMethodDefinition.GetILGenerator();
	}

	public static List<CodeInstruction> GetOriginalInstructions(MethodBase original, ILGenerator generator = null)
	{
		return MethodCopier.GetInstructions(generator ?? CreateILGenerator(original), original, 0);
	}

	public static List<CodeInstruction> GetOriginalInstructions(MethodBase original, out ILGenerator generator)
	{
		generator = CreateILGenerator(original);
		return MethodCopier.GetInstructions(generator, original, 0);
	}

	public static List<CodeInstruction> GetCurrentInstructions(MethodBase original, int maxTranspilers = int.MaxValue, ILGenerator generator = null)
	{
		return MethodCopier.GetInstructions(generator ?? CreateILGenerator(original), original, maxTranspilers);
	}

	public static List<CodeInstruction> GetCurrentInstructions(MethodBase original, out ILGenerator generator, int maxTranspilers = int.MaxValue)
	{
		generator = CreateILGenerator(original);
		return MethodCopier.GetInstructions(generator, original, maxTranspilers);
	}

	public static IEnumerable<KeyValuePair<OpCode, object>> ReadMethodBody(MethodBase method)
	{
		return from instr in MethodBodyReader.GetInstructions(CreateILGenerator(method), method)
			select new KeyValuePair<OpCode, object>(instr.opcode, instr.operand);
	}

	public static IEnumerable<KeyValuePair<OpCode, object>> ReadMethodBody(MethodBase method, ILGenerator generator)
	{
		return from instr in MethodBodyReader.GetInstructions(generator, method)
			select new KeyValuePair<OpCode, object>(instr.opcode, instr.operand);
	}
}


public static class Priority
{
	public const int Last = 0;

	public const int VeryLow = 100;

	public const int Low = 200;

	public const int LowerThanNormal = 300;

	public const int Normal = 400;

	public const int HigherThanNormal = 500;

	public const int High = 600;

	public const int VeryHigh = 700;

	public const int First = 800;
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;

public class ReversePatcher(Harmony instance, MethodBase original, HarmonyMethod standin)
{
	private readonly Harmony instance = instance;

	private readonly MethodBase original = original;

	private readonly HarmonyMethod standin = standin;

	public MethodInfo Patch(HarmonyReversePatchType type = HarmonyReversePatchType.Original)
	{
		if ((object)original == null)
		{
			throw new NullReferenceException("Null method for " + instance.Id);
		}
		standin.reversePatchType = type;
		MethodInfo transpiler = GetTranspiler(standin.method);
		return PatchFunctions.ReversePatch(standin, original, transpiler);
	}

	internal static MethodInfo GetTranspiler(MethodInfo method)
	{
		string methodName = method.Name;
		Type declaringType = method.DeclaringType;
		List<MethodInfo> declaredMethods = AccessTools.GetDeclaredMethods(declaringType);
		Type ici = typeof(IEnumerable<CodeInstruction>);
		return declaredMethods.FirstOrDefault((MethodInfo m) => !(m.ReturnType != ici) && m.Name.StartsWith("<" + methodName + ">"));
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

public static class Transpilers
{
	public static IEnumerable<CodeInstruction> MethodReplacer(this IEnumerable<CodeInstruction> instructions, MethodBase from, MethodBase to)
	{
		if ((object)from == null)
		{
			throw new ArgumentException("Unexpected null argument", "from");
		}
		if ((object)to == null)
		{
			throw new ArgumentException("Unexpected null argument", "to");
		}
		foreach (CodeInstruction instruction in instructions)
		{
			MethodBase methodBase = instruction.operand as MethodBase;
			if (methodBase == from)
			{
				instruction.opcode = (to.IsConstructor ? OpCodes.Newobj : OpCodes.Call);
				instruction.operand = to;
			}
			yield return instruction;
		}
	}

	public static IEnumerable<CodeInstruction> Manipulator(this IEnumerable<CodeInstruction> instructions, Func<CodeInstruction, bool> predicate, Action<CodeInstruction> action)
	{
		if (predicate == null)
		{
			throw new ArgumentNullException("predicate");
		}
		if (action == null)
		{
			throw new ArgumentNullException("action");
		}
		return instructions.Select(delegate(CodeInstruction instruction)
		{
			if (predicate(instruction))
			{
				action(instruction);
			}
			return instruction;
		}).AsEnumerable();
	}

	public static IEnumerable<CodeInstruction> DebugLogger(this IEnumerable<CodeInstruction> instructions, string text)
	{
		yield return new CodeInstruction(OpCodes.Ldstr, text);
		yield return new CodeInstruction(OpCodes.Call, AccessTools.Method(typeof(FileLog), "Debug"));
		foreach (CodeInstruction instruction in instructions)
		{
			yield return instruction;
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.Serialization;
using System.Threading;
using HarmonyLib;
using MonoMod.Utils;

public static class AccessTools
{
	public delegate ref F FieldRef<in T, F>(T instance = default(T));

	public delegate ref F StructFieldRef<T, F>(ref T instance) where T : struct;

	public delegate ref F FieldRef<F>();

	public static readonly BindingFlags all = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty;

	public static readonly BindingFlags allDeclared = all | BindingFlags.DeclaredOnly;

	private static readonly Dictionary<Type, FastInvokeHandler> addHandlerCache = new Dictionary<Type, FastInvokeHandler>();

	private static readonly ReaderWriterLockSlim addHandlerCacheLock = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);

	public static bool IsMonoRuntime { get; } = (object)Type.GetType("Mono.Runtime") != null;

	public static bool IsNetFrameworkRuntime { get; } = Type.GetType("System.Runtime.InteropServices.RuntimeInformation", throwOnError: false)?.GetProperty("FrameworkDescription").GetValue(null, null).ToString()
		.StartsWith(".NET Framework") ?? (!IsMonoRuntime);

	public static bool IsNetCoreRuntime { get; } = Type.GetType("System.Runtime.InteropServices.RuntimeInformation", throwOnError: false)?.GetProperty("FrameworkDescription").GetValue(null, null).ToString()
		.StartsWith(".NET Core") ?? false;

	public static IEnumerable<Assembly> AllAssemblies()
	{
		return from a in AppDomain.CurrentDomain.GetAssemblies()
			where !a.FullName.StartsWith("Microsoft.VisualStudio")
			select a;
	}

	public static Type TypeByName(string name)
	{
		Type type = Type.GetType(name, throwOnError: false);
		if ((object)type == null)
		{
			type = AllTypes().FirstOrDefault((Type t) => t.FullName == name);
		}
		if ((object)type == null)
		{
			type = AllTypes().FirstOrDefault((Type t) => t.Name == name);
		}
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.TypeByName: Could not find type named " + name);
		}
		return type;
	}

	public static Type[] GetTypesFromAssembly(Assembly assembly)
	{
		try
		{
			return assembly.GetTypes();
		}
		catch (ReflectionTypeLoadException ex)
		{
			FileLog.Debug($"AccessTools.GetTypesFromAssembly: assembly {assembly} => {ex}");
			return ex.Types.Where((Type type) => (object)type != null).ToArray();
		}
	}

	public static IEnumerable<Type> AllTypes()
	{
		return AllAssemblies().SelectMany((Assembly a) => GetTypesFromAssembly(a));
	}

	public static IEnumerable<Type> InnerTypes(Type type)
	{
		return type.GetNestedTypes(all);
	}

	public static T FindIncludingBaseTypes<T>(Type type, Func<Type, T> func) where T : class
	{
		do
		{
			T val = func(type);
			if (val != null)
			{
				return val;
			}
			type = type.BaseType;
		}
		while ((object)type != null);
		return null;
	}

	public static T FindIncludingInnerTypes<T>(Type type, Func<Type, T> func) where T : class
	{
		T val = func(type);
		if (val != null)
		{
			return val;
		}
		Type[] nestedTypes = type.GetNestedTypes(all);
		foreach (Type type2 in nestedTypes)
		{
			val = FindIncludingInnerTypes(type2, func);
			if (val != null)
			{
				break;
			}
		}
		return val;
	}

	public static FieldInfo DeclaredField(Type type, string name)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.DeclaredField: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.DeclaredField: name is null");
			return null;
		}
		FieldInfo field = type.GetField(name, allDeclared);
		if ((object)field == null)
		{
			FileLog.Debug($"AccessTools.DeclaredField: Could not find field for type {type} and name {name}");
		}
		return field;
	}

	public static FieldInfo DeclaredField(string typeColonName)
	{
		Tools.TypeAndName typeAndName = Tools.TypColonName(typeColonName);
		FieldInfo field = typeAndName.type.GetField(typeAndName.name, allDeclared);
		if ((object)field == null)
		{
			FileLog.Debug($"AccessTools.DeclaredField: Could not find field for type {typeAndName.type} and name {typeAndName.name}");
		}
		return field;
	}

	public static FieldInfo Field(Type type, string name)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.Field: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.Field: name is null");
			return null;
		}
		FieldInfo fieldInfo = FindIncludingBaseTypes(type, (Type t) => t.GetField(name, all));
		if ((object)fieldInfo == null)
		{
			FileLog.Debug($"AccessTools.Field: Could not find field for type {type} and name {name}");
		}
		return fieldInfo;
	}

	public static FieldInfo Field(string typeColonName)
	{
		Tools.TypeAndName info = Tools.TypColonName(typeColonName);
		FieldInfo fieldInfo = FindIncludingBaseTypes(info.type, (Type t) => t.GetField(info.name, all));
		if ((object)fieldInfo == null)
		{
			FileLog.Debug($"AccessTools.Field: Could not find field for type {info.type} and name {info.name}");
		}
		return fieldInfo;
	}

	public static FieldInfo DeclaredField(Type type, int idx)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.DeclaredField: type is null");
			return null;
		}
		FieldInfo fieldInfo = GetDeclaredFields(type).ElementAtOrDefault(idx);
		if ((object)fieldInfo == null)
		{
			FileLog.Debug($"AccessTools.DeclaredField: Could not find field for type {type} and idx {idx}");
		}
		return fieldInfo;
	}

	public static PropertyInfo DeclaredProperty(Type type, string name)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.DeclaredProperty: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.DeclaredProperty: name is null");
			return null;
		}
		PropertyInfo property = type.GetProperty(name, allDeclared);
		if ((object)property == null)
		{
			FileLog.Debug($"AccessTools.DeclaredProperty: Could not find property for type {type} and name {name}");
		}
		return property;
	}

	public static PropertyInfo DeclaredProperty(string typeColonName)
	{
		Tools.TypeAndName typeAndName = Tools.TypColonName(typeColonName);
		PropertyInfo property = typeAndName.type.GetProperty(typeAndName.name, allDeclared);
		if ((object)property == null)
		{
			FileLog.Debug($"AccessTools.DeclaredProperty: Could not find property for type {typeAndName.type} and name {typeAndName.name}");
		}
		return property;
	}

	public static PropertyInfo DeclaredIndexer(Type type, Type[] parameters = null)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.DeclaredIndexer: type is null");
			return null;
		}
		try
		{
			PropertyInfo propertyInfo = ((parameters == null) ? type.GetProperties(allDeclared).SingleOrDefault((PropertyInfo property) => property.GetIndexParameters().Length != 0) : type.GetProperties(allDeclared).FirstOrDefault((PropertyInfo property) => (from param in property.GetIndexParameters()
				select param.ParameterType).SequenceEqual(parameters)));
			if ((object)propertyInfo == null)
			{
				FileLog.Debug($"AccessTools.DeclaredIndexer: Could not find indexer for type {type} and parameters {parameters?.Description()}");
			}
			return propertyInfo;
		}
		catch (InvalidOperationException inner)
		{
			throw new AmbiguousMatchException("Multiple possible indexers were found.", inner);
		}
	}

	public static MethodInfo DeclaredPropertyGetter(Type type, string name)
	{
		return DeclaredProperty(type, name)?.GetGetMethod(nonPublic: true);
	}

	public static MethodInfo DeclaredPropertyGetter(string typeColonName)
	{
		return DeclaredProperty(typeColonName)?.GetGetMethod(nonPublic: true);
	}

	public static MethodInfo DeclaredIndexerGetter(Type type, Type[] parameters = null)
	{
		return DeclaredIndexer(type, parameters)?.GetGetMethod(nonPublic: true);
	}

	public static MethodInfo DeclaredPropertySetter(Type type, string name)
	{
		return DeclaredProperty(type, name)?.GetSetMethod(nonPublic: true);
	}

	public static MethodInfo DeclaredPropertySetter(string typeColonName)
	{
		return DeclaredProperty(typeColonName)?.GetSetMethod(nonPublic: true);
	}

	public static MethodInfo DeclaredIndexerSetter(Type type, Type[] parameters)
	{
		return DeclaredIndexer(type, parameters)?.GetSetMethod(nonPublic: true);
	}

	public static PropertyInfo Property(Type type, string name)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.Property: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.Property: name is null");
			return null;
		}
		PropertyInfo propertyInfo = FindIncludingBaseTypes(type, (Type t) => t.GetProperty(name, all));
		if ((object)propertyInfo == null)
		{
			FileLog.Debug($"AccessTools.Property: Could not find property for type {type} and name {name}");
		}
		return propertyInfo;
	}

	public static PropertyInfo Property(string typeColonName)
	{
		Tools.TypeAndName info = Tools.TypColonName(typeColonName);
		PropertyInfo propertyInfo = FindIncludingBaseTypes(info.type, (Type t) => t.GetProperty(info.name, all));
		if ((object)propertyInfo == null)
		{
			FileLog.Debug($"AccessTools.Property: Could not find property for type {info.type} and name {info.name}");
		}
		return propertyInfo;
	}

	public static PropertyInfo Indexer(Type type, Type[] parameters = null)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.Indexer: type is null");
			return null;
		}
		Func<Type, PropertyInfo> func = ((parameters == null) ? ((Func<Type, PropertyInfo>)((Type t) => t.GetProperties(all).SingleOrDefault((PropertyInfo property) => property.GetIndexParameters().Length != 0))) : ((Func<Type, PropertyInfo>)((Type t) => t.GetProperties(all).FirstOrDefault((PropertyInfo property) => (from param in property.GetIndexParameters()
			select param.ParameterType).SequenceEqual(parameters)))));
		try
		{
			PropertyInfo propertyInfo = FindIncludingBaseTypes(type, func);
			if ((object)propertyInfo == null)
			{
				FileLog.Debug($"AccessTools.Indexer: Could not find indexer for type {type} and parameters {parameters?.Description()}");
			}
			return propertyInfo;
		}
		catch (InvalidOperationException inner)
		{
			throw new AmbiguousMatchException("Multiple possible indexers were found.", inner);
		}
	}

	public static MethodInfo PropertyGetter(Type type, string name)
	{
		return Property(type, name)?.GetGetMethod(nonPublic: true);
	}

	public static MethodInfo PropertyGetter(string typeColonName)
	{
		return Property(typeColonName)?.GetGetMethod(nonPublic: true);
	}

	public static MethodInfo IndexerGetter(Type type, Type[] parameters = null)
	{
		return Indexer(type, parameters)?.GetGetMethod(nonPublic: true);
	}

	public static MethodInfo PropertySetter(Type type, string name)
	{
		return Property(type, name)?.GetSetMethod(nonPublic: true);
	}

	public static MethodInfo PropertySetter(string typeColonName)
	{
		return Property(typeColonName)?.GetSetMethod(nonPublic: true);
	}

	public static MethodInfo IndexerSetter(Type type, Type[] parameters = null)
	{
		return Indexer(type, parameters)?.GetSetMethod(nonPublic: true);
	}

	public static MethodInfo DeclaredMethod(Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.DeclaredMethod: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.DeclaredMethod: name is null");
			return null;
		}
		ParameterModifier[] modifiers = new ParameterModifier[0];
		MethodInfo methodInfo = ((parameters != null) ? type.GetMethod(name, allDeclared, null, parameters, modifiers) : type.GetMethod(name, allDeclared));
		if ((object)methodInfo == null)
		{
			FileLog.Debug($"AccessTools.DeclaredMethod: Could not find method for type {type} and name {name} and parameters {parameters?.Description()}");
			return null;
		}
		if (generics != null)
		{
			methodInfo = methodInfo.MakeGenericMethod(generics);
		}
		return methodInfo;
	}

	public static MethodInfo DeclaredMethod(string typeColonName, Type[] parameters = null, Type[] generics = null)
	{
		Tools.TypeAndName typeAndName = Tools.TypColonName(typeColonName);
		return DeclaredMethod(typeAndName.type, typeAndName.name, parameters, generics);
	}

	public static MethodInfo Method(Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.Method: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.Method: name is null");
			return null;
		}
		ParameterModifier[] modifiers = new ParameterModifier[0];
		MethodInfo methodInfo;
		if (parameters == null)
		{
			try
			{
				methodInfo = FindIncludingBaseTypes(type, (Type t) => t.GetMethod(name, all));
			}
			catch (AmbiguousMatchException inner)
			{
				methodInfo = FindIncludingBaseTypes(type, (Type t) => t.GetMethod(name, all, null, Array.Empty<Type>(), modifiers));
				if ((object)methodInfo == null)
				{
					throw new AmbiguousMatchException($"Ambiguous match in Harmony patch for {type}:{name}", inner);
				}
			}
		}
		else
		{
			methodInfo = FindIncludingBaseTypes(type, (Type t) => t.GetMethod(name, all, null, parameters, modifiers));
		}
		if ((object)methodInfo == null)
		{
			FileLog.Debug($"AccessTools.Method: Could not find method for type {type} and name {name} and parameters {parameters?.Description()}");
			return null;
		}
		if (generics != null)
		{
			methodInfo = methodInfo.MakeGenericMethod(generics);
		}
		return methodInfo;
	}

	public static MethodInfo Method(string typeColonName, Type[] parameters = null, Type[] generics = null)
	{
		Tools.TypeAndName typeAndName = Tools.TypColonName(typeColonName);
		return Method(typeAndName.type, typeAndName.name, parameters, generics);
	}

	public static MethodInfo EnumeratorMoveNext(MethodBase method)
	{
		if ((object)method == null)
		{
			FileLog.Debug("AccessTools.EnumeratorMoveNext: method is null");
			return null;
		}
		IEnumerable<KeyValuePair<OpCode, object>> source = from pair in PatchProcessor.ReadMethodBody(method)
			where pair.Key == OpCodes.Newobj
			select pair;
		if (source.Count() != 1)
		{
			FileLog.Debug("AccessTools.EnumeratorMoveNext: " + method.FullDescription() + " contains no Newobj opcode");
			return null;
		}
		ConstructorInfo constructorInfo = source.First().Value as ConstructorInfo;
		if (constructorInfo == null)
		{
			FileLog.Debug("AccessTools.EnumeratorMoveNext: " + method.FullDescription() + " contains no constructor");
			return null;
		}
		Type declaringType = constructorInfo.DeclaringType;
		if (declaringType == null)
		{
			FileLog.Debug("AccessTools.EnumeratorMoveNext: " + method.FullDescription() + " refers to a global type");
			return null;
		}
		return Method(declaringType, "MoveNext");
	}

	public static MethodInfo AsyncMoveNext(MethodBase method)
	{
		if ((object)method == null)
		{
			FileLog.Debug("AccessTools.AsyncMoveNext: method is null");
			return null;
		}
		AsyncStateMachineAttribute customAttribute = method.GetCustomAttribute<AsyncStateMachineAttribute>();
		if (customAttribute == null)
		{
			FileLog.Debug("AccessTools.AsyncMoveNext: Could not find AsyncStateMachine for " + method.FullDescription());
			return null;
		}
		Type stateMachineType = customAttribute.StateMachineType;
		MethodInfo methodInfo = DeclaredMethod(stateMachineType, "MoveNext");
		if ((object)methodInfo == null)
		{
			FileLog.Debug("AccessTools.AsyncMoveNext: Could not find async method body for " + method.FullDescription());
			return null;
		}
		return methodInfo;
	}

	public static List<string> GetMethodNames(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetMethodNames: type is null");
			return new List<string>();
		}
		return (from m in GetDeclaredMethods(type)
			select m.Name).ToList();
	}

	public static List<string> GetMethodNames(object instance)
	{
		if (instance == null)
		{
			FileLog.Debug("AccessTools.GetMethodNames: instance is null");
			return new List<string>();
		}
		return GetMethodNames(instance.GetType());
	}

	public static List<string> GetFieldNames(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetFieldNames: type is null");
			return new List<string>();
		}
		return (from f in GetDeclaredFields(type)
			select f.Name).ToList();
	}

	public static List<string> GetFieldNames(object instance)
	{
		if (instance == null)
		{
			FileLog.Debug("AccessTools.GetFieldNames: instance is null");
			return new List<string>();
		}
		return GetFieldNames(instance.GetType());
	}

	public static List<string> GetPropertyNames(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetPropertyNames: type is null");
			return new List<string>();
		}
		return (from f in GetDeclaredProperties(type)
			select f.Name).ToList();
	}

	public static List<string> GetPropertyNames(object instance)
	{
		if (instance == null)
		{
			FileLog.Debug("AccessTools.GetPropertyNames: instance is null");
			return new List<string>();
		}
		return GetPropertyNames(instance.GetType());
	}

	public static Type GetUnderlyingType(this MemberInfo member)
	{
		return member.MemberType switch
		{
			MemberTypes.Event => ((EventInfo)member).EventHandlerType, 
			MemberTypes.Field => ((FieldInfo)member).FieldType, 
			MemberTypes.Method => ((MethodInfo)member).ReturnType, 
			MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
			_ => throw new ArgumentException("Member must be of type EventInfo, FieldInfo, MethodInfo, or PropertyInfo"), 
		};
	}

	public static bool IsDeclaredMember<T>(this T member) where T : MemberInfo
	{
		return member.DeclaringType == member.ReflectedType;
	}

	public static T GetDeclaredMember<T>(this T member) where T : MemberInfo
	{
		if ((object)member.DeclaringType == null || member.IsDeclaredMember())
		{
			return member;
		}
		int metadataToken = member.MetadataToken;
		MemberInfo[] array = member.DeclaringType?.GetMembers(all) ?? Array.Empty<MemberInfo>();
		MemberInfo[] array2 = array;
		foreach (MemberInfo memberInfo in array2)
		{
			if (memberInfo.MetadataToken == metadataToken)
			{
				return (T)memberInfo;
			}
		}
		return member;
	}

	public static ConstructorInfo DeclaredConstructor(Type type, Type[] parameters = null, bool searchForStatic = false)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.DeclaredConstructor: type is null");
			return null;
		}
		if (parameters == null)
		{
			parameters = Array.Empty<Type>();
		}
		BindingFlags bindingAttr = (searchForStatic ? (allDeclared & ~BindingFlags.Instance) : (allDeclared & ~BindingFlags.Static));
		return type.GetConstructor(bindingAttr, null, parameters, Array.Empty<ParameterModifier>());
	}

	public static ConstructorInfo Constructor(Type type, Type[] parameters = null, bool searchForStatic = false)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.ConstructorInfo: type is null");
			return null;
		}
		if (parameters == null)
		{
			parameters = Array.Empty<Type>();
		}
		BindingFlags flags = (searchForStatic ? (all & ~BindingFlags.Instance) : (all & ~BindingFlags.Static));
		return FindIncludingBaseTypes(type, (Type t) => t.GetConstructor(flags, null, parameters, Array.Empty<ParameterModifier>()));
	}

	public static List<ConstructorInfo> GetDeclaredConstructors(Type type, bool? searchForStatic = null)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetDeclaredConstructors: type is null");
			return new List<ConstructorInfo>();
		}
		BindingFlags bindingFlags = allDeclared;
		if (searchForStatic.HasValue)
		{
			bindingFlags = (searchForStatic.Value ? (bindingFlags & ~BindingFlags.Instance) : (bindingFlags & ~BindingFlags.Static));
		}
		return (from method in type.GetConstructors(bindingFlags)
			where method.DeclaringType == type
			select method).ToList();
	}

	public static List<MethodInfo> GetDeclaredMethods(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetDeclaredMethods: type is null");
			return new List<MethodInfo>();
		}
		MethodInfo[] methods = type.GetMethods(allDeclared);
		List<MethodInfo> list = new List<MethodInfo>(methods.Length);
		list.AddRange(methods);
		return list;
	}

	public static List<PropertyInfo> GetDeclaredProperties(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetDeclaredProperties: type is null");
			return new List<PropertyInfo>();
		}
		PropertyInfo[] properties = type.GetProperties(allDeclared);
		List<PropertyInfo> list = new List<PropertyInfo>(properties.Length);
		list.AddRange(properties);
		return list;
	}

	public static List<FieldInfo> GetDeclaredFields(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetDeclaredFields: type is null");
			return new List<FieldInfo>();
		}
		FieldInfo[] fields = type.GetFields(allDeclared);
		List<FieldInfo> list = new List<FieldInfo>(fields.Length);
		list.AddRange(fields);
		return list;
	}

	public static Type GetReturnedType(MethodBase methodOrConstructor)
	{
		if ((object)methodOrConstructor == null)
		{
			FileLog.Debug("AccessTools.GetReturnedType: methodOrConstructor is null");
			return null;
		}
		if (methodOrConstructor is ConstructorInfo)
		{
			return typeof(void);
		}
		return ((MethodInfo)methodOrConstructor).ReturnType;
	}

	public static Type Inner(Type type, string name)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.Inner: type is null");
			return null;
		}
		if (name == null)
		{
			FileLog.Debug("AccessTools.Inner: name is null");
			return null;
		}
		return FindIncludingBaseTypes(type, (Type t) => t.GetNestedType(name, all));
	}

	public static Type FirstInner(Type type, Func<Type, bool> predicate)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.FirstInner: type is null");
			return null;
		}
		if (predicate == null)
		{
			FileLog.Debug("AccessTools.FirstInner: predicate is null");
			return null;
		}
		return type.GetNestedTypes(all).FirstOrDefault((Type subType) => predicate(subType));
	}

	public static MethodInfo FirstMethod(Type type, Func<MethodInfo, bool> predicate)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.FirstMethod: type is null");
			return null;
		}
		if (predicate == null)
		{
			FileLog.Debug("AccessTools.FirstMethod: predicate is null");
			return null;
		}
		return type.GetMethods(allDeclared).FirstOrDefault((MethodInfo method) => predicate(method));
	}

	public static ConstructorInfo FirstConstructor(Type type, Func<ConstructorInfo, bool> predicate)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.FirstConstructor: type is null");
			return null;
		}
		if (predicate == null)
		{
			FileLog.Debug("AccessTools.FirstConstructor: predicate is null");
			return null;
		}
		return type.GetConstructors(allDeclared).FirstOrDefault((ConstructorInfo constructor) => predicate(constructor));
	}

	public static PropertyInfo FirstProperty(Type type, Func<PropertyInfo, bool> predicate)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.FirstProperty: type is null");
			return null;
		}
		if (predicate == null)
		{
			FileLog.Debug("AccessTools.FirstProperty: predicate is null");
			return null;
		}
		return type.GetProperties(allDeclared).FirstOrDefault((PropertyInfo property) => predicate(property));
	}

	public static Type[] GetTypes(object[] parameters)
	{
		if (parameters == null)
		{
			return Array.Empty<Type>();
		}
		return parameters.Select((object p) => (p != null) ? p.GetType() : typeof(object)).ToArray();
	}

	public static object[] ActualParameters(MethodBase method, object[] inputs)
	{
		List<Type> inputTypes = inputs.Select((object obj) => obj?.GetType()).ToList();
		return (from p in method.GetParameters()
			select p.ParameterType).Select(delegate(Type pType)
		{
			int num = inputTypes.FindIndex((Type inType) => (object)inType != null && pType.IsAssignableFrom(inType));
			return (num >= 0) ? inputs[num] : GetDefaultValue(pType);
		}).ToArray();
	}

	public static FieldRef<T, F> FieldRefAccess<T, F>(string fieldName)
	{
		if (fieldName == null)
		{
			throw new ArgumentNullException("fieldName");
		}
		try
		{
			Type typeFromHandle = typeof(T);
			if (typeFromHandle.IsValueType)
			{
				throw new ArgumentException("T (FieldRefAccess instance type) must not be a value type");
			}
			return Tools.FieldRefAccess<T, F>(Tools.GetInstanceField(typeFromHandle, fieldName), needCastclass: false);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"FieldRefAccess<{typeof(T)}, {typeof(F)}> for {fieldName} caused an exception", innerException);
		}
	}

	public static ref F FieldRefAccess<T, F>(T instance, string fieldName)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if (fieldName == null)
		{
			throw new ArgumentNullException("fieldName");
		}
		try
		{
			Type typeFromHandle = typeof(T);
			if (typeFromHandle.IsValueType)
			{
				throw new ArgumentException("T (FieldRefAccess instance type) must not be a value type");
			}
			return ref Tools.FieldRefAccess<T, F>(Tools.GetInstanceField(typeFromHandle, fieldName), needCastclass: false)(instance);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"FieldRefAccess<{typeof(T)}, {typeof(F)}> for {instance}, {fieldName} caused an exception", innerException);
		}
	}

	public static FieldRef<object, F> FieldRefAccess<F>(Type type, string fieldName)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (fieldName == null)
		{
			throw new ArgumentNullException("fieldName");
		}
		try
		{
			FieldInfo fieldInfo = Field(type, fieldName);
			if ((object)fieldInfo == null)
			{
				throw new MissingFieldException(type.Name, fieldName);
			}
			if (!fieldInfo.IsStatic)
			{
				Type declaringType = fieldInfo.DeclaringType;
				if ((object)declaringType != null && declaringType.IsValueType)
				{
					throw new ArgumentException("Either FieldDeclaringType must be a class or field must be static");
				}
			}
			return Tools.FieldRefAccess<object, F>(fieldInfo, needCastclass: true);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"FieldRefAccess<{typeof(F)}> for {type}, {fieldName} caused an exception", innerException);
		}
	}

	public static FieldRef<object, F> FieldRefAccess<F>(string typeColonName)
	{
		Tools.TypeAndName typeAndName = Tools.TypColonName(typeColonName);
		return FieldRefAccess<F>(typeAndName.type, typeAndName.name);
	}

	public static FieldRef<T, F> FieldRefAccess<T, F>(FieldInfo fieldInfo)
	{
		if ((object)fieldInfo == null)
		{
			throw new ArgumentNullException("fieldInfo");
		}
		try
		{
			Type typeFromHandle = typeof(T);
			if (typeFromHandle.IsValueType)
			{
				throw new ArgumentException("T (FieldRefAccess instance type) must not be a value type");
			}
			bool needCastclass = false;
			if (!fieldInfo.IsStatic)
			{
				Type declaringType = fieldInfo.DeclaringType;
				if ((object)declaringType != null)
				{
					if (declaringType.IsValueType)
					{
						throw new ArgumentException("Either FieldDeclaringType must be a class or field must be static");
					}
					needCastclass = Tools.FieldRefNeedsClasscast(typeFromHandle, declaringType);
				}
			}
			return Tools.FieldRefAccess<T, F>(fieldInfo, needCastclass);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"FieldRefAccess<{typeof(T)}, {typeof(F)}> for {fieldInfo} caused an exception", innerException);
		}
	}

	public static ref F FieldRefAccess<T, F>(T instance, FieldInfo fieldInfo)
	{
		if (instance == null)
		{
			throw new ArgumentNullException("instance");
		}
		if ((object)fieldInfo == null)
		{
			throw new ArgumentNullException("fieldInfo");
		}
		try
		{
			Type typeFromHandle = typeof(T);
			if (typeFromHandle.IsValueType)
			{
				throw new ArgumentException("T (FieldRefAccess instance type) must not be a value type");
			}
			if (fieldInfo.IsStatic)
			{
				throw new ArgumentException("Field must not be static");
			}
			bool needCastclass = false;
			Type declaringType = fieldInfo.DeclaringType;
			if ((object)declaringType != null)
			{
				if (declaringType.IsValueType)
				{
					throw new ArgumentException("FieldDeclaringType must be a class");
				}
				needCastclass = Tools.FieldRefNeedsClasscast(typeFromHandle, declaringType);
			}
			return ref Tools.FieldRefAccess<T, F>(fieldInfo, needCastclass)(instance);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"FieldRefAccess<{typeof(T)}, {typeof(F)}> for {instance}, {fieldInfo} caused an exception", innerException);
		}
	}

	public static StructFieldRef<T, F> StructFieldRefAccess<T, F>(string fieldName) where T : struct
	{
		if (fieldName == null)
		{
			throw new ArgumentNullException("fieldName");
		}
		try
		{
			return Tools.StructFieldRefAccess<T, F>(Tools.GetInstanceField(typeof(T), fieldName));
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StructFieldRefAccess<{typeof(T)}, {typeof(F)}> for {fieldName} caused an exception", innerException);
		}
	}

	public static ref F StructFieldRefAccess<T, F>(ref T instance, string fieldName) where T : struct
	{
		if (fieldName == null)
		{
			throw new ArgumentNullException("fieldName");
		}
		try
		{
			return ref Tools.StructFieldRefAccess<T, F>(Tools.GetInstanceField(typeof(T), fieldName))(ref instance);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StructFieldRefAccess<{typeof(T)}, {typeof(F)}> for {instance}, {fieldName} caused an exception", innerException);
		}
	}

	public static StructFieldRef<T, F> StructFieldRefAccess<T, F>(FieldInfo fieldInfo) where T : struct
	{
		if ((object)fieldInfo == null)
		{
			throw new ArgumentNullException("fieldInfo");
		}
		try
		{
			Tools.ValidateStructField<T, F>(fieldInfo);
			return Tools.StructFieldRefAccess<T, F>(fieldInfo);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StructFieldRefAccess<{typeof(T)}, {typeof(F)}> for {fieldInfo} caused an exception", innerException);
		}
	}

	public static ref F StructFieldRefAccess<T, F>(ref T instance, FieldInfo fieldInfo) where T : struct
	{
		if ((object)fieldInfo == null)
		{
			throw new ArgumentNullException("fieldInfo");
		}
		try
		{
			Tools.ValidateStructField<T, F>(fieldInfo);
			return ref Tools.StructFieldRefAccess<T, F>(fieldInfo)(ref instance);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StructFieldRefAccess<{typeof(T)}, {typeof(F)}> for {instance}, {fieldInfo} caused an exception", innerException);
		}
	}

	public static ref F StaticFieldRefAccess<T, F>(string fieldName)
	{
		return ref StaticFieldRefAccess<F>(typeof(T), fieldName);
	}

	public static ref F StaticFieldRefAccess<F>(Type type, string fieldName)
	{
		try
		{
			FieldInfo fieldInfo = Field(type, fieldName);
			if ((object)fieldInfo == null)
			{
				throw new MissingFieldException(type.Name, fieldName);
			}
			return ref Tools.StaticFieldRefAccess<F>(fieldInfo)();
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StaticFieldRefAccess<{typeof(F)}> for {type}, {fieldName} caused an exception", innerException);
		}
	}

	public static ref F StaticFieldRefAccess<F>(string typeColonName)
	{
		Tools.TypeAndName typeAndName = Tools.TypColonName(typeColonName);
		return ref StaticFieldRefAccess<F>(typeAndName.type, typeAndName.name);
	}

	public static ref F StaticFieldRefAccess<T, F>(FieldInfo fieldInfo)
	{
		if ((object)fieldInfo == null)
		{
			throw new ArgumentNullException("fieldInfo");
		}
		try
		{
			return ref Tools.StaticFieldRefAccess<F>(fieldInfo)();
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StaticFieldRefAccess<{typeof(T)}, {typeof(F)}> for {fieldInfo} caused an exception", innerException);
		}
	}

	public static FieldRef<F> StaticFieldRefAccess<F>(FieldInfo fieldInfo)
	{
		if ((object)fieldInfo == null)
		{
			throw new ArgumentNullException("fieldInfo");
		}
		try
		{
			return Tools.StaticFieldRefAccess<F>(fieldInfo);
		}
		catch (Exception innerException)
		{
			throw new ArgumentException($"StaticFieldRefAccess<{typeof(F)}> for {fieldInfo} caused an exception", innerException);
		}
	}

	public static DelegateType MethodDelegate<DelegateType>(MethodInfo method, object instance = null, bool virtualCall = true) where DelegateType : Delegate
	{
		if ((object)method == null)
		{
			throw new ArgumentNullException("method");
		}
		Type typeFromHandle = typeof(DelegateType);
		if (method.IsStatic)
		{
			return (DelegateType)Delegate.CreateDelegate(typeFromHandle, method);
		}
		Type type = method.DeclaringType;
		if (type != null && type.IsInterface && !virtualCall)
		{
			throw new ArgumentException("Interface methods must be called virtually");
		}
		if (instance == null)
		{
			ParameterInfo[] parameters = typeFromHandle.GetMethod("Invoke").GetParameters();
			if (parameters.Length == 0)
			{
				Delegate.CreateDelegate(typeof(DelegateType), method);
				throw new ArgumentException("Invalid delegate type");
			}
			Type parameterType = parameters[0].ParameterType;
			if (type != null && type.IsInterface && parameterType.IsValueType)
			{
				InterfaceMapping interfaceMap = parameterType.GetInterfaceMap(type);
				method = interfaceMap.TargetMethods[Array.IndexOf(interfaceMap.InterfaceMethods, method)];
				type = parameterType;
			}
			if (type != null && virtualCall)
			{
				if (type.IsInterface)
				{
					return (DelegateType)Delegate.CreateDelegate(typeFromHandle, method);
				}
				if (parameterType.IsInterface)
				{
					InterfaceMapping interfaceMap2 = type.GetInterfaceMap(parameterType);
					MethodInfo method2 = interfaceMap2.InterfaceMethods[Array.IndexOf(interfaceMap2.TargetMethods, method)];
					return (DelegateType)Delegate.CreateDelegate(typeFromHandle, method2);
				}
				if (!type.IsValueType)
				{
					return (DelegateType)Delegate.CreateDelegate(typeFromHandle, method.GetBaseDefinition());
				}
			}
			ParameterInfo[] parameters2 = method.GetParameters();
			int num = parameters2.Length;
			Type[] array = new Type[num + 1];
			array[0] = type;
			for (int i = 0; i < num; i++)
			{
				array[i + 1] = parameters2[i].ParameterType;
			}
			DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("OpenInstanceDelegate_" + method.Name, method.ReturnType, array);
			ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
			if (type != null && type.IsValueType)
			{
				iLGenerator.Emit(OpCodes.Ldarga_S, 0);
			}
			else
			{
				iLGenerator.Emit(OpCodes.Ldarg_0);
			}
			for (int j = 1; j < array.Length; j++)
			{
				iLGenerator.Emit(OpCodes.Ldarg, j);
			}
			iLGenerator.Emit(OpCodes.Call, method);
			iLGenerator.Emit(OpCodes.Ret);
			return (DelegateType)dynamicMethodDefinition.Generate().CreateDelegate(typeFromHandle);
		}
		if (virtualCall)
		{
			return (DelegateType)Delegate.CreateDelegate(typeFromHandle, instance, method.GetBaseDefinition());
		}
		if (type != null && !type.IsInstanceOfType(instance))
		{
			Delegate.CreateDelegate(typeof(DelegateType), instance, method);
			throw new ArgumentException("Invalid delegate type");
		}
		if (IsMonoRuntime)
		{
			DynamicMethodDefinition dynamicMethodDefinition2 = new DynamicMethodDefinition("LdftnDelegate_" + method.Name, typeFromHandle, new Type[1] { typeof(object) });
			ILGenerator iLGenerator2 = dynamicMethodDefinition2.GetILGenerator();
			iLGenerator2.Emit(OpCodes.Ldarg_0);
			iLGenerator2.Emit(OpCodes.Ldftn, method);
			iLGenerator2.Emit(OpCodes.Newobj, typeFromHandle.GetConstructor(new Type[2]
			{
				typeof(object),
				typeof(IntPtr)
			}));
			iLGenerator2.Emit(OpCodes.Ret);
			return (DelegateType)dynamicMethodDefinition2.Generate().Invoke(null, new object[1] { instance });
		}
		return (DelegateType)Activator.CreateInstance(typeFromHandle, instance, method.MethodHandle.GetFunctionPointer());
	}

	public static DelegateType MethodDelegate<DelegateType>(string typeColonName, object instance = null, bool virtualCall = true) where DelegateType : Delegate
	{
		MethodInfo method = DeclaredMethod(typeColonName);
		return MethodDelegate<DelegateType>(method, instance, virtualCall);
	}

	public static DelegateType HarmonyDelegate<DelegateType>(object instance = null) where DelegateType : Delegate
	{
		HarmonyMethod mergedFromType = HarmonyMethodExtensions.GetMergedFromType(typeof(DelegateType));
		HarmonyMethod harmonyMethod = mergedFromType;
		MethodType valueOrDefault = harmonyMethod.methodType.GetValueOrDefault();
		if (!harmonyMethod.methodType.HasValue)
		{
			valueOrDefault = MethodType.Normal;
			harmonyMethod.methodType = valueOrDefault;
		}
		if (!(mergedFromType.GetOriginalMethod() is MethodInfo method))
		{
			throw new NullReferenceException($"Delegate {typeof(DelegateType)} has no defined original method");
		}
		return MethodDelegate<DelegateType>(method, instance, !mergedFromType.nonVirtualDelegate);
	}

	public static MethodBase GetOutsideCaller()
	{
		StackTrace stackTrace = new StackTrace(fNeedFileInfo: true);
		StackFrame[] frames = stackTrace.GetFrames();
		foreach (StackFrame stackFrame in frames)
		{
			MethodBase method = stackFrame.GetMethod();
			if (method.DeclaringType?.Namespace != typeof(Harmony).Namespace)
			{
				return method;
			}
		}
		throw new Exception("Unexpected end of stack trace");
	}

	public static void RethrowException(Exception exception)
	{
		ExceptionDispatchInfo.Capture(exception).Throw();
		throw exception;
	}

	public static void ThrowMissingMemberException(Type type, params string[] names)
	{
		string value = string.Join(",", GetFieldNames(type).ToArray());
		string value2 = string.Join(",", GetPropertyNames(type).ToArray());
		throw new MissingMemberException($"{string.Join(",", names)}; available fields: {value}; available properties: {value2}");
	}

	public static object GetDefaultValue(Type type)
	{
		if ((object)type == null)
		{
			FileLog.Debug("AccessTools.GetDefaultValue: type is null");
			return null;
		}
		if (type == typeof(void))
		{
			return null;
		}
		if (type.IsValueType)
		{
			return Activator.CreateInstance(type);
		}
		return null;
	}

	public static object CreateInstance(Type type)
	{
		if ((object)type == null)
		{
			throw new ArgumentNullException("type");
		}
		ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, CallingConventions.Any, Array.Empty<Type>(), null);
		if ((object)constructor != null)
		{
			return constructor.Invoke(null);
		}
		return FormatterServices.GetUninitializedObject(type);
	}

	public static T CreateInstance<T>()
	{
		object obj = CreateInstance(typeof(T));
		if (obj is T)
		{
			return (T)obj;
		}
		return default(T);
	}

	public static T MakeDeepCopy<T>(object source) where T : class
	{
		return MakeDeepCopy(source, typeof(T)) as T;
	}

	public static void MakeDeepCopy<T>(object source, out T result, Func<string, Traverse, Traverse, object> processor = null, string pathRoot = "")
	{
		result = (T)MakeDeepCopy(source, typeof(T), processor, pathRoot);
	}

	public static object MakeDeepCopy(object source, Type resultType, Func<string, Traverse, Traverse, object> processor = null, string pathRoot = "")
	{
		if (source == null || (object)resultType == null)
		{
			return null;
		}
		resultType = Nullable.GetUnderlyingType(resultType) ?? resultType;
		Type type = source.GetType();
		if (type.IsPrimitive)
		{
			return source;
		}
		if (type.IsEnum)
		{
			return Enum.ToObject(resultType, (int)source);
		}
		if (type.IsGenericType && resultType.IsGenericType)
		{
			addHandlerCacheLock.EnterUpgradeableReadLock();
			try
			{
				if (!addHandlerCache.TryGetValue(resultType, out var value))
				{
					MethodInfo methodInfo = FirstMethod(resultType, (MethodInfo m) => m.Name == "Add" && m.GetParameters().Length == 1);
					if ((object)methodInfo != null)
					{
						value = HarmonyLib.MethodInvoker.GetHandler(methodInfo);
					}
					addHandlerCacheLock.EnterWriteLock();
					try
					{
						addHandlerCache[resultType] = value;
					}
					finally
					{
						addHandlerCacheLock.ExitWriteLock();
					}
				}
				if (value != null)
				{
					object obj = Activator.CreateInstance(resultType);
					Type resultType2 = resultType.GetGenericArguments()[0];
					int num = 0;
					foreach (object item in source as IEnumerable)
					{
						string text = num++.ToString();
						string pathRoot2 = ((pathRoot.Length > 0) ? (pathRoot + "." + text) : text);
						object obj2 = MakeDeepCopy(item, resultType2, processor, pathRoot2);
						value(obj, obj2);
					}
					return obj;
				}
			}
			finally
			{
				addHandlerCacheLock.ExitUpgradeableReadLock();
			}
		}
		if (type.IsArray && resultType.IsArray)
		{
			Type elementType = resultType.GetElementType();
			int length = ((Array)source).Length;
			object[] array = Activator.CreateInstance(resultType, length) as object[];
			object[] array2 = source as object[];
			for (int i = 0; i < length; i++)
			{
				string text2 = i.ToString();
				string pathRoot3 = ((pathRoot.Length > 0) ? (pathRoot + "." + text2) : text2);
				array[i] = MakeDeepCopy(array2[i], elementType, processor, pathRoot3);
			}
			return array;
		}
		string @namespace = type.Namespace;
		if (@namespace == "System" || (@namespace != null && @namespace.StartsWith("System.")))
		{
			return source;
		}
		object obj3 = CreateInstance((resultType == typeof(object)) ? type : resultType);
		Traverse.IterateFields(source, obj3, delegate(string name, Traverse src, Traverse dst)
		{
			string text3 = ((pathRoot.Length > 0) ? (pathRoot + "." + name) : name);
			object source2 = ((processor != null) ? processor(text3, src, dst) : src.GetValue());
			dst.SetValue(MakeDeepCopy(source2, dst.GetValueType(), processor, text3));
		});
		return obj3;
	}

	public static bool IsStruct(Type type)
	{
		if (type == null)
		{
			return false;
		}
		if (type.IsValueType && !IsValue(type))
		{
			return !IsVoid(type);
		}
		return false;
	}

	public static bool IsClass(Type type)
	{
		if (type == null)
		{
			return false;
		}
		return !type.IsValueType;
	}

	public static bool IsValue(Type type)
	{
		if (type == null)
		{
			return false;
		}
		if (!type.IsPrimitive)
		{
			return type.IsEnum;
		}
		return true;
	}

	public static bool IsInteger(Type type)
	{
		if (type == null)
		{
			return false;
		}
		TypeCode typeCode = Type.GetTypeCode(type);
		if ((uint)(typeCode - 5) <= 7u)
		{
			return true;
		}
		return false;
	}

	public static bool IsFloatingPoint(Type type)
	{
		if (type == null)
		{
			return false;
		}
		TypeCode typeCode = Type.GetTypeCode(type);
		if ((uint)(typeCode - 13) <= 2u)
		{
			return true;
		}
		return false;
	}

	public static bool IsNumber(Type type)
	{
		if (!IsInteger(type))
		{
			return IsFloatingPoint(type);
		}
		return true;
	}

	public static bool IsVoid(Type type)
	{
		return type == typeof(void);
	}

	public static bool IsOfNullableType<T>(T instance)
	{
		return (object)Nullable.GetUnderlyingType(typeof(T)) != null;
	}

	public static bool IsStatic(MemberInfo member)
	{
		if ((object)member == null)
		{
			throw new ArgumentNullException("member");
		}
		switch (member.MemberType)
		{
		case MemberTypes.Constructor:
		case MemberTypes.Method:
			return ((MethodBase)member).IsStatic;
		case MemberTypes.Event:
			return IsStatic((EventInfo)member);
		case MemberTypes.Field:
			return ((FieldInfo)member).IsStatic;
		case MemberTypes.Property:
			return IsStatic((PropertyInfo)member);
		case MemberTypes.TypeInfo:
		case MemberTypes.NestedType:
			return IsStatic((Type)member);
		default:
			throw new ArgumentException($"Unknown member type: {member.MemberType}");
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool IsStatic(Type type)
	{
		if ((object)type == null)
		{
			return false;
		}
		if (type.IsAbstract)
		{
			return type.IsSealed;
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool IsStatic(PropertyInfo propertyInfo)
	{
		if ((object)propertyInfo == null)
		{
			throw new ArgumentNullException("propertyInfo");
		}
		return propertyInfo.GetAccessors(nonPublic: true)[0].IsStatic;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool IsStatic(EventInfo eventInfo)
	{
		if ((object)eventInfo == null)
		{
			throw new ArgumentNullException("eventInfo");
		}
		return eventInfo.GetAddMethod(nonPublic: true).IsStatic;
	}

	public static int CombinedHashCode(IEnumerable<object> objects)
	{
		int num = 352654597;
		int num2 = num;
		int num3 = 0;
		foreach (object @object in objects)
		{
			if (num3 % 2 == 0)
			{
				num = ((num << 5) + num + (num >> 27)) ^ @object.GetHashCode();
			}
			else
			{
				num2 = ((num2 << 5) + num2 + (num2 >> 27)) ^ @object.GetHashCode();
			}
			num3++;
		}
		return num + num2 * 1566083941;
	}
}


public delegate ref F FieldRef<in T, F>(T instance = default(T));


public delegate ref F StructFieldRef<T, F>(ref T instance) where T : struct;


public delegate ref F FieldRef<F>();


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;
using HarmonyLib;

public static class AccessToolsExtensions
{
	public static IEnumerable<Type> InnerTypes(this Type type)
	{
		return AccessTools.InnerTypes(type);
	}

	public static T FindIncludingBaseTypes<T>(this Type type, Func<Type, T> func) where T : class
	{
		return AccessTools.FindIncludingBaseTypes(type, func);
	}

	public static T FindIncludingInnerTypes<T>(this Type type, Func<Type, T> func) where T : class
	{
		return AccessTools.FindIncludingInnerTypes(type, func);
	}

	public static FieldInfo DeclaredField(this Type type, string name)
	{
		return AccessTools.DeclaredField(type, name);
	}

	public static FieldInfo Field(this Type type, string name)
	{
		return AccessTools.Field(type, name);
	}

	public static FieldInfo DeclaredField(this Type type, int idx)
	{
		return AccessTools.DeclaredField(type, idx);
	}

	public static PropertyInfo DeclaredProperty(this Type type, string name)
	{
		return AccessTools.DeclaredProperty(type, name);
	}

	public static PropertyInfo DeclaredIndexer(this Type type, Type[] parameters = null)
	{
		return AccessTools.DeclaredIndexer(type, parameters);
	}

	public static MethodInfo DeclaredPropertyGetter(this Type type, string name)
	{
		return AccessTools.DeclaredPropertyGetter(type, name);
	}

	public static MethodInfo DeclaredIndexerGetter(this Type type, Type[] parameters = null)
	{
		return AccessTools.DeclaredIndexerGetter(type, parameters);
	}

	public static MethodInfo DeclaredPropertySetter(this Type type, string name)
	{
		return AccessTools.DeclaredPropertySetter(type, name);
	}

	public static MethodInfo DeclaredIndexerSetter(this Type type, Type[] parameters)
	{
		return AccessTools.DeclaredIndexerSetter(type, parameters);
	}

	public static PropertyInfo Property(this Type type, string name)
	{
		return AccessTools.Property(type, name);
	}

	public static PropertyInfo Indexer(this Type type, Type[] parameters = null)
	{
		return AccessTools.Indexer(type, parameters);
	}

	public static MethodInfo PropertyGetter(this Type type, string name)
	{
		return AccessTools.PropertyGetter(type, name);
	}

	public static MethodInfo IndexerGetter(this Type type, Type[] parameters = null)
	{
		return AccessTools.IndexerGetter(type, parameters);
	}

	public static MethodInfo PropertySetter(this Type type, string name)
	{
		return AccessTools.PropertySetter(type, name);
	}

	public static MethodInfo IndexerSetter(this Type type, Type[] parameters = null)
	{
		return AccessTools.IndexerSetter(type, parameters);
	}

	public static MethodInfo DeclaredMethod(this Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		return AccessTools.DeclaredMethod(type, name, parameters, generics);
	}

	public static MethodInfo Method(this Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		return AccessTools.Method(type, name, parameters, generics);
	}

	public static List<string> GetMethodNames(this Type type)
	{
		return AccessTools.GetMethodNames(type);
	}

	public static List<string> GetFieldNames(this Type type)
	{
		return AccessTools.GetFieldNames(type);
	}

	public static List<string> GetPropertyNames(this Type type)
	{
		return AccessTools.GetPropertyNames(type);
	}

	public static ConstructorInfo DeclaredConstructor(this Type type, Type[] parameters = null, bool searchForStatic = false)
	{
		return AccessTools.DeclaredConstructor(type, parameters, searchForStatic);
	}

	public static ConstructorInfo Constructor(this Type type, Type[] parameters = null, bool searchForStatic = false)
	{
		return AccessTools.Constructor(type, parameters, searchForStatic);
	}

	public static List<ConstructorInfo> GetDeclaredConstructors(this Type type, bool? searchForStatic = null)
	{
		return AccessTools.GetDeclaredConstructors(type, searchForStatic);
	}

	public static List<MethodInfo> GetDeclaredMethods(this Type type)
	{
		return AccessTools.GetDeclaredMethods(type);
	}

	public static List<PropertyInfo> GetDeclaredProperties(this Type type)
	{
		return AccessTools.GetDeclaredProperties(type);
	}

	public static List<FieldInfo> GetDeclaredFields(this Type type)
	{
		return AccessTools.GetDeclaredFields(type);
	}

	public static Type Inner(this Type type, string name)
	{
		return AccessTools.Inner(type, name);
	}

	public static Type FirstInner(this Type type, Func<Type, bool> predicate)
	{
		return AccessTools.FirstInner(type, predicate);
	}

	public static MethodInfo FirstMethod(this Type type, Func<MethodInfo, bool> predicate)
	{
		return AccessTools.FirstMethod(type, predicate);
	}

	public static ConstructorInfo FirstConstructor(this Type type, Func<ConstructorInfo, bool> predicate)
	{
		return AccessTools.FirstConstructor(type, predicate);
	}

	public static PropertyInfo FirstProperty(this Type type, Func<PropertyInfo, bool> predicate)
	{
		return AccessTools.FirstProperty(type, predicate);
	}

	public static AccessTools.FieldRef<object, F> FieldRefAccess<F>(this Type type, string fieldName)
	{
		return AccessTools.FieldRefAccess<F>(type, fieldName);
	}

	public static ref F StaticFieldRefAccess<F>(this Type type, string fieldName)
	{
		return ref AccessTools.StaticFieldRefAccess<F>(type, fieldName);
	}

	public static void ThrowMissingMemberException(this Type type, params string[] names)
	{
		AccessTools.ThrowMissingMemberException(type, names);
	}

	public static object GetDefaultValue(this Type type)
	{
		return AccessTools.GetDefaultValue(type);
	}

	public static object CreateInstance(this Type type)
	{
		return AccessTools.CreateInstance(type);
	}

	public static bool IsStruct(this Type type)
	{
		return AccessTools.IsStruct(type);
	}

	public static bool IsClass(this Type type)
	{
		return AccessTools.IsClass(type);
	}

	public static bool IsValue(this Type type)
	{
		return AccessTools.IsValue(type);
	}

	public static bool IsInteger(this Type type)
	{
		return AccessTools.IsInteger(type);
	}

	public static bool IsFloatingPoint(this Type type)
	{
		return AccessTools.IsFloatingPoint(type);
	}

	public static bool IsNumber(this Type type)
	{
		return AccessTools.IsNumber(type);
	}

	public static bool IsVoid(this Type type)
	{
		return AccessTools.IsVoid(type);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool IsStatic(this Type type)
	{
		return AccessTools.IsStatic(type);
	}
}


using System.Reflection.Emit;
using HarmonyLib;

public static class Code
{
	public class Operand_ : CodeMatch
	{
		public Operand_ this[object operand = null, string name = null] => (Operand_)Set(operand, name);

		public Operand_()
			: base(null, null, null)
		{
		}
	}

	public class Nop_ : CodeMatch
	{
		public Nop_ this[object operand = null, string name = null] => (Nop_)Set(OpCodes.Nop, operand, name);

		public Nop_()
			: base(null, null, null)
		{
		}
	}

	public class Break_ : CodeMatch
	{
		public Break_ this[object operand = null, string name = null] => (Break_)Set(OpCodes.Break, operand, name);

		public Break_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarg_0_ : CodeMatch
	{
		public Ldarg_0_ this[object operand = null, string name = null] => (Ldarg_0_)Set(OpCodes.Ldarg_0, operand, name);

		public Ldarg_0_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarg_1_ : CodeMatch
	{
		public Ldarg_1_ this[object operand = null, string name = null] => (Ldarg_1_)Set(OpCodes.Ldarg_1, operand, name);

		public Ldarg_1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarg_2_ : CodeMatch
	{
		public Ldarg_2_ this[object operand = null, string name = null] => (Ldarg_2_)Set(OpCodes.Ldarg_2, operand, name);

		public Ldarg_2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarg_3_ : CodeMatch
	{
		public Ldarg_3_ this[object operand = null, string name = null] => (Ldarg_3_)Set(OpCodes.Ldarg_3, operand, name);

		public Ldarg_3_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloc_0_ : CodeMatch
	{
		public Ldloc_0_ this[object operand = null, string name = null] => (Ldloc_0_)Set(OpCodes.Ldloc_0, operand, name);

		public Ldloc_0_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloc_1_ : CodeMatch
	{
		public Ldloc_1_ this[object operand = null, string name = null] => (Ldloc_1_)Set(OpCodes.Ldloc_1, operand, name);

		public Ldloc_1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloc_2_ : CodeMatch
	{
		public Ldloc_2_ this[object operand = null, string name = null] => (Ldloc_2_)Set(OpCodes.Ldloc_2, operand, name);

		public Ldloc_2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloc_3_ : CodeMatch
	{
		public Ldloc_3_ this[object operand = null, string name = null] => (Ldloc_3_)Set(OpCodes.Ldloc_3, operand, name);

		public Ldloc_3_()
			: base(null, null, null)
		{
		}
	}

	public class Stloc_0_ : CodeMatch
	{
		public Stloc_0_ this[object operand = null, string name = null] => (Stloc_0_)Set(OpCodes.Stloc_0, operand, name);

		public Stloc_0_()
			: base(null, null, null)
		{
		}
	}

	public class Stloc_1_ : CodeMatch
	{
		public Stloc_1_ this[object operand = null, string name = null] => (Stloc_1_)Set(OpCodes.Stloc_1, operand, name);

		public Stloc_1_()
			: base(null, null, null)
		{
		}
	}

	public class Stloc_2_ : CodeMatch
	{
		public Stloc_2_ this[object operand = null, string name = null] => (Stloc_2_)Set(OpCodes.Stloc_2, operand, name);

		public Stloc_2_()
			: base(null, null, null)
		{
		}
	}

	public class Stloc_3_ : CodeMatch
	{
		public Stloc_3_ this[object operand = null, string name = null] => (Stloc_3_)Set(OpCodes.Stloc_3, operand, name);

		public Stloc_3_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarg_S_ : CodeMatch
	{
		public Ldarg_S_ this[object operand = null, string name = null] => (Ldarg_S_)Set(OpCodes.Ldarg_S, operand, name);

		public Ldarg_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarga_S_ : CodeMatch
	{
		public Ldarga_S_ this[object operand = null, string name = null] => (Ldarga_S_)Set(OpCodes.Ldarga_S, operand, name);

		public Ldarga_S_()
			: base(null, null, null)
		{
		}
	}

	public class Starg_S_ : CodeMatch
	{
		public Starg_S_ this[object operand = null, string name = null] => (Starg_S_)Set(OpCodes.Starg_S, operand, name);

		public Starg_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloc_S_ : CodeMatch
	{
		public Ldloc_S_ this[object operand = null, string name = null] => (Ldloc_S_)Set(OpCodes.Ldloc_S, operand, name);

		public Ldloc_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloca_S_ : CodeMatch
	{
		public Ldloca_S_ this[object operand = null, string name = null] => (Ldloca_S_)Set(OpCodes.Ldloca_S, operand, name);

		public Ldloca_S_()
			: base(null, null, null)
		{
		}
	}

	public class Stloc_S_ : CodeMatch
	{
		public Stloc_S_ this[object operand = null, string name = null] => (Stloc_S_)Set(OpCodes.Stloc_S, operand, name);

		public Stloc_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ldnull_ : CodeMatch
	{
		public Ldnull_ this[object operand = null, string name = null] => (Ldnull_)Set(OpCodes.Ldnull, operand, name);

		public Ldnull_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_M1_ : CodeMatch
	{
		public Ldc_I4_M1_ this[object operand = null, string name = null] => (Ldc_I4_M1_)Set(OpCodes.Ldc_I4_M1, operand, name);

		public Ldc_I4_M1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_0_ : CodeMatch
	{
		public Ldc_I4_0_ this[object operand = null, string name = null] => (Ldc_I4_0_)Set(OpCodes.Ldc_I4_0, operand, name);

		public Ldc_I4_0_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_1_ : CodeMatch
	{
		public Ldc_I4_1_ this[object operand = null, string name = null] => (Ldc_I4_1_)Set(OpCodes.Ldc_I4_1, operand, name);

		public Ldc_I4_1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_2_ : CodeMatch
	{
		public Ldc_I4_2_ this[object operand = null, string name = null] => (Ldc_I4_2_)Set(OpCodes.Ldc_I4_2, operand, name);

		public Ldc_I4_2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_3_ : CodeMatch
	{
		public Ldc_I4_3_ this[object operand = null, string name = null] => (Ldc_I4_3_)Set(OpCodes.Ldc_I4_3, operand, name);

		public Ldc_I4_3_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_4_ : CodeMatch
	{
		public Ldc_I4_4_ this[object operand = null, string name = null] => (Ldc_I4_4_)Set(OpCodes.Ldc_I4_4, operand, name);

		public Ldc_I4_4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_5_ : CodeMatch
	{
		public Ldc_I4_5_ this[object operand = null, string name = null] => (Ldc_I4_5_)Set(OpCodes.Ldc_I4_5, operand, name);

		public Ldc_I4_5_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_6_ : CodeMatch
	{
		public Ldc_I4_6_ this[object operand = null, string name = null] => (Ldc_I4_6_)Set(OpCodes.Ldc_I4_6, operand, name);

		public Ldc_I4_6_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_7_ : CodeMatch
	{
		public Ldc_I4_7_ this[object operand = null, string name = null] => (Ldc_I4_7_)Set(OpCodes.Ldc_I4_7, operand, name);

		public Ldc_I4_7_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_8_ : CodeMatch
	{
		public Ldc_I4_8_ this[object operand = null, string name = null] => (Ldc_I4_8_)Set(OpCodes.Ldc_I4_8, operand, name);

		public Ldc_I4_8_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_S_ : CodeMatch
	{
		public Ldc_I4_S_ this[object operand = null, string name = null] => (Ldc_I4_S_)Set(OpCodes.Ldc_I4_S, operand, name);

		public Ldc_I4_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I4_ : CodeMatch
	{
		public Ldc_I4_ this[object operand = null, string name = null] => (Ldc_I4_)Set(OpCodes.Ldc_I4, operand, name);

		public Ldc_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_I8_ : CodeMatch
	{
		public Ldc_I8_ this[object operand = null, string name = null] => (Ldc_I8_)Set(OpCodes.Ldc_I8, operand, name);

		public Ldc_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_R4_ : CodeMatch
	{
		public Ldc_R4_ this[object operand = null, string name = null] => (Ldc_R4_)Set(OpCodes.Ldc_R4, operand, name);

		public Ldc_R4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldc_R8_ : CodeMatch
	{
		public Ldc_R8_ this[object operand = null, string name = null] => (Ldc_R8_)Set(OpCodes.Ldc_R8, operand, name);

		public Ldc_R8_()
			: base(null, null, null)
		{
		}
	}

	public class Dup_ : CodeMatch
	{
		public Dup_ this[object operand = null, string name = null] => (Dup_)Set(OpCodes.Dup, operand, name);

		public Dup_()
			: base(null, null, null)
		{
		}
	}

	public class Pop_ : CodeMatch
	{
		public Pop_ this[object operand = null, string name = null] => (Pop_)Set(OpCodes.Pop, operand, name);

		public Pop_()
			: base(null, null, null)
		{
		}
	}

	public class Jmp_ : CodeMatch
	{
		public Jmp_ this[object operand = null, string name = null] => (Jmp_)Set(OpCodes.Jmp, operand, name);

		public Jmp_()
			: base(null, null, null)
		{
		}
	}

	public class Call_ : CodeMatch
	{
		public Call_ this[object operand = null, string name = null] => (Call_)Set(OpCodes.Call, operand, name);

		public Call_()
			: base(null, null, null)
		{
		}
	}

	public class Calli_ : CodeMatch
	{
		public Calli_ this[object operand = null, string name = null] => (Calli_)Set(OpCodes.Calli, operand, name);

		public Calli_()
			: base(null, null, null)
		{
		}
	}

	public class Ret_ : CodeMatch
	{
		public Ret_ this[object operand = null, string name = null] => (Ret_)Set(OpCodes.Ret, operand, name);

		public Ret_()
			: base(null, null, null)
		{
		}
	}

	public class Br_S_ : CodeMatch
	{
		public Br_S_ this[object operand = null, string name = null] => (Br_S_)Set(OpCodes.Br_S, operand, name);

		public Br_S_()
			: base(null, null, null)
		{
		}
	}

	public class Brfalse_S_ : CodeMatch
	{
		public Brfalse_S_ this[object operand = null, string name = null] => (Brfalse_S_)Set(OpCodes.Brfalse_S, operand, name);

		public Brfalse_S_()
			: base(null, null, null)
		{
		}
	}

	public class Brtrue_S_ : CodeMatch
	{
		public Brtrue_S_ this[object operand = null, string name = null] => (Brtrue_S_)Set(OpCodes.Brtrue_S, operand, name);

		public Brtrue_S_()
			: base(null, null, null)
		{
		}
	}

	public class Beq_S_ : CodeMatch
	{
		public Beq_S_ this[object operand = null, string name = null] => (Beq_S_)Set(OpCodes.Beq_S, operand, name);

		public Beq_S_()
			: base(null, null, null)
		{
		}
	}

	public class Bge_S_ : CodeMatch
	{
		public Bge_S_ this[object operand = null, string name = null] => (Bge_S_)Set(OpCodes.Bge_S, operand, name);

		public Bge_S_()
			: base(null, null, null)
		{
		}
	}

	public class Bgt_S_ : CodeMatch
	{
		public Bgt_S_ this[object operand = null, string name = null] => (Bgt_S_)Set(OpCodes.Bgt_S, operand, name);

		public Bgt_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ble_S_ : CodeMatch
	{
		public Ble_S_ this[object operand = null, string name = null] => (Ble_S_)Set(OpCodes.Ble_S, operand, name);

		public Ble_S_()
			: base(null, null, null)
		{
		}
	}

	public class Blt_S_ : CodeMatch
	{
		public Blt_S_ this[object operand = null, string name = null] => (Blt_S_)Set(OpCodes.Blt_S, operand, name);

		public Blt_S_()
			: base(null, null, null)
		{
		}
	}

	public class Bne_Un_S_ : CodeMatch
	{
		public Bne_Un_S_ this[object operand = null, string name = null] => (Bne_Un_S_)Set(OpCodes.Bne_Un_S, operand, name);

		public Bne_Un_S_()
			: base(null, null, null)
		{
		}
	}

	public class Bge_Un_S_ : CodeMatch
	{
		public Bge_Un_S_ this[object operand = null, string name = null] => (Bge_Un_S_)Set(OpCodes.Bge_Un_S, operand, name);

		public Bge_Un_S_()
			: base(null, null, null)
		{
		}
	}

	public class Bgt_Un_S_ : CodeMatch
	{
		public Bgt_Un_S_ this[object operand = null, string name = null] => (Bgt_Un_S_)Set(OpCodes.Bgt_Un_S, operand, name);

		public Bgt_Un_S_()
			: base(null, null, null)
		{
		}
	}

	public class Ble_Un_S_ : CodeMatch
	{
		public Ble_Un_S_ this[object operand = null, string name = null] => (Ble_Un_S_)Set(OpCodes.Ble_Un_S, operand, name);

		public Ble_Un_S_()
			: base(null, null, null)
		{
		}
	}

	public class Blt_Un_S_ : CodeMatch
	{
		public Blt_Un_S_ this[object operand = null, string name = null] => (Blt_Un_S_)Set(OpCodes.Blt_Un_S, operand, name);

		public Blt_Un_S_()
			: base(null, null, null)
		{
		}
	}

	public class Br_ : CodeMatch
	{
		public Br_ this[object operand = null, string name = null] => (Br_)Set(OpCodes.Br, operand, name);

		public Br_()
			: base(null, null, null)
		{
		}
	}

	public class Brfalse_ : CodeMatch
	{
		public Brfalse_ this[object operand = null, string name = null] => (Brfalse_)Set(OpCodes.Brfalse, operand, name);

		public Brfalse_()
			: base(null, null, null)
		{
		}
	}

	public class Brtrue_ : CodeMatch
	{
		public Brtrue_ this[object operand = null, string name = null] => (Brtrue_)Set(OpCodes.Brtrue, operand, name);

		public Brtrue_()
			: base(null, null, null)
		{
		}
	}

	public class Beq_ : CodeMatch
	{
		public Beq_ this[object operand = null, string name = null] => (Beq_)Set(OpCodes.Beq, operand, name);

		public Beq_()
			: base(null, null, null)
		{
		}
	}

	public class Bge_ : CodeMatch
	{
		public Bge_ this[object operand = null, string name = null] => (Bge_)Set(OpCodes.Bge, operand, name);

		public Bge_()
			: base(null, null, null)
		{
		}
	}

	public class Bgt_ : CodeMatch
	{
		public Bgt_ this[object operand = null, string name = null] => (Bgt_)Set(OpCodes.Bgt, operand, name);

		public Bgt_()
			: base(null, null, null)
		{
		}
	}

	public class Ble_ : CodeMatch
	{
		public Ble_ this[object operand = null, string name = null] => (Ble_)Set(OpCodes.Ble, operand, name);

		public Ble_()
			: base(null, null, null)
		{
		}
	}

	public class Blt_ : CodeMatch
	{
		public Blt_ this[object operand = null, string name = null] => (Blt_)Set(OpCodes.Blt, operand, name);

		public Blt_()
			: base(null, null, null)
		{
		}
	}

	public class Bne_Un_ : CodeMatch
	{
		public Bne_Un_ this[object operand = null, string name = null] => (Bne_Un_)Set(OpCodes.Bne_Un, operand, name);

		public Bne_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Bge_Un_ : CodeMatch
	{
		public Bge_Un_ this[object operand = null, string name = null] => (Bge_Un_)Set(OpCodes.Bge_Un, operand, name);

		public Bge_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Bgt_Un_ : CodeMatch
	{
		public Bgt_Un_ this[object operand = null, string name = null] => (Bgt_Un_)Set(OpCodes.Bgt_Un, operand, name);

		public Bgt_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Ble_Un_ : CodeMatch
	{
		public Ble_Un_ this[object operand = null, string name = null] => (Ble_Un_)Set(OpCodes.Ble_Un, operand, name);

		public Ble_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Blt_Un_ : CodeMatch
	{
		public Blt_Un_ this[object operand = null, string name = null] => (Blt_Un_)Set(OpCodes.Blt_Un, operand, name);

		public Blt_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Switch_ : CodeMatch
	{
		public Switch_ this[object operand = null, string name = null] => (Switch_)Set(OpCodes.Switch, operand, name);

		public Switch_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_I1_ : CodeMatch
	{
		public Ldind_I1_ this[object operand = null, string name = null] => (Ldind_I1_)Set(OpCodes.Ldind_I1, operand, name);

		public Ldind_I1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_U1_ : CodeMatch
	{
		public Ldind_U1_ this[object operand = null, string name = null] => (Ldind_U1_)Set(OpCodes.Ldind_U1, operand, name);

		public Ldind_U1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_I2_ : CodeMatch
	{
		public Ldind_I2_ this[object operand = null, string name = null] => (Ldind_I2_)Set(OpCodes.Ldind_I2, operand, name);

		public Ldind_I2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_U2_ : CodeMatch
	{
		public Ldind_U2_ this[object operand = null, string name = null] => (Ldind_U2_)Set(OpCodes.Ldind_U2, operand, name);

		public Ldind_U2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_I4_ : CodeMatch
	{
		public Ldind_I4_ this[object operand = null, string name = null] => (Ldind_I4_)Set(OpCodes.Ldind_I4, operand, name);

		public Ldind_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_U4_ : CodeMatch
	{
		public Ldind_U4_ this[object operand = null, string name = null] => (Ldind_U4_)Set(OpCodes.Ldind_U4, operand, name);

		public Ldind_U4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_I8_ : CodeMatch
	{
		public Ldind_I8_ this[object operand = null, string name = null] => (Ldind_I8_)Set(OpCodes.Ldind_I8, operand, name);

		public Ldind_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_I_ : CodeMatch
	{
		public Ldind_I_ this[object operand = null, string name = null] => (Ldind_I_)Set(OpCodes.Ldind_I, operand, name);

		public Ldind_I_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_R4_ : CodeMatch
	{
		public Ldind_R4_ this[object operand = null, string name = null] => (Ldind_R4_)Set(OpCodes.Ldind_R4, operand, name);

		public Ldind_R4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_R8_ : CodeMatch
	{
		public Ldind_R8_ this[object operand = null, string name = null] => (Ldind_R8_)Set(OpCodes.Ldind_R8, operand, name);

		public Ldind_R8_()
			: base(null, null, null)
		{
		}
	}

	public class Ldind_Ref_ : CodeMatch
	{
		public Ldind_Ref_ this[object operand = null, string name = null] => (Ldind_Ref_)Set(OpCodes.Ldind_Ref, operand, name);

		public Ldind_Ref_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_Ref_ : CodeMatch
	{
		public Stind_Ref_ this[object operand = null, string name = null] => (Stind_Ref_)Set(OpCodes.Stind_Ref, operand, name);

		public Stind_Ref_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_I1_ : CodeMatch
	{
		public Stind_I1_ this[object operand = null, string name = null] => (Stind_I1_)Set(OpCodes.Stind_I1, operand, name);

		public Stind_I1_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_I2_ : CodeMatch
	{
		public Stind_I2_ this[object operand = null, string name = null] => (Stind_I2_)Set(OpCodes.Stind_I2, operand, name);

		public Stind_I2_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_I4_ : CodeMatch
	{
		public Stind_I4_ this[object operand = null, string name = null] => (Stind_I4_)Set(OpCodes.Stind_I4, operand, name);

		public Stind_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_I8_ : CodeMatch
	{
		public Stind_I8_ this[object operand = null, string name = null] => (Stind_I8_)Set(OpCodes.Stind_I8, operand, name);

		public Stind_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_R4_ : CodeMatch
	{
		public Stind_R4_ this[object operand = null, string name = null] => (Stind_R4_)Set(OpCodes.Stind_R4, operand, name);

		public Stind_R4_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_R8_ : CodeMatch
	{
		public Stind_R8_ this[object operand = null, string name = null] => (Stind_R8_)Set(OpCodes.Stind_R8, operand, name);

		public Stind_R8_()
			: base(null, null, null)
		{
		}
	}

	public class Add_ : CodeMatch
	{
		public Add_ this[object operand = null, string name = null] => (Add_)Set(OpCodes.Add, operand, name);

		public Add_()
			: base(null, null, null)
		{
		}
	}

	public class Sub_ : CodeMatch
	{
		public Sub_ this[object operand = null, string name = null] => (Sub_)Set(OpCodes.Sub, operand, name);

		public Sub_()
			: base(null, null, null)
		{
		}
	}

	public class Mul_ : CodeMatch
	{
		public Mul_ this[object operand = null, string name = null] => (Mul_)Set(OpCodes.Mul, operand, name);

		public Mul_()
			: base(null, null, null)
		{
		}
	}

	public class Div_ : CodeMatch
	{
		public Div_ this[object operand = null, string name = null] => (Div_)Set(OpCodes.Div, operand, name);

		public Div_()
			: base(null, null, null)
		{
		}
	}

	public class Div_Un_ : CodeMatch
	{
		public Div_Un_ this[object operand = null, string name = null] => (Div_Un_)Set(OpCodes.Div_Un, operand, name);

		public Div_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Rem_ : CodeMatch
	{
		public Rem_ this[object operand = null, string name = null] => (Rem_)Set(OpCodes.Rem, operand, name);

		public Rem_()
			: base(null, null, null)
		{
		}
	}

	public class Rem_Un_ : CodeMatch
	{
		public Rem_Un_ this[object operand = null, string name = null] => (Rem_Un_)Set(OpCodes.Rem_Un, operand, name);

		public Rem_Un_()
			: base(null, null, null)
		{
		}
	}

	public class And_ : CodeMatch
	{
		public And_ this[object operand = null, string name = null] => (And_)Set(OpCodes.And, operand, name);

		public And_()
			: base(null, null, null)
		{
		}
	}

	public class Or_ : CodeMatch
	{
		public Or_ this[object operand = null, string name = null] => (Or_)Set(OpCodes.Or, operand, name);

		public Or_()
			: base(null, null, null)
		{
		}
	}

	public class Xor_ : CodeMatch
	{
		public Xor_ this[object operand = null, string name = null] => (Xor_)Set(OpCodes.Xor, operand, name);

		public Xor_()
			: base(null, null, null)
		{
		}
	}

	public class Shl_ : CodeMatch
	{
		public Shl_ this[object operand = null, string name = null] => (Shl_)Set(OpCodes.Shl, operand, name);

		public Shl_()
			: base(null, null, null)
		{
		}
	}

	public class Shr_ : CodeMatch
	{
		public Shr_ this[object operand = null, string name = null] => (Shr_)Set(OpCodes.Shr, operand, name);

		public Shr_()
			: base(null, null, null)
		{
		}
	}

	public class Shr_Un_ : CodeMatch
	{
		public Shr_Un_ this[object operand = null, string name = null] => (Shr_Un_)Set(OpCodes.Shr_Un, operand, name);

		public Shr_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Neg_ : CodeMatch
	{
		public Neg_ this[object operand = null, string name = null] => (Neg_)Set(OpCodes.Neg, operand, name);

		public Neg_()
			: base(null, null, null)
		{
		}
	}

	public class Not_ : CodeMatch
	{
		public Not_ this[object operand = null, string name = null] => (Not_)Set(OpCodes.Not, operand, name);

		public Not_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_I1_ : CodeMatch
	{
		public Conv_I1_ this[object operand = null, string name = null] => (Conv_I1_)Set(OpCodes.Conv_I1, operand, name);

		public Conv_I1_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_I2_ : CodeMatch
	{
		public Conv_I2_ this[object operand = null, string name = null] => (Conv_I2_)Set(OpCodes.Conv_I2, operand, name);

		public Conv_I2_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_I4_ : CodeMatch
	{
		public Conv_I4_ this[object operand = null, string name = null] => (Conv_I4_)Set(OpCodes.Conv_I4, operand, name);

		public Conv_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_I8_ : CodeMatch
	{
		public Conv_I8_ this[object operand = null, string name = null] => (Conv_I8_)Set(OpCodes.Conv_I8, operand, name);

		public Conv_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_R4_ : CodeMatch
	{
		public Conv_R4_ this[object operand = null, string name = null] => (Conv_R4_)Set(OpCodes.Conv_R4, operand, name);

		public Conv_R4_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_R8_ : CodeMatch
	{
		public Conv_R8_ this[object operand = null, string name = null] => (Conv_R8_)Set(OpCodes.Conv_R8, operand, name);

		public Conv_R8_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_U4_ : CodeMatch
	{
		public Conv_U4_ this[object operand = null, string name = null] => (Conv_U4_)Set(OpCodes.Conv_U4, operand, name);

		public Conv_U4_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_U8_ : CodeMatch
	{
		public Conv_U8_ this[object operand = null, string name = null] => (Conv_U8_)Set(OpCodes.Conv_U8, operand, name);

		public Conv_U8_()
			: base(null, null, null)
		{
		}
	}

	public class Callvirt_ : CodeMatch
	{
		public Callvirt_ this[object operand = null, string name = null] => (Callvirt_)Set(OpCodes.Callvirt, operand, name);

		public Callvirt_()
			: base(null, null, null)
		{
		}
	}

	public class Cpobj_ : CodeMatch
	{
		public Cpobj_ this[object operand = null, string name = null] => (Cpobj_)Set(OpCodes.Cpobj, operand, name);

		public Cpobj_()
			: base(null, null, null)
		{
		}
	}

	public class Ldobj_ : CodeMatch
	{
		public Ldobj_ this[object operand = null, string name = null] => (Ldobj_)Set(OpCodes.Ldobj, operand, name);

		public Ldobj_()
			: base(null, null, null)
		{
		}
	}

	public class Ldstr_ : CodeMatch
	{
		public Ldstr_ this[object operand = null, string name = null] => (Ldstr_)Set(OpCodes.Ldstr, operand, name);

		public Ldstr_()
			: base(null, null, null)
		{
		}
	}

	public class Newobj_ : CodeMatch
	{
		public Newobj_ this[object operand = null, string name = null] => (Newobj_)Set(OpCodes.Newobj, operand, name);

		public Newobj_()
			: base(null, null, null)
		{
		}
	}

	public class Castclass_ : CodeMatch
	{
		public Castclass_ this[object operand = null, string name = null] => (Castclass_)Set(OpCodes.Castclass, operand, name);

		public Castclass_()
			: base(null, null, null)
		{
		}
	}

	public class Isinst_ : CodeMatch
	{
		public Isinst_ this[object operand = null, string name = null] => (Isinst_)Set(OpCodes.Isinst, operand, name);

		public Isinst_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_R_Un_ : CodeMatch
	{
		public Conv_R_Un_ this[object operand = null, string name = null] => (Conv_R_Un_)Set(OpCodes.Conv_R_Un, operand, name);

		public Conv_R_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Unbox_ : CodeMatch
	{
		public Unbox_ this[object operand = null, string name = null] => (Unbox_)Set(OpCodes.Unbox, operand, name);

		public Unbox_()
			: base(null, null, null)
		{
		}
	}

	public class Throw_ : CodeMatch
	{
		public Throw_ this[object operand = null, string name = null] => (Throw_)Set(OpCodes.Throw, operand, name);

		public Throw_()
			: base(null, null, null)
		{
		}
	}

	public class Ldfld_ : CodeMatch
	{
		public Ldfld_ this[object operand = null, string name = null] => (Ldfld_)Set(OpCodes.Ldfld, operand, name);

		public Ldfld_()
			: base(null, null, null)
		{
		}
	}

	public class Ldflda_ : CodeMatch
	{
		public Ldflda_ this[object operand = null, string name = null] => (Ldflda_)Set(OpCodes.Ldflda, operand, name);

		public Ldflda_()
			: base(null, null, null)
		{
		}
	}

	public class Stfld_ : CodeMatch
	{
		public Stfld_ this[object operand = null, string name = null] => (Stfld_)Set(OpCodes.Stfld, operand, name);

		public Stfld_()
			: base(null, null, null)
		{
		}
	}

	public class Ldsfld_ : CodeMatch
	{
		public Ldsfld_ this[object operand = null, string name = null] => (Ldsfld_)Set(OpCodes.Ldsfld, operand, name);

		public Ldsfld_()
			: base(null, null, null)
		{
		}
	}

	public class Ldsflda_ : CodeMatch
	{
		public Ldsflda_ this[object operand = null, string name = null] => (Ldsflda_)Set(OpCodes.Ldsflda, operand, name);

		public Ldsflda_()
			: base(null, null, null)
		{
		}
	}

	public class Stsfld_ : CodeMatch
	{
		public Stsfld_ this[object operand = null, string name = null] => (Stsfld_)Set(OpCodes.Stsfld, operand, name);

		public Stsfld_()
			: base(null, null, null)
		{
		}
	}

	public class Stobj_ : CodeMatch
	{
		public Stobj_ this[object operand = null, string name = null] => (Stobj_)Set(OpCodes.Stobj, operand, name);

		public Stobj_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I1_Un_ : CodeMatch
	{
		public Conv_Ovf_I1_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I1_Un_)Set(OpCodes.Conv_Ovf_I1_Un, operand, name);

		public Conv_Ovf_I1_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I2_Un_ : CodeMatch
	{
		public Conv_Ovf_I2_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I2_Un_)Set(OpCodes.Conv_Ovf_I2_Un, operand, name);

		public Conv_Ovf_I2_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I4_Un_ : CodeMatch
	{
		public Conv_Ovf_I4_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I4_Un_)Set(OpCodes.Conv_Ovf_I4_Un, operand, name);

		public Conv_Ovf_I4_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I8_Un_ : CodeMatch
	{
		public Conv_Ovf_I8_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I8_Un_)Set(OpCodes.Conv_Ovf_I8_Un, operand, name);

		public Conv_Ovf_I8_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U1_Un_ : CodeMatch
	{
		public Conv_Ovf_U1_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U1_Un_)Set(OpCodes.Conv_Ovf_U1_Un, operand, name);

		public Conv_Ovf_U1_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U2_Un_ : CodeMatch
	{
		public Conv_Ovf_U2_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U2_Un_)Set(OpCodes.Conv_Ovf_U2_Un, operand, name);

		public Conv_Ovf_U2_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U4_Un_ : CodeMatch
	{
		public Conv_Ovf_U4_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U4_Un_)Set(OpCodes.Conv_Ovf_U4_Un, operand, name);

		public Conv_Ovf_U4_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U8_Un_ : CodeMatch
	{
		public Conv_Ovf_U8_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U8_Un_)Set(OpCodes.Conv_Ovf_U8_Un, operand, name);

		public Conv_Ovf_U8_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I_Un_ : CodeMatch
	{
		public Conv_Ovf_I_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I_Un_)Set(OpCodes.Conv_Ovf_I_Un, operand, name);

		public Conv_Ovf_I_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U_Un_ : CodeMatch
	{
		public Conv_Ovf_U_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U_Un_)Set(OpCodes.Conv_Ovf_U_Un, operand, name);

		public Conv_Ovf_U_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Box_ : CodeMatch
	{
		public Box_ this[object operand = null, string name = null] => (Box_)Set(OpCodes.Box, operand, name);

		public Box_()
			: base(null, null, null)
		{
		}
	}

	public class Newarr_ : CodeMatch
	{
		public Newarr_ this[object operand = null, string name = null] => (Newarr_)Set(OpCodes.Newarr, operand, name);

		public Newarr_()
			: base(null, null, null)
		{
		}
	}

	public class Ldlen_ : CodeMatch
	{
		public Ldlen_ this[object operand = null, string name = null] => (Ldlen_)Set(OpCodes.Ldlen, operand, name);

		public Ldlen_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelema_ : CodeMatch
	{
		public Ldelema_ this[object operand = null, string name = null] => (Ldelema_)Set(OpCodes.Ldelema, operand, name);

		public Ldelema_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_I1_ : CodeMatch
	{
		public Ldelem_I1_ this[object operand = null, string name = null] => (Ldelem_I1_)Set(OpCodes.Ldelem_I1, operand, name);

		public Ldelem_I1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_U1_ : CodeMatch
	{
		public Ldelem_U1_ this[object operand = null, string name = null] => (Ldelem_U1_)Set(OpCodes.Ldelem_U1, operand, name);

		public Ldelem_U1_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_I2_ : CodeMatch
	{
		public Ldelem_I2_ this[object operand = null, string name = null] => (Ldelem_I2_)Set(OpCodes.Ldelem_I2, operand, name);

		public Ldelem_I2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_U2_ : CodeMatch
	{
		public Ldelem_U2_ this[object operand = null, string name = null] => (Ldelem_U2_)Set(OpCodes.Ldelem_U2, operand, name);

		public Ldelem_U2_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_I4_ : CodeMatch
	{
		public Ldelem_I4_ this[object operand = null, string name = null] => (Ldelem_I4_)Set(OpCodes.Ldelem_I4, operand, name);

		public Ldelem_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_U4_ : CodeMatch
	{
		public Ldelem_U4_ this[object operand = null, string name = null] => (Ldelem_U4_)Set(OpCodes.Ldelem_U4, operand, name);

		public Ldelem_U4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_I8_ : CodeMatch
	{
		public Ldelem_I8_ this[object operand = null, string name = null] => (Ldelem_I8_)Set(OpCodes.Ldelem_I8, operand, name);

		public Ldelem_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_I_ : CodeMatch
	{
		public Ldelem_I_ this[object operand = null, string name = null] => (Ldelem_I_)Set(OpCodes.Ldelem_I, operand, name);

		public Ldelem_I_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_R4_ : CodeMatch
	{
		public Ldelem_R4_ this[object operand = null, string name = null] => (Ldelem_R4_)Set(OpCodes.Ldelem_R4, operand, name);

		public Ldelem_R4_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_R8_ : CodeMatch
	{
		public Ldelem_R8_ this[object operand = null, string name = null] => (Ldelem_R8_)Set(OpCodes.Ldelem_R8, operand, name);

		public Ldelem_R8_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_Ref_ : CodeMatch
	{
		public Ldelem_Ref_ this[object operand = null, string name = null] => (Ldelem_Ref_)Set(OpCodes.Ldelem_Ref, operand, name);

		public Ldelem_Ref_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_I_ : CodeMatch
	{
		public Stelem_I_ this[object operand = null, string name = null] => (Stelem_I_)Set(OpCodes.Stelem_I, operand, name);

		public Stelem_I_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_I1_ : CodeMatch
	{
		public Stelem_I1_ this[object operand = null, string name = null] => (Stelem_I1_)Set(OpCodes.Stelem_I1, operand, name);

		public Stelem_I1_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_I2_ : CodeMatch
	{
		public Stelem_I2_ this[object operand = null, string name = null] => (Stelem_I2_)Set(OpCodes.Stelem_I2, operand, name);

		public Stelem_I2_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_I4_ : CodeMatch
	{
		public Stelem_I4_ this[object operand = null, string name = null] => (Stelem_I4_)Set(OpCodes.Stelem_I4, operand, name);

		public Stelem_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_I8_ : CodeMatch
	{
		public Stelem_I8_ this[object operand = null, string name = null] => (Stelem_I8_)Set(OpCodes.Stelem_I8, operand, name);

		public Stelem_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_R4_ : CodeMatch
	{
		public Stelem_R4_ this[object operand = null, string name = null] => (Stelem_R4_)Set(OpCodes.Stelem_R4, operand, name);

		public Stelem_R4_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_R8_ : CodeMatch
	{
		public Stelem_R8_ this[object operand = null, string name = null] => (Stelem_R8_)Set(OpCodes.Stelem_R8, operand, name);

		public Stelem_R8_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_Ref_ : CodeMatch
	{
		public Stelem_Ref_ this[object operand = null, string name = null] => (Stelem_Ref_)Set(OpCodes.Stelem_Ref, operand, name);

		public Stelem_Ref_()
			: base(null, null, null)
		{
		}
	}

	public class Ldelem_ : CodeMatch
	{
		public Ldelem_ this[object operand = null, string name = null] => (Ldelem_)Set(OpCodes.Ldelem, operand, name);

		public Ldelem_()
			: base(null, null, null)
		{
		}
	}

	public class Stelem_ : CodeMatch
	{
		public Stelem_ this[object operand = null, string name = null] => (Stelem_)Set(OpCodes.Stelem, operand, name);

		public Stelem_()
			: base(null, null, null)
		{
		}
	}

	public class Unbox_Any_ : CodeMatch
	{
		public Unbox_Any_ this[object operand = null, string name = null] => (Unbox_Any_)Set(OpCodes.Unbox_Any, operand, name);

		public Unbox_Any_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I1_ : CodeMatch
	{
		public Conv_Ovf_I1_ this[object operand = null, string name = null] => (Conv_Ovf_I1_)Set(OpCodes.Conv_Ovf_I1, operand, name);

		public Conv_Ovf_I1_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U1_ : CodeMatch
	{
		public Conv_Ovf_U1_ this[object operand = null, string name = null] => (Conv_Ovf_U1_)Set(OpCodes.Conv_Ovf_U1, operand, name);

		public Conv_Ovf_U1_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I2_ : CodeMatch
	{
		public Conv_Ovf_I2_ this[object operand = null, string name = null] => (Conv_Ovf_I2_)Set(OpCodes.Conv_Ovf_I2, operand, name);

		public Conv_Ovf_I2_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U2_ : CodeMatch
	{
		public Conv_Ovf_U2_ this[object operand = null, string name = null] => (Conv_Ovf_U2_)Set(OpCodes.Conv_Ovf_U2, operand, name);

		public Conv_Ovf_U2_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I4_ : CodeMatch
	{
		public Conv_Ovf_I4_ this[object operand = null, string name = null] => (Conv_Ovf_I4_)Set(OpCodes.Conv_Ovf_I4, operand, name);

		public Conv_Ovf_I4_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U4_ : CodeMatch
	{
		public Conv_Ovf_U4_ this[object operand = null, string name = null] => (Conv_Ovf_U4_)Set(OpCodes.Conv_Ovf_U4, operand, name);

		public Conv_Ovf_U4_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I8_ : CodeMatch
	{
		public Conv_Ovf_I8_ this[object operand = null, string name = null] => (Conv_Ovf_I8_)Set(OpCodes.Conv_Ovf_I8, operand, name);

		public Conv_Ovf_I8_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U8_ : CodeMatch
	{
		public Conv_Ovf_U8_ this[object operand = null, string name = null] => (Conv_Ovf_U8_)Set(OpCodes.Conv_Ovf_U8, operand, name);

		public Conv_Ovf_U8_()
			: base(null, null, null)
		{
		}
	}

	public class Refanyval_ : CodeMatch
	{
		public Refanyval_ this[object operand = null, string name = null] => (Refanyval_)Set(OpCodes.Refanyval, operand, name);

		public Refanyval_()
			: base(null, null, null)
		{
		}
	}

	public class Ckfinite_ : CodeMatch
	{
		public Ckfinite_ this[object operand = null, string name = null] => (Ckfinite_)Set(OpCodes.Ckfinite, operand, name);

		public Ckfinite_()
			: base(null, null, null)
		{
		}
	}

	public class Mkrefany_ : CodeMatch
	{
		public Mkrefany_ this[object operand = null, string name = null] => (Mkrefany_)Set(OpCodes.Mkrefany, operand, name);

		public Mkrefany_()
			: base(null, null, null)
		{
		}
	}

	public class Ldtoken_ : CodeMatch
	{
		public Ldtoken_ this[object operand = null, string name = null] => (Ldtoken_)Set(OpCodes.Ldtoken, operand, name);

		public Ldtoken_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_U2_ : CodeMatch
	{
		public Conv_U2_ this[object operand = null, string name = null] => (Conv_U2_)Set(OpCodes.Conv_U2, operand, name);

		public Conv_U2_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_U1_ : CodeMatch
	{
		public Conv_U1_ this[object operand = null, string name = null] => (Conv_U1_)Set(OpCodes.Conv_U1, operand, name);

		public Conv_U1_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_I_ : CodeMatch
	{
		public Conv_I_ this[object operand = null, string name = null] => (Conv_I_)Set(OpCodes.Conv_I, operand, name);

		public Conv_I_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_I_ : CodeMatch
	{
		public Conv_Ovf_I_ this[object operand = null, string name = null] => (Conv_Ovf_I_)Set(OpCodes.Conv_Ovf_I, operand, name);

		public Conv_Ovf_I_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_Ovf_U_ : CodeMatch
	{
		public Conv_Ovf_U_ this[object operand = null, string name = null] => (Conv_Ovf_U_)Set(OpCodes.Conv_Ovf_U, operand, name);

		public Conv_Ovf_U_()
			: base(null, null, null)
		{
		}
	}

	public class Add_Ovf_ : CodeMatch
	{
		public Add_Ovf_ this[object operand = null, string name = null] => (Add_Ovf_)Set(OpCodes.Add_Ovf, operand, name);

		public Add_Ovf_()
			: base(null, null, null)
		{
		}
	}

	public class Add_Ovf_Un_ : CodeMatch
	{
		public Add_Ovf_Un_ this[object operand = null, string name = null] => (Add_Ovf_Un_)Set(OpCodes.Add_Ovf_Un, operand, name);

		public Add_Ovf_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Mul_Ovf_ : CodeMatch
	{
		public Mul_Ovf_ this[object operand = null, string name = null] => (Mul_Ovf_)Set(OpCodes.Mul_Ovf, operand, name);

		public Mul_Ovf_()
			: base(null, null, null)
		{
		}
	}

	public class Mul_Ovf_Un_ : CodeMatch
	{
		public Mul_Ovf_Un_ this[object operand = null, string name = null] => (Mul_Ovf_Un_)Set(OpCodes.Mul_Ovf_Un, operand, name);

		public Mul_Ovf_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Sub_Ovf_ : CodeMatch
	{
		public Sub_Ovf_ this[object operand = null, string name = null] => (Sub_Ovf_)Set(OpCodes.Sub_Ovf, operand, name);

		public Sub_Ovf_()
			: base(null, null, null)
		{
		}
	}

	public class Sub_Ovf_Un_ : CodeMatch
	{
		public Sub_Ovf_Un_ this[object operand = null, string name = null] => (Sub_Ovf_Un_)Set(OpCodes.Sub_Ovf_Un, operand, name);

		public Sub_Ovf_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Endfinally_ : CodeMatch
	{
		public Endfinally_ this[object operand = null, string name = null] => (Endfinally_)Set(OpCodes.Endfinally, operand, name);

		public Endfinally_()
			: base(null, null, null)
		{
		}
	}

	public class Leave_ : CodeMatch
	{
		public Leave_ this[object operand = null, string name = null] => (Leave_)Set(OpCodes.Leave, operand, name);

		public Leave_()
			: base(null, null, null)
		{
		}
	}

	public class Leave_S_ : CodeMatch
	{
		public Leave_S_ this[object operand = null, string name = null] => (Leave_S_)Set(OpCodes.Leave_S, operand, name);

		public Leave_S_()
			: base(null, null, null)
		{
		}
	}

	public class Stind_I_ : CodeMatch
	{
		public Stind_I_ this[object operand = null, string name = null] => (Stind_I_)Set(OpCodes.Stind_I, operand, name);

		public Stind_I_()
			: base(null, null, null)
		{
		}
	}

	public class Conv_U_ : CodeMatch
	{
		public Conv_U_ this[object operand = null, string name = null] => (Conv_U_)Set(OpCodes.Conv_U, operand, name);

		public Conv_U_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix7_ : CodeMatch
	{
		public Prefix7_ this[object operand = null, string name = null] => (Prefix7_)Set(OpCodes.Prefix7, operand, name);

		public Prefix7_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix6_ : CodeMatch
	{
		public Prefix6_ this[object operand = null, string name = null] => (Prefix6_)Set(OpCodes.Prefix6, operand, name);

		public Prefix6_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix5_ : CodeMatch
	{
		public Prefix5_ this[object operand = null, string name = null] => (Prefix5_)Set(OpCodes.Prefix5, operand, name);

		public Prefix5_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix4_ : CodeMatch
	{
		public Prefix4_ this[object operand = null, string name = null] => (Prefix4_)Set(OpCodes.Prefix4, operand, name);

		public Prefix4_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix3_ : CodeMatch
	{
		public Prefix3_ this[object operand = null, string name = null] => (Prefix3_)Set(OpCodes.Prefix3, operand, name);

		public Prefix3_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix2_ : CodeMatch
	{
		public Prefix2_ this[object operand = null, string name = null] => (Prefix2_)Set(OpCodes.Prefix2, operand, name);

		public Prefix2_()
			: base(null, null, null)
		{
		}
	}

	public class Prefix1_ : CodeMatch
	{
		public Prefix1_ this[object operand = null, string name = null] => (Prefix1_)Set(OpCodes.Prefix1, operand, name);

		public Prefix1_()
			: base(null, null, null)
		{
		}
	}

	public class Prefixref_ : CodeMatch
	{
		public Prefixref_ this[object operand = null, string name = null] => (Prefixref_)Set(OpCodes.Prefixref, operand, name);

		public Prefixref_()
			: base(null, null, null)
		{
		}
	}

	public class Arglist_ : CodeMatch
	{
		public Arglist_ this[object operand = null, string name = null] => (Arglist_)Set(OpCodes.Arglist, operand, name);

		public Arglist_()
			: base(null, null, null)
		{
		}
	}

	public class Ceq_ : CodeMatch
	{
		public Ceq_ this[object operand = null, string name = null] => (Ceq_)Set(OpCodes.Ceq, operand, name);

		public Ceq_()
			: base(null, null, null)
		{
		}
	}

	public class Cgt_ : CodeMatch
	{
		public Cgt_ this[object operand = null, string name = null] => (Cgt_)Set(OpCodes.Cgt, operand, name);

		public Cgt_()
			: base(null, null, null)
		{
		}
	}

	public class Cgt_Un_ : CodeMatch
	{
		public Cgt_Un_ this[object operand = null, string name = null] => (Cgt_Un_)Set(OpCodes.Cgt_Un, operand, name);

		public Cgt_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Clt_ : CodeMatch
	{
		public Clt_ this[object operand = null, string name = null] => (Clt_)Set(OpCodes.Clt, operand, name);

		public Clt_()
			: base(null, null, null)
		{
		}
	}

	public class Clt_Un_ : CodeMatch
	{
		public Clt_Un_ this[object operand = null, string name = null] => (Clt_Un_)Set(OpCodes.Clt_Un, operand, name);

		public Clt_Un_()
			: base(null, null, null)
		{
		}
	}

	public class Ldftn_ : CodeMatch
	{
		public Ldftn_ this[object operand = null, string name = null] => (Ldftn_)Set(OpCodes.Ldftn, operand, name);

		public Ldftn_()
			: base(null, null, null)
		{
		}
	}

	public class Ldvirtftn_ : CodeMatch
	{
		public Ldvirtftn_ this[object operand = null, string name = null] => (Ldvirtftn_)Set(OpCodes.Ldvirtftn, operand, name);

		public Ldvirtftn_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarg_ : CodeMatch
	{
		public Ldarg_ this[object operand = null, string name = null] => (Ldarg_)Set(OpCodes.Ldarg, operand, name);

		public Ldarg_()
			: base(null, null, null)
		{
		}
	}

	public class Ldarga_ : CodeMatch
	{
		public Ldarga_ this[object operand = null, string name = null] => (Ldarga_)Set(OpCodes.Ldarga, operand, name);

		public Ldarga_()
			: base(null, null, null)
		{
		}
	}

	public class Starg_ : CodeMatch
	{
		public Starg_ this[object operand = null, string name = null] => (Starg_)Set(OpCodes.Starg, operand, name);

		public Starg_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloc_ : CodeMatch
	{
		public Ldloc_ this[object operand = null, string name = null] => (Ldloc_)Set(OpCodes.Ldloc, operand, name);

		public Ldloc_()
			: base(null, null, null)
		{
		}
	}

	public class Ldloca_ : CodeMatch
	{
		public Ldloca_ this[object operand = null, string name = null] => (Ldloca_)Set(OpCodes.Ldloca, operand, name);

		public Ldloca_()
			: base(null, null, null)
		{
		}
	}

	public class Stloc_ : CodeMatch
	{
		public Stloc_ this[object operand = null, string name = null] => (Stloc_)Set(OpCodes.Stloc, operand, name);

		public Stloc_()
			: base(null, null, null)
		{
		}
	}

	public class Localloc_ : CodeMatch
	{
		public Localloc_ this[object operand = null, string name = null] => (Localloc_)Set(OpCodes.Localloc, operand, name);

		public Localloc_()
			: base(null, null, null)
		{
		}
	}

	public class Endfilter_ : CodeMatch
	{
		public Endfilter_ this[object operand = null, string name = null] => (Endfilter_)Set(OpCodes.Endfilter, operand, name);

		public Endfilter_()
			: base(null, null, null)
		{
		}
	}

	public class Unaligned_ : CodeMatch
	{
		public Unaligned_ this[object operand = null, string name = null] => (Unaligned_)Set(OpCodes.Unaligned, operand, name);

		public Unaligned_()
			: base(null, null, null)
		{
		}
	}

	public class Volatile_ : CodeMatch
	{
		public Volatile_ this[object operand = null, string name = null] => (Volatile_)Set(OpCodes.Volatile, operand, name);

		public Volatile_()
			: base(null, null, null)
		{
		}
	}

	public class Tailcall_ : CodeMatch
	{
		public Tailcall_ this[object operand = null, string name = null] => (Tailcall_)Set(OpCodes.Tailcall, operand, name);

		public Tailcall_()
			: base(null, null, null)
		{
		}
	}

	public class Initobj_ : CodeMatch
	{
		public Initobj_ this[object operand = null, string name = null] => (Initobj_)Set(OpCodes.Initobj, operand, name);

		public Initobj_()
			: base(null, null, null)
		{
		}
	}

	public class Constrained_ : CodeMatch
	{
		public Constrained_ this[object operand = null, string name = null] => (Constrained_)Set(OpCodes.Constrained, operand, name);

		public Constrained_()
			: base(null, null, null)
		{
		}
	}

	public class Cpblk_ : CodeMatch
	{
		public Cpblk_ this[object operand = null, string name = null] => (Cpblk_)Set(OpCodes.Cpblk, operand, name);

		public Cpblk_()
			: base(null, null, null)
		{
		}
	}

	public class Initblk_ : CodeMatch
	{
		public Initblk_ this[object operand = null, string name = null] => (Initblk_)Set(OpCodes.Initblk, operand, name);

		public Initblk_()
			: base(null, null, null)
		{
		}
	}

	public class Rethrow_ : CodeMatch
	{
		public Rethrow_ this[object operand = null, string name = null] => (Rethrow_)Set(OpCodes.Rethrow, operand, name);

		public Rethrow_()
			: base(null, null, null)
		{
		}
	}

	public class Sizeof_ : CodeMatch
	{
		public Sizeof_ this[object operand = null, string name = null] => (Sizeof_)Set(OpCodes.Sizeof, operand, name);

		public Sizeof_()
			: base(null, null, null)
		{
		}
	}

	public class Refanytype_ : CodeMatch
	{
		public Refanytype_ this[object operand = null, string name = null] => (Refanytype_)Set(OpCodes.Refanytype, operand, name);

		public Refanytype_()
			: base(null, null, null)
		{
		}
	}

	public class Readonly_ : CodeMatch
	{
		public Readonly_ this[object operand = null, string name = null] => (Readonly_)Set(OpCodes.Readonly, operand, name);

		public Readonly_()
			: base(null, null, null)
		{
		}
	}

	public static Operand_ Operand => new Operand_();

	public static Nop_ Nop => new Nop_
	{
		opcode = OpCodes.Nop
	};

	public static Break_ Break => new Break_
	{
		opcode = OpCodes.Break
	};

	public static Ldarg_0_ Ldarg_0 => new Ldarg_0_
	{
		opcode = OpCodes.Ldarg_0
	};

	public static Ldarg_1_ Ldarg_1 => new Ldarg_1_
	{
		opcode = OpCodes.Ldarg_1
	};

	public static Ldarg_2_ Ldarg_2 => new Ldarg_2_
	{
		opcode = OpCodes.Ldarg_2
	};

	public static Ldarg_3_ Ldarg_3 => new Ldarg_3_
	{
		opcode = OpCodes.Ldarg_3
	};

	public static Ldloc_0_ Ldloc_0 => new Ldloc_0_
	{
		opcode = OpCodes.Ldloc_0
	};

	public static Ldloc_1_ Ldloc_1 => new Ldloc_1_
	{
		opcode = OpCodes.Ldloc_1
	};

	public static Ldloc_2_ Ldloc_2 => new Ldloc_2_
	{
		opcode = OpCodes.Ldloc_2
	};

	public static Ldloc_3_ Ldloc_3 => new Ldloc_3_
	{
		opcode = OpCodes.Ldloc_3
	};

	public static Stloc_0_ Stloc_0 => new Stloc_0_
	{
		opcode = OpCodes.Stloc_0
	};

	public static Stloc_1_ Stloc_1 => new Stloc_1_
	{
		opcode = OpCodes.Stloc_1
	};

	public static Stloc_2_ Stloc_2 => new Stloc_2_
	{
		opcode = OpCodes.Stloc_2
	};

	public static Stloc_3_ Stloc_3 => new Stloc_3_
	{
		opcode = OpCodes.Stloc_3
	};

	public static Ldarg_S_ Ldarg_S => new Ldarg_S_
	{
		opcode = OpCodes.Ldarg_S
	};

	public static Ldarga_S_ Ldarga_S => new Ldarga_S_
	{
		opcode = OpCodes.Ldarga_S
	};

	public static Starg_S_ Starg_S => new Starg_S_
	{
		opcode = OpCodes.Starg_S
	};

	public static Ldloc_S_ Ldloc_S => new Ldloc_S_
	{
		opcode = OpCodes.Ldloc_S
	};

	public static Ldloca_S_ Ldloca_S => new Ldloca_S_
	{
		opcode = OpCodes.Ldloca_S
	};

	public static Stloc_S_ Stloc_S => new Stloc_S_
	{
		opcode = OpCodes.Stloc_S
	};

	public static Ldnull_ Ldnull => new Ldnull_
	{
		opcode = OpCodes.Ldnull
	};

	public static Ldc_I4_M1_ Ldc_I4_M1 => new Ldc_I4_M1_
	{
		opcode = OpCodes.Ldc_I4_M1
	};

	public static Ldc_I4_0_ Ldc_I4_0 => new Ldc_I4_0_
	{
		opcode = OpCodes.Ldc_I4_0
	};

	public static Ldc_I4_1_ Ldc_I4_1 => new Ldc_I4_1_
	{
		opcode = OpCodes.Ldc_I4_1
	};

	public static Ldc_I4_2_ Ldc_I4_2 => new Ldc_I4_2_
	{
		opcode = OpCodes.Ldc_I4_2
	};

	public static Ldc_I4_3_ Ldc_I4_3 => new Ldc_I4_3_
	{
		opcode = OpCodes.Ldc_I4_3
	};

	public static Ldc_I4_4_ Ldc_I4_4 => new Ldc_I4_4_
	{
		opcode = OpCodes.Ldc_I4_4
	};

	public static Ldc_I4_5_ Ldc_I4_5 => new Ldc_I4_5_
	{
		opcode = OpCodes.Ldc_I4_5
	};

	public static Ldc_I4_6_ Ldc_I4_6 => new Ldc_I4_6_
	{
		opcode = OpCodes.Ldc_I4_6
	};

	public static Ldc_I4_7_ Ldc_I4_7 => new Ldc_I4_7_
	{
		opcode = OpCodes.Ldc_I4_7
	};

	public static Ldc_I4_8_ Ldc_I4_8 => new Ldc_I4_8_
	{
		opcode = OpCodes.Ldc_I4_8
	};

	public static Ldc_I4_S_ Ldc_I4_S => new Ldc_I4_S_
	{
		opcode = OpCodes.Ldc_I4_S
	};

	public static Ldc_I4_ Ldc_I4 => new Ldc_I4_
	{
		opcode = OpCodes.Ldc_I4
	};

	public static Ldc_I8_ Ldc_I8 => new Ldc_I8_
	{
		opcode = OpCodes.Ldc_I8
	};

	public static Ldc_R4_ Ldc_R4 => new Ldc_R4_
	{
		opcode = OpCodes.Ldc_R4
	};

	public static Ldc_R8_ Ldc_R8 => new Ldc_R8_
	{
		opcode = OpCodes.Ldc_R8
	};

	public static Dup_ Dup => new Dup_
	{
		opcode = OpCodes.Dup
	};

	public static Pop_ Pop => new Pop_
	{
		opcode = OpCodes.Pop
	};

	public static Jmp_ Jmp => new Jmp_
	{
		opcode = OpCodes.Jmp
	};

	public static Call_ Call => new Call_
	{
		opcode = OpCodes.Call
	};

	public static Calli_ Calli => new Calli_
	{
		opcode = OpCodes.Calli
	};

	public static Ret_ Ret => new Ret_
	{
		opcode = OpCodes.Ret
	};

	public static Br_S_ Br_S => new Br_S_
	{
		opcode = OpCodes.Br_S
	};

	public static Brfalse_S_ Brfalse_S => new Brfalse_S_
	{
		opcode = OpCodes.Brfalse_S
	};

	public static Brtrue_S_ Brtrue_S => new Brtrue_S_
	{
		opcode = OpCodes.Brtrue_S
	};

	public static Beq_S_ Beq_S => new Beq_S_
	{
		opcode = OpCodes.Beq_S
	};

	public static Bge_S_ Bge_S => new Bge_S_
	{
		opcode = OpCodes.Bge_S
	};

	public static Bgt_S_ Bgt_S => new Bgt_S_
	{
		opcode = OpCodes.Bgt_S
	};

	public static Ble_S_ Ble_S => new Ble_S_
	{
		opcode = OpCodes.Ble_S
	};

	public static Blt_S_ Blt_S => new Blt_S_
	{
		opcode = OpCodes.Blt_S
	};

	public static Bne_Un_S_ Bne_Un_S => new Bne_Un_S_
	{
		opcode = OpCodes.Bne_Un_S
	};

	public static Bge_Un_S_ Bge_Un_S => new Bge_Un_S_
	{
		opcode = OpCodes.Bge_Un_S
	};

	public static Bgt_Un_S_ Bgt_Un_S => new Bgt_Un_S_
	{
		opcode = OpCodes.Bgt_Un_S
	};

	public static Ble_Un_S_ Ble_Un_S => new Ble_Un_S_
	{
		opcode = OpCodes.Ble_Un_S
	};

	public static Blt_Un_S_ Blt_Un_S => new Blt_Un_S_
	{
		opcode = OpCodes.Blt_Un_S
	};

	public static Br_ Br => new Br_
	{
		opcode = OpCodes.Br
	};

	public static Brfalse_ Brfalse => new Brfalse_
	{
		opcode = OpCodes.Brfalse
	};

	public static Brtrue_ Brtrue => new Brtrue_
	{
		opcode = OpCodes.Brtrue
	};

	public static Beq_ Beq => new Beq_
	{
		opcode = OpCodes.Beq
	};

	public static Bge_ Bge => new Bge_
	{
		opcode = OpCodes.Bge
	};

	public static Bgt_ Bgt => new Bgt_
	{
		opcode = OpCodes.Bgt
	};

	public static Ble_ Ble => new Ble_
	{
		opcode = OpCodes.Ble
	};

	public static Blt_ Blt => new Blt_
	{
		opcode = OpCodes.Blt
	};

	public static Bne_Un_ Bne_Un => new Bne_Un_
	{
		opcode = OpCodes.Bne_Un
	};

	public static Bge_Un_ Bge_Un => new Bge_Un_
	{
		opcode = OpCodes.Bge_Un
	};

	public static Bgt_Un_ Bgt_Un => new Bgt_Un_
	{
		opcode = OpCodes.Bgt_Un
	};

	public static Ble_Un_ Ble_Un => new Ble_Un_
	{
		opcode = OpCodes.Ble_Un
	};

	public static Blt_Un_ Blt_Un => new Blt_Un_
	{
		opcode = OpCodes.Blt_Un
	};

	public static Switch_ Switch => new Switch_
	{
		opcode = OpCodes.Switch
	};

	public static Ldind_I1_ Ldind_I1 => new Ldind_I1_
	{
		opcode = OpCodes.Ldind_I1
	};

	public static Ldind_U1_ Ldind_U1 => new Ldind_U1_
	{
		opcode = OpCodes.Ldind_U1
	};

	public static Ldind_I2_ Ldind_I2 => new Ldind_I2_
	{
		opcode = OpCodes.Ldind_I2
	};

	public static Ldind_U2_ Ldind_U2 => new Ldind_U2_
	{
		opcode = OpCodes.Ldind_U2
	};

	public static Ldind_I4_ Ldind_I4 => new Ldind_I4_
	{
		opcode = OpCodes.Ldind_I4
	};

	public static Ldind_U4_ Ldind_U4 => new Ldind_U4_
	{
		opcode = OpCodes.Ldind_U4
	};

	public static Ldind_I8_ Ldind_I8 => new Ldind_I8_
	{
		opcode = OpCodes.Ldind_I8
	};

	public static Ldind_I_ Ldind_I => new Ldind_I_
	{
		opcode = OpCodes.Ldind_I
	};

	public static Ldind_R4_ Ldind_R4 => new Ldind_R4_
	{
		opcode = OpCodes.Ldind_R4
	};

	public static Ldind_R8_ Ldind_R8 => new Ldind_R8_
	{
		opcode = OpCodes.Ldind_R8
	};

	public static Ldind_Ref_ Ldind_Ref => new Ldind_Ref_
	{
		opcode = OpCodes.Ldind_Ref
	};

	public static Stind_Ref_ Stind_Ref => new Stind_Ref_
	{
		opcode = OpCodes.Stind_Ref
	};

	public static Stind_I1_ Stind_I1 => new Stind_I1_
	{
		opcode = OpCodes.Stind_I1
	};

	public static Stind_I2_ Stind_I2 => new Stind_I2_
	{
		opcode = OpCodes.Stind_I2
	};

	public static Stind_I4_ Stind_I4 => new Stind_I4_
	{
		opcode = OpCodes.Stind_I4
	};

	public static Stind_I8_ Stind_I8 => new Stind_I8_
	{
		opcode = OpCodes.Stind_I8
	};

	public static Stind_R4_ Stind_R4 => new Stind_R4_
	{
		opcode = OpCodes.Stind_R4
	};

	public static Stind_R8_ Stind_R8 => new Stind_R8_
	{
		opcode = OpCodes.Stind_R8
	};

	public static Add_ Add => new Add_
	{
		opcode = OpCodes.Add
	};

	public static Sub_ Sub => new Sub_
	{
		opcode = OpCodes.Sub
	};

	public static Mul_ Mul => new Mul_
	{
		opcode = OpCodes.Mul
	};

	public static Div_ Div => new Div_
	{
		opcode = OpCodes.Div
	};

	public static Div_Un_ Div_Un => new Div_Un_
	{
		opcode = OpCodes.Div_Un
	};

	public static Rem_ Rem => new Rem_
	{
		opcode = OpCodes.Rem
	};

	public static Rem_Un_ Rem_Un => new Rem_Un_
	{
		opcode = OpCodes.Rem_Un
	};

	public static And_ And => new And_
	{
		opcode = OpCodes.And
	};

	public static Or_ Or => new Or_
	{
		opcode = OpCodes.Or
	};

	public static Xor_ Xor => new Xor_
	{
		opcode = OpCodes.Xor
	};

	public static Shl_ Shl => new Shl_
	{
		opcode = OpCodes.Shl
	};

	public static Shr_ Shr => new Shr_
	{
		opcode = OpCodes.Shr
	};

	public static Shr_Un_ Shr_Un => new Shr_Un_
	{
		opcode = OpCodes.Shr_Un
	};

	public static Neg_ Neg => new Neg_
	{
		opcode = OpCodes.Neg
	};

	public static Not_ Not => new Not_
	{
		opcode = OpCodes.Not
	};

	public static Conv_I1_ Conv_I1 => new Conv_I1_
	{
		opcode = OpCodes.Conv_I1
	};

	public static Conv_I2_ Conv_I2 => new Conv_I2_
	{
		opcode = OpCodes.Conv_I2
	};

	public static Conv_I4_ Conv_I4 => new Conv_I4_
	{
		opcode = OpCodes.Conv_I4
	};

	public static Conv_I8_ Conv_I8 => new Conv_I8_
	{
		opcode = OpCodes.Conv_I8
	};

	public static Conv_R4_ Conv_R4 => new Conv_R4_
	{
		opcode = OpCodes.Conv_R4
	};

	public static Conv_R8_ Conv_R8 => new Conv_R8_
	{
		opcode = OpCodes.Conv_R8
	};

	public static Conv_U4_ Conv_U4 => new Conv_U4_
	{
		opcode = OpCodes.Conv_U4
	};

	public static Conv_U8_ Conv_U8 => new Conv_U8_
	{
		opcode = OpCodes.Conv_U8
	};

	public static Callvirt_ Callvirt => new Callvirt_
	{
		opcode = OpCodes.Callvirt
	};

	public static Cpobj_ Cpobj => new Cpobj_
	{
		opcode = OpCodes.Cpobj
	};

	public static Ldobj_ Ldobj => new Ldobj_
	{
		opcode = OpCodes.Ldobj
	};

	public static Ldstr_ Ldstr => new Ldstr_
	{
		opcode = OpCodes.Ldstr
	};

	public static Newobj_ Newobj => new Newobj_
	{
		opcode = OpCodes.Newobj
	};

	public static Castclass_ Castclass => new Castclass_
	{
		opcode = OpCodes.Castclass
	};

	public static Isinst_ Isinst => new Isinst_
	{
		opcode = OpCodes.Isinst
	};

	public static Conv_R_Un_ Conv_R_Un => new Conv_R_Un_
	{
		opcode = OpCodes.Conv_R_Un
	};

	public static Unbox_ Unbox => new Unbox_
	{
		opcode = OpCodes.Unbox
	};

	public static Throw_ Throw => new Throw_
	{
		opcode = OpCodes.Throw
	};

	public static Ldfld_ Ldfld => new Ldfld_
	{
		opcode = OpCodes.Ldfld
	};

	public static Ldflda_ Ldflda => new Ldflda_
	{
		opcode = OpCodes.Ldflda
	};

	public static Stfld_ Stfld => new Stfld_
	{
		opcode = OpCodes.Stfld
	};

	public static Ldsfld_ Ldsfld => new Ldsfld_
	{
		opcode = OpCodes.Ldsfld
	};

	public static Ldsflda_ Ldsflda => new Ldsflda_
	{
		opcode = OpCodes.Ldsflda
	};

	public static Stsfld_ Stsfld => new Stsfld_
	{
		opcode = OpCodes.Stsfld
	};

	public static Stobj_ Stobj => new Stobj_
	{
		opcode = OpCodes.Stobj
	};

	public static Conv_Ovf_I1_Un_ Conv_Ovf_I1_Un => new Conv_Ovf_I1_Un_
	{
		opcode = OpCodes.Conv_Ovf_I1_Un
	};

	public static Conv_Ovf_I2_Un_ Conv_Ovf_I2_Un => new Conv_Ovf_I2_Un_
	{
		opcode = OpCodes.Conv_Ovf_I2_Un
	};

	public static Conv_Ovf_I4_Un_ Conv_Ovf_I4_Un => new Conv_Ovf_I4_Un_
	{
		opcode = OpCodes.Conv_Ovf_I4_Un
	};

	public static Conv_Ovf_I8_Un_ Conv_Ovf_I8_Un => new Conv_Ovf_I8_Un_
	{
		opcode = OpCodes.Conv_Ovf_I8_Un
	};

	public static Conv_Ovf_U1_Un_ Conv_Ovf_U1_Un => new Conv_Ovf_U1_Un_
	{
		opcode = OpCodes.Conv_Ovf_U1_Un
	};

	public static Conv_Ovf_U2_Un_ Conv_Ovf_U2_Un => new Conv_Ovf_U2_Un_
	{
		opcode = OpCodes.Conv_Ovf_U2_Un
	};

	public static Conv_Ovf_U4_Un_ Conv_Ovf_U4_Un => new Conv_Ovf_U4_Un_
	{
		opcode = OpCodes.Conv_Ovf_U4_Un
	};

	public static Conv_Ovf_U8_Un_ Conv_Ovf_U8_Un => new Conv_Ovf_U8_Un_
	{
		opcode = OpCodes.Conv_Ovf_U8_Un
	};

	public static Conv_Ovf_I_Un_ Conv_Ovf_I_Un => new Conv_Ovf_I_Un_
	{
		opcode = OpCodes.Conv_Ovf_I_Un
	};

	public static Conv_Ovf_U_Un_ Conv_Ovf_U_Un => new Conv_Ovf_U_Un_
	{
		opcode = OpCodes.Conv_Ovf_U_Un
	};

	public static Box_ Box => new Box_
	{
		opcode = OpCodes.Box
	};

	public static Newarr_ Newarr => new Newarr_
	{
		opcode = OpCodes.Newarr
	};

	public static Ldlen_ Ldlen => new Ldlen_
	{
		opcode = OpCodes.Ldlen
	};

	public static Ldelema_ Ldelema => new Ldelema_
	{
		opcode = OpCodes.Ldelema
	};

	public static Ldelem_I1_ Ldelem_I1 => new Ldelem_I1_
	{
		opcode = OpCodes.Ldelem_I1
	};

	public static Ldelem_U1_ Ldelem_U1 => new Ldelem_U1_
	{
		opcode = OpCodes.Ldelem_U1
	};

	public static Ldelem_I2_ Ldelem_I2 => new Ldelem_I2_
	{
		opcode = OpCodes.Ldelem_I2
	};

	public static Ldelem_U2_ Ldelem_U2 => new Ldelem_U2_
	{
		opcode = OpCodes.Ldelem_U2
	};

	public static Ldelem_I4_ Ldelem_I4 => new Ldelem_I4_
	{
		opcode = OpCodes.Ldelem_I4
	};

	public static Ldelem_U4_ Ldelem_U4 => new Ldelem_U4_
	{
		opcode = OpCodes.Ldelem_U4
	};

	public static Ldelem_I8_ Ldelem_I8 => new Ldelem_I8_
	{
		opcode = OpCodes.Ldelem_I8
	};

	public static Ldelem_I_ Ldelem_I => new Ldelem_I_
	{
		opcode = OpCodes.Ldelem_I
	};

	public static Ldelem_R4_ Ldelem_R4 => new Ldelem_R4_
	{
		opcode = OpCodes.Ldelem_R4
	};

	public static Ldelem_R8_ Ldelem_R8 => new Ldelem_R8_
	{
		opcode = OpCodes.Ldelem_R8
	};

	public static Ldelem_Ref_ Ldelem_Ref => new Ldelem_Ref_
	{
		opcode = OpCodes.Ldelem_Ref
	};

	public static Stelem_I_ Stelem_I => new Stelem_I_
	{
		opcode = OpCodes.Stelem_I
	};

	public static Stelem_I1_ Stelem_I1 => new Stelem_I1_
	{
		opcode = OpCodes.Stelem_I1
	};

	public static Stelem_I2_ Stelem_I2 => new Stelem_I2_
	{
		opcode = OpCodes.Stelem_I2
	};

	public static Stelem_I4_ Stelem_I4 => new Stelem_I4_
	{
		opcode = OpCodes.Stelem_I4
	};

	public static Stelem_I8_ Stelem_I8 => new Stelem_I8_
	{
		opcode = OpCodes.Stelem_I8
	};

	public static Stelem_R4_ Stelem_R4 => new Stelem_R4_
	{
		opcode = OpCodes.Stelem_R4
	};

	public static Stelem_R8_ Stelem_R8 => new Stelem_R8_
	{
		opcode = OpCodes.Stelem_R8
	};

	public static Stelem_Ref_ Stelem_Ref => new Stelem_Ref_
	{
		opcode = OpCodes.Stelem_Ref
	};

	public static Ldelem_ Ldelem => new Ldelem_
	{
		opcode = OpCodes.Ldelem
	};

	public static Stelem_ Stelem => new Stelem_
	{
		opcode = OpCodes.Stelem
	};

	public static Unbox_Any_ Unbox_Any => new Unbox_Any_
	{
		opcode = OpCodes.Unbox_Any
	};

	public static Conv_Ovf_I1_ Conv_Ovf_I1 => new Conv_Ovf_I1_
	{
		opcode = OpCodes.Conv_Ovf_I1
	};

	public static Conv_Ovf_U1_ Conv_Ovf_U1 => new Conv_Ovf_U1_
	{
		opcode = OpCodes.Conv_Ovf_U1
	};

	public static Conv_Ovf_I2_ Conv_Ovf_I2 => new Conv_Ovf_I2_
	{
		opcode = OpCodes.Conv_Ovf_I2
	};

	public static Conv_Ovf_U2_ Conv_Ovf_U2 => new Conv_Ovf_U2_
	{
		opcode = OpCodes.Conv_Ovf_U2
	};

	public static Conv_Ovf_I4_ Conv_Ovf_I4 => new Conv_Ovf_I4_
	{
		opcode = OpCodes.Conv_Ovf_I4
	};

	public static Conv_Ovf_U4_ Conv_Ovf_U4 => new Conv_Ovf_U4_
	{
		opcode = OpCodes.Conv_Ovf_U4
	};

	public static Conv_Ovf_I8_ Conv_Ovf_I8 => new Conv_Ovf_I8_
	{
		opcode = OpCodes.Conv_Ovf_I8
	};

	public static Conv_Ovf_U8_ Conv_Ovf_U8 => new Conv_Ovf_U8_
	{
		opcode = OpCodes.Conv_Ovf_U8
	};

	public static Refanyval_ Refanyval => new Refanyval_
	{
		opcode = OpCodes.Refanyval
	};

	public static Ckfinite_ Ckfinite => new Ckfinite_
	{
		opcode = OpCodes.Ckfinite
	};

	public static Mkrefany_ Mkrefany => new Mkrefany_
	{
		opcode = OpCodes.Mkrefany
	};

	public static Ldtoken_ Ldtoken => new Ldtoken_
	{
		opcode = OpCodes.Ldtoken
	};

	public static Conv_U2_ Conv_U2 => new Conv_U2_
	{
		opcode = OpCodes.Conv_U2
	};

	public static Conv_U1_ Conv_U1 => new Conv_U1_
	{
		opcode = OpCodes.Conv_U1
	};

	public static Conv_I_ Conv_I => new Conv_I_
	{
		opcode = OpCodes.Conv_I
	};

	public static Conv_Ovf_I_ Conv_Ovf_I => new Conv_Ovf_I_
	{
		opcode = OpCodes.Conv_Ovf_I
	};

	public static Conv_Ovf_U_ Conv_Ovf_U => new Conv_Ovf_U_
	{
		opcode = OpCodes.Conv_Ovf_U
	};

	public static Add_Ovf_ Add_Ovf => new Add_Ovf_
	{
		opcode = OpCodes.Add_Ovf
	};

	public static Add_Ovf_Un_ Add_Ovf_Un => new Add_Ovf_Un_
	{
		opcode = OpCodes.Add_Ovf_Un
	};

	public static Mul_Ovf_ Mul_Ovf => new Mul_Ovf_
	{
		opcode = OpCodes.Mul_Ovf
	};

	public static Mul_Ovf_Un_ Mul_Ovf_Un => new Mul_Ovf_Un_
	{
		opcode = OpCodes.Mul_Ovf_Un
	};

	public static Sub_Ovf_ Sub_Ovf => new Sub_Ovf_
	{
		opcode = OpCodes.Sub_Ovf
	};

	public static Sub_Ovf_Un_ Sub_Ovf_Un => new Sub_Ovf_Un_
	{
		opcode = OpCodes.Sub_Ovf_Un
	};

	public static Endfinally_ Endfinally => new Endfinally_
	{
		opcode = OpCodes.Endfinally
	};

	public static Leave_ Leave => new Leave_
	{
		opcode = OpCodes.Leave
	};

	public static Leave_S_ Leave_S => new Leave_S_
	{
		opcode = OpCodes.Leave_S
	};

	public static Stind_I_ Stind_I => new Stind_I_
	{
		opcode = OpCodes.Stind_I
	};

	public static Conv_U_ Conv_U => new Conv_U_
	{
		opcode = OpCodes.Conv_U
	};

	public static Prefix7_ Prefix7 => new Prefix7_
	{
		opcode = OpCodes.Prefix7
	};

	public static Prefix6_ Prefix6 => new Prefix6_
	{
		opcode = OpCodes.Prefix6
	};

	public static Prefix5_ Prefix5 => new Prefix5_
	{
		opcode = OpCodes.Prefix5
	};

	public static Prefix4_ Prefix4 => new Prefix4_
	{
		opcode = OpCodes.Prefix4
	};

	public static Prefix3_ Prefix3 => new Prefix3_
	{
		opcode = OpCodes.Prefix3
	};

	public static Prefix2_ Prefix2 => new Prefix2_
	{
		opcode = OpCodes.Prefix2
	};

	public static Prefix1_ Prefix1 => new Prefix1_
	{
		opcode = OpCodes.Prefix1
	};

	public static Prefixref_ Prefixref => new Prefixref_
	{
		opcode = OpCodes.Prefixref
	};

	public static Arglist_ Arglist => new Arglist_
	{
		opcode = OpCodes.Arglist
	};

	public static Ceq_ Ceq => new Ceq_
	{
		opcode = OpCodes.Ceq
	};

	public static Cgt_ Cgt => new Cgt_
	{
		opcode = OpCodes.Cgt
	};

	public static Cgt_Un_ Cgt_Un => new Cgt_Un_
	{
		opcode = OpCodes.Cgt_Un
	};

	public static Clt_ Clt => new Clt_
	{
		opcode = OpCodes.Clt
	};

	public static Clt_Un_ Clt_Un => new Clt_Un_
	{
		opcode = OpCodes.Clt_Un
	};

	public static Ldftn_ Ldftn => new Ldftn_
	{
		opcode = OpCodes.Ldftn
	};

	public static Ldvirtftn_ Ldvirtftn => new Ldvirtftn_
	{
		opcode = OpCodes.Ldvirtftn
	};

	public static Ldarg_ Ldarg => new Ldarg_
	{
		opcode = OpCodes.Ldarg
	};

	public static Ldarga_ Ldarga => new Ldarga_
	{
		opcode = OpCodes.Ldarga
	};

	public static Starg_ Starg => new Starg_
	{
		opcode = OpCodes.Starg
	};

	public static Ldloc_ Ldloc => new Ldloc_
	{
		opcode = OpCodes.Ldloc
	};

	public static Ldloca_ Ldloca => new Ldloca_
	{
		opcode = OpCodes.Ldloca
	};

	public static Stloc_ Stloc => new Stloc_
	{
		opcode = OpCodes.Stloc
	};

	public static Localloc_ Localloc => new Localloc_
	{
		opcode = OpCodes.Localloc
	};

	public static Endfilter_ Endfilter => new Endfilter_
	{
		opcode = OpCodes.Endfilter
	};

	public static Unaligned_ Unaligned => new Unaligned_
	{
		opcode = OpCodes.Unaligned
	};

	public static Volatile_ Volatile => new Volatile_
	{
		opcode = OpCodes.Volatile
	};

	public static Tailcall_ Tailcall => new Tailcall_
	{
		opcode = OpCodes.Tailcall
	};

	public static Initobj_ Initobj => new Initobj_
	{
		opcode = OpCodes.Initobj
	};

	public static Constrained_ Constrained => new Constrained_
	{
		opcode = OpCodes.Constrained
	};

	public static Cpblk_ Cpblk => new Cpblk_
	{
		opcode = OpCodes.Cpblk
	};

	public static Initblk_ Initblk => new Initblk_
	{
		opcode = OpCodes.Initblk
	};

	public static Rethrow_ Rethrow => new Rethrow_
	{
		opcode = OpCodes.Rethrow
	};

	public static Sizeof_ Sizeof => new Sizeof_
	{
		opcode = OpCodes.Sizeof
	};

	public static Refanytype_ Refanytype => new Refanytype_
	{
		opcode = OpCodes.Refanytype
	};

	public static Readonly_ Readonly => new Readonly_
	{
		opcode = OpCodes.Readonly
	};
}


public class Operand_ : CodeMatch
{
	public Operand_ this[object operand = null, string name = null] => (Operand_)Set(operand, name);

	public Operand_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Nop_ : CodeMatch
{
	public Nop_ this[object operand = null, string name = null] => (Nop_)Set(OpCodes.Nop, operand, name);

	public Nop_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Break_ : CodeMatch
{
	public Break_ this[object operand = null, string name = null] => (Break_)Set(OpCodes.Break, operand, name);

	public Break_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarg_0_ : CodeMatch
{
	public Ldarg_0_ this[object operand = null, string name = null] => (Ldarg_0_)Set(OpCodes.Ldarg_0, operand, name);

	public Ldarg_0_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarg_1_ : CodeMatch
{
	public Ldarg_1_ this[object operand = null, string name = null] => (Ldarg_1_)Set(OpCodes.Ldarg_1, operand, name);

	public Ldarg_1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarg_2_ : CodeMatch
{
	public Ldarg_2_ this[object operand = null, string name = null] => (Ldarg_2_)Set(OpCodes.Ldarg_2, operand, name);

	public Ldarg_2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarg_3_ : CodeMatch
{
	public Ldarg_3_ this[object operand = null, string name = null] => (Ldarg_3_)Set(OpCodes.Ldarg_3, operand, name);

	public Ldarg_3_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloc_0_ : CodeMatch
{
	public Ldloc_0_ this[object operand = null, string name = null] => (Ldloc_0_)Set(OpCodes.Ldloc_0, operand, name);

	public Ldloc_0_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloc_1_ : CodeMatch
{
	public Ldloc_1_ this[object operand = null, string name = null] => (Ldloc_1_)Set(OpCodes.Ldloc_1, operand, name);

	public Ldloc_1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloc_2_ : CodeMatch
{
	public Ldloc_2_ this[object operand = null, string name = null] => (Ldloc_2_)Set(OpCodes.Ldloc_2, operand, name);

	public Ldloc_2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloc_3_ : CodeMatch
{
	public Ldloc_3_ this[object operand = null, string name = null] => (Ldloc_3_)Set(OpCodes.Ldloc_3, operand, name);

	public Ldloc_3_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stloc_0_ : CodeMatch
{
	public Stloc_0_ this[object operand = null, string name = null] => (Stloc_0_)Set(OpCodes.Stloc_0, operand, name);

	public Stloc_0_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stloc_1_ : CodeMatch
{
	public Stloc_1_ this[object operand = null, string name = null] => (Stloc_1_)Set(OpCodes.Stloc_1, operand, name);

	public Stloc_1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stloc_2_ : CodeMatch
{
	public Stloc_2_ this[object operand = null, string name = null] => (Stloc_2_)Set(OpCodes.Stloc_2, operand, name);

	public Stloc_2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stloc_3_ : CodeMatch
{
	public Stloc_3_ this[object operand = null, string name = null] => (Stloc_3_)Set(OpCodes.Stloc_3, operand, name);

	public Stloc_3_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarg_S_ : CodeMatch
{
	public Ldarg_S_ this[object operand = null, string name = null] => (Ldarg_S_)Set(OpCodes.Ldarg_S, operand, name);

	public Ldarg_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarga_S_ : CodeMatch
{
	public Ldarga_S_ this[object operand = null, string name = null] => (Ldarga_S_)Set(OpCodes.Ldarga_S, operand, name);

	public Ldarga_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Starg_S_ : CodeMatch
{
	public Starg_S_ this[object operand = null, string name = null] => (Starg_S_)Set(OpCodes.Starg_S, operand, name);

	public Starg_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloc_S_ : CodeMatch
{
	public Ldloc_S_ this[object operand = null, string name = null] => (Ldloc_S_)Set(OpCodes.Ldloc_S, operand, name);

	public Ldloc_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloca_S_ : CodeMatch
{
	public Ldloca_S_ this[object operand = null, string name = null] => (Ldloca_S_)Set(OpCodes.Ldloca_S, operand, name);

	public Ldloca_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stloc_S_ : CodeMatch
{
	public Stloc_S_ this[object operand = null, string name = null] => (Stloc_S_)Set(OpCodes.Stloc_S, operand, name);

	public Stloc_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldnull_ : CodeMatch
{
	public Ldnull_ this[object operand = null, string name = null] => (Ldnull_)Set(OpCodes.Ldnull, operand, name);

	public Ldnull_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_M1_ : CodeMatch
{
	public Ldc_I4_M1_ this[object operand = null, string name = null] => (Ldc_I4_M1_)Set(OpCodes.Ldc_I4_M1, operand, name);

	public Ldc_I4_M1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_0_ : CodeMatch
{
	public Ldc_I4_0_ this[object operand = null, string name = null] => (Ldc_I4_0_)Set(OpCodes.Ldc_I4_0, operand, name);

	public Ldc_I4_0_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_1_ : CodeMatch
{
	public Ldc_I4_1_ this[object operand = null, string name = null] => (Ldc_I4_1_)Set(OpCodes.Ldc_I4_1, operand, name);

	public Ldc_I4_1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_2_ : CodeMatch
{
	public Ldc_I4_2_ this[object operand = null, string name = null] => (Ldc_I4_2_)Set(OpCodes.Ldc_I4_2, operand, name);

	public Ldc_I4_2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_3_ : CodeMatch
{
	public Ldc_I4_3_ this[object operand = null, string name = null] => (Ldc_I4_3_)Set(OpCodes.Ldc_I4_3, operand, name);

	public Ldc_I4_3_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_4_ : CodeMatch
{
	public Ldc_I4_4_ this[object operand = null, string name = null] => (Ldc_I4_4_)Set(OpCodes.Ldc_I4_4, operand, name);

	public Ldc_I4_4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_5_ : CodeMatch
{
	public Ldc_I4_5_ this[object operand = null, string name = null] => (Ldc_I4_5_)Set(OpCodes.Ldc_I4_5, operand, name);

	public Ldc_I4_5_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_6_ : CodeMatch
{
	public Ldc_I4_6_ this[object operand = null, string name = null] => (Ldc_I4_6_)Set(OpCodes.Ldc_I4_6, operand, name);

	public Ldc_I4_6_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_7_ : CodeMatch
{
	public Ldc_I4_7_ this[object operand = null, string name = null] => (Ldc_I4_7_)Set(OpCodes.Ldc_I4_7, operand, name);

	public Ldc_I4_7_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_8_ : CodeMatch
{
	public Ldc_I4_8_ this[object operand = null, string name = null] => (Ldc_I4_8_)Set(OpCodes.Ldc_I4_8, operand, name);

	public Ldc_I4_8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_S_ : CodeMatch
{
	public Ldc_I4_S_ this[object operand = null, string name = null] => (Ldc_I4_S_)Set(OpCodes.Ldc_I4_S, operand, name);

	public Ldc_I4_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I4_ : CodeMatch
{
	public Ldc_I4_ this[object operand = null, string name = null] => (Ldc_I4_)Set(OpCodes.Ldc_I4, operand, name);

	public Ldc_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_I8_ : CodeMatch
{
	public Ldc_I8_ this[object operand = null, string name = null] => (Ldc_I8_)Set(OpCodes.Ldc_I8, operand, name);

	public Ldc_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_R4_ : CodeMatch
{
	public Ldc_R4_ this[object operand = null, string name = null] => (Ldc_R4_)Set(OpCodes.Ldc_R4, operand, name);

	public Ldc_R4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldc_R8_ : CodeMatch
{
	public Ldc_R8_ this[object operand = null, string name = null] => (Ldc_R8_)Set(OpCodes.Ldc_R8, operand, name);

	public Ldc_R8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Dup_ : CodeMatch
{
	public Dup_ this[object operand = null, string name = null] => (Dup_)Set(OpCodes.Dup, operand, name);

	public Dup_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Pop_ : CodeMatch
{
	public Pop_ this[object operand = null, string name = null] => (Pop_)Set(OpCodes.Pop, operand, name);

	public Pop_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Jmp_ : CodeMatch
{
	public Jmp_ this[object operand = null, string name = null] => (Jmp_)Set(OpCodes.Jmp, operand, name);

	public Jmp_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Call_ : CodeMatch
{
	public Call_ this[object operand = null, string name = null] => (Call_)Set(OpCodes.Call, operand, name);

	public Call_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Calli_ : CodeMatch
{
	public Calli_ this[object operand = null, string name = null] => (Calli_)Set(OpCodes.Calli, operand, name);

	public Calli_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ret_ : CodeMatch
{
	public Ret_ this[object operand = null, string name = null] => (Ret_)Set(OpCodes.Ret, operand, name);

	public Ret_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Br_S_ : CodeMatch
{
	public Br_S_ this[object operand = null, string name = null] => (Br_S_)Set(OpCodes.Br_S, operand, name);

	public Br_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Brfalse_S_ : CodeMatch
{
	public Brfalse_S_ this[object operand = null, string name = null] => (Brfalse_S_)Set(OpCodes.Brfalse_S, operand, name);

	public Brfalse_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Brtrue_S_ : CodeMatch
{
	public Brtrue_S_ this[object operand = null, string name = null] => (Brtrue_S_)Set(OpCodes.Brtrue_S, operand, name);

	public Brtrue_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Beq_S_ : CodeMatch
{
	public Beq_S_ this[object operand = null, string name = null] => (Beq_S_)Set(OpCodes.Beq_S, operand, name);

	public Beq_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bge_S_ : CodeMatch
{
	public Bge_S_ this[object operand = null, string name = null] => (Bge_S_)Set(OpCodes.Bge_S, operand, name);

	public Bge_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bgt_S_ : CodeMatch
{
	public Bgt_S_ this[object operand = null, string name = null] => (Bgt_S_)Set(OpCodes.Bgt_S, operand, name);

	public Bgt_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ble_S_ : CodeMatch
{
	public Ble_S_ this[object operand = null, string name = null] => (Ble_S_)Set(OpCodes.Ble_S, operand, name);

	public Ble_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Blt_S_ : CodeMatch
{
	public Blt_S_ this[object operand = null, string name = null] => (Blt_S_)Set(OpCodes.Blt_S, operand, name);

	public Blt_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bne_Un_S_ : CodeMatch
{
	public Bne_Un_S_ this[object operand = null, string name = null] => (Bne_Un_S_)Set(OpCodes.Bne_Un_S, operand, name);

	public Bne_Un_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bge_Un_S_ : CodeMatch
{
	public Bge_Un_S_ this[object operand = null, string name = null] => (Bge_Un_S_)Set(OpCodes.Bge_Un_S, operand, name);

	public Bge_Un_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bgt_Un_S_ : CodeMatch
{
	public Bgt_Un_S_ this[object operand = null, string name = null] => (Bgt_Un_S_)Set(OpCodes.Bgt_Un_S, operand, name);

	public Bgt_Un_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ble_Un_S_ : CodeMatch
{
	public Ble_Un_S_ this[object operand = null, string name = null] => (Ble_Un_S_)Set(OpCodes.Ble_Un_S, operand, name);

	public Ble_Un_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Blt_Un_S_ : CodeMatch
{
	public Blt_Un_S_ this[object operand = null, string name = null] => (Blt_Un_S_)Set(OpCodes.Blt_Un_S, operand, name);

	public Blt_Un_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Br_ : CodeMatch
{
	public Br_ this[object operand = null, string name = null] => (Br_)Set(OpCodes.Br, operand, name);

	public Br_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Brfalse_ : CodeMatch
{
	public Brfalse_ this[object operand = null, string name = null] => (Brfalse_)Set(OpCodes.Brfalse, operand, name);

	public Brfalse_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Brtrue_ : CodeMatch
{
	public Brtrue_ this[object operand = null, string name = null] => (Brtrue_)Set(OpCodes.Brtrue, operand, name);

	public Brtrue_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Beq_ : CodeMatch
{
	public Beq_ this[object operand = null, string name = null] => (Beq_)Set(OpCodes.Beq, operand, name);

	public Beq_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bge_ : CodeMatch
{
	public Bge_ this[object operand = null, string name = null] => (Bge_)Set(OpCodes.Bge, operand, name);

	public Bge_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bgt_ : CodeMatch
{
	public Bgt_ this[object operand = null, string name = null] => (Bgt_)Set(OpCodes.Bgt, operand, name);

	public Bgt_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ble_ : CodeMatch
{
	public Ble_ this[object operand = null, string name = null] => (Ble_)Set(OpCodes.Ble, operand, name);

	public Ble_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Blt_ : CodeMatch
{
	public Blt_ this[object operand = null, string name = null] => (Blt_)Set(OpCodes.Blt, operand, name);

	public Blt_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bne_Un_ : CodeMatch
{
	public Bne_Un_ this[object operand = null, string name = null] => (Bne_Un_)Set(OpCodes.Bne_Un, operand, name);

	public Bne_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bge_Un_ : CodeMatch
{
	public Bge_Un_ this[object operand = null, string name = null] => (Bge_Un_)Set(OpCodes.Bge_Un, operand, name);

	public Bge_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Bgt_Un_ : CodeMatch
{
	public Bgt_Un_ this[object operand = null, string name = null] => (Bgt_Un_)Set(OpCodes.Bgt_Un, operand, name);

	public Bgt_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ble_Un_ : CodeMatch
{
	public Ble_Un_ this[object operand = null, string name = null] => (Ble_Un_)Set(OpCodes.Ble_Un, operand, name);

	public Ble_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Blt_Un_ : CodeMatch
{
	public Blt_Un_ this[object operand = null, string name = null] => (Blt_Un_)Set(OpCodes.Blt_Un, operand, name);

	public Blt_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Switch_ : CodeMatch
{
	public Switch_ this[object operand = null, string name = null] => (Switch_)Set(OpCodes.Switch, operand, name);

	public Switch_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_I1_ : CodeMatch
{
	public Ldind_I1_ this[object operand = null, string name = null] => (Ldind_I1_)Set(OpCodes.Ldind_I1, operand, name);

	public Ldind_I1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_U1_ : CodeMatch
{
	public Ldind_U1_ this[object operand = null, string name = null] => (Ldind_U1_)Set(OpCodes.Ldind_U1, operand, name);

	public Ldind_U1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_I2_ : CodeMatch
{
	public Ldind_I2_ this[object operand = null, string name = null] => (Ldind_I2_)Set(OpCodes.Ldind_I2, operand, name);

	public Ldind_I2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_U2_ : CodeMatch
{
	public Ldind_U2_ this[object operand = null, string name = null] => (Ldind_U2_)Set(OpCodes.Ldind_U2, operand, name);

	public Ldind_U2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_I4_ : CodeMatch
{
	public Ldind_I4_ this[object operand = null, string name = null] => (Ldind_I4_)Set(OpCodes.Ldind_I4, operand, name);

	public Ldind_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_U4_ : CodeMatch
{
	public Ldind_U4_ this[object operand = null, string name = null] => (Ldind_U4_)Set(OpCodes.Ldind_U4, operand, name);

	public Ldind_U4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_I8_ : CodeMatch
{
	public Ldind_I8_ this[object operand = null, string name = null] => (Ldind_I8_)Set(OpCodes.Ldind_I8, operand, name);

	public Ldind_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_I_ : CodeMatch
{
	public Ldind_I_ this[object operand = null, string name = null] => (Ldind_I_)Set(OpCodes.Ldind_I, operand, name);

	public Ldind_I_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_R4_ : CodeMatch
{
	public Ldind_R4_ this[object operand = null, string name = null] => (Ldind_R4_)Set(OpCodes.Ldind_R4, operand, name);

	public Ldind_R4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_R8_ : CodeMatch
{
	public Ldind_R8_ this[object operand = null, string name = null] => (Ldind_R8_)Set(OpCodes.Ldind_R8, operand, name);

	public Ldind_R8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldind_Ref_ : CodeMatch
{
	public Ldind_Ref_ this[object operand = null, string name = null] => (Ldind_Ref_)Set(OpCodes.Ldind_Ref, operand, name);

	public Ldind_Ref_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_Ref_ : CodeMatch
{
	public Stind_Ref_ this[object operand = null, string name = null] => (Stind_Ref_)Set(OpCodes.Stind_Ref, operand, name);

	public Stind_Ref_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_I1_ : CodeMatch
{
	public Stind_I1_ this[object operand = null, string name = null] => (Stind_I1_)Set(OpCodes.Stind_I1, operand, name);

	public Stind_I1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_I2_ : CodeMatch
{
	public Stind_I2_ this[object operand = null, string name = null] => (Stind_I2_)Set(OpCodes.Stind_I2, operand, name);

	public Stind_I2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_I4_ : CodeMatch
{
	public Stind_I4_ this[object operand = null, string name = null] => (Stind_I4_)Set(OpCodes.Stind_I4, operand, name);

	public Stind_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_I8_ : CodeMatch
{
	public Stind_I8_ this[object operand = null, string name = null] => (Stind_I8_)Set(OpCodes.Stind_I8, operand, name);

	public Stind_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_R4_ : CodeMatch
{
	public Stind_R4_ this[object operand = null, string name = null] => (Stind_R4_)Set(OpCodes.Stind_R4, operand, name);

	public Stind_R4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_R8_ : CodeMatch
{
	public Stind_R8_ this[object operand = null, string name = null] => (Stind_R8_)Set(OpCodes.Stind_R8, operand, name);

	public Stind_R8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Add_ : CodeMatch
{
	public Add_ this[object operand = null, string name = null] => (Add_)Set(OpCodes.Add, operand, name);

	public Add_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Sub_ : CodeMatch
{
	public Sub_ this[object operand = null, string name = null] => (Sub_)Set(OpCodes.Sub, operand, name);

	public Sub_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Mul_ : CodeMatch
{
	public Mul_ this[object operand = null, string name = null] => (Mul_)Set(OpCodes.Mul, operand, name);

	public Mul_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Div_ : CodeMatch
{
	public Div_ this[object operand = null, string name = null] => (Div_)Set(OpCodes.Div, operand, name);

	public Div_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Div_Un_ : CodeMatch
{
	public Div_Un_ this[object operand = null, string name = null] => (Div_Un_)Set(OpCodes.Div_Un, operand, name);

	public Div_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Rem_ : CodeMatch
{
	public Rem_ this[object operand = null, string name = null] => (Rem_)Set(OpCodes.Rem, operand, name);

	public Rem_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Rem_Un_ : CodeMatch
{
	public Rem_Un_ this[object operand = null, string name = null] => (Rem_Un_)Set(OpCodes.Rem_Un, operand, name);

	public Rem_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class And_ : CodeMatch
{
	public And_ this[object operand = null, string name = null] => (And_)Set(OpCodes.And, operand, name);

	public And_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Or_ : CodeMatch
{
	public Or_ this[object operand = null, string name = null] => (Or_)Set(OpCodes.Or, operand, name);

	public Or_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Xor_ : CodeMatch
{
	public Xor_ this[object operand = null, string name = null] => (Xor_)Set(OpCodes.Xor, operand, name);

	public Xor_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Shl_ : CodeMatch
{
	public Shl_ this[object operand = null, string name = null] => (Shl_)Set(OpCodes.Shl, operand, name);

	public Shl_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Shr_ : CodeMatch
{
	public Shr_ this[object operand = null, string name = null] => (Shr_)Set(OpCodes.Shr, operand, name);

	public Shr_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Shr_Un_ : CodeMatch
{
	public Shr_Un_ this[object operand = null, string name = null] => (Shr_Un_)Set(OpCodes.Shr_Un, operand, name);

	public Shr_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Neg_ : CodeMatch
{
	public Neg_ this[object operand = null, string name = null] => (Neg_)Set(OpCodes.Neg, operand, name);

	public Neg_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Not_ : CodeMatch
{
	public Not_ this[object operand = null, string name = null] => (Not_)Set(OpCodes.Not, operand, name);

	public Not_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_I1_ : CodeMatch
{
	public Conv_I1_ this[object operand = null, string name = null] => (Conv_I1_)Set(OpCodes.Conv_I1, operand, name);

	public Conv_I1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_I2_ : CodeMatch
{
	public Conv_I2_ this[object operand = null, string name = null] => (Conv_I2_)Set(OpCodes.Conv_I2, operand, name);

	public Conv_I2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_I4_ : CodeMatch
{
	public Conv_I4_ this[object operand = null, string name = null] => (Conv_I4_)Set(OpCodes.Conv_I4, operand, name);

	public Conv_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_I8_ : CodeMatch
{
	public Conv_I8_ this[object operand = null, string name = null] => (Conv_I8_)Set(OpCodes.Conv_I8, operand, name);

	public Conv_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_R4_ : CodeMatch
{
	public Conv_R4_ this[object operand = null, string name = null] => (Conv_R4_)Set(OpCodes.Conv_R4, operand, name);

	public Conv_R4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_R8_ : CodeMatch
{
	public Conv_R8_ this[object operand = null, string name = null] => (Conv_R8_)Set(OpCodes.Conv_R8, operand, name);

	public Conv_R8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_U4_ : CodeMatch
{
	public Conv_U4_ this[object operand = null, string name = null] => (Conv_U4_)Set(OpCodes.Conv_U4, operand, name);

	public Conv_U4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_U8_ : CodeMatch
{
	public Conv_U8_ this[object operand = null, string name = null] => (Conv_U8_)Set(OpCodes.Conv_U8, operand, name);

	public Conv_U8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Callvirt_ : CodeMatch
{
	public Callvirt_ this[object operand = null, string name = null] => (Callvirt_)Set(OpCodes.Callvirt, operand, name);

	public Callvirt_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Cpobj_ : CodeMatch
{
	public Cpobj_ this[object operand = null, string name = null] => (Cpobj_)Set(OpCodes.Cpobj, operand, name);

	public Cpobj_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldobj_ : CodeMatch
{
	public Ldobj_ this[object operand = null, string name = null] => (Ldobj_)Set(OpCodes.Ldobj, operand, name);

	public Ldobj_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldstr_ : CodeMatch
{
	public Ldstr_ this[object operand = null, string name = null] => (Ldstr_)Set(OpCodes.Ldstr, operand, name);

	public Ldstr_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Newobj_ : CodeMatch
{
	public Newobj_ this[object operand = null, string name = null] => (Newobj_)Set(OpCodes.Newobj, operand, name);

	public Newobj_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Castclass_ : CodeMatch
{
	public Castclass_ this[object operand = null, string name = null] => (Castclass_)Set(OpCodes.Castclass, operand, name);

	public Castclass_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Isinst_ : CodeMatch
{
	public Isinst_ this[object operand = null, string name = null] => (Isinst_)Set(OpCodes.Isinst, operand, name);

	public Isinst_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_R_Un_ : CodeMatch
{
	public Conv_R_Un_ this[object operand = null, string name = null] => (Conv_R_Un_)Set(OpCodes.Conv_R_Un, operand, name);

	public Conv_R_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Unbox_ : CodeMatch
{
	public Unbox_ this[object operand = null, string name = null] => (Unbox_)Set(OpCodes.Unbox, operand, name);

	public Unbox_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Throw_ : CodeMatch
{
	public Throw_ this[object operand = null, string name = null] => (Throw_)Set(OpCodes.Throw, operand, name);

	public Throw_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldfld_ : CodeMatch
{
	public Ldfld_ this[object operand = null, string name = null] => (Ldfld_)Set(OpCodes.Ldfld, operand, name);

	public Ldfld_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldflda_ : CodeMatch
{
	public Ldflda_ this[object operand = null, string name = null] => (Ldflda_)Set(OpCodes.Ldflda, operand, name);

	public Ldflda_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stfld_ : CodeMatch
{
	public Stfld_ this[object operand = null, string name = null] => (Stfld_)Set(OpCodes.Stfld, operand, name);

	public Stfld_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldsfld_ : CodeMatch
{
	public Ldsfld_ this[object operand = null, string name = null] => (Ldsfld_)Set(OpCodes.Ldsfld, operand, name);

	public Ldsfld_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldsflda_ : CodeMatch
{
	public Ldsflda_ this[object operand = null, string name = null] => (Ldsflda_)Set(OpCodes.Ldsflda, operand, name);

	public Ldsflda_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stsfld_ : CodeMatch
{
	public Stsfld_ this[object operand = null, string name = null] => (Stsfld_)Set(OpCodes.Stsfld, operand, name);

	public Stsfld_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stobj_ : CodeMatch
{
	public Stobj_ this[object operand = null, string name = null] => (Stobj_)Set(OpCodes.Stobj, operand, name);

	public Stobj_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I1_Un_ : CodeMatch
{
	public Conv_Ovf_I1_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I1_Un_)Set(OpCodes.Conv_Ovf_I1_Un, operand, name);

	public Conv_Ovf_I1_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I2_Un_ : CodeMatch
{
	public Conv_Ovf_I2_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I2_Un_)Set(OpCodes.Conv_Ovf_I2_Un, operand, name);

	public Conv_Ovf_I2_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I4_Un_ : CodeMatch
{
	public Conv_Ovf_I4_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I4_Un_)Set(OpCodes.Conv_Ovf_I4_Un, operand, name);

	public Conv_Ovf_I4_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I8_Un_ : CodeMatch
{
	public Conv_Ovf_I8_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I8_Un_)Set(OpCodes.Conv_Ovf_I8_Un, operand, name);

	public Conv_Ovf_I8_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U1_Un_ : CodeMatch
{
	public Conv_Ovf_U1_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U1_Un_)Set(OpCodes.Conv_Ovf_U1_Un, operand, name);

	public Conv_Ovf_U1_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U2_Un_ : CodeMatch
{
	public Conv_Ovf_U2_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U2_Un_)Set(OpCodes.Conv_Ovf_U2_Un, operand, name);

	public Conv_Ovf_U2_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U4_Un_ : CodeMatch
{
	public Conv_Ovf_U4_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U4_Un_)Set(OpCodes.Conv_Ovf_U4_Un, operand, name);

	public Conv_Ovf_U4_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U8_Un_ : CodeMatch
{
	public Conv_Ovf_U8_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U8_Un_)Set(OpCodes.Conv_Ovf_U8_Un, operand, name);

	public Conv_Ovf_U8_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I_Un_ : CodeMatch
{
	public Conv_Ovf_I_Un_ this[object operand = null, string name = null] => (Conv_Ovf_I_Un_)Set(OpCodes.Conv_Ovf_I_Un, operand, name);

	public Conv_Ovf_I_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U_Un_ : CodeMatch
{
	public Conv_Ovf_U_Un_ this[object operand = null, string name = null] => (Conv_Ovf_U_Un_)Set(OpCodes.Conv_Ovf_U_Un, operand, name);

	public Conv_Ovf_U_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Box_ : CodeMatch
{
	public Box_ this[object operand = null, string name = null] => (Box_)Set(OpCodes.Box, operand, name);

	public Box_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Newarr_ : CodeMatch
{
	public Newarr_ this[object operand = null, string name = null] => (Newarr_)Set(OpCodes.Newarr, operand, name);

	public Newarr_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldlen_ : CodeMatch
{
	public Ldlen_ this[object operand = null, string name = null] => (Ldlen_)Set(OpCodes.Ldlen, operand, name);

	public Ldlen_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelema_ : CodeMatch
{
	public Ldelema_ this[object operand = null, string name = null] => (Ldelema_)Set(OpCodes.Ldelema, operand, name);

	public Ldelema_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_I1_ : CodeMatch
{
	public Ldelem_I1_ this[object operand = null, string name = null] => (Ldelem_I1_)Set(OpCodes.Ldelem_I1, operand, name);

	public Ldelem_I1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_U1_ : CodeMatch
{
	public Ldelem_U1_ this[object operand = null, string name = null] => (Ldelem_U1_)Set(OpCodes.Ldelem_U1, operand, name);

	public Ldelem_U1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_I2_ : CodeMatch
{
	public Ldelem_I2_ this[object operand = null, string name = null] => (Ldelem_I2_)Set(OpCodes.Ldelem_I2, operand, name);

	public Ldelem_I2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_U2_ : CodeMatch
{
	public Ldelem_U2_ this[object operand = null, string name = null] => (Ldelem_U2_)Set(OpCodes.Ldelem_U2, operand, name);

	public Ldelem_U2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_I4_ : CodeMatch
{
	public Ldelem_I4_ this[object operand = null, string name = null] => (Ldelem_I4_)Set(OpCodes.Ldelem_I4, operand, name);

	public Ldelem_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_U4_ : CodeMatch
{
	public Ldelem_U4_ this[object operand = null, string name = null] => (Ldelem_U4_)Set(OpCodes.Ldelem_U4, operand, name);

	public Ldelem_U4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_I8_ : CodeMatch
{
	public Ldelem_I8_ this[object operand = null, string name = null] => (Ldelem_I8_)Set(OpCodes.Ldelem_I8, operand, name);

	public Ldelem_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_I_ : CodeMatch
{
	public Ldelem_I_ this[object operand = null, string name = null] => (Ldelem_I_)Set(OpCodes.Ldelem_I, operand, name);

	public Ldelem_I_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_R4_ : CodeMatch
{
	public Ldelem_R4_ this[object operand = null, string name = null] => (Ldelem_R4_)Set(OpCodes.Ldelem_R4, operand, name);

	public Ldelem_R4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_R8_ : CodeMatch
{
	public Ldelem_R8_ this[object operand = null, string name = null] => (Ldelem_R8_)Set(OpCodes.Ldelem_R8, operand, name);

	public Ldelem_R8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_Ref_ : CodeMatch
{
	public Ldelem_Ref_ this[object operand = null, string name = null] => (Ldelem_Ref_)Set(OpCodes.Ldelem_Ref, operand, name);

	public Ldelem_Ref_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_I_ : CodeMatch
{
	public Stelem_I_ this[object operand = null, string name = null] => (Stelem_I_)Set(OpCodes.Stelem_I, operand, name);

	public Stelem_I_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_I1_ : CodeMatch
{
	public Stelem_I1_ this[object operand = null, string name = null] => (Stelem_I1_)Set(OpCodes.Stelem_I1, operand, name);

	public Stelem_I1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_I2_ : CodeMatch
{
	public Stelem_I2_ this[object operand = null, string name = null] => (Stelem_I2_)Set(OpCodes.Stelem_I2, operand, name);

	public Stelem_I2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_I4_ : CodeMatch
{
	public Stelem_I4_ this[object operand = null, string name = null] => (Stelem_I4_)Set(OpCodes.Stelem_I4, operand, name);

	public Stelem_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_I8_ : CodeMatch
{
	public Stelem_I8_ this[object operand = null, string name = null] => (Stelem_I8_)Set(OpCodes.Stelem_I8, operand, name);

	public Stelem_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_R4_ : CodeMatch
{
	public Stelem_R4_ this[object operand = null, string name = null] => (Stelem_R4_)Set(OpCodes.Stelem_R4, operand, name);

	public Stelem_R4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_R8_ : CodeMatch
{
	public Stelem_R8_ this[object operand = null, string name = null] => (Stelem_R8_)Set(OpCodes.Stelem_R8, operand, name);

	public Stelem_R8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_Ref_ : CodeMatch
{
	public Stelem_Ref_ this[object operand = null, string name = null] => (Stelem_Ref_)Set(OpCodes.Stelem_Ref, operand, name);

	public Stelem_Ref_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldelem_ : CodeMatch
{
	public Ldelem_ this[object operand = null, string name = null] => (Ldelem_)Set(OpCodes.Ldelem, operand, name);

	public Ldelem_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stelem_ : CodeMatch
{
	public Stelem_ this[object operand = null, string name = null] => (Stelem_)Set(OpCodes.Stelem, operand, name);

	public Stelem_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Unbox_Any_ : CodeMatch
{
	public Unbox_Any_ this[object operand = null, string name = null] => (Unbox_Any_)Set(OpCodes.Unbox_Any, operand, name);

	public Unbox_Any_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I1_ : CodeMatch
{
	public Conv_Ovf_I1_ this[object operand = null, string name = null] => (Conv_Ovf_I1_)Set(OpCodes.Conv_Ovf_I1, operand, name);

	public Conv_Ovf_I1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U1_ : CodeMatch
{
	public Conv_Ovf_U1_ this[object operand = null, string name = null] => (Conv_Ovf_U1_)Set(OpCodes.Conv_Ovf_U1, operand, name);

	public Conv_Ovf_U1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I2_ : CodeMatch
{
	public Conv_Ovf_I2_ this[object operand = null, string name = null] => (Conv_Ovf_I2_)Set(OpCodes.Conv_Ovf_I2, operand, name);

	public Conv_Ovf_I2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U2_ : CodeMatch
{
	public Conv_Ovf_U2_ this[object operand = null, string name = null] => (Conv_Ovf_U2_)Set(OpCodes.Conv_Ovf_U2, operand, name);

	public Conv_Ovf_U2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I4_ : CodeMatch
{
	public Conv_Ovf_I4_ this[object operand = null, string name = null] => (Conv_Ovf_I4_)Set(OpCodes.Conv_Ovf_I4, operand, name);

	public Conv_Ovf_I4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U4_ : CodeMatch
{
	public Conv_Ovf_U4_ this[object operand = null, string name = null] => (Conv_Ovf_U4_)Set(OpCodes.Conv_Ovf_U4, operand, name);

	public Conv_Ovf_U4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I8_ : CodeMatch
{
	public Conv_Ovf_I8_ this[object operand = null, string name = null] => (Conv_Ovf_I8_)Set(OpCodes.Conv_Ovf_I8, operand, name);

	public Conv_Ovf_I8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U8_ : CodeMatch
{
	public Conv_Ovf_U8_ this[object operand = null, string name = null] => (Conv_Ovf_U8_)Set(OpCodes.Conv_Ovf_U8, operand, name);

	public Conv_Ovf_U8_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Refanyval_ : CodeMatch
{
	public Refanyval_ this[object operand = null, string name = null] => (Refanyval_)Set(OpCodes.Refanyval, operand, name);

	public Refanyval_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ckfinite_ : CodeMatch
{
	public Ckfinite_ this[object operand = null, string name = null] => (Ckfinite_)Set(OpCodes.Ckfinite, operand, name);

	public Ckfinite_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Mkrefany_ : CodeMatch
{
	public Mkrefany_ this[object operand = null, string name = null] => (Mkrefany_)Set(OpCodes.Mkrefany, operand, name);

	public Mkrefany_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldtoken_ : CodeMatch
{
	public Ldtoken_ this[object operand = null, string name = null] => (Ldtoken_)Set(OpCodes.Ldtoken, operand, name);

	public Ldtoken_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_U2_ : CodeMatch
{
	public Conv_U2_ this[object operand = null, string name = null] => (Conv_U2_)Set(OpCodes.Conv_U2, operand, name);

	public Conv_U2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_U1_ : CodeMatch
{
	public Conv_U1_ this[object operand = null, string name = null] => (Conv_U1_)Set(OpCodes.Conv_U1, operand, name);

	public Conv_U1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_I_ : CodeMatch
{
	public Conv_I_ this[object operand = null, string name = null] => (Conv_I_)Set(OpCodes.Conv_I, operand, name);

	public Conv_I_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_I_ : CodeMatch
{
	public Conv_Ovf_I_ this[object operand = null, string name = null] => (Conv_Ovf_I_)Set(OpCodes.Conv_Ovf_I, operand, name);

	public Conv_Ovf_I_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_Ovf_U_ : CodeMatch
{
	public Conv_Ovf_U_ this[object operand = null, string name = null] => (Conv_Ovf_U_)Set(OpCodes.Conv_Ovf_U, operand, name);

	public Conv_Ovf_U_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Add_Ovf_ : CodeMatch
{
	public Add_Ovf_ this[object operand = null, string name = null] => (Add_Ovf_)Set(OpCodes.Add_Ovf, operand, name);

	public Add_Ovf_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Add_Ovf_Un_ : CodeMatch
{
	public Add_Ovf_Un_ this[object operand = null, string name = null] => (Add_Ovf_Un_)Set(OpCodes.Add_Ovf_Un, operand, name);

	public Add_Ovf_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Mul_Ovf_ : CodeMatch
{
	public Mul_Ovf_ this[object operand = null, string name = null] => (Mul_Ovf_)Set(OpCodes.Mul_Ovf, operand, name);

	public Mul_Ovf_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Mul_Ovf_Un_ : CodeMatch
{
	public Mul_Ovf_Un_ this[object operand = null, string name = null] => (Mul_Ovf_Un_)Set(OpCodes.Mul_Ovf_Un, operand, name);

	public Mul_Ovf_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Sub_Ovf_ : CodeMatch
{
	public Sub_Ovf_ this[object operand = null, string name = null] => (Sub_Ovf_)Set(OpCodes.Sub_Ovf, operand, name);

	public Sub_Ovf_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Sub_Ovf_Un_ : CodeMatch
{
	public Sub_Ovf_Un_ this[object operand = null, string name = null] => (Sub_Ovf_Un_)Set(OpCodes.Sub_Ovf_Un, operand, name);

	public Sub_Ovf_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Endfinally_ : CodeMatch
{
	public Endfinally_ this[object operand = null, string name = null] => (Endfinally_)Set(OpCodes.Endfinally, operand, name);

	public Endfinally_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Leave_ : CodeMatch
{
	public Leave_ this[object operand = null, string name = null] => (Leave_)Set(OpCodes.Leave, operand, name);

	public Leave_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Leave_S_ : CodeMatch
{
	public Leave_S_ this[object operand = null, string name = null] => (Leave_S_)Set(OpCodes.Leave_S, operand, name);

	public Leave_S_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stind_I_ : CodeMatch
{
	public Stind_I_ this[object operand = null, string name = null] => (Stind_I_)Set(OpCodes.Stind_I, operand, name);

	public Stind_I_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Conv_U_ : CodeMatch
{
	public Conv_U_ this[object operand = null, string name = null] => (Conv_U_)Set(OpCodes.Conv_U, operand, name);

	public Conv_U_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix7_ : CodeMatch
{
	public Prefix7_ this[object operand = null, string name = null] => (Prefix7_)Set(OpCodes.Prefix7, operand, name);

	public Prefix7_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix6_ : CodeMatch
{
	public Prefix6_ this[object operand = null, string name = null] => (Prefix6_)Set(OpCodes.Prefix6, operand, name);

	public Prefix6_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix5_ : CodeMatch
{
	public Prefix5_ this[object operand = null, string name = null] => (Prefix5_)Set(OpCodes.Prefix5, operand, name);

	public Prefix5_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix4_ : CodeMatch
{
	public Prefix4_ this[object operand = null, string name = null] => (Prefix4_)Set(OpCodes.Prefix4, operand, name);

	public Prefix4_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix3_ : CodeMatch
{
	public Prefix3_ this[object operand = null, string name = null] => (Prefix3_)Set(OpCodes.Prefix3, operand, name);

	public Prefix3_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix2_ : CodeMatch
{
	public Prefix2_ this[object operand = null, string name = null] => (Prefix2_)Set(OpCodes.Prefix2, operand, name);

	public Prefix2_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefix1_ : CodeMatch
{
	public Prefix1_ this[object operand = null, string name = null] => (Prefix1_)Set(OpCodes.Prefix1, operand, name);

	public Prefix1_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Prefixref_ : CodeMatch
{
	public Prefixref_ this[object operand = null, string name = null] => (Prefixref_)Set(OpCodes.Prefixref, operand, name);

	public Prefixref_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Arglist_ : CodeMatch
{
	public Arglist_ this[object operand = null, string name = null] => (Arglist_)Set(OpCodes.Arglist, operand, name);

	public Arglist_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ceq_ : CodeMatch
{
	public Ceq_ this[object operand = null, string name = null] => (Ceq_)Set(OpCodes.Ceq, operand, name);

	public Ceq_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Cgt_ : CodeMatch
{
	public Cgt_ this[object operand = null, string name = null] => (Cgt_)Set(OpCodes.Cgt, operand, name);

	public Cgt_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Cgt_Un_ : CodeMatch
{
	public Cgt_Un_ this[object operand = null, string name = null] => (Cgt_Un_)Set(OpCodes.Cgt_Un, operand, name);

	public Cgt_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Clt_ : CodeMatch
{
	public Clt_ this[object operand = null, string name = null] => (Clt_)Set(OpCodes.Clt, operand, name);

	public Clt_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Clt_Un_ : CodeMatch
{
	public Clt_Un_ this[object operand = null, string name = null] => (Clt_Un_)Set(OpCodes.Clt_Un, operand, name);

	public Clt_Un_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldftn_ : CodeMatch
{
	public Ldftn_ this[object operand = null, string name = null] => (Ldftn_)Set(OpCodes.Ldftn, operand, name);

	public Ldftn_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldvirtftn_ : CodeMatch
{
	public Ldvirtftn_ this[object operand = null, string name = null] => (Ldvirtftn_)Set(OpCodes.Ldvirtftn, operand, name);

	public Ldvirtftn_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarg_ : CodeMatch
{
	public Ldarg_ this[object operand = null, string name = null] => (Ldarg_)Set(OpCodes.Ldarg, operand, name);

	public Ldarg_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldarga_ : CodeMatch
{
	public Ldarga_ this[object operand = null, string name = null] => (Ldarga_)Set(OpCodes.Ldarga, operand, name);

	public Ldarga_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Starg_ : CodeMatch
{
	public Starg_ this[object operand = null, string name = null] => (Starg_)Set(OpCodes.Starg, operand, name);

	public Starg_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloc_ : CodeMatch
{
	public Ldloc_ this[object operand = null, string name = null] => (Ldloc_)Set(OpCodes.Ldloc, operand, name);

	public Ldloc_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Ldloca_ : CodeMatch
{
	public Ldloca_ this[object operand = null, string name = null] => (Ldloca_)Set(OpCodes.Ldloca, operand, name);

	public Ldloca_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Stloc_ : CodeMatch
{
	public Stloc_ this[object operand = null, string name = null] => (Stloc_)Set(OpCodes.Stloc, operand, name);

	public Stloc_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Localloc_ : CodeMatch
{
	public Localloc_ this[object operand = null, string name = null] => (Localloc_)Set(OpCodes.Localloc, operand, name);

	public Localloc_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Endfilter_ : CodeMatch
{
	public Endfilter_ this[object operand = null, string name = null] => (Endfilter_)Set(OpCodes.Endfilter, operand, name);

	public Endfilter_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Unaligned_ : CodeMatch
{
	public Unaligned_ this[object operand = null, string name = null] => (Unaligned_)Set(OpCodes.Unaligned, operand, name);

	public Unaligned_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Volatile_ : CodeMatch
{
	public Volatile_ this[object operand = null, string name = null] => (Volatile_)Set(OpCodes.Volatile, operand, name);

	public Volatile_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Tailcall_ : CodeMatch
{
	public Tailcall_ this[object operand = null, string name = null] => (Tailcall_)Set(OpCodes.Tailcall, operand, name);

	public Tailcall_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Initobj_ : CodeMatch
{
	public Initobj_ this[object operand = null, string name = null] => (Initobj_)Set(OpCodes.Initobj, operand, name);

	public Initobj_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Constrained_ : CodeMatch
{
	public Constrained_ this[object operand = null, string name = null] => (Constrained_)Set(OpCodes.Constrained, operand, name);

	public Constrained_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Cpblk_ : CodeMatch
{
	public Cpblk_ this[object operand = null, string name = null] => (Cpblk_)Set(OpCodes.Cpblk, operand, name);

	public Cpblk_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Initblk_ : CodeMatch
{
	public Initblk_ this[object operand = null, string name = null] => (Initblk_)Set(OpCodes.Initblk, operand, name);

	public Initblk_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Rethrow_ : CodeMatch
{
	public Rethrow_ this[object operand = null, string name = null] => (Rethrow_)Set(OpCodes.Rethrow, operand, name);

	public Rethrow_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Sizeof_ : CodeMatch
{
	public Sizeof_ this[object operand = null, string name = null] => (Sizeof_)Set(OpCodes.Sizeof, operand, name);

	public Sizeof_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Refanytype_ : CodeMatch
{
	public Refanytype_ this[object operand = null, string name = null] => (Refanytype_)Set(OpCodes.Refanytype, operand, name);

	public Refanytype_()
		: base(null, null, null)
	{
	}
}


using System.Reflection.Emit;

public class Readonly_ : CodeMatch
{
	public Readonly_ this[object operand = null, string name = null] => (Readonly_)Set(OpCodes.Readonly, operand, name);

	public Readonly_()
		: base(null, null, null)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

public class CodeMatch : CodeInstruction
{
	public string name;

	public HashSet<OpCode> opcodeSet = new HashSet<OpCode>();

	public List<object> operands = new List<object>();

	public List<int> jumpsFrom = new List<int>();

	public List<int> jumpsTo = new List<int>();

	public Func<CodeInstruction, bool> predicate;

	[Obsolete("Use opcodeSet instead")]
	public List<OpCode> opcodes
	{
		get
		{
			HashSet<OpCode> hashSet = opcodeSet;
			List<OpCode> list = new List<OpCode>(hashSet.Count);
			list.AddRange(hashSet);
			return list;
		}
		set
		{
			opcodeSet = new HashSet<OpCode>(value);
		}
	}

	internal CodeMatch Set(object operand, string name)
	{
		if (base.operand == null)
		{
			base.operand = operand;
		}
		if (operand != null)
		{
			operands.Add(operand);
		}
		if (this.name == null)
		{
			this.name = name;
		}
		return this;
	}

	internal CodeMatch Set(OpCode opcode, object operand, string name)
	{
		base.opcode = opcode;
		opcodeSet.Add(opcode);
		if (base.operand == null)
		{
			base.operand = operand;
		}
		if (operand != null)
		{
			operands.Add(operand);
		}
		if (this.name == null)
		{
			this.name = name;
		}
		return this;
	}

	public CodeMatch(OpCode? opcode = null, object operand = null, string name = null)
	{
		if (opcode.HasValue)
		{
			OpCode item = (base.opcode = opcode.GetValueOrDefault());
			opcodeSet.Add(item);
		}
		if (operand != null)
		{
			operands.Add(operand);
		}
		base.operand = operand;
		this.name = name;
	}

	public static CodeMatch WithOpcodes(HashSet<OpCode> opcodes, object operand = null, string name = null)
	{
		return new CodeMatch(null, operand, name)
		{
			opcodeSet = opcodes
		};
	}

	public CodeMatch(Expression<Action> expression, string name = null)
	{
		opcodeSet.UnionWith(CodeInstructionExtensions.opcodesCalling);
		operand = SymbolExtensions.GetMethodInfo(expression);
		if (operand != null)
		{
			operands.Add(operand);
		}
		this.name = name;
	}

	public CodeMatch(LambdaExpression expression, string name = null)
	{
		opcodeSet.UnionWith(CodeInstructionExtensions.opcodesCalling);
		operand = SymbolExtensions.GetMethodInfo(expression);
		if (operand != null)
		{
			operands.Add(operand);
		}
		this.name = name;
	}

	public CodeMatch(CodeInstruction instruction, string name = null)
		: this(instruction.opcode, instruction.operand, name)
	{
	}

	public CodeMatch(Func<CodeInstruction, bool> predicate, string name = null)
	{
		this.predicate = predicate;
		this.name = name;
	}

	internal bool Matches(List<CodeInstruction> codes, CodeInstruction instruction)
	{
		if (predicate != null)
		{
			return predicate(instruction);
		}
		if (opcodeSet.Count > 0 && !opcodeSet.Contains(instruction.opcode))
		{
			return false;
		}
		if (operands.Count > 0 && !operands.Contains(instruction.operand))
		{
			return false;
		}
		if (labels.Count > 0 && !labels.Intersect(instruction.labels).Any())
		{
			return false;
		}
		if (blocks.Count > 0 && !blocks.Intersect(instruction.blocks).Any())
		{
			return false;
		}
		if (jumpsFrom.Count > 0 && !jumpsFrom.Select((int index) => codes[index].operand).OfType<Label>().Intersect(instruction.labels)
			.Any())
		{
			return false;
		}
		if (jumpsTo.Count > 0)
		{
			object obj = instruction.operand;
			if (obj == null || obj.GetType() != typeof(Label))
			{
				return false;
			}
			Label label = (Label)obj;
			IEnumerable<int> second = from idx in Enumerable.Range(0, codes.Count)
				where codes[idx].labels.Contains(label)
				select idx;
			if (!jumpsTo.Intersect(second).Any())
			{
				return false;
			}
		}
		return true;
	}

	public static CodeMatch IsLdarg(int? n = null)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.IsLdarg(n));
	}

	public static CodeMatch IsLdarga(int? n = null)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.IsLdarga(n));
	}

	public static CodeMatch IsStarg(int? n = null)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.IsStarg(n));
	}

	public static CodeMatch IsLdloc(LocalBuilder variable = null)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.IsLdloc(variable));
	}

	public static CodeMatch IsStloc(LocalBuilder variable = null)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.IsStloc(variable));
	}

	public static CodeMatch Calls(MethodInfo method)
	{
		return WithOpcodes(CodeInstructionExtensions.opcodesCalling, method);
	}

	public static CodeMatch LoadsConstant()
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.LoadsConstant());
	}

	public static CodeMatch LoadsConstant(long number)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.LoadsConstant(number));
	}

	public static CodeMatch LoadsConstant(double number)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.LoadsConstant(number));
	}

	public static CodeMatch LoadsConstant(Enum e)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.LoadsConstant(e));
	}

	public static CodeMatch LoadsConstant(string str)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.LoadsConstant(str));
	}

	public static CodeMatch LoadsField(FieldInfo field, bool byAddress = false)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.LoadsField(field, byAddress));
	}

	public static CodeMatch StoresField(FieldInfo field)
	{
		return new CodeMatch((CodeInstruction instruction) => instruction.StoresField(field));
	}

	public static CodeMatch Calls(Expression<Action> expression)
	{
		return new CodeMatch(expression);
	}

	public static CodeMatch Calls(LambdaExpression expression)
	{
		return new CodeMatch(expression);
	}

	public static CodeMatch LoadsLocal(bool useAddress = false, string name = null)
	{
		return WithOpcodes(useAddress ? CodeInstructionExtensions.opcodesLoadingLocalByAddress : CodeInstructionExtensions.opcodesLoadingLocalNormal, null, name);
	}

	public static CodeMatch StoresLocal(string name = null)
	{
		return WithOpcodes(CodeInstructionExtensions.opcodesStoringLocal, null, name);
	}

	public static CodeMatch LoadsArgument(bool useAddress = false, string name = null)
	{
		return WithOpcodes(useAddress ? CodeInstructionExtensions.opcodesLoadingArgumentByAddress : CodeInstructionExtensions.opcodesLoadingArgumentNormal, null, name);
	}

	public static CodeMatch StoresArgument(string name = null)
	{
		return WithOpcodes(CodeInstructionExtensions.opcodesStoringArgument, null, name);
	}

	public static CodeMatch Branches(string name = null)
	{
		return WithOpcodes(CodeInstructionExtensions.opcodesBranching, null, name);
	}

	public override string ToString()
	{
		string text = "[";
		if (name != null)
		{
			text = text + name + ": ";
		}
		if (opcodeSet.Count > 0)
		{
			text = text + "opcodes=" + opcodeSet.Join() + " ";
		}
		if (operands.Count > 0)
		{
			text = text + "operands=" + operands.Join() + " ";
		}
		if (labels.Count > 0)
		{
			text = text + "labels=" + labels.Join() + " ";
		}
		if (blocks.Count > 0)
		{
			text = text + "blocks=" + blocks.Join() + " ";
		}
		if (jumpsFrom.Count > 0)
		{
			text = text + "jumpsFrom=" + jumpsFrom.Join() + " ";
		}
		if (jumpsTo.Count > 0)
		{
			text = text + "jumpsTo=" + jumpsTo.Join() + " ";
		}
		if (predicate != null)
		{
			text += "predicate=yes ";
		}
		return text.TrimEnd(Array.Empty<char>()) + "]";
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

public class CodeMatcher
{
	private delegate CodeMatcher MatchDelegate();

	private readonly ILGenerator generator;

	private readonly List<CodeInstruction> codes = new List<CodeInstruction>();

	private Dictionary<string, CodeInstruction> lastMatches = new Dictionary<string, CodeInstruction>();

	private string lastError;

	private MatchDelegate lastMatchCall;

	public int Pos { get; private set; } = -1;

	public int Length => codes.Count;

	public bool IsValid
	{
		get
		{
			if (Pos >= 0)
			{
				return Pos < Length;
			}
			return false;
		}
	}

	public bool IsInvalid
	{
		get
		{
			if (Pos >= 0)
			{
				return Pos >= Length;
			}
			return true;
		}
	}

	public int Remaining => Length - Math.Max(0, Pos);

	public ref OpCode Opcode => ref codes[Pos].opcode;

	public ref object Operand => ref codes[Pos].operand;

	public ref List<Label> Labels => ref codes[Pos].labels;

	public ref List<ExceptionBlock> Blocks => ref codes[Pos].blocks;

	public CodeInstruction Instruction => codes[Pos];

	private void FixStart()
	{
		Pos = Math.Max(0, Pos);
	}

	private void SetOutOfBounds(int direction)
	{
		Pos = ((direction > 0) ? Length : (-1));
	}

	public CodeMatcher()
	{
	}

	public CodeMatcher(IEnumerable<CodeInstruction> instructions, ILGenerator generator = null)
	{
		this.generator = generator;
		codes = instructions.Select((CodeInstruction c) => new CodeInstruction(c)).ToList();
	}

	public CodeMatcher Clone()
	{
		return new CodeMatcher(codes, generator)
		{
			Pos = Pos,
			lastMatches = lastMatches,
			lastError = lastError,
			lastMatchCall = lastMatchCall
		};
	}

	public CodeInstruction InstructionAt(int offset)
	{
		return codes[Pos + offset];
	}

	public List<CodeInstruction> Instructions()
	{
		return codes;
	}

	public IEnumerable<CodeInstruction> InstructionEnumeration()
	{
		return codes.AsEnumerable();
	}

	public List<CodeInstruction> Instructions(int count)
	{
		return (from c in codes.GetRange(Pos, count)
			select new CodeInstruction(c)).ToList();
	}

	public List<CodeInstruction> InstructionsInRange(int start, int end)
	{
		List<CodeInstruction> list = codes;
		if (start > end)
		{
			int num = start;
			start = end;
			end = num;
		}
		list = list.GetRange(start, end - start + 1);
		return list.Select((CodeInstruction c) => new CodeInstruction(c)).ToList();
	}

	public List<CodeInstruction> InstructionsWithOffsets(int startOffset, int endOffset)
	{
		return InstructionsInRange(Pos + startOffset, Pos + endOffset);
	}

	public List<Label> DistinctLabels(IEnumerable<CodeInstruction> instructions)
	{
		return instructions.SelectMany((CodeInstruction instruction) => instruction.labels).Distinct().ToList();
	}

	public bool ReportFailure(MethodBase method, Action<string> logger)
	{
		if (IsValid)
		{
			return false;
		}
		string value = lastError ?? "Unexpected code";
		logger($"{value} in {method}");
		return true;
	}

	public CodeMatcher ThrowIfInvalid(string explanation)
	{
		if (explanation == null)
		{
			throw new ArgumentNullException("explanation");
		}
		if (IsInvalid)
		{
			throw new InvalidOperationException(explanation + " - Current state is invalid");
		}
		return this;
	}

	public CodeMatcher ThrowIfNotMatch(string explanation, params CodeMatch[] matches)
	{
		ThrowIfInvalid(explanation);
		if (!MatchSequence(Pos, matches))
		{
			throw new InvalidOperationException(explanation + " - Match failed");
		}
		return this;
	}

	private void ThrowIfNotMatch(string explanation, int direction, CodeMatch[] matches)
	{
		ThrowIfInvalid(explanation);
		int pos = Pos;
		try
		{
			if (Match(matches, direction, useEnd: false).IsInvalid)
			{
				throw new InvalidOperationException(explanation + " - Match failed");
			}
		}
		finally
		{
			Pos = pos;
		}
	}

	public CodeMatcher ThrowIfNotMatchForward(string explanation, params CodeMatch[] matches)
	{
		ThrowIfNotMatch(explanation, 1, matches);
		return this;
	}

	public CodeMatcher ThrowIfNotMatchBack(string explanation, params CodeMatch[] matches)
	{
		ThrowIfNotMatch(explanation, -1, matches);
		return this;
	}

	public CodeMatcher ThrowIfFalse(string explanation, Func<CodeMatcher, bool> stateCheckFunc)
	{
		if (stateCheckFunc == null)
		{
			throw new ArgumentNullException("stateCheckFunc");
		}
		ThrowIfInvalid(explanation);
		if (!stateCheckFunc(this))
		{
			throw new InvalidOperationException(explanation + " - Check function returned false");
		}
		return this;
	}

	public CodeMatcher SetInstruction(CodeInstruction instruction)
	{
		codes[Pos] = instruction;
		return this;
	}

	public CodeMatcher SetInstructionAndAdvance(CodeInstruction instruction)
	{
		SetInstruction(instruction);
		Pos++;
		return this;
	}

	public CodeMatcher Set(OpCode opcode, object operand)
	{
		Opcode = opcode;
		Operand = operand;
		return this;
	}

	public CodeMatcher SetAndAdvance(OpCode opcode, object operand)
	{
		Set(opcode, operand);
		Pos++;
		return this;
	}

	public CodeMatcher SetOpcodeAndAdvance(OpCode opcode)
	{
		Opcode = opcode;
		Pos++;
		return this;
	}

	public CodeMatcher SetOperandAndAdvance(object operand)
	{
		Operand = operand;
		Pos++;
		return this;
	}

	public CodeMatcher DeclareLocal(Type variableType, out LocalBuilder localVariable)
	{
		localVariable = generator.DeclareLocal(variableType);
		return this;
	}

	public CodeMatcher DefineLabel(out Label label)
	{
		label = generator.DefineLabel();
		return this;
	}

	public CodeMatcher CreateLabel(out Label label)
	{
		label = generator.DefineLabel();
		Labels.Add(label);
		return this;
	}

	public CodeMatcher CreateLabelAt(int position, out Label label)
	{
		label = generator.DefineLabel();
		AddLabelsAt(position, new Label[1] { label });
		return this;
	}

	public CodeMatcher CreateLabelWithOffsets(int offset, out Label label)
	{
		label = generator.DefineLabel();
		return AddLabelsAt(Pos + offset, new Label[1] { label });
	}

	public CodeMatcher AddLabels(IEnumerable<Label> labels)
	{
		Labels.AddRange(labels);
		return this;
	}

	public CodeMatcher AddLabelsAt(int position, IEnumerable<Label> labels)
	{
		codes[position].labels.AddRange(labels);
		return this;
	}

	public CodeMatcher SetJumpTo(OpCode opcode, int destination, out Label label)
	{
		CreateLabelAt(destination, out label);
		return Set(opcode, label);
	}

	public CodeMatcher Insert(params CodeInstruction[] instructions)
	{
		codes.InsertRange(Pos, instructions);
		return this;
	}

	public CodeMatcher Insert(IEnumerable<CodeInstruction> instructions)
	{
		codes.InsertRange(Pos, instructions);
		return this;
	}

	public CodeMatcher InsertBranch(OpCode opcode, int destination)
	{
		CreateLabelAt(destination, out var label);
		codes.Insert(Pos, new CodeInstruction(opcode, label));
		return this;
	}

	public CodeMatcher InsertAndAdvance(params CodeInstruction[] instructions)
	{
		foreach (CodeInstruction codeInstruction in instructions)
		{
			Insert(codeInstruction);
			Pos++;
		}
		return this;
	}

	public CodeMatcher InsertAndAdvance(IEnumerable<CodeInstruction> instructions)
	{
		foreach (CodeInstruction instruction in instructions)
		{
			InsertAndAdvance(instruction);
		}
		return this;
	}

	public CodeMatcher InsertBranchAndAdvance(OpCode opcode, int destination)
	{
		InsertBranch(opcode, destination);
		Pos++;
		return this;
	}

	public CodeMatcher RemoveInstruction()
	{
		codes.RemoveAt(Pos);
		return this;
	}

	public CodeMatcher RemoveInstructions(int count)
	{
		codes.RemoveRange(Pos, count);
		return this;
	}

	public CodeMatcher RemoveInstructionsInRange(int start, int end)
	{
		if (start > end)
		{
			int num = start;
			start = end;
			end = num;
		}
		codes.RemoveRange(start, end - start + 1);
		return this;
	}

	public CodeMatcher RemoveInstructionsWithOffsets(int startOffset, int endOffset)
	{
		return RemoveInstructionsInRange(Pos + startOffset, Pos + endOffset);
	}

	public CodeMatcher Advance(int offset)
	{
		Pos += offset;
		if (!IsValid)
		{
			SetOutOfBounds(offset);
		}
		return this;
	}

	public CodeMatcher Start()
	{
		Pos = 0;
		return this;
	}

	public CodeMatcher End()
	{
		Pos = Length - 1;
		return this;
	}

	public CodeMatcher SearchForward(Func<CodeInstruction, bool> predicate)
	{
		return Search(predicate, 1);
	}

	public CodeMatcher SearchBackwards(Func<CodeInstruction, bool> predicate)
	{
		return Search(predicate, -1);
	}

	private CodeMatcher Search(Func<CodeInstruction, bool> predicate, int direction)
	{
		FixStart();
		while (IsValid && !predicate(Instruction))
		{
			Pos += direction;
		}
		lastError = (IsInvalid ? $"Cannot find {predicate}" : null);
		return this;
	}

	public CodeMatcher MatchStartForward(params CodeMatch[] matches)
	{
		return Match(matches, 1, useEnd: false);
	}

	public CodeMatcher MatchEndForward(params CodeMatch[] matches)
	{
		return Match(matches, 1, useEnd: true);
	}

	public CodeMatcher MatchStartBackwards(params CodeMatch[] matches)
	{
		return Match(matches, -1, useEnd: false);
	}

	public CodeMatcher MatchEndBackwards(params CodeMatch[] matches)
	{
		return Match(matches, -1, useEnd: true);
	}

	private CodeMatcher Match(CodeMatch[] matches, int direction, bool useEnd)
	{
		lastMatchCall = delegate
		{
			FixStart();
			while (IsValid)
			{
				if (MatchSequence(Pos, matches))
				{
					if (useEnd)
					{
						Pos += matches.Length - 1;
					}
					break;
				}
				Pos += direction;
			}
			lastError = (IsInvalid ? ("Cannot find " + matches.Join()) : null);
			return this;
		};
		return lastMatchCall();
	}

	public CodeMatcher Repeat(Action<CodeMatcher> matchAction, Action<string> notFoundAction = null)
	{
		int num = 0;
		if (lastMatchCall == null)
		{
			throw new InvalidOperationException("No previous Match operation - cannot repeat");
		}
		while (IsValid)
		{
			matchAction(this);
			lastMatchCall();
			num++;
		}
		lastMatchCall = null;
		if (num == 0)
		{
			notFoundAction?.Invoke(lastError);
		}
		return this;
	}

	public CodeInstruction NamedMatch(string name)
	{
		return lastMatches[name];
	}

	private bool MatchSequence(int start, CodeMatch[] matches)
	{
		if (start < 0)
		{
			return false;
		}
		lastMatches = new Dictionary<string, CodeInstruction>();
		foreach (CodeMatch codeMatch in matches)
		{
			if (start >= Length || !codeMatch.Matches(codes, codes[start]))
			{
				return false;
			}
			if (codeMatch.name != null)
			{
				lastMatches.Add(codeMatch.name, codes[start]);
			}
			start++;
		}
		return true;
	}
}


private delegate CodeMatcher MatchDelegate();


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using HarmonyLib;

public static class GeneralExtensions
{
	public static string Join<T>(this IEnumerable<T> enumeration, Func<T, string> converter = null, string delimiter = ", ")
	{
		if (converter == null)
		{
			converter = (T t) => t.ToString();
		}
		return enumeration.Aggregate("", (string prev, T curr) => prev + ((prev.Length > 0) ? delimiter : "") + converter(curr));
	}

	public static string Description(this Type[] parameters)
	{
		if (parameters == null)
		{
			return "NULL";
		}
		return "(" + parameters.Join((Type p) => p.FullDescription()) + ")";
	}

	public static string FullDescription(this Type type)
	{
		if ((object)type == null)
		{
			return "null";
		}
		string text = type.Namespace;
		if (!string.IsNullOrEmpty(text))
		{
			text += ".";
		}
		string text2 = text + type.Name;
		if (type.IsGenericType)
		{
			text2 += "<";
			Type[] genericArguments = type.GetGenericArguments();
			for (int i = 0; i < genericArguments.Length; i++)
			{
				if (!text2.EndsWith("<", StringComparison.Ordinal))
				{
					text2 += ", ";
				}
				text2 += genericArguments[i].FullDescription();
			}
			text2 += ">";
		}
		return text2;
	}

	public static string FullDescription(this MethodBase member)
	{
		if ((object)member == null)
		{
			return "null";
		}
		Type returnedType = AccessTools.GetReturnedType(member);
		StringBuilder stringBuilder = new StringBuilder();
		if (member.IsStatic)
		{
			stringBuilder.Append("static ");
		}
		if (member.IsAbstract)
		{
			stringBuilder.Append("abstract ");
		}
		if (member.IsVirtual)
		{
			stringBuilder.Append("virtual ");
		}
		stringBuilder.Append(returnedType.FullDescription() + " ");
		if ((object)member.DeclaringType != null)
		{
			stringBuilder.Append(member.DeclaringType.FullDescription() + "::");
		}
		string text = member.GetParameters().Join((ParameterInfo p) => p.ParameterType.FullDescription() + " " + p.Name);
		stringBuilder.Append(member.Name + "(" + text + ")");
		return stringBuilder.ToString();
	}

	public static Type[] Types(this ParameterInfo[] pinfo)
	{
		return pinfo.Select((ParameterInfo pi) => pi.ParameterType).ToArray();
	}

	public static T GetValueSafe<S, T>(this Dictionary<S, T> dictionary, S key)
	{
		if (dictionary.TryGetValue(key, out var value))
		{
			return value;
		}
		return default(T);
	}

	public static T GetTypedValue<T>(this Dictionary<string, object> dictionary, string key)
	{
		if (dictionary.TryGetValue(key, out var value) && value is T)
		{
			return (T)value;
		}
		return default(T);
	}

	public static string ToLiteral(this string input, string quoteChar = "\"")
	{
		StringBuilder stringBuilder = new StringBuilder(input.Length + 2);
		stringBuilder.Append(quoteChar);
		foreach (char c in input)
		{
			switch (c)
			{
			case '\'':
				stringBuilder.Append("\\'");
				continue;
			case '"':
				stringBuilder.Append("\\\"");
				continue;
			case '\\':
				stringBuilder.Append("\\\\");
				continue;
			case '\0':
				stringBuilder.Append("\\0");
				continue;
			case '\a':
				stringBuilder.Append("\\a");
				continue;
			case '\b':
				stringBuilder.Append("\\b");
				continue;
			case '\f':
				stringBuilder.Append("\\f");
				continue;
			case '\n':
				stringBuilder.Append("\\n");
				continue;
			case '\r':
				stringBuilder.Append("\\r");
				continue;
			case '\t':
				stringBuilder.Append("\\t");
				continue;
			case '\v':
				stringBuilder.Append("\\v");
				continue;
			}
			if (c >= ' ' && c <= '~')
			{
				stringBuilder.Append(c);
				continue;
			}
			stringBuilder.Append("\\u");
			int num = c;
			stringBuilder.Append(num.ToString("x4"));
		}
		stringBuilder.Append(quoteChar);
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;

public static class CodeInstructionExtensions
{
	internal static readonly HashSet<OpCode> opcodesCalling = new HashSet<OpCode>
	{
		OpCodes.Call,
		OpCodes.Callvirt
	};

	internal static readonly HashSet<OpCode> opcodesLoadingLocalByAddress = new HashSet<OpCode>
	{
		OpCodes.Ldloca_S,
		OpCodes.Ldloca
	};

	internal static readonly HashSet<OpCode> opcodesLoadingLocalNormal = new HashSet<OpCode>
	{
		OpCodes.Ldloc_0,
		OpCodes.Ldloc_1,
		OpCodes.Ldloc_2,
		OpCodes.Ldloc_3,
		OpCodes.Ldloc_S,
		OpCodes.Ldloc
	};

	internal static readonly HashSet<OpCode> opcodesStoringLocal = new HashSet<OpCode>
	{
		OpCodes.Stloc_0,
		OpCodes.Stloc_1,
		OpCodes.Stloc_2,
		OpCodes.Stloc_3,
		OpCodes.Stloc_S,
		OpCodes.Stloc
	};

	internal static readonly HashSet<OpCode> opcodesLoadingArgumentByAddress = new HashSet<OpCode>
	{
		OpCodes.Ldarga_S,
		OpCodes.Ldarga
	};

	internal static readonly HashSet<OpCode> opcodesLoadingArgumentNormal = new HashSet<OpCode>
	{
		OpCodes.Ldarg_0,
		OpCodes.Ldarg_1,
		OpCodes.Ldarg_2,
		OpCodes.Ldarg_3,
		OpCodes.Ldarg_S,
		OpCodes.Ldarg
	};

	internal static readonly HashSet<OpCode> opcodesStoringArgument = new HashSet<OpCode>
	{
		OpCodes.Starg_S,
		OpCodes.Starg
	};

	internal static readonly HashSet<OpCode> opcodesBranching = new HashSet<OpCode>
	{
		OpCodes.Br_S,
		OpCodes.Brfalse_S,
		OpCodes.Brtrue_S,
		OpCodes.Beq_S,
		OpCodes.Bge_S,
		OpCodes.Bgt_S,
		OpCodes.Ble_S,
		OpCodes.Blt_S,
		OpCodes.Bne_Un_S,
		OpCodes.Bge_Un_S,
		OpCodes.Bgt_Un_S,
		OpCodes.Ble_Un_S,
		OpCodes.Blt_Un_S,
		OpCodes.Br,
		OpCodes.Brfalse,
		OpCodes.Brtrue,
		OpCodes.Beq,
		OpCodes.Bge,
		OpCodes.Bgt,
		OpCodes.Ble,
		OpCodes.Blt,
		OpCodes.Bne_Un,
		OpCodes.Bge_Un,
		OpCodes.Bgt_Un,
		OpCodes.Ble_Un,
		OpCodes.Blt_Un
	};

	private static readonly HashSet<OpCode> constantLoadingCodes = new HashSet<OpCode>
	{
		OpCodes.Ldc_I4_M1,
		OpCodes.Ldc_I4_0,
		OpCodes.Ldc_I4_1,
		OpCodes.Ldc_I4_2,
		OpCodes.Ldc_I4_3,
		OpCodes.Ldc_I4_4,
		OpCodes.Ldc_I4_5,
		OpCodes.Ldc_I4_6,
		OpCodes.Ldc_I4_7,
		OpCodes.Ldc_I4_8,
		OpCodes.Ldc_I4,
		OpCodes.Ldc_I4_S,
		OpCodes.Ldc_I8,
		OpCodes.Ldc_R4,
		OpCodes.Ldc_R8
	};

	public static bool IsValid(this OpCode code)
	{
		return code.Size > 0;
	}

	public static bool OperandIs(this CodeInstruction code, object value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (code.operand == null)
		{
			return false;
		}
		Type type = value.GetType();
		Type type2 = code.operand.GetType();
		if (AccessTools.IsInteger(type) && AccessTools.IsNumber(type2))
		{
			return Convert.ToInt64(code.operand) == Convert.ToInt64(value);
		}
		if (AccessTools.IsFloatingPoint(type) && AccessTools.IsNumber(type2))
		{
			return Convert.ToDouble(code.operand) == Convert.ToDouble(value);
		}
		return object.Equals(code.operand, value);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool OperandIs(this CodeInstruction code, MemberInfo value)
	{
		if ((object)value == null)
		{
			throw new ArgumentNullException("value");
		}
		return object.Equals(code.operand, value);
	}

	public static bool Is(this CodeInstruction code, OpCode opcode, object operand)
	{
		if (code.opcode == opcode)
		{
			return code.OperandIs(operand);
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public static bool Is(this CodeInstruction code, OpCode opcode, MemberInfo operand)
	{
		if (code.opcode == opcode)
		{
			return code.OperandIs(operand);
		}
		return false;
	}

	public static bool IsLdarg(this CodeInstruction code, int? n = null)
	{
		if ((!n.HasValue || n.Value == 0) && code.opcode == OpCodes.Ldarg_0)
		{
			return true;
		}
		if ((!n.HasValue || n.Value == 1) && code.opcode == OpCodes.Ldarg_1)
		{
			return true;
		}
		if ((!n.HasValue || n.Value == 2) && code.opcode == OpCodes.Ldarg_2)
		{
			return true;
		}
		if ((!n.HasValue || n.Value == 3) && code.opcode == OpCodes.Ldarg_3)
		{
			return true;
		}
		if (code.opcode == OpCodes.Ldarg && (!n.HasValue || n.Value == Convert.ToInt32(code.operand)))
		{
			return true;
		}
		if (code.opcode == OpCodes.Ldarg_S && (!n.HasValue || n.Value == Convert.ToInt32(code.operand)))
		{
			return true;
		}
		return false;
	}

	public static bool IsLdarga(this CodeInstruction code, int? n = null)
	{
		if (code.opcode != OpCodes.Ldarga && code.opcode != OpCodes.Ldarga_S)
		{
			return false;
		}
		if (n.HasValue)
		{
			return n.Value == Convert.ToInt32(code.operand);
		}
		return true;
	}

	public static bool IsStarg(this CodeInstruction code, int? n = null)
	{
		if (code.opcode != OpCodes.Starg && code.opcode != OpCodes.Starg_S)
		{
			return false;
		}
		if (n.HasValue)
		{
			return n.Value == Convert.ToInt32(code.operand);
		}
		return true;
	}

	public static bool IsLdloc(this CodeInstruction code, LocalBuilder variable = null)
	{
		if (!opcodesLoadingLocalNormal.Contains(code.opcode) && !opcodesLoadingLocalByAddress.Contains(code.opcode))
		{
			return false;
		}
		if (variable != null)
		{
			return object.Equals(variable, code.operand);
		}
		return true;
	}

	public static bool IsStloc(this CodeInstruction code, LocalBuilder variable = null)
	{
		if (!opcodesStoringLocal.Contains(code.opcode))
		{
			return false;
		}
		if (variable != null)
		{
			return object.Equals(variable, code.operand);
		}
		return true;
	}

	public static bool Branches(this CodeInstruction code, out Label? label)
	{
		if (opcodesBranching.Contains(code.opcode))
		{
			label = (Label)code.operand;
			return true;
		}
		label = null;
		return false;
	}

	public static bool Calls(this CodeInstruction code, MethodInfo method)
	{
		if ((object)method == null)
		{
			throw new ArgumentNullException("method");
		}
		if (code.opcode != OpCodes.Call && code.opcode != OpCodes.Callvirt)
		{
			return false;
		}
		return object.Equals(code.operand, method);
	}

	public static bool LoadsConstant(this CodeInstruction code)
	{
		return constantLoadingCodes.Contains(code.opcode);
	}

	public static bool LoadsConstant(this CodeInstruction code, long number)
	{
		OpCode opcode = code.opcode;
		if (number == -1 && opcode == OpCodes.Ldc_I4_M1)
		{
			return true;
		}
		if (number == 0L && opcode == OpCodes.Ldc_I4_0)
		{
			return true;
		}
		if (number == 1 && opcode == OpCodes.Ldc_I4_1)
		{
			return true;
		}
		if (number == 2 && opcode == OpCodes.Ldc_I4_2)
		{
			return true;
		}
		if (number == 3 && opcode == OpCodes.Ldc_I4_3)
		{
			return true;
		}
		if (number == 4 && opcode == OpCodes.Ldc_I4_4)
		{
			return true;
		}
		if (number == 5 && opcode == OpCodes.Ldc_I4_5)
		{
			return true;
		}
		if (number == 6 && opcode == OpCodes.Ldc_I4_6)
		{
			return true;
		}
		if (number == 7 && opcode == OpCodes.Ldc_I4_7)
		{
			return true;
		}
		if (number == 8 && opcode == OpCodes.Ldc_I4_8)
		{
			return true;
		}
		if (opcode != OpCodes.Ldc_I4 && opcode != OpCodes.Ldc_I4_S && opcode != OpCodes.Ldc_I8)
		{
			return false;
		}
		return Convert.ToInt64(code.operand) == number;
	}

	public static bool LoadsConstant(this CodeInstruction code, double number)
	{
		if (code.opcode != OpCodes.Ldc_R4 && code.opcode != OpCodes.Ldc_R8)
		{
			return false;
		}
		double num = Convert.ToDouble(code.operand);
		return num == number;
	}

	public static bool LoadsConstant(this CodeInstruction code, Enum e)
	{
		return code.LoadsConstant(Convert.ToInt64(e));
	}

	public static bool LoadsConstant(this CodeInstruction code, string str)
	{
		if (code.opcode != OpCodes.Ldstr)
		{
			return false;
		}
		string text = Convert.ToString(code.operand);
		return text == str;
	}

	public static bool LoadsField(this CodeInstruction code, FieldInfo field, bool byAddress = false)
	{
		if ((object)field == null)
		{
			throw new ArgumentNullException("field");
		}
		OpCode opCode = (field.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld);
		if (!byAddress && code.opcode == opCode && object.Equals(code.operand, field))
		{
			return true;
		}
		OpCode opCode2 = (field.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda);
		if (byAddress && code.opcode == opCode2 && object.Equals(code.operand, field))
		{
			return true;
		}
		return false;
	}

	public static bool StoresField(this CodeInstruction code, FieldInfo field)
	{
		if ((object)field == null)
		{
			throw new ArgumentNullException("field");
		}
		OpCode opCode = (field.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld);
		if (code.opcode == opCode)
		{
			return object.Equals(code.operand, field);
		}
		return false;
	}

	public static int LocalIndex(this CodeInstruction code)
	{
		if (code.opcode == OpCodes.Ldloc_0 || code.opcode == OpCodes.Stloc_0)
		{
			return 0;
		}
		if (code.opcode == OpCodes.Ldloc_1 || code.opcode == OpCodes.Stloc_1)
		{
			return 1;
		}
		if (code.opcode == OpCodes.Ldloc_2 || code.opcode == OpCodes.Stloc_2)
		{
			return 2;
		}
		if (code.opcode == OpCodes.Ldloc_3 || code.opcode == OpCodes.Stloc_3)
		{
			return 3;
		}
		if (code.opcode == OpCodes.Ldloc_S || code.opcode == OpCodes.Ldloc)
		{
			return Convert.ToInt32(code.operand);
		}
		if (code.opcode == OpCodes.Stloc_S || code.opcode == OpCodes.Stloc)
		{
			return Convert.ToInt32(code.operand);
		}
		if (code.opcode == OpCodes.Ldloca_S || code.opcode == OpCodes.Ldloca)
		{
			return Convert.ToInt32(code.operand);
		}
		throw new ArgumentException("Instruction is not a load or store", "code");
	}

	public static int ArgumentIndex(this CodeInstruction code)
	{
		if (code.opcode == OpCodes.Ldarg_0)
		{
			return 0;
		}
		if (code.opcode == OpCodes.Ldarg_1)
		{
			return 1;
		}
		if (code.opcode == OpCodes.Ldarg_2)
		{
			return 2;
		}
		if (code.opcode == OpCodes.Ldarg_3)
		{
			return 3;
		}
		if (code.opcode == OpCodes.Ldarg_S || code.opcode == OpCodes.Ldarg)
		{
			return Convert.ToInt32(code.operand);
		}
		if (code.opcode == OpCodes.Starg_S || code.opcode == OpCodes.Starg)
		{
			return Convert.ToInt32(code.operand);
		}
		if (code.opcode == OpCodes.Ldarga_S || code.opcode == OpCodes.Ldarga)
		{
			return Convert.ToInt32(code.operand);
		}
		throw new ArgumentException("Instruction is not a load or store", "code");
	}

	public static CodeInstruction WithLabels(this CodeInstruction code, params Label[] labels)
	{
		code.labels.AddRange(labels);
		return code;
	}

	public static CodeInstruction WithLabels(this CodeInstruction code, IEnumerable<Label> labels)
	{
		code.labels.AddRange(labels);
		return code;
	}

	public static List<Label> ExtractLabels(this CodeInstruction code)
	{
		List<Label> result = new List<Label>(code.labels);
		code.labels.Clear();
		return result;
	}

	public static CodeInstruction MoveLabelsTo(this CodeInstruction code, CodeInstruction other)
	{
		other.WithLabels(code.ExtractLabels());
		return code;
	}

	public static CodeInstruction MoveLabelsFrom(this CodeInstruction code, CodeInstruction other)
	{
		return code.WithLabels(other.ExtractLabels());
	}

	public static CodeInstruction WithBlocks(this CodeInstruction code, params ExceptionBlock[] blocks)
	{
		code.blocks.AddRange(blocks);
		return code;
	}

	public static CodeInstruction WithBlocks(this CodeInstruction code, IEnumerable<ExceptionBlock> blocks)
	{
		code.blocks.AddRange(blocks);
		return code;
	}

	public static List<ExceptionBlock> ExtractBlocks(this CodeInstruction code)
	{
		List<ExceptionBlock> result = new List<ExceptionBlock>(code.blocks);
		code.blocks.Clear();
		return result;
	}

	public static CodeInstruction MoveBlocksTo(this CodeInstruction code, CodeInstruction other)
	{
		other.WithBlocks(code.ExtractBlocks());
		return code;
	}

	public static CodeInstruction MoveBlocksFrom(this CodeInstruction code, CodeInstruction other)
	{
		return code.WithBlocks(other.ExtractBlocks());
	}
}


using System.Collections.Generic;
using HarmonyLib;

public static class CodeInstructionsExtensions
{
	public static bool Matches(this IEnumerable<CodeInstruction> instructions, CodeMatch[] matches)
	{
		return new CodeMatcher(instructions).MatchStartForward(matches).IsValid;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;

public static class CollectionExtensions
{
	public static void Do<T>(this IEnumerable<T> sequence, Action<T> action)
	{
		if (sequence != null)
		{
			IEnumerator<T> enumerator = sequence.GetEnumerator();
			while (enumerator.MoveNext())
			{
				action(enumerator.Current);
			}
		}
	}

	public static void DoIf<T>(this IEnumerable<T> sequence, Func<T, bool> condition, Action<T> action)
	{
		Do(sequence.Where(condition), action);
	}

	public static IEnumerable<T> AddItem<T>(this IEnumerable<T> sequence, T item)
	{
		return (sequence ?? Array.Empty<T>()).Concat(new T[1] { item });
	}

	public static T[] AddToArray<T>(this T[] sequence, T item)
	{
		return AddItem(sequence, item).ToArray();
	}

	public static T[] AddRangeToArray<T>(this T[] sequence, T[] items)
	{
		return (sequence ?? Enumerable.Empty<T>()).Concat(items).ToArray();
	}

	internal static Dictionary<K, V> Merge<K, V>(this IEnumerable<KeyValuePair<K, V>> firstDict, params IEnumerable<KeyValuePair<K, V>>[] otherDicts)
	{
		Dictionary<K, V> dictionary = new Dictionary<K, V>();
		foreach (KeyValuePair<K, V> item in firstDict)
		{
			dictionary[item.Key] = item.Value;
		}
		foreach (IEnumerable<KeyValuePair<K, V>> enumerable in otherDicts)
		{
			foreach (KeyValuePair<K, V> item2 in enumerable)
			{
				dictionary[item2.Key] = item2.Value;
			}
		}
		return dictionary;
	}

	internal static Dictionary<K, V> TransformKeys<K, V>(this Dictionary<K, V> origDict, Func<K, K> transform)
	{
		Dictionary<K, V> dictionary = new Dictionary<K, V>();
		foreach (KeyValuePair<K, V> item in origDict)
		{
			dictionary.Add(transform(item.Key), item.Value);
		}
		return dictionary;
	}
}


using System.Reflection;

public static class MethodBaseExtensions
{
	public static bool HasMethodBody(this MethodBase member)
	{
		return (member.GetMethodBody()?.GetILAsByteArray()?.Length).GetValueOrDefault() > 0;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using HarmonyLib;

public static class FileLog
{
	private static readonly object fileLock = new object();

	private static bool _logPathInited;

	private static string _logPath;

	public static char indentChar = '\t';

	public static int indentLevel = 0;

	private static List<string> buffer = new List<string>();

	public static StreamWriter LogWriter { get; set; }

	public static string LogPath
	{
		get
		{
			lock (fileLock)
			{
				if (!_logPathInited)
				{
					_logPathInited = true;
					string environmentVariable = Environment.GetEnvironmentVariable("HARMONY_NO_LOG");
					if (!string.IsNullOrEmpty(environmentVariable))
					{
						return null;
					}
					_logPath = Environment.GetEnvironmentVariable("HARMONY_LOG_FILE");
					if (string.IsNullOrEmpty(_logPath))
					{
						string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
						Directory.CreateDirectory(folderPath);
						_logPath = Path.Combine(folderPath, "harmony.log.txt");
					}
				}
				return _logPath;
			}
		}
	}

	private static string IndentString()
	{
		return new string(indentChar, indentLevel);
	}

	public static void ChangeIndent(int delta)
	{
		lock (fileLock)
		{
			indentLevel = Math.Max(0, indentLevel + delta);
		}
	}

	public static void LogBuffered(string str)
	{
		lock (fileLock)
		{
			buffer.Add(IndentString() + str);
		}
	}

	public static void LogBuffered(List<string> strings)
	{
		lock (fileLock)
		{
			buffer.AddRange(strings);
		}
	}

	public static List<string> GetBuffer(bool clear)
	{
		lock (fileLock)
		{
			List<string> result = buffer;
			if (clear)
			{
				buffer = new List<string>();
			}
			return result;
		}
	}

	public static void SetBuffer(List<string> buffer)
	{
		lock (fileLock)
		{
			FileLog.buffer = buffer;
		}
	}

	public static void FlushBuffer()
	{
		if (LogWriter != null)
		{
			foreach (string item in buffer)
			{
				LogWriter.WriteLine(item);
			}
			buffer.Clear();
		}
		else
		{
			if (LogPath == null)
			{
				return;
			}
			lock (fileLock)
			{
				if (buffer.Count <= 0)
				{
					return;
				}
				using StreamWriter streamWriter = File.AppendText(LogPath);
				foreach (string item2 in buffer)
				{
					streamWriter.WriteLine(item2);
				}
				buffer.Clear();
			}
		}
	}

	public static void Log(string str)
	{
		if (LogWriter != null)
		{
			LogWriter.WriteLine(IndentString() + str);
		}
		else
		{
			if (LogPath == null)
			{
				return;
			}
			lock (fileLock)
			{
				using StreamWriter streamWriter = File.AppendText(LogPath);
				streamWriter.WriteLine(IndentString() + str);
			}
		}
	}

	public static void Debug(string str)
	{
		if (Harmony.DEBUG)
		{
			Log(str);
		}
	}

	public static void Reset()
	{
		lock (fileLock)
		{
			string path = $"{Environment.GetFolderPath(Environment.SpecialFolder.Desktop)}{Path.DirectorySeparatorChar}harmony.log.txt";
			File.Delete(path);
		}
	}

	public unsafe static void LogBytes(long ptr, int len)
	{
		lock (fileLock)
		{
			byte* ptr2 = (byte*)ptr;
			string text = "";
			for (int i = 1; i <= len; i++)
			{
				if (text.Length == 0)
				{
					text = "#  ";
				}
				text += $"{*ptr2:X2} ";
				if (i > 1 || len == 1)
				{
					if (i % 8 == 0 || i == len)
					{
						Log(text);
						text = "";
					}
					else if (i % 4 == 0)
					{
						text += " ";
					}
				}
				ptr2++;
			}
			byte[] destination = new byte[len];
			Marshal.Copy((IntPtr)ptr, destination, 0, len);
			MD5 mD = MD5.Create();
			byte[] array = mD.ComputeHash(destination);
			StringBuilder stringBuilder = new StringBuilder();
			for (int j = 0; j < array.Length; j++)
			{
				stringBuilder.Append(array[j].ToString("X2"));
			}
			Log($"HASH: {stringBuilder}");
		}
	}
}


using System;
using System.Linq.Expressions;
using System.Reflection;

public static class SymbolExtensions
{
	public static MethodInfo GetMethodInfo(Expression<Action> expression)
	{
		return GetMethodInfo((LambdaExpression)expression);
	}

	public static MethodInfo GetMethodInfo<T>(Expression<Action<T>> expression)
	{
		return GetMethodInfo((LambdaExpression)expression);
	}

	public static MethodInfo GetMethodInfo<T, TResult>(Expression<Func<T, TResult>> expression)
	{
		return GetMethodInfo((LambdaExpression)expression);
	}

	public static MethodInfo GetMethodInfo(LambdaExpression expression)
	{
		if (!(expression.Body is MethodCallExpression methodCallExpression))
		{
			if (expression.Body is UnaryExpression { Operand: MethodCallExpression { Object: ConstantExpression { Value: MethodInfo value } } })
			{
				return value;
			}
			throw new ArgumentException("Invalid Expression. Expression should consist of a Method call only.");
		}
		MethodInfo method = methodCallExpression.Method;
		if ((object)method == null)
		{
			throw new Exception($"Cannot find method for expression {expression}");
		}
		return method;
	}
}


using System;
using System.Reflection;
using System.Reflection.Emit;
using HarmonyLib;
using MonoMod.Utils;

internal class Tools
{
	internal struct TypeAndName
	{
		internal Type type;

		internal string name;
	}

	internal static readonly bool isWindows = Environment.OSVersion.Platform.Equals(PlatformID.Win32NT);

	internal static TypeAndName TypColonName(string typeColonName)
	{
		if (typeColonName == null)
		{
			throw new ArgumentNullException("typeColonName");
		}
		string[] array = typeColonName.Split(new char[1] { ':' });
		if (array.Length != 2)
		{
			throw new ArgumentException(" must be specified as 'Namespace.Type1.Type2:MemberName", "typeColonName");
		}
		TypeAndName result = default(TypeAndName);
		result.type = AccessTools.TypeByName(array[0]);
		result.name = array[1];
		return result;
	}

	internal static void ValidateFieldType<F>(FieldInfo fieldInfo)
	{
		Type typeFromHandle = typeof(F);
		Type fieldType = fieldInfo.FieldType;
		if (typeFromHandle == fieldType)
		{
			return;
		}
		if (fieldType.IsEnum)
		{
			Type underlyingType = Enum.GetUnderlyingType(fieldType);
			if (typeFromHandle != underlyingType)
			{
				throw new ArgumentException("FieldRefAccess return type must be the same as FieldType or " + $"FieldType's underlying integral type ({underlyingType}) for enum types");
			}
		}
		else
		{
			if (fieldType.IsValueType)
			{
				throw new ArgumentException("FieldRefAccess return type must be the same as FieldType for value types");
			}
			if (!typeFromHandle.IsAssignableFrom(fieldType))
			{
				throw new ArgumentException("FieldRefAccess return type must be assignable from FieldType for reference types");
			}
		}
	}

	internal static AccessTools.FieldRef<T, F> FieldRefAccess<T, F>(FieldInfo fieldInfo, bool needCastclass)
	{
		ValidateFieldType<F>(fieldInfo);
		Type typeFromHandle = typeof(T);
		Type declaringType = fieldInfo.DeclaringType;
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("__refget_" + typeFromHandle.Name + "_fi_" + fieldInfo.Name, typeof(F).MakeByRefType(), new Type[1] { typeFromHandle });
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		if (fieldInfo.IsStatic)
		{
			iLGenerator.Emit(OpCodes.Ldsflda, fieldInfo);
		}
		else
		{
			iLGenerator.Emit(OpCodes.Ldarg_0);
			if (needCastclass)
			{
				iLGenerator.Emit(OpCodes.Castclass, declaringType);
			}
			iLGenerator.Emit(OpCodes.Ldflda, fieldInfo);
		}
		iLGenerator.Emit(OpCodes.Ret);
		return (AccessTools.FieldRef<T, F>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(AccessTools.FieldRef<T, F>));
	}

	internal static AccessTools.StructFieldRef<T, F> StructFieldRefAccess<T, F>(FieldInfo fieldInfo) where T : struct
	{
		ValidateFieldType<F>(fieldInfo);
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("__refget_" + typeof(T).Name + "_struct_fi_" + fieldInfo.Name, typeof(F).MakeByRefType(), new Type[1] { typeof(T).MakeByRefType() });
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldflda, fieldInfo);
		iLGenerator.Emit(OpCodes.Ret);
		return (AccessTools.StructFieldRef<T, F>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(AccessTools.StructFieldRef<T, F>));
	}

	internal static AccessTools.FieldRef<F> StaticFieldRefAccess<F>(FieldInfo fieldInfo)
	{
		if (!fieldInfo.IsStatic)
		{
			throw new ArgumentException("Field must be static");
		}
		ValidateFieldType<F>(fieldInfo);
		DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("__refget_" + (fieldInfo.DeclaringType?.Name ?? "null") + "_static_fi_" + fieldInfo.Name, typeof(F).MakeByRefType(), Array.Empty<Type>());
		ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldsflda, fieldInfo);
		iLGenerator.Emit(OpCodes.Ret);
		return (AccessTools.FieldRef<F>)dynamicMethodDefinition.Generate().CreateDelegate(typeof(AccessTools.FieldRef<F>));
	}

	internal static FieldInfo GetInstanceField(Type type, string fieldName)
	{
		FieldInfo fieldInfo = AccessTools.Field(type, fieldName);
		if ((object)fieldInfo == null)
		{
			throw new MissingFieldException(type.Name, fieldName);
		}
		if (fieldInfo.IsStatic)
		{
			throw new ArgumentException("Field must not be static");
		}
		return fieldInfo;
	}

	internal static bool FieldRefNeedsClasscast(Type delegateInstanceType, Type declaringType)
	{
		bool flag = false;
		if (delegateInstanceType != declaringType)
		{
			flag = delegateInstanceType.IsAssignableFrom(declaringType);
			if (!flag && !declaringType.IsAssignableFrom(delegateInstanceType))
			{
				throw new ArgumentException("FieldDeclaringType must be assignable from or to T (FieldRefAccess instance type) - \"instanceOfT is FieldDeclaringType\" must be possible");
			}
		}
		return flag;
	}

	internal static void ValidateStructField<T, F>(FieldInfo fieldInfo) where T : struct
	{
		if (fieldInfo.IsStatic)
		{
			throw new ArgumentException("Field must not be static");
		}
		if (fieldInfo.DeclaringType != typeof(T))
		{
			throw new ArgumentException("FieldDeclaringType must be T (StructFieldRefAccess instance type)");
		}
	}
}


using System;

internal struct TypeAndName
{
	internal Type type;

	internal string name;
}


using HarmonyLib;

public class Traverse<T>
{
	private readonly Traverse traverse;

	public T Value
	{
		get
		{
			return traverse.GetValue<T>();
		}
		set
		{
			traverse.SetValue(value);
		}
	}

	private Traverse()
	{
	}

	public Traverse(Traverse traverse)
	{
		this.traverse = traverse;
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using HarmonyLib;

public class Traverse
{
	private static readonly AccessCache Cache;

	private readonly Type _type;

	private readonly object _root;

	private readonly MemberInfo _info;

	private readonly MethodBase _method;

	private readonly object[] _params;

	public static Action<Traverse, Traverse> CopyFields;

	[MethodImpl(MethodImplOptions.Synchronized)]
	static Traverse()
	{
		CopyFields = delegate(Traverse from, Traverse to)
		{
			to.SetValue(from.GetValue());
		};
		if (Cache == null)
		{
			Cache = new AccessCache();
		}
	}

	public static Traverse Create(Type type)
	{
		return new Traverse(type);
	}

	public static Traverse Create<T>()
	{
		return Create(typeof(T));
	}

	public static Traverse Create(object root)
	{
		return new Traverse(root);
	}

	public static Traverse CreateWithType(string name)
	{
		return new Traverse(AccessTools.TypeByName(name));
	}

	private Traverse()
	{
	}

	public Traverse(Type type)
	{
		_type = type;
	}

	public Traverse(object root)
	{
		_root = root;
		_type = root?.GetType();
	}

	private Traverse(object root, MemberInfo info, object[] index)
	{
		_root = root;
		_type = root?.GetType() ?? info.GetUnderlyingType();
		_info = info;
		_params = index;
	}

	private Traverse(object root, MethodInfo method, object[] parameter)
	{
		_root = root;
		_type = method.ReturnType;
		_method = method;
		_params = parameter;
	}

	public object GetValue()
	{
		if (_info is FieldInfo)
		{
			return ((FieldInfo)_info).GetValue(_root);
		}
		if (_info is PropertyInfo)
		{
			return ((PropertyInfo)_info).GetValue(_root, AccessTools.all, null, _params, CultureInfo.CurrentCulture);
		}
		if ((object)_method != null)
		{
			return _method.Invoke(_root, _params);
		}
		if (_root == null && (object)_type != null)
		{
			return _type;
		}
		return _root;
	}

	public T GetValue<T>()
	{
		object value = GetValue();
		if (value == null)
		{
			return default(T);
		}
		return (T)value;
	}

	public object GetValue(params object[] arguments)
	{
		if ((object)_method == null)
		{
			throw new Exception("cannot get method value without method");
		}
		return _method.Invoke(_root, arguments);
	}

	public T GetValue<T>(params object[] arguments)
	{
		if ((object)_method == null)
		{
			throw new Exception("cannot get method value without method");
		}
		return (T)_method.Invoke(_root, arguments);
	}

	public Traverse SetValue(object value)
	{
		if (_info is FieldInfo)
		{
			((FieldInfo)_info).SetValue(_root, value, AccessTools.all, null, CultureInfo.CurrentCulture);
		}
		if (_info is PropertyInfo)
		{
			((PropertyInfo)_info).SetValue(_root, value, AccessTools.all, null, _params, CultureInfo.CurrentCulture);
		}
		if ((object)_method != null)
		{
			throw new Exception("cannot set value of method " + _method.FullDescription());
		}
		return this;
	}

	public Type GetValueType()
	{
		if (_info is FieldInfo)
		{
			return ((FieldInfo)_info).FieldType;
		}
		if (_info is PropertyInfo)
		{
			return ((PropertyInfo)_info).PropertyType;
		}
		return null;
	}

	private Traverse Resolve()
	{
		if (_root == null)
		{
			if (_info is FieldInfo { IsStatic: not false })
			{
				return new Traverse(GetValue());
			}
			if (_info is PropertyInfo propertyInfo && propertyInfo.GetGetMethod().IsStatic)
			{
				return new Traverse(GetValue());
			}
			if ((object)_method != null && _method.IsStatic)
			{
				return new Traverse(GetValue());
			}
			if ((object)_type != null)
			{
				return this;
			}
		}
		return new Traverse(GetValue());
	}

	public Traverse Type(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if ((object)_type == null)
		{
			return new Traverse();
		}
		Type type = AccessTools.Inner(_type, name);
		if ((object)type == null)
		{
			return new Traverse();
		}
		return new Traverse(type);
	}

	public Traverse Field(string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		Traverse traverse = Resolve();
		if ((object)traverse._type == null)
		{
			return new Traverse();
		}
		FieldInfo fieldInfo = Cache.GetFieldInfo(traverse._type, name);
		if ((object)fieldInfo == null)
		{
			return new Traverse();
		}
		if (!fieldInfo.IsStatic && traverse._root == null)
		{
			return new Traverse();
		}
		return new Traverse(traverse._root, fieldInfo, null);
	}

	public Traverse<T> Field<T>(string name)
	{
		return new Traverse<T>(Field(name));
	}

	public List<string> Fields()
	{
		Traverse traverse = Resolve();
		return AccessTools.GetFieldNames(traverse._type);
	}

	public Traverse Property(string name, object[] index = null)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		Traverse traverse = Resolve();
		if ((object)traverse._type == null)
		{
			return new Traverse();
		}
		PropertyInfo propertyInfo = Cache.GetPropertyInfo(traverse._type, name);
		if ((object)propertyInfo == null)
		{
			return new Traverse();
		}
		return new Traverse(traverse._root, propertyInfo, index);
	}

	public Traverse<T> Property<T>(string name, object[] index = null)
	{
		return new Traverse<T>(Property(name, index));
	}

	public List<string> Properties()
	{
		Traverse traverse = Resolve();
		return AccessTools.GetPropertyNames(traverse._type);
	}

	public Traverse Method(string name, params object[] arguments)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		Traverse traverse = Resolve();
		if ((object)traverse._type == null)
		{
			return new Traverse();
		}
		Type[] types = AccessTools.GetTypes(arguments);
		MethodBase methodInfo = Cache.GetMethodInfo(traverse._type, name, types);
		if ((object)methodInfo == null)
		{
			return new Traverse();
		}
		return new Traverse(traverse._root, (MethodInfo)methodInfo, arguments);
	}

	public Traverse Method(string name, Type[] paramTypes, object[] arguments = null)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		Traverse traverse = Resolve();
		if ((object)traverse._type == null)
		{
			return new Traverse();
		}
		MethodBase methodInfo = Cache.GetMethodInfo(traverse._type, name, paramTypes);
		if ((object)methodInfo == null)
		{
			return new Traverse();
		}
		return new Traverse(traverse._root, (MethodInfo)methodInfo, arguments);
	}

	public List<string> Methods()
	{
		Traverse traverse = Resolve();
		return AccessTools.GetMethodNames(traverse._type);
	}

	public bool FieldExists()
	{
		if ((object)_info != null)
		{
			return _info is FieldInfo;
		}
		return false;
	}

	public bool PropertyExists()
	{
		if ((object)_info != null)
		{
			return _info is PropertyInfo;
		}
		return false;
	}

	public bool MethodExists()
	{
		return (object)_method != null;
	}

	public bool TypeExists()
	{
		return (object)_type != null;
	}

	public static void IterateFields(object source, Action<Traverse> action)
	{
		Traverse sourceTrv = Create(source);
		AccessTools.GetFieldNames(source).ForEach(delegate(string f)
		{
			action(sourceTrv.Field(f));
		});
	}

	public static void IterateFields(object source, object target, Action<Traverse, Traverse> action)
	{
		Traverse sourceTrv = Create(source);
		Traverse targetTrv = Create(target);
		AccessTools.GetFieldNames(source).ForEach(delegate(string f)
		{
			action(sourceTrv.Field(f), targetTrv.Field(f));
		});
	}

	public static void IterateFields(object source, object target, Action<string, Traverse, Traverse> action)
	{
		Traverse sourceTrv = Create(source);
		Traverse targetTrv = Create(target);
		AccessTools.GetFieldNames(source).ForEach(delegate(string f)
		{
			action(f, sourceTrv.Field(f), targetTrv.Field(f));
		});
	}

	public static void IterateProperties(object source, Action<Traverse> action)
	{
		Traverse sourceTrv = Create(source);
		AccessTools.GetPropertyNames(source).ForEach(delegate(string f)
		{
			action(sourceTrv.Property(f));
		});
	}

	public static void IterateProperties(object source, object target, Action<Traverse, Traverse> action)
	{
		Traverse sourceTrv = Create(source);
		Traverse targetTrv = Create(target);
		AccessTools.GetPropertyNames(source).ForEach(delegate(string f)
		{
			action(sourceTrv.Property(f), targetTrv.Property(f));
		});
	}

	public static void IterateProperties(object source, object target, Action<string, Traverse, Traverse> action)
	{
		Traverse sourceTrv = Create(source);
		Traverse targetTrv = Create(target);
		AccessTools.GetPropertyNames(source).ForEach(delegate(string f)
		{
			action(f, sourceTrv.Property(f), targetTrv.Property(f));
		});
	}

	public override string ToString()
	{
		return (_method ?? GetValue())?.ToString();
	}
}


internal static class Consts
{
	public const string AssemblyName = "Mono.Cecil";

	public const string PublicKey = "00240000048000009400000006020000002400005253413100040000010001002b5c9f7f04346c324a3176f8d3ee823bbf2d60efdbc35f86fd9e65ea3e6cd11bcdcba3a353e55133c8ac5c4caaba581b2c6dfff2cc2d0edc43959ddb86b973300a479a82419ef489c3225f1fe429a708507bd515835160e10bc743d20ca33ab9570cfd68d479fcf0bc797a763bec5d1000f0159ef619e709d915975e87beebaf";
}


using System;
using Mono;

internal static class Disposable
{
	public static Disposable<T> Owned<T>(T value) where T : class, IDisposable
	{
		return new Disposable<T>(value, owned: true);
	}

	public static Disposable<T> NotOwned<T>(T value) where T : class, IDisposable
	{
		return new Disposable<T>(value, owned: false);
	}
}


using System;

internal struct Disposable<T> : IDisposable where T : class, IDisposable
{
	internal readonly T value;

	private readonly bool owned;

	public Disposable(T value, bool owned)
	{
		this.value = value;
		this.owned = owned;
	}

	public void Dispose()
	{
		if (value != null && owned)
		{
			value.Dispose();
		}
	}
}


internal static class Empty<T>
{
	public static readonly T[] Array = new T[0];
}


using System;

internal class ArgumentNullOrEmptyException : ArgumentException
{
	public ArgumentNullOrEmptyException(string paramName)
		: base("Argument null or empty", paramName)
	{
	}
}


using System;
using System.Collections.Generic;
using Mono;

internal class MergeSort<T>
{
	private readonly T[] elements;

	private readonly T[] buffer;

	private readonly IComparer<T> comparer;

	private MergeSort(T[] elements, IComparer<T> comparer)
	{
		this.elements = elements;
		buffer = new T[elements.Length];
		Array.Copy(this.elements, buffer, elements.Length);
		this.comparer = comparer;
	}

	public static void Sort(T[] source, IComparer<T> comparer)
	{
		Sort(source, 0, source.Length, comparer);
	}

	public static void Sort(T[] source, int start, int length, IComparer<T> comparer)
	{
		new MergeSort<T>(source, comparer).Sort(start, length);
	}

	private void Sort(int start, int length)
	{
		TopDownSplitMerge(buffer, elements, start, length);
	}

	private void TopDownSplitMerge(T[] a, T[] b, int start, int end)
	{
		if (end - start >= 2)
		{
			int num = (end + start) / 2;
			TopDownSplitMerge(b, a, start, num);
			TopDownSplitMerge(b, a, num, end);
			TopDownMerge(a, b, start, num, end);
		}
	}

	private void TopDownMerge(T[] a, T[] b, int start, int middle, int end)
	{
		int num = start;
		int num2 = middle;
		for (int i = start; i < end; i++)
		{
			if (num < middle && (num2 >= end || comparer.Compare(a[num], a[num2]) <= 0))
			{
				b[i] = a[num++];
			}
			else
			{
				b[i] = a[num2++];
			}
		}
	}
}


using System;
using System.Security.Cryptography;

internal static class CryptoConvert
{
	private static int ToInt32LE(byte[] bytes, int offset)
	{
		return (bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset];
	}

	private static uint ToUInt32LE(byte[] bytes, int offset)
	{
		return (uint)((bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset]);
	}

	private static byte[] GetBytesLE(int val)
	{
		return new byte[4]
		{
			(byte)(val & 0xFF),
			(byte)((val >> 8) & 0xFF),
			(byte)((val >> 16) & 0xFF),
			(byte)((val >> 24) & 0xFF)
		};
	}

	private static byte[] Trim(byte[] array)
	{
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != 0)
			{
				byte[] array2 = new byte[array.Length - i];
				Buffer.BlockCopy(array, i, array2, 0, array2.Length);
				return array2;
			}
		}
		return null;
	}

	private static RSA FromCapiPrivateKeyBlob(byte[] blob, int offset)
	{
		RSAParameters parameters = default(RSAParameters);
		try
		{
			if (blob[offset] != 7 || blob[offset + 1] != 2 || blob[offset + 2] != 0 || blob[offset + 3] != 0 || ToUInt32LE(blob, offset + 8) != 843141970)
			{
				throw new CryptographicException("Invalid blob header");
			}
			int num = ToInt32LE(blob, offset + 12);
			byte[] array = new byte[4];
			Buffer.BlockCopy(blob, offset + 16, array, 0, 4);
			Array.Reverse((Array)array);
			parameters.Exponent = Trim(array);
			int num2 = offset + 20;
			int num3 = num >> 3;
			parameters.Modulus = new byte[num3];
			Buffer.BlockCopy(blob, num2, parameters.Modulus, 0, num3);
			Array.Reverse((Array)parameters.Modulus);
			num2 += num3;
			int num4 = num3 >> 1;
			parameters.P = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.P, 0, num4);
			Array.Reverse((Array)parameters.P);
			num2 += num4;
			parameters.Q = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.Q, 0, num4);
			Array.Reverse((Array)parameters.Q);
			num2 += num4;
			parameters.DP = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.DP, 0, num4);
			Array.Reverse((Array)parameters.DP);
			num2 += num4;
			parameters.DQ = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.DQ, 0, num4);
			Array.Reverse((Array)parameters.DQ);
			num2 += num4;
			parameters.InverseQ = new byte[num4];
			Buffer.BlockCopy(blob, num2, parameters.InverseQ, 0, num4);
			Array.Reverse((Array)parameters.InverseQ);
			num2 += num4;
			parameters.D = new byte[num3];
			if (num2 + num3 + offset <= blob.Length)
			{
				Buffer.BlockCopy(blob, num2, parameters.D, 0, num3);
				Array.Reverse((Array)parameters.D);
			}
		}
		catch (Exception inner)
		{
			throw new CryptographicException("Invalid blob.", inner);
		}
		RSA rSA = null;
		try
		{
			rSA = RSA.Create();
			rSA.ImportParameters(parameters);
		}
		catch (CryptographicException)
		{
			bool flag = false;
			try
			{
				rSA = new RSACryptoServiceProvider(new CspParameters
				{
					Flags = CspProviderFlags.UseMachineKeyStore
				});
				rSA.ImportParameters(parameters);
			}
			catch
			{
				flag = true;
			}
			if (flag)
			{
				throw;
			}
		}
		return rSA;
	}

	private static RSA FromCapiPublicKeyBlob(byte[] blob, int offset)
	{
		try
		{
			if (blob[offset] != 6 || blob[offset + 1] != 2 || blob[offset + 2] != 0 || blob[offset + 3] != 0 || ToUInt32LE(blob, offset + 8) != 826364754)
			{
				throw new CryptographicException("Invalid blob header");
			}
			int num = ToInt32LE(blob, offset + 12);
			RSAParameters parameters = new RSAParameters
			{
				Exponent = new byte[3]
			};
			parameters.Exponent[0] = blob[offset + 18];
			parameters.Exponent[1] = blob[offset + 17];
			parameters.Exponent[2] = blob[offset + 16];
			int srcOffset = offset + 20;
			int num2 = num >> 3;
			parameters.Modulus = new byte[num2];
			Buffer.BlockCopy(blob, srcOffset, parameters.Modulus, 0, num2);
			Array.Reverse((Array)parameters.Modulus);
			RSA rSA = null;
			try
			{
				rSA = RSA.Create();
				rSA.ImportParameters(parameters);
			}
			catch (CryptographicException)
			{
				rSA = new RSACryptoServiceProvider(new CspParameters
				{
					Flags = CspProviderFlags.UseMachineKeyStore
				});
				rSA.ImportParameters(parameters);
			}
			return rSA;
		}
		catch (Exception inner)
		{
			throw new CryptographicException("Invalid blob.", inner);
		}
	}

	public static RSA FromCapiKeyBlob(byte[] blob)
	{
		return FromCapiKeyBlob(blob, 0);
	}

	public static RSA FromCapiKeyBlob(byte[] blob, int offset)
	{
		if (blob == null)
		{
			throw new ArgumentNullException("blob");
		}
		if (offset >= blob.Length)
		{
			throw new ArgumentException("blob is too small.");
		}
		switch (blob[offset])
		{
		case 0:
			if (blob[offset + 12] == 6)
			{
				return FromCapiPublicKeyBlob(blob, offset + 12);
			}
			break;
		case 6:
			return FromCapiPublicKeyBlob(blob, offset);
		case 7:
			return FromCapiPrivateKeyBlob(blob, offset);
		}
		throw new CryptographicException("Unknown blob format.");
	}

	public static byte[] ToCapiPublicKeyBlob(RSA rsa)
	{
		RSAParameters rSAParameters = rsa.ExportParameters(includePrivateParameters: false);
		int num = rSAParameters.Modulus.Length;
		byte[] array = new byte[20 + num];
		array[0] = 6;
		array[1] = 2;
		array[5] = 36;
		array[8] = 82;
		array[9] = 83;
		array[10] = 65;
		array[11] = 49;
		byte[] bytesLE = GetBytesLE(num << 3);
		array[12] = bytesLE[0];
		array[13] = bytesLE[1];
		array[14] = bytesLE[2];
		array[15] = bytesLE[3];
		int num2 = 16;
		int num3 = rSAParameters.Exponent.Length;
		while (num3 > 0)
		{
			array[num2++] = rSAParameters.Exponent[--num3];
		}
		num2 = 20;
		byte[]? modulus = rSAParameters.Modulus;
		int num4 = modulus.Length;
		Array.Reverse((Array)modulus, 0, num4);
		Buffer.BlockCopy(modulus, 0, array, num2, num4);
		num2 += num4;
		return array;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Mono;
using Mono.Cecil;
using Mono.Collections.Generic;

internal class Collection<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
{
	public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
	{
		private Collection<T> collection;

		private T current;

		private int next;

		private readonly int version;

		public T Current => current;

		object IEnumerator.Current
		{
			get
			{
				CheckState();
				if (next <= 0)
				{
					throw new InvalidOperationException();
				}
				return current;
			}
		}

		internal Enumerator(Collection<T> collection)
		{
			this = default(Enumerator);
			this.collection = collection;
			version = collection.version;
		}

		public bool MoveNext()
		{
			CheckState();
			if (next < 0)
			{
				return false;
			}
			if (next < collection.size)
			{
				current = collection.items[next++];
				return true;
			}
			next = -1;
			return false;
		}

		public void Reset()
		{
			CheckState();
			next = 0;
		}

		private void CheckState()
		{
			if (collection == null)
			{
				throw new ObjectDisposedException(GetType().FullName);
			}
			if (version != collection.version)
			{
				throw new InvalidOperationException();
			}
		}

		public void Dispose()
		{
			collection = null;
		}
	}

	internal T[] items;

	internal int size;

	private int version;

	public int Count => size;

	public T this[int index]
	{
		get
		{
			if (index >= size)
			{
				throw new ArgumentOutOfRangeException();
			}
			return items[index];
		}
		set
		{
			CheckIndex(index);
			if (index == size)
			{
				throw new ArgumentOutOfRangeException();
			}
			OnSet(value, index);
			items[index] = value;
		}
	}

	public int Capacity
	{
		get
		{
			return items.Length;
		}
		set
		{
			if (value < 0 || value < size)
			{
				throw new ArgumentOutOfRangeException();
			}
			Resize(value);
		}
	}

	bool ICollection<T>.IsReadOnly => false;

	bool IList.IsFixedSize => false;

	bool IList.IsReadOnly => false;

	object IList.this[int index]
	{
		get
		{
			return this[index];
		}
		set
		{
			CheckIndex(index);
			try
			{
				this[index] = (T)value;
				return;
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
			throw new ArgumentException();
		}
	}

	int ICollection.Count => Count;

	bool ICollection.IsSynchronized => false;

	object ICollection.SyncRoot => this;

	public Collection()
	{
		items = Empty<T>.Array;
	}

	public Collection(int capacity)
	{
		if (capacity < 0)
		{
			throw new ArgumentOutOfRangeException();
		}
		items = ((capacity == 0) ? Empty<T>.Array : new T[capacity]);
	}

	public Collection(ICollection<T> items)
	{
		if (items == null)
		{
			throw new ArgumentNullException("items");
		}
		this.items = new T[items.Count];
		items.CopyTo(this.items, 0);
		size = this.items.Length;
	}

	public void Add(T item)
	{
		if (size == items.Length)
		{
			Grow(1);
		}
		OnAdd(item, size);
		items[size++] = item;
		version++;
	}

	public bool Contains(T item)
	{
		return IndexOf(item) != -1;
	}

	public int IndexOf(T item)
	{
		return Array.IndexOf(items, item, 0, size);
	}

	public void Insert(int index, T item)
	{
		CheckIndex(index);
		if (size == items.Length)
		{
			Grow(1);
		}
		OnInsert(item, index);
		Shift(index, 1);
		items[index] = item;
		version++;
	}

	public void RemoveAt(int index)
	{
		if (index < 0 || index >= size)
		{
			throw new ArgumentOutOfRangeException();
		}
		T item = items[index];
		OnRemove(item, index);
		Shift(index, -1);
		version++;
	}

	public bool Remove(T item)
	{
		int num = IndexOf(item);
		if (num == -1)
		{
			return false;
		}
		OnRemove(item, num);
		Shift(num, -1);
		version++;
		return true;
	}

	public void Clear()
	{
		OnClear();
		Array.Clear(items, 0, size);
		size = 0;
		version++;
	}

	public void CopyTo(T[] array, int arrayIndex)
	{
		Array.Copy(items, 0, array, arrayIndex, size);
	}

	public T[] ToArray()
	{
		T[] array = new T[size];
		Array.Copy(items, 0, array, 0, size);
		return array;
	}

	private void CheckIndex(int index)
	{
		if (index < 0 || index > size)
		{
			throw new ArgumentOutOfRangeException();
		}
	}

	private void Shift(int start, int delta)
	{
		if (delta < 0)
		{
			start -= delta;
		}
		if (start < size)
		{
			Array.Copy(items, start, items, start + delta, size - start);
		}
		size += delta;
		if (delta < 0)
		{
			Array.Clear(items, size, -delta);
		}
	}

	protected virtual void OnAdd(T item, int index)
	{
	}

	protected virtual void OnInsert(T item, int index)
	{
	}

	protected virtual void OnSet(T item, int index)
	{
	}

	protected virtual void OnRemove(T item, int index)
	{
	}

	protected virtual void OnClear()
	{
	}

	internal virtual void Grow(int desired)
	{
		int num = size + desired;
		if (num > items.Length)
		{
			num = Math.Max(Math.Max(items.Length * 2, 4), num);
			Resize(num);
		}
	}

	protected void Resize(int new_size)
	{
		if (new_size != size)
		{
			if (new_size < size)
			{
				throw new ArgumentOutOfRangeException();
			}
			items = items.Resize(new_size);
		}
	}

	int IList.Add(object value)
	{
		try
		{
			Add((T)value);
			return size - 1;
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
		throw new ArgumentException();
	}

	void IList.Clear()
	{
		Clear();
	}

	bool IList.Contains(object value)
	{
		return ((IList)this).IndexOf(value) > -1;
	}

	int IList.IndexOf(object value)
	{
		try
		{
			return IndexOf((T)value);
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
		return -1;
	}

	void IList.Insert(int index, object value)
	{
		CheckIndex(index);
		try
		{
			Insert(index, (T)value);
			return;
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
		throw new ArgumentException();
	}

	void IList.Remove(object value)
	{
		try
		{
			Remove((T)value);
		}
		catch (InvalidCastException)
		{
		}
		catch (NullReferenceException)
		{
		}
	}

	void IList.RemoveAt(int index)
	{
		RemoveAt(index);
	}

	void ICollection.CopyTo(Array array, int index)
	{
		Array.Copy(items, 0, array, index, size);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		return new Enumerator(this);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
{
	private Collection<T> collection;

	private T current;

	private int next;

	private readonly int version;

	public T Current => current;

	object IEnumerator.Current
	{
		get
		{
			CheckState();
			if (next <= 0)
			{
				throw new InvalidOperationException();
			}
			return current;
		}
	}

	internal Enumerator(Collection<T> collection)
	{
		this = default(Enumerator);
		this.collection = collection;
		version = collection.version;
	}

	public bool MoveNext()
	{
		CheckState();
		if (next < 0)
		{
			return false;
		}
		if (next < collection.size)
		{
			current = collection.items[next++];
			return true;
		}
		next = -1;
		return false;
	}

	public void Reset()
	{
		CheckState();
		next = 0;
	}

	private void CheckState()
	{
		if (collection == null)
		{
			throw new ObjectDisposedException(GetType().FullName);
		}
		if (version != collection.version)
		{
			throw new InvalidOperationException();
		}
	}

	public void Dispose()
	{
		collection = null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using Mono.Collections.Generic;

internal sealed class ReadOnlyCollection<T> : Collection<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
{
	private static ReadOnlyCollection<T> empty;

	public static ReadOnlyCollection<T> Empty
	{
		get
		{
			if (empty != null)
			{
				return empty;
			}
			Interlocked.CompareExchange(ref empty, new ReadOnlyCollection<T>(), null);
			return empty;
		}
	}

	bool ICollection<T>.IsReadOnly => true;

	bool IList.IsFixedSize => true;

	bool IList.IsReadOnly => true;

	private ReadOnlyCollection()
	{
	}

	public ReadOnlyCollection(T[] array)
	{
		if (array == null)
		{
			throw new ArgumentNullException();
		}
		Initialize(array, array.Length);
	}

	public ReadOnlyCollection(Collection<T> collection)
	{
		if (collection == null)
		{
			throw new ArgumentNullException();
		}
		Initialize(collection.items, collection.size);
	}

	private void Initialize(T[] items, int size)
	{
		base.items = new T[size];
		Array.Copy(items, 0, base.items, 0, size);
		base.size = size;
	}

	internal override void Grow(int desired)
	{
		throw new InvalidOperationException();
	}

	protected override void OnAdd(T item, int index)
	{
		throw new InvalidOperationException();
	}

	protected override void OnClear()
	{
		throw new InvalidOperationException();
	}

	protected override void OnInsert(T item, int index)
	{
		throw new InvalidOperationException();
	}

	protected override void OnRemove(T item, int index)
	{
		throw new InvalidOperationException();
	}

	protected override void OnSet(T item, int index)
	{
		throw new InvalidOperationException();
	}
}


using System;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;
using Mono.Security.Cryptography;

internal static class Mixin
{
	public enum Argument
	{
		name,
		fileName,
		fullName,
		stream,
		type,
		method,
		field,
		parameters,
		module,
		modifierType,
		eventType,
		fieldType,
		declaringType,
		returnType,
		propertyType,
		interfaceType,
		constraintType
	}

	public static Version ZeroVersion = new Version(0, 0, 0, 0);

	public const int NotResolvedMarker = -2;

	public const int NoDataMarker = -1;

	internal static object NoValue = new object();

	internal static object NotResolved = new object();

	public const string mscorlib = "mscorlib";

	public const string system_runtime = "System.Runtime";

	public const string system_private_corelib = "System.Private.CoreLib";

	public const string netstandard = "netstandard";

	public const int TableCount = 58;

	public const int CodedIndexCount = 14;

	public static bool IsNullOrEmpty<T>(this T[] self)
	{
		if (self != null)
		{
			return self.Length == 0;
		}
		return true;
	}

	public static bool IsNullOrEmpty<T>(this Collection<T> self)
	{
		if (self != null)
		{
			return self.size == 0;
		}
		return true;
	}

	public static T[] Resize<T>(this T[] self, int length)
	{
		Array.Resize(ref self, length);
		return self;
	}

	public static T[] Add<T>(this T[] self, T item)
	{
		if (self == null)
		{
			self = new T[1] { item };
			return self;
		}
		self = self.Resize(self.Length + 1);
		self[^1] = item;
		return self;
	}

	public static Version CheckVersion(Version version)
	{
		if (version == null)
		{
			return ZeroVersion;
		}
		if (version.Build == -1)
		{
			return new Version(version.Major, version.Minor, 0, 0);
		}
		if (version.Revision == -1)
		{
			return new Version(version.Major, version.Minor, version.Build, 0);
		}
		return version;
	}

	public static bool TryGetUniqueDocument(this MethodDebugInformation info, out Document document)
	{
		document = info.SequencePoints[0].Document;
		for (int i = 1; i < info.SequencePoints.Count; i++)
		{
			if (info.SequencePoints[i].Document != document)
			{
				return false;
			}
		}
		return true;
	}

	public static void ResolveConstant(this IConstantProvider self, ref object constant, ModuleDefinition module)
	{
		if (module == null)
		{
			constant = NoValue;
			return;
		}
		lock (module.SyncRoot)
		{
			if (constant != NotResolved)
			{
				return;
			}
			if (module.HasImage())
			{
				constant = module.Read(self, (IConstantProvider provider, MetadataReader reader) => reader.ReadConstant(provider));
			}
			else
			{
				constant = NoValue;
			}
		}
	}

	public static bool GetHasCustomAttributes(this Mono.Cecil.ICustomAttributeProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (Mono.Cecil.ICustomAttributeProvider provider, MetadataReader reader) => reader.HasCustomAttributes(provider));
		}
		return false;
	}

	public static Collection<CustomAttribute> GetCustomAttributes(this Mono.Cecil.ICustomAttributeProvider self, ref Collection<CustomAttribute> variable, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(ref variable, self, (Mono.Cecil.ICustomAttributeProvider provider, MetadataReader reader) => reader.ReadCustomAttributes(provider));
		}
		Interlocked.CompareExchange(ref variable, new Collection<CustomAttribute>(), null);
		return variable;
	}

	public static bool ContainsGenericParameter(this IGenericInstance self)
	{
		Collection<TypeReference> genericArguments = self.GenericArguments;
		for (int i = 0; i < genericArguments.Count; i++)
		{
			if (genericArguments[i].ContainsGenericParameter)
			{
				return true;
			}
		}
		return false;
	}

	public static void GenericInstanceFullName(this IGenericInstance self, StringBuilder builder)
	{
		builder.Append("<");
		Collection<TypeReference> genericArguments = self.GenericArguments;
		for (int i = 0; i < genericArguments.Count; i++)
		{
			if (i > 0)
			{
				builder.Append(",");
			}
			builder.Append(genericArguments[i].FullName);
		}
		builder.Append(">");
	}

	public static bool GetHasGenericParameters(this IGenericParameterProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (IGenericParameterProvider provider, MetadataReader reader) => reader.HasGenericParameters(provider));
		}
		return false;
	}

	public static Collection<GenericParameter> GetGenericParameters(this IGenericParameterProvider self, ref Collection<GenericParameter> collection, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(ref collection, self, (IGenericParameterProvider provider, MetadataReader reader) => reader.ReadGenericParameters(provider));
		}
		Interlocked.CompareExchange(ref collection, new GenericParameterCollection(self), null);
		return collection;
	}

	public static bool GetHasMarshalInfo(this IMarshalInfoProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (IMarshalInfoProvider provider, MetadataReader reader) => reader.HasMarshalInfo(provider));
		}
		return false;
	}

	public static MarshalInfo GetMarshalInfo(this IMarshalInfoProvider self, ref MarshalInfo variable, ModuleDefinition module)
	{
		if (!module.HasImage())
		{
			return null;
		}
		return module.Read(ref variable, self, (IMarshalInfoProvider provider, MetadataReader reader) => reader.ReadMarshalInfo(provider));
	}

	public static bool GetAttributes(this uint self, uint attributes)
	{
		return (self & attributes) != 0;
	}

	public static uint SetAttributes(this uint self, uint attributes, bool value)
	{
		if (value)
		{
			return self | attributes;
		}
		return self & ~attributes;
	}

	public static bool GetMaskedAttributes(this uint self, uint mask, uint attributes)
	{
		return (self & mask) == attributes;
	}

	public static uint SetMaskedAttributes(this uint self, uint mask, uint attributes, bool value)
	{
		if (value)
		{
			self &= ~mask;
			return self | attributes;
		}
		return self & ~(mask & attributes);
	}

	public static bool GetAttributes(this ushort self, ushort attributes)
	{
		return (self & attributes) != 0;
	}

	public static ushort SetAttributes(this ushort self, ushort attributes, bool value)
	{
		if (value)
		{
			return (ushort)(self | attributes);
		}
		return (ushort)(self & ~attributes);
	}

	public static bool GetMaskedAttributes(this ushort self, ushort mask, uint attributes)
	{
		return (self & mask) == attributes;
	}

	public static ushort SetMaskedAttributes(this ushort self, ushort mask, uint attributes, bool value)
	{
		if (value)
		{
			self = (ushort)(self & ~mask);
			return (ushort)(self | attributes);
		}
		return (ushort)(self & ~(mask & attributes));
	}

	public static bool HasImplicitThis(this IMethodSignature self)
	{
		if (self.HasThis)
		{
			return !self.ExplicitThis;
		}
		return false;
	}

	public static void MethodSignatureFullName(this IMethodSignature self, StringBuilder builder)
	{
		builder.Append("(");
		if (self.HasParameters)
		{
			Collection<ParameterDefinition> parameters = self.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				ParameterDefinition parameterDefinition = parameters[i];
				if (i > 0)
				{
					builder.Append(",");
				}
				if (parameterDefinition.ParameterType.IsSentinel)
				{
					builder.Append("...,");
				}
				builder.Append(parameterDefinition.ParameterType.FullName);
			}
		}
		builder.Append(")");
	}

	public static void CheckModule(ModuleDefinition module)
	{
		if (module == null)
		{
			throw new ArgumentNullException(Argument.module.ToString());
		}
	}

	public static bool TryGetAssemblyNameReference(this ModuleDefinition module, AssemblyNameReference name_reference, out AssemblyNameReference assembly_reference)
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			if (Equals(name_reference, assemblyNameReference))
			{
				assembly_reference = assemblyNameReference;
				return true;
			}
		}
		assembly_reference = null;
		return false;
	}

	private static bool Equals(byte[] a, byte[] b)
	{
		if (a == b)
		{
			return true;
		}
		if (a == null)
		{
			return false;
		}
		if (a.Length != b.Length)
		{
			return false;
		}
		for (int i = 0; i < a.Length; i++)
		{
			if (a[i] != b[i])
			{
				return false;
			}
		}
		return true;
	}

	private static bool Equals<T>(T a, T b) where T : class, IEquatable<T>
	{
		if (a == b)
		{
			return true;
		}
		return a?.Equals(b) ?? false;
	}

	private static bool Equals(AssemblyNameReference a, AssemblyNameReference b)
	{
		if (a == b)
		{
			return true;
		}
		if (a.Name != b.Name)
		{
			return false;
		}
		if (!Equals(a.Version, b.Version))
		{
			return false;
		}
		if (a.Culture != b.Culture)
		{
			return false;
		}
		if (!Equals(a.PublicKeyToken, b.PublicKeyToken))
		{
			return false;
		}
		return true;
	}

	public static ParameterDefinition GetParameter(this Mono.Cecil.Cil.MethodBody self, int index)
	{
		MethodDefinition method = self.method;
		if (method.HasThis)
		{
			if (index == 0)
			{
				return self.ThisParameter;
			}
			index--;
		}
		Collection<ParameterDefinition> parameters = method.Parameters;
		if (index < 0 || index >= parameters.size)
		{
			return null;
		}
		return parameters[index];
	}

	public static VariableDefinition GetVariable(this Mono.Cecil.Cil.MethodBody self, int index)
	{
		Collection<VariableDefinition> variables = self.Variables;
		if (index < 0 || index >= variables.size)
		{
			return null;
		}
		return variables[index];
	}

	public static bool GetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics)
	{
		return (self.SemanticsAttributes & semantics) != 0;
	}

	public static void SetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
	{
		if (value)
		{
			self.SemanticsAttributes |= semantics;
		}
		else
		{
			self.SemanticsAttributes &= (MethodSemanticsAttributes)(ushort)(~(int)semantics);
		}
	}

	public static bool IsVarArg(this IMethodSignature self)
	{
		return self.CallingConvention == MethodCallingConvention.VarArg;
	}

	public static int GetSentinelPosition(this IMethodSignature self)
	{
		if (!self.HasParameters)
		{
			return -1;
		}
		Collection<ParameterDefinition> parameters = self.Parameters;
		for (int i = 0; i < parameters.Count; i++)
		{
			if (parameters[i].ParameterType.IsSentinel)
			{
				return i;
			}
		}
		return -1;
	}

	public static void CheckName(object name)
	{
		if (name == null)
		{
			throw new ArgumentNullException(Argument.name.ToString());
		}
	}

	public static void CheckName(string name)
	{
		if (string.IsNullOrEmpty(name))
		{
			throw new ArgumentNullOrEmptyException(Argument.name.ToString());
		}
	}

	public static void CheckFileName(string fileName)
	{
		if (string.IsNullOrEmpty(fileName))
		{
			throw new ArgumentNullOrEmptyException(Argument.fileName.ToString());
		}
	}

	public static void CheckFullName(string fullName)
	{
		if (string.IsNullOrEmpty(fullName))
		{
			throw new ArgumentNullOrEmptyException(Argument.fullName.ToString());
		}
	}

	public static void CheckStream(object stream)
	{
		if (stream == null)
		{
			throw new ArgumentNullException(Argument.stream.ToString());
		}
	}

	public static void CheckWriteSeek(Stream stream)
	{
		if (!stream.CanWrite || !stream.CanSeek)
		{
			throw new ArgumentException("Stream must be writable and seekable.");
		}
	}

	public static void CheckReadSeek(Stream stream)
	{
		if (!stream.CanRead || !stream.CanSeek)
		{
			throw new ArgumentException("Stream must be readable and seekable.");
		}
	}

	public static void CheckType(object type)
	{
		if (type == null)
		{
			throw new ArgumentNullException(Argument.type.ToString());
		}
	}

	public static void CheckType(object type, Argument argument)
	{
		if (type == null)
		{
			throw new ArgumentNullException(argument.ToString());
		}
	}

	public static void CheckField(object field)
	{
		if (field == null)
		{
			throw new ArgumentNullException(Argument.field.ToString());
		}
	}

	public static void CheckMethod(object method)
	{
		if (method == null)
		{
			throw new ArgumentNullException(Argument.method.ToString());
		}
	}

	public static void CheckParameters(object parameters)
	{
		if (parameters == null)
		{
			throw new ArgumentNullException(Argument.parameters.ToString());
		}
	}

	public static uint GetTimestamp()
	{
		return (uint)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
	}

	public static bool HasImage(this ModuleDefinition self)
	{
		return self?.HasImage ?? false;
	}

	public static string GetFileName(this Stream self)
	{
		if (!(self is FileStream fileStream))
		{
			return string.Empty;
		}
		return Path.GetFullPath(fileStream.Name);
	}

	public static TargetRuntime ParseRuntime(this string self)
	{
		if (string.IsNullOrEmpty(self))
		{
			return TargetRuntime.Net_4_0;
		}
		switch (self[1])
		{
		case '1':
			if (self[3] != '0')
			{
				return TargetRuntime.Net_1_1;
			}
			return TargetRuntime.Net_1_0;
		case '2':
			return TargetRuntime.Net_2_0;
		default:
			return TargetRuntime.Net_4_0;
		}
	}

	public static string RuntimeVersionString(this TargetRuntime runtime)
	{
		return runtime switch
		{
			TargetRuntime.Net_1_0 => "v1.0.3705", 
			TargetRuntime.Net_1_1 => "v1.1.4322", 
			TargetRuntime.Net_2_0 => "v2.0.50727", 
			_ => "v4.0.30319", 
		};
	}

	public static bool IsWindowsMetadata(this ModuleDefinition module)
	{
		return module.MetadataKind != MetadataKind.Ecma335;
	}

	public static byte[] ReadAll(this Stream self)
	{
		MemoryStream memoryStream = new MemoryStream((int)self.Length);
		byte[] array = new byte[1024];
		int count;
		while ((count = self.Read(array, 0, array.Length)) != 0)
		{
			memoryStream.Write(array, 0, count);
		}
		return memoryStream.ToArray();
	}

	public static void Read(object o)
	{
	}

	public static bool GetHasSecurityDeclarations(this ISecurityDeclarationProvider self, ModuleDefinition module)
	{
		if (module.HasImage())
		{
			return module.Read(self, (ISecurityDeclarationProvider provider, MetadataReader reader) => reader.HasSecurityDeclarations(provider));
		}
		return false;
	}

	public static Collection<SecurityDeclaration> GetSecurityDeclarations(this ISecurityDeclarationProvider self, ref Collection<SecurityDeclaration> variable, ModuleDefinition module)
	{
		if (module.HasImage)
		{
			return module.Read(ref variable, self, (ISecurityDeclarationProvider provider, MetadataReader reader) => reader.ReadSecurityDeclarations(provider));
		}
		Interlocked.CompareExchange(ref variable, new Collection<SecurityDeclaration>(), null);
		return variable;
	}

	public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
	{
		Collection<FieldDefinition> fields = self.Fields;
		for (int i = 0; i < fields.Count; i++)
		{
			FieldDefinition fieldDefinition = fields[i];
			if (!fieldDefinition.IsStatic)
			{
				return fieldDefinition.FieldType;
			}
		}
		throw new ArgumentException();
	}

	public static TypeDefinition GetNestedType(this TypeDefinition self, string fullname)
	{
		if (!self.HasNestedTypes)
		{
			return null;
		}
		Collection<TypeDefinition> nestedTypes = self.NestedTypes;
		for (int i = 0; i < nestedTypes.Count; i++)
		{
			TypeDefinition typeDefinition = nestedTypes[i];
			if (typeDefinition.TypeFullName() == fullname)
			{
				return typeDefinition;
			}
		}
		return null;
	}

	public static bool IsPrimitive(this ElementType self)
	{
		if (self - 2 <= ElementType.U8 || self - 24 <= ElementType.Void)
		{
			return true;
		}
		return false;
	}

	public static string TypeFullName(this TypeReference self)
	{
		if (!string.IsNullOrEmpty(self.Namespace))
		{
			return self.Namespace + "." + self.Name;
		}
		return self.Name;
	}

	public static bool IsTypeOf(this TypeReference self, string @namespace, string name)
	{
		if (self.Name == name)
		{
			return self.Namespace == @namespace;
		}
		return false;
	}

	public static bool IsTypeSpecification(this TypeReference type)
	{
		switch (type.etype)
		{
		case ElementType.Ptr:
		case ElementType.ByRef:
		case ElementType.Var:
		case ElementType.Array:
		case ElementType.GenericInst:
		case ElementType.FnPtr:
		case ElementType.SzArray:
		case ElementType.MVar:
		case ElementType.CModReqD:
		case ElementType.CModOpt:
		case ElementType.Sentinel:
		case ElementType.Pinned:
			return true;
		default:
			return false;
		}
	}

	public static TypeDefinition CheckedResolve(this TypeReference self)
	{
		return self.Resolve() ?? throw new ResolutionException(self);
	}

	public static bool TryGetCoreLibraryReference(this ModuleDefinition module, out AssemblyNameReference reference)
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			reference = assemblyReferences[i];
			if (IsCoreLibrary(reference))
			{
				return true;
			}
		}
		reference = null;
		return false;
	}

	public static bool IsCoreLibrary(this ModuleDefinition module)
	{
		if (module.Assembly == null)
		{
			return false;
		}
		if (!IsCoreLibrary(module.Assembly.Name))
		{
			return false;
		}
		if (module.HasImage && module.Read(module, (ModuleDefinition m, MetadataReader reader) => reader.image.GetTableLength(Table.AssemblyRef) > 0))
		{
			return false;
		}
		return true;
	}

	public static void KnownValueType(this TypeReference type)
	{
		if (!type.IsDefinition)
		{
			type.IsValueType = true;
		}
	}

	private static bool IsCoreLibrary(AssemblyNameReference reference)
	{
		string name = reference.Name;
		switch (name)
		{
		default:
			return name == "netstandard";
		case "mscorlib":
		case "System.Runtime":
		case "System.Private.CoreLib":
			return true;
		}
	}

	public static ImageDebugHeaderEntry GetCodeViewEntry(this ImageDebugHeader header)
	{
		return header.GetEntry(ImageDebugType.CodeView);
	}

	public static ImageDebugHeaderEntry GetDeterministicEntry(this ImageDebugHeader header)
	{
		return header.GetEntry(ImageDebugType.Deterministic);
	}

	public static ImageDebugHeader AddDeterministicEntry(this ImageDebugHeader header)
	{
		ImageDebugDirectory directory = default(ImageDebugDirectory);
		directory.Type = ImageDebugType.Deterministic;
		ImageDebugHeaderEntry imageDebugHeaderEntry = new ImageDebugHeaderEntry(directory, Empty<byte>.Array);
		if (header == null)
		{
			return new ImageDebugHeader(imageDebugHeaderEntry);
		}
		ImageDebugHeaderEntry[] array = new ImageDebugHeaderEntry[header.Entries.Length + 1];
		Array.Copy(header.Entries, array, header.Entries.Length);
		array[^1] = imageDebugHeaderEntry;
		return new ImageDebugHeader(array);
	}

	public static ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry(this ImageDebugHeader header)
	{
		return header.GetEntry(ImageDebugType.EmbeddedPortablePdb);
	}

	public static ImageDebugHeaderEntry GetPdbChecksumEntry(this ImageDebugHeader header)
	{
		return header.GetEntry(ImageDebugType.PdbChecksum);
	}

	private static ImageDebugHeaderEntry GetEntry(this ImageDebugHeader header, ImageDebugType type)
	{
		if (!header.HasEntries)
		{
			return null;
		}
		for (int i = 0; i < header.Entries.Length; i++)
		{
			ImageDebugHeaderEntry imageDebugHeaderEntry = header.Entries[i];
			if (imageDebugHeaderEntry.Directory.Type == type)
			{
				return imageDebugHeaderEntry;
			}
		}
		return null;
	}

	public static string GetPdbFileName(string assemblyFileName)
	{
		return Path.ChangeExtension(assemblyFileName, ".pdb");
	}

	public static string GetMdbFileName(string assemblyFileName)
	{
		return assemblyFileName + ".mdb";
	}

	public static bool IsPortablePdb(string fileName)
	{
		using FileStream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
		return IsPortablePdb(stream);
	}

	public static bool IsPortablePdb(Stream stream)
	{
		if (stream.Length < 4)
		{
			return false;
		}
		long position = stream.Position;
		try
		{
			return new BinaryReader(stream).ReadUInt32() == 1112167234;
		}
		finally
		{
			stream.Position = position;
		}
	}

	public static uint ReadCompressedUInt32(this byte[] data, ref int position)
	{
		uint result;
		if ((data[position] & 0x80) == 0)
		{
			result = data[position];
			position++;
		}
		else if ((data[position] & 0x40) == 0)
		{
			result = (uint)((data[position] & -129) << 8);
			result |= data[position + 1];
			position += 2;
		}
		else
		{
			result = (uint)((data[position] & -193) << 24);
			result |= (uint)(data[position + 1] << 16);
			result |= (uint)(data[position + 2] << 8);
			result |= data[position + 3];
			position += 4;
		}
		return result;
	}

	public static MetadataToken GetMetadataToken(this CodedIndex self, uint data)
	{
		uint rid;
		TokenType type;
		switch (self)
		{
		case CodedIndex.TypeDefOrRef:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_006d;
			case 2u:
				goto IL_0078;
			default:
				goto end_IL_0001;
			}
			type = TokenType.TypeDef;
			goto IL_05b3;
		case CodedIndex.HasConstant:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_00ad;
			case 2u:
				goto IL_00b8;
			default:
				goto end_IL_0001;
			}
			type = TokenType.Field;
			goto IL_05b3;
		case CodedIndex.HasCustomAttribute:
			rid = data >> 5;
			switch (data & 0x1F)
			{
			case 0u:
				break;
			case 1u:
				goto IL_013a;
			case 2u:
				goto IL_0145;
			case 3u:
				goto IL_0150;
			case 4u:
				goto IL_015b;
			case 5u:
				goto IL_0166;
			case 6u:
				goto IL_0171;
			case 7u:
				goto IL_017c;
			case 8u:
				goto IL_0183;
			case 9u:
				goto IL_018e;
			case 10u:
				goto IL_0199;
			case 11u:
				goto IL_01a4;
			case 12u:
				goto IL_01af;
			case 13u:
				goto IL_01ba;
			case 14u:
				goto IL_01c5;
			case 15u:
				goto IL_01d0;
			case 16u:
				goto IL_01db;
			case 17u:
				goto IL_01e6;
			case 18u:
				goto IL_01f1;
			case 19u:
				goto IL_01fc;
			case 20u:
				goto IL_0207;
			case 21u:
				goto IL_0212;
			default:
				goto end_IL_0001;
			}
			type = TokenType.Method;
			goto IL_05b3;
		case CodedIndex.HasFieldMarshal:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Param;
			}
			else
			{
				type = TokenType.Field;
			}
			goto IL_05b3;
		}
		case CodedIndex.HasDeclSecurity:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_0271;
			case 2u:
				goto IL_027c;
			default:
				goto end_IL_0001;
			}
			type = TokenType.TypeDef;
			goto IL_05b3;
		case CodedIndex.MemberRefParent:
			rid = data >> 3;
			switch (data & 7)
			{
			case 0u:
				break;
			case 1u:
				goto IL_02b9;
			case 2u:
				goto IL_02c4;
			case 3u:
				goto IL_02cf;
			case 4u:
				goto IL_02da;
			default:
				goto end_IL_0001;
			}
			type = TokenType.TypeDef;
			goto IL_05b3;
		case CodedIndex.HasSemantics:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Property;
			}
			else
			{
				type = TokenType.Event;
			}
			goto IL_05b3;
		}
		case CodedIndex.MethodDefOrRef:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.MemberRef;
			}
			else
			{
				type = TokenType.Method;
			}
			goto IL_05b3;
		}
		case CodedIndex.MemberForwarded:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Method;
			}
			else
			{
				type = TokenType.Field;
			}
			goto IL_05b3;
		}
		case CodedIndex.Implementation:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_038d;
			case 2u:
				goto IL_0398;
			default:
				goto end_IL_0001;
			}
			type = TokenType.File;
			goto IL_05b3;
		case CodedIndex.CustomAttributeType:
		{
			rid = data >> 3;
			uint num = data & 7;
			if (num != 2)
			{
				if (num != 3)
				{
					break;
				}
				type = TokenType.MemberRef;
			}
			else
			{
				type = TokenType.Method;
			}
			goto IL_05b3;
		}
		case CodedIndex.ResolutionScope:
			rid = data >> 2;
			switch (data & 3)
			{
			case 0u:
				break;
			case 1u:
				goto IL_03f8;
			case 2u:
				goto IL_0403;
			case 3u:
				goto IL_040e;
			default:
				goto end_IL_0001;
			}
			type = TokenType.Module;
			goto IL_05b3;
		case CodedIndex.TypeOrMethodDef:
		{
			rid = data >> 1;
			uint num = data & 1;
			if (num != 0)
			{
				if (num != 1)
				{
					break;
				}
				type = TokenType.Method;
			}
			else
			{
				type = TokenType.TypeDef;
			}
			goto IL_05b3;
		}
		case CodedIndex.HasCustomDebugInformation:
			{
				rid = data >> 5;
				switch (data & 0x1F)
				{
				case 0u:
					break;
				case 1u:
					goto IL_04ce;
				case 2u:
					goto IL_04d9;
				case 3u:
					goto IL_04e4;
				case 4u:
					goto IL_04ef;
				case 5u:
					goto IL_04fa;
				case 6u:
					goto IL_0505;
				case 7u:
					goto IL_0510;
				case 8u:
					goto IL_0517;
				case 9u:
					goto IL_0522;
				case 10u:
					goto IL_052d;
				case 11u:
					goto IL_0535;
				case 12u:
					goto IL_053d;
				case 13u:
					goto IL_0545;
				case 14u:
					goto IL_054d;
				case 15u:
					goto IL_0555;
				case 16u:
					goto IL_055d;
				case 17u:
					goto IL_0565;
				case 18u:
					goto IL_056d;
				case 19u:
					goto IL_0575;
				case 20u:
					goto IL_057d;
				case 21u:
					goto IL_0585;
				case 22u:
					goto IL_058d;
				case 23u:
					goto IL_0595;
				case 24u:
					goto IL_059d;
				case 25u:
					goto IL_05a5;
				case 26u:
					goto IL_05ad;
				default:
					goto end_IL_0001;
				}
				type = TokenType.Method;
				goto IL_05b3;
			}
			IL_05ad:
			type = TokenType.ImportScope;
			goto IL_05b3;
			IL_05a5:
			type = TokenType.LocalConstant;
			goto IL_05b3;
			IL_059d:
			type = TokenType.LocalVariable;
			goto IL_05b3;
			IL_0595:
			type = TokenType.LocalScope;
			goto IL_05b3;
			IL_058d:
			type = TokenType.Document;
			goto IL_05b3;
			IL_0585:
			type = TokenType.MethodSpec;
			goto IL_05b3;
			IL_057d:
			type = TokenType.GenericParamConstraint;
			goto IL_05b3;
			IL_0575:
			type = TokenType.GenericParam;
			goto IL_05b3;
			IL_056d:
			type = TokenType.ManifestResource;
			goto IL_05b3;
			IL_0565:
			type = TokenType.ExportedType;
			goto IL_05b3;
			IL_055d:
			type = TokenType.File;
			goto IL_05b3;
			IL_0555:
			type = TokenType.AssemblyRef;
			goto IL_05b3;
			IL_054d:
			type = TokenType.Assembly;
			goto IL_05b3;
			IL_0545:
			type = TokenType.TypeSpec;
			goto IL_05b3;
			IL_053d:
			type = TokenType.ModuleRef;
			goto IL_05b3;
			IL_0535:
			type = TokenType.Signature;
			goto IL_05b3;
			IL_052d:
			type = TokenType.Event;
			goto IL_05b3;
			IL_0522:
			type = TokenType.Property;
			goto IL_05b3;
			IL_0517:
			type = TokenType.Permission;
			goto IL_05b3;
			IL_0510:
			type = TokenType.Module;
			goto IL_05b3;
			IL_0505:
			type = TokenType.MemberRef;
			goto IL_05b3;
			IL_04fa:
			type = TokenType.InterfaceImpl;
			goto IL_05b3;
			IL_04ef:
			type = TokenType.Param;
			goto IL_05b3;
			IL_04e4:
			type = TokenType.TypeDef;
			goto IL_05b3;
			IL_04d9:
			type = TokenType.TypeRef;
			goto IL_05b3;
			IL_04ce:
			type = TokenType.Field;
			goto IL_05b3;
			IL_01db:
			type = TokenType.File;
			goto IL_05b3;
			IL_01d0:
			type = TokenType.AssemblyRef;
			goto IL_05b3;
			IL_01ba:
			type = TokenType.TypeSpec;
			goto IL_05b3;
			IL_01c5:
			type = TokenType.Assembly;
			goto IL_05b3;
			IL_040e:
			type = TokenType.TypeRef;
			goto IL_05b3;
			IL_0403:
			type = TokenType.AssemblyRef;
			goto IL_05b3;
			IL_03f8:
			type = TokenType.ModuleRef;
			goto IL_05b3;
			IL_01af:
			type = TokenType.ModuleRef;
			goto IL_05b3;
			IL_01a4:
			type = TokenType.Signature;
			goto IL_05b3;
			IL_018e:
			type = TokenType.Property;
			goto IL_05b3;
			IL_0199:
			type = TokenType.Event;
			goto IL_05b3;
			IL_0398:
			type = TokenType.ExportedType;
			goto IL_05b3;
			IL_038d:
			type = TokenType.AssemblyRef;
			goto IL_05b3;
			IL_0183:
			type = TokenType.Permission;
			goto IL_05b3;
			IL_017c:
			type = TokenType.Module;
			goto IL_05b3;
			IL_0166:
			type = TokenType.InterfaceImpl;
			goto IL_05b3;
			IL_0171:
			type = TokenType.MemberRef;
			goto IL_05b3;
			IL_015b:
			type = TokenType.Param;
			goto IL_05b3;
			IL_0145:
			type = TokenType.TypeRef;
			goto IL_05b3;
			IL_0150:
			type = TokenType.TypeDef;
			goto IL_05b3;
			IL_013a:
			type = TokenType.Field;
			goto IL_05b3;
			IL_006d:
			type = TokenType.TypeRef;
			goto IL_05b3;
			IL_02da:
			type = TokenType.TypeSpec;
			goto IL_05b3;
			IL_02cf:
			type = TokenType.Method;
			goto IL_05b3;
			IL_02c4:
			type = TokenType.ModuleRef;
			goto IL_05b3;
			IL_02b9:
			type = TokenType.TypeRef;
			goto IL_05b3;
			IL_00b8:
			type = TokenType.Property;
			goto IL_05b3;
			IL_027c:
			type = TokenType.Assembly;
			goto IL_05b3;
			IL_0271:
			type = TokenType.Method;
			goto IL_05b3;
			IL_00ad:
			type = TokenType.Param;
			goto IL_05b3;
			IL_05b3:
			return new MetadataToken(type, rid);
			IL_0078:
			type = TokenType.TypeSpec;
			goto IL_05b3;
			IL_0212:
			type = TokenType.MethodSpec;
			goto IL_05b3;
			IL_0207:
			type = TokenType.GenericParamConstraint;
			goto IL_05b3;
			IL_01fc:
			type = TokenType.GenericParam;
			goto IL_05b3;
			IL_01f1:
			type = TokenType.ManifestResource;
			goto IL_05b3;
			IL_01e6:
			type = TokenType.ExportedType;
			goto IL_05b3;
			end_IL_0001:
			break;
		}
		return MetadataToken.Zero;
	}

	public static uint CompressMetadataToken(this CodedIndex self, MetadataToken token)
	{
		uint result = 0u;
		if (token.RID == 0)
		{
			return result;
		}
		switch (self)
		{
		case CodedIndex.TypeDefOrRef:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.TypeRef:
				return result | 1;
			case TokenType.TypeSpec:
				return result | 2;
			}
			break;
		case CodedIndex.HasConstant:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.Field:
				return result | 0;
			case TokenType.Param:
				return result | 1;
			case TokenType.Property:
				return result | 2;
			}
			break;
		case CodedIndex.HasCustomAttribute:
			result = token.RID << 5;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 0;
			case TokenType.Field:
				return result | 1;
			case TokenType.TypeRef:
				return result | 2;
			case TokenType.TypeDef:
				return result | 3;
			case TokenType.Param:
				return result | 4;
			case TokenType.InterfaceImpl:
				return result | 5;
			case TokenType.MemberRef:
				return result | 6;
			case TokenType.Module:
				return result | 7;
			case TokenType.Permission:
				return result | 8;
			case TokenType.Property:
				return result | 9;
			case TokenType.Event:
				return result | 0xA;
			case TokenType.Signature:
				return result | 0xB;
			case TokenType.ModuleRef:
				return result | 0xC;
			case TokenType.TypeSpec:
				return result | 0xD;
			case TokenType.Assembly:
				return result | 0xE;
			case TokenType.AssemblyRef:
				return result | 0xF;
			case TokenType.File:
				return result | 0x10;
			case TokenType.ExportedType:
				return result | 0x11;
			case TokenType.ManifestResource:
				return result | 0x12;
			case TokenType.GenericParam:
				return result | 0x13;
			case TokenType.GenericParamConstraint:
				return result | 0x14;
			case TokenType.MethodSpec:
				return result | 0x15;
			}
			break;
		case CodedIndex.HasFieldMarshal:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Field:
				return result | 0;
			case TokenType.Param:
				return result | 1;
			}
			break;
		case CodedIndex.HasDeclSecurity:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.Method:
				return result | 1;
			case TokenType.Assembly:
				return result | 2;
			}
			break;
		case CodedIndex.MemberRefParent:
			result = token.RID << 3;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.TypeRef:
				return result | 1;
			case TokenType.ModuleRef:
				return result | 2;
			case TokenType.Method:
				return result | 3;
			case TokenType.TypeSpec:
				return result | 4;
			}
			break;
		case CodedIndex.HasSemantics:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Event:
				return result | 0;
			case TokenType.Property:
				return result | 1;
			}
			break;
		case CodedIndex.MethodDefOrRef:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 0;
			case TokenType.MemberRef:
				return result | 1;
			}
			break;
		case CodedIndex.MemberForwarded:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.Field:
				return result | 0;
			case TokenType.Method:
				return result | 1;
			}
			break;
		case CodedIndex.Implementation:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.File:
				return result | 0;
			case TokenType.AssemblyRef:
				return result | 1;
			case TokenType.ExportedType:
				return result | 2;
			}
			break;
		case CodedIndex.CustomAttributeType:
			result = token.RID << 3;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 2;
			case TokenType.MemberRef:
				return result | 3;
			}
			break;
		case CodedIndex.ResolutionScope:
			result = token.RID << 2;
			switch (token.TokenType)
			{
			case TokenType.Module:
				return result | 0;
			case TokenType.ModuleRef:
				return result | 1;
			case TokenType.AssemblyRef:
				return result | 2;
			case TokenType.TypeRef:
				return result | 3;
			}
			break;
		case CodedIndex.TypeOrMethodDef:
			result = token.RID << 1;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				return result | 0;
			case TokenType.Method:
				return result | 1;
			}
			break;
		case CodedIndex.HasCustomDebugInformation:
			result = token.RID << 5;
			switch (token.TokenType)
			{
			case TokenType.Method:
				return result | 0;
			case TokenType.Field:
				return result | 1;
			case TokenType.TypeRef:
				return result | 2;
			case TokenType.TypeDef:
				return result | 3;
			case TokenType.Param:
				return result | 4;
			case TokenType.InterfaceImpl:
				return result | 5;
			case TokenType.MemberRef:
				return result | 6;
			case TokenType.Module:
				return result | 7;
			case TokenType.Permission:
				return result | 8;
			case TokenType.Property:
				return result | 9;
			case TokenType.Event:
				return result | 0xA;
			case TokenType.Signature:
				return result | 0xB;
			case TokenType.ModuleRef:
				return result | 0xC;
			case TokenType.TypeSpec:
				return result | 0xD;
			case TokenType.Assembly:
				return result | 0xE;
			case TokenType.AssemblyRef:
				return result | 0xF;
			case TokenType.File:
				return result | 0x10;
			case TokenType.ExportedType:
				return result | 0x11;
			case TokenType.ManifestResource:
				return result | 0x12;
			case TokenType.GenericParam:
				return result | 0x13;
			case TokenType.GenericParamConstraint:
				return result | 0x14;
			case TokenType.MethodSpec:
				return result | 0x15;
			case TokenType.Document:
				return result | 0x16;
			case TokenType.LocalScope:
				return result | 0x17;
			case TokenType.LocalVariable:
				return result | 0x18;
			case TokenType.LocalConstant:
				return result | 0x19;
			case TokenType.ImportScope:
				return result | 0x1A;
			}
			break;
		}
		throw new ArgumentException();
	}

	public static int GetSize(this CodedIndex self, Func<Table, int> counter)
	{
		int num;
		Table[] array;
		switch (self)
		{
		case CodedIndex.TypeDefOrRef:
			num = 2;
			array = new Table[3]
			{
				Table.TypeDef,
				Table.TypeRef,
				Table.TypeSpec
			};
			break;
		case CodedIndex.HasConstant:
			num = 2;
			array = new Table[3]
			{
				Table.Field,
				Table.Param,
				Table.Property
			};
			break;
		case CodedIndex.HasCustomAttribute:
			num = 5;
			array = new Table[22]
			{
				Table.Method,
				Table.Field,
				Table.TypeRef,
				Table.TypeDef,
				Table.Param,
				Table.InterfaceImpl,
				Table.MemberRef,
				Table.Module,
				Table.DeclSecurity,
				Table.Property,
				Table.Event,
				Table.StandAloneSig,
				Table.ModuleRef,
				Table.TypeSpec,
				Table.Assembly,
				Table.AssemblyRef,
				Table.File,
				Table.ExportedType,
				Table.ManifestResource,
				Table.GenericParam,
				Table.GenericParamConstraint,
				Table.MethodSpec
			};
			break;
		case CodedIndex.HasFieldMarshal:
			num = 1;
			array = new Table[2]
			{
				Table.Field,
				Table.Param
			};
			break;
		case CodedIndex.HasDeclSecurity:
			num = 2;
			array = new Table[3]
			{
				Table.TypeDef,
				Table.Method,
				Table.Assembly
			};
			break;
		case CodedIndex.MemberRefParent:
			num = 3;
			array = new Table[5]
			{
				Table.TypeDef,
				Table.TypeRef,
				Table.ModuleRef,
				Table.Method,
				Table.TypeSpec
			};
			break;
		case CodedIndex.HasSemantics:
			num = 1;
			array = new Table[2]
			{
				Table.Event,
				Table.Property
			};
			break;
		case CodedIndex.MethodDefOrRef:
			num = 1;
			array = new Table[2]
			{
				Table.Method,
				Table.MemberRef
			};
			break;
		case CodedIndex.MemberForwarded:
			num = 1;
			array = new Table[2]
			{
				Table.Field,
				Table.Method
			};
			break;
		case CodedIndex.Implementation:
			num = 2;
			array = new Table[3]
			{
				Table.File,
				Table.AssemblyRef,
				Table.ExportedType
			};
			break;
		case CodedIndex.CustomAttributeType:
			num = 3;
			array = new Table[2]
			{
				Table.Method,
				Table.MemberRef
			};
			break;
		case CodedIndex.ResolutionScope:
			num = 2;
			array = new Table[4]
			{
				Table.Module,
				Table.ModuleRef,
				Table.AssemblyRef,
				Table.TypeRef
			};
			break;
		case CodedIndex.TypeOrMethodDef:
			num = 1;
			array = new Table[2]
			{
				Table.TypeDef,
				Table.Method
			};
			break;
		case CodedIndex.HasCustomDebugInformation:
			num = 5;
			array = new Table[27]
			{
				Table.Method,
				Table.Field,
				Table.TypeRef,
				Table.TypeDef,
				Table.Param,
				Table.InterfaceImpl,
				Table.MemberRef,
				Table.Module,
				Table.DeclSecurity,
				Table.Property,
				Table.Event,
				Table.StandAloneSig,
				Table.ModuleRef,
				Table.TypeSpec,
				Table.Assembly,
				Table.AssemblyRef,
				Table.File,
				Table.ExportedType,
				Table.ManifestResource,
				Table.GenericParam,
				Table.GenericParamConstraint,
				Table.MethodSpec,
				Table.Document,
				Table.LocalScope,
				Table.LocalVariable,
				Table.LocalConstant,
				Table.ImportScope
			};
			break;
		default:
			throw new ArgumentException();
		}
		int num2 = 0;
		for (int i = 0; i < array.Length; i++)
		{
			num2 = Math.Max(counter(array[i]), num2);
		}
		if (num2 >= 1 << 16 - num)
		{
			return 4;
		}
		return 2;
	}

	public static RSA CreateRSA(this WriterParameters writer_parameters)
	{
		if (writer_parameters.StrongNameKeyBlob != null)
		{
			return CryptoConvert.FromCapiKeyBlob(writer_parameters.StrongNameKeyBlob);
		}
		string key_container;
		byte[] key;
		if (writer_parameters.StrongNameKeyContainer != null)
		{
			key_container = writer_parameters.StrongNameKeyContainer;
		}
		else if (!TryGetKeyContainer(writer_parameters.StrongNameKeyPair, out key, out key_container))
		{
			return CryptoConvert.FromCapiKeyBlob(key);
		}
		return new RSACryptoServiceProvider(new CspParameters
		{
			Flags = CspProviderFlags.UseMachineKeyStore,
			KeyContainerName = key_container,
			KeyNumber = 2
		});
	}

	private static bool TryGetKeyContainer(ISerializable key_pair, out byte[] key, out string key_container)
	{
		SerializationInfo serializationInfo = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
		key_pair.GetObjectData(serializationInfo, default(StreamingContext));
		key = (byte[])serializationInfo.GetValue("_keyPairArray", typeof(byte[]));
		key_container = serializationInfo.GetString("_keyPairContainer");
		return key_container != null;
	}
}


public enum Argument
{
	name,
	fileName,
	fullName,
	stream,
	type,
	method,
	field,
	parameters,
	module,
	modifierType,
	eventType,
	fieldType,
	declaringType,
	returnType,
	propertyType,
	interfaceType,
	constraintType
}


internal struct ArrayDimension
{
	private int? lower_bound;

	private int? upper_bound;

	public int? LowerBound
	{
		get
		{
			return lower_bound;
		}
		set
		{
			lower_bound = value;
		}
	}

	public int? UpperBound
	{
		get
		{
			return upper_bound;
		}
		set
		{
			upper_bound = value;
		}
	}

	public bool IsSized
	{
		get
		{
			if (!lower_bound.HasValue)
			{
				return upper_bound.HasValue;
			}
			return true;
		}
	}

	public ArrayDimension(int? lowerBound, int? upperBound)
	{
		lower_bound = lowerBound;
		upper_bound = upperBound;
	}

	public override string ToString()
	{
		if (IsSized)
		{
			int? num = lower_bound;
			string? text = num.ToString();
			num = upper_bound;
			return text + "..." + num;
		}
		return string.Empty;
	}
}


using System;
using System.Text;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class ArrayType : TypeSpecification
{
	private Collection<ArrayDimension> dimensions;

	public Collection<ArrayDimension> Dimensions
	{
		get
		{
			if (dimensions != null)
			{
				return dimensions;
			}
			Collection<ArrayDimension> collection = new Collection<ArrayDimension>();
			collection.Add(default(ArrayDimension));
			Interlocked.CompareExchange(ref dimensions, collection, null);
			return dimensions;
		}
	}

	public int Rank
	{
		get
		{
			if (dimensions != null)
			{
				return dimensions.Count;
			}
			return 1;
		}
	}

	public bool IsVector
	{
		get
		{
			if (dimensions == null)
			{
				return true;
			}
			if (dimensions.Count > 1)
			{
				return false;
			}
			return !dimensions[0].IsSized;
		}
	}

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string Name => base.Name + Suffix;

	public override string FullName => base.FullName + Suffix;

	private string Suffix
	{
		get
		{
			if (IsVector)
			{
				return "[]";
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("[");
			for (int i = 0; i < dimensions.Count; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(",");
				}
				stringBuilder.Append(dimensions[i].ToString());
			}
			stringBuilder.Append("]");
			return stringBuilder.ToString();
		}
	}

	public override bool IsArray => true;

	public ArrayType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Array;
	}

	public ArrayType(TypeReference type, int rank)
		: this(type)
	{
		Mixin.CheckType(type);
		if (rank != 1)
		{
			dimensions = new Collection<ArrayDimension>(rank);
			for (int i = 0; i < rank; i++)
			{
				dimensions.Add(default(ArrayDimension));
			}
			etype = Mono.Cecil.Metadata.ElementType.Array;
		}
	}
}


using System;
using System.IO;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class AssemblyDefinition : ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider, IDisposable
{
	private AssemblyNameDefinition name;

	internal ModuleDefinition main_module;

	private Collection<ModuleDefinition> modules;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<SecurityDeclaration> security_declarations;

	public AssemblyNameDefinition Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public string FullName
	{
		get
		{
			if (name == null)
			{
				return string.Empty;
			}
			return name.FullName;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return new MetadataToken(TokenType.Assembly, 1);
		}
		set
		{
		}
	}

	public Collection<ModuleDefinition> Modules
	{
		get
		{
			if (modules != null)
			{
				return modules;
			}
			if (main_module.HasImage)
			{
				return main_module.Read(ref modules, this, (AssemblyDefinition _, MetadataReader reader) => reader.ReadModules());
			}
			Interlocked.CompareExchange(ref modules, new Collection<ModuleDefinition>(1) { main_module }, null);
			return modules;
		}
	}

	public ModuleDefinition MainModule => main_module;

	public MethodDefinition EntryPoint
	{
		get
		{
			return main_module.EntryPoint;
		}
		set
		{
			main_module.EntryPoint = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(main_module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, main_module);

	public bool HasSecurityDeclarations
	{
		get
		{
			if (security_declarations != null)
			{
				return security_declarations.Count > 0;
			}
			return this.GetHasSecurityDeclarations(main_module);
		}
	}

	public Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, main_module);

	internal AssemblyDefinition()
	{
	}

	public void Dispose()
	{
		if (modules == null)
		{
			main_module.Dispose();
			return;
		}
		Collection<ModuleDefinition> collection = Modules;
		for (int i = 0; i < collection.Count; i++)
		{
			collection[i].Dispose();
		}
	}

	public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
	{
		return CreateAssembly(assemblyName, moduleName, new ModuleParameters
		{
			Kind = kind
		});
	}

	public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
	{
		if (assemblyName == null)
		{
			throw new ArgumentNullException("assemblyName");
		}
		if (moduleName == null)
		{
			throw new ArgumentNullException("moduleName");
		}
		Mixin.CheckParameters(parameters);
		if (parameters.Kind == ModuleKind.NetModule)
		{
			throw new ArgumentException("kind");
		}
		AssemblyDefinition assembly = ModuleDefinition.CreateModule(moduleName, parameters).Assembly;
		assembly.Name = assemblyName;
		return assembly;
	}

	public static AssemblyDefinition ReadAssembly(string fileName)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(fileName));
	}

	public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(fileName, parameters));
	}

	public static AssemblyDefinition ReadAssembly(Stream stream)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(stream));
	}

	public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters)
	{
		return ReadAssembly(ModuleDefinition.ReadModule(stream, parameters));
	}

	private static AssemblyDefinition ReadAssembly(ModuleDefinition module)
	{
		return module.Assembly ?? throw new ArgumentException();
	}

	public void Write(string fileName)
	{
		Write(fileName, new WriterParameters());
	}

	public void Write(string fileName, WriterParameters parameters)
	{
		main_module.Write(fileName, parameters);
	}

	public void Write()
	{
		main_module.Write();
	}

	public void Write(WriterParameters parameters)
	{
		main_module.Write(parameters);
	}

	public void Write(Stream stream)
	{
		Write(stream, new WriterParameters());
	}

	public void Write(Stream stream, WriterParameters parameters)
	{
		main_module.Write(stream, parameters);
	}

	public override string ToString()
	{
		return FullName;
	}
}


using System;

[Flags]
internal enum AssemblyAttributes : uint
{
	PublicKey = 1u,
	SideBySideCompatible = 0u,
	Retargetable = 0x100u,
	WindowsRuntime = 0x200u,
	DisableJITCompileOptimizer = 0x4000u,
	EnableJITCompileTracking = 0x8000u
}


internal enum AssemblyHashAlgorithm : uint
{
	None = 0u,
	MD5 = 32771u,
	SHA1 = 32772u,
	SHA256 = 32780u,
	SHA384 = 32781u,
	SHA512 = 32782u,
	Reserved = 32771u
}


using Mono.Cecil;

internal sealed class AssemblyLinkedResource : Resource
{
	private AssemblyNameReference reference;

	public AssemblyNameReference Assembly
	{
		get
		{
			return reference;
		}
		set
		{
			reference = value;
		}
	}

	public override ResourceType ResourceType => ResourceType.AssemblyLinked;

	public AssemblyLinkedResource(string name, ManifestResourceAttributes flags)
		: base(name, flags)
	{
	}

	public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
		: base(name, flags)
	{
		this.reference = reference;
	}
}


using System;
using Mono;
using Mono.Cecil;

internal sealed class AssemblyNameDefinition : AssemblyNameReference
{
	public override byte[] Hash => Empty<byte>.Array;

	internal AssemblyNameDefinition()
	{
		token = new MetadataToken(TokenType.Assembly, 1);
	}

	public AssemblyNameDefinition(string name, Version version)
		: base(name, version)
	{
		token = new MetadataToken(TokenType.Assembly, 1);
	}
}


using System;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using Mono;
using Mono.Cecil;

internal class AssemblyNameReference : IMetadataScope, IMetadataTokenProvider
{
	private string name;

	private string culture;

	private Version version;

	private uint attributes;

	private byte[] public_key;

	private byte[] public_key_token;

	private AssemblyHashAlgorithm hash_algorithm;

	private byte[] hash;

	internal MetadataToken token;

	private string full_name;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
			full_name = null;
		}
	}

	public string Culture
	{
		get
		{
			return culture;
		}
		set
		{
			culture = value;
			full_name = null;
		}
	}

	public Version Version
	{
		get
		{
			return version;
		}
		set
		{
			version = Mixin.CheckVersion(value);
			full_name = null;
		}
	}

	public AssemblyAttributes Attributes
	{
		get
		{
			return (AssemblyAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public bool HasPublicKey
	{
		get
		{
			return attributes.GetAttributes(1u);
		}
		set
		{
			attributes = attributes.SetAttributes(1u, value);
		}
	}

	public bool IsSideBySideCompatible
	{
		get
		{
			return attributes.GetAttributes(0u);
		}
		set
		{
			attributes = attributes.SetAttributes(0u, value);
		}
	}

	public bool IsRetargetable
	{
		get
		{
			return attributes.GetAttributes(256u);
		}
		set
		{
			attributes = attributes.SetAttributes(256u, value);
		}
	}

	public bool IsWindowsRuntime
	{
		get
		{
			return attributes.GetAttributes(512u);
		}
		set
		{
			attributes = attributes.SetAttributes(512u, value);
		}
	}

	public byte[] PublicKey
	{
		get
		{
			return public_key ?? Empty<byte>.Array;
		}
		set
		{
			public_key = value;
			HasPublicKey = !public_key.IsNullOrEmpty();
			public_key_token = null;
			full_name = null;
		}
	}

	public byte[] PublicKeyToken
	{
		get
		{
			if (public_key_token == null && !public_key.IsNullOrEmpty())
			{
				byte[] array = HashPublicKey();
				byte[] array2 = new byte[8];
				Array.Copy(array, array.Length - 8, array2, 0, 8);
				Array.Reverse((Array)array2, 0, 8);
				Interlocked.CompareExchange(ref public_key_token, array2, null);
			}
			return public_key_token ?? Empty<byte>.Array;
		}
		set
		{
			public_key_token = value;
			full_name = null;
		}
	}

	public virtual MetadataScopeType MetadataScopeType => MetadataScopeType.AssemblyNameReference;

	public string FullName
	{
		get
		{
			if (full_name != null)
			{
				return full_name;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(name);
			stringBuilder.Append(", ");
			stringBuilder.Append("Version=");
			stringBuilder.Append(version.ToString(4));
			stringBuilder.Append(", ");
			stringBuilder.Append("Culture=");
			stringBuilder.Append(string.IsNullOrEmpty(culture) ? "neutral" : culture);
			stringBuilder.Append(", ");
			stringBuilder.Append("PublicKeyToken=");
			byte[] publicKeyToken = PublicKeyToken;
			if (!publicKeyToken.IsNullOrEmpty() && publicKeyToken.Length != 0)
			{
				for (int i = 0; i < publicKeyToken.Length; i++)
				{
					stringBuilder.Append(publicKeyToken[i].ToString("x2"));
				}
			}
			else
			{
				stringBuilder.Append("null");
			}
			if (IsRetargetable)
			{
				stringBuilder.Append(", ");
				stringBuilder.Append("Retargetable=Yes");
			}
			Interlocked.CompareExchange(ref full_name, stringBuilder.ToString(), null);
			return full_name;
		}
	}

	public AssemblyHashAlgorithm HashAlgorithm
	{
		get
		{
			return hash_algorithm;
		}
		set
		{
			hash_algorithm = value;
		}
	}

	public virtual byte[] Hash
	{
		get
		{
			return hash;
		}
		set
		{
			hash = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	private byte[] HashPublicKey()
	{
		HashAlgorithm hashAlgorithm = ((hash_algorithm != AssemblyHashAlgorithm.MD5) ? ((HashAlgorithm)SHA1.Create()) : ((HashAlgorithm)MD5.Create()));
		using (hashAlgorithm)
		{
			return hashAlgorithm.ComputeHash(public_key);
		}
	}

	public static AssemblyNameReference Parse(string fullName)
	{
		if (fullName == null)
		{
			throw new ArgumentNullException("fullName");
		}
		if (fullName.Length == 0)
		{
			throw new ArgumentException("Name can not be empty");
		}
		AssemblyNameReference assemblyNameReference = new AssemblyNameReference();
		string[] array = fullName.Split(new char[1] { ',' });
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (i == 0)
			{
				assemblyNameReference.Name = text;
				continue;
			}
			string[] array2 = text.Split(new char[1] { '=' });
			if (array2.Length != 2)
			{
				throw new ArgumentException("Malformed name");
			}
			switch (array2[0].ToLowerInvariant())
			{
			case "version":
				assemblyNameReference.Version = new Version(array2[1]);
				break;
			case "culture":
				assemblyNameReference.Culture = ((array2[1] == "neutral") ? "" : array2[1]);
				break;
			case "publickeytoken":
			{
				string text2 = array2[1];
				if (!(text2 == "null"))
				{
					assemblyNameReference.PublicKeyToken = new byte[text2.Length / 2];
					for (int j = 0; j < assemblyNameReference.PublicKeyToken.Length; j++)
					{
						assemblyNameReference.PublicKeyToken[j] = byte.Parse(text2.Substring(j * 2, 2), NumberStyles.HexNumber);
					}
				}
				break;
			}
			}
		}
		return assemblyNameReference;
	}

	internal AssemblyNameReference()
	{
		version = Mixin.ZeroVersion;
		token = new MetadataToken(TokenType.AssemblyRef);
	}

	public AssemblyNameReference(string name, Version version)
	{
		Mixin.CheckName(name);
		this.name = name;
		this.version = Mixin.CheckVersion(version);
		hash_algorithm = AssemblyHashAlgorithm.None;
		token = new MetadataToken(TokenType.AssemblyRef);
	}

	public override string ToString()
	{
		return FullName;
	}
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal abstract class ModuleReader
{
	protected readonly ModuleDefinition module;

	protected ModuleReader(Image image, ReadingMode mode)
	{
		module = new ModuleDefinition(image);
		module.ReadingMode = mode;
	}

	protected abstract void ReadModule();

	public abstract void ReadSymbols(ModuleDefinition module);

	protected void ReadModuleManifest(MetadataReader reader)
	{
		reader.Populate(module);
		ReadAssembly(reader);
	}

	private void ReadAssembly(MetadataReader reader)
	{
		AssemblyNameDefinition assemblyNameDefinition = reader.ReadAssemblyNameDefinition();
		if (assemblyNameDefinition == null)
		{
			module.kind = ModuleKind.NetModule;
			return;
		}
		AssemblyDefinition assemblyDefinition = new AssemblyDefinition();
		assemblyDefinition.Name = assemblyNameDefinition;
		module.assembly = assemblyDefinition;
		assemblyDefinition.main_module = module;
	}

	public static ModuleDefinition CreateModule(Image image, ReaderParameters parameters)
	{
		ModuleReader moduleReader = CreateModuleReader(image, parameters.ReadingMode);
		ModuleDefinition moduleDefinition = moduleReader.module;
		if (parameters.assembly_resolver != null)
		{
			moduleDefinition.assembly_resolver = Disposable.NotOwned(parameters.assembly_resolver);
		}
		if (parameters.metadata_resolver != null)
		{
			moduleDefinition.metadata_resolver = parameters.metadata_resolver;
		}
		if (parameters.metadata_importer_provider != null)
		{
			moduleDefinition.metadata_importer = parameters.metadata_importer_provider.GetMetadataImporter(moduleDefinition);
		}
		if (parameters.reflection_importer_provider != null)
		{
			moduleDefinition.reflection_importer = parameters.reflection_importer_provider.GetReflectionImporter(moduleDefinition);
		}
		GetMetadataKind(moduleDefinition, parameters);
		moduleReader.ReadModule();
		ReadSymbols(moduleDefinition, parameters);
		moduleReader.ReadSymbols(moduleDefinition);
		if (parameters.ReadingMode == ReadingMode.Immediate)
		{
			moduleDefinition.MetadataSystem.Clear();
		}
		return moduleDefinition;
	}

	private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters)
	{
		ISymbolReaderProvider symbolReaderProvider = parameters.SymbolReaderProvider;
		if (symbolReaderProvider == null && parameters.ReadSymbols)
		{
			symbolReaderProvider = new DefaultSymbolReaderProvider();
		}
		if (symbolReaderProvider != null)
		{
			module.SymbolReaderProvider = symbolReaderProvider;
			ISymbolReader symbolReader = ((parameters.SymbolStream != null) ? symbolReaderProvider.GetSymbolReader(module, parameters.SymbolStream) : symbolReaderProvider.GetSymbolReader(module, module.FileName));
			if (symbolReader != null)
			{
				try
				{
					module.ReadSymbols(symbolReader, parameters.ThrowIfSymbolsAreNotMatching);
				}
				catch (Exception)
				{
					symbolReader.Dispose();
					throw;
				}
			}
		}
		if (module.Image.HasDebugTables())
		{
			module.ReadSymbols(new PortablePdbReader(module.Image, module));
		}
	}

	private static void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters)
	{
		if (!parameters.ApplyWindowsRuntimeProjections)
		{
			module.MetadataKind = MetadataKind.Ecma335;
			return;
		}
		string runtimeVersion = module.RuntimeVersion;
		if (!runtimeVersion.Contains("WindowsRuntime"))
		{
			module.MetadataKind = MetadataKind.Ecma335;
		}
		else if (runtimeVersion.Contains("CLR"))
		{
			module.MetadataKind = MetadataKind.ManagedWindowsMetadata;
		}
		else
		{
			module.MetadataKind = MetadataKind.WindowsMetadata;
		}
	}

	private static ModuleReader CreateModuleReader(Image image, ReadingMode mode)
	{
		return mode switch
		{
			ReadingMode.Immediate => new ImmediateModuleReader(image), 
			ReadingMode.Deferred => new DeferredModuleReader(image), 
			_ => throw new ArgumentException(), 
		};
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class ImmediateModuleReader : ModuleReader
{
	private bool resolve_attributes;

	public ImmediateModuleReader(Image image)
		: base(image, ReadingMode.Immediate)
	{
	}

	protected override void ReadModule()
	{
		module.Read(module, delegate(ModuleDefinition module, MetadataReader reader)
		{
			ReadModuleManifest(reader);
			ReadModule(module, resolve_attributes: true);
		});
	}

	public void ReadModule(ModuleDefinition module, bool resolve_attributes)
	{
		this.resolve_attributes = resolve_attributes;
		if (module.HasAssemblyReferences)
		{
			Mixin.Read(module.AssemblyReferences);
		}
		if (module.HasResources)
		{
			Mixin.Read(module.Resources);
		}
		if (module.HasModuleReferences)
		{
			Mixin.Read(module.ModuleReferences);
		}
		if (module.HasTypes)
		{
			ReadTypes(module.Types);
		}
		if (module.HasExportedTypes)
		{
			Mixin.Read(module.ExportedTypes);
		}
		ReadCustomAttributes(module);
		AssemblyDefinition assembly = module.Assembly;
		if (module.kind != ModuleKind.NetModule && assembly != null)
		{
			ReadCustomAttributes(assembly);
			ReadSecurityDeclarations(assembly);
		}
	}

	private void ReadTypes(Collection<TypeDefinition> types)
	{
		for (int i = 0; i < types.Count; i++)
		{
			ReadType(types[i]);
		}
	}

	private void ReadType(TypeDefinition type)
	{
		ReadGenericParameters(type);
		if (type.HasInterfaces)
		{
			ReadInterfaces(type);
		}
		if (type.HasNestedTypes)
		{
			ReadTypes(type.NestedTypes);
		}
		if (type.HasLayoutInfo)
		{
			Mixin.Read(type.ClassSize);
		}
		if (type.HasFields)
		{
			ReadFields(type);
		}
		if (type.HasMethods)
		{
			ReadMethods(type);
		}
		if (type.HasProperties)
		{
			ReadProperties(type);
		}
		if (type.HasEvents)
		{
			ReadEvents(type);
		}
		ReadSecurityDeclarations(type);
		ReadCustomAttributes(type);
	}

	private void ReadInterfaces(TypeDefinition type)
	{
		Collection<InterfaceImplementation> interfaces = type.Interfaces;
		for (int i = 0; i < interfaces.Count; i++)
		{
			ReadCustomAttributes(interfaces[i]);
		}
	}

	private void ReadGenericParameters(IGenericParameterProvider provider)
	{
		if (!provider.HasGenericParameters)
		{
			return;
		}
		Collection<GenericParameter> genericParameters = provider.GenericParameters;
		for (int i = 0; i < genericParameters.Count; i++)
		{
			GenericParameter genericParameter = genericParameters[i];
			if (genericParameter.HasConstraints)
			{
				ReadGenericParameterConstraints(genericParameter);
			}
			ReadCustomAttributes(genericParameter);
		}
	}

	private void ReadGenericParameterConstraints(GenericParameter parameter)
	{
		Collection<GenericParameterConstraint> constraints = parameter.Constraints;
		for (int i = 0; i < constraints.Count; i++)
		{
			ReadCustomAttributes(constraints[i]);
		}
	}

	private void ReadSecurityDeclarations(ISecurityDeclarationProvider provider)
	{
		if (!provider.HasSecurityDeclarations)
		{
			return;
		}
		Collection<SecurityDeclaration> securityDeclarations = provider.SecurityDeclarations;
		if (resolve_attributes)
		{
			for (int i = 0; i < securityDeclarations.Count; i++)
			{
				Mixin.Read(securityDeclarations[i].SecurityAttributes);
			}
		}
	}

	private void ReadCustomAttributes(ICustomAttributeProvider provider)
	{
		if (!provider.HasCustomAttributes)
		{
			return;
		}
		Collection<CustomAttribute> customAttributes = provider.CustomAttributes;
		if (resolve_attributes)
		{
			for (int i = 0; i < customAttributes.Count; i++)
			{
				Mixin.Read(customAttributes[i].ConstructorArguments);
			}
		}
	}

	private void ReadFields(TypeDefinition type)
	{
		Collection<FieldDefinition> fields = type.Fields;
		for (int i = 0; i < fields.Count; i++)
		{
			FieldDefinition fieldDefinition = fields[i];
			if (fieldDefinition.HasConstant)
			{
				Mixin.Read(fieldDefinition.Constant);
			}
			if (fieldDefinition.HasLayoutInfo)
			{
				Mixin.Read(fieldDefinition.Offset);
			}
			if (fieldDefinition.RVA > 0)
			{
				Mixin.Read(fieldDefinition.InitialValue);
			}
			if (fieldDefinition.HasMarshalInfo)
			{
				Mixin.Read(fieldDefinition.MarshalInfo);
			}
			ReadCustomAttributes(fieldDefinition);
		}
	}

	private void ReadMethods(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			ReadGenericParameters(methodDefinition);
			if (methodDefinition.HasParameters)
			{
				ReadParameters(methodDefinition);
			}
			if (methodDefinition.HasOverrides)
			{
				Mixin.Read(methodDefinition.Overrides);
			}
			if (methodDefinition.IsPInvokeImpl)
			{
				Mixin.Read(methodDefinition.PInvokeInfo);
			}
			ReadSecurityDeclarations(methodDefinition);
			ReadCustomAttributes(methodDefinition);
			MethodReturnType methodReturnType = methodDefinition.MethodReturnType;
			if (methodReturnType.HasConstant)
			{
				Mixin.Read(methodReturnType.Constant);
			}
			if (methodReturnType.HasMarshalInfo)
			{
				Mixin.Read(methodReturnType.MarshalInfo);
			}
			ReadCustomAttributes(methodReturnType);
		}
	}

	private void ReadParameters(MethodDefinition method)
	{
		Collection<ParameterDefinition> parameters = method.Parameters;
		for (int i = 0; i < parameters.Count; i++)
		{
			ParameterDefinition parameterDefinition = parameters[i];
			if (parameterDefinition.HasConstant)
			{
				Mixin.Read(parameterDefinition.Constant);
			}
			if (parameterDefinition.HasMarshalInfo)
			{
				Mixin.Read(parameterDefinition.MarshalInfo);
			}
			ReadCustomAttributes(parameterDefinition);
		}
	}

	private void ReadProperties(TypeDefinition type)
	{
		Collection<PropertyDefinition> properties = type.Properties;
		for (int i = 0; i < properties.Count; i++)
		{
			PropertyDefinition propertyDefinition = properties[i];
			Mixin.Read(propertyDefinition.GetMethod);
			if (propertyDefinition.HasConstant)
			{
				Mixin.Read(propertyDefinition.Constant);
			}
			ReadCustomAttributes(propertyDefinition);
		}
	}

	private void ReadEvents(TypeDefinition type)
	{
		Collection<EventDefinition> events = type.Events;
		for (int i = 0; i < events.Count; i++)
		{
			EventDefinition eventDefinition = events[i];
			Mixin.Read(eventDefinition.AddMethod);
			ReadCustomAttributes(eventDefinition);
		}
	}

	public override void ReadSymbols(ModuleDefinition module)
	{
		if (module.symbol_reader != null)
		{
			ReadTypesSymbols(module.Types, module.symbol_reader);
		}
	}

	private void ReadTypesSymbols(Collection<TypeDefinition> types, ISymbolReader symbol_reader)
	{
		for (int i = 0; i < types.Count; i++)
		{
			TypeDefinition typeDefinition = types[i];
			if (typeDefinition.HasNestedTypes)
			{
				ReadTypesSymbols(typeDefinition.NestedTypes, symbol_reader);
			}
			if (typeDefinition.HasMethods)
			{
				ReadMethodsSymbols(typeDefinition, symbol_reader);
			}
		}
	}

	private void ReadMethodsSymbols(TypeDefinition type, ISymbolReader symbol_reader)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			if (methodDefinition.HasBody && methodDefinition.token.RID != 0 && methodDefinition.debug_info == null)
			{
				methodDefinition.debug_info = symbol_reader.Read(methodDefinition);
			}
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.PE;

internal sealed class DeferredModuleReader : ModuleReader
{
	public DeferredModuleReader(Image image)
		: base(image, ReadingMode.Deferred)
	{
	}

	protected override void ReadModule()
	{
		module.Read(module, delegate(ModuleDefinition _, MetadataReader reader)
		{
			ReadModuleManifest(reader);
		});
	}

	public override void ReadSymbols(ModuleDefinition module)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class MetadataReader : ByteBuffer
{
	internal readonly Image image;

	internal readonly ModuleDefinition module;

	internal readonly MetadataSystem metadata;

	internal CodeReader code;

	internal IGenericContext context;

	private readonly MetadataReader metadata_reader;

	public MetadataReader(ModuleDefinition module)
		: base(module.Image.TableHeap.data)
	{
		image = module.Image;
		this.module = module;
		metadata = module.MetadataSystem;
		code = new CodeReader(this);
	}

	public MetadataReader(Image image, ModuleDefinition module, MetadataReader metadata_reader)
		: base(image.TableHeap.data)
	{
		this.image = image;
		this.module = module;
		metadata = module.MetadataSystem;
		this.metadata_reader = metadata_reader;
	}

	private int GetCodedIndexSize(CodedIndex index)
	{
		return image.GetCodedIndexSize(index);
	}

	private uint ReadByIndexSize(int size)
	{
		if (size == 4)
		{
			return ReadUInt32();
		}
		return ReadUInt16();
	}

	private byte[] ReadBlob()
	{
		BlobHeap blobHeap = image.BlobHeap;
		if (blobHeap == null)
		{
			position += 2;
			return Empty<byte>.Array;
		}
		return blobHeap.Read(ReadBlobIndex());
	}

	private byte[] ReadBlob(uint signature)
	{
		BlobHeap blobHeap = image.BlobHeap;
		if (blobHeap == null)
		{
			return Empty<byte>.Array;
		}
		return blobHeap.Read(signature);
	}

	private uint ReadBlobIndex()
	{
		return ReadByIndexSize(image.BlobHeap?.IndexSize ?? 2);
	}

	private void GetBlobView(uint signature, out byte[] blob, out int index, out int count)
	{
		BlobHeap blobHeap = image.BlobHeap;
		if (blobHeap == null)
		{
			blob = null;
			index = (count = 0);
		}
		else
		{
			blobHeap.GetView(signature, out blob, out index, out count);
		}
	}

	private string ReadString()
	{
		return image.StringHeap.Read(ReadByIndexSize(image.StringHeap.IndexSize));
	}

	private uint ReadStringIndex()
	{
		return ReadByIndexSize(image.StringHeap.IndexSize);
	}

	private Guid ReadGuid()
	{
		return image.GuidHeap.Read(ReadByIndexSize(image.GuidHeap.IndexSize));
	}

	private uint ReadTableIndex(Table table)
	{
		return ReadByIndexSize(image.GetTableIndexSize(table));
	}

	private MetadataToken ReadMetadataToken(CodedIndex index)
	{
		return index.GetMetadataToken(ReadByIndexSize(GetCodedIndexSize(index)));
	}

	private int MoveTo(Table table)
	{
		TableInformation tableInformation = image.TableHeap[table];
		if (tableInformation.Length != 0)
		{
			position = (int)tableInformation.Offset;
		}
		return (int)tableInformation.Length;
	}

	private bool MoveTo(Table table, uint row)
	{
		TableInformation tableInformation = image.TableHeap[table];
		uint num = tableInformation.Length;
		if (num == 0 || row > num)
		{
			return false;
		}
		position = (int)(tableInformation.Offset + tableInformation.RowSize * (row - 1));
		return true;
	}

	public AssemblyNameDefinition ReadAssemblyNameDefinition()
	{
		if (MoveTo(Table.Assembly) == 0)
		{
			return null;
		}
		AssemblyNameDefinition assemblyNameDefinition = new AssemblyNameDefinition();
		assemblyNameDefinition.HashAlgorithm = (AssemblyHashAlgorithm)ReadUInt32();
		PopulateVersionAndFlags(assemblyNameDefinition);
		assemblyNameDefinition.PublicKey = ReadBlob();
		PopulateNameAndCulture(assemblyNameDefinition);
		return assemblyNameDefinition;
	}

	public ModuleDefinition Populate(ModuleDefinition module)
	{
		if (MoveTo(Table.Module) == 0)
		{
			return module;
		}
		Advance(2);
		module.Name = ReadString();
		module.Mvid = ReadGuid();
		return module;
	}

	private void InitializeAssemblyReferences()
	{
		if (metadata.AssemblyReferences != null)
		{
			return;
		}
		int num = MoveTo(Table.AssemblyRef);
		AssemblyNameReference[] array = (metadata.AssemblyReferences = new AssemblyNameReference[num]);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			AssemblyNameReference assemblyNameReference = new AssemblyNameReference();
			assemblyNameReference.token = new MetadataToken(TokenType.AssemblyRef, num2 + 1);
			PopulateVersionAndFlags(assemblyNameReference);
			byte[] array2 = ReadBlob();
			if (assemblyNameReference.HasPublicKey)
			{
				assemblyNameReference.PublicKey = array2;
			}
			else
			{
				assemblyNameReference.PublicKeyToken = array2;
			}
			PopulateNameAndCulture(assemblyNameReference);
			assemblyNameReference.Hash = ReadBlob();
			array[num2] = assemblyNameReference;
		}
	}

	public Collection<AssemblyNameReference> ReadAssemblyReferences()
	{
		InitializeAssemblyReferences();
		Collection<AssemblyNameReference> collection = new Collection<AssemblyNameReference>(metadata.AssemblyReferences);
		if (module.IsWindowsMetadata())
		{
			module.Projections.AddVirtualReferences(collection);
		}
		return collection;
	}

	public MethodDefinition ReadEntryPoint()
	{
		if (module.Image.EntryPointToken == 0)
		{
			return null;
		}
		return GetMethodDefinition(new MetadataToken(module.Image.EntryPointToken).RID);
	}

	public Collection<ModuleDefinition> ReadModules()
	{
		Collection<ModuleDefinition> collection = new Collection<ModuleDefinition>(1);
		collection.Add(module);
		int num = MoveTo(Table.File);
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			uint num3 = ReadUInt32();
			string name = ReadString();
			ReadBlobIndex();
			if (num3 == 0)
			{
				ReaderParameters parameters = new ReaderParameters
				{
					ReadingMode = module.ReadingMode,
					SymbolReaderProvider = module.SymbolReaderProvider,
					AssemblyResolver = module.AssemblyResolver
				};
				ModuleDefinition moduleDefinition = ModuleDefinition.ReadModule(GetModuleFileName(name), parameters);
				moduleDefinition.assembly = module.assembly;
				collection.Add(moduleDefinition);
			}
		}
		return collection;
	}

	private string GetModuleFileName(string name)
	{
		if (module.FileName == null)
		{
			throw new NotSupportedException();
		}
		return Path.Combine(Path.GetDirectoryName(module.FileName), name);
	}

	private void InitializeModuleReferences()
	{
		if (metadata.ModuleReferences == null)
		{
			int num = MoveTo(Table.ModuleRef);
			ModuleReference[] array = (metadata.ModuleReferences = new ModuleReference[num]);
			for (uint num2 = 0u; num2 < num; num2++)
			{
				ModuleReference moduleReference = new ModuleReference(ReadString());
				moduleReference.token = new MetadataToken(TokenType.ModuleRef, num2 + 1);
				array[num2] = moduleReference;
			}
		}
	}

	public Collection<ModuleReference> ReadModuleReferences()
	{
		InitializeModuleReferences();
		return new Collection<ModuleReference>(metadata.ModuleReferences);
	}

	public bool HasFileResource()
	{
		int num = MoveTo(Table.File);
		if (num == 0)
		{
			return false;
		}
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			if (ReadFileRecord(num2).Col1 == Mono.Cecil.FileAttributes.ContainsNoMetaData)
			{
				return true;
			}
		}
		return false;
	}

	public Collection<Resource> ReadResources()
	{
		int num = MoveTo(Table.ManifestResource);
		Collection<Resource> collection = new Collection<Resource>(num);
		for (int i = 1; i <= num; i++)
		{
			uint offset = ReadUInt32();
			ManifestResourceAttributes manifestResourceAttributes = (ManifestResourceAttributes)ReadUInt32();
			string name = ReadString();
			MetadataToken scope = ReadMetadataToken(CodedIndex.Implementation);
			Resource item;
			if (scope.RID == 0)
			{
				item = new EmbeddedResource(name, manifestResourceAttributes, offset, this);
			}
			else if (scope.TokenType == TokenType.AssemblyRef)
			{
				item = new AssemblyLinkedResource(name, manifestResourceAttributes)
				{
					Assembly = (AssemblyNameReference)GetTypeReferenceScope(scope)
				};
			}
			else
			{
				if (scope.TokenType != TokenType.File)
				{
					continue;
				}
				Row<Mono.Cecil.FileAttributes, string, uint> row = ReadFileRecord(scope.RID);
				item = new LinkedResource(name, manifestResourceAttributes)
				{
					File = row.Col2,
					hash = ReadBlob(row.Col3)
				};
			}
			collection.Add(item);
		}
		return collection;
	}

	private Row<Mono.Cecil.FileAttributes, string, uint> ReadFileRecord(uint rid)
	{
		int num = position;
		if (!MoveTo(Table.File, rid))
		{
			throw new ArgumentException();
		}
		Row<Mono.Cecil.FileAttributes, string, uint> result = new Row<Mono.Cecil.FileAttributes, string, uint>((Mono.Cecil.FileAttributes)ReadUInt32(), ReadString(), ReadBlobIndex());
		position = num;
		return result;
	}

	public byte[] GetManagedResource(uint offset)
	{
		return image.GetReaderAt(image.Resources.VirtualAddress, offset, delegate(uint o, BinaryStreamReader reader)
		{
			reader.Advance((int)o);
			return reader.ReadBytes(reader.ReadInt32());
		}) ?? Empty<byte>.Array;
	}

	private void PopulateVersionAndFlags(AssemblyNameReference name)
	{
		name.Version = new Version(ReadUInt16(), ReadUInt16(), ReadUInt16(), ReadUInt16());
		name.Attributes = (AssemblyAttributes)ReadUInt32();
	}

	private void PopulateNameAndCulture(AssemblyNameReference name)
	{
		name.Name = ReadString();
		name.Culture = ReadString();
	}

	public TypeDefinitionCollection ReadTypes()
	{
		InitializeTypeDefinitions();
		TypeDefinition[] types = metadata.Types;
		int capacity = types.Length - metadata.NestedTypes.Count;
		TypeDefinitionCollection typeDefinitionCollection = new TypeDefinitionCollection(module, capacity);
		foreach (TypeDefinition typeDefinition in types)
		{
			if (!IsNested(typeDefinition.Attributes))
			{
				typeDefinitionCollection.Add(typeDefinition);
			}
		}
		if (image.HasTable(Table.MethodPtr) || image.HasTable(Table.FieldPtr))
		{
			CompleteTypes();
		}
		return typeDefinitionCollection;
	}

	private void CompleteTypes()
	{
		TypeDefinition[] types = metadata.Types;
		foreach (TypeDefinition obj in types)
		{
			Mixin.Read(obj.Fields);
			Mixin.Read(obj.Methods);
		}
	}

	private void InitializeTypeDefinitions()
	{
		if (metadata.Types != null)
		{
			return;
		}
		InitializeNestedTypes();
		InitializeFields();
		InitializeMethods();
		int num = MoveTo(Table.TypeDef);
		TypeDefinition[] array = (metadata.Types = new TypeDefinition[num]);
		for (uint num2 = 0u; num2 < num; num2++)
		{
			if (array[num2] == null)
			{
				array[num2] = ReadType(num2 + 1);
			}
		}
		if (module.IsWindowsMetadata())
		{
			for (uint num3 = 0u; num3 < num; num3++)
			{
				WindowsRuntimeProjections.Project(array[num3]);
			}
		}
	}

	private static bool IsNested(TypeAttributes attributes)
	{
		TypeAttributes typeAttributes = attributes & TypeAttributes.VisibilityMask;
		if (typeAttributes - 2 <= TypeAttributes.NestedAssembly)
		{
			return true;
		}
		return false;
	}

	public bool HasNestedTypes(TypeDefinition type)
	{
		InitializeNestedTypes();
		if (!metadata.TryGetNestedTypeMapping(type, out var mapping))
		{
			return false;
		}
		return mapping.Count > 0;
	}

	public Collection<TypeDefinition> ReadNestedTypes(TypeDefinition type)
	{
		InitializeNestedTypes();
		if (!metadata.TryGetNestedTypeMapping(type, out var mapping))
		{
			return new MemberDefinitionCollection<TypeDefinition>(type);
		}
		MemberDefinitionCollection<TypeDefinition> memberDefinitionCollection = new MemberDefinitionCollection<TypeDefinition>(type, mapping.Count);
		for (int i = 0; i < mapping.Count; i++)
		{
			TypeDefinition typeDefinition = GetTypeDefinition(mapping[i]);
			if (typeDefinition != null)
			{
				memberDefinitionCollection.Add(typeDefinition);
			}
		}
		return memberDefinitionCollection;
	}

	private void InitializeNestedTypes()
	{
		if (metadata.NestedTypes != null)
		{
			return;
		}
		int num = MoveTo(Table.NestedClass);
		metadata.NestedTypes = new Dictionary<uint, Collection<uint>>(num);
		metadata.ReverseNestedTypes = new Dictionary<uint, uint>(num);
		if (num != 0)
		{
			for (int i = 1; i <= num; i++)
			{
				uint nested = ReadTableIndex(Table.TypeDef);
				uint declaring = ReadTableIndex(Table.TypeDef);
				AddNestedMapping(declaring, nested);
			}
		}
	}

	private void AddNestedMapping(uint declaring, uint nested)
	{
		metadata.SetNestedTypeMapping(declaring, AddMapping(metadata.NestedTypes, declaring, nested));
		metadata.SetReverseNestedTypeMapping(nested, declaring);
	}

	private static Collection<TValue> AddMapping<TKey, TValue>(Dictionary<TKey, Collection<TValue>> cache, TKey key, TValue value)
	{
		if (!cache.TryGetValue(key, out var value2))
		{
			value2 = new Collection<TValue>();
		}
		value2.Add(value);
		return value2;
	}

	private TypeDefinition ReadType(uint rid)
	{
		if (!MoveTo(Table.TypeDef, rid))
		{
			return null;
		}
		TypeAttributes attributes = (TypeAttributes)ReadUInt32();
		string name = ReadString();
		TypeDefinition typeDefinition = new TypeDefinition(ReadString(), name, attributes);
		typeDefinition.token = new MetadataToken(TokenType.TypeDef, rid);
		typeDefinition.scope = module;
		typeDefinition.module = module;
		metadata.AddTypeDefinition(typeDefinition);
		context = typeDefinition;
		typeDefinition.BaseType = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));
		typeDefinition.fields_range = ReadListRange(rid, Table.TypeDef, Table.Field);
		typeDefinition.methods_range = ReadListRange(rid, Table.TypeDef, Table.Method);
		if (IsNested(attributes))
		{
			typeDefinition.DeclaringType = GetNestedTypeDeclaringType(typeDefinition);
		}
		return typeDefinition;
	}

	private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type)
	{
		if (!metadata.TryGetReverseNestedTypeMapping(type, out var declaring))
		{
			return null;
		}
		return GetTypeDefinition(declaring);
	}

	private Mono.Cecil.Range ReadListRange(uint current_index, Table current, Table target)
	{
		Mono.Cecil.Range result = default(Mono.Cecil.Range);
		uint num = ReadTableIndex(target);
		if (num == 0)
		{
			return result;
		}
		TableInformation tableInformation = image.TableHeap[current];
		uint num2;
		if (current_index == tableInformation.Length)
		{
			num2 = image.TableHeap[target].Length + 1;
		}
		else
		{
			int num3 = position;
			position += (int)(tableInformation.RowSize - image.GetTableIndexSize(target));
			num2 = ReadTableIndex(target);
			position = num3;
		}
		result.Start = num;
		result.Length = num2 - num;
		return result;
	}

	public Row<short, int> ReadTypeLayout(TypeDefinition type)
	{
		InitializeTypeLayouts();
		uint rID = type.token.RID;
		if (!metadata.ClassLayouts.TryGetValue(rID, out var value))
		{
			return new Row<short, int>(-1, -1);
		}
		type.PackingSize = (short)value.Col1;
		type.ClassSize = (int)value.Col2;
		metadata.ClassLayouts.Remove(rID);
		return new Row<short, int>((short)value.Col1, (int)value.Col2);
	}

	private void InitializeTypeLayouts()
	{
		if (metadata.ClassLayouts == null)
		{
			int num = MoveTo(Table.ClassLayout);
			Dictionary<uint, Row<ushort, uint>> dictionary = (metadata.ClassLayouts = new Dictionary<uint, Row<ushort, uint>>(num));
			for (uint num2 = 0u; num2 < num; num2++)
			{
				ushort col = ReadUInt16();
				uint col2 = ReadUInt32();
				uint key = ReadTableIndex(Table.TypeDef);
				dictionary.Add(key, new Row<ushort, uint>(col, col2));
			}
		}
	}

	public TypeReference GetTypeDefOrRef(MetadataToken token)
	{
		return (TypeReference)LookupToken(token);
	}

	public TypeDefinition GetTypeDefinition(uint rid)
	{
		InitializeTypeDefinitions();
		TypeDefinition typeDefinition = metadata.GetTypeDefinition(rid);
		if (typeDefinition != null)
		{
			return typeDefinition;
		}
		typeDefinition = ReadTypeDefinition(rid);
		if (module.IsWindowsMetadata())
		{
			WindowsRuntimeProjections.Project(typeDefinition);
		}
		return typeDefinition;
	}

	private TypeDefinition ReadTypeDefinition(uint rid)
	{
		if (!MoveTo(Table.TypeDef, rid))
		{
			return null;
		}
		return ReadType(rid);
	}

	private void InitializeTypeReferences()
	{
		if (metadata.TypeReferences == null)
		{
			metadata.TypeReferences = new TypeReference[image.GetTableLength(Table.TypeRef)];
		}
	}

	public TypeReference GetTypeReference(string scope, string full_name)
	{
		InitializeTypeReferences();
		int num = metadata.TypeReferences.Length;
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			TypeReference typeReference = GetTypeReference(num2);
			if (!(typeReference.FullName != full_name))
			{
				if (string.IsNullOrEmpty(scope))
				{
					return typeReference;
				}
				if (typeReference.Scope.Name == scope)
				{
					return typeReference;
				}
			}
		}
		return null;
	}

	private TypeReference GetTypeReference(uint rid)
	{
		InitializeTypeReferences();
		TypeReference typeReference = metadata.GetTypeReference(rid);
		if (typeReference != null)
		{
			return typeReference;
		}
		return ReadTypeReference(rid);
	}

	private TypeReference ReadTypeReference(uint rid)
	{
		if (!MoveTo(Table.TypeRef, rid))
		{
			return null;
		}
		TypeReference typeReference = null;
		MetadataToken metadataToken = ReadMetadataToken(CodedIndex.ResolutionScope);
		string name = ReadString();
		TypeReference typeReference2 = new TypeReference(ReadString(), name, module, null);
		typeReference2.token = new MetadataToken(TokenType.TypeRef, rid);
		metadata.AddTypeReference(typeReference2);
		IMetadataScope scope;
		if (metadataToken.TokenType == TokenType.TypeRef)
		{
			if (metadataToken.RID != rid)
			{
				typeReference = GetTypeDefOrRef(metadataToken);
				IMetadataScope metadataScope2;
				if (typeReference == null)
				{
					IMetadataScope metadataScope = module;
					metadataScope2 = metadataScope;
				}
				else
				{
					metadataScope2 = typeReference.Scope;
				}
				scope = metadataScope2;
			}
			else
			{
				scope = module;
			}
		}
		else
		{
			scope = GetTypeReferenceScope(metadataToken);
		}
		typeReference2.scope = scope;
		typeReference2.DeclaringType = typeReference;
		MetadataSystem.TryProcessPrimitiveTypeReference(typeReference2);
		if (typeReference2.Module.IsWindowsMetadata())
		{
			WindowsRuntimeProjections.Project(typeReference2);
		}
		return typeReference2;
	}

	private IMetadataScope GetTypeReferenceScope(MetadataToken scope)
	{
		if (scope.TokenType == TokenType.Module)
		{
			return module;
		}
		IMetadataScope[] array;
		switch (scope.TokenType)
		{
		case TokenType.AssemblyRef:
		{
			InitializeAssemblyReferences();
			IMetadataScope[] moduleReferences = metadata.AssemblyReferences;
			array = moduleReferences;
			break;
		}
		case TokenType.ModuleRef:
		{
			InitializeModuleReferences();
			IMetadataScope[] moduleReferences = metadata.ModuleReferences;
			array = moduleReferences;
			break;
		}
		default:
			throw new NotSupportedException();
		}
		uint num = scope.RID - 1;
		if (num < 0 || num >= array.Length)
		{
			return null;
		}
		return array[num];
	}

	public IEnumerable<TypeReference> GetTypeReferences()
	{
		InitializeTypeReferences();
		int tableLength = image.GetTableLength(Table.TypeRef);
		TypeReference[] array = new TypeReference[tableLength];
		for (uint num = 1u; num <= tableLength; num++)
		{
			array[num - 1] = GetTypeReference(num);
		}
		return array;
	}

	private TypeReference GetTypeSpecification(uint rid)
	{
		if (!MoveTo(Table.TypeSpec, rid))
		{
			return null;
		}
		TypeReference typeReference = ReadSignature(ReadBlobIndex()).ReadTypeSignature();
		if (typeReference.token.RID == 0)
		{
			typeReference.token = new MetadataToken(TokenType.TypeSpec, rid);
		}
		return typeReference;
	}

	private SignatureReader ReadSignature(uint signature)
	{
		return new SignatureReader(signature, this);
	}

	public bool HasInterfaces(TypeDefinition type)
	{
		InitializeInterfaces();
		Collection<Row<uint, MetadataToken>> mapping;
		return metadata.TryGetInterfaceMapping(type, out mapping);
	}

	public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type)
	{
		InitializeInterfaces();
		if (!metadata.TryGetInterfaceMapping(type, out var mapping))
		{
			return new InterfaceImplementationCollection(type);
		}
		InterfaceImplementationCollection interfaceImplementationCollection = new InterfaceImplementationCollection(type, mapping.Count);
		context = type;
		for (int i = 0; i < mapping.Count; i++)
		{
			interfaceImplementationCollection.Add(new InterfaceImplementation(GetTypeDefOrRef(mapping[i].Col2), new MetadataToken(TokenType.InterfaceImpl, mapping[i].Col1)));
		}
		return interfaceImplementationCollection;
	}

	private void InitializeInterfaces()
	{
		if (metadata.Interfaces == null)
		{
			int num = MoveTo(Table.InterfaceImpl);
			metadata.Interfaces = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(num);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint type = ReadTableIndex(Table.TypeDef);
				MetadataToken col = ReadMetadataToken(CodedIndex.TypeDefOrRef);
				AddInterfaceMapping(type, new Row<uint, MetadataToken>(num2, col));
			}
		}
	}

	private void AddInterfaceMapping(uint type, Row<uint, MetadataToken> @interface)
	{
		metadata.SetInterfaceMapping(type, AddMapping(metadata.Interfaces, type, @interface));
	}

	public Collection<FieldDefinition> ReadFields(TypeDefinition type)
	{
		Mono.Cecil.Range fields_range = type.fields_range;
		if (fields_range.Length == 0)
		{
			return new MemberDefinitionCollection<FieldDefinition>(type);
		}
		MemberDefinitionCollection<FieldDefinition> memberDefinitionCollection = new MemberDefinitionCollection<FieldDefinition>(type, (int)fields_range.Length);
		context = type;
		if (!MoveTo(Table.FieldPtr, fields_range.Start))
		{
			if (!MoveTo(Table.Field, fields_range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < fields_range.Length; num++)
			{
				ReadField(fields_range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.FieldPtr, Table.Field, fields_range, memberDefinitionCollection, ReadField);
		}
		return memberDefinitionCollection;
	}

	private void ReadField(uint field_rid, Collection<FieldDefinition> fields)
	{
		FieldAttributes attributes = (FieldAttributes)ReadUInt16();
		string name = ReadString();
		uint signature = ReadBlobIndex();
		FieldDefinition fieldDefinition = new FieldDefinition(name, attributes, ReadFieldType(signature));
		fieldDefinition.token = new MetadataToken(TokenType.Field, field_rid);
		metadata.AddFieldDefinition(fieldDefinition);
		if (!IsDeleted(fieldDefinition))
		{
			fields.Add(fieldDefinition);
			if (module.IsWindowsMetadata())
			{
				WindowsRuntimeProjections.Project(fieldDefinition);
			}
		}
	}

	private void InitializeFields()
	{
		if (metadata.Fields == null)
		{
			metadata.Fields = new FieldDefinition[image.GetTableLength(Table.Field)];
		}
	}

	private TypeReference ReadFieldType(uint signature)
	{
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.ReadByte() != 6)
		{
			throw new NotSupportedException();
		}
		return signatureReader.ReadTypeSignature();
	}

	public int ReadFieldRVA(FieldDefinition field)
	{
		InitializeFieldRVAs();
		uint rID = field.token.RID;
		if (!metadata.FieldRVAs.TryGetValue(rID, out var value))
		{
			return 0;
		}
		int fieldTypeSize = GetFieldTypeSize(field.FieldType);
		if (fieldTypeSize == 0 || value == 0)
		{
			return 0;
		}
		metadata.FieldRVAs.Remove(rID);
		field.InitialValue = GetFieldInitializeValue(fieldTypeSize, value);
		return (int)value;
	}

	private byte[] GetFieldInitializeValue(int size, uint rva)
	{
		return image.GetReaderAt(rva, size, (int s, BinaryStreamReader reader) => reader.ReadBytes(s)) ?? Empty<byte>.Array;
	}

	private static int GetFieldTypeSize(TypeReference type)
	{
		int result = 0;
		switch (type.etype)
		{
		case ElementType.Boolean:
		case ElementType.I1:
		case ElementType.U1:
			result = 1;
			break;
		case ElementType.Char:
		case ElementType.I2:
		case ElementType.U2:
			result = 2;
			break;
		case ElementType.I4:
		case ElementType.U4:
		case ElementType.R4:
			result = 4;
			break;
		case ElementType.I8:
		case ElementType.U8:
		case ElementType.R8:
			result = 8;
			break;
		case ElementType.Ptr:
		case ElementType.FnPtr:
			result = IntPtr.Size;
			break;
		case ElementType.CModReqD:
		case ElementType.CModOpt:
			return GetFieldTypeSize(((IModifierType)type).ElementType);
		default:
		{
			TypeDefinition typeDefinition = type.Resolve();
			if (typeDefinition != null && typeDefinition.HasLayoutInfo)
			{
				result = typeDefinition.ClassSize;
			}
			break;
		}
		}
		return result;
	}

	private void InitializeFieldRVAs()
	{
		if (metadata.FieldRVAs == null)
		{
			int num = MoveTo(Table.FieldRVA);
			Dictionary<uint, uint> dictionary = (metadata.FieldRVAs = new Dictionary<uint, uint>(num));
			for (int i = 0; i < num; i++)
			{
				uint value = ReadUInt32();
				uint key = ReadTableIndex(Table.Field);
				dictionary.Add(key, value);
			}
		}
	}

	public int ReadFieldLayout(FieldDefinition field)
	{
		InitializeFieldLayouts();
		uint rID = field.token.RID;
		if (!metadata.FieldLayouts.TryGetValue(rID, out var value))
		{
			return -1;
		}
		metadata.FieldLayouts.Remove(rID);
		return (int)value;
	}

	private void InitializeFieldLayouts()
	{
		if (metadata.FieldLayouts == null)
		{
			int num = MoveTo(Table.FieldLayout);
			Dictionary<uint, uint> dictionary = (metadata.FieldLayouts = new Dictionary<uint, uint>(num));
			for (int i = 0; i < num; i++)
			{
				uint value = ReadUInt32();
				uint key = ReadTableIndex(Table.Field);
				dictionary.Add(key, value);
			}
		}
	}

	public bool HasEvents(TypeDefinition type)
	{
		InitializeEvents();
		if (!metadata.TryGetEventsRange(type, out var range))
		{
			return false;
		}
		return range.Length != 0;
	}

	public Collection<EventDefinition> ReadEvents(TypeDefinition type)
	{
		InitializeEvents();
		if (!metadata.TryGetEventsRange(type, out var range))
		{
			return new MemberDefinitionCollection<EventDefinition>(type);
		}
		MemberDefinitionCollection<EventDefinition> memberDefinitionCollection = new MemberDefinitionCollection<EventDefinition>(type, (int)range.Length);
		if (range.Length == 0)
		{
			return memberDefinitionCollection;
		}
		context = type;
		if (!MoveTo(Table.EventPtr, range.Start))
		{
			if (!MoveTo(Table.Event, range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < range.Length; num++)
			{
				ReadEvent(range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.EventPtr, Table.Event, range, memberDefinitionCollection, ReadEvent);
		}
		return memberDefinitionCollection;
	}

	private void ReadEvent(uint event_rid, Collection<EventDefinition> events)
	{
		EventAttributes attributes = (EventAttributes)ReadUInt16();
		string name = ReadString();
		TypeReference typeDefOrRef = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));
		EventDefinition eventDefinition = new EventDefinition(name, attributes, typeDefOrRef);
		eventDefinition.token = new MetadataToken(TokenType.Event, event_rid);
		if (!IsDeleted(eventDefinition))
		{
			events.Add(eventDefinition);
		}
	}

	private void InitializeEvents()
	{
		if (metadata.Events == null)
		{
			int num = MoveTo(Table.EventMap);
			metadata.Events = new Dictionary<uint, Mono.Cecil.Range>(num);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint type_rid = ReadTableIndex(Table.TypeDef);
				Mono.Cecil.Range range = ReadListRange(num2, Table.EventMap, Table.Event);
				metadata.AddEventsRange(type_rid, range);
			}
		}
	}

	public bool HasProperties(TypeDefinition type)
	{
		InitializeProperties();
		if (!metadata.TryGetPropertiesRange(type, out var range))
		{
			return false;
		}
		return range.Length != 0;
	}

	public Collection<PropertyDefinition> ReadProperties(TypeDefinition type)
	{
		InitializeProperties();
		if (!metadata.TryGetPropertiesRange(type, out var range))
		{
			return new MemberDefinitionCollection<PropertyDefinition>(type);
		}
		MemberDefinitionCollection<PropertyDefinition> memberDefinitionCollection = new MemberDefinitionCollection<PropertyDefinition>(type, (int)range.Length);
		if (range.Length == 0)
		{
			return memberDefinitionCollection;
		}
		context = type;
		if (!MoveTo(Table.PropertyPtr, range.Start))
		{
			if (!MoveTo(Table.Property, range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < range.Length; num++)
			{
				ReadProperty(range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.PropertyPtr, Table.Property, range, memberDefinitionCollection, ReadProperty);
		}
		return memberDefinitionCollection;
	}

	private void ReadProperty(uint property_rid, Collection<PropertyDefinition> properties)
	{
		PropertyAttributes attributes = (PropertyAttributes)ReadUInt16();
		string name = ReadString();
		uint signature = ReadBlobIndex();
		SignatureReader signatureReader = ReadSignature(signature);
		byte num = signatureReader.ReadByte();
		if ((num & 8) == 0)
		{
			throw new NotSupportedException();
		}
		bool hasThis = (num & 0x20) != 0;
		signatureReader.ReadCompressedUInt32();
		PropertyDefinition propertyDefinition = new PropertyDefinition(name, attributes, signatureReader.ReadTypeSignature());
		propertyDefinition.HasThis = hasThis;
		propertyDefinition.token = new MetadataToken(TokenType.Property, property_rid);
		if (!IsDeleted(propertyDefinition))
		{
			properties.Add(propertyDefinition);
		}
	}

	private void InitializeProperties()
	{
		if (metadata.Properties == null)
		{
			int num = MoveTo(Table.PropertyMap);
			metadata.Properties = new Dictionary<uint, Mono.Cecil.Range>(num);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint type_rid = ReadTableIndex(Table.TypeDef);
				Mono.Cecil.Range range = ReadListRange(num2, Table.PropertyMap, Table.Property);
				metadata.AddPropertiesRange(type_rid, range);
			}
		}
	}

	private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method)
	{
		InitializeMethodSemantics();
		if (!metadata.Semantics.TryGetValue(method.token.RID, out var value))
		{
			return MethodSemanticsAttributes.None;
		}
		TypeDefinition declaringType = method.DeclaringType;
		switch (value.Col1)
		{
		case MethodSemanticsAttributes.AddOn:
			GetEvent(declaringType, value.Col2).add_method = method;
			break;
		case MethodSemanticsAttributes.Fire:
			GetEvent(declaringType, value.Col2).invoke_method = method;
			break;
		case MethodSemanticsAttributes.RemoveOn:
			GetEvent(declaringType, value.Col2).remove_method = method;
			break;
		case MethodSemanticsAttributes.Getter:
			GetProperty(declaringType, value.Col2).get_method = method;
			break;
		case MethodSemanticsAttributes.Setter:
			GetProperty(declaringType, value.Col2).set_method = method;
			break;
		case MethodSemanticsAttributes.Other:
			switch (value.Col2.TokenType)
			{
			case TokenType.Event:
			{
				EventDefinition @event = GetEvent(declaringType, value.Col2);
				if (@event.other_methods == null)
				{
					@event.other_methods = new Collection<MethodDefinition>();
				}
				@event.other_methods.Add(method);
				break;
			}
			case TokenType.Property:
			{
				PropertyDefinition property = GetProperty(declaringType, value.Col2);
				if (property.other_methods == null)
				{
					property.other_methods = new Collection<MethodDefinition>();
				}
				property.other_methods.Add(method);
				break;
			}
			default:
				throw new NotSupportedException();
			}
			break;
		default:
			throw new NotSupportedException();
		}
		metadata.Semantics.Remove(method.token.RID);
		return value.Col1;
	}

	private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token)
	{
		if (token.TokenType != TokenType.Event)
		{
			throw new ArgumentException();
		}
		return GetMember(type.Events, token);
	}

	private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token)
	{
		if (token.TokenType != TokenType.Property)
		{
			throw new ArgumentException();
		}
		return GetMember(type.Properties, token);
	}

	private static TMember GetMember<TMember>(Collection<TMember> members, MetadataToken token) where TMember : IMemberDefinition
	{
		for (int i = 0; i < members.Count; i++)
		{
			TMember result = members[i];
			if (result.MetadataToken == token)
			{
				return result;
			}
		}
		throw new ArgumentException();
	}

	private void InitializeMethodSemantics()
	{
		if (metadata.Semantics == null)
		{
			int num = MoveTo(Table.MethodSemantics);
			Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> dictionary = (metadata.Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>>(0));
			for (uint num2 = 0u; num2 < num; num2++)
			{
				MethodSemanticsAttributes col = (MethodSemanticsAttributes)ReadUInt16();
				uint key = ReadTableIndex(Table.Method);
				MetadataToken col2 = ReadMetadataToken(CodedIndex.HasSemantics);
				dictionary[key] = new Row<MethodSemanticsAttributes, MetadataToken>(col, col2);
			}
		}
	}

	public void ReadMethods(PropertyDefinition property)
	{
		ReadAllSemantics(property.DeclaringType);
	}

	public void ReadMethods(EventDefinition @event)
	{
		ReadAllSemantics(@event.DeclaringType);
	}

	public void ReadAllSemantics(MethodDefinition method)
	{
		ReadAllSemantics(method.DeclaringType);
	}

	private void ReadAllSemantics(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			if (!methodDefinition.sem_attrs_ready)
			{
				methodDefinition.sem_attrs = ReadMethodSemantics(methodDefinition);
				methodDefinition.sem_attrs_ready = true;
			}
		}
	}

	public Collection<MethodDefinition> ReadMethods(TypeDefinition type)
	{
		Mono.Cecil.Range methods_range = type.methods_range;
		if (methods_range.Length == 0)
		{
			return new MemberDefinitionCollection<MethodDefinition>(type);
		}
		MemberDefinitionCollection<MethodDefinition> memberDefinitionCollection = new MemberDefinitionCollection<MethodDefinition>(type, (int)methods_range.Length);
		if (!MoveTo(Table.MethodPtr, methods_range.Start))
		{
			if (!MoveTo(Table.Method, methods_range.Start))
			{
				return memberDefinitionCollection;
			}
			for (uint num = 0u; num < methods_range.Length; num++)
			{
				ReadMethod(methods_range.Start + num, memberDefinitionCollection);
			}
		}
		else
		{
			ReadPointers(Table.MethodPtr, Table.Method, methods_range, memberDefinitionCollection, ReadMethod);
		}
		return memberDefinitionCollection;
	}

	private void ReadPointers<TMember>(Table ptr, Table table, Mono.Cecil.Range range, Collection<TMember> members, Action<uint, Collection<TMember>> reader) where TMember : IMemberDefinition
	{
		for (uint num = 0u; num < range.Length; num++)
		{
			MoveTo(ptr, range.Start + num);
			uint num2 = ReadTableIndex(table);
			MoveTo(table, num2);
			reader(num2, members);
		}
	}

	private static bool IsDeleted(IMemberDefinition member)
	{
		if (member.IsSpecialName)
		{
			return member.Name == "_Deleted";
		}
		return false;
	}

	private void InitializeMethods()
	{
		if (metadata.Methods == null)
		{
			metadata.Methods = new MethodDefinition[image.GetTableLength(Table.Method)];
		}
	}

	private void ReadMethod(uint method_rid, Collection<MethodDefinition> methods)
	{
		MethodDefinition methodDefinition = new MethodDefinition();
		methodDefinition.rva = ReadUInt32();
		methodDefinition.ImplAttributes = (MethodImplAttributes)ReadUInt16();
		methodDefinition.Attributes = (MethodAttributes)ReadUInt16();
		methodDefinition.Name = ReadString();
		methodDefinition.token = new MetadataToken(TokenType.Method, method_rid);
		if (!IsDeleted(methodDefinition))
		{
			methods.Add(methodDefinition);
			uint signature = ReadBlobIndex();
			Mono.Cecil.Range param_range = ReadListRange(method_rid, Table.Method, Table.Param);
			context = methodDefinition;
			ReadMethodSignature(signature, methodDefinition);
			metadata.AddMethodDefinition(methodDefinition);
			if (param_range.Length != 0)
			{
				int num = position;
				ReadParameters(methodDefinition, param_range);
				position = num;
			}
			if (module.IsWindowsMetadata())
			{
				WindowsRuntimeProjections.Project(methodDefinition);
			}
		}
	}

	private void ReadParameters(MethodDefinition method, Mono.Cecil.Range param_range)
	{
		if (!MoveTo(Table.ParamPtr, param_range.Start))
		{
			if (MoveTo(Table.Param, param_range.Start))
			{
				for (uint num = 0u; num < param_range.Length; num++)
				{
					ReadParameter(param_range.Start + num, method);
				}
			}
		}
		else
		{
			ReadParameterPointers(method, param_range);
		}
	}

	private void ReadParameterPointers(MethodDefinition method, Mono.Cecil.Range range)
	{
		for (uint num = 0u; num < range.Length; num++)
		{
			MoveTo(Table.ParamPtr, range.Start + num);
			uint num2 = ReadTableIndex(Table.Param);
			MoveTo(Table.Param, num2);
			ReadParameter(num2, method);
		}
	}

	private void ReadParameter(uint param_rid, MethodDefinition method)
	{
		ParameterAttributes attributes = (ParameterAttributes)ReadUInt16();
		ushort num = ReadUInt16();
		string name = ReadString();
		ParameterDefinition obj = ((num == 0) ? method.MethodReturnType.Parameter : method.Parameters[num - 1]);
		obj.token = new MetadataToken(TokenType.Param, param_rid);
		obj.Name = name;
		obj.Attributes = attributes;
	}

	private void ReadMethodSignature(uint signature, IMethodSignature method)
	{
		ReadSignature(signature).ReadMethodSignature(method);
	}

	public PInvokeInfo ReadPInvokeInfo(MethodDefinition method)
	{
		InitializePInvokes();
		uint rID = method.token.RID;
		if (!metadata.PInvokes.TryGetValue(rID, out var value))
		{
			return null;
		}
		metadata.PInvokes.Remove(rID);
		return new PInvokeInfo(value.Col1, image.StringHeap.Read(value.Col2), module.ModuleReferences[(int)(value.Col3 - 1)]);
	}

	private void InitializePInvokes()
	{
		if (metadata.PInvokes != null)
		{
			return;
		}
		int num = MoveTo(Table.ImplMap);
		Dictionary<uint, Row<PInvokeAttributes, uint, uint>> dictionary = (metadata.PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>>(num));
		for (int i = 1; i <= num; i++)
		{
			PInvokeAttributes col = (PInvokeAttributes)ReadUInt16();
			MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MemberForwarded);
			uint col2 = ReadStringIndex();
			uint col3 = ReadTableIndex(Table.File);
			if (metadataToken.TokenType == TokenType.Method)
			{
				dictionary.Add(metadataToken.RID, new Row<PInvokeAttributes, uint, uint>(col, col2, col3));
			}
		}
	}

	public bool HasGenericParameters(IGenericParameterProvider provider)
	{
		InitializeGenericParameters();
		if (!metadata.TryGetGenericParameterRanges(provider, out var ranges))
		{
			return false;
		}
		return RangesSize(ranges) > 0;
	}

	public Collection<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider)
	{
		InitializeGenericParameters();
		if (!metadata.TryGetGenericParameterRanges(provider, out var ranges))
		{
			return new GenericParameterCollection(provider);
		}
		GenericParameterCollection genericParameterCollection = new GenericParameterCollection(provider, RangesSize(ranges));
		for (int i = 0; i < ranges.Length; i++)
		{
			ReadGenericParametersRange(ranges[i], provider, genericParameterCollection);
		}
		return genericParameterCollection;
	}

	private void ReadGenericParametersRange(Mono.Cecil.Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
	{
		if (MoveTo(Table.GenericParam, range.Start))
		{
			for (uint num = 0u; num < range.Length; num++)
			{
				ReadUInt16();
				GenericParameterAttributes attributes = (GenericParameterAttributes)ReadUInt16();
				ReadMetadataToken(CodedIndex.TypeOrMethodDef);
				GenericParameter genericParameter = new GenericParameter(ReadString(), provider);
				genericParameter.token = new MetadataToken(TokenType.GenericParam, range.Start + num);
				genericParameter.Attributes = attributes;
				generic_parameters.Add(genericParameter);
			}
		}
	}

	private void InitializeGenericParameters()
	{
		if (metadata.GenericParameters == null)
		{
			metadata.GenericParameters = InitializeRanges(Table.GenericParam, delegate
			{
				Advance(4);
				MetadataToken result = ReadMetadataToken(CodedIndex.TypeOrMethodDef);
				ReadStringIndex();
				return result;
			});
		}
	}

	private Dictionary<MetadataToken, Mono.Cecil.Range[]> InitializeRanges(Table table, Func<MetadataToken> get_next)
	{
		int num = MoveTo(table);
		Dictionary<MetadataToken, Mono.Cecil.Range[]> dictionary = new Dictionary<MetadataToken, Mono.Cecil.Range[]>(num);
		if (num == 0)
		{
			return dictionary;
		}
		MetadataToken metadataToken = MetadataToken.Zero;
		Mono.Cecil.Range range = new Mono.Cecil.Range(1u, 0u);
		for (uint num2 = 1u; num2 <= num; num2++)
		{
			MetadataToken metadataToken2 = get_next();
			if (num2 == 1)
			{
				metadataToken = metadataToken2;
				range.Length++;
			}
			else if (metadataToken2 != metadataToken)
			{
				AddRange(dictionary, metadataToken, range);
				range = new Mono.Cecil.Range(num2, 1u);
				metadataToken = metadataToken2;
			}
			else
			{
				range.Length++;
			}
		}
		AddRange(dictionary, metadataToken, range);
		return dictionary;
	}

	private static void AddRange(Dictionary<MetadataToken, Mono.Cecil.Range[]> ranges, MetadataToken owner, Mono.Cecil.Range range)
	{
		if (owner.RID != 0)
		{
			if (!ranges.TryGetValue(owner, out var value))
			{
				ranges.Add(owner, new Mono.Cecil.Range[1] { range });
			}
			else
			{
				ranges[owner] = value.Add(range);
			}
		}
	}

	public bool HasGenericConstraints(GenericParameter generic_parameter)
	{
		InitializeGenericConstraints();
		if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out var mapping))
		{
			return false;
		}
		return mapping.Count > 0;
	}

	public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter)
	{
		InitializeGenericConstraints();
		if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out var mapping))
		{
			return new GenericParameterConstraintCollection(generic_parameter);
		}
		GenericParameterConstraintCollection genericParameterConstraintCollection = new GenericParameterConstraintCollection(generic_parameter, mapping.Count);
		context = (IGenericContext)generic_parameter.Owner;
		for (int i = 0; i < mapping.Count; i++)
		{
			genericParameterConstraintCollection.Add(new GenericParameterConstraint(GetTypeDefOrRef(mapping[i].Col2), new MetadataToken(TokenType.GenericParamConstraint, mapping[i].Col1)));
		}
		return genericParameterConstraintCollection;
	}

	private void InitializeGenericConstraints()
	{
		if (metadata.GenericConstraints == null)
		{
			int num = MoveTo(Table.GenericParamConstraint);
			metadata.GenericConstraints = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(num);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				AddGenericConstraintMapping(ReadTableIndex(Table.GenericParam), new Row<uint, MetadataToken>(num2, ReadMetadataToken(CodedIndex.TypeDefOrRef)));
			}
		}
	}

	private void AddGenericConstraintMapping(uint generic_parameter, Row<uint, MetadataToken> constraint)
	{
		metadata.SetGenericConstraintMapping(generic_parameter, AddMapping(metadata.GenericConstraints, generic_parameter, constraint));
	}

	public bool HasOverrides(MethodDefinition method)
	{
		InitializeOverrides();
		if (!metadata.TryGetOverrideMapping(method, out var mapping))
		{
			return false;
		}
		return mapping.Count > 0;
	}

	public Collection<MethodReference> ReadOverrides(MethodDefinition method)
	{
		InitializeOverrides();
		if (!metadata.TryGetOverrideMapping(method, out var mapping))
		{
			return new Collection<MethodReference>();
		}
		Collection<MethodReference> collection = new Collection<MethodReference>(mapping.Count);
		context = method;
		for (int i = 0; i < mapping.Count; i++)
		{
			collection.Add((MethodReference)LookupToken(mapping[i]));
		}
		return collection;
	}

	private void InitializeOverrides()
	{
		if (metadata.Overrides != null)
		{
			return;
		}
		int num = MoveTo(Table.MethodImpl);
		metadata.Overrides = new Dictionary<uint, Collection<MetadataToken>>(num);
		for (int i = 1; i <= num; i++)
		{
			ReadTableIndex(Table.TypeDef);
			MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MethodDefOrRef);
			if (metadataToken.TokenType != TokenType.Method)
			{
				throw new NotSupportedException();
			}
			MetadataToken @override = ReadMetadataToken(CodedIndex.MethodDefOrRef);
			AddOverrideMapping(metadataToken.RID, @override);
		}
	}

	private void AddOverrideMapping(uint method_rid, MetadataToken @override)
	{
		metadata.SetOverrideMapping(method_rid, AddMapping(metadata.Overrides, method_rid, @override));
	}

	public MethodBody ReadMethodBody(MethodDefinition method)
	{
		return code.ReadMethodBody(method);
	}

	public int ReadCodeSize(MethodDefinition method)
	{
		return code.ReadCodeSize(method);
	}

	public CallSite ReadCallSite(MetadataToken token)
	{
		if (!MoveTo(Table.StandAloneSig, token.RID))
		{
			return null;
		}
		uint signature = ReadBlobIndex();
		CallSite callSite = new CallSite();
		ReadMethodSignature(signature, callSite);
		callSite.MetadataToken = token;
		return callSite;
	}

	public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token, MethodDefinition method = null)
	{
		if (!MoveTo(Table.StandAloneSig, local_var_token.RID))
		{
			return null;
		}
		SignatureReader signatureReader = ReadSignature(ReadBlobIndex());
		if (signatureReader.ReadByte() != 7)
		{
			throw new NotSupportedException();
		}
		uint num = signatureReader.ReadCompressedUInt32();
		if (num == 0)
		{
			return null;
		}
		VariableDefinitionCollection variableDefinitionCollection = new VariableDefinitionCollection(method, (int)num);
		for (int i = 0; i < num; i++)
		{
			variableDefinitionCollection.Add(new VariableDefinition(signatureReader.ReadTypeSignature()));
		}
		return variableDefinitionCollection;
	}

	public IMetadataTokenProvider LookupToken(MetadataToken token)
	{
		uint rID = token.RID;
		if (rID == 0)
		{
			return null;
		}
		if (metadata_reader != null)
		{
			return metadata_reader.LookupToken(token);
		}
		int num = position;
		IGenericContext genericContext = context;
		IMetadataTokenProvider result;
		switch (token.TokenType)
		{
		case TokenType.TypeDef:
			result = GetTypeDefinition(rID);
			break;
		case TokenType.TypeRef:
			result = GetTypeReference(rID);
			break;
		case TokenType.TypeSpec:
			result = GetTypeSpecification(rID);
			break;
		case TokenType.Field:
			result = GetFieldDefinition(rID);
			break;
		case TokenType.Method:
			result = GetMethodDefinition(rID);
			break;
		case TokenType.MemberRef:
			result = GetMemberReference(rID);
			break;
		case TokenType.MethodSpec:
			result = GetMethodSpecification(rID);
			break;
		default:
			return null;
		}
		position = num;
		context = genericContext;
		return result;
	}

	public FieldDefinition GetFieldDefinition(uint rid)
	{
		InitializeTypeDefinitions();
		FieldDefinition fieldDefinition = metadata.GetFieldDefinition(rid);
		if (fieldDefinition != null)
		{
			return fieldDefinition;
		}
		return LookupField(rid);
	}

	private FieldDefinition LookupField(uint rid)
	{
		TypeDefinition fieldDeclaringType = metadata.GetFieldDeclaringType(rid);
		if (fieldDeclaringType == null)
		{
			return null;
		}
		Mixin.Read(fieldDeclaringType.Fields);
		return metadata.GetFieldDefinition(rid);
	}

	public MethodDefinition GetMethodDefinition(uint rid)
	{
		InitializeTypeDefinitions();
		MethodDefinition methodDefinition = metadata.GetMethodDefinition(rid);
		if (methodDefinition != null)
		{
			return methodDefinition;
		}
		return LookupMethod(rid);
	}

	private MethodDefinition LookupMethod(uint rid)
	{
		TypeDefinition methodDeclaringType = metadata.GetMethodDeclaringType(rid);
		if (methodDeclaringType == null)
		{
			return null;
		}
		Mixin.Read(methodDeclaringType.Methods);
		return metadata.GetMethodDefinition(rid);
	}

	private MethodSpecification GetMethodSpecification(uint rid)
	{
		if (!MoveTo(Table.MethodSpec, rid))
		{
			return null;
		}
		MethodReference method = (MethodReference)LookupToken(ReadMetadataToken(CodedIndex.MethodDefOrRef));
		uint signature = ReadBlobIndex();
		MethodSpecification methodSpecification = ReadMethodSpecSignature(signature, method);
		methodSpecification.token = new MetadataToken(TokenType.MethodSpec, rid);
		return methodSpecification;
	}

	private MethodSpecification ReadMethodSpecSignature(uint signature, MethodReference method)
	{
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.ReadByte() != 10)
		{
			throw new NotSupportedException();
		}
		uint arity = signatureReader.ReadCompressedUInt32();
		GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(method, (int)arity);
		signatureReader.ReadGenericInstanceSignature(method, genericInstanceMethod, arity);
		return genericInstanceMethod;
	}

	private MemberReference GetMemberReference(uint rid)
	{
		InitializeMemberReferences();
		MemberReference memberReference = metadata.GetMemberReference(rid);
		if (memberReference != null)
		{
			return memberReference;
		}
		memberReference = ReadMemberReference(rid);
		if (memberReference != null && !memberReference.ContainsGenericParameter)
		{
			metadata.AddMemberReference(memberReference);
		}
		return memberReference;
	}

	private MemberReference ReadMemberReference(uint rid)
	{
		if (!MoveTo(Table.MemberRef, rid))
		{
			return null;
		}
		MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MemberRefParent);
		string name = ReadString();
		uint signature = ReadBlobIndex();
		MemberReference memberReference;
		switch (metadataToken.TokenType)
		{
		case TokenType.TypeRef:
		case TokenType.TypeDef:
		case TokenType.TypeSpec:
			memberReference = ReadTypeMemberReference(metadataToken, name, signature);
			break;
		case TokenType.Method:
			memberReference = ReadMethodMemberReference(metadataToken, name, signature);
			break;
		default:
			throw new NotSupportedException();
		}
		memberReference.token = new MetadataToken(TokenType.MemberRef, rid);
		return memberReference;
	}

	private MemberReference ReadTypeMemberReference(MetadataToken type, string name, uint signature)
	{
		TypeReference typeDefOrRef = GetTypeDefOrRef(type);
		if (!typeDefOrRef.IsArray)
		{
			context = typeDefOrRef;
		}
		MemberReference memberReference = ReadMemberReferenceSignature(signature, typeDefOrRef);
		memberReference.Name = name;
		return memberReference;
	}

	private MemberReference ReadMemberReferenceSignature(uint signature, TypeReference declaring_type)
	{
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.buffer[signatureReader.position] == 6)
		{
			signatureReader.position++;
			return new FieldReference
			{
				DeclaringType = declaring_type,
				FieldType = signatureReader.ReadTypeSignature()
			};
		}
		MethodReference methodReference = new MethodReference();
		methodReference.DeclaringType = declaring_type;
		signatureReader.ReadMethodSignature(methodReference);
		return methodReference;
	}

	private MemberReference ReadMethodMemberReference(MetadataToken token, string name, uint signature)
	{
		MemberReference memberReference = ReadMemberReferenceSignature(signature, ((MethodDefinition)(context = GetMethodDefinition(token.RID))).DeclaringType);
		memberReference.Name = name;
		return memberReference;
	}

	private void InitializeMemberReferences()
	{
		if (metadata.MemberReferences == null)
		{
			metadata.MemberReferences = new MemberReference[image.GetTableLength(Table.MemberRef)];
		}
	}

	public IEnumerable<MemberReference> GetMemberReferences()
	{
		InitializeMemberReferences();
		int tableLength = image.GetTableLength(Table.MemberRef);
		TypeSystem typeSystem = module.TypeSystem;
		MethodDefinition methodDefinition = new MethodDefinition(string.Empty, MethodAttributes.Static, typeSystem.Void);
		methodDefinition.DeclaringType = new TypeDefinition(string.Empty, string.Empty, TypeAttributes.Public);
		MemberReference[] array = new MemberReference[tableLength];
		for (uint num = 1u; num <= tableLength; num++)
		{
			context = methodDefinition;
			array[num - 1] = GetMemberReference(num);
		}
		return array;
	}

	private void InitializeConstants()
	{
		if (metadata.Constants == null)
		{
			int num = MoveTo(Table.Constant);
			Dictionary<MetadataToken, Row<ElementType, uint>> dictionary = (metadata.Constants = new Dictionary<MetadataToken, Row<ElementType, uint>>(num));
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				ElementType col = (ElementType)ReadUInt16();
				MetadataToken key = ReadMetadataToken(CodedIndex.HasConstant);
				uint col2 = ReadBlobIndex();
				dictionary.Add(key, new Row<ElementType, uint>(col, col2));
			}
		}
	}

	public TypeReference ReadConstantSignature(MetadataToken token)
	{
		if (token.TokenType != TokenType.Signature)
		{
			throw new NotSupportedException();
		}
		if (token.RID == 0)
		{
			return null;
		}
		if (!MoveTo(Table.StandAloneSig, token.RID))
		{
			return null;
		}
		return ReadFieldType(ReadBlobIndex());
	}

	public object ReadConstant(IConstantProvider owner)
	{
		InitializeConstants();
		if (!metadata.Constants.TryGetValue(owner.MetadataToken, out var value))
		{
			return Mixin.NoValue;
		}
		metadata.Constants.Remove(owner.MetadataToken);
		return ReadConstantValue(value.Col1, value.Col2);
	}

	private object ReadConstantValue(ElementType etype, uint signature)
	{
		switch (etype)
		{
		case ElementType.Class:
		case ElementType.Object:
			return null;
		case ElementType.String:
			return ReadConstantString(signature);
		default:
			return ReadConstantPrimitive(etype, signature);
		}
	}

	private string ReadConstantString(uint signature)
	{
		GetBlobView(signature, out var blob, out var index, out var count);
		if (count == 0)
		{
			return string.Empty;
		}
		if ((count & 1) == 1)
		{
			count--;
		}
		return Encoding.Unicode.GetString(blob, index, count);
	}

	private object ReadConstantPrimitive(ElementType type, uint signature)
	{
		return ReadSignature(signature).ReadConstantSignature(type);
	}

	internal void InitializeCustomAttributes()
	{
		if (metadata.CustomAttributes == null)
		{
			metadata.CustomAttributes = InitializeRanges(Table.CustomAttribute, delegate
			{
				MetadataToken result = ReadMetadataToken(CodedIndex.HasCustomAttribute);
				ReadMetadataToken(CodedIndex.CustomAttributeType);
				ReadBlobIndex();
				return result;
			});
		}
	}

	public bool HasCustomAttributes(ICustomAttributeProvider owner)
	{
		InitializeCustomAttributes();
		if (!metadata.TryGetCustomAttributeRanges(owner, out var ranges))
		{
			return false;
		}
		return RangesSize(ranges) > 0;
	}

	public Collection<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner)
	{
		InitializeCustomAttributes();
		if (!metadata.TryGetCustomAttributeRanges(owner, out var ranges))
		{
			return new Collection<CustomAttribute>();
		}
		Collection<CustomAttribute> collection = new Collection<CustomAttribute>(RangesSize(ranges));
		for (int i = 0; i < ranges.Length; i++)
		{
			ReadCustomAttributeRange(ranges[i], collection);
		}
		if (module.IsWindowsMetadata())
		{
			foreach (CustomAttribute item in collection)
			{
				WindowsRuntimeProjections.Project(owner, collection, item);
			}
		}
		return collection;
	}

	private void ReadCustomAttributeRange(Mono.Cecil.Range range, Collection<CustomAttribute> custom_attributes)
	{
		if (MoveTo(Table.CustomAttribute, range.Start))
		{
			for (int i = 0; i < range.Length; i++)
			{
				ReadMetadataToken(CodedIndex.HasCustomAttribute);
				MethodReference constructor = (MethodReference)LookupToken(ReadMetadataToken(CodedIndex.CustomAttributeType));
				uint signature = ReadBlobIndex();
				custom_attributes.Add(new CustomAttribute(signature, constructor));
			}
		}
	}

	private static int RangesSize(Mono.Cecil.Range[] ranges)
	{
		uint num = 0u;
		for (int i = 0; i < ranges.Length; i++)
		{
			num += ranges[i].Length;
		}
		return (int)num;
	}

	public IEnumerable<CustomAttribute> GetCustomAttributes()
	{
		InitializeTypeDefinitions();
		uint capacity = image.TableHeap[Table.CustomAttribute].Length;
		Collection<CustomAttribute> collection = new Collection<CustomAttribute>((int)capacity);
		ReadCustomAttributeRange(new Mono.Cecil.Range(1u, capacity), collection);
		return collection;
	}

	public byte[] ReadCustomAttributeBlob(uint signature)
	{
		return ReadBlob(signature);
	}

	public void ReadCustomAttributeSignature(CustomAttribute attribute)
	{
		SignatureReader signatureReader = ReadSignature(attribute.signature);
		if (!signatureReader.CanReadMore())
		{
			return;
		}
		if (signatureReader.ReadUInt16() != 1)
		{
			throw new InvalidOperationException();
		}
		MethodReference constructor = attribute.Constructor;
		if (constructor.HasParameters)
		{
			signatureReader.ReadCustomAttributeConstructorArguments(attribute, constructor.Parameters);
		}
		if (signatureReader.CanReadMore())
		{
			ushort num = signatureReader.ReadUInt16();
			if (num != 0)
			{
				signatureReader.ReadCustomAttributeNamedArguments(num, ref attribute.fields, ref attribute.properties);
			}
		}
	}

	private void InitializeMarshalInfos()
	{
		if (metadata.FieldMarshals != null)
		{
			return;
		}
		int num = MoveTo(Table.FieldMarshal);
		Dictionary<MetadataToken, uint> dictionary = (metadata.FieldMarshals = new Dictionary<MetadataToken, uint>(num));
		for (int i = 0; i < num; i++)
		{
			MetadataToken key = ReadMetadataToken(CodedIndex.HasFieldMarshal);
			uint value = ReadBlobIndex();
			if (key.RID != 0)
			{
				dictionary.Add(key, value);
			}
		}
	}

	public bool HasMarshalInfo(IMarshalInfoProvider owner)
	{
		InitializeMarshalInfos();
		return metadata.FieldMarshals.ContainsKey(owner.MetadataToken);
	}

	public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner)
	{
		InitializeMarshalInfos();
		if (!metadata.FieldMarshals.TryGetValue(owner.MetadataToken, out var value))
		{
			return null;
		}
		SignatureReader signatureReader = ReadSignature(value);
		metadata.FieldMarshals.Remove(owner.MetadataToken);
		return signatureReader.ReadMarshalInfo();
	}

	private void InitializeSecurityDeclarations()
	{
		if (metadata.SecurityDeclarations == null)
		{
			metadata.SecurityDeclarations = InitializeRanges(Table.DeclSecurity, delegate
			{
				ReadUInt16();
				MetadataToken result = ReadMetadataToken(CodedIndex.HasDeclSecurity);
				ReadBlobIndex();
				return result;
			});
		}
	}

	public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner)
	{
		InitializeSecurityDeclarations();
		if (!metadata.TryGetSecurityDeclarationRanges(owner, out var ranges))
		{
			return false;
		}
		return RangesSize(ranges) > 0;
	}

	public Collection<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner)
	{
		InitializeSecurityDeclarations();
		if (!metadata.TryGetSecurityDeclarationRanges(owner, out var ranges))
		{
			return new Collection<SecurityDeclaration>();
		}
		Collection<SecurityDeclaration> collection = new Collection<SecurityDeclaration>(RangesSize(ranges));
		for (int i = 0; i < ranges.Length; i++)
		{
			ReadSecurityDeclarationRange(ranges[i], collection);
		}
		return collection;
	}

	private void ReadSecurityDeclarationRange(Mono.Cecil.Range range, Collection<SecurityDeclaration> security_declarations)
	{
		if (MoveTo(Table.DeclSecurity, range.Start))
		{
			for (int i = 0; i < range.Length; i++)
			{
				SecurityAction action = (SecurityAction)ReadUInt16();
				ReadMetadataToken(CodedIndex.HasDeclSecurity);
				uint signature = ReadBlobIndex();
				security_declarations.Add(new SecurityDeclaration(action, signature, module));
			}
		}
	}

	public byte[] ReadSecurityDeclarationBlob(uint signature)
	{
		return ReadBlob(signature);
	}

	public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration)
	{
		uint signature = declaration.signature;
		SignatureReader signatureReader = ReadSignature(signature);
		if (signatureReader.buffer[signatureReader.position] != 46)
		{
			ReadXmlSecurityDeclaration(signature, declaration);
			return;
		}
		signatureReader.position++;
		uint num = signatureReader.ReadCompressedUInt32();
		Collection<SecurityAttribute> collection = new Collection<SecurityAttribute>((int)num);
		for (int i = 0; i < num; i++)
		{
			collection.Add(signatureReader.ReadSecurityAttribute());
		}
		declaration.security_attributes = collection;
	}

	private void ReadXmlSecurityDeclaration(uint signature, SecurityDeclaration declaration)
	{
		Collection<SecurityAttribute> collection = new Collection<SecurityAttribute>(1);
		SecurityAttribute securityAttribute = new SecurityAttribute(module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"));
		securityAttribute.properties = new Collection<CustomAttributeNamedArgument>(1);
		securityAttribute.properties.Add(new CustomAttributeNamedArgument("XML", new CustomAttributeArgument(module.TypeSystem.String, ReadUnicodeStringBlob(signature))));
		collection.Add(securityAttribute);
		declaration.security_attributes = collection;
	}

	public Collection<ExportedType> ReadExportedTypes()
	{
		int num = MoveTo(Table.ExportedType);
		if (num == 0)
		{
			return new Collection<ExportedType>();
		}
		Collection<ExportedType> collection = new Collection<ExportedType>(num);
		for (int i = 1; i <= num; i++)
		{
			TypeAttributes attributes = (TypeAttributes)ReadUInt32();
			uint identifier = ReadUInt32();
			string name = ReadString();
			string @namespace = ReadString();
			MetadataToken token = ReadMetadataToken(CodedIndex.Implementation);
			ExportedType declaringType = null;
			IMetadataScope scope = null;
			switch (token.TokenType)
			{
			case TokenType.AssemblyRef:
			case TokenType.File:
				scope = GetExportedTypeScope(token);
				break;
			case TokenType.ExportedType:
				declaringType = collection[(int)(token.RID - 1)];
				break;
			}
			ExportedType exportedType = new ExportedType(@namespace, name, module, scope)
			{
				Attributes = attributes,
				Identifier = (int)identifier,
				DeclaringType = declaringType
			};
			exportedType.token = new MetadataToken(TokenType.ExportedType, i);
			collection.Add(exportedType);
		}
		return collection;
	}

	private IMetadataScope GetExportedTypeScope(MetadataToken token)
	{
		int num = position;
		IMetadataScope result;
		switch (token.TokenType)
		{
		case TokenType.AssemblyRef:
			InitializeAssemblyReferences();
			result = metadata.GetAssemblyNameReference(token.RID);
			break;
		case TokenType.File:
			InitializeModuleReferences();
			result = GetModuleReferenceFromFile(token);
			break;
		default:
			throw new NotSupportedException();
		}
		position = num;
		return result;
	}

	private ModuleReference GetModuleReferenceFromFile(MetadataToken token)
	{
		if (!MoveTo(Table.File, token.RID))
		{
			return null;
		}
		ReadUInt32();
		string text = ReadString();
		Collection<ModuleReference> moduleReferences = module.ModuleReferences;
		ModuleReference moduleReference;
		for (int i = 0; i < moduleReferences.Count; i++)
		{
			moduleReference = moduleReferences[i];
			if (moduleReference.Name == text)
			{
				return moduleReference;
			}
		}
		moduleReference = new ModuleReference(text);
		moduleReferences.Add(moduleReference);
		return moduleReference;
	}

	private void InitializeDocuments()
	{
		if (metadata.Documents == null)
		{
			int num = MoveTo(Table.Document);
			Document[] array = (metadata.Documents = new Document[num]);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint signature = ReadBlobIndex();
				Guid hashAlgorithmGuid = ReadGuid();
				byte[] hash = ReadBlob();
				Guid languageGuid = ReadGuid();
				string url = ReadSignature(signature).ReadDocumentName();
				array[num2 - 1] = new Document(url)
				{
					HashAlgorithmGuid = hashAlgorithmGuid,
					Hash = hash,
					LanguageGuid = languageGuid,
					token = new MetadataToken(TokenType.Document, num2)
				};
			}
		}
	}

	public Collection<SequencePoint> ReadSequencePoints(MethodDefinition method)
	{
		InitializeDocuments();
		if (!MoveTo(Table.MethodDebugInformation, method.MetadataToken.RID))
		{
			return new Collection<SequencePoint>(0);
		}
		uint rid = ReadTableIndex(Table.Document);
		uint num = ReadBlobIndex();
		if (num == 0)
		{
			return new Collection<SequencePoint>(0);
		}
		Document document = GetDocument(rid);
		return ReadSignature(num).ReadSequencePoints(document);
	}

	public Document GetDocument(uint rid)
	{
		Document document = metadata.GetDocument(rid);
		if (document == null)
		{
			return null;
		}
		document.custom_infos = GetCustomDebugInformation(document);
		return document;
	}

	private void InitializeLocalScopes()
	{
		if (metadata.LocalScopes == null)
		{
			InitializeMethods();
			int num = MoveTo(Table.LocalScope);
			metadata.LocalScopes = new Dictionary<uint, Collection<Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint>>>();
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint num3 = ReadTableIndex(Table.Method);
				uint col = ReadTableIndex(Table.ImportScope);
				Mono.Cecil.Range col2 = ReadListRange(num2, Table.LocalScope, Table.LocalVariable);
				Mono.Cecil.Range col3 = ReadListRange(num2, Table.LocalScope, Table.LocalConstant);
				uint col4 = ReadUInt32();
				uint col5 = ReadUInt32();
				metadata.SetLocalScopes(num3, AddMapping(metadata.LocalScopes, num3, new Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint>(col, col2, col3, col4, col5, num2)));
			}
		}
	}

	public ScopeDebugInformation ReadScope(MethodDefinition method)
	{
		InitializeLocalScopes();
		InitializeImportScopes();
		if (!metadata.TryGetLocalScopes(method, out var scopes))
		{
			return null;
		}
		ScopeDebugInformation scopeDebugInformation = null;
		for (int i = 0; i < scopes.Count; i++)
		{
			ScopeDebugInformation scopeDebugInformation2 = ReadLocalScope(scopes[i]);
			if (i == 0)
			{
				scopeDebugInformation = scopeDebugInformation2;
			}
			else if (!AddScope(scopeDebugInformation.scopes, scopeDebugInformation2))
			{
				scopeDebugInformation.Scopes.Add(scopeDebugInformation2);
			}
		}
		return scopeDebugInformation;
	}

	private static bool AddScope(Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
	{
		if (scopes.IsNullOrEmpty())
		{
			return false;
		}
		foreach (ScopeDebugInformation scope2 in scopes)
		{
			if (scope2.HasScopes && AddScope(scope2.Scopes, scope))
			{
				return true;
			}
			if (scope.Start.Offset >= scope2.Start.Offset && scope.End.Offset <= scope2.End.Offset)
			{
				scope2.Scopes.Add(scope);
				return true;
			}
		}
		return false;
	}

	private ScopeDebugInformation ReadLocalScope(Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint> record)
	{
		ScopeDebugInformation scopeDebugInformation = new ScopeDebugInformation
		{
			start = new InstructionOffset((int)record.Col4),
			end = new InstructionOffset((int)(record.Col4 + record.Col5)),
			token = new MetadataToken(TokenType.LocalScope, record.Col6)
		};
		if (record.Col1 != 0)
		{
			scopeDebugInformation.import = metadata.GetImportScope(record.Col1);
		}
		if (record.Col2.Length != 0)
		{
			scopeDebugInformation.variables = new Collection<VariableDebugInformation>((int)record.Col2.Length);
			for (uint num = 0u; num < record.Col2.Length; num++)
			{
				VariableDebugInformation variableDebugInformation = ReadLocalVariable(record.Col2.Start + num);
				if (variableDebugInformation != null)
				{
					scopeDebugInformation.variables.Add(variableDebugInformation);
				}
			}
		}
		if (record.Col3.Length != 0)
		{
			scopeDebugInformation.constants = new Collection<ConstantDebugInformation>((int)record.Col3.Length);
			for (uint num2 = 0u; num2 < record.Col3.Length; num2++)
			{
				ConstantDebugInformation constantDebugInformation = ReadLocalConstant(record.Col3.Start + num2);
				if (constantDebugInformation != null)
				{
					scopeDebugInformation.constants.Add(constantDebugInformation);
				}
			}
		}
		return scopeDebugInformation;
	}

	private VariableDebugInformation ReadLocalVariable(uint rid)
	{
		if (!MoveTo(Table.LocalVariable, rid))
		{
			return null;
		}
		VariableAttributes attributes = (VariableAttributes)ReadUInt16();
		ushort index = ReadUInt16();
		string name = ReadString();
		VariableDebugInformation variableDebugInformation = new VariableDebugInformation(index, name)
		{
			Attributes = attributes,
			token = new MetadataToken(TokenType.LocalVariable, rid)
		};
		variableDebugInformation.custom_infos = GetCustomDebugInformation(variableDebugInformation);
		return variableDebugInformation;
	}

	private ConstantDebugInformation ReadLocalConstant(uint rid)
	{
		if (!MoveTo(Table.LocalConstant, rid))
		{
			return null;
		}
		string name = ReadString();
		SignatureReader signatureReader = ReadSignature(ReadBlobIndex());
		TypeReference typeReference = signatureReader.ReadTypeSignature();
		object value;
		if (typeReference.etype == ElementType.String)
		{
			if (!signatureReader.CanReadMore())
			{
				value = "";
			}
			else if (signatureReader.buffer[signatureReader.position] != byte.MaxValue)
			{
				byte[] array = signatureReader.ReadBytes((int)(signatureReader.sig_length - (signatureReader.position - signatureReader.start)));
				value = Encoding.Unicode.GetString(array, 0, array.Length);
			}
			else
			{
				value = null;
			}
		}
		else if (!typeReference.IsTypeOf("System", "Decimal"))
		{
			value = (typeReference.IsTypeOf("System", "DateTime") ? ((object)new DateTime(signatureReader.ReadInt64())) : ((typeReference.etype != ElementType.Object && typeReference.etype != 0 && typeReference.etype != ElementType.Class && typeReference.etype != ElementType.Array && typeReference.etype != ElementType.GenericInst) ? signatureReader.ReadConstantSignature(typeReference.etype) : null));
		}
		else
		{
			byte b = signatureReader.ReadByte();
			value = new decimal(signatureReader.ReadInt32(), signatureReader.ReadInt32(), signatureReader.ReadInt32(), (b & 0x80) != 0, (byte)(b & 0x7F));
		}
		ConstantDebugInformation constantDebugInformation = new ConstantDebugInformation(name, typeReference, value)
		{
			token = new MetadataToken(TokenType.LocalConstant, rid)
		};
		constantDebugInformation.custom_infos = GetCustomDebugInformation(constantDebugInformation);
		return constantDebugInformation;
	}

	private void InitializeImportScopes()
	{
		if (metadata.ImportScopes != null)
		{
			return;
		}
		int num = MoveTo(Table.ImportScope);
		metadata.ImportScopes = new ImportDebugInformation[num];
		for (int i = 1; i <= num; i++)
		{
			ReadTableIndex(Table.ImportScope);
			ImportDebugInformation importDebugInformation = new ImportDebugInformation();
			importDebugInformation.token = new MetadataToken(TokenType.ImportScope, i);
			SignatureReader signatureReader = ReadSignature(ReadBlobIndex());
			while (signatureReader.CanReadMore())
			{
				importDebugInformation.Targets.Add(ReadImportTarget(signatureReader));
			}
			metadata.ImportScopes[i - 1] = importDebugInformation;
		}
		MoveTo(Table.ImportScope);
		for (int j = 0; j < num; j++)
		{
			uint num2 = ReadTableIndex(Table.ImportScope);
			ReadBlobIndex();
			if (num2 != 0)
			{
				metadata.ImportScopes[j].Parent = metadata.GetImportScope(num2);
			}
		}
	}

	public string ReadUTF8StringBlob(uint signature)
	{
		return ReadStringBlob(signature, Encoding.UTF8);
	}

	private string ReadUnicodeStringBlob(uint signature)
	{
		return ReadStringBlob(signature, Encoding.Unicode);
	}

	private string ReadStringBlob(uint signature, Encoding encoding)
	{
		GetBlobView(signature, out var blob, out var index, out var count);
		if (count == 0)
		{
			return string.Empty;
		}
		return encoding.GetString(blob, index, count);
	}

	private ImportTarget ReadImportTarget(SignatureReader signature)
	{
		AssemblyNameReference reference = null;
		string @namespace = null;
		string alias = null;
		TypeReference type = null;
		ImportTargetKind importTargetKind = (ImportTargetKind)signature.ReadCompressedUInt32();
		switch (importTargetKind)
		{
		case ImportTargetKind.ImportNamespace:
			@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.ImportNamespaceInAssembly:
			reference = metadata.GetAssemblyNameReference(signature.ReadCompressedUInt32());
			@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.ImportType:
			type = signature.ReadTypeToken();
			break;
		case ImportTargetKind.ImportXmlNamespaceWithAlias:
			alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.ImportAlias:
			alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.DefineAssemblyAlias:
			alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			reference = metadata.GetAssemblyNameReference(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.DefineNamespaceAlias:
			alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.DefineNamespaceInAssemblyAlias:
			alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			reference = metadata.GetAssemblyNameReference(signature.ReadCompressedUInt32());
			@namespace = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			break;
		case ImportTargetKind.DefineTypeAlias:
			alias = ReadUTF8StringBlob(signature.ReadCompressedUInt32());
			type = signature.ReadTypeToken();
			break;
		}
		return new ImportTarget(importTargetKind)
		{
			alias = alias,
			type = type,
			@namespace = @namespace,
			reference = reference
		};
	}

	private void InitializeStateMachineMethods()
	{
		if (metadata.StateMachineMethods == null)
		{
			int num = MoveTo(Table.StateMachineMethod);
			metadata.StateMachineMethods = new Dictionary<uint, uint>(num);
			for (int i = 0; i < num; i++)
			{
				metadata.StateMachineMethods.Add(ReadTableIndex(Table.Method), ReadTableIndex(Table.Method));
			}
		}
	}

	public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method)
	{
		InitializeStateMachineMethods();
		if (!metadata.TryGetStateMachineKickOffMethod(method, out var rid))
		{
			return null;
		}
		return GetMethodDefinition(rid);
	}

	private void InitializeCustomDebugInformations()
	{
		if (metadata.CustomDebugInformations == null)
		{
			int num = MoveTo(Table.CustomDebugInformation);
			metadata.CustomDebugInformations = new Dictionary<MetadataToken, Row<Guid, uint, uint>[]>();
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				MetadataToken key = ReadMetadataToken(CodedIndex.HasCustomDebugInformation);
				Row<Guid, uint, uint> item = new Row<Guid, uint, uint>(ReadGuid(), ReadBlobIndex(), num2);
				metadata.CustomDebugInformations.TryGetValue(key, out var value);
				metadata.CustomDebugInformations[key] = value.Add(item);
			}
		}
	}

	public Collection<CustomDebugInformation> GetCustomDebugInformation(ICustomDebugInformationProvider provider)
	{
		InitializeCustomDebugInformations();
		if (!metadata.CustomDebugInformations.TryGetValue(provider.MetadataToken, out var value))
		{
			return null;
		}
		Collection<CustomDebugInformation> collection = new Collection<CustomDebugInformation>(value.Length);
		for (int i = 0; i < value.Length; i++)
		{
			if (value[i].Col1 == StateMachineScopeDebugInformation.KindIdentifier)
			{
				SignatureReader signatureReader = ReadSignature(value[i].Col2);
				Collection<StateMachineScope> collection2 = new Collection<StateMachineScope>();
				while (signatureReader.CanReadMore())
				{
					int num = signatureReader.ReadInt32();
					int end = num + signatureReader.ReadInt32();
					collection2.Add(new StateMachineScope(num, end));
				}
				StateMachineScopeDebugInformation stateMachineScopeDebugInformation = new StateMachineScopeDebugInformation();
				stateMachineScopeDebugInformation.scopes = collection2;
				collection.Add(stateMachineScopeDebugInformation);
			}
			else if (value[i].Col1 == AsyncMethodBodyDebugInformation.KindIdentifier)
			{
				SignatureReader signatureReader2 = ReadSignature(value[i].Col2);
				int catchHandler = signatureReader2.ReadInt32() - 1;
				Collection<InstructionOffset> collection3 = new Collection<InstructionOffset>();
				Collection<InstructionOffset> collection4 = new Collection<InstructionOffset>();
				Collection<MethodDefinition> collection5 = new Collection<MethodDefinition>();
				while (signatureReader2.CanReadMore())
				{
					collection3.Add(new InstructionOffset(signatureReader2.ReadInt32()));
					collection4.Add(new InstructionOffset(signatureReader2.ReadInt32()));
					collection5.Add(GetMethodDefinition(signatureReader2.ReadCompressedUInt32()));
				}
				AsyncMethodBodyDebugInformation asyncMethodBodyDebugInformation = new AsyncMethodBodyDebugInformation(catchHandler);
				asyncMethodBodyDebugInformation.yields = collection3;
				asyncMethodBodyDebugInformation.resumes = collection4;
				asyncMethodBodyDebugInformation.resume_methods = collection5;
				collection.Add(asyncMethodBodyDebugInformation);
			}
			else if (value[i].Col1 == EmbeddedSourceDebugInformation.KindIdentifier)
			{
				collection.Add(new EmbeddedSourceDebugInformation(value[i].Col2, this));
			}
			else if (value[i].Col1 == SourceLinkDebugInformation.KindIdentifier)
			{
				collection.Add(new SourceLinkDebugInformation(Encoding.UTF8.GetString(ReadBlob(value[i].Col2))));
			}
			else
			{
				collection.Add(new BinaryCustomDebugInformation(value[i].Col1, ReadBlob(value[i].Col2)));
			}
			collection[i].token = new MetadataToken(TokenType.CustomDebugInformation, value[i].Col3);
		}
		return collection;
	}

	public byte[] ReadRawEmbeddedSourceDebugInformation(uint index)
	{
		SignatureReader signatureReader = ReadSignature(index);
		return signatureReader.ReadBytes((int)signatureReader.sig_length);
	}

	public Row<byte[], bool> ReadEmbeddedSourceDebugInformation(uint index)
	{
		SignatureReader signatureReader = ReadSignature(index);
		int num = signatureReader.ReadInt32();
		uint num2 = signatureReader.sig_length - 4;
		if (num == 0)
		{
			return new Row<byte[], bool>(signatureReader.ReadBytes((int)num2), col2: false);
		}
		if (num > 0)
		{
			MemoryStream stream = new MemoryStream(signatureReader.ReadBytes((int)num2));
			byte[] col = new byte[num];
			MemoryStream destination = new MemoryStream(col);
			using (DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress, leaveOpen: true))
			{
				deflateStream.CopyTo(destination);
			}
			return new Row<byte[], bool>(col, col2: true);
		}
		throw new NotSupportedException();
	}
}


using System;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class SignatureReader : ByteBuffer
{
	private readonly MetadataReader reader;

	internal readonly uint start;

	internal readonly uint sig_length;

	private TypeSystem TypeSystem => reader.module.TypeSystem;

	public SignatureReader(uint blob, MetadataReader reader)
		: base(reader.image.BlobHeap.data)
	{
		this.reader = reader;
		position = (int)blob;
		sig_length = ReadCompressedUInt32();
		start = (uint)position;
	}

	private MetadataToken ReadTypeTokenSignature()
	{
		return CodedIndex.TypeDefOrRef.GetMetadataToken(ReadCompressedUInt32());
	}

	private GenericParameter GetGenericParameter(GenericParameterType type, uint var)
	{
		IGenericContext context = reader.context;
		if (context == null)
		{
			return GetUnboundGenericParameter(type, (int)var);
		}
		IGenericParameterProvider genericParameterProvider = type switch
		{
			GenericParameterType.Type => context.Type, 
			GenericParameterType.Method => context.Method, 
			_ => throw new NotSupportedException(), 
		};
		if (!context.IsDefinition)
		{
			CheckGenericContext(genericParameterProvider, (int)var);
		}
		if ((int)var >= genericParameterProvider.GenericParameters.Count)
		{
			return GetUnboundGenericParameter(type, (int)var);
		}
		return genericParameterProvider.GenericParameters[(int)var];
	}

	private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index)
	{
		return new GenericParameter(index, type, reader.module);
	}

	private static void CheckGenericContext(IGenericParameterProvider owner, int index)
	{
		Collection<GenericParameter> genericParameters = owner.GenericParameters;
		for (int i = genericParameters.Count; i <= index; i++)
		{
			genericParameters.Add(new GenericParameter(owner));
		}
	}

	public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, uint arity)
	{
		if (!provider.IsDefinition)
		{
			CheckGenericContext(provider, (int)(arity - 1));
		}
		Collection<TypeReference> genericArguments = instance.GenericArguments;
		for (int i = 0; i < arity; i++)
		{
			genericArguments.Add(ReadTypeSignature());
		}
	}

	private ArrayType ReadArrayTypeSignature()
	{
		ArrayType arrayType = new ArrayType(ReadTypeSignature());
		uint num = ReadCompressedUInt32();
		uint[] array = new uint[ReadCompressedUInt32()];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = ReadCompressedUInt32();
		}
		int[] array2 = new int[ReadCompressedUInt32()];
		for (int j = 0; j < array2.Length; j++)
		{
			array2[j] = ReadCompressedInt32();
		}
		arrayType.Dimensions.Clear();
		for (int k = 0; k < num; k++)
		{
			int? num2 = null;
			int? upperBound = null;
			if (k < array2.Length)
			{
				num2 = array2[k];
			}
			if (k < array.Length)
			{
				upperBound = num2 + (int)array[k] - 1;
			}
			arrayType.Dimensions.Add(new ArrayDimension(num2, upperBound));
		}
		return arrayType;
	}

	private TypeReference GetTypeDefOrRef(MetadataToken token)
	{
		return reader.GetTypeDefOrRef(token);
	}

	public TypeReference ReadTypeSignature()
	{
		return ReadTypeSignature((ElementType)ReadByte());
	}

	public TypeReference ReadTypeToken()
	{
		return GetTypeDefOrRef(ReadTypeTokenSignature());
	}

	private TypeReference ReadTypeSignature(ElementType etype)
	{
		switch (etype)
		{
		case ElementType.ValueType:
		{
			TypeReference typeDefOrRef2 = GetTypeDefOrRef(ReadTypeTokenSignature());
			typeDefOrRef2.KnownValueType();
			return typeDefOrRef2;
		}
		case ElementType.Class:
			return GetTypeDefOrRef(ReadTypeTokenSignature());
		case ElementType.Ptr:
			return new PointerType(ReadTypeSignature());
		case ElementType.FnPtr:
		{
			FunctionPointerType functionPointerType = new FunctionPointerType();
			ReadMethodSignature(functionPointerType);
			return functionPointerType;
		}
		case ElementType.ByRef:
			return new ByReferenceType(ReadTypeSignature());
		case ElementType.Pinned:
			return new PinnedType(ReadTypeSignature());
		case ElementType.SzArray:
			return new ArrayType(ReadTypeSignature());
		case ElementType.Array:
			return ReadArrayTypeSignature();
		case ElementType.CModOpt:
			return new OptionalModifierType(GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
		case ElementType.CModReqD:
			return new RequiredModifierType(GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
		case ElementType.Sentinel:
			return new SentinelType(ReadTypeSignature());
		case ElementType.Var:
			return GetGenericParameter(GenericParameterType.Type, ReadCompressedUInt32());
		case ElementType.MVar:
			return GetGenericParameter(GenericParameterType.Method, ReadCompressedUInt32());
		case ElementType.GenericInst:
		{
			bool num = ReadByte() == 17;
			TypeReference typeDefOrRef = GetTypeDefOrRef(ReadTypeTokenSignature());
			uint arity = ReadCompressedUInt32();
			GenericInstanceType genericInstanceType = new GenericInstanceType(typeDefOrRef, (int)arity);
			ReadGenericInstanceSignature(typeDefOrRef, genericInstanceType, arity);
			if (num)
			{
				genericInstanceType.KnownValueType();
				typeDefOrRef.GetElementType().KnownValueType();
			}
			return genericInstanceType;
		}
		case ElementType.Object:
			return TypeSystem.Object;
		case ElementType.Void:
			return TypeSystem.Void;
		case ElementType.TypedByRef:
			return TypeSystem.TypedReference;
		case ElementType.I:
			return TypeSystem.IntPtr;
		case ElementType.U:
			return TypeSystem.UIntPtr;
		default:
			return GetPrimitiveType(etype);
		}
	}

	public void ReadMethodSignature(IMethodSignature method)
	{
		byte b = ReadByte();
		if ((b & 0x20) != 0)
		{
			method.HasThis = true;
			b = (byte)(b & -33);
		}
		if ((b & 0x40) != 0)
		{
			method.ExplicitThis = true;
			b = (byte)(b & -65);
		}
		method.CallingConvention = (MethodCallingConvention)b;
		MethodReference methodReference = method as MethodReference;
		if (methodReference != null && !methodReference.DeclaringType.IsArray)
		{
			reader.context = methodReference;
		}
		if ((b & 0x10) != 0)
		{
			uint num = ReadCompressedUInt32();
			if (methodReference != null && !methodReference.IsDefinition)
			{
				CheckGenericContext(methodReference, (int)(num - 1));
			}
		}
		uint num2 = ReadCompressedUInt32();
		method.MethodReturnType.ReturnType = ReadTypeSignature();
		if (num2 != 0)
		{
			Collection<ParameterDefinition> collection = ((!(method is MethodReference methodReference2)) ? method.Parameters : (methodReference2.parameters = new ParameterDefinitionCollection(method, (int)num2)));
			for (int i = 0; i < num2; i++)
			{
				collection.Add(new ParameterDefinition(ReadTypeSignature()));
			}
		}
	}

	public object ReadConstantSignature(ElementType type)
	{
		return ReadPrimitiveValue(type);
	}

	public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection<ParameterDefinition> parameters)
	{
		int count = parameters.Count;
		if (count != 0)
		{
			attribute.arguments = new Collection<CustomAttributeArgument>(count);
			for (int i = 0; i < count; i++)
			{
				TypeReference type = GenericParameterResolver.ResolveParameterTypeIfNeeded(attribute.Constructor, parameters[i]);
				attribute.arguments.Add(ReadCustomAttributeFixedArgument(type));
			}
		}
	}

	private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type)
	{
		if (type.IsArray)
		{
			return ReadCustomAttributeFixedArrayArgument((ArrayType)type);
		}
		return ReadCustomAttributeElement(type);
	}

	public void ReadCustomAttributeNamedArguments(ushort count, ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
	{
		for (int i = 0; i < count; i++)
		{
			if (!CanReadMore())
			{
				break;
			}
			ReadCustomAttributeNamedArgument(ref fields, ref properties);
		}
	}

	private void ReadCustomAttributeNamedArgument(ref Collection<CustomAttributeNamedArgument> fields, ref Collection<CustomAttributeNamedArgument> properties)
	{
		byte b = ReadByte();
		TypeReference type = ReadCustomAttributeFieldOrPropType();
		string name = ReadUTF8String();
		(b switch
		{
			83 => GetCustomAttributeNamedArgumentCollection(ref fields), 
			84 => GetCustomAttributeNamedArgumentCollection(ref properties), 
			_ => throw new NotSupportedException(), 
		}).Add(new CustomAttributeNamedArgument(name, ReadCustomAttributeFixedArgument(type)));
	}

	private static Collection<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(ref Collection<CustomAttributeNamedArgument> collection)
	{
		if (collection != null)
		{
			return collection;
		}
		return collection = new Collection<CustomAttributeNamedArgument>();
	}

	private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type)
	{
		uint num = ReadUInt32();
		switch (num)
		{
		case uint.MaxValue:
			return new CustomAttributeArgument(type, null);
		case 0u:
			return new CustomAttributeArgument(type, Empty<CustomAttributeArgument>.Array);
		default:
		{
			CustomAttributeArgument[] array = new CustomAttributeArgument[num];
			TypeReference elementType = type.ElementType;
			for (int i = 0; i < num; i++)
			{
				array[i] = ReadCustomAttributeElement(elementType);
			}
			return new CustomAttributeArgument(type, array);
		}
		}
	}

	private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type)
	{
		if (type.IsArray)
		{
			return ReadCustomAttributeFixedArrayArgument((ArrayType)type);
		}
		return new CustomAttributeArgument(type, (type.etype == ElementType.Object) ? ((object)ReadCustomAttributeElement(ReadCustomAttributeFieldOrPropType())) : ReadCustomAttributeElementValue(type));
	}

	private object ReadCustomAttributeElementValue(TypeReference type)
	{
		ElementType etype = type.etype;
		if (etype == ElementType.GenericInst)
		{
			type = type.GetElementType();
			etype = type.etype;
		}
		switch (etype)
		{
		case ElementType.String:
			return ReadUTF8String();
		case ElementType.None:
			if (type.IsTypeOf("System", "Type"))
			{
				return ReadTypeReference();
			}
			return ReadCustomAttributeEnum(type);
		default:
			return ReadPrimitiveValue(etype);
		}
	}

	private object ReadPrimitiveValue(ElementType type)
	{
		return type switch
		{
			ElementType.Boolean => ReadByte() == 1, 
			ElementType.I1 => (sbyte)ReadByte(), 
			ElementType.U1 => ReadByte(), 
			ElementType.Char => (char)ReadUInt16(), 
			ElementType.I2 => ReadInt16(), 
			ElementType.U2 => ReadUInt16(), 
			ElementType.I4 => ReadInt32(), 
			ElementType.U4 => ReadUInt32(), 
			ElementType.I8 => ReadInt64(), 
			ElementType.U8 => ReadUInt64(), 
			ElementType.R4 => ReadSingle(), 
			ElementType.R8 => ReadDouble(), 
			_ => throw new NotImplementedException(type.ToString()), 
		};
	}

	private TypeReference GetPrimitiveType(ElementType etype)
	{
		return etype switch
		{
			ElementType.Boolean => TypeSystem.Boolean, 
			ElementType.Char => TypeSystem.Char, 
			ElementType.I1 => TypeSystem.SByte, 
			ElementType.U1 => TypeSystem.Byte, 
			ElementType.I2 => TypeSystem.Int16, 
			ElementType.U2 => TypeSystem.UInt16, 
			ElementType.I4 => TypeSystem.Int32, 
			ElementType.U4 => TypeSystem.UInt32, 
			ElementType.I8 => TypeSystem.Int64, 
			ElementType.U8 => TypeSystem.UInt64, 
			ElementType.R4 => TypeSystem.Single, 
			ElementType.R8 => TypeSystem.Double, 
			ElementType.String => TypeSystem.String, 
			_ => throw new NotImplementedException(etype.ToString()), 
		};
	}

	private TypeReference ReadCustomAttributeFieldOrPropType()
	{
		ElementType elementType = (ElementType)ReadByte();
		return elementType switch
		{
			ElementType.Boxed => TypeSystem.Object, 
			ElementType.SzArray => new ArrayType(ReadCustomAttributeFieldOrPropType()), 
			ElementType.Enum => ReadTypeReference(), 
			ElementType.Type => TypeSystem.LookupType("System", "Type"), 
			_ => GetPrimitiveType(elementType), 
		};
	}

	public TypeReference ReadTypeReference()
	{
		return TypeParser.ParseType(reader.module, ReadUTF8String());
	}

	private object ReadCustomAttributeEnum(TypeReference enum_type)
	{
		TypeDefinition typeDefinition = enum_type.CheckedResolve();
		if (!typeDefinition.IsEnum)
		{
			throw new ArgumentException();
		}
		return ReadCustomAttributeElementValue(typeDefinition.GetEnumUnderlyingType());
	}

	public SecurityAttribute ReadSecurityAttribute()
	{
		SecurityAttribute securityAttribute = new SecurityAttribute(ReadTypeReference());
		ReadCompressedUInt32();
		ReadCustomAttributeNamedArguments((ushort)ReadCompressedUInt32(), ref securityAttribute.fields, ref securityAttribute.properties);
		return securityAttribute;
	}

	public MarshalInfo ReadMarshalInfo()
	{
		NativeType nativeType = ReadNativeType();
		switch (nativeType)
		{
		case NativeType.Array:
		{
			ArrayMarshalInfo arrayMarshalInfo = new ArrayMarshalInfo();
			if (CanReadMore())
			{
				arrayMarshalInfo.element_type = ReadNativeType();
			}
			if (CanReadMore())
			{
				arrayMarshalInfo.size_parameter_index = (int)ReadCompressedUInt32();
			}
			if (CanReadMore())
			{
				arrayMarshalInfo.size = (int)ReadCompressedUInt32();
			}
			if (CanReadMore())
			{
				arrayMarshalInfo.size_parameter_multiplier = (int)ReadCompressedUInt32();
			}
			return arrayMarshalInfo;
		}
		case NativeType.SafeArray:
		{
			SafeArrayMarshalInfo safeArrayMarshalInfo = new SafeArrayMarshalInfo();
			if (CanReadMore())
			{
				safeArrayMarshalInfo.element_type = ReadVariantType();
			}
			return safeArrayMarshalInfo;
		}
		case NativeType.FixedArray:
		{
			FixedArrayMarshalInfo fixedArrayMarshalInfo = new FixedArrayMarshalInfo();
			if (CanReadMore())
			{
				fixedArrayMarshalInfo.size = (int)ReadCompressedUInt32();
			}
			if (CanReadMore())
			{
				fixedArrayMarshalInfo.element_type = ReadNativeType();
			}
			return fixedArrayMarshalInfo;
		}
		case NativeType.FixedSysString:
		{
			FixedSysStringMarshalInfo fixedSysStringMarshalInfo = new FixedSysStringMarshalInfo();
			if (CanReadMore())
			{
				fixedSysStringMarshalInfo.size = (int)ReadCompressedUInt32();
			}
			return fixedSysStringMarshalInfo;
		}
		case NativeType.CustomMarshaler:
		{
			CustomMarshalInfo customMarshalInfo = new CustomMarshalInfo();
			string text = ReadUTF8String();
			customMarshalInfo.guid = ((!string.IsNullOrEmpty(text)) ? new Guid(text) : Guid.Empty);
			customMarshalInfo.unmanaged_type = ReadUTF8String();
			customMarshalInfo.managed_type = ReadTypeReference();
			customMarshalInfo.cookie = ReadUTF8String();
			return customMarshalInfo;
		}
		default:
			return new MarshalInfo(nativeType);
		}
	}

	private NativeType ReadNativeType()
	{
		return (NativeType)ReadByte();
	}

	private VariantType ReadVariantType()
	{
		return (VariantType)ReadByte();
	}

	private string ReadUTF8String()
	{
		if (buffer[position] == byte.MaxValue)
		{
			position++;
			return null;
		}
		int num = (int)ReadCompressedUInt32();
		if (num == 0)
		{
			return string.Empty;
		}
		if (position + num > buffer.Length)
		{
			return string.Empty;
		}
		string @string = Encoding.UTF8.GetString(buffer, position, num);
		position += num;
		return @string;
	}

	public string ReadDocumentName()
	{
		char c = (char)buffer[position];
		position++;
		StringBuilder stringBuilder = new StringBuilder();
		int num = 0;
		while (CanReadMore())
		{
			if (num > 0 && c != 0)
			{
				stringBuilder.Append(c);
			}
			uint num2 = ReadCompressedUInt32();
			if (num2 != 0)
			{
				stringBuilder.Append(reader.ReadUTF8StringBlob(num2));
			}
			num++;
		}
		return stringBuilder.ToString();
	}

	public Collection<SequencePoint> ReadSequencePoints(Document document)
	{
		ReadCompressedUInt32();
		if (document == null)
		{
			document = reader.GetDocument(ReadCompressedUInt32());
		}
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		bool flag = true;
		Collection<SequencePoint> collection = new Collection<SequencePoint>((int)(sig_length - (position - start)) / 5);
		int num4 = 0;
		while (CanReadMore())
		{
			int num5 = (int)ReadCompressedUInt32();
			if (num4 > 0 && num5 == 0)
			{
				document = reader.GetDocument(ReadCompressedUInt32());
			}
			else
			{
				num += num5;
				int num6 = (int)ReadCompressedUInt32();
				int num7 = ((num6 == 0) ? ((int)ReadCompressedUInt32()) : ReadCompressedInt32());
				if (num6 == 0 && num7 == 0)
				{
					collection.Add(new SequencePoint(num, document)
					{
						StartLine = 16707566,
						EndLine = 16707566,
						StartColumn = 0,
						EndColumn = 0
					});
				}
				else
				{
					if (flag)
					{
						num2 = (int)ReadCompressedUInt32();
						num3 = (int)ReadCompressedUInt32();
					}
					else
					{
						num2 += ReadCompressedInt32();
						num3 += ReadCompressedInt32();
					}
					collection.Add(new SequencePoint(num, document)
					{
						StartLine = num2,
						StartColumn = num3,
						EndLine = num2 + num6,
						EndColumn = num3 + num7
					});
					flag = false;
				}
			}
			num4++;
		}
		return collection;
	}

	public bool CanReadMore()
	{
		return position - start < sig_length;
	}
}


using System;
using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal static class ModuleWriter
{
	public static void WriteModule(ModuleDefinition module, Disposable<Stream> stream, WriterParameters parameters)
	{
		using (stream)
		{
			Write(module, stream, parameters);
		}
	}

	private static void Write(ModuleDefinition module, Disposable<Stream> stream, WriterParameters parameters)
	{
		if ((module.Attributes & ModuleAttributes.ILOnly) == 0)
		{
			throw new NotSupportedException("Writing mixed-mode assemblies is not supported");
		}
		if (module.HasImage && module.ReadingMode == ReadingMode.Deferred)
		{
			ImmediateModuleReader immediateModuleReader = new ImmediateModuleReader(module.Image);
			immediateModuleReader.ReadModule(module, resolve_attributes: false);
			immediateModuleReader.ReadSymbols(module);
		}
		module.MetadataSystem.Clear();
		if (module.symbol_reader != null)
		{
			module.symbol_reader.Dispose();
		}
		AssemblyNameDefinition assemblyNameDefinition = ((module.assembly != null && module.kind != ModuleKind.NetModule) ? module.assembly.Name : null);
		string fileName = stream.value.GetFileName();
		uint timestamp = parameters.Timestamp ?? module.timestamp;
		ISymbolWriterProvider symbolWriterProvider = parameters.SymbolWriterProvider;
		if (symbolWriterProvider == null && parameters.WriteSymbols)
		{
			symbolWriterProvider = new DefaultSymbolWriterProvider();
		}
		if (parameters.HasStrongNameKey && assemblyNameDefinition != null)
		{
			assemblyNameDefinition.PublicKey = CryptoService.GetPublicKey(parameters);
			module.Attributes |= ModuleAttributes.StrongNameSigned;
		}
		if (parameters.DeterministicMvid)
		{
			module.Mvid = Guid.Empty;
		}
		MetadataBuilder metadataBuilder = new MetadataBuilder(module, fileName, timestamp, symbolWriterProvider);
		try
		{
			module.metadata_builder = metadataBuilder;
			using ISymbolWriter symbolWriter = GetSymbolWriter(module, fileName, symbolWriterProvider, parameters);
			metadataBuilder.SetSymbolWriter(symbolWriter);
			BuildMetadata(module, metadataBuilder);
			symbolWriter?.Write();
			ImageWriter imageWriter = ImageWriter.CreateWriter(module, metadataBuilder, stream);
			stream.value.SetLength(0L);
			imageWriter.WriteImage();
			if (parameters.DeterministicMvid)
			{
				ComputeDeterministicMvid(imageWriter, module);
			}
			if (parameters.HasStrongNameKey)
			{
				CryptoService.StrongName(stream.value, imageWriter, parameters);
			}
		}
		finally
		{
			module.metadata_builder = null;
		}
	}

	private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata)
	{
		if (!module.HasImage)
		{
			metadata.BuildMetadata();
			return;
		}
		module.Read(metadata, delegate(MetadataBuilder builder, MetadataReader _)
		{
			builder.BuildMetadata();
			return builder;
		});
	}

	private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters)
	{
		if (symbol_writer_provider == null)
		{
			return null;
		}
		if (parameters.SymbolStream != null)
		{
			return symbol_writer_provider.GetSymbolWriter(module, parameters.SymbolStream);
		}
		return symbol_writer_provider.GetSymbolWriter(module, fq_name);
	}

	private static void ComputeDeterministicMvid(ImageWriter writer, ModuleDefinition module)
	{
		long position = writer.BaseStream.Position;
		writer.BaseStream.Seek(0L, SeekOrigin.Begin);
		Guid mvid = CryptoService.ComputeGuid(CryptoService.ComputeHash(writer.BaseStream));
		writer.MoveToRVA(TextSegment.GuidHeap);
		writer.WriteBytes(mvid.ToByteArray());
		writer.Flush();
		module.Mvid = mvid;
		writer.BaseStream.Seek(position, SeekOrigin.Begin);
	}
}


using Mono.Cecil.Metadata;

internal abstract class MetadataTable
{
	public abstract int Length { get; }

	public bool IsLarge => Length > 65535;

	public abstract void Write(TableHeapBuffer buffer);

	public abstract void Sort();
}


using Mono.Cecil;

internal abstract class OneRowTable<TRow> : MetadataTable where TRow : struct
{
	internal TRow row;

	public sealed override int Length => 1;

	public sealed override void Sort()
	{
	}
}


using System;
using Mono.Cecil;

internal abstract class MetadataTable<TRow> : MetadataTable where TRow : struct
{
	internal TRow[] rows = new TRow[2];

	internal int length;

	public sealed override int Length => length;

	public int AddRow(TRow row)
	{
		if (rows.Length == length)
		{
			Grow();
		}
		rows[length++] = row;
		return length;
	}

	private void Grow()
	{
		TRow[] destinationArray = new TRow[rows.Length * 2];
		Array.Copy(rows, destinationArray, rows.Length);
		rows = destinationArray;
	}

	public override void Sort()
	{
	}
}


using System.Collections.Generic;
using Mono;
using Mono.Cecil;

internal abstract class SortedTable<TRow> : MetadataTable<TRow>, IComparer<TRow> where TRow : struct
{
	public sealed override void Sort()
	{
		MergeSort<TRow>.Sort(rows, 0, length, this);
	}

	protected static int Compare(uint x, uint y)
	{
		if (x != y)
		{
			if (x <= y)
			{
				return -1;
			}
			return 1;
		}
		return 0;
	}

	public abstract int Compare(TRow x, TRow y);
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ModuleTable : OneRowTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		buffer.WriteUInt16(0);
		buffer.WriteString(row.Col1);
		buffer.WriteGuid(row.Col2);
		buffer.WriteUInt16(0);
		buffer.WriteUInt16(0);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TypeRefTable : MetadataTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.ResolutionScope);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TypeDefTable : MetadataTable<Row<TypeAttributes, uint, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32((uint)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteCodedRID(rows[i].Col4, CodedIndex.TypeDefOrRef);
			buffer.WriteRID(rows[i].Col5, Table.Field);
			buffer.WriteRID(rows[i].Col6, Table.Method);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldTable : MetadataTable<Row<FieldAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodTable : MetadataTable<Row<uint, MethodImplAttributes, MethodAttributes, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteUInt16((ushort)rows[i].Col2);
			buffer.WriteUInt16((ushort)rows[i].Col3);
			buffer.WriteString(rows[i].Col4);
			buffer.WriteBlob(rows[i].Col5);
			buffer.WriteRID(rows[i].Col6, Table.Param);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ParamTable : MetadataTable<Row<ParameterAttributes, ushort, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteUInt16(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class InterfaceImplTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MemberRefTable : MetadataTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MemberRefParent);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ConstantTable : SortedTable<Row<ElementType, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasConstant);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<ElementType, uint, uint> x, Row<ElementType, uint, uint> y)
	{
		return SortedTable<Row<ElementType, uint, uint>>.Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class CustomAttributeTable : SortedTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasCustomAttribute);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.CustomAttributeType);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
	{
		return SortedTable<Row<uint, uint, uint>>.Compare(x.Col1, y.Col1);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldMarshalTable : SortedTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasFieldMarshal);
			buffer.WriteBlob(rows[i].Col2);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return SortedTable<Row<uint, uint>>.Compare(x.Col1, y.Col1);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class DeclSecurityTable : SortedTable<Row<SecurityAction, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasDeclSecurity);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<SecurityAction, uint, uint> x, Row<SecurityAction, uint, uint> y)
	{
		return SortedTable<Row<SecurityAction, uint, uint>>.Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ClassLayoutTable : SortedTable<Row<ushort, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16(rows[i].Col1);
			buffer.WriteUInt32(rows[i].Col2);
			buffer.WriteRID(rows[i].Col3, Table.TypeDef);
		}
	}

	public override int Compare(Row<ushort, uint, uint> x, Row<ushort, uint, uint> y)
	{
		return SortedTable<Row<ushort, uint, uint>>.Compare(x.Col3, y.Col3);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldLayoutTable : SortedTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteRID(rows[i].Col2, Table.Field);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return SortedTable<Row<uint, uint>>.Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class StandAloneSigTable : MetadataTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteBlob(rows[i]);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class EventMapTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteRID(rows[i].Col2, Table.Event);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class EventTable : MetadataTable<Row<EventAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class PropertyMapTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteRID(rows[i].Col2, Table.Property);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class PropertyTable : MetadataTable<Row<PropertyAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodSemanticsTable : SortedTable<Row<MethodSemanticsAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteRID(rows[i].Col2, Table.Method);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.HasSemantics);
		}
	}

	public override int Compare(Row<MethodSemanticsAttributes, uint, uint> x, Row<MethodSemanticsAttributes, uint, uint> y)
	{
		return SortedTable<Row<MethodSemanticsAttributes, uint, uint>>.Compare(x.Col3, y.Col3);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodImplTable : MetadataTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MethodDefOrRef);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.MethodDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ModuleRefTable : MetadataTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteString(rows[i]);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TypeSpecTable : MetadataTable<uint>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteBlob(rows[i]);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ImplMapTable : SortedTable<Row<PInvokeAttributes, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MemberForwarded);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteRID(rows[i].Col4, Table.ModuleRef);
		}
	}

	public override int Compare(Row<PInvokeAttributes, uint, uint, uint> x, Row<PInvokeAttributes, uint, uint, uint> y)
	{
		return SortedTable<Row<PInvokeAttributes, uint, uint, uint>>.Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FieldRVATable : SortedTable<Row<uint, uint>>
{
	internal int position;

	public override void Write(TableHeapBuffer buffer)
	{
		position = buffer.position;
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteRID(rows[i].Col2, Table.Field);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return SortedTable<Row<uint, uint>>.Compare(x.Col2, y.Col2);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class AssemblyTable : OneRowTable<Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		buffer.WriteUInt32((uint)row.Col1);
		buffer.WriteUInt16(row.Col2);
		buffer.WriteUInt16(row.Col3);
		buffer.WriteUInt16(row.Col4);
		buffer.WriteUInt16(row.Col5);
		buffer.WriteUInt32((uint)row.Col6);
		buffer.WriteBlob(row.Col7);
		buffer.WriteString(row.Col8);
		buffer.WriteString(row.Col9);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class AssemblyRefTable : MetadataTable<Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16(rows[i].Col1);
			buffer.WriteUInt16(rows[i].Col2);
			buffer.WriteUInt16(rows[i].Col3);
			buffer.WriteUInt16(rows[i].Col4);
			buffer.WriteUInt32((uint)rows[i].Col5);
			buffer.WriteBlob(rows[i].Col6);
			buffer.WriteString(rows[i].Col7);
			buffer.WriteString(rows[i].Col8);
			buffer.WriteBlob(rows[i].Col9);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class FileTable : MetadataTable<Row<FileAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32((uint)rows[i].Col1);
			buffer.WriteString(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ExportedTypeTable : MetadataTable<Row<TypeAttributes, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32((uint)rows[i].Col1);
			buffer.WriteUInt32(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteString(rows[i].Col4);
			buffer.WriteCodedRID(rows[i].Col5, CodedIndex.Implementation);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ManifestResourceTable : MetadataTable<Row<uint, ManifestResourceAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt32(rows[i].Col1);
			buffer.WriteUInt32((uint)rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
			buffer.WriteCodedRID(rows[i].Col4, CodedIndex.Implementation);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class NestedClassTable : SortedTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.TypeDef);
			buffer.WriteRID(rows[i].Col2, Table.TypeDef);
		}
	}

	public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
	{
		return SortedTable<Row<uint, uint>>.Compare(x.Col1, y.Col1);
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class GenericParamTable : MetadataTable<Row<ushort, GenericParameterAttributes, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16(rows[i].Col1);
			buffer.WriteUInt16((ushort)rows[i].Col2);
			buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeOrMethodDef);
			buffer.WriteString(rows[i].Col4);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodSpecTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MethodDefOrRef);
			buffer.WriteBlob(rows[i].Col2);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class GenericParamConstraintTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.GenericParam);
			buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class DocumentTable : MetadataTable<Row<uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteBlob(rows[i].Col1);
			buffer.WriteGuid(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
			buffer.WriteGuid(rows[i].Col4);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class MethodDebugInformationTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.Document);
			buffer.WriteBlob(rows[i].Col2);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class LocalScopeTable : MetadataTable<Row<uint, uint, uint, uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.Method);
			buffer.WriteRID(rows[i].Col2, Table.ImportScope);
			buffer.WriteRID(rows[i].Col3, Table.LocalVariable);
			buffer.WriteRID(rows[i].Col4, Table.LocalConstant);
			buffer.WriteUInt32(rows[i].Col5);
			buffer.WriteUInt32(rows[i].Col6);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;

internal sealed class LocalVariableTable : MetadataTable<Row<VariableAttributes, ushort, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteUInt16((ushort)rows[i].Col1);
			buffer.WriteUInt16(rows[i].Col2);
			buffer.WriteString(rows[i].Col3);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class LocalConstantTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteString(rows[i].Col1);
			buffer.WriteBlob(rows[i].Col2);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ImportScopeTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.ImportScope);
			buffer.WriteBlob(rows[i].Col2);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class StateMachineMethodTable : MetadataTable<Row<uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteRID(rows[i].Col1, Table.Method);
			buffer.WriteRID(rows[i].Col2, Table.Method);
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class CustomDebugInformationTable : SortedTable<Row<uint, uint, uint>>
{
	public override void Write(TableHeapBuffer buffer)
	{
		for (int i = 0; i < length; i++)
		{
			buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasCustomDebugInformation);
			buffer.WriteGuid(rows[i].Col2);
			buffer.WriteBlob(rows[i].Col3);
		}
	}

	public override int Compare(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
	{
		return SortedTable<Row<uint, uint, uint>>.Compare(x.Col1, y.Col1);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class MetadataBuilder
{
	private sealed class GenericParameterComparer : IComparer<GenericParameter>
	{
		public int Compare(GenericParameter a, GenericParameter b)
		{
			uint num = MakeCodedRID(a.Owner, CodedIndex.TypeOrMethodDef);
			uint num2 = MakeCodedRID(b.Owner, CodedIndex.TypeOrMethodDef);
			if (num == num2)
			{
				int position = a.Position;
				int position2 = b.Position;
				if (position != position2)
				{
					if (position <= position2)
					{
						return -1;
					}
					return 1;
				}
				return 0;
			}
			if (num <= num2)
			{
				return -1;
			}
			return 1;
		}
	}

	internal readonly ModuleDefinition module;

	internal readonly ISymbolWriterProvider symbol_writer_provider;

	internal ISymbolWriter symbol_writer;

	internal readonly TextMap text_map;

	internal readonly string fq_name;

	internal readonly uint timestamp;

	private readonly Dictionary<Row<uint, uint, uint>, MetadataToken> type_ref_map;

	private readonly Dictionary<uint, MetadataToken> type_spec_map;

	private readonly Dictionary<Row<uint, uint, uint>, MetadataToken> member_ref_map;

	private readonly Dictionary<Row<uint, uint>, MetadataToken> method_spec_map;

	private readonly Collection<GenericParameter> generic_parameters;

	internal readonly CodeWriter code;

	internal readonly DataBuffer data;

	internal readonly ResourceBuffer resources;

	internal readonly StringHeapBuffer string_heap;

	internal readonly GuidHeapBuffer guid_heap;

	internal readonly UserStringHeapBuffer user_string_heap;

	internal readonly BlobHeapBuffer blob_heap;

	internal readonly TableHeapBuffer table_heap;

	internal readonly PdbHeapBuffer pdb_heap;

	internal MetadataToken entry_point;

	internal uint type_rid = 1u;

	internal uint field_rid = 1u;

	internal uint method_rid = 1u;

	internal uint param_rid = 1u;

	internal uint property_rid = 1u;

	internal uint event_rid = 1u;

	internal uint local_variable_rid = 1u;

	internal uint local_constant_rid = 1u;

	private readonly TypeRefTable type_ref_table;

	private readonly TypeDefTable type_def_table;

	private readonly FieldTable field_table;

	private readonly MethodTable method_table;

	private readonly ParamTable param_table;

	private readonly InterfaceImplTable iface_impl_table;

	private readonly MemberRefTable member_ref_table;

	private readonly ConstantTable constant_table;

	private readonly CustomAttributeTable custom_attribute_table;

	private readonly DeclSecurityTable declsec_table;

	private readonly StandAloneSigTable standalone_sig_table;

	private readonly EventMapTable event_map_table;

	private readonly EventTable event_table;

	private readonly PropertyMapTable property_map_table;

	private readonly PropertyTable property_table;

	private readonly TypeSpecTable typespec_table;

	private readonly MethodSpecTable method_spec_table;

	internal MetadataBuilder metadata_builder;

	private readonly DocumentTable document_table;

	private readonly MethodDebugInformationTable method_debug_information_table;

	private readonly LocalScopeTable local_scope_table;

	private readonly LocalVariableTable local_variable_table;

	private readonly LocalConstantTable local_constant_table;

	private readonly ImportScopeTable import_scope_table;

	private readonly StateMachineMethodTable state_machine_method_table;

	private readonly CustomDebugInformationTable custom_debug_information_table;

	private readonly Dictionary<Row<uint, uint>, MetadataToken> import_scope_map;

	private readonly Dictionary<string, MetadataToken> document_map;

	public MetadataBuilder(ModuleDefinition module, string fq_name, uint timestamp, ISymbolWriterProvider symbol_writer_provider)
	{
		this.module = module;
		text_map = CreateTextMap();
		this.fq_name = fq_name;
		this.timestamp = timestamp;
		this.symbol_writer_provider = symbol_writer_provider;
		code = new CodeWriter(this);
		data = new DataBuffer();
		resources = new ResourceBuffer();
		string_heap = new StringHeapBuffer();
		guid_heap = new GuidHeapBuffer();
		user_string_heap = new UserStringHeapBuffer();
		blob_heap = new BlobHeapBuffer();
		table_heap = new TableHeapBuffer(module, this);
		type_ref_table = GetTable<TypeRefTable>(Table.TypeRef);
		type_def_table = GetTable<TypeDefTable>(Table.TypeDef);
		field_table = GetTable<FieldTable>(Table.Field);
		method_table = GetTable<MethodTable>(Table.Method);
		param_table = GetTable<ParamTable>(Table.Param);
		iface_impl_table = GetTable<InterfaceImplTable>(Table.InterfaceImpl);
		member_ref_table = GetTable<MemberRefTable>(Table.MemberRef);
		constant_table = GetTable<ConstantTable>(Table.Constant);
		custom_attribute_table = GetTable<CustomAttributeTable>(Table.CustomAttribute);
		declsec_table = GetTable<DeclSecurityTable>(Table.DeclSecurity);
		standalone_sig_table = GetTable<StandAloneSigTable>(Table.StandAloneSig);
		event_map_table = GetTable<EventMapTable>(Table.EventMap);
		event_table = GetTable<EventTable>(Table.Event);
		property_map_table = GetTable<PropertyMapTable>(Table.PropertyMap);
		property_table = GetTable<PropertyTable>(Table.Property);
		typespec_table = GetTable<TypeSpecTable>(Table.TypeSpec);
		method_spec_table = GetTable<MethodSpecTable>(Table.MethodSpec);
		RowEqualityComparer comparer = new RowEqualityComparer();
		type_ref_map = new Dictionary<Row<uint, uint, uint>, MetadataToken>(comparer);
		type_spec_map = new Dictionary<uint, MetadataToken>();
		member_ref_map = new Dictionary<Row<uint, uint, uint>, MetadataToken>(comparer);
		method_spec_map = new Dictionary<Row<uint, uint>, MetadataToken>(comparer);
		generic_parameters = new Collection<GenericParameter>();
		document_table = GetTable<DocumentTable>(Table.Document);
		method_debug_information_table = GetTable<MethodDebugInformationTable>(Table.MethodDebugInformation);
		local_scope_table = GetTable<LocalScopeTable>(Table.LocalScope);
		local_variable_table = GetTable<LocalVariableTable>(Table.LocalVariable);
		local_constant_table = GetTable<LocalConstantTable>(Table.LocalConstant);
		import_scope_table = GetTable<ImportScopeTable>(Table.ImportScope);
		state_machine_method_table = GetTable<StateMachineMethodTable>(Table.StateMachineMethod);
		custom_debug_information_table = GetTable<CustomDebugInformationTable>(Table.CustomDebugInformation);
		document_map = new Dictionary<string, MetadataToken>(StringComparer.Ordinal);
		import_scope_map = new Dictionary<Row<uint, uint>, MetadataToken>(comparer);
	}

	public MetadataBuilder(ModuleDefinition module, PortablePdbWriterProvider writer_provider)
	{
		this.module = module;
		text_map = new TextMap();
		symbol_writer_provider = writer_provider;
		string_heap = new StringHeapBuffer();
		guid_heap = new GuidHeapBuffer();
		user_string_heap = new UserStringHeapBuffer();
		blob_heap = new BlobHeapBuffer();
		table_heap = new TableHeapBuffer(module, this);
		pdb_heap = new PdbHeapBuffer();
		document_table = GetTable<DocumentTable>(Table.Document);
		method_debug_information_table = GetTable<MethodDebugInformationTable>(Table.MethodDebugInformation);
		local_scope_table = GetTable<LocalScopeTable>(Table.LocalScope);
		local_variable_table = GetTable<LocalVariableTable>(Table.LocalVariable);
		local_constant_table = GetTable<LocalConstantTable>(Table.LocalConstant);
		import_scope_table = GetTable<ImportScopeTable>(Table.ImportScope);
		state_machine_method_table = GetTable<StateMachineMethodTable>(Table.StateMachineMethod);
		custom_debug_information_table = GetTable<CustomDebugInformationTable>(Table.CustomDebugInformation);
		RowEqualityComparer comparer = new RowEqualityComparer();
		document_map = new Dictionary<string, MetadataToken>();
		import_scope_map = new Dictionary<Row<uint, uint>, MetadataToken>(comparer);
	}

	public void SetSymbolWriter(ISymbolWriter writer)
	{
		symbol_writer = writer;
		if (symbol_writer == null && module.HasImage && module.Image.HasDebugTables())
		{
			symbol_writer = new PortablePdbWriter(this, module);
		}
	}

	private TextMap CreateTextMap()
	{
		TextMap textMap = new TextMap();
		textMap.AddMap(TextSegment.ImportAddressTable, (module.Architecture == TargetArchitecture.I386) ? 8 : 0);
		textMap.AddMap(TextSegment.CLIHeader, 72, 8);
		bool flag = module.Architecture == TargetArchitecture.AMD64 || module.Architecture == TargetArchitecture.IA64 || module.Architecture == TargetArchitecture.ARM64;
		textMap.AddMap(TextSegment.Code, 0, (!flag) ? 4 : 16);
		return textMap;
	}

	private TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
	{
		return table_heap.GetTable<TTable>(table);
	}

	private uint GetStringIndex(string @string)
	{
		if (string.IsNullOrEmpty(@string))
		{
			return 0u;
		}
		return string_heap.GetStringIndex(@string);
	}

	private uint GetGuidIndex(Guid guid)
	{
		return guid_heap.GetGuidIndex(guid);
	}

	private uint GetBlobIndex(ByteBuffer blob)
	{
		if (blob.length == 0)
		{
			return 0u;
		}
		return blob_heap.GetBlobIndex(blob);
	}

	private uint GetBlobIndex(byte[] blob)
	{
		if (blob.IsNullOrEmpty())
		{
			return 0u;
		}
		return GetBlobIndex(new ByteBuffer(blob));
	}

	public void BuildMetadata()
	{
		BuildModule();
		table_heap.string_offsets = string_heap.WriteStrings();
		table_heap.ComputeTableInformations();
		table_heap.WriteTableHeap();
	}

	private void BuildModule()
	{
		ModuleTable table = GetTable<ModuleTable>(Table.Module);
		table.row.Col1 = GetStringIndex(module.Name);
		table.row.Col2 = GetGuidIndex(module.Mvid);
		AssemblyDefinition assembly = module.Assembly;
		if (module.kind != ModuleKind.NetModule && assembly != null)
		{
			BuildAssembly();
		}
		if (module.HasAssemblyReferences)
		{
			AddAssemblyReferences();
		}
		if (module.HasModuleReferences)
		{
			AddModuleReferences();
		}
		if (module.HasResources)
		{
			AddResources();
		}
		if (module.HasExportedTypes)
		{
			AddExportedTypes();
		}
		BuildTypes();
		if (module.kind != ModuleKind.NetModule && assembly != null)
		{
			if (assembly.HasCustomAttributes)
			{
				AddCustomAttributes(assembly);
			}
			if (assembly.HasSecurityDeclarations)
			{
				AddSecurityDeclarations(assembly);
			}
		}
		if (module.HasCustomAttributes)
		{
			AddCustomAttributes(module);
		}
		if (module.EntryPoint != null)
		{
			entry_point = LookupToken(module.EntryPoint);
		}
	}

	private void BuildAssembly()
	{
		AssemblyDefinition assembly = module.Assembly;
		AssemblyNameDefinition name = assembly.Name;
		GetTable<AssemblyTable>(Table.Assembly).row = new Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>(name.HashAlgorithm, (ushort)name.Version.Major, (ushort)name.Version.Minor, (ushort)name.Version.Build, (ushort)name.Version.Revision, name.Attributes, GetBlobIndex(name.PublicKey), GetStringIndex(name.Name), GetStringIndex(name.Culture));
		if (assembly.Modules.Count > 1)
		{
			BuildModules();
		}
	}

	private void BuildModules()
	{
		Collection<ModuleDefinition> modules = module.Assembly.Modules;
		FileTable table = GetTable<FileTable>(Table.File);
		for (int i = 0; i < modules.Count; i++)
		{
			ModuleDefinition moduleDefinition = modules[i];
			if (!moduleDefinition.IsMain)
			{
				WriterParameters parameters = new WriterParameters
				{
					SymbolWriterProvider = symbol_writer_provider
				};
				string moduleFileName = GetModuleFileName(moduleDefinition.Name);
				moduleDefinition.Write(moduleFileName, parameters);
				byte[] blob = CryptoService.ComputeHash(moduleFileName);
				table.AddRow(new Row<Mono.Cecil.FileAttributes, uint, uint>(Mono.Cecil.FileAttributes.ContainsMetaData, GetStringIndex(moduleDefinition.Name), GetBlobIndex(blob)));
			}
		}
	}

	private string GetModuleFileName(string name)
	{
		if (string.IsNullOrEmpty(name))
		{
			throw new NotSupportedException();
		}
		return Path.Combine(Path.GetDirectoryName(fq_name), name);
	}

	private void AddAssemblyReferences()
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		AssemblyRefTable table = GetTable<AssemblyRefTable>(Table.AssemblyRef);
		if (module.IsWindowsMetadata())
		{
			module.Projections.RemoveVirtualReferences(assemblyReferences);
		}
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			byte[] blob = (assemblyNameReference.PublicKey.IsNullOrEmpty() ? assemblyNameReference.PublicKeyToken : assemblyNameReference.PublicKey);
			Version version = assemblyNameReference.Version;
			int rid = table.AddRow(new Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>((ushort)version.Major, (ushort)version.Minor, (ushort)version.Build, (ushort)version.Revision, assemblyNameReference.Attributes, GetBlobIndex(blob), GetStringIndex(assemblyNameReference.Name), GetStringIndex(assemblyNameReference.Culture), GetBlobIndex(assemblyNameReference.Hash)));
			assemblyNameReference.token = new MetadataToken(TokenType.AssemblyRef, rid);
		}
		if (module.IsWindowsMetadata())
		{
			module.Projections.AddVirtualReferences(assemblyReferences);
		}
	}

	private void AddModuleReferences()
	{
		Collection<ModuleReference> moduleReferences = module.ModuleReferences;
		ModuleRefTable table = GetTable<ModuleRefTable>(Table.ModuleRef);
		for (int i = 0; i < moduleReferences.Count; i++)
		{
			ModuleReference moduleReference = moduleReferences[i];
			moduleReference.token = new MetadataToken(TokenType.ModuleRef, table.AddRow(GetStringIndex(moduleReference.Name)));
		}
	}

	private void AddResources()
	{
		Collection<Resource> collection = module.Resources;
		ManifestResourceTable table = GetTable<ManifestResourceTable>(Table.ManifestResource);
		for (int i = 0; i < collection.Count; i++)
		{
			Resource resource = collection[i];
			Row<uint, ManifestResourceAttributes, uint, uint> row = new Row<uint, ManifestResourceAttributes, uint, uint>(0u, resource.Attributes, GetStringIndex(resource.Name), 0u);
			switch (resource.ResourceType)
			{
			case ResourceType.Embedded:
				row.Col1 = AddEmbeddedResource((EmbeddedResource)resource);
				break;
			case ResourceType.Linked:
				row.Col4 = CodedIndex.Implementation.CompressMetadataToken(new MetadataToken(TokenType.File, AddLinkedResource((LinkedResource)resource)));
				break;
			case ResourceType.AssemblyLinked:
				row.Col4 = CodedIndex.Implementation.CompressMetadataToken(((AssemblyLinkedResource)resource).Assembly.MetadataToken);
				break;
			default:
				throw new NotSupportedException();
			}
			table.AddRow(row);
		}
	}

	private uint AddLinkedResource(LinkedResource resource)
	{
		FileTable table = GetTable<FileTable>(Table.File);
		byte[] array = resource.Hash;
		if (array.IsNullOrEmpty())
		{
			array = CryptoService.ComputeHash(resource.File);
		}
		return (uint)table.AddRow(new Row<Mono.Cecil.FileAttributes, uint, uint>(Mono.Cecil.FileAttributes.ContainsNoMetaData, GetStringIndex(resource.File), GetBlobIndex(array)));
	}

	private uint AddEmbeddedResource(EmbeddedResource resource)
	{
		return resources.AddResource(resource.GetResourceData());
	}

	private void AddExportedTypes()
	{
		Collection<ExportedType> exportedTypes = module.ExportedTypes;
		ExportedTypeTable table = GetTable<ExportedTypeTable>(Table.ExportedType);
		for (int i = 0; i < exportedTypes.Count; i++)
		{
			ExportedType exportedType = exportedTypes[i];
			int rid = table.AddRow(new Row<TypeAttributes, uint, uint, uint, uint>(exportedType.Attributes, (uint)exportedType.Identifier, GetStringIndex(exportedType.Name), GetStringIndex(exportedType.Namespace), MakeCodedRID(GetExportedTypeScope(exportedType), CodedIndex.Implementation)));
			exportedType.token = new MetadataToken(TokenType.ExportedType, rid);
		}
	}

	private MetadataToken GetExportedTypeScope(ExportedType exported_type)
	{
		if (exported_type.DeclaringType != null)
		{
			return exported_type.DeclaringType.MetadataToken;
		}
		IMetadataScope scope = exported_type.Scope;
		switch (scope.MetadataToken.TokenType)
		{
		case TokenType.AssemblyRef:
			return scope.MetadataToken;
		case TokenType.ModuleRef:
		{
			FileTable table = GetTable<FileTable>(Table.File);
			for (int i = 0; i < table.length; i++)
			{
				if (table.rows[i].Col2 == GetStringIndex(scope.Name))
				{
					return new MetadataToken(TokenType.File, i + 1);
				}
			}
			break;
		}
		}
		throw new NotSupportedException();
	}

	private void BuildTypes()
	{
		if (module.HasTypes)
		{
			AttachTokens();
			AddTypes();
			AddGenericParameters();
		}
	}

	private void AttachTokens()
	{
		Collection<TypeDefinition> types = module.Types;
		for (int i = 0; i < types.Count; i++)
		{
			AttachTypeToken(types[i]);
		}
	}

	private void AttachTypeToken(TypeDefinition type)
	{
		TypeDefinitionProjection projection = WindowsRuntimeProjections.RemoveProjection(type);
		type.token = new MetadataToken(TokenType.TypeDef, type_rid++);
		type.fields_range.Start = field_rid;
		type.methods_range.Start = method_rid;
		if (type.HasFields)
		{
			AttachFieldsToken(type);
		}
		if (type.HasMethods)
		{
			AttachMethodsToken(type);
		}
		if (type.HasNestedTypes)
		{
			AttachNestedTypesToken(type);
		}
		WindowsRuntimeProjections.ApplyProjection(type, projection);
	}

	private void AttachNestedTypesToken(TypeDefinition type)
	{
		Collection<TypeDefinition> nestedTypes = type.NestedTypes;
		for (int i = 0; i < nestedTypes.Count; i++)
		{
			AttachTypeToken(nestedTypes[i]);
		}
	}

	private void AttachFieldsToken(TypeDefinition type)
	{
		Collection<FieldDefinition> fields = type.Fields;
		type.fields_range.Length = (uint)fields.Count;
		for (int i = 0; i < fields.Count; i++)
		{
			fields[i].token = new MetadataToken(TokenType.Field, field_rid++);
		}
	}

	private void AttachMethodsToken(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		type.methods_range.Length = (uint)methods.Count;
		for (int i = 0; i < methods.Count; i++)
		{
			methods[i].token = new MetadataToken(TokenType.Method, method_rid++);
		}
	}

	private MetadataToken GetTypeToken(TypeReference type)
	{
		if (type == null)
		{
			return MetadataToken.Zero;
		}
		if (type.IsDefinition)
		{
			return type.token;
		}
		if (type.IsTypeSpecification())
		{
			return GetTypeSpecToken(type);
		}
		return GetTypeRefToken(type);
	}

	private MetadataToken GetTypeSpecToken(TypeReference type)
	{
		uint blobIndex = GetBlobIndex(GetTypeSpecSignature(type));
		if (type_spec_map.TryGetValue(blobIndex, out var value))
		{
			return value;
		}
		return AddTypeSpecification(type, blobIndex);
	}

	private MetadataToken AddTypeSpecification(TypeReference type, uint row)
	{
		type.token = new MetadataToken(TokenType.TypeSpec, typespec_table.AddRow(row));
		MetadataToken token = type.token;
		type_spec_map.Add(row, token);
		return token;
	}

	private MetadataToken GetTypeRefToken(TypeReference type)
	{
		TypeReferenceProjection projection = WindowsRuntimeProjections.RemoveProjection(type);
		Row<uint, uint, uint> row = CreateTypeRefRow(type);
		if (!type_ref_map.TryGetValue(row, out var value))
		{
			value = AddTypeReference(type, row);
		}
		WindowsRuntimeProjections.ApplyProjection(type, projection);
		return value;
	}

	private Row<uint, uint, uint> CreateTypeRefRow(TypeReference type)
	{
		return new Row<uint, uint, uint>(MakeCodedRID(GetScopeToken(type), CodedIndex.ResolutionScope), GetStringIndex(type.Name), GetStringIndex(type.Namespace));
	}

	private MetadataToken GetScopeToken(TypeReference type)
	{
		if (type.IsNested)
		{
			return GetTypeRefToken(type.DeclaringType);
		}
		return type.Scope?.MetadataToken ?? MetadataToken.Zero;
	}

	private static uint MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index)
	{
		return MakeCodedRID(provider.MetadataToken, index);
	}

	private static uint MakeCodedRID(MetadataToken token, CodedIndex index)
	{
		return index.CompressMetadataToken(token);
	}

	private MetadataToken AddTypeReference(TypeReference type, Row<uint, uint, uint> row)
	{
		type.token = new MetadataToken(TokenType.TypeRef, type_ref_table.AddRow(row));
		MetadataToken token = type.token;
		type_ref_map.Add(row, token);
		return token;
	}

	private void AddTypes()
	{
		Collection<TypeDefinition> types = module.Types;
		for (int i = 0; i < types.Count; i++)
		{
			AddType(types[i]);
		}
	}

	private void AddType(TypeDefinition type)
	{
		TypeDefinitionProjection projection = WindowsRuntimeProjections.RemoveProjection(type);
		type_def_table.AddRow(new Row<TypeAttributes, uint, uint, uint, uint, uint>(type.Attributes, GetStringIndex(type.Name), GetStringIndex(type.Namespace), MakeCodedRID(GetTypeToken(type.BaseType), CodedIndex.TypeDefOrRef), type.fields_range.Start, type.methods_range.Start));
		if (type.HasGenericParameters)
		{
			AddGenericParameters(type);
		}
		if (type.HasInterfaces)
		{
			AddInterfaces(type);
		}
		if (type.HasLayoutInfo)
		{
			AddLayoutInfo(type);
		}
		if (type.HasFields)
		{
			AddFields(type);
		}
		if (type.HasMethods)
		{
			AddMethods(type);
		}
		if (type.HasProperties)
		{
			AddProperties(type);
		}
		if (type.HasEvents)
		{
			AddEvents(type);
		}
		if (type.HasCustomAttributes)
		{
			AddCustomAttributes(type);
		}
		if (type.HasSecurityDeclarations)
		{
			AddSecurityDeclarations(type);
		}
		if (type.HasNestedTypes)
		{
			AddNestedTypes(type);
		}
		WindowsRuntimeProjections.ApplyProjection(type, projection);
	}

	private void AddGenericParameters(IGenericParameterProvider owner)
	{
		Collection<GenericParameter> genericParameters = owner.GenericParameters;
		for (int i = 0; i < genericParameters.Count; i++)
		{
			generic_parameters.Add(genericParameters[i]);
		}
	}

	private void AddGenericParameters()
	{
		GenericParameter[] items = generic_parameters.items;
		int size = generic_parameters.size;
		Array.Sort(items, 0, size, new GenericParameterComparer());
		GenericParamTable table = GetTable<GenericParamTable>(Table.GenericParam);
		GenericParamConstraintTable table2 = GetTable<GenericParamConstraintTable>(Table.GenericParamConstraint);
		for (int i = 0; i < size; i++)
		{
			GenericParameter genericParameter = items[i];
			int rid = table.AddRow(new Row<ushort, GenericParameterAttributes, uint, uint>((ushort)genericParameter.Position, genericParameter.Attributes, MakeCodedRID(genericParameter.Owner, CodedIndex.TypeOrMethodDef), GetStringIndex(genericParameter.Name)));
			genericParameter.token = new MetadataToken(TokenType.GenericParam, rid);
			if (genericParameter.HasConstraints)
			{
				AddConstraints(genericParameter, table2);
			}
			if (genericParameter.HasCustomAttributes)
			{
				AddCustomAttributes(genericParameter);
			}
		}
	}

	private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table)
	{
		Collection<GenericParameterConstraint> constraints = generic_parameter.Constraints;
		uint rID = generic_parameter.token.RID;
		for (int i = 0; i < constraints.Count; i++)
		{
			GenericParameterConstraint genericParameterConstraint = constraints[i];
			int rid = table.AddRow(new Row<uint, uint>(rID, MakeCodedRID(GetTypeToken(genericParameterConstraint.ConstraintType), CodedIndex.TypeDefOrRef)));
			genericParameterConstraint.token = new MetadataToken(TokenType.GenericParamConstraint, rid);
			if (genericParameterConstraint.HasCustomAttributes)
			{
				AddCustomAttributes(genericParameterConstraint);
			}
		}
	}

	private void AddInterfaces(TypeDefinition type)
	{
		Collection<InterfaceImplementation> interfaces = type.Interfaces;
		uint rID = type.token.RID;
		for (int i = 0; i < interfaces.Count; i++)
		{
			InterfaceImplementation interfaceImplementation = interfaces[i];
			int rid = iface_impl_table.AddRow(new Row<uint, uint>(rID, MakeCodedRID(GetTypeToken(interfaceImplementation.InterfaceType), CodedIndex.TypeDefOrRef)));
			interfaceImplementation.token = new MetadataToken(TokenType.InterfaceImpl, rid);
			if (interfaceImplementation.HasCustomAttributes)
			{
				AddCustomAttributes(interfaceImplementation);
			}
		}
	}

	private void AddLayoutInfo(TypeDefinition type)
	{
		GetTable<ClassLayoutTable>(Table.ClassLayout).AddRow(new Row<ushort, uint, uint>((ushort)type.PackingSize, (uint)type.ClassSize, type.token.RID));
	}

	private void AddNestedTypes(TypeDefinition type)
	{
		Collection<TypeDefinition> nestedTypes = type.NestedTypes;
		NestedClassTable table = GetTable<NestedClassTable>(Table.NestedClass);
		for (int i = 0; i < nestedTypes.Count; i++)
		{
			TypeDefinition typeDefinition = nestedTypes[i];
			AddType(typeDefinition);
			table.AddRow(new Row<uint, uint>(typeDefinition.token.RID, type.token.RID));
		}
	}

	private void AddFields(TypeDefinition type)
	{
		Collection<FieldDefinition> fields = type.Fields;
		for (int i = 0; i < fields.Count; i++)
		{
			AddField(fields[i]);
		}
	}

	private void AddField(FieldDefinition field)
	{
		FieldDefinitionProjection projection = WindowsRuntimeProjections.RemoveProjection(field);
		field_table.AddRow(new Row<FieldAttributes, uint, uint>(field.Attributes, GetStringIndex(field.Name), GetBlobIndex(GetFieldSignature(field))));
		if (!field.InitialValue.IsNullOrEmpty())
		{
			AddFieldRVA(field);
		}
		if (field.HasLayoutInfo)
		{
			AddFieldLayout(field);
		}
		if (field.HasCustomAttributes)
		{
			AddCustomAttributes(field);
		}
		if (field.HasConstant)
		{
			AddConstant(field, field.FieldType);
		}
		if (field.HasMarshalInfo)
		{
			AddMarshalInfo(field);
		}
		WindowsRuntimeProjections.ApplyProjection(field, projection);
	}

	private void AddFieldRVA(FieldDefinition field)
	{
		FieldRVATable table = GetTable<FieldRVATable>(Table.FieldRVA);
		int align = 1;
		if (field.FieldType.IsDefinition && !field.FieldType.IsGenericInstance)
		{
			TypeDefinition typeDefinition = field.FieldType.Resolve();
			if (typeDefinition.Module == module && typeDefinition.PackingSize > 1)
			{
				align = typeDefinition.PackingSize;
			}
		}
		table.AddRow(new Row<uint, uint>(data.AddData(field.InitialValue, align), field.token.RID));
	}

	private void AddFieldLayout(FieldDefinition field)
	{
		GetTable<FieldLayoutTable>(Table.FieldLayout).AddRow(new Row<uint, uint>((uint)field.Offset, field.token.RID));
	}

	private void AddMethods(TypeDefinition type)
	{
		Collection<MethodDefinition> methods = type.Methods;
		for (int i = 0; i < methods.Count; i++)
		{
			AddMethod(methods[i]);
		}
	}

	private void AddMethod(MethodDefinition method)
	{
		MethodDefinitionProjection projection = WindowsRuntimeProjections.RemoveProjection(method);
		method_table.AddRow(new Row<uint, MethodImplAttributes, MethodAttributes, uint, uint, uint>(method.HasBody ? code.WriteMethodBody(method) : 0u, method.ImplAttributes, method.Attributes, GetStringIndex(method.Name), GetBlobIndex(GetMethodSignature(method)), param_rid));
		AddParameters(method);
		if (method.HasGenericParameters)
		{
			AddGenericParameters(method);
		}
		if (method.IsPInvokeImpl)
		{
			AddPInvokeInfo(method);
		}
		if (method.HasCustomAttributes)
		{
			AddCustomAttributes(method);
		}
		if (method.HasSecurityDeclarations)
		{
			AddSecurityDeclarations(method);
		}
		if (method.HasOverrides)
		{
			AddOverrides(method);
		}
		WindowsRuntimeProjections.ApplyProjection(method, projection);
	}

	private void AddParameters(MethodDefinition method)
	{
		ParameterDefinition parameter = method.MethodReturnType.parameter;
		if (parameter != null && RequiresParameterRow(parameter))
		{
			AddParameter(0, parameter, param_table);
		}
		if (!method.HasParameters)
		{
			return;
		}
		Collection<ParameterDefinition> parameters = method.Parameters;
		for (int i = 0; i < parameters.Count; i++)
		{
			ParameterDefinition parameter2 = parameters[i];
			if (RequiresParameterRow(parameter2))
			{
				AddParameter((ushort)(i + 1), parameter2, param_table);
			}
		}
	}

	private void AddPInvokeInfo(MethodDefinition method)
	{
		PInvokeInfo pInvokeInfo = method.PInvokeInfo;
		if (pInvokeInfo != null)
		{
			GetTable<ImplMapTable>(Table.ImplMap).AddRow(new Row<PInvokeAttributes, uint, uint, uint>(pInvokeInfo.Attributes, MakeCodedRID(method, CodedIndex.MemberForwarded), GetStringIndex(pInvokeInfo.EntryPoint), pInvokeInfo.Module.MetadataToken.RID));
		}
	}

	private void AddOverrides(MethodDefinition method)
	{
		Collection<MethodReference> overrides = method.Overrides;
		MethodImplTable table = GetTable<MethodImplTable>(Table.MethodImpl);
		for (int i = 0; i < overrides.Count; i++)
		{
			table.AddRow(new Row<uint, uint, uint>(method.DeclaringType.token.RID, MakeCodedRID(method, CodedIndex.MethodDefOrRef), MakeCodedRID(LookupToken(overrides[i]), CodedIndex.MethodDefOrRef)));
		}
	}

	private static bool RequiresParameterRow(ParameterDefinition parameter)
	{
		if (string.IsNullOrEmpty(parameter.Name) && parameter.Attributes == ParameterAttributes.None && !parameter.HasMarshalInfo && !parameter.HasConstant)
		{
			return parameter.HasCustomAttributes;
		}
		return true;
	}

	private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table)
	{
		table.AddRow(new Row<ParameterAttributes, ushort, uint>(parameter.Attributes, sequence, GetStringIndex(parameter.Name)));
		parameter.token = new MetadataToken(TokenType.Param, param_rid++);
		if (parameter.HasCustomAttributes)
		{
			AddCustomAttributes(parameter);
		}
		if (parameter.HasConstant)
		{
			AddConstant(parameter, parameter.ParameterType);
		}
		if (parameter.HasMarshalInfo)
		{
			AddMarshalInfo(parameter);
		}
	}

	private void AddMarshalInfo(IMarshalInfoProvider owner)
	{
		GetTable<FieldMarshalTable>(Table.FieldMarshal).AddRow(new Row<uint, uint>(MakeCodedRID(owner, CodedIndex.HasFieldMarshal), GetBlobIndex(GetMarshalInfoSignature(owner))));
	}

	private void AddProperties(TypeDefinition type)
	{
		Collection<PropertyDefinition> properties = type.Properties;
		property_map_table.AddRow(new Row<uint, uint>(type.token.RID, property_rid));
		for (int i = 0; i < properties.Count; i++)
		{
			AddProperty(properties[i]);
		}
	}

	private void AddProperty(PropertyDefinition property)
	{
		property_table.AddRow(new Row<PropertyAttributes, uint, uint>(property.Attributes, GetStringIndex(property.Name), GetBlobIndex(GetPropertySignature(property))));
		property.token = new MetadataToken(TokenType.Property, property_rid++);
		MethodDefinition getMethod = property.GetMethod;
		if (getMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.Getter, property, getMethod);
		}
		getMethod = property.SetMethod;
		if (getMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.Setter, property, getMethod);
		}
		if (property.HasOtherMethods)
		{
			AddOtherSemantic(property, property.OtherMethods);
		}
		if (property.HasCustomAttributes)
		{
			AddCustomAttributes(property);
		}
		if (property.HasConstant)
		{
			AddConstant(property, property.PropertyType);
		}
	}

	private void AddOtherSemantic(IMetadataTokenProvider owner, Collection<MethodDefinition> others)
	{
		for (int i = 0; i < others.Count; i++)
		{
			AddSemantic(MethodSemanticsAttributes.Other, owner, others[i]);
		}
	}

	private void AddEvents(TypeDefinition type)
	{
		Collection<EventDefinition> events = type.Events;
		event_map_table.AddRow(new Row<uint, uint>(type.token.RID, event_rid));
		for (int i = 0; i < events.Count; i++)
		{
			AddEvent(events[i]);
		}
	}

	private void AddEvent(EventDefinition @event)
	{
		event_table.AddRow(new Row<EventAttributes, uint, uint>(@event.Attributes, GetStringIndex(@event.Name), MakeCodedRID(GetTypeToken(@event.EventType), CodedIndex.TypeDefOrRef)));
		@event.token = new MetadataToken(TokenType.Event, event_rid++);
		MethodDefinition addMethod = @event.AddMethod;
		if (addMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.AddOn, @event, addMethod);
		}
		addMethod = @event.InvokeMethod;
		if (addMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.Fire, @event, addMethod);
		}
		addMethod = @event.RemoveMethod;
		if (addMethod != null)
		{
			AddSemantic(MethodSemanticsAttributes.RemoveOn, @event, addMethod);
		}
		if (@event.HasOtherMethods)
		{
			AddOtherSemantic(@event, @event.OtherMethods);
		}
		if (@event.HasCustomAttributes)
		{
			AddCustomAttributes(@event);
		}
	}

	private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
	{
		method.SemanticsAttributes = semantics;
		GetTable<MethodSemanticsTable>(Table.MethodSemantics).AddRow(new Row<MethodSemanticsAttributes, uint, uint>(semantics, method.token.RID, MakeCodedRID(provider, CodedIndex.HasSemantics)));
	}

	private void AddConstant(IConstantProvider owner, TypeReference type)
	{
		object constant = owner.Constant;
		ElementType constantType = GetConstantType(type, constant);
		constant_table.AddRow(new Row<ElementType, uint, uint>(constantType, MakeCodedRID(owner.MetadataToken, CodedIndex.HasConstant), GetBlobIndex(GetConstantSignature(constantType, constant))));
	}

	private static ElementType GetConstantType(TypeReference constant_type, object constant)
	{
		if (constant == null)
		{
			return ElementType.Class;
		}
		ElementType etype = constant_type.etype;
		switch (etype)
		{
		case ElementType.None:
		{
			TypeDefinition typeDefinition = constant_type.CheckedResolve();
			if (typeDefinition.IsEnum)
			{
				return GetConstantType(typeDefinition.GetEnumUnderlyingType(), constant);
			}
			return ElementType.Class;
		}
		case ElementType.String:
			return ElementType.String;
		case ElementType.Object:
			return GetConstantType(constant.GetType());
		case ElementType.Var:
		case ElementType.Array:
		case ElementType.SzArray:
		case ElementType.MVar:
			return ElementType.Class;
		case ElementType.GenericInst:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)constant_type;
			if (genericInstanceType.ElementType.IsTypeOf("System", "Nullable`1"))
			{
				return GetConstantType(genericInstanceType.GenericArguments[0], constant);
			}
			return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
		}
		case ElementType.ByRef:
		case ElementType.CModReqD:
		case ElementType.CModOpt:
		case ElementType.Sentinel:
			return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
		case ElementType.Boolean:
		case ElementType.Char:
		case ElementType.I1:
		case ElementType.U1:
		case ElementType.I2:
		case ElementType.U2:
		case ElementType.I4:
		case ElementType.U4:
		case ElementType.I8:
		case ElementType.U8:
		case ElementType.R4:
		case ElementType.R8:
		case ElementType.I:
		case ElementType.U:
			return GetConstantType(constant.GetType());
		default:
			return etype;
		}
	}

	private static ElementType GetConstantType(Type type)
	{
		return Type.GetTypeCode(type) switch
		{
			TypeCode.Boolean => ElementType.Boolean, 
			TypeCode.Byte => ElementType.U1, 
			TypeCode.SByte => ElementType.I1, 
			TypeCode.Char => ElementType.Char, 
			TypeCode.Int16 => ElementType.I2, 
			TypeCode.UInt16 => ElementType.U2, 
			TypeCode.Int32 => ElementType.I4, 
			TypeCode.UInt32 => ElementType.U4, 
			TypeCode.Int64 => ElementType.I8, 
			TypeCode.UInt64 => ElementType.U8, 
			TypeCode.Single => ElementType.R4, 
			TypeCode.Double => ElementType.R8, 
			TypeCode.String => ElementType.String, 
			_ => throw new NotSupportedException(type.FullName), 
		};
	}

	private void AddCustomAttributes(ICustomAttributeProvider owner)
	{
		Collection<CustomAttribute> customAttributes = owner.CustomAttributes;
		for (int i = 0; i < customAttributes.Count; i++)
		{
			CustomAttribute customAttribute = customAttributes[i];
			CustomAttributeValueProjection projection = WindowsRuntimeProjections.RemoveProjection(customAttribute);
			custom_attribute_table.AddRow(new Row<uint, uint, uint>(MakeCodedRID(owner, CodedIndex.HasCustomAttribute), MakeCodedRID(LookupToken(customAttribute.Constructor), CodedIndex.CustomAttributeType), GetBlobIndex(GetCustomAttributeSignature(customAttribute))));
			WindowsRuntimeProjections.ApplyProjection(customAttribute, projection);
		}
	}

	private void AddSecurityDeclarations(ISecurityDeclarationProvider owner)
	{
		Collection<SecurityDeclaration> securityDeclarations = owner.SecurityDeclarations;
		for (int i = 0; i < securityDeclarations.Count; i++)
		{
			SecurityDeclaration securityDeclaration = securityDeclarations[i];
			declsec_table.AddRow(new Row<SecurityAction, uint, uint>(securityDeclaration.Action, MakeCodedRID(owner, CodedIndex.HasDeclSecurity), GetBlobIndex(GetSecurityDeclarationSignature(securityDeclaration))));
		}
	}

	private MetadataToken GetMemberRefToken(MemberReference member)
	{
		Row<uint, uint, uint> row = CreateMemberRefRow(member);
		if (!member_ref_map.TryGetValue(row, out var value))
		{
			return AddMemberReference(member, row);
		}
		return value;
	}

	private Row<uint, uint, uint> CreateMemberRefRow(MemberReference member)
	{
		return new Row<uint, uint, uint>(MakeCodedRID(GetTypeToken(member.DeclaringType), CodedIndex.MemberRefParent), GetStringIndex(member.Name), GetBlobIndex(GetMemberRefSignature(member)));
	}

	private MetadataToken AddMemberReference(MemberReference member, Row<uint, uint, uint> row)
	{
		member.token = new MetadataToken(TokenType.MemberRef, member_ref_table.AddRow(row));
		MetadataToken token = member.token;
		member_ref_map.Add(row, token);
		return token;
	}

	private MetadataToken GetMethodSpecToken(MethodSpecification method_spec)
	{
		Row<uint, uint> row = CreateMethodSpecRow(method_spec);
		if (method_spec_map.TryGetValue(row, out var value))
		{
			return value;
		}
		AddMethodSpecification(method_spec, row);
		return method_spec.token;
	}

	private void AddMethodSpecification(MethodSpecification method_spec, Row<uint, uint> row)
	{
		method_spec.token = new MetadataToken(TokenType.MethodSpec, method_spec_table.AddRow(row));
		method_spec_map.Add(row, method_spec.token);
	}

	private Row<uint, uint> CreateMethodSpecRow(MethodSpecification method_spec)
	{
		return new Row<uint, uint>(MakeCodedRID(LookupToken(method_spec.ElementMethod), CodedIndex.MethodDefOrRef), GetBlobIndex(GetMethodSpecSignature(method_spec)));
	}

	private SignatureWriter CreateSignatureWriter()
	{
		return new SignatureWriter(this);
	}

	private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec)
	{
		if (!method_spec.IsGenericInstance)
		{
			throw new NotSupportedException();
		}
		GenericInstanceMethod instance = (GenericInstanceMethod)method_spec;
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(10);
		signatureWriter.WriteGenericInstanceSignature(instance);
		return signatureWriter;
	}

	public uint AddStandAloneSignature(uint signature)
	{
		return (uint)standalone_sig_table.AddRow(signature);
	}

	public uint GetLocalVariableBlobIndex(Collection<VariableDefinition> variables)
	{
		return GetBlobIndex(GetVariablesSignature(variables));
	}

	public uint GetCallSiteBlobIndex(CallSite call_site)
	{
		return GetBlobIndex(GetMethodSignature(call_site));
	}

	public uint GetConstantTypeBlobIndex(TypeReference constant_type)
	{
		return GetBlobIndex(GetConstantTypeSignature(constant_type));
	}

	private SignatureWriter GetVariablesSignature(Collection<VariableDefinition> variables)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(7);
		signatureWriter.WriteCompressedUInt32((uint)variables.Count);
		for (int i = 0; i < variables.Count; i++)
		{
			signatureWriter.WriteTypeSignature(variables[i].VariableType);
		}
		return signatureWriter;
	}

	private SignatureWriter GetConstantTypeSignature(TypeReference constant_type)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(6);
		signatureWriter.WriteTypeSignature(constant_type);
		return signatureWriter;
	}

	private SignatureWriter GetFieldSignature(FieldReference field)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteByte(6);
		signatureWriter.WriteTypeSignature(field.FieldType);
		return signatureWriter;
	}

	private SignatureWriter GetMethodSignature(IMethodSignature method)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteMethodSignature(method);
		return signatureWriter;
	}

	private SignatureWriter GetMemberRefSignature(MemberReference member)
	{
		if (member is FieldReference field)
		{
			return GetFieldSignature(field);
		}
		if (member is MethodReference method)
		{
			return GetMethodSignature(method);
		}
		throw new NotSupportedException();
	}

	private SignatureWriter GetPropertySignature(PropertyDefinition property)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		byte b = 8;
		if (property.HasThis)
		{
			b |= 0x20;
		}
		uint num = 0u;
		Collection<ParameterDefinition> collection = null;
		if (property.HasParameters)
		{
			collection = property.Parameters;
			num = (uint)collection.Count;
		}
		signatureWriter.WriteByte(b);
		signatureWriter.WriteCompressedUInt32(num);
		signatureWriter.WriteTypeSignature(property.PropertyType);
		if (num == 0)
		{
			return signatureWriter;
		}
		for (int i = 0; i < num; i++)
		{
			signatureWriter.WriteTypeSignature(collection[i].ParameterType);
		}
		return signatureWriter;
	}

	private SignatureWriter GetTypeSpecSignature(TypeReference type)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteTypeSignature(type);
		return signatureWriter;
	}

	private SignatureWriter GetConstantSignature(ElementType type, object value)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		switch (type)
		{
		case ElementType.None:
		case ElementType.Class:
		case ElementType.Var:
		case ElementType.Array:
		case ElementType.GenericInst:
		case ElementType.Object:
		case ElementType.SzArray:
		case ElementType.MVar:
			signatureWriter.WriteInt32(0);
			break;
		case ElementType.String:
			signatureWriter.WriteConstantString((string)value);
			break;
		default:
			signatureWriter.WriteConstantPrimitive(value);
			break;
		}
		return signatureWriter;
	}

	private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		if (!attribute.resolved)
		{
			signatureWriter.WriteBytes(attribute.GetBlob());
			return signatureWriter;
		}
		signatureWriter.WriteUInt16(1);
		signatureWriter.WriteCustomAttributeConstructorArguments(attribute);
		signatureWriter.WriteCustomAttributeNamedArguments(attribute);
		return signatureWriter;
	}

	private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		if (!declaration.resolved)
		{
			signatureWriter.WriteBytes(declaration.GetBlob());
		}
		else if (module.Runtime < TargetRuntime.Net_2_0)
		{
			signatureWriter.WriteXmlSecurityDeclaration(declaration);
		}
		else
		{
			signatureWriter.WriteSecurityDeclaration(declaration);
		}
		return signatureWriter;
	}

	private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteMarshalInfo(owner.MarshalInfo);
		return signatureWriter;
	}

	private static Exception CreateForeignMemberException(MemberReference member)
	{
		return new ArgumentException($"Member '{member}' is declared in another module and needs to be imported");
	}

	public MetadataToken LookupToken(IMetadataTokenProvider provider)
	{
		if (provider == null)
		{
			throw new ArgumentNullException();
		}
		if (metadata_builder != null)
		{
			return metadata_builder.LookupToken(provider);
		}
		MemberReference memberReference = provider as MemberReference;
		if (memberReference == null || memberReference.Module != module)
		{
			throw CreateForeignMemberException(memberReference);
		}
		MetadataToken metadataToken = provider.MetadataToken;
		switch (metadataToken.TokenType)
		{
		case TokenType.TypeDef:
		case TokenType.Field:
		case TokenType.Method:
		case TokenType.Event:
		case TokenType.Property:
			return metadataToken;
		case TokenType.TypeRef:
		case TokenType.TypeSpec:
		case TokenType.GenericParam:
			return GetTypeToken((TypeReference)provider);
		case TokenType.MethodSpec:
			return GetMethodSpecToken((MethodSpecification)provider);
		case TokenType.MemberRef:
			return GetMemberRefToken(memberReference);
		default:
			throw new NotSupportedException();
		}
	}

	public void AddMethodDebugInformation(MethodDebugInformation method_info)
	{
		if (method_info.HasSequencePoints)
		{
			AddSequencePoints(method_info);
		}
		if (method_info.Scope != null)
		{
			AddLocalScope(method_info, method_info.Scope);
		}
		if (method_info.StateMachineKickOffMethod != null)
		{
			AddStateMachineMethod(method_info);
		}
		AddCustomDebugInformations(method_info.Method);
	}

	private void AddStateMachineMethod(MethodDebugInformation method_info)
	{
		state_machine_method_table.AddRow(new Row<uint, uint>(method_info.Method.MetadataToken.RID, method_info.StateMachineKickOffMethod.MetadataToken.RID));
	}

	private void AddLocalScope(MethodDebugInformation method_info, ScopeDebugInformation scope)
	{
		int rid = local_scope_table.AddRow(new Row<uint, uint, uint, uint, uint, uint>(method_info.Method.MetadataToken.RID, (scope.import != null) ? AddImportScope(scope.import) : 0u, local_variable_rid, local_constant_rid, (uint)scope.Start.Offset, (uint)((scope.End.IsEndOfMethod ? method_info.code_size : scope.End.Offset) - scope.Start.Offset)));
		scope.token = new MetadataToken(TokenType.LocalScope, rid);
		AddCustomDebugInformations(scope);
		if (scope.HasVariables)
		{
			AddLocalVariables(scope);
		}
		if (scope.HasConstants)
		{
			AddLocalConstants(scope);
		}
		for (int i = 0; i < scope.Scopes.Count; i++)
		{
			AddLocalScope(method_info, scope.Scopes[i]);
		}
	}

	private void AddLocalVariables(ScopeDebugInformation scope)
	{
		for (int i = 0; i < scope.Variables.Count; i++)
		{
			VariableDebugInformation variableDebugInformation = scope.Variables[i];
			local_variable_table.AddRow(new Row<VariableAttributes, ushort, uint>(variableDebugInformation.Attributes, (ushort)variableDebugInformation.Index, GetStringIndex(variableDebugInformation.Name)));
			variableDebugInformation.token = new MetadataToken(TokenType.LocalVariable, local_variable_rid);
			local_variable_rid++;
			AddCustomDebugInformations(variableDebugInformation);
		}
	}

	private void AddLocalConstants(ScopeDebugInformation scope)
	{
		for (int i = 0; i < scope.Constants.Count; i++)
		{
			ConstantDebugInformation constantDebugInformation = scope.Constants[i];
			local_constant_table.AddRow(new Row<uint, uint>(GetStringIndex(constantDebugInformation.Name), GetBlobIndex(GetConstantSignature(constantDebugInformation))));
			constantDebugInformation.token = new MetadataToken(TokenType.LocalConstant, local_constant_rid);
			local_constant_rid++;
		}
	}

	private SignatureWriter GetConstantSignature(ConstantDebugInformation constant)
	{
		TypeReference constantType = constant.ConstantType;
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteTypeSignature(constantType);
		if (constantType.IsTypeOf("System", "Decimal"))
		{
			int[] bits = decimal.GetBits((decimal)constant.Value);
			uint value = (uint)bits[0];
			uint value2 = (uint)bits[1];
			uint value3 = (uint)bits[2];
			byte b = (byte)(bits[3] >> 16);
			bool flag = (bits[3] & 0x80000000u) != 0;
			signatureWriter.WriteByte((byte)(b | (flag ? 128 : 0)));
			signatureWriter.WriteUInt32(value);
			signatureWriter.WriteUInt32(value2);
			signatureWriter.WriteUInt32(value3);
			return signatureWriter;
		}
		if (constantType.IsTypeOf("System", "DateTime"))
		{
			signatureWriter.WriteInt64(((DateTime)constant.Value).Ticks);
			return signatureWriter;
		}
		signatureWriter.WriteBytes(GetConstantSignature(constantType.etype, constant.Value));
		return signatureWriter;
	}

	public void AddCustomDebugInformations(ICustomDebugInformationProvider provider)
	{
		if (!provider.HasCustomDebugInformations)
		{
			return;
		}
		Collection<CustomDebugInformation> customDebugInformations = provider.CustomDebugInformations;
		for (int i = 0; i < customDebugInformations.Count; i++)
		{
			CustomDebugInformation customDebugInformation = customDebugInformations[i];
			switch (customDebugInformation.Kind)
			{
			case CustomDebugInformationKind.Binary:
			{
				BinaryCustomDebugInformation binaryCustomDebugInformation = (BinaryCustomDebugInformation)customDebugInformation;
				AddCustomDebugInformation(provider, binaryCustomDebugInformation, GetBlobIndex(binaryCustomDebugInformation.Data));
				break;
			}
			case CustomDebugInformationKind.AsyncMethodBody:
				AddAsyncMethodBodyDebugInformation(provider, (AsyncMethodBodyDebugInformation)customDebugInformation);
				break;
			case CustomDebugInformationKind.StateMachineScope:
				AddStateMachineScopeDebugInformation(provider, (StateMachineScopeDebugInformation)customDebugInformation);
				break;
			case CustomDebugInformationKind.EmbeddedSource:
				AddEmbeddedSourceDebugInformation(provider, (EmbeddedSourceDebugInformation)customDebugInformation);
				break;
			case CustomDebugInformationKind.SourceLink:
				AddSourceLinkDebugInformation(provider, (SourceLinkDebugInformation)customDebugInformation);
				break;
			default:
				throw new NotImplementedException();
			}
		}
	}

	private void AddStateMachineScopeDebugInformation(ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope)
	{
		MethodDebugInformation debugInformation = ((MethodDefinition)provider).DebugInformation;
		SignatureWriter signatureWriter = CreateSignatureWriter();
		Collection<StateMachineScope> scopes = state_machine_scope.Scopes;
		for (int i = 0; i < scopes.Count; i++)
		{
			StateMachineScope stateMachineScope = scopes[i];
			signatureWriter.WriteUInt32((uint)stateMachineScope.Start.Offset);
			int num = (stateMachineScope.End.IsEndOfMethod ? debugInformation.code_size : stateMachineScope.End.Offset);
			signatureWriter.WriteUInt32((uint)(num - stateMachineScope.Start.Offset));
		}
		AddCustomDebugInformation(provider, state_machine_scope, signatureWriter);
	}

	private void AddAsyncMethodBodyDebugInformation(ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteUInt32((uint)(async_method.catch_handler.Offset + 1));
		if (!async_method.yields.IsNullOrEmpty())
		{
			for (int i = 0; i < async_method.yields.Count; i++)
			{
				signatureWriter.WriteUInt32((uint)async_method.yields[i].Offset);
				signatureWriter.WriteUInt32((uint)async_method.resumes[i].Offset);
				signatureWriter.WriteCompressedUInt32(async_method.resume_methods[i].MetadataToken.RID);
			}
		}
		AddCustomDebugInformation(provider, async_method, signatureWriter);
	}

	private void AddEmbeddedSourceDebugInformation(ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		if (!embedded_source.resolved)
		{
			signatureWriter.WriteBytes(embedded_source.ReadRawEmbeddedSourceDebugInformation());
			AddCustomDebugInformation(provider, embedded_source, signatureWriter);
			return;
		}
		byte[] array = embedded_source.content ?? Empty<byte>.Array;
		if (embedded_source.compress)
		{
			signatureWriter.WriteInt32(array.Length);
			MemoryStream memoryStream = new MemoryStream(array);
			MemoryStream memoryStream2 = new MemoryStream();
			using (DeflateStream destination = new DeflateStream(memoryStream2, CompressionMode.Compress, leaveOpen: true))
			{
				memoryStream.CopyTo(destination);
			}
			signatureWriter.WriteBytes(memoryStream2.ToArray());
		}
		else
		{
			signatureWriter.WriteInt32(0);
			signatureWriter.WriteBytes(array);
		}
		AddCustomDebugInformation(provider, embedded_source, signatureWriter);
	}

	private void AddSourceLinkDebugInformation(ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link)
	{
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteBytes(Encoding.UTF8.GetBytes(source_link.content));
		AddCustomDebugInformation(provider, source_link, signatureWriter);
	}

	private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature)
	{
		AddCustomDebugInformation(provider, custom_info, GetBlobIndex(signature));
	}

	private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, uint blob_index)
	{
		int rid = custom_debug_information_table.AddRow(new Row<uint, uint, uint>(MakeCodedRID(provider.MetadataToken, CodedIndex.HasCustomDebugInformation), GetGuidIndex(custom_info.Identifier), blob_index));
		custom_info.token = new MetadataToken(TokenType.CustomDebugInformation, rid);
	}

	private uint AddImportScope(ImportDebugInformation import)
	{
		uint col = 0u;
		if (import.Parent != null)
		{
			col = AddImportScope(import.Parent);
		}
		uint col2 = 0u;
		if (import.HasTargets)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			for (int i = 0; i < import.Targets.Count; i++)
			{
				AddImportTarget(import.Targets[i], signatureWriter);
			}
			col2 = GetBlobIndex(signatureWriter);
		}
		Row<uint, uint> row = new Row<uint, uint>(col, col2);
		if (import_scope_map.TryGetValue(row, out var value))
		{
			return value.RID;
		}
		value = new MetadataToken(TokenType.ImportScope, import_scope_table.AddRow(row));
		import_scope_map.Add(row, value);
		return value.RID;
	}

	private void AddImportTarget(ImportTarget target, SignatureWriter signature)
	{
		signature.WriteCompressedUInt32((uint)target.kind);
		switch (target.kind)
		{
		case ImportTargetKind.ImportNamespace:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
			break;
		case ImportTargetKind.ImportNamespaceInAssembly:
			signature.WriteCompressedUInt32(target.reference.MetadataToken.RID);
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
			break;
		case ImportTargetKind.ImportType:
			signature.WriteTypeToken(target.type);
			break;
		case ImportTargetKind.ImportXmlNamespaceWithAlias:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
			break;
		case ImportTargetKind.ImportAlias:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
			break;
		case ImportTargetKind.DefineAssemblyAlias:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
			signature.WriteCompressedUInt32(target.reference.MetadataToken.RID);
			break;
		case ImportTargetKind.DefineNamespaceAlias:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
			break;
		case ImportTargetKind.DefineNamespaceInAssemblyAlias:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
			signature.WriteCompressedUInt32(target.reference.MetadataToken.RID);
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.@namespace));
			break;
		case ImportTargetKind.DefineTypeAlias:
			signature.WriteCompressedUInt32(GetUTF8StringBlobIndex(target.alias));
			signature.WriteTypeToken(target.type);
			break;
		}
	}

	private uint GetUTF8StringBlobIndex(string s)
	{
		return GetBlobIndex(Encoding.UTF8.GetBytes(s));
	}

	public MetadataToken GetDocumentToken(Document document)
	{
		if (document_map.TryGetValue(document.Url, out var value))
		{
			return value;
		}
		value = (document.token = new MetadataToken(TokenType.Document, document_table.AddRow(new Row<uint, uint, uint, uint>(GetBlobIndex(GetDocumentNameSignature(document)), GetGuidIndex(document.HashAlgorithm.ToGuid()), GetBlobIndex(document.Hash), GetGuidIndex(document.Language.ToGuid())))));
		AddCustomDebugInformations(document);
		document_map.Add(document.Url, value);
		return value;
	}

	private SignatureWriter GetDocumentNameSignature(Document document)
	{
		string url = document.Url;
		SignatureWriter signatureWriter = CreateSignatureWriter();
		if (!TryGetDocumentNameSeparator(url, out var separator))
		{
			signatureWriter.WriteByte(0);
			signatureWriter.WriteCompressedUInt32(GetUTF8StringBlobIndex(url));
			return signatureWriter;
		}
		signatureWriter.WriteByte((byte)separator);
		string[] array = url.Split(new char[1] { separator });
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == string.Empty)
			{
				signatureWriter.WriteCompressedUInt32(0u);
			}
			else
			{
				signatureWriter.WriteCompressedUInt32(GetUTF8StringBlobIndex(array[i]));
			}
		}
		return signatureWriter;
	}

	private static bool TryGetDocumentNameSeparator(string path, out char separator)
	{
		separator = '\0';
		if (string.IsNullOrEmpty(path))
		{
			return false;
		}
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < path.Length; i++)
		{
			if (path[i] == '/')
			{
				num++;
			}
			else if (path[i] == '\\')
			{
				num2++;
			}
		}
		if (num == 0 && num2 == 0)
		{
			return false;
		}
		if (num >= num2)
		{
			separator = '/';
			return true;
		}
		separator = '\\';
		return true;
	}

	private void AddSequencePoints(MethodDebugInformation info)
	{
		uint rID = info.Method.MetadataToken.RID;
		if (info.TryGetUniqueDocument(out var document))
		{
			method_debug_information_table.rows[rID - 1].Col1 = GetDocumentToken(document).RID;
		}
		SignatureWriter signatureWriter = CreateSignatureWriter();
		signatureWriter.WriteSequencePoints(info);
		method_debug_information_table.rows[rID - 1].Col2 = GetBlobIndex(signatureWriter);
	}
}


using System.Collections.Generic;
using Mono.Cecil.Metadata;

private sealed class GenericParameterComparer : IComparer<GenericParameter>
{
	public int Compare(GenericParameter a, GenericParameter b)
	{
		uint num = MakeCodedRID(a.Owner, CodedIndex.TypeOrMethodDef);
		uint num2 = MakeCodedRID(b.Owner, CodedIndex.TypeOrMethodDef);
		if (num == num2)
		{
			int position = a.Position;
			int position2 = b.Position;
			if (position != position2)
			{
				if (position <= position2)
				{
					return -1;
				}
				return 1;
			}
			return 0;
		}
		if (num <= num2)
		{
			return -1;
		}
		return 1;
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class SignatureWriter : ByteBuffer
{
	private readonly MetadataBuilder metadata;

	public SignatureWriter(MetadataBuilder metadata)
		: base(6)
	{
		this.metadata = metadata;
	}

	public void WriteElementType(ElementType element_type)
	{
		WriteByte((byte)element_type);
	}

	public void WriteUTF8String(string @string)
	{
		if (@string == null)
		{
			WriteByte(byte.MaxValue);
			return;
		}
		byte[] bytes = Encoding.UTF8.GetBytes(@string);
		WriteCompressedUInt32((uint)bytes.Length);
		WriteBytes(bytes);
	}

	public void WriteMethodSignature(IMethodSignature method)
	{
		byte b = (byte)method.CallingConvention;
		if (method.HasThis)
		{
			b |= 0x20;
		}
		if (method.ExplicitThis)
		{
			b |= 0x40;
		}
		int num = ((method is IGenericParameterProvider { HasGenericParameters: not false } genericParameterProvider) ? genericParameterProvider.GenericParameters.Count : 0);
		if (num > 0)
		{
			b |= 0x10;
		}
		int num2 = (method.HasParameters ? method.Parameters.Count : 0);
		WriteByte(b);
		if (num > 0)
		{
			WriteCompressedUInt32((uint)num);
		}
		WriteCompressedUInt32((uint)num2);
		WriteTypeSignature(method.ReturnType);
		if (num2 != 0)
		{
			Collection<ParameterDefinition> parameters = method.Parameters;
			for (int i = 0; i < num2; i++)
			{
				WriteTypeSignature(parameters[i].ParameterType);
			}
		}
	}

	private uint MakeTypeDefOrRefCodedRID(TypeReference type)
	{
		return CodedIndex.TypeDefOrRef.CompressMetadataToken(metadata.LookupToken(type));
	}

	public void WriteTypeToken(TypeReference type)
	{
		WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type));
	}

	public void WriteTypeSignature(TypeReference type)
	{
		if (type == null)
		{
			throw new ArgumentNullException();
		}
		ElementType etype = type.etype;
		switch (etype)
		{
		case ElementType.Var:
		case ElementType.MVar:
		{
			GenericParameter obj = (GenericParameter)type;
			WriteElementType(etype);
			int num = obj.Position;
			if (num == -1)
			{
				throw new NotSupportedException();
			}
			WriteCompressedUInt32((uint)num);
			break;
		}
		case ElementType.GenericInst:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)type;
			WriteElementType(ElementType.GenericInst);
			WriteElementType(genericInstanceType.IsValueType ? ElementType.ValueType : ElementType.Class);
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(genericInstanceType.ElementType));
			WriteGenericInstanceSignature(genericInstanceType);
			break;
		}
		case ElementType.Ptr:
		case ElementType.ByRef:
		case ElementType.Sentinel:
		case ElementType.Pinned:
		{
			TypeSpecification typeSpecification = (TypeSpecification)type;
			WriteElementType(etype);
			WriteTypeSignature(typeSpecification.ElementType);
			break;
		}
		case ElementType.FnPtr:
		{
			FunctionPointerType method = (FunctionPointerType)type;
			WriteElementType(ElementType.FnPtr);
			WriteMethodSignature(method);
			break;
		}
		case ElementType.CModReqD:
		case ElementType.CModOpt:
		{
			IModifierType type2 = (IModifierType)type;
			WriteModifierSignature(etype, type2);
			break;
		}
		case ElementType.Array:
		{
			ArrayType arrayType = (ArrayType)type;
			if (!arrayType.IsVector)
			{
				WriteArrayTypeSignature(arrayType);
				break;
			}
			WriteElementType(ElementType.SzArray);
			WriteTypeSignature(arrayType.ElementType);
			break;
		}
		case ElementType.None:
			WriteElementType(type.IsValueType ? ElementType.ValueType : ElementType.Class);
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type));
			break;
		default:
			if (!TryWriteElementType(type))
			{
				throw new NotSupportedException();
			}
			break;
		}
	}

	private void WriteArrayTypeSignature(ArrayType array)
	{
		WriteElementType(ElementType.Array);
		WriteTypeSignature(array.ElementType);
		Collection<ArrayDimension> dimensions = array.Dimensions;
		int count = dimensions.Count;
		WriteCompressedUInt32((uint)count);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < count; i++)
		{
			ArrayDimension arrayDimension = dimensions[i];
			if (arrayDimension.UpperBound.HasValue)
			{
				num++;
				num2++;
			}
			else if (arrayDimension.LowerBound.HasValue)
			{
				num2++;
			}
		}
		int[] array2 = new int[num];
		int[] array3 = new int[num2];
		for (int j = 0; j < num2; j++)
		{
			ArrayDimension arrayDimension2 = dimensions[j];
			array3[j] = arrayDimension2.LowerBound.GetValueOrDefault();
			if (arrayDimension2.UpperBound.HasValue)
			{
				array2[j] = arrayDimension2.UpperBound.Value - array3[j] + 1;
			}
		}
		WriteCompressedUInt32((uint)num);
		for (int k = 0; k < num; k++)
		{
			WriteCompressedUInt32((uint)array2[k]);
		}
		WriteCompressedUInt32((uint)num2);
		for (int l = 0; l < num2; l++)
		{
			WriteCompressedInt32(array3[l]);
		}
	}

	public void WriteGenericInstanceSignature(IGenericInstance instance)
	{
		Collection<TypeReference> genericArguments = instance.GenericArguments;
		int count = genericArguments.Count;
		WriteCompressedUInt32((uint)count);
		for (int i = 0; i < count; i++)
		{
			WriteTypeSignature(genericArguments[i]);
		}
	}

	private void WriteModifierSignature(ElementType element_type, IModifierType type)
	{
		WriteElementType(element_type);
		WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type.ModifierType));
		WriteTypeSignature(type.ElementType);
	}

	private bool TryWriteElementType(TypeReference type)
	{
		ElementType etype = type.etype;
		if (etype == ElementType.None)
		{
			return false;
		}
		WriteElementType(etype);
		return true;
	}

	public void WriteConstantString(string value)
	{
		if (value != null)
		{
			WriteBytes(Encoding.Unicode.GetBytes(value));
		}
		else
		{
			WriteByte(byte.MaxValue);
		}
	}

	public void WriteConstantPrimitive(object value)
	{
		WritePrimitiveValue(value);
	}

	public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute)
	{
		if (attribute.HasConstructorArguments)
		{
			Collection<CustomAttributeArgument> constructorArguments = attribute.ConstructorArguments;
			Collection<ParameterDefinition> parameters = attribute.Constructor.Parameters;
			if (parameters.Count != constructorArguments.Count)
			{
				throw new InvalidOperationException();
			}
			for (int i = 0; i < constructorArguments.Count; i++)
			{
				TypeReference type = GenericParameterResolver.ResolveParameterTypeIfNeeded(attribute.Constructor, parameters[i]);
				WriteCustomAttributeFixedArgument(type, constructorArguments[i]);
			}
		}
	}

	private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument)
	{
		if (type.IsArray)
		{
			WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
		}
		else
		{
			WriteCustomAttributeElement(type, argument);
		}
	}

	private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument)
	{
		if (!(argument.Value is CustomAttributeArgument[] array))
		{
			WriteUInt32(uint.MaxValue);
			return;
		}
		WriteInt32(array.Length);
		if (array.Length != 0)
		{
			TypeReference elementType = type.ElementType;
			for (int i = 0; i < array.Length; i++)
			{
				WriteCustomAttributeElement(elementType, array[i]);
			}
		}
	}

	private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument)
	{
		if (type.IsArray)
		{
			WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
		}
		else if (type.etype == ElementType.Object)
		{
			argument = (CustomAttributeArgument)argument.Value;
			type = argument.Type;
			WriteCustomAttributeFieldOrPropType(type);
			WriteCustomAttributeElement(type, argument);
		}
		else
		{
			WriteCustomAttributeValue(type, argument.Value);
		}
	}

	private void WriteCustomAttributeValue(TypeReference type, object value)
	{
		switch (type.etype)
		{
		case ElementType.String:
		{
			string text = (string)value;
			if (text == null)
			{
				WriteByte(byte.MaxValue);
			}
			else
			{
				WriteUTF8String(text);
			}
			break;
		}
		case ElementType.None:
			if (type.IsTypeOf("System", "Type"))
			{
				WriteCustomAttributeTypeValue((TypeReference)value);
			}
			else
			{
				WriteCustomAttributeEnumValue(type, value);
			}
			break;
		case ElementType.GenericInst:
			WriteCustomAttributeEnumValue(type, value);
			break;
		default:
			WritePrimitiveValue(value);
			break;
		}
	}

	private void WriteCustomAttributeTypeValue(TypeReference value)
	{
		if (value is TypeDefinition typeDefinition)
		{
			TypeDefinition typeDefinition2 = typeDefinition;
			while (typeDefinition2.DeclaringType != null)
			{
				typeDefinition2 = typeDefinition2.DeclaringType;
			}
			if (WindowsRuntimeProjections.IsClrImplementationType(typeDefinition2))
			{
				WindowsRuntimeProjections.Project(typeDefinition2);
				WriteTypeReference(value);
				WindowsRuntimeProjections.RemoveProjection(typeDefinition2);
				return;
			}
		}
		WriteTypeReference(value);
	}

	private void WritePrimitiveValue(object value)
	{
		if (value == null)
		{
			throw new ArgumentNullException();
		}
		switch (Type.GetTypeCode(value.GetType()))
		{
		case TypeCode.Boolean:
			WriteByte((byte)(((bool)value) ? 1u : 0u));
			break;
		case TypeCode.Byte:
			WriteByte((byte)value);
			break;
		case TypeCode.SByte:
			WriteSByte((sbyte)value);
			break;
		case TypeCode.Int16:
			WriteInt16((short)value);
			break;
		case TypeCode.UInt16:
			WriteUInt16((ushort)value);
			break;
		case TypeCode.Char:
			WriteInt16((short)(char)value);
			break;
		case TypeCode.Int32:
			WriteInt32((int)value);
			break;
		case TypeCode.UInt32:
			WriteUInt32((uint)value);
			break;
		case TypeCode.Single:
			WriteSingle((float)value);
			break;
		case TypeCode.Int64:
			WriteInt64((long)value);
			break;
		case TypeCode.UInt64:
			WriteUInt64((ulong)value);
			break;
		case TypeCode.Double:
			WriteDouble((double)value);
			break;
		default:
			throw new NotSupportedException(value.GetType().FullName);
		}
	}

	private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value)
	{
		TypeDefinition typeDefinition = enum_type.CheckedResolve();
		if (!typeDefinition.IsEnum)
		{
			throw new ArgumentException();
		}
		WriteCustomAttributeValue(typeDefinition.GetEnumUnderlyingType(), value);
	}

	private void WriteCustomAttributeFieldOrPropType(TypeReference type)
	{
		if (type.IsArray)
		{
			ArrayType arrayType = (ArrayType)type;
			WriteElementType(ElementType.SzArray);
			WriteCustomAttributeFieldOrPropType(arrayType.ElementType);
			return;
		}
		ElementType etype = type.etype;
		switch (etype)
		{
		case ElementType.Object:
			WriteElementType(ElementType.Boxed);
			break;
		case ElementType.None:
			if (type.IsTypeOf("System", "Type"))
			{
				WriteElementType(ElementType.Type);
				break;
			}
			WriteElementType(ElementType.Enum);
			WriteTypeReference(type);
			break;
		case ElementType.GenericInst:
			WriteElementType(ElementType.Enum);
			WriteTypeReference(type);
			break;
		default:
			WriteElementType(etype);
			break;
		}
	}

	public void WriteCustomAttributeNamedArguments(CustomAttribute attribute)
	{
		int namedArgumentCount = GetNamedArgumentCount(attribute);
		WriteUInt16((ushort)namedArgumentCount);
		if (namedArgumentCount != 0)
		{
			WriteICustomAttributeNamedArguments(attribute);
		}
	}

	private static int GetNamedArgumentCount(ICustomAttribute attribute)
	{
		int num = 0;
		if (attribute.HasFields)
		{
			num += attribute.Fields.Count;
		}
		if (attribute.HasProperties)
		{
			num += attribute.Properties.Count;
		}
		return num;
	}

	private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute)
	{
		if (attribute.HasFields)
		{
			WriteCustomAttributeNamedArguments(83, attribute.Fields);
		}
		if (attribute.HasProperties)
		{
			WriteCustomAttributeNamedArguments(84, attribute.Properties);
		}
	}

	private void WriteCustomAttributeNamedArguments(byte kind, Collection<CustomAttributeNamedArgument> named_arguments)
	{
		for (int i = 0; i < named_arguments.Count; i++)
		{
			WriteCustomAttributeNamedArgument(kind, named_arguments[i]);
		}
	}

	private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument)
	{
		CustomAttributeArgument argument = named_argument.Argument;
		WriteByte(kind);
		WriteCustomAttributeFieldOrPropType(argument.Type);
		WriteUTF8String(named_argument.Name);
		WriteCustomAttributeFixedArgument(argument.Type, argument);
	}

	private void WriteSecurityAttribute(SecurityAttribute attribute)
	{
		WriteTypeReference(attribute.AttributeType);
		int namedArgumentCount = GetNamedArgumentCount(attribute);
		if (namedArgumentCount == 0)
		{
			WriteCompressedUInt32(1u);
			WriteCompressedUInt32(0u);
			return;
		}
		SignatureWriter signatureWriter = new SignatureWriter(metadata);
		signatureWriter.WriteCompressedUInt32((uint)namedArgumentCount);
		signatureWriter.WriteICustomAttributeNamedArguments(attribute);
		WriteCompressedUInt32((uint)signatureWriter.length);
		WriteBytes(signatureWriter);
	}

	public void WriteSecurityDeclaration(SecurityDeclaration declaration)
	{
		WriteByte(46);
		Collection<SecurityAttribute> security_attributes = declaration.security_attributes;
		if (security_attributes == null)
		{
			throw new NotSupportedException();
		}
		WriteCompressedUInt32((uint)security_attributes.Count);
		for (int i = 0; i < security_attributes.Count; i++)
		{
			WriteSecurityAttribute(security_attributes[i]);
		}
	}

	public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration)
	{
		string xmlSecurityDeclaration = GetXmlSecurityDeclaration(declaration);
		if (xmlSecurityDeclaration == null)
		{
			throw new NotSupportedException();
		}
		WriteBytes(Encoding.Unicode.GetBytes(xmlSecurityDeclaration));
	}

	private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration)
	{
		if (declaration.security_attributes == null || declaration.security_attributes.Count != 1)
		{
			return null;
		}
		SecurityAttribute securityAttribute = declaration.security_attributes[0];
		if (!securityAttribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
		{
			return null;
		}
		if (securityAttribute.properties == null || securityAttribute.properties.Count != 1)
		{
			return null;
		}
		CustomAttributeNamedArgument customAttributeNamedArgument = securityAttribute.properties[0];
		if (customAttributeNamedArgument.Name != "XML")
		{
			return null;
		}
		return (string)customAttributeNamedArgument.Argument.Value;
	}

	private void WriteTypeReference(TypeReference type)
	{
		WriteUTF8String(TypeParser.ToParseable(type, top_level: false));
	}

	public void WriteMarshalInfo(MarshalInfo marshal_info)
	{
		WriteNativeType(marshal_info.native);
		switch (marshal_info.native)
		{
		case NativeType.Array:
		{
			ArrayMarshalInfo arrayMarshalInfo = (ArrayMarshalInfo)marshal_info;
			if (arrayMarshalInfo.element_type != NativeType.None)
			{
				WriteNativeType(arrayMarshalInfo.element_type);
			}
			if (arrayMarshalInfo.size_parameter_index > -1)
			{
				WriteCompressedUInt32((uint)arrayMarshalInfo.size_parameter_index);
			}
			if (arrayMarshalInfo.size > -1)
			{
				WriteCompressedUInt32((uint)arrayMarshalInfo.size);
			}
			if (arrayMarshalInfo.size_parameter_multiplier > -1)
			{
				WriteCompressedUInt32((uint)arrayMarshalInfo.size_parameter_multiplier);
			}
			break;
		}
		case NativeType.SafeArray:
		{
			SafeArrayMarshalInfo safeArrayMarshalInfo = (SafeArrayMarshalInfo)marshal_info;
			if (safeArrayMarshalInfo.element_type != 0)
			{
				WriteVariantType(safeArrayMarshalInfo.element_type);
			}
			break;
		}
		case NativeType.FixedArray:
		{
			FixedArrayMarshalInfo fixedArrayMarshalInfo = (FixedArrayMarshalInfo)marshal_info;
			if (fixedArrayMarshalInfo.size > -1)
			{
				WriteCompressedUInt32((uint)fixedArrayMarshalInfo.size);
			}
			if (fixedArrayMarshalInfo.element_type != NativeType.None)
			{
				WriteNativeType(fixedArrayMarshalInfo.element_type);
			}
			break;
		}
		case NativeType.FixedSysString:
		{
			FixedSysStringMarshalInfo fixedSysStringMarshalInfo = (FixedSysStringMarshalInfo)marshal_info;
			if (fixedSysStringMarshalInfo.size > -1)
			{
				WriteCompressedUInt32((uint)fixedSysStringMarshalInfo.size);
			}
			break;
		}
		case NativeType.CustomMarshaler:
		{
			CustomMarshalInfo customMarshalInfo = (CustomMarshalInfo)marshal_info;
			WriteUTF8String((customMarshalInfo.guid != Guid.Empty) ? customMarshalInfo.guid.ToString() : string.Empty);
			WriteUTF8String(customMarshalInfo.unmanaged_type);
			WriteTypeReference(customMarshalInfo.managed_type);
			WriteUTF8String(customMarshalInfo.cookie);
			break;
		}
		}
	}

	private void WriteNativeType(NativeType native)
	{
		WriteByte((byte)native);
	}

	private void WriteVariantType(VariantType variant)
	{
		WriteByte((byte)variant);
	}

	public void WriteSequencePoints(MethodDebugInformation info)
	{
		int num = -1;
		int num2 = -1;
		WriteCompressedUInt32(info.local_var_token.RID);
		if (!info.TryGetUniqueDocument(out var document))
		{
			document = null;
		}
		for (int i = 0; i < info.SequencePoints.Count; i++)
		{
			SequencePoint sequencePoint = info.SequencePoints[i];
			Document document2 = sequencePoint.Document;
			if (document != document2)
			{
				MetadataToken documentToken = metadata.GetDocumentToken(document2);
				if (document != null)
				{
					WriteCompressedUInt32(0u);
				}
				WriteCompressedUInt32(documentToken.RID);
				document = document2;
			}
			if (i > 0)
			{
				WriteCompressedUInt32((uint)(sequencePoint.Offset - info.SequencePoints[i - 1].Offset));
			}
			else
			{
				WriteCompressedUInt32((uint)sequencePoint.Offset);
			}
			if (sequencePoint.IsHidden)
			{
				WriteInt16(0);
				continue;
			}
			int num3 = sequencePoint.EndLine - sequencePoint.StartLine;
			int value = sequencePoint.EndColumn - sequencePoint.StartColumn;
			WriteCompressedUInt32((uint)num3);
			if (num3 == 0)
			{
				WriteCompressedUInt32((uint)value);
			}
			else
			{
				WriteCompressedInt32(value);
			}
			if (num < 0)
			{
				WriteCompressedUInt32((uint)sequencePoint.StartLine);
				WriteCompressedUInt32((uint)sequencePoint.StartColumn);
			}
			else
			{
				WriteCompressedInt32(sequencePoint.StartLine - num);
				WriteCompressedInt32(sequencePoint.StartColumn - num2);
			}
			num = sequencePoint.StartLine;
			num2 = sequencePoint.StartColumn;
		}
	}
}


using Mono.Cecil;

internal delegate AssemblyDefinition AssemblyResolveEventHandler(object sender, AssemblyNameReference reference);


using System;
using Mono.Cecil;

internal sealed class AssemblyResolveEventArgs : EventArgs
{
	private readonly AssemblyNameReference reference;

	public AssemblyNameReference AssemblyReference => reference;

	public AssemblyResolveEventArgs(AssemblyNameReference reference)
	{
		this.reference = reference;
	}
}


using System;
using System.IO;
using System.Runtime.Serialization;
using Mono.Cecil;

[Serializable]
internal sealed class AssemblyResolutionException : FileNotFoundException
{
	private readonly AssemblyNameReference reference;

	public AssemblyNameReference AssemblyReference => reference;

	public AssemblyResolutionException(AssemblyNameReference reference)
		: this(reference, null)
	{
	}

	public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException)
		: base($"Failed to resolve assembly: '{reference}'", innerException)
	{
		this.reference = reference;
	}

	private AssemblyResolutionException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Collections.Generic;

internal abstract class BaseAssemblyResolver : IAssemblyResolver, IDisposable
{
	private static readonly bool on_mono = Type.GetType("Mono.Runtime") != null;

	private readonly Collection<string> directories;

	private Collection<string> gac_paths;

	public event AssemblyResolveEventHandler ResolveFailure;

	public void AddSearchDirectory(string directory)
	{
		directories.Add(directory);
	}

	public void RemoveSearchDirectory(string directory)
	{
		directories.Remove(directory);
	}

	public string[] GetSearchDirectories()
	{
		string[] array = new string[directories.size];
		Array.Copy(directories.items, array, array.Length);
		return array;
	}

	protected BaseAssemblyResolver()
	{
		directories = new Collection<string>(2) { ".", "bin" };
	}

	private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters)
	{
		if (parameters.AssemblyResolver == null)
		{
			parameters.AssemblyResolver = this;
		}
		return ModuleDefinition.ReadModule(file, parameters).Assembly;
	}

	public virtual AssemblyDefinition Resolve(AssemblyNameReference name)
	{
		return Resolve(name, new ReaderParameters());
	}

	public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
	{
		Mixin.CheckName(name);
		Mixin.CheckParameters(parameters);
		AssemblyDefinition assemblyDefinition = SearchDirectory(name, directories, parameters);
		if (assemblyDefinition != null)
		{
			return assemblyDefinition;
		}
		if (name.IsRetargetable)
		{
			name = new AssemblyNameReference(name.Name, Mixin.ZeroVersion)
			{
				PublicKeyToken = Empty<byte>.Array
			};
		}
		string directoryName = Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName);
		string[] array = ((!on_mono) ? new string[1] { directoryName } : new string[2]
		{
			directoryName,
			Path.Combine(directoryName, "Facades")
		});
		if (IsZero(name.Version))
		{
			assemblyDefinition = SearchDirectory(name, array, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
		}
		if (name.Name == "mscorlib")
		{
			assemblyDefinition = GetCorlib(name, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
		}
		assemblyDefinition = GetAssemblyInGac(name, parameters);
		if (assemblyDefinition != null)
		{
			return assemblyDefinition;
		}
		assemblyDefinition = SearchDirectory(name, array, parameters);
		if (assemblyDefinition != null)
		{
			return assemblyDefinition;
		}
		if (this.ResolveFailure != null)
		{
			assemblyDefinition = this.ResolveFailure(this, name);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
		}
		throw new AssemblyResolutionException(name);
	}

	protected virtual AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable<string> directories, ReaderParameters parameters)
	{
		string[] array = ((!name.IsWindowsRuntime) ? new string[2] { ".exe", ".dll" } : new string[2] { ".winmd", ".dll" });
		foreach (string directory in directories)
		{
			string[] array2 = array;
			foreach (string text in array2)
			{
				string text2 = Path.Combine(directory, name.Name + text);
				if (File.Exists(text2))
				{
					try
					{
						return GetAssembly(text2, parameters);
					}
					catch (BadImageFormatException)
					{
					}
				}
			}
		}
		return null;
	}

	private static bool IsZero(Version version)
	{
		if (version.Major == 0 && version.Minor == 0 && version.Build == 0)
		{
			return version.Revision == 0;
		}
		return false;
	}

	private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters)
	{
		Version version = reference.Version;
		if (typeof(object).Assembly.GetName().Version == version || IsZero(version))
		{
			return GetAssembly(typeof(object).Module.FullyQualifiedName, parameters);
		}
		string fullName = Directory.GetParent(Directory.GetParent(typeof(object).Module.FullyQualifiedName).FullName).FullName;
		if (!on_mono)
		{
			fullName = version.Major switch
			{
				1 => (version.MajorRevision != 3300) ? Path.Combine(fullName, "v1.1.4322") : Path.Combine(fullName, "v1.0.3705"), 
				2 => Path.Combine(fullName, "v2.0.50727"), 
				4 => Path.Combine(fullName, "v4.0.30319"), 
				_ => throw new NotSupportedException("Version not supported: " + version), 
			};
		}
		else if (version.Major == 1)
		{
			fullName = Path.Combine(fullName, "1.0");
		}
		else if (version.Major == 2)
		{
			fullName = ((version.MajorRevision != 5) ? Path.Combine(fullName, "2.0") : Path.Combine(fullName, "2.1"));
		}
		else
		{
			if (version.Major != 4)
			{
				throw new NotSupportedException("Version not supported: " + version);
			}
			fullName = Path.Combine(fullName, "4.0");
		}
		string text = Path.Combine(fullName, "mscorlib.dll");
		if (File.Exists(text))
		{
			return GetAssembly(text, parameters);
		}
		if (on_mono && Directory.Exists(fullName + "-api"))
		{
			text = Path.Combine(fullName + "-api", "mscorlib.dll");
			if (File.Exists(text))
			{
				return GetAssembly(text, parameters);
			}
		}
		return null;
	}

	private static Collection<string> GetGacPaths()
	{
		if (on_mono)
		{
			return GetDefaultMonoGacPaths();
		}
		Collection<string> collection = new Collection<string>(2);
		string environmentVariable = Environment.GetEnvironmentVariable("WINDIR");
		if (environmentVariable == null)
		{
			return collection;
		}
		collection.Add(Path.Combine(environmentVariable, "assembly"));
		collection.Add(Path.Combine(environmentVariable, Path.Combine("Microsoft.NET", "assembly")));
		return collection;
	}

	private static Collection<string> GetDefaultMonoGacPaths()
	{
		Collection<string> collection = new Collection<string>(1);
		string currentMonoGac = GetCurrentMonoGac();
		if (currentMonoGac != null)
		{
			collection.Add(currentMonoGac);
		}
		string environmentVariable = Environment.GetEnvironmentVariable("MONO_GAC_PREFIX");
		if (string.IsNullOrEmpty(environmentVariable))
		{
			return collection;
		}
		string[] array = environmentVariable.Split(new char[1] { Path.PathSeparator });
		foreach (string text in array)
		{
			if (!string.IsNullOrEmpty(text))
			{
				string text2 = Path.Combine(Path.Combine(Path.Combine(text, "lib"), "mono"), "gac");
				if (Directory.Exists(text2) && !collection.Contains(currentMonoGac))
				{
					collection.Add(text2);
				}
			}
		}
		return collection;
	}

	private static string GetCurrentMonoGac()
	{
		return Path.Combine(Directory.GetParent(Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName)).FullName, "gac");
	}

	private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters)
	{
		if (reference.PublicKeyToken == null || reference.PublicKeyToken.Length == 0)
		{
			return null;
		}
		if (gac_paths == null)
		{
			gac_paths = GetGacPaths();
		}
		if (on_mono)
		{
			return GetAssemblyInMonoGac(reference, parameters);
		}
		return GetAssemblyInNetGac(reference, parameters);
	}

	private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters)
	{
		for (int i = 0; i < gac_paths.Count; i++)
		{
			string gac = gac_paths[i];
			string assemblyFile = GetAssemblyFile(reference, string.Empty, gac);
			if (File.Exists(assemblyFile))
			{
				return GetAssembly(assemblyFile, parameters);
			}
		}
		return null;
	}

	private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters)
	{
		string[] array = new string[4] { "GAC_MSIL", "GAC_32", "GAC_64", "GAC" };
		string[] array2 = new string[2]
		{
			string.Empty,
			"v4.0_"
		};
		for (int i = 0; i < gac_paths.Count; i++)
		{
			for (int j = 0; j < array.Length; j++)
			{
				string text = Path.Combine(gac_paths[i], array[j]);
				string assemblyFile = GetAssemblyFile(reference, array2[i], text);
				if (Directory.Exists(text) && File.Exists(assemblyFile))
				{
					return GetAssembly(assemblyFile, parameters);
				}
			}
		}
		return null;
	}

	private static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac)
	{
		StringBuilder stringBuilder = new StringBuilder().Append(prefix).Append(reference.Version).Append("__");
		for (int i = 0; i < reference.PublicKeyToken.Length; i++)
		{
			stringBuilder.Append(reference.PublicKeyToken[i].ToString("x2"));
		}
		return Path.Combine(Path.Combine(Path.Combine(gac, reference.Name), stringBuilder.ToString()), reference.Name + ".dll");
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected virtual void Dispose(bool disposing)
	{
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class CallSite : IMethodSignature, IMetadataTokenProvider
{
	private readonly MethodReference signature;

	public bool HasThis
	{
		get
		{
			return signature.HasThis;
		}
		set
		{
			signature.HasThis = value;
		}
	}

	public bool ExplicitThis
	{
		get
		{
			return signature.ExplicitThis;
		}
		set
		{
			signature.ExplicitThis = value;
		}
	}

	public MethodCallingConvention CallingConvention
	{
		get
		{
			return signature.CallingConvention;
		}
		set
		{
			signature.CallingConvention = value;
		}
	}

	public bool HasParameters => signature.HasParameters;

	public Collection<ParameterDefinition> Parameters => signature.Parameters;

	public TypeReference ReturnType
	{
		get
		{
			return signature.MethodReturnType.ReturnType;
		}
		set
		{
			signature.MethodReturnType.ReturnType = value;
		}
	}

	public MethodReturnType MethodReturnType => signature.MethodReturnType;

	public string Name
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public string Namespace
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public ModuleDefinition Module => ReturnType.Module;

	public IMetadataScope Scope => signature.ReturnType.Scope;

	public MetadataToken MetadataToken
	{
		get
		{
			return signature.token;
		}
		set
		{
			signature.token = value;
		}
	}

	public string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(ReturnType.FullName);
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	internal CallSite()
	{
		signature = new MethodReference();
		signature.token = new MetadataToken(TokenType.Signature, 0);
	}

	public CallSite(TypeReference returnType)
		: this()
	{
		if (returnType == null)
		{
			throw new ArgumentNullException("returnType");
		}
		signature.ReturnType = returnType;
	}

	public override string ToString()
	{
		return FullName;
	}
}


using Mono.Cecil;

internal struct CustomAttributeArgument
{
	private readonly TypeReference type;

	private readonly object value;

	public TypeReference Type => type;

	public object Value => value;

	public CustomAttributeArgument(TypeReference type, object value)
	{
		Mixin.CheckType(type);
		this.type = type;
		this.value = value;
	}
}


using Mono.Cecil;

internal struct CustomAttributeNamedArgument
{
	private readonly string name;

	private readonly CustomAttributeArgument argument;

	public string Name => name;

	public CustomAttributeArgument Argument => argument;

	public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument)
	{
		Mixin.CheckName(name);
		this.name = name;
		this.argument = argument;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal interface ICustomAttribute
{
	TypeReference AttributeType { get; }

	bool HasFields { get; }

	bool HasProperties { get; }

	bool HasConstructorArguments { get; }

	Collection<CustomAttributeNamedArgument> Fields { get; }

	Collection<CustomAttributeNamedArgument> Properties { get; }

	Collection<CustomAttributeArgument> ConstructorArguments { get; }
}


using System;
using System.Diagnostics;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

[DebuggerDisplay("{AttributeType}")]
internal sealed class CustomAttribute : ICustomAttribute
{
	internal CustomAttributeValueProjection projection;

	internal readonly uint signature;

	internal bool resolved;

	private MethodReference constructor;

	private byte[] blob;

	internal Collection<CustomAttributeArgument> arguments;

	internal Collection<CustomAttributeNamedArgument> fields;

	internal Collection<CustomAttributeNamedArgument> properties;

	public MethodReference Constructor
	{
		get
		{
			return constructor;
		}
		set
		{
			constructor = value;
		}
	}

	public TypeReference AttributeType => constructor.DeclaringType;

	public bool IsResolved => resolved;

	public bool HasConstructorArguments
	{
		get
		{
			Resolve();
			return !arguments.IsNullOrEmpty();
		}
	}

	public Collection<CustomAttributeArgument> ConstructorArguments
	{
		get
		{
			Resolve();
			if (arguments == null)
			{
				Interlocked.CompareExchange(ref arguments, new Collection<CustomAttributeArgument>(), null);
			}
			return arguments;
		}
	}

	public bool HasFields
	{
		get
		{
			Resolve();
			return !fields.IsNullOrEmpty();
		}
	}

	public Collection<CustomAttributeNamedArgument> Fields
	{
		get
		{
			Resolve();
			if (fields == null)
			{
				Interlocked.CompareExchange(ref fields, new Collection<CustomAttributeNamedArgument>(), null);
			}
			return fields;
		}
	}

	public bool HasProperties
	{
		get
		{
			Resolve();
			return !properties.IsNullOrEmpty();
		}
	}

	public Collection<CustomAttributeNamedArgument> Properties
	{
		get
		{
			Resolve();
			if (properties == null)
			{
				Interlocked.CompareExchange(ref properties, new Collection<CustomAttributeNamedArgument>(), null);
			}
			return properties;
		}
	}

	internal bool HasImage
	{
		get
		{
			if (constructor != null)
			{
				return constructor.HasImage;
			}
			return false;
		}
	}

	internal ModuleDefinition Module => constructor.Module;

	internal CustomAttribute(uint signature, MethodReference constructor)
	{
		this.signature = signature;
		this.constructor = constructor;
		resolved = false;
	}

	public CustomAttribute(MethodReference constructor)
	{
		this.constructor = constructor;
		resolved = true;
	}

	public CustomAttribute(MethodReference constructor, byte[] blob)
	{
		this.constructor = constructor;
		resolved = false;
		this.blob = blob;
	}

	public byte[] GetBlob()
	{
		if (blob != null)
		{
			return blob;
		}
		if (!HasImage)
		{
			throw new NotSupportedException();
		}
		return Module.Read(ref blob, this, (CustomAttribute attribute, MetadataReader reader) => reader.ReadCustomAttributeBlob(attribute.signature));
	}

	private void Resolve()
	{
		if (resolved || !HasImage)
		{
			return;
		}
		lock (Module.SyncRoot)
		{
			if (resolved)
			{
				return;
			}
			Module.Read(this, delegate(CustomAttribute attribute, MetadataReader reader)
			{
				try
				{
					reader.ReadCustomAttributeSignature(attribute);
					resolved = true;
				}
				catch (ResolutionException)
				{
					if (arguments != null)
					{
						arguments.Clear();
					}
					if (fields != null)
					{
						fields.Clear();
					}
					if (properties != null)
					{
						properties.Clear();
					}
					resolved = false;
				}
			});
		}
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;

internal class DefaultAssemblyResolver : BaseAssemblyResolver
{
	private readonly IDictionary<string, AssemblyDefinition> cache;

	public DefaultAssemblyResolver()
	{
		cache = new Dictionary<string, AssemblyDefinition>(StringComparer.Ordinal);
	}

	public override AssemblyDefinition Resolve(AssemblyNameReference name)
	{
		Mixin.CheckName(name);
		if (cache.TryGetValue(name.FullName, out var value))
		{
			return value;
		}
		value = base.Resolve(name);
		cache[name.FullName] = value;
		return value;
	}

	protected void RegisterAssembly(AssemblyDefinition assembly)
	{
		if (assembly == null)
		{
			throw new ArgumentNullException("assembly");
		}
		string fullName = assembly.Name.FullName;
		if (!cache.ContainsKey(fullName))
		{
			cache[fullName] = assembly;
		}
	}

	protected override void Dispose(bool disposing)
	{
		foreach (AssemblyDefinition value in cache.Values)
		{
			value.Dispose();
		}
		cache.Clear();
		base.Dispose(disposing);
	}
}


using System;
using System.IO;
using Mono.Cecil;

internal sealed class EmbeddedResource : Resource
{
	private readonly MetadataReader reader;

	private uint? offset;

	private byte[] data;

	private Stream stream;

	public override ResourceType ResourceType => ResourceType.Embedded;

	public EmbeddedResource(string name, ManifestResourceAttributes attributes, byte[] data)
		: base(name, attributes)
	{
		this.data = data;
	}

	public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream)
		: base(name, attributes)
	{
		this.stream = stream;
	}

	internal EmbeddedResource(string name, ManifestResourceAttributes attributes, uint offset, MetadataReader reader)
		: base(name, attributes)
	{
		this.offset = offset;
		this.reader = reader;
	}

	public Stream GetResourceStream()
	{
		if (stream != null)
		{
			return stream;
		}
		if (data != null)
		{
			return new MemoryStream(data);
		}
		if (offset.HasValue)
		{
			return new MemoryStream(reader.GetManagedResource(offset.Value));
		}
		throw new InvalidOperationException();
	}

	public byte[] GetResourceData()
	{
		if (stream != null)
		{
			return ReadStream(stream);
		}
		if (data != null)
		{
			return data;
		}
		if (offset.HasValue)
		{
			return reader.GetManagedResource(offset.Value);
		}
		throw new InvalidOperationException();
	}

	private static byte[] ReadStream(Stream stream)
	{
		int num3;
		if (stream.CanSeek)
		{
			int num = (int)stream.Length;
			byte[] array = new byte[num];
			int num2 = 0;
			while ((num3 = stream.Read(array, num2, num - num2)) > 0)
			{
				num2 += num3;
			}
			return array;
		}
		byte[] array2 = new byte[8192];
		MemoryStream memoryStream = new MemoryStream();
		while ((num3 = stream.Read(array2, 0, array2.Length)) > 0)
		{
			memoryStream.Write(array2, 0, num3);
		}
		return memoryStream.ToArray();
	}
}


using System;

[Flags]
internal enum EventAttributes : ushort
{
	None = 0,
	SpecialName = 0x200,
	RTSpecialName = 0x400
}


using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class EventDefinition : EventReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider
{
	private ushort attributes;

	private Collection<CustomAttribute> custom_attributes;

	internal MethodDefinition add_method;

	internal MethodDefinition invoke_method;

	internal MethodDefinition remove_method;

	internal Collection<MethodDefinition> other_methods;

	public EventAttributes Attributes
	{
		get
		{
			return (EventAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public MethodDefinition AddMethod
	{
		get
		{
			if (add_method != null)
			{
				return add_method;
			}
			InitializeMethods();
			return add_method;
		}
		set
		{
			add_method = value;
		}
	}

	public MethodDefinition InvokeMethod
	{
		get
		{
			if (invoke_method != null)
			{
				return invoke_method;
			}
			InitializeMethods();
			return invoke_method;
		}
		set
		{
			invoke_method = value;
		}
	}

	public MethodDefinition RemoveMethod
	{
		get
		{
			if (remove_method != null)
			{
				return remove_method;
			}
			InitializeMethods();
			return remove_method;
		}
		set
		{
			remove_method = value;
		}
	}

	public bool HasOtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods.Count > 0;
			}
			InitializeMethods();
			return !other_methods.IsNullOrEmpty();
		}
	}

	public Collection<MethodDefinition> OtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods;
			}
			InitializeMethods();
			if (other_methods == null)
			{
				Interlocked.CompareExchange(ref other_methods, new Collection<MethodDefinition>(), null);
			}
			return other_methods;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	public override bool IsDefinition => true;

	public EventDefinition(string name, EventAttributes attributes, TypeReference eventType)
		: base(name, eventType)
	{
		this.attributes = (ushort)attributes;
		token = new MetadataToken(TokenType.Event);
	}

	private void InitializeMethods()
	{
		ModuleDefinition module = Module;
		if (module == null)
		{
			return;
		}
		lock (module.SyncRoot)
		{
			if (add_method == null && invoke_method == null && remove_method == null && module.HasImage())
			{
				module.Read(this, delegate(EventDefinition @event, MetadataReader reader)
				{
					reader.ReadMethods(@event);
				});
			}
		}
	}

	public override EventDefinition Resolve()
	{
		return this;
	}
}


using Mono.Cecil;

internal abstract class EventReference : MemberReference
{
	private TypeReference event_type;

	public TypeReference EventType
	{
		get
		{
			return event_type;
		}
		set
		{
			event_type = value;
		}
	}

	public override string FullName => event_type.FullName + " " + MemberFullName();

	protected EventReference(string name, TypeReference eventType)
		: base(name)
	{
		Mixin.CheckType(eventType, Mixin.Argument.eventType);
		event_type = eventType;
	}

	protected override IMemberDefinition ResolveDefinition()
	{
		return Resolve();
	}

	public new abstract EventDefinition Resolve();
}


using Mono.Cecil;

internal sealed class ExportedType : IMetadataTokenProvider
{
	private string @namespace;

	private string name;

	private uint attributes;

	private IMetadataScope scope;

	private ModuleDefinition module;

	private int identifier;

	private ExportedType declaring_type;

	internal MetadataToken token;

	public string Namespace
	{
		get
		{
			return @namespace;
		}
		set
		{
			@namespace = value;
		}
	}

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public TypeAttributes Attributes
	{
		get
		{
			return (TypeAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public IMetadataScope Scope
	{
		get
		{
			if (declaring_type != null)
			{
				return declaring_type.Scope;
			}
			return scope;
		}
		set
		{
			if (declaring_type != null)
			{
				declaring_type.Scope = value;
			}
			else
			{
				scope = value;
			}
		}
	}

	public ExportedType DeclaringType
	{
		get
		{
			return declaring_type;
		}
		set
		{
			declaring_type = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	public int Identifier
	{
		get
		{
			return identifier;
		}
		set
		{
			identifier = value;
		}
	}

	public bool IsNotPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 0u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 1u, value);
		}
	}

	public bool IsNestedPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 2u, value);
		}
	}

	public bool IsNestedPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 3u, value);
		}
	}

	public bool IsNestedFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 4u, value);
		}
	}

	public bool IsNestedAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 5u, value);
		}
	}

	public bool IsNestedFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 6u, value);
		}
	}

	public bool IsNestedFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 7u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 7u, value);
		}
	}

	public bool IsAutoLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 0u, value);
		}
	}

	public bool IsSequentialLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 8u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 8u, value);
		}
	}

	public bool IsExplicitLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 16u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 16u, value);
		}
	}

	public bool IsClass
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 0u, value);
		}
	}

	public bool IsInterface
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 32u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 32u, value);
		}
	}

	public bool IsAbstract
	{
		get
		{
			return attributes.GetAttributes(128u);
		}
		set
		{
			attributes = attributes.SetAttributes(128u, value);
		}
	}

	public bool IsSealed
	{
		get
		{
			return attributes.GetAttributes(256u);
		}
		set
		{
			attributes = attributes.SetAttributes(256u, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024u);
		}
		set
		{
			attributes = attributes.SetAttributes(1024u, value);
		}
	}

	public bool IsImport
	{
		get
		{
			return attributes.GetAttributes(4096u);
		}
		set
		{
			attributes = attributes.SetAttributes(4096u, value);
		}
	}

	public bool IsSerializable
	{
		get
		{
			return attributes.GetAttributes(8192u);
		}
		set
		{
			attributes = attributes.SetAttributes(8192u, value);
		}
	}

	public bool IsAnsiClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 0u, value);
		}
	}

	public bool IsUnicodeClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 65536u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 65536u, value);
		}
	}

	public bool IsAutoClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 131072u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 131072u, value);
		}
	}

	public bool IsBeforeFieldInit
	{
		get
		{
			return attributes.GetAttributes(1048576u);
		}
		set
		{
			attributes = attributes.SetAttributes(1048576u, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(2048u);
		}
		set
		{
			attributes = attributes.SetAttributes(2048u, value);
		}
	}

	public bool HasSecurity
	{
		get
		{
			return attributes.GetAttributes(262144u);
		}
		set
		{
			attributes = attributes.SetAttributes(262144u, value);
		}
	}

	public bool IsForwarder
	{
		get
		{
			return attributes.GetAttributes(2097152u);
		}
		set
		{
			attributes = attributes.SetAttributes(2097152u, value);
		}
	}

	public string FullName
	{
		get
		{
			string text = (string.IsNullOrEmpty(@namespace) ? name : (@namespace + "." + name));
			if (declaring_type != null)
			{
				return declaring_type.FullName + "/" + text;
			}
			return text;
		}
	}

	public ExportedType(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
	{
		this.@namespace = @namespace;
		this.name = name;
		this.scope = scope;
		this.module = module;
	}

	public override string ToString()
	{
		return FullName;
	}

	public TypeDefinition Resolve()
	{
		return module.Resolve(CreateReference());
	}

	internal TypeReference CreateReference()
	{
		return new TypeReference(@namespace, name, module, scope)
		{
			DeclaringType = ((declaring_type != null) ? declaring_type.CreateReference() : null)
		};
	}
}


using System;

[Flags]
internal enum FieldAttributes : ushort
{
	FieldAccessMask = 7,
	CompilerControlled = 0,
	Private = 1,
	FamANDAssem = 2,
	Assembly = 3,
	Family = 4,
	FamORAssem = 5,
	Public = 6,
	Static = 0x10,
	InitOnly = 0x20,
	Literal = 0x40,
	NotSerialized = 0x80,
	SpecialName = 0x200,
	PInvokeImpl = 0x2000,
	RTSpecialName = 0x400,
	HasFieldMarshal = 0x1000,
	HasDefault = 0x8000,
	HasFieldRVA = 0x100
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class FieldDefinition : FieldReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider, IMarshalInfoProvider
{
	private ushort attributes;

	private Collection<CustomAttribute> custom_attributes;

	private int offset = -2;

	internal int rva = -2;

	private byte[] initial_value;

	private object constant = Mixin.NotResolved;

	private MarshalInfo marshal_info;

	public bool HasLayoutInfo
	{
		get
		{
			if (offset >= 0)
			{
				return true;
			}
			ResolveLayout();
			return offset >= 0;
		}
	}

	public int Offset
	{
		get
		{
			if (offset >= 0)
			{
				return offset;
			}
			ResolveLayout();
			if (offset < 0)
			{
				return -1;
			}
			return offset;
		}
		set
		{
			offset = value;
		}
	}

	internal FieldDefinitionProjection WindowsRuntimeProjection
	{
		get
		{
			return (FieldDefinitionProjection)projection;
		}
		set
		{
			projection = value;
		}
	}

	public int RVA
	{
		get
		{
			if (rva > 0)
			{
				return rva;
			}
			ResolveRVA();
			if (rva <= 0)
			{
				return 0;
			}
			return rva;
		}
	}

	public byte[] InitialValue
	{
		get
		{
			if (initial_value != null)
			{
				return initial_value;
			}
			ResolveRVA();
			if (initial_value == null)
			{
				initial_value = Empty<byte>.Array;
			}
			return initial_value;
		}
		set
		{
			initial_value = value;
			HasFieldRVA = !initial_value.IsNullOrEmpty();
			rva = 0;
		}
	}

	public FieldAttributes Attributes
	{
		get
		{
			return (FieldAttributes)attributes;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && (uint)value != attributes)
			{
				throw new InvalidOperationException();
			}
			attributes = (ushort)value;
		}
	}

	public bool HasConstant
	{
		get
		{
			this.ResolveConstant(ref constant, Module);
			return constant != Mixin.NoValue;
		}
		set
		{
			if (!value)
			{
				constant = Mixin.NoValue;
			}
		}
	}

	public object Constant
	{
		get
		{
			if (!HasConstant)
			{
				return null;
			}
			return constant;
		}
		set
		{
			constant = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public bool HasMarshalInfo
	{
		get
		{
			if (marshal_info != null)
			{
				return true;
			}
			return this.GetHasMarshalInfo(Module);
		}
	}

	public MarshalInfo MarshalInfo
	{
		get
		{
			return marshal_info ?? this.GetMarshalInfo(ref marshal_info, Module);
		}
		set
		{
			marshal_info = value;
		}
	}

	public bool IsCompilerControlled
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 0u, value);
		}
	}

	public bool IsPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 1u, value);
		}
	}

	public bool IsFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 2u, value);
		}
	}

	public bool IsAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 3u, value);
		}
	}

	public bool IsFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 4u, value);
		}
	}

	public bool IsFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 5u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 6u, value);
		}
	}

	public bool IsStatic
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public bool IsInitOnly
	{
		get
		{
			return attributes.GetAttributes(32);
		}
		set
		{
			attributes = attributes.SetAttributes(32, value);
		}
	}

	public bool IsLiteral
	{
		get
		{
			return attributes.GetAttributes(64);
		}
		set
		{
			attributes = attributes.SetAttributes(64, value);
		}
	}

	public bool IsNotSerialized
	{
		get
		{
			return attributes.GetAttributes(128);
		}
		set
		{
			attributes = attributes.SetAttributes(128, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsPInvokeImpl
	{
		get
		{
			return attributes.GetAttributes(8192);
		}
		set
		{
			attributes = attributes.SetAttributes(8192, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public bool HasDefault
	{
		get
		{
			return attributes.GetAttributes(32768);
		}
		set
		{
			attributes = attributes.SetAttributes(32768, value);
		}
	}

	public bool HasFieldRVA
	{
		get
		{
			return attributes.GetAttributes(256);
		}
		set
		{
			attributes = attributes.SetAttributes(256, value);
		}
	}

	public override bool IsDefinition => true;

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	private void ResolveLayout()
	{
		if (offset != -2)
		{
			return;
		}
		if (!base.HasImage)
		{
			offset = -1;
			return;
		}
		lock (Module.SyncRoot)
		{
			if (offset == -2)
			{
				offset = Module.Read(this, (FieldDefinition field, MetadataReader reader) => reader.ReadFieldLayout(field));
			}
		}
	}

	private void ResolveRVA()
	{
		if (rva != -2 || !base.HasImage)
		{
			return;
		}
		lock (Module.SyncRoot)
		{
			if (rva == -2)
			{
				rva = Module.Read(this, (FieldDefinition field, MetadataReader reader) => reader.ReadFieldRVA(field));
			}
		}
	}

	public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType)
		: base(name, fieldType)
	{
		this.attributes = (ushort)attributes;
	}

	public override FieldDefinition Resolve()
	{
		return this;
	}
}


using System;
using Mono.Cecil;

internal class FieldReference : MemberReference
{
	private TypeReference field_type;

	public TypeReference FieldType
	{
		get
		{
			return field_type;
		}
		set
		{
			field_type = value;
		}
	}

	public override string FullName => field_type.FullName + " " + MemberFullName();

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!field_type.ContainsGenericParameter)
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	internal FieldReference()
	{
		token = new MetadataToken(TokenType.MemberRef);
	}

	public FieldReference(string name, TypeReference fieldType)
		: base(name)
	{
		Mixin.CheckType(fieldType, Mixin.Argument.fieldType);
		field_type = fieldType;
		token = new MetadataToken(TokenType.MemberRef);
	}

	public FieldReference(string name, TypeReference fieldType, TypeReference declaringType)
		: this(name, fieldType)
	{
		Mixin.CheckType(declaringType, Mixin.Argument.declaringType);
		DeclaringType = declaringType;
	}

	protected override IMemberDefinition ResolveDefinition()
	{
		return Resolve();
	}

	public new virtual FieldDefinition Resolve()
	{
		return (Module ?? throw new NotSupportedException()).Resolve(this);
	}
}


internal enum FileAttributes : uint
{
	ContainsMetaData,
	ContainsNoMetaData
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class FunctionPointerType : TypeSpecification, IMethodSignature, IMetadataTokenProvider
{
	private readonly MethodReference function;

	public bool HasThis
	{
		get
		{
			return function.HasThis;
		}
		set
		{
			function.HasThis = value;
		}
	}

	public bool ExplicitThis
	{
		get
		{
			return function.ExplicitThis;
		}
		set
		{
			function.ExplicitThis = value;
		}
	}

	public MethodCallingConvention CallingConvention
	{
		get
		{
			return function.CallingConvention;
		}
		set
		{
			function.CallingConvention = value;
		}
	}

	public bool HasParameters => function.HasParameters;

	public Collection<ParameterDefinition> Parameters => function.Parameters;

	public TypeReference ReturnType
	{
		get
		{
			return function.MethodReturnType.ReturnType;
		}
		set
		{
			function.MethodReturnType.ReturnType = value;
		}
	}

	public MethodReturnType MethodReturnType => function.MethodReturnType;

	public override string Name
	{
		get
		{
			return function.Name;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string Namespace
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override ModuleDefinition Module => ReturnType.Module;

	public override IMetadataScope Scope
	{
		get
		{
			return function.ReturnType.Scope;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsFunctionPointer => true;

	public override bool ContainsGenericParameter => function.ContainsGenericParameter;

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(function.Name);
			stringBuilder.Append(" ");
			stringBuilder.Append(function.ReturnType.FullName);
			stringBuilder.Append(" *");
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public FunctionPointerType()
		: base(null)
	{
		function = new MethodReference();
		function.Name = "method";
		etype = Mono.Cecil.Metadata.ElementType.FnPtr;
	}

	public override TypeDefinition Resolve()
	{
		return null;
	}

	public override TypeReference GetElementType()
	{
		return this;
	}
}


using System.Text;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance, IMetadataTokenProvider, IGenericContext
{
	private Collection<TypeReference> arguments;

	public bool HasGenericArguments => !arguments.IsNullOrEmpty();

	public Collection<TypeReference> GenericArguments
	{
		get
		{
			if (arguments == null)
			{
				Interlocked.CompareExchange(ref arguments, new Collection<TypeReference>(), null);
			}
			return arguments;
		}
	}

	public override bool IsGenericInstance => true;

	IGenericParameterProvider IGenericContext.Method => base.ElementMethod;

	IGenericParameterProvider IGenericContext.Type => base.ElementMethod.DeclaringType;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!this.ContainsGenericParameter())
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			MethodReference elementMethod = base.ElementMethod;
			stringBuilder.Append(elementMethod.ReturnType.FullName).Append(" ").Append(elementMethod.DeclaringType.FullName)
				.Append("::")
				.Append(elementMethod.Name);
			this.GenericInstanceFullName(stringBuilder);
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public GenericInstanceMethod(MethodReference method)
		: base(method)
	{
	}

	internal GenericInstanceMethod(MethodReference method, int arity)
		: this(method)
	{
		arguments = new Collection<TypeReference>(arity);
	}
}


using System;
using System.Text;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class GenericInstanceType : TypeSpecification, IGenericInstance, IMetadataTokenProvider, IGenericContext
{
	private Collection<TypeReference> arguments;

	public bool HasGenericArguments => !arguments.IsNullOrEmpty();

	public Collection<TypeReference> GenericArguments
	{
		get
		{
			if (arguments == null)
			{
				Interlocked.CompareExchange(ref arguments, new Collection<TypeReference>(), null);
			}
			return arguments;
		}
	}

	public override TypeReference DeclaringType
	{
		get
		{
			return base.ElementType.DeclaringType;
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(base.FullName);
			this.GenericInstanceFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public override bool IsGenericInstance => true;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!this.ContainsGenericParameter())
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	IGenericParameterProvider IGenericContext.Type => base.ElementType;

	public GenericInstanceType(TypeReference type)
		: base(type)
	{
		base.IsValueType = type.IsValueType;
		etype = Mono.Cecil.Metadata.ElementType.GenericInst;
	}

	internal GenericInstanceType(TypeReference type, int arity)
		: this(type)
	{
		arguments = new Collection<TypeReference>(arity);
	}
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class GenericParameter : TypeReference, ICustomAttributeProvider, IMetadataTokenProvider
{
	internal int position;

	internal GenericParameterType type;

	internal IGenericParameterProvider owner;

	private ushort attributes;

	private GenericParameterConstraintCollection constraints;

	private Collection<CustomAttribute> custom_attributes;

	public GenericParameterAttributes Attributes
	{
		get
		{
			return (GenericParameterAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public int Position => position;

	public GenericParameterType Type => type;

	public IGenericParameterProvider Owner => owner;

	public bool HasConstraints
	{
		get
		{
			if (constraints != null)
			{
				return constraints.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (GenericParameter generic_parameter, MetadataReader reader) => reader.HasGenericConstraints(generic_parameter));
			}
			return false;
		}
	}

	public Collection<GenericParameterConstraint> Constraints
	{
		get
		{
			if (constraints != null)
			{
				return constraints;
			}
			if (base.HasImage)
			{
				return Module.Read(ref constraints, this, (GenericParameter generic_parameter, MetadataReader reader) => reader.ReadGenericConstraints(generic_parameter));
			}
			Interlocked.CompareExchange(ref constraints, new GenericParameterConstraintCollection(this), null);
			return constraints;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public override IMetadataScope Scope
	{
		get
		{
			if (owner == null)
			{
				return null;
			}
			if (owner.GenericParameterType != GenericParameterType.Method)
			{
				return ((TypeReference)owner).Scope;
			}
			return ((MethodReference)owner).DeclaringType.Scope;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override TypeReference DeclaringType
	{
		get
		{
			return owner as TypeReference;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public MethodReference DeclaringMethod => owner as MethodReference;

	public override ModuleDefinition Module => module ?? owner.Module;

	public override string Name
	{
		get
		{
			if (!string.IsNullOrEmpty(base.Name))
			{
				return base.Name;
			}
			return base.Name = ((type == GenericParameterType.Method) ? "!!" : "!") + position;
		}
	}

	public override string Namespace
	{
		get
		{
			return string.Empty;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string FullName => Name;

	public override bool IsGenericParameter => true;

	public override bool ContainsGenericParameter => true;

	public override MetadataType MetadataType => (MetadataType)etype;

	public bool IsNonVariant
	{
		get
		{
			return attributes.GetMaskedAttributes(3, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(3, 0u, value);
		}
	}

	public bool IsCovariant
	{
		get
		{
			return attributes.GetMaskedAttributes(3, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(3, 1u, value);
		}
	}

	public bool IsContravariant
	{
		get
		{
			return attributes.GetMaskedAttributes(3, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(3, 2u, value);
		}
	}

	public bool HasReferenceTypeConstraint
	{
		get
		{
			return attributes.GetAttributes(4);
		}
		set
		{
			attributes = attributes.SetAttributes(4, value);
		}
	}

	public bool HasNotNullableValueTypeConstraint
	{
		get
		{
			return attributes.GetAttributes(8);
		}
		set
		{
			attributes = attributes.SetAttributes(8, value);
		}
	}

	public bool HasDefaultConstructorConstraint
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public GenericParameter(IGenericParameterProvider owner)
		: this(string.Empty, owner)
	{
	}

	public GenericParameter(string name, IGenericParameterProvider owner)
		: base(string.Empty, name)
	{
		if (owner == null)
		{
			throw new ArgumentNullException();
		}
		position = -1;
		this.owner = owner;
		type = owner.GenericParameterType;
		etype = ConvertGenericParameterType(type);
		token = new MetadataToken(TokenType.GenericParam);
	}

	internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module)
		: base(string.Empty, string.Empty)
	{
		Mixin.CheckModule(module);
		this.position = position;
		this.type = type;
		etype = ConvertGenericParameterType(type);
		base.module = module;
		token = new MetadataToken(TokenType.GenericParam);
	}

	private static ElementType ConvertGenericParameterType(GenericParameterType type)
	{
		return type switch
		{
			GenericParameterType.Type => ElementType.Var, 
			GenericParameterType.Method => ElementType.MVar, 
			_ => throw new ArgumentOutOfRangeException(), 
		};
	}

	public override TypeDefinition Resolve()
	{
		return null;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class GenericParameterCollection : Collection<GenericParameter>
{
	private readonly IGenericParameterProvider owner;

	internal GenericParameterCollection(IGenericParameterProvider owner)
	{
		this.owner = owner;
	}

	internal GenericParameterCollection(IGenericParameterProvider owner, int capacity)
		: base(capacity)
	{
		this.owner = owner;
	}

	protected override void OnAdd(GenericParameter item, int index)
	{
		UpdateGenericParameter(item, index);
	}

	protected override void OnInsert(GenericParameter item, int index)
	{
		UpdateGenericParameter(item, index);
		for (int i = index; i < size; i++)
		{
			items[i].position = i + 1;
		}
	}

	protected override void OnSet(GenericParameter item, int index)
	{
		UpdateGenericParameter(item, index);
	}

	private void UpdateGenericParameter(GenericParameter item, int index)
	{
		item.owner = owner;
		item.position = index;
		item.type = owner.GenericParameterType;
	}

	protected override void OnRemove(GenericParameter item, int index)
	{
		item.owner = null;
		item.position = -1;
		item.type = GenericParameterType.Type;
		for (int i = index + 1; i < size; i++)
		{
			items[i].position = i - 1;
		}
	}
}


using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class GenericParameterConstraint : ICustomAttributeProvider, IMetadataTokenProvider
{
	internal GenericParameter generic_parameter;

	internal MetadataToken token;

	private TypeReference constraint_type;

	private Collection<CustomAttribute> custom_attributes;

	public TypeReference ConstraintType
	{
		get
		{
			return constraint_type;
		}
		set
		{
			constraint_type = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			if (generic_parameter == null)
			{
				return false;
			}
			return this.GetHasCustomAttributes(generic_parameter.Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes
	{
		get
		{
			if (generic_parameter == null)
			{
				if (custom_attributes == null)
				{
					Interlocked.CompareExchange(ref custom_attributes, new Collection<CustomAttribute>(), null);
				}
				return custom_attributes;
			}
			return custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, generic_parameter.Module);
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal GenericParameterConstraint(TypeReference constraintType, MetadataToken token)
	{
		constraint_type = constraintType;
		this.token = token;
	}

	public GenericParameterConstraint(TypeReference constraintType)
	{
		Mixin.CheckType(constraintType, Mixin.Argument.constraintType);
		constraint_type = constraintType;
		token = new MetadataToken(TokenType.GenericParamConstraint);
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal class GenericParameterConstraintCollection : Collection<GenericParameterConstraint>
{
	private readonly GenericParameter generic_parameter;

	internal GenericParameterConstraintCollection(GenericParameter genericParameter)
	{
		generic_parameter = genericParameter;
	}

	internal GenericParameterConstraintCollection(GenericParameter genericParameter, int length)
		: base(length)
	{
		generic_parameter = genericParameter;
	}

	protected override void OnAdd(GenericParameterConstraint item, int index)
	{
		item.generic_parameter = generic_parameter;
	}

	protected override void OnInsert(GenericParameterConstraint item, int index)
	{
		item.generic_parameter = generic_parameter;
	}

	protected override void OnSet(GenericParameterConstraint item, int index)
	{
		item.generic_parameter = generic_parameter;
	}

	protected override void OnRemove(GenericParameterConstraint item, int index)
	{
		item.generic_parameter = null;
	}
}


using System;

[Flags]
internal enum GenericParameterAttributes : ushort
{
	VarianceMask = 3,
	NonVariant = 0,
	Covariant = 1,
	Contravariant = 2,
	SpecialConstraintMask = 0x1C,
	ReferenceTypeConstraint = 4,
	NotNullableValueTypeConstraint = 8,
	DefaultConstructorConstraint = 0x10
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class GenericParameterResolver
{
	internal static TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference)
	{
		if (methodReference.DeclaringType.IsArray && methodReference.Name == "Get")
		{
			return methodReference.ReturnType;
		}
		GenericInstanceMethod genericInstanceMethod = methodReference as GenericInstanceMethod;
		GenericInstanceType genericInstanceType = methodReference.DeclaringType as GenericInstanceType;
		if (genericInstanceMethod == null && genericInstanceType == null)
		{
			return methodReference.ReturnType;
		}
		return ResolveIfNeeded(genericInstanceMethod, genericInstanceType, methodReference.ReturnType);
	}

	internal static TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference)
	{
		return ResolveIfNeeded(null, fieldReference.DeclaringType as GenericInstanceType, fieldReference.FieldType);
	}

	internal static TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter)
	{
		GenericInstanceMethod genericInstanceMethod = method as GenericInstanceMethod;
		GenericInstanceType genericInstanceType = method.DeclaringType as GenericInstanceType;
		if (genericInstanceMethod == null && genericInstanceType == null)
		{
			return parameter.ParameterType;
		}
		return ResolveIfNeeded(genericInstanceMethod, genericInstanceType, parameter.ParameterType);
	}

	internal static TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable)
	{
		GenericInstanceMethod genericInstanceMethod = method as GenericInstanceMethod;
		GenericInstanceType genericInstanceType = method.DeclaringType as GenericInstanceType;
		if (genericInstanceMethod == null && genericInstanceType == null)
		{
			return variable.VariableType;
		}
		return ResolveIfNeeded(genericInstanceMethod, genericInstanceType, variable.VariableType);
	}

	private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType)
	{
		if (parameterType is ByReferenceType byReferenceType)
		{
			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, byReferenceType);
		}
		if (parameterType is ArrayType arrayType)
		{
			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, arrayType);
		}
		if (parameterType is GenericInstanceType genericInstanceType)
		{
			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, genericInstanceType);
		}
		if (parameterType is GenericParameter genericParameterElement)
		{
			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, genericParameterElement);
		}
		if (parameterType is RequiredModifierType requiredModifierType && ContainsGenericParameters(requiredModifierType))
		{
			return ResolveIfNeeded(genericInstanceMethod, declaringGenericInstanceType, requiredModifierType.ElementType);
		}
		if (ContainsGenericParameters(parameterType))
		{
			throw new Exception("Unexpected generic parameter.");
		}
		return parameterType;
	}

	private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement)
	{
		if (genericParameterElement.MetadataType != MetadataType.MVar)
		{
			return genericInstanceType.GenericArguments[genericParameterElement.Position];
		}
		if (genericInstanceMethod == null)
		{
			return genericParameterElement;
		}
		return genericInstanceMethod.GenericArguments[genericParameterElement.Position];
	}

	private static ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType)
	{
		return new ArrayType(ResolveIfNeeded(genericInstanceMethod, genericInstanceType, arrayType.ElementType), arrayType.Rank);
	}

	private static ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType)
	{
		return new ByReferenceType(ResolveIfNeeded(genericInstanceMethod, genericInstanceType, byReferenceType.ElementType));
	}

	private static GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1)
	{
		if (!ContainsGenericParameters(genericInstanceType1))
		{
			return genericInstanceType1;
		}
		GenericInstanceType genericInstanceType2 = new GenericInstanceType(genericInstanceType1.ElementType);
		foreach (TypeReference genericArgument in genericInstanceType1.GenericArguments)
		{
			if (!genericArgument.IsGenericParameter)
			{
				genericInstanceType2.GenericArguments.Add(ResolveIfNeeded(genericInstanceMethod, genericInstanceType, genericArgument));
				continue;
			}
			GenericParameter genericParameter = (GenericParameter)genericArgument;
			switch (genericParameter.Type)
			{
			case GenericParameterType.Type:
				if (genericInstanceType == null)
				{
					throw new NotSupportedException();
				}
				genericInstanceType2.GenericArguments.Add(genericInstanceType.GenericArguments[genericParameter.Position]);
				break;
			case GenericParameterType.Method:
				if (genericInstanceMethod == null)
				{
					genericInstanceType2.GenericArguments.Add(genericParameter);
				}
				else
				{
					genericInstanceType2.GenericArguments.Add(genericInstanceMethod.GenericArguments[genericParameter.Position]);
				}
				break;
			}
		}
		return genericInstanceType2;
	}

	private static bool ContainsGenericParameters(TypeReference typeReference)
	{
		if (typeReference is GenericParameter)
		{
			return true;
		}
		if (typeReference is ArrayType arrayType)
		{
			return ContainsGenericParameters(arrayType.ElementType);
		}
		if (typeReference is PointerType pointerType)
		{
			return ContainsGenericParameters(pointerType.ElementType);
		}
		if (typeReference is ByReferenceType byReferenceType)
		{
			return ContainsGenericParameters(byReferenceType.ElementType);
		}
		if (typeReference is SentinelType sentinelType)
		{
			return ContainsGenericParameters(sentinelType.ElementType);
		}
		if (typeReference is PinnedType pinnedType)
		{
			return ContainsGenericParameters(pinnedType.ElementType);
		}
		if (typeReference is RequiredModifierType requiredModifierType)
		{
			return ContainsGenericParameters(requiredModifierType.ElementType);
		}
		if (typeReference is GenericInstanceType genericInstanceType)
		{
			foreach (TypeReference genericArgument in genericInstanceType.GenericArguments)
			{
				if (ContainsGenericParameters(genericArgument))
				{
					return true;
				}
			}
			return false;
		}
		if (typeReference is TypeSpecification)
		{
			throw new NotSupportedException();
		}
		return false;
	}
}


using Mono.Cecil;

internal interface IConstantProvider : IMetadataTokenProvider
{
	bool HasConstant { get; set; }

	object Constant { get; set; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal interface ICustomAttributeProvider : IMetadataTokenProvider
{
	Collection<CustomAttribute> CustomAttributes { get; }

	bool HasCustomAttributes { get; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal interface IGenericInstance : IMetadataTokenProvider
{
	bool HasGenericArguments { get; }

	Collection<TypeReference> GenericArguments { get; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal interface IGenericParameterProvider : IMetadataTokenProvider
{
	bool HasGenericParameters { get; }

	bool IsDefinition { get; }

	ModuleDefinition Module { get; }

	Collection<GenericParameter> GenericParameters { get; }

	GenericParameterType GenericParameterType { get; }
}


internal enum GenericParameterType
{
	Type,
	Method
}


using Mono.Cecil;

internal interface IGenericContext
{
	bool IsDefinition { get; }

	IGenericParameterProvider Type { get; }

	IGenericParameterProvider Method { get; }
}


using Mono.Cecil;

internal interface IMarshalInfoProvider : IMetadataTokenProvider
{
	bool HasMarshalInfo { get; }

	MarshalInfo MarshalInfo { get; set; }
}


using Mono.Cecil;

internal interface IMemberDefinition : ICustomAttributeProvider, IMetadataTokenProvider
{
	string Name { get; set; }

	string FullName { get; }

	bool IsSpecialName { get; set; }

	bool IsRuntimeSpecialName { get; set; }

	TypeDefinition DeclaringType { get; set; }
}


internal enum MetadataScopeType
{
	AssemblyNameReference,
	ModuleReference,
	ModuleDefinition
}


using Mono.Cecil;

internal interface IMetadataScope : IMetadataTokenProvider
{
	MetadataScopeType MetadataScopeType { get; }

	string Name { get; set; }
}


using Mono.Cecil;

internal interface IMetadataTokenProvider
{
	MetadataToken MetadataToken { get; set; }
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal interface IMethodSignature : IMetadataTokenProvider
{
	bool HasThis { get; set; }

	bool ExplicitThis { get; set; }

	MethodCallingConvention CallingConvention { get; set; }

	bool HasParameters { get; }

	Collection<ParameterDefinition> Parameters { get; }

	TypeReference ReturnType { get; set; }

	MethodReturnType MethodReturnType { get; }
}


using Mono.Cecil;

internal interface IMetadataImporterProvider
{
	IMetadataImporter GetMetadataImporter(ModuleDefinition module);
}


using Mono.Cecil;

internal interface IMetadataImporter
{
	AssemblyNameReference ImportReference(AssemblyNameReference reference);

	TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);

	FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);

	MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}


using Mono.Cecil;

internal interface IReflectionImporterProvider
{
	IReflectionImporter GetReflectionImporter(ModuleDefinition module);
}


using System;
using System.Reflection;
using Mono.Cecil;

internal interface IReflectionImporter
{
	AssemblyNameReference ImportReference(AssemblyName reference);

	TypeReference ImportReference(Type type, IGenericParameterProvider context);

	FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);

	MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

internal struct ImportGenericContext
{
	private Collection<IGenericParameterProvider> stack;

	public bool IsEmpty => stack == null;

	public ImportGenericContext(IGenericParameterProvider provider)
	{
		if (provider == null)
		{
			throw new ArgumentNullException("provider");
		}
		stack = null;
		Push(provider);
	}

	public void Push(IGenericParameterProvider provider)
	{
		if (stack == null)
		{
			stack = new Collection<IGenericParameterProvider>(1) { provider };
		}
		else
		{
			stack.Add(provider);
		}
	}

	public void Pop()
	{
		stack.RemoveAt(stack.Count - 1);
	}

	public TypeReference MethodParameter(string method, int position)
	{
		for (int num = stack.Count - 1; num >= 0; num--)
		{
			if (stack[num] is MethodReference methodReference && !(method != NormalizeMethodName(methodReference)))
			{
				return methodReference.GenericParameters[position];
			}
		}
		throw new InvalidOperationException();
	}

	public string NormalizeMethodName(MethodReference method)
	{
		return method.DeclaringType.GetElementType().FullName + "." + method.Name;
	}

	public TypeReference TypeParameter(string type, int position)
	{
		for (int num = stack.Count - 1; num >= 0; num--)
		{
			TypeReference typeReference = GenericTypeFor(stack[num]);
			if (!(typeReference.FullName != type))
			{
				return typeReference.GenericParameters[position];
			}
		}
		throw new InvalidOperationException();
	}

	private static TypeReference GenericTypeFor(IGenericParameterProvider context)
	{
		if (context is TypeReference typeReference)
		{
			return typeReference.GetElementType();
		}
		if (context is MethodReference methodReference)
		{
			return methodReference.DeclaringType.GetElementType();
		}
		throw new InvalidOperationException();
	}

	public static ImportGenericContext For(IGenericParameterProvider context)
	{
		if (context == null)
		{
			return default(ImportGenericContext);
		}
		return new ImportGenericContext(context);
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal class DefaultReflectionImporter : IReflectionImporter
{
	private enum ImportGenericKind
	{
		Definition,
		Open
	}

	protected readonly ModuleDefinition module;

	private static readonly Dictionary<Type, ElementType> type_etype_mapping = new Dictionary<Type, ElementType>(18)
	{
		{
			typeof(void),
			ElementType.Void
		},
		{
			typeof(bool),
			ElementType.Boolean
		},
		{
			typeof(char),
			ElementType.Char
		},
		{
			typeof(sbyte),
			ElementType.I1
		},
		{
			typeof(byte),
			ElementType.U1
		},
		{
			typeof(short),
			ElementType.I2
		},
		{
			typeof(ushort),
			ElementType.U2
		},
		{
			typeof(int),
			ElementType.I4
		},
		{
			typeof(uint),
			ElementType.U4
		},
		{
			typeof(long),
			ElementType.I8
		},
		{
			typeof(ulong),
			ElementType.U8
		},
		{
			typeof(float),
			ElementType.R4
		},
		{
			typeof(double),
			ElementType.R8
		},
		{
			typeof(string),
			ElementType.String
		},
		{
			typeof(TypedReference),
			ElementType.TypedByRef
		},
		{
			typeof(IntPtr),
			ElementType.I
		},
		{
			typeof(UIntPtr),
			ElementType.U
		},
		{
			typeof(object),
			ElementType.Object
		}
	};

	public DefaultReflectionImporter(ModuleDefinition module)
	{
		Mixin.CheckModule(module);
		this.module = module;
	}

	private TypeReference ImportType(Type type, ImportGenericContext context)
	{
		return ImportType(type, context, ImportGenericKind.Open);
	}

	private TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind)
	{
		if (IsTypeSpecification(type) || ImportOpenGenericType(type, import_kind))
		{
			return ImportTypeSpecification(type, context);
		}
		TypeReference typeReference = new TypeReference(string.Empty, type.Name, module, ImportScope(type), type.IsValueType);
		typeReference.etype = ImportElementType(type);
		if (IsNestedType(type))
		{
			typeReference.DeclaringType = ImportType(type.DeclaringType, context, import_kind);
		}
		else
		{
			typeReference.Namespace = type.Namespace ?? string.Empty;
		}
		if (type.IsGenericType)
		{
			ImportGenericParameters(typeReference, type.GetGenericArguments());
		}
		return typeReference;
	}

	protected virtual IMetadataScope ImportScope(Type type)
	{
		return ImportScope(type.Assembly);
	}

	private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind)
	{
		if (type.IsGenericType && type.IsGenericTypeDefinition)
		{
			return import_kind == ImportGenericKind.Open;
		}
		return false;
	}

	private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind)
	{
		if (method.IsGenericMethod && method.IsGenericMethodDefinition)
		{
			return import_kind == ImportGenericKind.Open;
		}
		return false;
	}

	private static bool IsNestedType(Type type)
	{
		return type.IsNested;
	}

	private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context)
	{
		if (type.IsByRef)
		{
			return new ByReferenceType(ImportType(type.GetElementType(), context));
		}
		if (type.IsPointer)
		{
			return new PointerType(ImportType(type.GetElementType(), context));
		}
		if (type.IsArray)
		{
			return new ArrayType(ImportType(type.GetElementType(), context), type.GetArrayRank());
		}
		if (type.IsGenericType)
		{
			return ImportGenericInstance(type, context);
		}
		if (type.IsGenericParameter)
		{
			return ImportGenericParameter(type, context);
		}
		throw new NotSupportedException(type.FullName);
	}

	private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context)
	{
		if (context.IsEmpty)
		{
			throw new InvalidOperationException();
		}
		if (type.DeclaringMethod != null)
		{
			return context.MethodParameter(NormalizeMethodName(type.DeclaringMethod), type.GenericParameterPosition);
		}
		if (type.DeclaringType != null)
		{
			return context.TypeParameter(NormalizeTypeFullName(type.DeclaringType), type.GenericParameterPosition);
		}
		throw new InvalidOperationException();
	}

	private static string NormalizeMethodName(MethodBase method)
	{
		return NormalizeTypeFullName(method.DeclaringType) + "." + method.Name;
	}

	private static string NormalizeTypeFullName(Type type)
	{
		if (IsNestedType(type))
		{
			return NormalizeTypeFullName(type.DeclaringType) + "/" + type.Name;
		}
		return type.FullName;
	}

	private TypeReference ImportGenericInstance(Type type, ImportGenericContext context)
	{
		TypeReference typeReference = ImportType(type.GetGenericTypeDefinition(), context, ImportGenericKind.Definition);
		Type[] genericArguments = type.GetGenericArguments();
		GenericInstanceType genericInstanceType = new GenericInstanceType(typeReference, genericArguments.Length);
		Collection<TypeReference> genericArguments2 = genericInstanceType.GenericArguments;
		context.Push(typeReference);
		try
		{
			for (int i = 0; i < genericArguments.Length; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceType;
		}
		finally
		{
			context.Pop();
		}
	}

	private static bool IsTypeSpecification(Type type)
	{
		if (!type.HasElementType && !IsGenericInstance(type))
		{
			return type.IsGenericParameter;
		}
		return true;
	}

	private static bool IsGenericInstance(Type type)
	{
		if (type.IsGenericType)
		{
			return !type.IsGenericTypeDefinition;
		}
		return false;
	}

	private static ElementType ImportElementType(Type type)
	{
		if (!type_etype_mapping.TryGetValue(type, out var value))
		{
			return ElementType.None;
		}
		return value;
	}

	protected AssemblyNameReference ImportScope(Assembly assembly)
	{
		return ImportReference(assembly.GetName());
	}

	public virtual AssemblyNameReference ImportReference(AssemblyName name)
	{
		Mixin.CheckName(name);
		if (TryGetAssemblyNameReference(name, out var assembly_reference))
		{
			return assembly_reference;
		}
		assembly_reference = new AssemblyNameReference(name.Name, name.Version)
		{
			PublicKeyToken = name.GetPublicKeyToken(),
			Culture = name.CultureInfo.Name,
			HashAlgorithm = (AssemblyHashAlgorithm)name.HashAlgorithm
		};
		module.AssemblyReferences.Add(assembly_reference);
		return assembly_reference;
	}

	private bool TryGetAssemblyNameReference(AssemblyName name, out AssemblyNameReference assembly_reference)
	{
		Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
		for (int i = 0; i < assemblyReferences.Count; i++)
		{
			AssemblyNameReference assemblyNameReference = assemblyReferences[i];
			if (!(name.FullName != assemblyNameReference.FullName))
			{
				assembly_reference = assemblyNameReference;
				return true;
			}
		}
		assembly_reference = null;
		return false;
	}

	private FieldReference ImportField(FieldInfo field, ImportGenericContext context)
	{
		TypeReference typeReference = ImportType(field.DeclaringType, context);
		if (IsGenericInstance(field.DeclaringType))
		{
			field = ResolveFieldDefinition(field);
		}
		context.Push(typeReference);
		try
		{
			return new FieldReference
			{
				Name = field.Name,
				DeclaringType = typeReference,
				FieldType = ImportType(field.FieldType, context)
			};
		}
		finally
		{
			context.Pop();
		}
	}

	private static FieldInfo ResolveFieldDefinition(FieldInfo field)
	{
		return field.Module.ResolveField(field.MetadataToken);
	}

	private static MethodBase ResolveMethodDefinition(MethodBase method)
	{
		return method.Module.ResolveMethod(method.MetadataToken);
	}

	private MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
	{
		if (IsMethodSpecification(method) || ImportOpenGenericMethod(method, import_kind))
		{
			return ImportMethodSpecification(method, context);
		}
		TypeReference declaringType = ImportType(method.DeclaringType, context);
		if (IsGenericInstance(method.DeclaringType))
		{
			method = ResolveMethodDefinition(method);
		}
		MethodReference methodReference = new MethodReference
		{
			Name = method.Name,
			HasThis = HasCallingConvention(method, CallingConventions.HasThis),
			ExplicitThis = HasCallingConvention(method, CallingConventions.ExplicitThis),
			DeclaringType = ImportType(method.DeclaringType, context, ImportGenericKind.Definition)
		};
		if (HasCallingConvention(method, CallingConventions.VarArgs))
		{
			methodReference.CallingConvention &= MethodCallingConvention.VarArg;
		}
		if (method.IsGenericMethod)
		{
			ImportGenericParameters(methodReference, method.GetGenericArguments());
		}
		context.Push(methodReference);
		try
		{
			MethodInfo methodInfo = method as MethodInfo;
			methodReference.ReturnType = ((methodInfo != null) ? ImportType(methodInfo.ReturnType, context) : ImportType(typeof(void), default(ImportGenericContext)));
			ParameterInfo[] parameters = method.GetParameters();
			Collection<ParameterDefinition> parameters2 = methodReference.Parameters;
			for (int i = 0; i < parameters.Length; i++)
			{
				parameters2.Add(new ParameterDefinition(ImportType(parameters[i].ParameterType, context)));
			}
			methodReference.DeclaringType = declaringType;
			return methodReference;
		}
		finally
		{
			context.Pop();
		}
	}

	private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments)
	{
		Collection<GenericParameter> genericParameters = provider.GenericParameters;
		for (int i = 0; i < arguments.Length; i++)
		{
			genericParameters.Add(new GenericParameter(arguments[i].Name, provider));
		}
	}

	private static bool IsMethodSpecification(MethodBase method)
	{
		if (method.IsGenericMethod)
		{
			return !method.IsGenericMethodDefinition;
		}
		return false;
	}

	private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context)
	{
		MethodInfo methodInfo = method as MethodInfo;
		if (methodInfo == null)
		{
			throw new InvalidOperationException();
		}
		MethodReference methodReference = ImportMethod(methodInfo.GetGenericMethodDefinition(), context, ImportGenericKind.Definition);
		GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(methodReference);
		Type[] genericArguments = method.GetGenericArguments();
		Collection<TypeReference> genericArguments2 = genericInstanceMethod.GenericArguments;
		context.Push(methodReference);
		try
		{
			for (int i = 0; i < genericArguments.Length; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceMethod;
		}
		finally
		{
			context.Pop();
		}
	}

	private static bool HasCallingConvention(MethodBase method, CallingConventions conventions)
	{
		return (method.CallingConvention & conventions) != 0;
	}

	public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context)
	{
		Mixin.CheckType(type);
		return ImportType(type, ImportGenericContext.For(context), (context != null) ? ImportGenericKind.Open : ImportGenericKind.Definition);
	}

	public virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
	{
		Mixin.CheckField(field);
		return ImportField(field, ImportGenericContext.For(context));
	}

	public virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
	{
		Mixin.CheckMethod(method);
		return ImportMethod(method, ImportGenericContext.For(context), (context != null) ? ImportGenericKind.Open : ImportGenericKind.Definition);
	}
}


private enum ImportGenericKind
{
	Definition,
	Open
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal class DefaultMetadataImporter : IMetadataImporter
{
	protected readonly ModuleDefinition module;

	public DefaultMetadataImporter(ModuleDefinition module)
	{
		Mixin.CheckModule(module);
		this.module = module;
	}

	private TypeReference ImportType(TypeReference type, ImportGenericContext context)
	{
		if (type.IsTypeSpecification())
		{
			return ImportTypeSpecification(type, context);
		}
		TypeReference typeReference = new TypeReference(type.Namespace, type.Name, module, ImportScope(type), type.IsValueType);
		MetadataSystem.TryProcessPrimitiveTypeReference(typeReference);
		if (type.IsNested)
		{
			typeReference.DeclaringType = ImportType(type.DeclaringType, context);
		}
		if (type.HasGenericParameters)
		{
			ImportGenericParameters(typeReference, type);
		}
		return typeReference;
	}

	protected virtual IMetadataScope ImportScope(TypeReference type)
	{
		return ImportScope(type.Scope);
	}

	protected IMetadataScope ImportScope(IMetadataScope scope)
	{
		switch (scope.MetadataScopeType)
		{
		case MetadataScopeType.AssemblyNameReference:
			return ImportReference((AssemblyNameReference)scope);
		case MetadataScopeType.ModuleDefinition:
			if (scope == module)
			{
				return scope;
			}
			return ImportReference(((ModuleDefinition)scope).Assembly.Name);
		case MetadataScopeType.ModuleReference:
			throw new NotImplementedException();
		default:
			throw new NotSupportedException();
		}
	}

	public virtual AssemblyNameReference ImportReference(AssemblyNameReference name)
	{
		Mixin.CheckName(name);
		if (module.TryGetAssemblyNameReference(name, out var assembly_reference))
		{
			return assembly_reference;
		}
		assembly_reference = new AssemblyNameReference(name.Name, name.Version)
		{
			Culture = name.Culture,
			HashAlgorithm = name.HashAlgorithm,
			IsRetargetable = name.IsRetargetable,
			IsWindowsRuntime = name.IsWindowsRuntime
		};
		byte[] array = ((!name.PublicKeyToken.IsNullOrEmpty()) ? new byte[name.PublicKeyToken.Length] : Empty<byte>.Array);
		if (array.Length != 0)
		{
			Buffer.BlockCopy(name.PublicKeyToken, 0, array, 0, array.Length);
		}
		assembly_reference.PublicKeyToken = array;
		module.AssemblyReferences.Add(assembly_reference);
		return assembly_reference;
	}

	private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original)
	{
		Collection<GenericParameter> genericParameters = original.GenericParameters;
		Collection<GenericParameter> genericParameters2 = imported.GenericParameters;
		for (int i = 0; i < genericParameters.Count; i++)
		{
			genericParameters2.Add(new GenericParameter(genericParameters[i].Name, imported));
		}
	}

	private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context)
	{
		switch (type.etype)
		{
		case ElementType.SzArray:
		{
			ArrayType arrayType = (ArrayType)type;
			return new ArrayType(ImportType(arrayType.ElementType, context));
		}
		case ElementType.Ptr:
		{
			PointerType pointerType = (PointerType)type;
			return new PointerType(ImportType(pointerType.ElementType, context));
		}
		case ElementType.ByRef:
		{
			ByReferenceType byReferenceType = (ByReferenceType)type;
			return new ByReferenceType(ImportType(byReferenceType.ElementType, context));
		}
		case ElementType.Pinned:
		{
			PinnedType pinnedType = (PinnedType)type;
			return new PinnedType(ImportType(pinnedType.ElementType, context));
		}
		case ElementType.Sentinel:
		{
			SentinelType sentinelType = (SentinelType)type;
			return new SentinelType(ImportType(sentinelType.ElementType, context));
		}
		case ElementType.FnPtr:
		{
			FunctionPointerType functionPointerType = (FunctionPointerType)type;
			FunctionPointerType functionPointerType2 = new FunctionPointerType
			{
				HasThis = functionPointerType.HasThis,
				ExplicitThis = functionPointerType.ExplicitThis,
				CallingConvention = functionPointerType.CallingConvention,
				ReturnType = ImportType(functionPointerType.ReturnType, context)
			};
			if (!functionPointerType.HasParameters)
			{
				return functionPointerType2;
			}
			for (int j = 0; j < functionPointerType.Parameters.Count; j++)
			{
				functionPointerType2.Parameters.Add(new ParameterDefinition(ImportType(functionPointerType.Parameters[j].ParameterType, context)));
			}
			return functionPointerType2;
		}
		case ElementType.CModOpt:
		{
			OptionalModifierType optionalModifierType = (OptionalModifierType)type;
			return new OptionalModifierType(ImportType(optionalModifierType.ModifierType, context), ImportType(optionalModifierType.ElementType, context));
		}
		case ElementType.CModReqD:
		{
			RequiredModifierType requiredModifierType = (RequiredModifierType)type;
			return new RequiredModifierType(ImportType(requiredModifierType.ModifierType, context), ImportType(requiredModifierType.ElementType, context));
		}
		case ElementType.Array:
		{
			ArrayType arrayType2 = (ArrayType)type;
			ArrayType arrayType3 = new ArrayType(ImportType(arrayType2.ElementType, context));
			if (arrayType2.IsVector)
			{
				return arrayType3;
			}
			Collection<ArrayDimension> dimensions = arrayType2.Dimensions;
			Collection<ArrayDimension> dimensions2 = arrayType3.Dimensions;
			dimensions2.Clear();
			for (int k = 0; k < dimensions.Count; k++)
			{
				ArrayDimension arrayDimension = dimensions[k];
				dimensions2.Add(new ArrayDimension(arrayDimension.LowerBound, arrayDimension.UpperBound));
			}
			return arrayType3;
		}
		case ElementType.GenericInst:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)type;
			TypeReference type2 = ImportType(genericInstanceType.ElementType, context);
			Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
			GenericInstanceType genericInstanceType2 = new GenericInstanceType(type2, genericArguments.Count);
			Collection<TypeReference> genericArguments2 = genericInstanceType2.GenericArguments;
			for (int i = 0; i < genericArguments.Count; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceType2;
		}
		case ElementType.Var:
		{
			GenericParameter genericParameter2 = (GenericParameter)type;
			if (genericParameter2.DeclaringType == null)
			{
				throw new InvalidOperationException();
			}
			return context.TypeParameter(genericParameter2.DeclaringType.FullName, genericParameter2.Position);
		}
		case ElementType.MVar:
		{
			GenericParameter genericParameter = (GenericParameter)type;
			if (genericParameter.DeclaringMethod == null)
			{
				throw new InvalidOperationException();
			}
			return context.MethodParameter(context.NormalizeMethodName(genericParameter.DeclaringMethod), genericParameter.Position);
		}
		default:
			throw new NotSupportedException(type.etype.ToString());
		}
	}

	private FieldReference ImportField(FieldReference field, ImportGenericContext context)
	{
		TypeReference typeReference = ImportType(field.DeclaringType, context);
		context.Push(typeReference);
		try
		{
			return new FieldReference
			{
				Name = field.Name,
				DeclaringType = typeReference,
				FieldType = ImportType(field.FieldType, context)
			};
		}
		finally
		{
			context.Pop();
		}
	}

	private MethodReference ImportMethod(MethodReference method, ImportGenericContext context)
	{
		if (method.IsGenericInstance)
		{
			return ImportMethodSpecification(method, context);
		}
		TypeReference declaringType = ImportType(method.DeclaringType, context);
		MethodReference methodReference = new MethodReference
		{
			Name = method.Name,
			HasThis = method.HasThis,
			ExplicitThis = method.ExplicitThis,
			DeclaringType = declaringType,
			CallingConvention = method.CallingConvention
		};
		if (method.HasGenericParameters)
		{
			ImportGenericParameters(methodReference, method);
		}
		context.Push(methodReference);
		try
		{
			methodReference.ReturnType = ImportType(method.ReturnType, context);
			if (!method.HasParameters)
			{
				return methodReference;
			}
			Collection<ParameterDefinition> parameters = method.Parameters;
			ParameterDefinitionCollection parameterDefinitionCollection = (methodReference.parameters = new ParameterDefinitionCollection(methodReference, parameters.Count));
			for (int i = 0; i < parameters.Count; i++)
			{
				parameterDefinitionCollection.Add(new ParameterDefinition(ImportType(parameters[i].ParameterType, context)));
			}
			return methodReference;
		}
		finally
		{
			context.Pop();
		}
	}

	private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context)
	{
		if (!method.IsGenericInstance)
		{
			throw new NotSupportedException();
		}
		GenericInstanceMethod genericInstanceMethod = (GenericInstanceMethod)method;
		GenericInstanceMethod genericInstanceMethod2 = new GenericInstanceMethod(ImportMethod(genericInstanceMethod.ElementMethod, context));
		Collection<TypeReference> genericArguments = genericInstanceMethod.GenericArguments;
		Collection<TypeReference> genericArguments2 = genericInstanceMethod2.GenericArguments;
		for (int i = 0; i < genericArguments.Count; i++)
		{
			genericArguments2.Add(ImportType(genericArguments[i], context));
		}
		return genericInstanceMethod2;
	}

	public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
	{
		Mixin.CheckType(type);
		return ImportType(type, ImportGenericContext.For(context));
	}

	public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
	{
		Mixin.CheckField(field);
		return ImportField(field, ImportGenericContext.For(context));
	}

	public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
	{
		Mixin.CheckMethod(method);
		return ImportMethod(method, ImportGenericContext.For(context));
	}
}


using Mono.Cecil;

internal sealed class LinkedResource : Resource
{
	internal byte[] hash;

	private string file;

	public byte[] Hash => hash;

	public string File
	{
		get
		{
			return file;
		}
		set
		{
			file = value;
		}
	}

	public override ResourceType ResourceType => ResourceType.Linked;

	public LinkedResource(string name, ManifestResourceAttributes flags)
		: base(name, flags)
	{
	}

	public LinkedResource(string name, ManifestResourceAttributes flags, string file)
		: base(name, flags)
	{
		this.file = file;
	}
}


using System;

[Flags]
internal enum ManifestResourceAttributes : uint
{
	VisibilityMask = 7u,
	Public = 1u,
	Private = 2u
}


using Mono.Cecil;

internal class MarshalInfo
{
	internal NativeType native;

	public NativeType NativeType
	{
		get
		{
			return native;
		}
		set
		{
			native = value;
		}
	}

	public MarshalInfo(NativeType native)
	{
		this.native = native;
	}
}


using Mono.Cecil;

internal sealed class ArrayMarshalInfo : MarshalInfo
{
	internal NativeType element_type;

	internal int size_parameter_index;

	internal int size;

	internal int size_parameter_multiplier;

	public NativeType ElementType
	{
		get
		{
			return element_type;
		}
		set
		{
			element_type = value;
		}
	}

	public int SizeParameterIndex
	{
		get
		{
			return size_parameter_index;
		}
		set
		{
			size_parameter_index = value;
		}
	}

	public int Size
	{
		get
		{
			return size;
		}
		set
		{
			size = value;
		}
	}

	public int SizeParameterMultiplier
	{
		get
		{
			return size_parameter_multiplier;
		}
		set
		{
			size_parameter_multiplier = value;
		}
	}

	public ArrayMarshalInfo()
		: base(NativeType.Array)
	{
		element_type = NativeType.None;
		size_parameter_index = -1;
		size = -1;
		size_parameter_multiplier = -1;
	}
}


using System;
using Mono.Cecil;

internal sealed class CustomMarshalInfo : MarshalInfo
{
	internal Guid guid;

	internal string unmanaged_type;

	internal TypeReference managed_type;

	internal string cookie;

	public Guid Guid
	{
		get
		{
			return guid;
		}
		set
		{
			guid = value;
		}
	}

	public string UnmanagedType
	{
		get
		{
			return unmanaged_type;
		}
		set
		{
			unmanaged_type = value;
		}
	}

	public TypeReference ManagedType
	{
		get
		{
			return managed_type;
		}
		set
		{
			managed_type = value;
		}
	}

	public string Cookie
	{
		get
		{
			return cookie;
		}
		set
		{
			cookie = value;
		}
	}

	public CustomMarshalInfo()
		: base(NativeType.CustomMarshaler)
	{
	}
}


using Mono.Cecil;

internal sealed class SafeArrayMarshalInfo : MarshalInfo
{
	internal VariantType element_type;

	public VariantType ElementType
	{
		get
		{
			return element_type;
		}
		set
		{
			element_type = value;
		}
	}

	public SafeArrayMarshalInfo()
		: base(NativeType.SafeArray)
	{
		element_type = VariantType.None;
	}
}


using Mono.Cecil;

internal sealed class FixedArrayMarshalInfo : MarshalInfo
{
	internal NativeType element_type;

	internal int size;

	public NativeType ElementType
	{
		get
		{
			return element_type;
		}
		set
		{
			element_type = value;
		}
	}

	public int Size
	{
		get
		{
			return size;
		}
		set
		{
			size = value;
		}
	}

	public FixedArrayMarshalInfo()
		: base(NativeType.FixedArray)
	{
		element_type = NativeType.None;
	}
}


using Mono.Cecil;

internal sealed class FixedSysStringMarshalInfo : MarshalInfo
{
	internal int size;

	public int Size
	{
		get
		{
			return size;
		}
		set
		{
			size = value;
		}
	}

	public FixedSysStringMarshalInfo()
		: base(NativeType.FixedSysString)
	{
		size = -1;
	}
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class MemberDefinitionCollection<T> : Collection<T> where T : IMemberDefinition
{
	private TypeDefinition container;

	internal MemberDefinitionCollection(TypeDefinition container)
	{
		this.container = container;
	}

	internal MemberDefinitionCollection(TypeDefinition container, int capacity)
		: base(capacity)
	{
		this.container = container;
	}

	protected override void OnAdd(T item, int index)
	{
		Attach(item);
	}

	protected sealed override void OnSet(T item, int index)
	{
		Attach(item);
	}

	protected sealed override void OnInsert(T item, int index)
	{
		Attach(item);
	}

	protected sealed override void OnRemove(T item, int index)
	{
		Detach(item);
	}

	protected sealed override void OnClear()
	{
		using Enumerator enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			Detach(enumerator.Current);
		}
	}

	private void Attach(T element)
	{
		if (element.DeclaringType != container)
		{
			if (element.DeclaringType != null)
			{
				throw new ArgumentException("Member already attached");
			}
			element.DeclaringType = container;
		}
	}

	private static void Detach(T element)
	{
		element.DeclaringType = null;
	}
}


using System;
using Mono.Cecil;

internal abstract class MemberReference : IMetadataTokenProvider
{
	private string name;

	private TypeReference declaring_type;

	internal MetadataToken token;

	internal object projection;

	public virtual string Name
	{
		get
		{
			return name;
		}
		set
		{
			if (IsWindowsRuntimeProjection && value != name)
			{
				throw new InvalidOperationException();
			}
			name = value;
		}
	}

	public abstract string FullName { get; }

	public virtual TypeReference DeclaringType
	{
		get
		{
			return declaring_type;
		}
		set
		{
			declaring_type = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	public bool IsWindowsRuntimeProjection => projection != null;

	internal bool HasImage => Module?.HasImage ?? false;

	public virtual ModuleDefinition Module
	{
		get
		{
			if (declaring_type == null)
			{
				return null;
			}
			return declaring_type.Module;
		}
	}

	public virtual bool IsDefinition => false;

	public virtual bool ContainsGenericParameter
	{
		get
		{
			if (declaring_type != null)
			{
				return declaring_type.ContainsGenericParameter;
			}
			return false;
		}
	}

	internal MemberReference()
	{
	}

	internal MemberReference(string name)
	{
		this.name = name ?? string.Empty;
	}

	internal string MemberFullName()
	{
		if (declaring_type == null)
		{
			return name;
		}
		return declaring_type.FullName + "::" + name;
	}

	public IMemberDefinition Resolve()
	{
		return ResolveDefinition();
	}

	protected abstract IMemberDefinition ResolveDefinition();

	public override string ToString()
	{
		return FullName;
	}
}


using System;
using Mono.Cecil;

internal interface IAssemblyResolver : IDisposable
{
	AssemblyDefinition Resolve(AssemblyNameReference name);

	AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
}


using Mono.Cecil;

internal interface IMetadataResolver
{
	TypeDefinition Resolve(TypeReference type);

	FieldDefinition Resolve(FieldReference field);

	MethodDefinition Resolve(MethodReference method);
}


using System;
using System.Runtime.Serialization;
using Mono.Cecil;

[Serializable]
internal sealed class ResolutionException : Exception
{
	private readonly MemberReference member;

	public MemberReference Member => member;

	public IMetadataScope Scope
	{
		get
		{
			if (member is TypeReference typeReference)
			{
				return typeReference.Scope;
			}
			TypeReference declaringType = member.DeclaringType;
			if (declaringType != null)
			{
				return declaringType.Scope;
			}
			throw new NotSupportedException();
		}
	}

	public ResolutionException(MemberReference member)
		: base("Failed to resolve " + member.FullName)
	{
		if (member == null)
		{
			throw new ArgumentNullException("member");
		}
		this.member = member;
	}

	public ResolutionException(MemberReference member, Exception innerException)
		: base("Failed to resolve " + member.FullName, innerException)
	{
		if (member == null)
		{
			throw new ArgumentNullException("member");
		}
		this.member = member;
	}

	private ResolutionException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

internal class MetadataResolver : IMetadataResolver
{
	private readonly IAssemblyResolver assembly_resolver;

	public IAssemblyResolver AssemblyResolver => assembly_resolver;

	public MetadataResolver(IAssemblyResolver assemblyResolver)
	{
		if (assemblyResolver == null)
		{
			throw new ArgumentNullException("assemblyResolver");
		}
		assembly_resolver = assemblyResolver;
	}

	public virtual TypeDefinition Resolve(TypeReference type)
	{
		Mixin.CheckType(type);
		type = type.GetElementType();
		IMetadataScope scope = type.Scope;
		if (scope == null)
		{
			return null;
		}
		switch (scope.MetadataScopeType)
		{
		case MetadataScopeType.AssemblyNameReference:
		{
			AssemblyDefinition assemblyDefinition = assembly_resolver.Resolve((AssemblyNameReference)scope);
			if (assemblyDefinition == null)
			{
				return null;
			}
			return GetType(assemblyDefinition.MainModule, type);
		}
		case MetadataScopeType.ModuleDefinition:
			return GetType((ModuleDefinition)scope, type);
		case MetadataScopeType.ModuleReference:
		{
			if (type.Module.Assembly == null)
			{
				return null;
			}
			Collection<ModuleDefinition> modules = type.Module.Assembly.Modules;
			ModuleReference moduleReference = (ModuleReference)scope;
			for (int i = 0; i < modules.Count; i++)
			{
				ModuleDefinition moduleDefinition = modules[i];
				if (moduleDefinition.Name == moduleReference.Name)
				{
					return GetType(moduleDefinition, type);
				}
			}
			break;
		}
		}
		throw new NotSupportedException();
	}

	private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference)
	{
		TypeDefinition typeDefinition = GetTypeDefinition(module, reference);
		if (typeDefinition != null)
		{
			return typeDefinition;
		}
		if (!module.HasExportedTypes)
		{
			return null;
		}
		Collection<ExportedType> exportedTypes = module.ExportedTypes;
		for (int i = 0; i < exportedTypes.Count; i++)
		{
			ExportedType exportedType = exportedTypes[i];
			if (!(exportedType.Name != reference.Name) && !(exportedType.Namespace != reference.Namespace))
			{
				return exportedType.Resolve();
			}
		}
		return null;
	}

	private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type)
	{
		if (!type.IsNested)
		{
			return module.GetType(type.Namespace, type.Name);
		}
		return type.DeclaringType.Resolve()?.GetNestedType(type.TypeFullName());
	}

	public virtual FieldDefinition Resolve(FieldReference field)
	{
		Mixin.CheckField(field);
		TypeDefinition typeDefinition = Resolve(field.DeclaringType);
		if (typeDefinition == null)
		{
			return null;
		}
		if (!typeDefinition.HasFields)
		{
			return null;
		}
		return GetField(typeDefinition, field);
	}

	private FieldDefinition GetField(TypeDefinition type, FieldReference reference)
	{
		while (type != null)
		{
			FieldDefinition field = GetField(type.Fields, reference);
			if (field != null)
			{
				return field;
			}
			if (type.BaseType == null)
			{
				return null;
			}
			type = Resolve(type.BaseType);
		}
		return null;
	}

	private static FieldDefinition GetField(Collection<FieldDefinition> fields, FieldReference reference)
	{
		for (int i = 0; i < fields.Count; i++)
		{
			FieldDefinition fieldDefinition = fields[i];
			if (!(fieldDefinition.Name != reference.Name) && AreSame(fieldDefinition.FieldType, reference.FieldType))
			{
				return fieldDefinition;
			}
		}
		return null;
	}

	public virtual MethodDefinition Resolve(MethodReference method)
	{
		Mixin.CheckMethod(method);
		TypeDefinition typeDefinition = Resolve(method.DeclaringType);
		if (typeDefinition == null)
		{
			return null;
		}
		method = method.GetElementMethod();
		if (!typeDefinition.HasMethods)
		{
			return null;
		}
		return GetMethod(typeDefinition, method);
	}

	private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference)
	{
		while (type != null)
		{
			MethodDefinition method = GetMethod(type.Methods, reference);
			if (method != null)
			{
				return method;
			}
			if (type.BaseType == null)
			{
				return null;
			}
			type = Resolve(type.BaseType);
		}
		return null;
	}

	public static MethodDefinition GetMethod(Collection<MethodDefinition> methods, MethodReference reference)
	{
		for (int i = 0; i < methods.Count; i++)
		{
			MethodDefinition methodDefinition = methods[i];
			if (methodDefinition.Name != reference.Name || methodDefinition.HasGenericParameters != reference.HasGenericParameters || (methodDefinition.HasGenericParameters && methodDefinition.GenericParameters.Count != reference.GenericParameters.Count) || !AreSame(methodDefinition.ReturnType, reference.ReturnType) || methodDefinition.HasThis != reference.HasThis || methodDefinition.IsVarArg() != reference.IsVarArg())
			{
				continue;
			}
			if (methodDefinition.IsVarArg() && IsVarArgCallTo(methodDefinition, reference))
			{
				return methodDefinition;
			}
			if (methodDefinition.HasParameters == reference.HasParameters)
			{
				if (!methodDefinition.HasParameters && !reference.HasParameters)
				{
					return methodDefinition;
				}
				if (AreSame(methodDefinition.Parameters, reference.Parameters))
				{
					return methodDefinition;
				}
			}
		}
		return null;
	}

	private static bool AreSame(Collection<ParameterDefinition> a, Collection<ParameterDefinition> b)
	{
		int count = a.Count;
		if (count != b.Count)
		{
			return false;
		}
		if (count == 0)
		{
			return true;
		}
		for (int i = 0; i < count; i++)
		{
			if (!AreSame(a[i].ParameterType, b[i].ParameterType))
			{
				return false;
			}
		}
		return true;
	}

	private static bool IsVarArgCallTo(MethodDefinition method, MethodReference reference)
	{
		if (method.Parameters.Count >= reference.Parameters.Count)
		{
			return false;
		}
		if (reference.GetSentinelPosition() != method.Parameters.Count)
		{
			return false;
		}
		for (int i = 0; i < method.Parameters.Count; i++)
		{
			if (!AreSame(method.Parameters[i].ParameterType, reference.Parameters[i].ParameterType))
			{
				return false;
			}
		}
		return true;
	}

	private static bool AreSame(TypeSpecification a, TypeSpecification b)
	{
		if (!AreSame(a.ElementType, b.ElementType))
		{
			return false;
		}
		if (a.IsGenericInstance)
		{
			return AreSame((GenericInstanceType)a, (GenericInstanceType)b);
		}
		if (a.IsRequiredModifier || a.IsOptionalModifier)
		{
			return AreSame((IModifierType)a, (IModifierType)b);
		}
		if (a.IsArray)
		{
			return AreSame((ArrayType)a, (ArrayType)b);
		}
		if (a.IsFunctionPointer)
		{
			return AreSame((FunctionPointerType)a, (FunctionPointerType)b);
		}
		return true;
	}

	private static bool AreSame(FunctionPointerType a, FunctionPointerType b)
	{
		if (a.HasThis != b.HasThis)
		{
			return false;
		}
		if (a.CallingConvention != b.CallingConvention)
		{
			return false;
		}
		if (!AreSame(a.ReturnType, b.ReturnType))
		{
			return false;
		}
		if (a.ContainsGenericParameter != b.ContainsGenericParameter)
		{
			return false;
		}
		if (a.HasParameters != b.HasParameters)
		{
			return false;
		}
		if (!a.HasParameters)
		{
			return true;
		}
		if (!AreSame(a.Parameters, b.Parameters))
		{
			return false;
		}
		return true;
	}

	private static bool AreSame(ArrayType a, ArrayType b)
	{
		if (a.Rank != b.Rank)
		{
			return false;
		}
		return true;
	}

	private static bool AreSame(IModifierType a, IModifierType b)
	{
		return AreSame(a.ModifierType, b.ModifierType);
	}

	private static bool AreSame(GenericInstanceType a, GenericInstanceType b)
	{
		if (a.GenericArguments.Count != b.GenericArguments.Count)
		{
			return false;
		}
		for (int i = 0; i < a.GenericArguments.Count; i++)
		{
			if (!AreSame(a.GenericArguments[i], b.GenericArguments[i]))
			{
				return false;
			}
		}
		return true;
	}

	private static bool AreSame(GenericParameter a, GenericParameter b)
	{
		return a.Position == b.Position;
	}

	private static bool AreSame(TypeReference a, TypeReference b)
	{
		if (a == b)
		{
			return true;
		}
		if (a == null || b == null)
		{
			return false;
		}
		if (a.etype != b.etype)
		{
			return false;
		}
		if (a.IsGenericParameter)
		{
			return AreSame((GenericParameter)a, (GenericParameter)b);
		}
		if (a.IsTypeSpecification())
		{
			return AreSame((TypeSpecification)a, (TypeSpecification)b);
		}
		if (a.Name != b.Name || a.Namespace != b.Namespace)
		{
			return false;
		}
		return AreSame(a.DeclaringType, b.DeclaringType);
	}
}


internal struct Range
{
	public uint Start;

	public uint Length;

	public Range(uint index, uint length)
	{
		Start = index;
		Length = length;
	}
}


using System;
using System.Collections.Generic;
using System.Threading;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class MetadataSystem
{
	internal AssemblyNameReference[] AssemblyReferences;

	internal ModuleReference[] ModuleReferences;

	internal TypeDefinition[] Types;

	internal TypeReference[] TypeReferences;

	internal FieldDefinition[] Fields;

	internal MethodDefinition[] Methods;

	internal MemberReference[] MemberReferences;

	internal Dictionary<uint, Collection<uint>> NestedTypes;

	internal Dictionary<uint, uint> ReverseNestedTypes;

	internal Dictionary<uint, Collection<Row<uint, MetadataToken>>> Interfaces;

	internal Dictionary<uint, Row<ushort, uint>> ClassLayouts;

	internal Dictionary<uint, uint> FieldLayouts;

	internal Dictionary<uint, uint> FieldRVAs;

	internal Dictionary<MetadataToken, uint> FieldMarshals;

	internal Dictionary<MetadataToken, Row<ElementType, uint>> Constants;

	internal Dictionary<uint, Collection<MetadataToken>> Overrides;

	internal Dictionary<MetadataToken, Mono.Cecil.Range[]> CustomAttributes;

	internal Dictionary<MetadataToken, Mono.Cecil.Range[]> SecurityDeclarations;

	internal Dictionary<uint, Mono.Cecil.Range> Events;

	internal Dictionary<uint, Mono.Cecil.Range> Properties;

	internal Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> Semantics;

	internal Dictionary<uint, Row<PInvokeAttributes, uint, uint>> PInvokes;

	internal Dictionary<MetadataToken, Mono.Cecil.Range[]> GenericParameters;

	internal Dictionary<uint, Collection<Row<uint, MetadataToken>>> GenericConstraints;

	internal Document[] Documents;

	internal Dictionary<uint, Collection<Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint>>> LocalScopes;

	internal ImportDebugInformation[] ImportScopes;

	internal Dictionary<uint, uint> StateMachineMethods;

	internal Dictionary<MetadataToken, Row<Guid, uint, uint>[]> CustomDebugInformations;

	private static Dictionary<string, Row<ElementType, bool>> primitive_value_types;

	private static void InitializePrimitives()
	{
		Dictionary<string, Row<ElementType, bool>> value = new Dictionary<string, Row<ElementType, bool>>(18, StringComparer.Ordinal)
		{
			{
				"Void",
				new Row<ElementType, bool>(ElementType.Void, col2: false)
			},
			{
				"Boolean",
				new Row<ElementType, bool>(ElementType.Boolean, col2: true)
			},
			{
				"Char",
				new Row<ElementType, bool>(ElementType.Char, col2: true)
			},
			{
				"SByte",
				new Row<ElementType, bool>(ElementType.I1, col2: true)
			},
			{
				"Byte",
				new Row<ElementType, bool>(ElementType.U1, col2: true)
			},
			{
				"Int16",
				new Row<ElementType, bool>(ElementType.I2, col2: true)
			},
			{
				"UInt16",
				new Row<ElementType, bool>(ElementType.U2, col2: true)
			},
			{
				"Int32",
				new Row<ElementType, bool>(ElementType.I4, col2: true)
			},
			{
				"UInt32",
				new Row<ElementType, bool>(ElementType.U4, col2: true)
			},
			{
				"Int64",
				new Row<ElementType, bool>(ElementType.I8, col2: true)
			},
			{
				"UInt64",
				new Row<ElementType, bool>(ElementType.U8, col2: true)
			},
			{
				"Single",
				new Row<ElementType, bool>(ElementType.R4, col2: true)
			},
			{
				"Double",
				new Row<ElementType, bool>(ElementType.R8, col2: true)
			},
			{
				"String",
				new Row<ElementType, bool>(ElementType.String, col2: false)
			},
			{
				"TypedReference",
				new Row<ElementType, bool>(ElementType.TypedByRef, col2: false)
			},
			{
				"IntPtr",
				new Row<ElementType, bool>(ElementType.I, col2: true)
			},
			{
				"UIntPtr",
				new Row<ElementType, bool>(ElementType.U, col2: true)
			},
			{
				"Object",
				new Row<ElementType, bool>(ElementType.Object, col2: false)
			}
		};
		Interlocked.CompareExchange(ref primitive_value_types, value, null);
	}

	public static void TryProcessPrimitiveTypeReference(TypeReference type)
	{
		if (!(type.Namespace != "System"))
		{
			IMetadataScope scope = type.scope;
			if (scope != null && scope.MetadataScopeType == MetadataScopeType.AssemblyNameReference && TryGetPrimitiveData(type, out var primitive_data))
			{
				type.etype = primitive_data.Col1;
				type.IsValueType = primitive_data.Col2;
			}
		}
	}

	public static bool TryGetPrimitiveElementType(TypeDefinition type, out ElementType etype)
	{
		etype = ElementType.None;
		if (type.Namespace != "System")
		{
			return false;
		}
		if (TryGetPrimitiveData(type, out var primitive_data))
		{
			etype = primitive_data.Col1;
			return true;
		}
		return false;
	}

	private static bool TryGetPrimitiveData(TypeReference type, out Row<ElementType, bool> primitive_data)
	{
		if (primitive_value_types == null)
		{
			InitializePrimitives();
		}
		return primitive_value_types.TryGetValue(type.Name, out primitive_data);
	}

	public void Clear()
	{
		if (NestedTypes != null)
		{
			NestedTypes = new Dictionary<uint, Collection<uint>>(0);
		}
		if (ReverseNestedTypes != null)
		{
			ReverseNestedTypes = new Dictionary<uint, uint>(0);
		}
		if (Interfaces != null)
		{
			Interfaces = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(0);
		}
		if (ClassLayouts != null)
		{
			ClassLayouts = new Dictionary<uint, Row<ushort, uint>>(0);
		}
		if (FieldLayouts != null)
		{
			FieldLayouts = new Dictionary<uint, uint>(0);
		}
		if (FieldRVAs != null)
		{
			FieldRVAs = new Dictionary<uint, uint>(0);
		}
		if (FieldMarshals != null)
		{
			FieldMarshals = new Dictionary<MetadataToken, uint>(0);
		}
		if (Constants != null)
		{
			Constants = new Dictionary<MetadataToken, Row<ElementType, uint>>(0);
		}
		if (Overrides != null)
		{
			Overrides = new Dictionary<uint, Collection<MetadataToken>>(0);
		}
		if (CustomAttributes != null)
		{
			CustomAttributes = new Dictionary<MetadataToken, Mono.Cecil.Range[]>(0);
		}
		if (SecurityDeclarations != null)
		{
			SecurityDeclarations = new Dictionary<MetadataToken, Mono.Cecil.Range[]>(0);
		}
		if (Events != null)
		{
			Events = new Dictionary<uint, Mono.Cecil.Range>(0);
		}
		if (Properties != null)
		{
			Properties = new Dictionary<uint, Mono.Cecil.Range>(0);
		}
		if (Semantics != null)
		{
			Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>>(0);
		}
		if (PInvokes != null)
		{
			PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>>(0);
		}
		if (GenericParameters != null)
		{
			GenericParameters = new Dictionary<MetadataToken, Mono.Cecil.Range[]>(0);
		}
		if (GenericConstraints != null)
		{
			GenericConstraints = new Dictionary<uint, Collection<Row<uint, MetadataToken>>>(0);
		}
		Documents = Empty<Document>.Array;
		ImportScopes = Empty<ImportDebugInformation>.Array;
		if (LocalScopes != null)
		{
			LocalScopes = new Dictionary<uint, Collection<Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint>>>(0);
		}
		if (StateMachineMethods != null)
		{
			StateMachineMethods = new Dictionary<uint, uint>(0);
		}
	}

	public AssemblyNameReference GetAssemblyNameReference(uint rid)
	{
		if (rid < 1 || rid > AssemblyReferences.Length)
		{
			return null;
		}
		return AssemblyReferences[rid - 1];
	}

	public TypeDefinition GetTypeDefinition(uint rid)
	{
		if (rid < 1 || rid > Types.Length)
		{
			return null;
		}
		return Types[rid - 1];
	}

	public void AddTypeDefinition(TypeDefinition type)
	{
		Types[type.token.RID - 1] = type;
	}

	public TypeReference GetTypeReference(uint rid)
	{
		if (rid < 1 || rid > TypeReferences.Length)
		{
			return null;
		}
		return TypeReferences[rid - 1];
	}

	public void AddTypeReference(TypeReference type)
	{
		TypeReferences[type.token.RID - 1] = type;
	}

	public FieldDefinition GetFieldDefinition(uint rid)
	{
		if (rid < 1 || rid > Fields.Length)
		{
			return null;
		}
		return Fields[rid - 1];
	}

	public void AddFieldDefinition(FieldDefinition field)
	{
		Fields[field.token.RID - 1] = field;
	}

	public MethodDefinition GetMethodDefinition(uint rid)
	{
		if (rid < 1 || rid > Methods.Length)
		{
			return null;
		}
		return Methods[rid - 1];
	}

	public void AddMethodDefinition(MethodDefinition method)
	{
		Methods[method.token.RID - 1] = method;
	}

	public MemberReference GetMemberReference(uint rid)
	{
		if (rid < 1 || rid > MemberReferences.Length)
		{
			return null;
		}
		return MemberReferences[rid - 1];
	}

	public void AddMemberReference(MemberReference member)
	{
		MemberReferences[member.token.RID - 1] = member;
	}

	public bool TryGetNestedTypeMapping(TypeDefinition type, out Collection<uint> mapping)
	{
		return NestedTypes.TryGetValue(type.token.RID, out mapping);
	}

	public void SetNestedTypeMapping(uint type_rid, Collection<uint> mapping)
	{
		NestedTypes[type_rid] = mapping;
	}

	public bool TryGetReverseNestedTypeMapping(TypeDefinition type, out uint declaring)
	{
		return ReverseNestedTypes.TryGetValue(type.token.RID, out declaring);
	}

	public void SetReverseNestedTypeMapping(uint nested, uint declaring)
	{
		ReverseNestedTypes[nested] = declaring;
	}

	public bool TryGetInterfaceMapping(TypeDefinition type, out Collection<Row<uint, MetadataToken>> mapping)
	{
		return Interfaces.TryGetValue(type.token.RID, out mapping);
	}

	public void SetInterfaceMapping(uint type_rid, Collection<Row<uint, MetadataToken>> mapping)
	{
		Interfaces[type_rid] = mapping;
	}

	public void AddPropertiesRange(uint type_rid, Mono.Cecil.Range range)
	{
		Properties.Add(type_rid, range);
	}

	public bool TryGetPropertiesRange(TypeDefinition type, out Mono.Cecil.Range range)
	{
		return Properties.TryGetValue(type.token.RID, out range);
	}

	public void AddEventsRange(uint type_rid, Mono.Cecil.Range range)
	{
		Events.Add(type_rid, range);
	}

	public bool TryGetEventsRange(TypeDefinition type, out Mono.Cecil.Range range)
	{
		return Events.TryGetValue(type.token.RID, out range);
	}

	public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, out Mono.Cecil.Range[] ranges)
	{
		return GenericParameters.TryGetValue(owner.MetadataToken, out ranges);
	}

	public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, out Mono.Cecil.Range[] ranges)
	{
		return CustomAttributes.TryGetValue(owner.MetadataToken, out ranges);
	}

	public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, out Mono.Cecil.Range[] ranges)
	{
		return SecurityDeclarations.TryGetValue(owner.MetadataToken, out ranges);
	}

	public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, out Collection<Row<uint, MetadataToken>> mapping)
	{
		return GenericConstraints.TryGetValue(generic_parameter.token.RID, out mapping);
	}

	public void SetGenericConstraintMapping(uint gp_rid, Collection<Row<uint, MetadataToken>> mapping)
	{
		GenericConstraints[gp_rid] = mapping;
	}

	public bool TryGetOverrideMapping(MethodDefinition method, out Collection<MetadataToken> mapping)
	{
		return Overrides.TryGetValue(method.token.RID, out mapping);
	}

	public void SetOverrideMapping(uint rid, Collection<MetadataToken> mapping)
	{
		Overrides[rid] = mapping;
	}

	public Document GetDocument(uint rid)
	{
		if (rid < 1 || rid > Documents.Length)
		{
			return null;
		}
		return Documents[rid - 1];
	}

	public bool TryGetLocalScopes(MethodDefinition method, out Collection<Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint>> scopes)
	{
		return LocalScopes.TryGetValue(method.MetadataToken.RID, out scopes);
	}

	public void SetLocalScopes(uint method_rid, Collection<Row<uint, Mono.Cecil.Range, Mono.Cecil.Range, uint, uint, uint>> records)
	{
		LocalScopes[method_rid] = records;
	}

	public ImportDebugInformation GetImportScope(uint rid)
	{
		if (rid < 1 || rid > ImportScopes.Length)
		{
			return null;
		}
		return ImportScopes[rid - 1];
	}

	public bool TryGetStateMachineKickOffMethod(MethodDefinition method, out uint rid)
	{
		return StateMachineMethods.TryGetValue(method.MetadataToken.RID, out rid);
	}

	public TypeDefinition GetFieldDeclaringType(uint field_rid)
	{
		return BinaryRangeSearch(Types, field_rid, field: true);
	}

	public TypeDefinition GetMethodDeclaringType(uint method_rid)
	{
		return BinaryRangeSearch(Types, method_rid, field: false);
	}

	private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, uint rid, bool field)
	{
		int num = 0;
		int num2 = types.Length - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			TypeDefinition typeDefinition = types[num3];
			Mono.Cecil.Range range = (field ? typeDefinition.fields_range : typeDefinition.methods_range);
			if (rid < range.Start)
			{
				num2 = num3 - 1;
				continue;
			}
			if (rid >= range.Start + range.Length)
			{
				num = num3 + 1;
				continue;
			}
			return typeDefinition;
		}
		return null;
	}
}


using System;

[Flags]
internal enum MethodAttributes : ushort
{
	MemberAccessMask = 7,
	CompilerControlled = 0,
	Private = 1,
	FamANDAssem = 2,
	Assembly = 3,
	Family = 4,
	FamORAssem = 5,
	Public = 6,
	Static = 0x10,
	Final = 0x20,
	Virtual = 0x40,
	HideBySig = 0x80,
	VtableLayoutMask = 0x100,
	ReuseSlot = 0,
	NewSlot = 0x100,
	CheckAccessOnOverride = 0x200,
	Abstract = 0x400,
	SpecialName = 0x800,
	PInvokeImpl = 0x2000,
	UnmanagedExport = 8,
	RTSpecialName = 0x1000,
	HasSecurity = 0x4000,
	RequireSecObject = 0x8000
}


internal enum MethodCallingConvention : byte
{
	Default = 0,
	C = 1,
	StdCall = 2,
	ThisCall = 3,
	FastCall = 4,
	VarArg = 5,
	Unmanaged = 9,
	Generic = 16
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class MethodDefinition : MethodReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider, ICustomDebugInformationProvider
{
	private ushort attributes;

	private ushort impl_attributes;

	internal volatile bool sem_attrs_ready;

	internal MethodSemanticsAttributes sem_attrs;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<SecurityDeclaration> security_declarations;

	internal uint rva;

	internal PInvokeInfo pinvoke;

	private Collection<MethodReference> overrides;

	internal MethodBody body;

	internal MethodDebugInformation debug_info;

	internal Collection<CustomDebugInformation> custom_infos;

	public override string Name
	{
		get
		{
			return base.Name;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && value != base.Name)
			{
				throw new InvalidOperationException();
			}
			base.Name = value;
		}
	}

	public MethodAttributes Attributes
	{
		get
		{
			return (MethodAttributes)attributes;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && (uint)value != attributes)
			{
				throw new InvalidOperationException();
			}
			attributes = (ushort)value;
		}
	}

	public MethodImplAttributes ImplAttributes
	{
		get
		{
			return (MethodImplAttributes)impl_attributes;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && (uint)value != impl_attributes)
			{
				throw new InvalidOperationException();
			}
			impl_attributes = (ushort)value;
		}
	}

	public MethodSemanticsAttributes SemanticsAttributes
	{
		get
		{
			if (sem_attrs_ready)
			{
				return sem_attrs;
			}
			if (base.HasImage)
			{
				ReadSemantics();
				return sem_attrs;
			}
			sem_attrs = MethodSemanticsAttributes.None;
			sem_attrs_ready = true;
			return sem_attrs;
		}
		set
		{
			sem_attrs = value;
		}
	}

	internal MethodDefinitionProjection WindowsRuntimeProjection
	{
		get
		{
			return (MethodDefinitionProjection)projection;
		}
		set
		{
			projection = value;
		}
	}

	public bool HasSecurityDeclarations
	{
		get
		{
			if (security_declarations != null)
			{
				return security_declarations.Count > 0;
			}
			return this.GetHasSecurityDeclarations(Module);
		}
	}

	public Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, Module);

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public int RVA => (int)rva;

	public bool HasBody
	{
		get
		{
			if ((attributes & 0x400) == 0 && (attributes & 0x2000) == 0 && (impl_attributes & 0x1000) == 0 && (impl_attributes & 1) == 0 && (impl_attributes & 4) == 0)
			{
				return (impl_attributes & 3) == 0;
			}
			return false;
		}
	}

	public MethodBody Body
	{
		get
		{
			MethodBody methodBody = body;
			if (methodBody != null)
			{
				return methodBody;
			}
			if (!HasBody)
			{
				return null;
			}
			if (base.HasImage && rva != 0)
			{
				return Module.Read(ref body, this, (MethodDefinition method, MetadataReader reader) => reader.ReadMethodBody(method));
			}
			Interlocked.CompareExchange(ref body, new MethodBody(this), null);
			return body;
		}
		set
		{
			ModuleDefinition module = Module;
			if (module == null)
			{
				body = value;
				return;
			}
			lock (module.SyncRoot)
			{
				body = value;
				if (value == null)
				{
					debug_info = null;
				}
			}
		}
	}

	public MethodDebugInformation DebugInformation
	{
		get
		{
			Mixin.Read(Body);
			if (debug_info == null)
			{
				Interlocked.CompareExchange(ref debug_info, new MethodDebugInformation(this), null);
			}
			return debug_info;
		}
		set
		{
			debug_info = value;
		}
	}

	public bool HasPInvokeInfo
	{
		get
		{
			if (pinvoke != null)
			{
				return true;
			}
			return IsPInvokeImpl;
		}
	}

	public PInvokeInfo PInvokeInfo
	{
		get
		{
			if (pinvoke != null)
			{
				return pinvoke;
			}
			if (base.HasImage && IsPInvokeImpl)
			{
				return Module.Read(ref pinvoke, this, (MethodDefinition method, MetadataReader reader) => reader.ReadPInvokeInfo(method));
			}
			return null;
		}
		set
		{
			IsPInvokeImpl = true;
			pinvoke = value;
		}
	}

	public bool HasOverrides
	{
		get
		{
			if (overrides != null)
			{
				return overrides.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (MethodDefinition method, MetadataReader reader) => reader.HasOverrides(method));
			}
			return false;
		}
	}

	public Collection<MethodReference> Overrides
	{
		get
		{
			if (overrides != null)
			{
				return overrides;
			}
			if (base.HasImage)
			{
				return Module.Read(ref overrides, this, (MethodDefinition method, MetadataReader reader) => reader.ReadOverrides(method));
			}
			Interlocked.CompareExchange(ref overrides, new Collection<MethodReference>(), null);
			return overrides;
		}
	}

	public override bool HasGenericParameters
	{
		get
		{
			if (generic_parameters != null)
			{
				return generic_parameters.Count > 0;
			}
			return this.GetHasGenericParameters(Module);
		}
	}

	public override Collection<GenericParameter> GenericParameters => generic_parameters ?? this.GetGenericParameters(ref generic_parameters, Module);

	public bool HasCustomDebugInformations
	{
		get
		{
			Mixin.Read(Body);
			return !custom_infos.IsNullOrEmpty();
		}
	}

	public Collection<CustomDebugInformation> CustomDebugInformations
	{
		get
		{
			Mixin.Read(Body);
			if (custom_infos == null)
			{
				Interlocked.CompareExchange(ref custom_infos, new Collection<CustomDebugInformation>(), null);
			}
			return custom_infos;
		}
	}

	public bool IsCompilerControlled
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 0u, value);
		}
	}

	public bool IsPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 1u, value);
		}
	}

	public bool IsFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 2u, value);
		}
	}

	public bool IsAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 3u, value);
		}
	}

	public bool IsFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 4u, value);
		}
	}

	public bool IsFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 5u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7, 6u, value);
		}
	}

	public bool IsStatic
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public bool IsFinal
	{
		get
		{
			return attributes.GetAttributes(32);
		}
		set
		{
			attributes = attributes.SetAttributes(32, value);
		}
	}

	public bool IsVirtual
	{
		get
		{
			return attributes.GetAttributes(64);
		}
		set
		{
			attributes = attributes.SetAttributes(64, value);
		}
	}

	public bool IsHideBySig
	{
		get
		{
			return attributes.GetAttributes(128);
		}
		set
		{
			attributes = attributes.SetAttributes(128, value);
		}
	}

	public bool IsReuseSlot
	{
		get
		{
			return attributes.GetMaskedAttributes(256, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(256, 0u, value);
		}
	}

	public bool IsNewSlot
	{
		get
		{
			return attributes.GetMaskedAttributes(256, 256u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(256, 256u, value);
		}
	}

	public bool IsCheckAccessOnOverride
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsAbstract
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(2048);
		}
		set
		{
			attributes = attributes.SetAttributes(2048, value);
		}
	}

	public bool IsPInvokeImpl
	{
		get
		{
			return attributes.GetAttributes(8192);
		}
		set
		{
			attributes = attributes.SetAttributes(8192, value);
		}
	}

	public bool IsUnmanagedExport
	{
		get
		{
			return attributes.GetAttributes(8);
		}
		set
		{
			attributes = attributes.SetAttributes(8, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(4096);
		}
		set
		{
			attributes = attributes.SetAttributes(4096, value);
		}
	}

	public bool HasSecurity
	{
		get
		{
			return attributes.GetAttributes(16384);
		}
		set
		{
			attributes = attributes.SetAttributes(16384, value);
		}
	}

	public bool IsIL
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(3, 0u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(3, 0u, value);
		}
	}

	public bool IsNative
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(3, 1u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(3, 1u, value);
		}
	}

	public bool IsRuntime
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(3, 3u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(3, 3u, value);
		}
	}

	public bool IsUnmanaged
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(4, 4u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(4, 4u, value);
		}
	}

	public bool IsManaged
	{
		get
		{
			return impl_attributes.GetMaskedAttributes(4, 0u);
		}
		set
		{
			impl_attributes = impl_attributes.SetMaskedAttributes(4, 0u, value);
		}
	}

	public bool IsForwardRef
	{
		get
		{
			return impl_attributes.GetAttributes(16);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(16, value);
		}
	}

	public bool IsPreserveSig
	{
		get
		{
			return impl_attributes.GetAttributes(128);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(128, value);
		}
	}

	public bool IsInternalCall
	{
		get
		{
			return impl_attributes.GetAttributes(4096);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(4096, value);
		}
	}

	public bool IsSynchronized
	{
		get
		{
			return impl_attributes.GetAttributes(32);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(32, value);
		}
	}

	public bool NoInlining
	{
		get
		{
			return impl_attributes.GetAttributes(8);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(8, value);
		}
	}

	public bool NoOptimization
	{
		get
		{
			return impl_attributes.GetAttributes(64);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(64, value);
		}
	}

	public bool AggressiveInlining
	{
		get
		{
			return impl_attributes.GetAttributes(256);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(256, value);
		}
	}

	public bool AggressiveOptimization
	{
		get
		{
			return impl_attributes.GetAttributes(512);
		}
		set
		{
			impl_attributes = impl_attributes.SetAttributes(512, value);
		}
	}

	public bool IsSetter
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Setter);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Setter, value);
		}
	}

	public bool IsGetter
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Getter);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Getter, value);
		}
	}

	public bool IsOther
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Other);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Other, value);
		}
	}

	public bool IsAddOn
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.AddOn);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.AddOn, value);
		}
	}

	public bool IsRemoveOn
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.RemoveOn);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.RemoveOn, value);
		}
	}

	public bool IsFire
	{
		get
		{
			return this.GetSemantics(MethodSemanticsAttributes.Fire);
		}
		set
		{
			this.SetSemantics(MethodSemanticsAttributes.Fire, value);
		}
	}

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	public bool IsConstructor
	{
		get
		{
			if (IsRuntimeSpecialName && IsSpecialName)
			{
				if (!(Name == ".cctor"))
				{
					return Name == ".ctor";
				}
				return true;
			}
			return false;
		}
	}

	public override bool IsDefinition => true;

	internal void ReadSemantics()
	{
		if (sem_attrs_ready)
		{
			return;
		}
		ModuleDefinition module = Module;
		if (module == null || !module.HasImage)
		{
			return;
		}
		lock (module.SyncRoot)
		{
			if (!sem_attrs_ready)
			{
				module.Read(this, delegate(MethodDefinition method, MetadataReader reader)
				{
					reader.ReadAllSemantics(method);
				});
			}
		}
	}

	internal MethodDefinition()
	{
		token = new MetadataToken(TokenType.Method);
	}

	public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType)
		: base(name, returnType)
	{
		this.attributes = (ushort)attributes;
		HasThis = !IsStatic;
		token = new MetadataToken(TokenType.Method);
	}

	public override MethodDefinition Resolve()
	{
		return this;
	}
}


using System;

[Flags]
internal enum MethodImplAttributes : ushort
{
	CodeTypeMask = 3,
	IL = 0,
	Native = 1,
	OPTIL = 2,
	Runtime = 3,
	ManagedMask = 4,
	Unmanaged = 4,
	Managed = 0,
	ForwardRef = 0x10,
	PreserveSig = 0x80,
	InternalCall = 0x1000,
	Synchronized = 0x20,
	NoOptimization = 0x40,
	NoInlining = 8,
	AggressiveInlining = 0x100,
	AggressiveOptimization = 0x200
}


using System;
using System.Text;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal class MethodReference : MemberReference, IMethodSignature, IMetadataTokenProvider, IGenericParameterProvider, IGenericContext
{
	internal ParameterDefinitionCollection parameters;

	private MethodReturnType return_type;

	private bool has_this;

	private bool explicit_this;

	private MethodCallingConvention calling_convention;

	internal Collection<GenericParameter> generic_parameters;

	public virtual bool HasThis
	{
		get
		{
			return has_this;
		}
		set
		{
			has_this = value;
		}
	}

	public virtual bool ExplicitThis
	{
		get
		{
			return explicit_this;
		}
		set
		{
			explicit_this = value;
		}
	}

	public virtual MethodCallingConvention CallingConvention
	{
		get
		{
			return calling_convention;
		}
		set
		{
			calling_convention = value;
		}
	}

	public virtual bool HasParameters => !parameters.IsNullOrEmpty();

	public virtual Collection<ParameterDefinition> Parameters
	{
		get
		{
			if (parameters == null)
			{
				Interlocked.CompareExchange(ref parameters, new ParameterDefinitionCollection(this), null);
			}
			return parameters;
		}
	}

	IGenericParameterProvider IGenericContext.Type
	{
		get
		{
			TypeReference declaringType = DeclaringType;
			if (declaringType is GenericInstanceType genericInstanceType)
			{
				return genericInstanceType.ElementType;
			}
			return declaringType;
		}
	}

	IGenericParameterProvider IGenericContext.Method => this;

	GenericParameterType IGenericParameterProvider.GenericParameterType => GenericParameterType.Method;

	public virtual bool HasGenericParameters => !generic_parameters.IsNullOrEmpty();

	public virtual Collection<GenericParameter> GenericParameters
	{
		get
		{
			if (generic_parameters == null)
			{
				Interlocked.CompareExchange(ref generic_parameters, new GenericParameterCollection(this), null);
			}
			return generic_parameters;
		}
	}

	public TypeReference ReturnType
	{
		get
		{
			return MethodReturnType?.ReturnType;
		}
		set
		{
			MethodReturnType methodReturnType = MethodReturnType;
			if (methodReturnType != null)
			{
				methodReturnType.ReturnType = value;
			}
		}
	}

	public virtual MethodReturnType MethodReturnType
	{
		get
		{
			return return_type;
		}
		set
		{
			return_type = value;
		}
	}

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(ReturnType.FullName).Append(" ").Append(MemberFullName());
			this.MethodSignatureFullName(stringBuilder);
			return stringBuilder.ToString();
		}
	}

	public virtual bool IsGenericInstance => false;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (ReturnType.ContainsGenericParameter || base.ContainsGenericParameter)
			{
				return true;
			}
			if (!HasParameters)
			{
				return false;
			}
			Collection<ParameterDefinition> collection = Parameters;
			for (int i = 0; i < collection.Count; i++)
			{
				if (collection[i].ParameterType.ContainsGenericParameter)
				{
					return true;
				}
			}
			return false;
		}
	}

	internal MethodReference()
	{
		return_type = new MethodReturnType(this);
		token = new MetadataToken(TokenType.MemberRef);
	}

	public MethodReference(string name, TypeReference returnType)
		: base(name)
	{
		Mixin.CheckType(returnType, Mixin.Argument.returnType);
		return_type = new MethodReturnType(this);
		return_type.ReturnType = returnType;
		token = new MetadataToken(TokenType.MemberRef);
	}

	public MethodReference(string name, TypeReference returnType, TypeReference declaringType)
		: this(name, returnType)
	{
		Mixin.CheckType(declaringType, Mixin.Argument.declaringType);
		DeclaringType = declaringType;
	}

	public virtual MethodReference GetElementMethod()
	{
		return this;
	}

	protected override IMemberDefinition ResolveDefinition()
	{
		return Resolve();
	}

	public new virtual MethodDefinition Resolve()
	{
		return (Module ?? throw new NotSupportedException()).Resolve(this);
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;

internal sealed class MethodReferenceComparer : EqualityComparer<MethodReference>
{
	[ThreadStatic]
	private static List<MethodReference> xComparisonStack;

	[ThreadStatic]
	private static List<MethodReference> yComparisonStack;

	public override bool Equals(MethodReference x, MethodReference y)
	{
		return AreEqual(x, y);
	}

	public override int GetHashCode(MethodReference obj)
	{
		return GetHashCodeFor(obj);
	}

	public static bool AreEqual(MethodReference x, MethodReference y)
	{
		if (x == y)
		{
			return true;
		}
		if (x.HasThis != y.HasThis)
		{
			return false;
		}
		if (x.HasParameters != y.HasParameters)
		{
			return false;
		}
		if (x.HasGenericParameters != y.HasGenericParameters)
		{
			return false;
		}
		if (x.Parameters.Count != y.Parameters.Count)
		{
			return false;
		}
		if (x.Name != y.Name)
		{
			return false;
		}
		if (!TypeReferenceEqualityComparer.AreEqual(x.DeclaringType, y.DeclaringType))
		{
			return false;
		}
		GenericInstanceMethod genericInstanceMethod = x as GenericInstanceMethod;
		GenericInstanceMethod genericInstanceMethod2 = y as GenericInstanceMethod;
		if (genericInstanceMethod != null || genericInstanceMethod2 != null)
		{
			if (genericInstanceMethod == null || genericInstanceMethod2 == null)
			{
				return false;
			}
			if (genericInstanceMethod.GenericArguments.Count != genericInstanceMethod2.GenericArguments.Count)
			{
				return false;
			}
			for (int i = 0; i < genericInstanceMethod.GenericArguments.Count; i++)
			{
				if (!TypeReferenceEqualityComparer.AreEqual(genericInstanceMethod.GenericArguments[i], genericInstanceMethod2.GenericArguments[i]))
				{
					return false;
				}
			}
		}
		MethodDefinition methodDefinition = x.Resolve();
		MethodDefinition methodDefinition2 = y.Resolve();
		if (methodDefinition != methodDefinition2)
		{
			return false;
		}
		if (methodDefinition == null)
		{
			if (xComparisonStack == null)
			{
				xComparisonStack = new List<MethodReference>();
			}
			if (yComparisonStack == null)
			{
				yComparisonStack = new List<MethodReference>();
			}
			for (int j = 0; j < xComparisonStack.Count; j++)
			{
				if (xComparisonStack[j] == x && yComparisonStack[j] == y)
				{
					return true;
				}
			}
			xComparisonStack.Add(x);
			try
			{
				yComparisonStack.Add(y);
				try
				{
					for (int k = 0; k < x.Parameters.Count; k++)
					{
						if (!TypeReferenceEqualityComparer.AreEqual(x.Parameters[k].ParameterType, y.Parameters[k].ParameterType))
						{
							return false;
						}
					}
				}
				finally
				{
					yComparisonStack.RemoveAt(yComparisonStack.Count - 1);
				}
			}
			finally
			{
				xComparisonStack.RemoveAt(xComparisonStack.Count - 1);
			}
		}
		return true;
	}

	public static bool AreSignaturesEqual(MethodReference x, MethodReference y, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
	{
		if (x.HasThis != y.HasThis)
		{
			return false;
		}
		if (x.Parameters.Count != y.Parameters.Count)
		{
			return false;
		}
		if (x.GenericParameters.Count != y.GenericParameters.Count)
		{
			return false;
		}
		for (int i = 0; i < x.Parameters.Count; i++)
		{
			if (!TypeReferenceEqualityComparer.AreEqual(x.Parameters[i].ParameterType, y.Parameters[i].ParameterType, comparisonMode))
			{
				return false;
			}
		}
		if (!TypeReferenceEqualityComparer.AreEqual(x.ReturnType, y.ReturnType, comparisonMode))
		{
			return false;
		}
		return true;
	}

	public static int GetHashCodeFor(MethodReference obj)
	{
		if (obj is GenericInstanceMethod genericInstanceMethod)
		{
			int num = GetHashCodeFor(genericInstanceMethod.ElementMethod);
			for (int i = 0; i < genericInstanceMethod.GenericArguments.Count; i++)
			{
				num = num * 486187739 + TypeReferenceEqualityComparer.GetHashCodeFor(genericInstanceMethod.GenericArguments[i]);
			}
			return num;
		}
		return TypeReferenceEqualityComparer.GetHashCodeFor(obj.DeclaringType) * 486187739 + obj.Name.GetHashCode();
	}
}


using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class MethodReturnType : IConstantProvider, IMetadataTokenProvider, ICustomAttributeProvider, IMarshalInfoProvider
{
	internal IMethodSignature method;

	internal ParameterDefinition parameter;

	private TypeReference return_type;

	public IMethodSignature Method => method;

	public TypeReference ReturnType
	{
		get
		{
			return return_type;
		}
		set
		{
			return_type = value;
		}
	}

	internal ParameterDefinition Parameter
	{
		get
		{
			if (parameter == null)
			{
				Interlocked.CompareExchange(ref parameter, new ParameterDefinition(return_type, method), null);
			}
			return parameter;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return Parameter.MetadataToken;
		}
		set
		{
			Parameter.MetadataToken = value;
		}
	}

	public ParameterAttributes Attributes
	{
		get
		{
			return Parameter.Attributes;
		}
		set
		{
			Parameter.Attributes = value;
		}
	}

	public string Name
	{
		get
		{
			return Parameter.Name;
		}
		set
		{
			Parameter.Name = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasCustomAttributes;
			}
			return false;
		}
	}

	public Collection<CustomAttribute> CustomAttributes => Parameter.CustomAttributes;

	public bool HasDefault
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasDefault;
			}
			return false;
		}
		set
		{
			Parameter.HasDefault = value;
		}
	}

	public bool HasConstant
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasConstant;
			}
			return false;
		}
		set
		{
			Parameter.HasConstant = value;
		}
	}

	public object Constant
	{
		get
		{
			return Parameter.Constant;
		}
		set
		{
			Parameter.Constant = value;
		}
	}

	public bool HasFieldMarshal
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasFieldMarshal;
			}
			return false;
		}
		set
		{
			Parameter.HasFieldMarshal = value;
		}
	}

	public bool HasMarshalInfo
	{
		get
		{
			if (parameter != null)
			{
				return parameter.HasMarshalInfo;
			}
			return false;
		}
	}

	public MarshalInfo MarshalInfo
	{
		get
		{
			return Parameter.MarshalInfo;
		}
		set
		{
			Parameter.MarshalInfo = value;
		}
	}

	public MethodReturnType(IMethodSignature method)
	{
		this.method = method;
	}
}


using System;

[Flags]
internal enum MethodSemanticsAttributes : ushort
{
	None = 0,
	Setter = 1,
	Getter = 2,
	Other = 4,
	AddOn = 8,
	RemoveOn = 0x10,
	Fire = 0x20
}


using System;
using Mono.Cecil;
using Mono.Collections.Generic;

internal abstract class MethodSpecification : MethodReference
{
	private readonly MethodReference method;

	public MethodReference ElementMethod => method;

	public override string Name
	{
		get
		{
			return method.Name;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override MethodCallingConvention CallingConvention
	{
		get
		{
			return method.CallingConvention;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool HasThis
	{
		get
		{
			return method.HasThis;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool ExplicitThis
	{
		get
		{
			return method.ExplicitThis;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override MethodReturnType MethodReturnType
	{
		get
		{
			return method.MethodReturnType;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override TypeReference DeclaringType
	{
		get
		{
			return method.DeclaringType;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override ModuleDefinition Module => method.Module;

	public override bool HasParameters => method.HasParameters;

	public override Collection<ParameterDefinition> Parameters => method.Parameters;

	public override bool ContainsGenericParameter => method.ContainsGenericParameter;

	internal MethodSpecification(MethodReference method)
	{
		Mixin.CheckMethod(method);
		this.method = method;
		token = new MetadataToken(TokenType.MethodSpec);
	}

	public sealed override MethodReference GetElementMethod()
	{
		return method.GetElementMethod();
	}
}


using Mono.Cecil;

internal interface IModifierType
{
	TypeReference ModifierType { get; }

	TypeReference ElementType { get; }
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class OptionalModifierType : TypeSpecification, IModifierType
{
	private TypeReference modifier_type;

	public TypeReference ModifierType
	{
		get
		{
			return modifier_type;
		}
		set
		{
			modifier_type = value;
		}
	}

	public override string Name => base.Name + Suffix;

	public override string FullName => base.FullName + Suffix;

	private string Suffix => " modopt(" + modifier_type?.ToString() + ")";

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsOptionalModifier => true;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!modifier_type.ContainsGenericParameter)
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	public OptionalModifierType(TypeReference modifierType, TypeReference type)
		: base(type)
	{
		if (modifierType == null)
		{
			throw new ArgumentNullException(Mixin.Argument.modifierType.ToString());
		}
		Mixin.CheckType(type);
		modifier_type = modifierType;
		etype = Mono.Cecil.Metadata.ElementType.CModOpt;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class RequiredModifierType : TypeSpecification, IModifierType
{
	private TypeReference modifier_type;

	public TypeReference ModifierType
	{
		get
		{
			return modifier_type;
		}
		set
		{
			modifier_type = value;
		}
	}

	public override string Name => base.Name + Suffix;

	public override string FullName => base.FullName + Suffix;

	private string Suffix => " modreq(" + modifier_type?.ToString() + ")";

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsRequiredModifier => true;

	public override bool ContainsGenericParameter
	{
		get
		{
			if (!modifier_type.ContainsGenericParameter)
			{
				return base.ContainsGenericParameter;
			}
			return true;
		}
	}

	public RequiredModifierType(TypeReference modifierType, TypeReference type)
		: base(type)
	{
		if (modifierType == null)
		{
			throw new ArgumentNullException(Mixin.Argument.modifierType.ToString());
		}
		Mixin.CheckType(type);
		modifier_type = modifierType;
		etype = Mono.Cecil.Metadata.ElementType.CModReqD;
	}
}


internal enum ReadingMode
{
	Immediate = 1,
	Deferred
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class ReaderParameters
{
	private ReadingMode reading_mode;

	internal IAssemblyResolver assembly_resolver;

	internal IMetadataResolver metadata_resolver;

	internal IMetadataImporterProvider metadata_importer_provider;

	internal IReflectionImporterProvider reflection_importer_provider;

	private Stream symbol_stream;

	private ISymbolReaderProvider symbol_reader_provider;

	private bool read_symbols;

	private bool throw_symbols_mismatch;

	private bool projections;

	private bool in_memory;

	private bool read_write;

	public ReadingMode ReadingMode
	{
		get
		{
			return reading_mode;
		}
		set
		{
			reading_mode = value;
		}
	}

	public bool InMemory
	{
		get
		{
			return in_memory;
		}
		set
		{
			in_memory = value;
		}
	}

	public IAssemblyResolver AssemblyResolver
	{
		get
		{
			return assembly_resolver;
		}
		set
		{
			assembly_resolver = value;
		}
	}

	public IMetadataResolver MetadataResolver
	{
		get
		{
			return metadata_resolver;
		}
		set
		{
			metadata_resolver = value;
		}
	}

	public IMetadataImporterProvider MetadataImporterProvider
	{
		get
		{
			return metadata_importer_provider;
		}
		set
		{
			metadata_importer_provider = value;
		}
	}

	public IReflectionImporterProvider ReflectionImporterProvider
	{
		get
		{
			return reflection_importer_provider;
		}
		set
		{
			reflection_importer_provider = value;
		}
	}

	public Stream SymbolStream
	{
		get
		{
			return symbol_stream;
		}
		set
		{
			symbol_stream = value;
		}
	}

	public ISymbolReaderProvider SymbolReaderProvider
	{
		get
		{
			return symbol_reader_provider;
		}
		set
		{
			symbol_reader_provider = value;
		}
	}

	public bool ReadSymbols
	{
		get
		{
			return read_symbols;
		}
		set
		{
			read_symbols = value;
		}
	}

	public bool ThrowIfSymbolsAreNotMatching
	{
		get
		{
			return throw_symbols_mismatch;
		}
		set
		{
			throw_symbols_mismatch = value;
		}
	}

	public bool ReadWrite
	{
		get
		{
			return read_write;
		}
		set
		{
			read_write = value;
		}
	}

	public bool ApplyWindowsRuntimeProjections
	{
		get
		{
			return projections;
		}
		set
		{
			projections = value;
		}
	}

	public ReaderParameters()
		: this(ReadingMode.Deferred)
	{
	}

	public ReaderParameters(ReadingMode readingMode)
	{
		reading_mode = readingMode;
		throw_symbols_mismatch = true;
	}
}


using Mono.Cecil;

internal sealed class ModuleParameters
{
	private ModuleKind kind;

	private TargetRuntime runtime;

	private uint? timestamp;

	private TargetArchitecture architecture;

	private IAssemblyResolver assembly_resolver;

	private IMetadataResolver metadata_resolver;

	private IMetadataImporterProvider metadata_importer_provider;

	private IReflectionImporterProvider reflection_importer_provider;

	public ModuleKind Kind
	{
		get
		{
			return kind;
		}
		set
		{
			kind = value;
		}
	}

	public TargetRuntime Runtime
	{
		get
		{
			return runtime;
		}
		set
		{
			runtime = value;
		}
	}

	public uint? Timestamp
	{
		get
		{
			return timestamp;
		}
		set
		{
			timestamp = value;
		}
	}

	public TargetArchitecture Architecture
	{
		get
		{
			return architecture;
		}
		set
		{
			architecture = value;
		}
	}

	public IAssemblyResolver AssemblyResolver
	{
		get
		{
			return assembly_resolver;
		}
		set
		{
			assembly_resolver = value;
		}
	}

	public IMetadataResolver MetadataResolver
	{
		get
		{
			return metadata_resolver;
		}
		set
		{
			metadata_resolver = value;
		}
	}

	public IMetadataImporterProvider MetadataImporterProvider
	{
		get
		{
			return metadata_importer_provider;
		}
		set
		{
			metadata_importer_provider = value;
		}
	}

	public IReflectionImporterProvider ReflectionImporterProvider
	{
		get
		{
			return reflection_importer_provider;
		}
		set
		{
			reflection_importer_provider = value;
		}
	}

	public ModuleParameters()
	{
		kind = ModuleKind.Dll;
		Runtime = GetCurrentRuntime();
		architecture = TargetArchitecture.I386;
	}

	private static TargetRuntime GetCurrentRuntime()
	{
		return typeof(object).Assembly.ImageRuntimeVersion.ParseRuntime();
	}
}


using System.IO;
using System.Reflection;
using Mono.Cecil.Cil;

internal sealed class WriterParameters
{
	private uint? timestamp;

	private Stream symbol_stream;

	private ISymbolWriterProvider symbol_writer_provider;

	private bool write_symbols;

	private byte[] key_blob;

	private string key_container;

	private StrongNameKeyPair key_pair;

	public uint? Timestamp
	{
		get
		{
			return timestamp;
		}
		set
		{
			timestamp = value;
		}
	}

	public Stream SymbolStream
	{
		get
		{
			return symbol_stream;
		}
		set
		{
			symbol_stream = value;
		}
	}

	public ISymbolWriterProvider SymbolWriterProvider
	{
		get
		{
			return symbol_writer_provider;
		}
		set
		{
			symbol_writer_provider = value;
		}
	}

	public bool WriteSymbols
	{
		get
		{
			return write_symbols;
		}
		set
		{
			write_symbols = value;
		}
	}

	public bool HasStrongNameKey
	{
		get
		{
			if (key_pair == null && key_blob == null)
			{
				return key_container != null;
			}
			return true;
		}
	}

	public byte[] StrongNameKeyBlob
	{
		get
		{
			return key_blob;
		}
		set
		{
			key_blob = value;
		}
	}

	public string StrongNameKeyContainer
	{
		get
		{
			return key_container;
		}
		set
		{
			key_container = value;
		}
	}

	public StrongNameKeyPair StrongNameKeyPair
	{
		get
		{
			return key_pair;
		}
		set
		{
			key_pair = value;
		}
	}

	public bool DeterministicMvid { get; set; }
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class ModuleDefinition : ModuleReference, Mono.Cecil.ICustomAttributeProvider, IMetadataTokenProvider, ICustomDebugInformationProvider, IDisposable
{
	internal Image Image;

	internal MetadataSystem MetadataSystem;

	internal ReadingMode ReadingMode;

	internal ISymbolReaderProvider SymbolReaderProvider;

	internal ISymbolReader symbol_reader;

	internal Disposable<IAssemblyResolver> assembly_resolver;

	internal IMetadataResolver metadata_resolver;

	internal TypeSystem type_system;

	internal readonly MetadataReader reader;

	private readonly string file_name;

	internal string runtime_version;

	internal ModuleKind kind;

	private WindowsRuntimeProjections projections;

	private MetadataKind metadata_kind;

	private TargetRuntime runtime;

	private TargetArchitecture architecture;

	private ModuleAttributes attributes;

	private ModuleCharacteristics characteristics;

	private Guid mvid;

	internal ushort linker_version = 8;

	internal ushort subsystem_major = 4;

	internal ushort subsystem_minor;

	internal uint timestamp;

	internal AssemblyDefinition assembly;

	private MethodDefinition entry_point;

	private bool entry_point_set;

	internal IReflectionImporter reflection_importer;

	internal IMetadataImporter metadata_importer;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<AssemblyNameReference> references;

	private Collection<ModuleReference> modules;

	private Collection<Resource> resources;

	private Collection<ExportedType> exported_types;

	private TypeDefinitionCollection types;

	internal Collection<CustomDebugInformation> custom_infos;

	internal MetadataBuilder metadata_builder;

	private readonly object module_lock = new object();

	public bool IsMain => kind != ModuleKind.NetModule;

	public ModuleKind Kind
	{
		get
		{
			return kind;
		}
		set
		{
			kind = value;
		}
	}

	public MetadataKind MetadataKind
	{
		get
		{
			return metadata_kind;
		}
		set
		{
			metadata_kind = value;
		}
	}

	internal WindowsRuntimeProjections Projections
	{
		get
		{
			if (projections == null)
			{
				Interlocked.CompareExchange(ref projections, new WindowsRuntimeProjections(this), null);
			}
			return projections;
		}
	}

	public TargetRuntime Runtime
	{
		get
		{
			return runtime;
		}
		set
		{
			runtime = value;
			runtime_version = runtime.RuntimeVersionString();
		}
	}

	public string RuntimeVersion
	{
		get
		{
			return runtime_version;
		}
		set
		{
			runtime_version = value;
			runtime = runtime_version.ParseRuntime();
		}
	}

	public TargetArchitecture Architecture
	{
		get
		{
			return architecture;
		}
		set
		{
			architecture = value;
		}
	}

	public ModuleAttributes Attributes
	{
		get
		{
			return attributes;
		}
		set
		{
			attributes = value;
		}
	}

	public ModuleCharacteristics Characteristics
	{
		get
		{
			return characteristics;
		}
		set
		{
			characteristics = value;
		}
	}

	[Obsolete("Use FileName")]
	public string FullyQualifiedName => file_name;

	public string FileName => file_name;

	public Guid Mvid
	{
		get
		{
			return mvid;
		}
		set
		{
			mvid = value;
		}
	}

	internal bool HasImage => Image != null;

	public bool HasSymbols => symbol_reader != null;

	public ISymbolReader SymbolReader => symbol_reader;

	public override MetadataScopeType MetadataScopeType => MetadataScopeType.ModuleDefinition;

	public AssemblyDefinition Assembly => assembly;

	internal IReflectionImporter ReflectionImporter
	{
		get
		{
			if (reflection_importer == null)
			{
				Interlocked.CompareExchange(ref reflection_importer, new DefaultReflectionImporter(this), null);
			}
			return reflection_importer;
		}
	}

	internal IMetadataImporter MetadataImporter
	{
		get
		{
			if (metadata_importer == null)
			{
				Interlocked.CompareExchange(ref metadata_importer, new DefaultMetadataImporter(this), null);
			}
			return metadata_importer;
		}
	}

	public IAssemblyResolver AssemblyResolver
	{
		get
		{
			if (assembly_resolver.value == null)
			{
				lock (module_lock)
				{
					assembly_resolver = Disposable.Owned((IAssemblyResolver)new DefaultAssemblyResolver());
				}
			}
			return assembly_resolver.value;
		}
	}

	public IMetadataResolver MetadataResolver
	{
		get
		{
			if (metadata_resolver == null)
			{
				Interlocked.CompareExchange(ref metadata_resolver, new MetadataResolver(AssemblyResolver), null);
			}
			return metadata_resolver;
		}
	}

	public TypeSystem TypeSystem
	{
		get
		{
			if (type_system == null)
			{
				Interlocked.CompareExchange(ref type_system, TypeSystem.CreateTypeSystem(this), null);
			}
			return type_system;
		}
	}

	public bool HasAssemblyReferences
	{
		get
		{
			if (references != null)
			{
				return references.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.AssemblyRef);
			}
			return false;
		}
	}

	public Collection<AssemblyNameReference> AssemblyReferences
	{
		get
		{
			if (references != null)
			{
				return references;
			}
			if (HasImage)
			{
				return Read(ref references, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadAssemblyReferences());
			}
			Interlocked.CompareExchange(ref references, new Collection<AssemblyNameReference>(), null);
			return references;
		}
	}

	public bool HasModuleReferences
	{
		get
		{
			if (modules != null)
			{
				return modules.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.ModuleRef);
			}
			return false;
		}
	}

	public Collection<ModuleReference> ModuleReferences
	{
		get
		{
			if (modules != null)
			{
				return modules;
			}
			if (HasImage)
			{
				return Read(ref modules, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadModuleReferences());
			}
			Interlocked.CompareExchange(ref modules, new Collection<ModuleReference>(), null);
			return modules;
		}
	}

	public bool HasResources
	{
		get
		{
			if (resources != null)
			{
				return resources.Count > 0;
			}
			if (HasImage)
			{
				if (!Image.HasTable(Table.ManifestResource))
				{
					return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.HasFileResource());
				}
				return true;
			}
			return false;
		}
	}

	public Collection<Resource> Resources
	{
		get
		{
			if (resources != null)
			{
				return resources;
			}
			if (HasImage)
			{
				return Read(ref resources, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadResources());
			}
			Interlocked.CompareExchange(ref resources, new Collection<Resource>(), null);
			return resources;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(this);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, this);

	public bool HasTypes
	{
		get
		{
			if (types != null)
			{
				return types.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.TypeDef);
			}
			return false;
		}
	}

	public Collection<TypeDefinition> Types
	{
		get
		{
			if (types != null)
			{
				return types;
			}
			if (HasImage)
			{
				return Read(ref types, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadTypes());
			}
			Interlocked.CompareExchange(ref types, new TypeDefinitionCollection(this), null);
			return types;
		}
	}

	public bool HasExportedTypes
	{
		get
		{
			if (exported_types != null)
			{
				return exported_types.Count > 0;
			}
			if (HasImage)
			{
				return Image.HasTable(Table.ExportedType);
			}
			return false;
		}
	}

	public Collection<ExportedType> ExportedTypes
	{
		get
		{
			if (exported_types != null)
			{
				return exported_types;
			}
			if (HasImage)
			{
				return Read(ref exported_types, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadExportedTypes());
			}
			Interlocked.CompareExchange(ref exported_types, new Collection<ExportedType>(), null);
			return exported_types;
		}
	}

	public MethodDefinition EntryPoint
	{
		get
		{
			if (entry_point_set)
			{
				return entry_point;
			}
			if (HasImage)
			{
				Read(ref entry_point, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadEntryPoint());
			}
			else
			{
				entry_point = null;
			}
			entry_point_set = true;
			return entry_point;
		}
		set
		{
			entry_point = value;
			entry_point_set = true;
		}
	}

	public bool HasCustomDebugInformations
	{
		get
		{
			if (custom_infos != null)
			{
				return custom_infos.Count > 0;
			}
			return false;
		}
	}

	public Collection<CustomDebugInformation> CustomDebugInformations
	{
		get
		{
			if (custom_infos == null)
			{
				Interlocked.CompareExchange(ref custom_infos, new Collection<CustomDebugInformation>(), null);
			}
			return custom_infos;
		}
	}

	internal object SyncRoot => module_lock;

	public bool HasDebugHeader
	{
		get
		{
			if (Image != null)
			{
				return Image.DebugHeader != null;
			}
			return false;
		}
	}

	internal ModuleDefinition()
	{
		MetadataSystem = new MetadataSystem();
		token = new MetadataToken(TokenType.Module, 1);
	}

	internal ModuleDefinition(Image image)
		: this()
	{
		Image = image;
		kind = image.Kind;
		RuntimeVersion = image.RuntimeVersion;
		architecture = image.Architecture;
		attributes = image.Attributes;
		characteristics = image.DllCharacteristics;
		linker_version = image.LinkerVersion;
		subsystem_major = image.SubSystemMajor;
		subsystem_minor = image.SubSystemMinor;
		file_name = image.FileName;
		timestamp = image.Timestamp;
		reader = new MetadataReader(this);
	}

	public void Dispose()
	{
		if (Image != null)
		{
			Image.Dispose();
		}
		if (symbol_reader != null)
		{
			symbol_reader.Dispose();
		}
		if (assembly_resolver.value != null)
		{
			assembly_resolver.Dispose();
		}
	}

	public bool HasTypeReference(string fullName)
	{
		return HasTypeReference(string.Empty, fullName);
	}

	public bool HasTypeReference(string scope, string fullName)
	{
		Mixin.CheckFullName(fullName);
		if (!HasImage)
		{
			return false;
		}
		return GetTypeReference(scope, fullName) != null;
	}

	public bool TryGetTypeReference(string fullName, out TypeReference type)
	{
		return TryGetTypeReference(string.Empty, fullName, out type);
	}

	public bool TryGetTypeReference(string scope, string fullName, out TypeReference type)
	{
		Mixin.CheckFullName(fullName);
		if (!HasImage)
		{
			type = null;
			return false;
		}
		return (type = GetTypeReference(scope, fullName)) != null;
	}

	private TypeReference GetTypeReference(string scope, string fullname)
	{
		return Read(new Row<string, string>(scope, fullname), (Row<string, string> row, MetadataReader reader) => reader.GetTypeReference(row.Col1, row.Col2));
	}

	public IEnumerable<TypeReference> GetTypeReferences()
	{
		if (!HasImage)
		{
			return Empty<TypeReference>.Array;
		}
		return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetTypeReferences());
	}

	public IEnumerable<MemberReference> GetMemberReferences()
	{
		if (!HasImage)
		{
			return Empty<MemberReference>.Array;
		}
		return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetMemberReferences());
	}

	public IEnumerable<CustomAttribute> GetCustomAttributes()
	{
		if (!HasImage)
		{
			return Empty<CustomAttribute>.Array;
		}
		return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetCustomAttributes());
	}

	public TypeReference GetType(string fullName, bool runtimeName)
	{
		if (!runtimeName)
		{
			return GetType(fullName);
		}
		return TypeParser.ParseType(this, fullName, typeDefinitionOnly: true);
	}

	public TypeDefinition GetType(string fullName)
	{
		Mixin.CheckFullName(fullName);
		if (fullName.IndexOf('/') > 0)
		{
			return GetNestedType(fullName);
		}
		return ((TypeDefinitionCollection)Types).GetType(fullName);
	}

	public TypeDefinition GetType(string @namespace, string name)
	{
		Mixin.CheckName(name);
		return ((TypeDefinitionCollection)Types).GetType(@namespace ?? string.Empty, name);
	}

	public IEnumerable<TypeDefinition> GetTypes()
	{
		return GetTypes(Types);
	}

	private static IEnumerable<TypeDefinition> GetTypes(Collection<TypeDefinition> types)
	{
		for (int i = 0; i < types.Count; i++)
		{
			TypeDefinition type = types[i];
			yield return type;
			if (!type.HasNestedTypes)
			{
				continue;
			}
			foreach (TypeDefinition type2 in GetTypes(type.NestedTypes))
			{
				yield return type2;
			}
		}
	}

	private TypeDefinition GetNestedType(string fullname)
	{
		string[] array = fullname.Split(new char[1] { '/' });
		TypeDefinition typeDefinition = GetType(array[0]);
		if (typeDefinition == null)
		{
			return null;
		}
		for (int i = 1; i < array.Length; i++)
		{
			TypeDefinition nestedType = typeDefinition.GetNestedType(array[i]);
			if (nestedType == null)
			{
				return null;
			}
			typeDefinition = nestedType;
		}
		return typeDefinition;
	}

	internal FieldDefinition Resolve(FieldReference field)
	{
		return MetadataResolver.Resolve(field);
	}

	internal MethodDefinition Resolve(MethodReference method)
	{
		return MetadataResolver.Resolve(method);
	}

	internal TypeDefinition Resolve(TypeReference type)
	{
		return MetadataResolver.Resolve(type);
	}

	private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module)
	{
		if (context == null || context.Module == module)
		{
			return;
		}
		throw new ArgumentException();
	}

	[Obsolete("Use ImportReference", false)]
	public TypeReference Import(Type type)
	{
		return ImportReference(type, null);
	}

	public TypeReference ImportReference(Type type)
	{
		return ImportReference(type, null);
	}

	[Obsolete("Use ImportReference", false)]
	public TypeReference Import(Type type, IGenericParameterProvider context)
	{
		return ImportReference(type, context);
	}

	public TypeReference ImportReference(Type type, IGenericParameterProvider context)
	{
		Mixin.CheckType(type);
		CheckContext(context, this);
		return ReflectionImporter.ImportReference(type, context);
	}

	[Obsolete("Use ImportReference", false)]
	public FieldReference Import(FieldInfo field)
	{
		return ImportReference(field, null);
	}

	[Obsolete("Use ImportReference", false)]
	public FieldReference Import(FieldInfo field, IGenericParameterProvider context)
	{
		return ImportReference(field, context);
	}

	public FieldReference ImportReference(FieldInfo field)
	{
		return ImportReference(field, null);
	}

	public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context)
	{
		Mixin.CheckField(field);
		CheckContext(context, this);
		return ReflectionImporter.ImportReference(field, context);
	}

	[Obsolete("Use ImportReference", false)]
	public MethodReference Import(MethodBase method)
	{
		return ImportReference(method, null);
	}

	[Obsolete("Use ImportReference", false)]
	public MethodReference Import(MethodBase method, IGenericParameterProvider context)
	{
		return ImportReference(method, context);
	}

	public MethodReference ImportReference(MethodBase method)
	{
		return ImportReference(method, null);
	}

	public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context)
	{
		Mixin.CheckMethod(method);
		CheckContext(context, this);
		return ReflectionImporter.ImportReference(method, context);
	}

	[Obsolete("Use ImportReference", false)]
	public TypeReference Import(TypeReference type)
	{
		return ImportReference(type, null);
	}

	[Obsolete("Use ImportReference", false)]
	public TypeReference Import(TypeReference type, IGenericParameterProvider context)
	{
		return ImportReference(type, context);
	}

	public TypeReference ImportReference(TypeReference type)
	{
		return ImportReference(type, null);
	}

	public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context)
	{
		Mixin.CheckType(type);
		if (type.Module == this)
		{
			return type;
		}
		CheckContext(context, this);
		return MetadataImporter.ImportReference(type, context);
	}

	[Obsolete("Use ImportReference", false)]
	public FieldReference Import(FieldReference field)
	{
		return ImportReference(field, null);
	}

	[Obsolete("Use ImportReference", false)]
	public FieldReference Import(FieldReference field, IGenericParameterProvider context)
	{
		return ImportReference(field, context);
	}

	public FieldReference ImportReference(FieldReference field)
	{
		return ImportReference(field, null);
	}

	public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context)
	{
		Mixin.CheckField(field);
		if (field.Module == this)
		{
			return field;
		}
		CheckContext(context, this);
		return MetadataImporter.ImportReference(field, context);
	}

	[Obsolete("Use ImportReference", false)]
	public MethodReference Import(MethodReference method)
	{
		return ImportReference(method, null);
	}

	[Obsolete("Use ImportReference", false)]
	public MethodReference Import(MethodReference method, IGenericParameterProvider context)
	{
		return ImportReference(method, context);
	}

	public MethodReference ImportReference(MethodReference method)
	{
		return ImportReference(method, null);
	}

	public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context)
	{
		Mixin.CheckMethod(method);
		if (method.Module == this)
		{
			return method;
		}
		CheckContext(context, this);
		return MetadataImporter.ImportReference(method, context);
	}

	public IMetadataTokenProvider LookupToken(int token)
	{
		return LookupToken(new MetadataToken((uint)token));
	}

	public IMetadataTokenProvider LookupToken(MetadataToken token)
	{
		return Read(token, (MetadataToken t, MetadataReader reader) => reader.LookupToken(t));
	}

	public void ImmediateRead()
	{
		if (HasImage)
		{
			ReadingMode = ReadingMode.Immediate;
			new ImmediateModuleReader(Image).ReadModule(this, resolve_attributes: true);
		}
	}

	internal void Read<TItem>(TItem item, Action<TItem, MetadataReader> read)
	{
		lock (module_lock)
		{
			int position = reader.position;
			IGenericContext context = reader.context;
			read(item, reader);
			reader.position = position;
			reader.context = context;
		}
	}

	internal TRet Read<TItem, TRet>(TItem item, Func<TItem, MetadataReader, TRet> read)
	{
		lock (module_lock)
		{
			int position = reader.position;
			IGenericContext context = reader.context;
			TRet result = read(item, reader);
			reader.position = position;
			reader.context = context;
			return result;
		}
	}

	internal TRet Read<TItem, TRet>(ref TRet variable, TItem item, Func<TItem, MetadataReader, TRet> read) where TRet : class
	{
		lock (module_lock)
		{
			if (variable != null)
			{
				return variable;
			}
			int position = reader.position;
			IGenericContext context = reader.context;
			TRet val = read(item, reader);
			reader.position = position;
			reader.context = context;
			return variable = val;
		}
	}

	public ImageDebugHeader GetDebugHeader()
	{
		return Image.DebugHeader ?? new ImageDebugHeader();
	}

	public static ModuleDefinition CreateModule(string name, ModuleKind kind)
	{
		return CreateModule(name, new ModuleParameters
		{
			Kind = kind
		});
	}

	public static ModuleDefinition CreateModule(string name, ModuleParameters parameters)
	{
		Mixin.CheckName(name);
		Mixin.CheckParameters(parameters);
		ModuleDefinition moduleDefinition = new ModuleDefinition
		{
			Name = name,
			kind = parameters.Kind,
			timestamp = (parameters.Timestamp ?? Mixin.GetTimestamp()),
			Runtime = parameters.Runtime,
			architecture = parameters.Architecture,
			mvid = Guid.NewGuid(),
			Attributes = ModuleAttributes.ILOnly,
			Characteristics = (ModuleCharacteristics.DynamicBase | ModuleCharacteristics.NoSEH | ModuleCharacteristics.NXCompat | ModuleCharacteristics.TerminalServerAware)
		};
		if (parameters.AssemblyResolver != null)
		{
			moduleDefinition.assembly_resolver = Disposable.NotOwned(parameters.AssemblyResolver);
		}
		if (parameters.MetadataResolver != null)
		{
			moduleDefinition.metadata_resolver = parameters.MetadataResolver;
		}
		if (parameters.MetadataImporterProvider != null)
		{
			moduleDefinition.metadata_importer = parameters.MetadataImporterProvider.GetMetadataImporter(moduleDefinition);
		}
		if (parameters.ReflectionImporterProvider != null)
		{
			moduleDefinition.reflection_importer = parameters.ReflectionImporterProvider.GetReflectionImporter(moduleDefinition);
		}
		if (parameters.Kind != ModuleKind.NetModule)
		{
			AssemblyDefinition assemblyDefinition = (moduleDefinition.assembly = new AssemblyDefinition());
			moduleDefinition.assembly.Name = CreateAssemblyName(name);
			assemblyDefinition.main_module = moduleDefinition;
		}
		moduleDefinition.Types.Add(new TypeDefinition(string.Empty, "<Module>", Mono.Cecil.TypeAttributes.NotPublic));
		return moduleDefinition;
	}

	private static AssemblyNameDefinition CreateAssemblyName(string name)
	{
		if (name.EndsWith(".dll") || name.EndsWith(".exe"))
		{
			name = name.Substring(0, name.Length - 4);
		}
		return new AssemblyNameDefinition(name, Mixin.ZeroVersion);
	}

	public void ReadSymbols()
	{
		if (string.IsNullOrEmpty(file_name))
		{
			throw new InvalidOperationException();
		}
		DefaultSymbolReaderProvider defaultSymbolReaderProvider = new DefaultSymbolReaderProvider(throwIfNoSymbol: true);
		ReadSymbols(defaultSymbolReaderProvider.GetSymbolReader(this, file_name), throwIfSymbolsAreNotMaching: true);
	}

	public void ReadSymbols(ISymbolReader reader)
	{
		ReadSymbols(reader, throwIfSymbolsAreNotMaching: true);
	}

	public void ReadSymbols(ISymbolReader reader, bool throwIfSymbolsAreNotMaching)
	{
		if (reader == null)
		{
			throw new ArgumentNullException("reader");
		}
		symbol_reader = reader;
		if (!symbol_reader.ProcessDebugHeader(GetDebugHeader()))
		{
			symbol_reader = null;
			if (throwIfSymbolsAreNotMaching)
			{
				throw new SymbolsNotMatchingException("Symbols were found but are not matching the assembly");
			}
		}
		else if (HasImage && ReadingMode == ReadingMode.Immediate)
		{
			new ImmediateModuleReader(Image).ReadSymbols(this);
		}
	}

	public static ModuleDefinition ReadModule(string fileName)
	{
		return ReadModule(fileName, new ReaderParameters(ReadingMode.Deferred));
	}

	public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters)
	{
		Stream stream = GetFileStream(fileName, FileMode.Open, (!parameters.ReadWrite) ? FileAccess.Read : FileAccess.ReadWrite, FileShare.Read);
		if (parameters.InMemory)
		{
			MemoryStream memoryStream = new MemoryStream((int)(stream.CanSeek ? stream.Length : 0));
			using (stream)
			{
				stream.CopyTo(memoryStream);
			}
			memoryStream.Position = 0L;
			stream = memoryStream;
		}
		try
		{
			return ReadModule(Disposable.Owned(stream), fileName, parameters);
		}
		catch (Exception)
		{
			stream.Dispose();
			throw;
		}
	}

	private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share)
	{
		Mixin.CheckFileName(fileName);
		return new FileStream(fileName, mode, access, share);
	}

	public static ModuleDefinition ReadModule(Stream stream)
	{
		return ReadModule(stream, new ReaderParameters(ReadingMode.Deferred));
	}

	public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters)
	{
		Mixin.CheckStream(stream);
		Mixin.CheckReadSeek(stream);
		return ReadModule(Disposable.NotOwned(stream), stream.GetFileName(), parameters);
	}

	private static ModuleDefinition ReadModule(Disposable<Stream> stream, string fileName, ReaderParameters parameters)
	{
		Mixin.CheckParameters(parameters);
		return ModuleReader.CreateModule(ImageReader.ReadImage(stream, fileName), parameters);
	}

	public void Write(string fileName)
	{
		Write(fileName, new WriterParameters());
	}

	public void Write(string fileName, WriterParameters parameters)
	{
		Mixin.CheckParameters(parameters);
		Stream fileStream = GetFileStream(fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.Read);
		ModuleWriter.WriteModule(this, Disposable.Owned(fileStream), parameters);
	}

	public void Write()
	{
		Write(new WriterParameters());
	}

	public void Write(WriterParameters parameters)
	{
		if (!HasImage)
		{
			throw new InvalidOperationException();
		}
		Write(Image.Stream.value, parameters);
	}

	public void Write(Stream stream)
	{
		Write(stream, new WriterParameters());
	}

	public void Write(Stream stream, WriterParameters parameters)
	{
		Mixin.CheckStream(stream);
		Mixin.CheckWriteSeek(stream);
		Mixin.CheckParameters(parameters);
		ModuleWriter.WriteModule(this, Disposable.NotOwned(stream), parameters);
	}
}


internal enum ModuleKind
{
	Dll,
	Console,
	Windows,
	NetModule
}


internal enum MetadataKind
{
	Ecma335,
	WindowsMetadata,
	ManagedWindowsMetadata
}


internal enum TargetArchitecture
{
	I386 = 332,
	AMD64 = 34404,
	IA64 = 512,
	ARM = 448,
	ARMv7 = 452,
	ARM64 = 43620
}


using System;

[Flags]
internal enum ModuleAttributes
{
	ILOnly = 1,
	Required32Bit = 2,
	ILLibrary = 4,
	StrongNameSigned = 8,
	Preferred32Bit = 0x20000
}


using System;

[Flags]
internal enum ModuleCharacteristics
{
	HighEntropyVA = 0x20,
	DynamicBase = 0x40,
	NoSEH = 0x400,
	NXCompat = 0x100,
	AppContainer = 0x1000,
	TerminalServerAware = 0x8000
}


using Mono.Cecil;

internal class ModuleReference : IMetadataScope, IMetadataTokenProvider
{
	private string name;

	internal MetadataToken token;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public virtual MetadataScopeType MetadataScopeType => MetadataScopeType.ModuleReference;

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal ModuleReference()
	{
		token = new MetadataToken(TokenType.ModuleRef);
	}

	public ModuleReference(string name)
		: this()
	{
		this.name = name;
	}

	public override string ToString()
	{
		return name;
	}
}


internal enum NativeType
{
	None = 102,
	Boolean = 2,
	I1 = 3,
	U1 = 4,
	I2 = 5,
	U2 = 6,
	I4 = 7,
	U4 = 8,
	I8 = 9,
	U8 = 10,
	R4 = 11,
	R8 = 12,
	LPStr = 20,
	Int = 31,
	UInt = 32,
	Func = 38,
	Array = 42,
	Currency = 15,
	BStr = 19,
	LPWStr = 21,
	LPTStr = 22,
	FixedSysString = 23,
	IUnknown = 25,
	IDispatch = 26,
	Struct = 27,
	IntF = 28,
	SafeArray = 29,
	FixedArray = 30,
	ByValStr = 34,
	ANSIBStr = 35,
	TBStr = 36,
	VariantBool = 37,
	ASAny = 40,
	LPStruct = 43,
	CustomMarshaler = 44,
	Error = 45,
	Max = 80
}


using System;

[Flags]
internal enum ParameterAttributes : ushort
{
	None = 0,
	In = 1,
	Out = 2,
	Lcid = 4,
	Retval = 8,
	Optional = 0x10,
	HasDefault = 0x1000,
	HasFieldMarshal = 0x2000,
	Unused = 0xCFE0
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class ParameterDefinition : ParameterReference, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider, IMarshalInfoProvider
{
	private ushort attributes;

	internal IMethodSignature method;

	private object constant = Mixin.NotResolved;

	private Collection<CustomAttribute> custom_attributes;

	private MarshalInfo marshal_info;

	public ParameterAttributes Attributes
	{
		get
		{
			return (ParameterAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public IMethodSignature Method => method;

	public int Sequence
	{
		get
		{
			if (method == null)
			{
				return -1;
			}
			if (!method.HasImplicitThis())
			{
				return index;
			}
			return index + 1;
		}
	}

	public bool HasConstant
	{
		get
		{
			this.ResolveConstant(ref constant, parameter_type.Module);
			return constant != Mixin.NoValue;
		}
		set
		{
			if (!value)
			{
				constant = Mixin.NoValue;
			}
		}
	}

	public object Constant
	{
		get
		{
			if (!HasConstant)
			{
				return null;
			}
			return constant;
		}
		set
		{
			constant = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(parameter_type.Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, parameter_type.Module);

	public bool HasMarshalInfo
	{
		get
		{
			if (marshal_info != null)
			{
				return true;
			}
			return this.GetHasMarshalInfo(parameter_type.Module);
		}
	}

	public MarshalInfo MarshalInfo
	{
		get
		{
			return marshal_info ?? this.GetMarshalInfo(ref marshal_info, parameter_type.Module);
		}
		set
		{
			marshal_info = value;
		}
	}

	public bool IsIn
	{
		get
		{
			return attributes.GetAttributes(1);
		}
		set
		{
			attributes = attributes.SetAttributes(1, value);
		}
	}

	public bool IsOut
	{
		get
		{
			return attributes.GetAttributes(2);
		}
		set
		{
			attributes = attributes.SetAttributes(2, value);
		}
	}

	public bool IsLcid
	{
		get
		{
			return attributes.GetAttributes(4);
		}
		set
		{
			attributes = attributes.SetAttributes(4, value);
		}
	}

	public bool IsReturnValue
	{
		get
		{
			return attributes.GetAttributes(8);
		}
		set
		{
			attributes = attributes.SetAttributes(8, value);
		}
	}

	public bool IsOptional
	{
		get
		{
			return attributes.GetAttributes(16);
		}
		set
		{
			attributes = attributes.SetAttributes(16, value);
		}
	}

	public bool HasDefault
	{
		get
		{
			return attributes.GetAttributes(4096);
		}
		set
		{
			attributes = attributes.SetAttributes(4096, value);
		}
	}

	public bool HasFieldMarshal
	{
		get
		{
			return attributes.GetAttributes(8192);
		}
		set
		{
			attributes = attributes.SetAttributes(8192, value);
		}
	}

	internal ParameterDefinition(TypeReference parameterType, IMethodSignature method)
		: this(string.Empty, ParameterAttributes.None, parameterType)
	{
		this.method = method;
	}

	public ParameterDefinition(TypeReference parameterType)
		: this(string.Empty, ParameterAttributes.None, parameterType)
	{
	}

	public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType)
		: base(name, parameterType)
	{
		this.attributes = (ushort)attributes;
		token = new MetadataToken(TokenType.Param);
	}

	public override ParameterDefinition Resolve()
	{
		return this;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class ParameterDefinitionCollection : Collection<ParameterDefinition>
{
	private readonly IMethodSignature method;

	internal ParameterDefinitionCollection(IMethodSignature method)
	{
		this.method = method;
	}

	internal ParameterDefinitionCollection(IMethodSignature method, int capacity)
		: base(capacity)
	{
		this.method = method;
	}

	protected override void OnAdd(ParameterDefinition item, int index)
	{
		item.method = method;
		item.index = index;
	}

	protected override void OnInsert(ParameterDefinition item, int index)
	{
		item.method = method;
		item.index = index;
		for (int i = index; i < size; i++)
		{
			items[i].index = i + 1;
		}
	}

	protected override void OnSet(ParameterDefinition item, int index)
	{
		item.method = method;
		item.index = index;
	}

	protected override void OnRemove(ParameterDefinition item, int index)
	{
		item.method = null;
		item.index = -1;
		for (int i = index + 1; i < size; i++)
		{
			items[i].index = i - 1;
		}
	}
}


using System;
using Mono.Cecil;

internal abstract class ParameterReference : IMetadataTokenProvider
{
	private string name;

	internal int index = -1;

	protected TypeReference parameter_type;

	internal MetadataToken token;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public int Index => index;

	public TypeReference ParameterType
	{
		get
		{
			return parameter_type;
		}
		set
		{
			parameter_type = value;
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal ParameterReference(string name, TypeReference parameterType)
	{
		if (parameterType == null)
		{
			throw new ArgumentNullException("parameterType");
		}
		this.name = name ?? string.Empty;
		parameter_type = parameterType;
	}

	public override string ToString()
	{
		return name;
	}

	public abstract ParameterDefinition Resolve();
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class PinnedType : TypeSpecification
{
	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsPinned => true;

	public PinnedType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Pinned;
	}
}


using System;

[Flags]
internal enum PInvokeAttributes : ushort
{
	NoMangle = 1,
	CharSetMask = 6,
	CharSetNotSpec = 0,
	CharSetAnsi = 2,
	CharSetUnicode = 4,
	CharSetAuto = 6,
	SupportsLastError = 0x40,
	CallConvMask = 0x700,
	CallConvWinapi = 0x100,
	CallConvCdecl = 0x200,
	CallConvStdCall = 0x300,
	CallConvThiscall = 0x400,
	CallConvFastcall = 0x500,
	BestFitMask = 0x30,
	BestFitEnabled = 0x10,
	BestFitDisabled = 0x20,
	ThrowOnUnmappableCharMask = 0x3000,
	ThrowOnUnmappableCharEnabled = 0x1000,
	ThrowOnUnmappableCharDisabled = 0x2000
}


using Mono.Cecil;

internal sealed class PInvokeInfo
{
	private ushort attributes;

	private string entry_point;

	private ModuleReference module;

	public PInvokeAttributes Attributes
	{
		get
		{
			return (PInvokeAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public string EntryPoint
	{
		get
		{
			return entry_point;
		}
		set
		{
			entry_point = value;
		}
	}

	public ModuleReference Module
	{
		get
		{
			return module;
		}
		set
		{
			module = value;
		}
	}

	public bool IsNoMangle
	{
		get
		{
			return attributes.GetAttributes(1);
		}
		set
		{
			attributes = attributes.SetAttributes(1, value);
		}
	}

	public bool IsCharSetNotSpec
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 0u, value);
		}
	}

	public bool IsCharSetAnsi
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 2u, value);
		}
	}

	public bool IsCharSetUnicode
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 4u, value);
		}
	}

	public bool IsCharSetAuto
	{
		get
		{
			return attributes.GetMaskedAttributes(6, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(6, 6u, value);
		}
	}

	public bool SupportsLastError
	{
		get
		{
			return attributes.GetAttributes(64);
		}
		set
		{
			attributes = attributes.SetAttributes(64, value);
		}
	}

	public bool IsCallConvWinapi
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 256u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 256u, value);
		}
	}

	public bool IsCallConvCdecl
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 512u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 512u, value);
		}
	}

	public bool IsCallConvStdCall
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 768u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 768u, value);
		}
	}

	public bool IsCallConvThiscall
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 1024u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 1024u, value);
		}
	}

	public bool IsCallConvFastcall
	{
		get
		{
			return attributes.GetMaskedAttributes(1792, 1280u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(1792, 1280u, value);
		}
	}

	public bool IsBestFitEnabled
	{
		get
		{
			return attributes.GetMaskedAttributes(48, 16u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(48, 16u, value);
		}
	}

	public bool IsBestFitDisabled
	{
		get
		{
			return attributes.GetMaskedAttributes(48, 32u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(48, 32u, value);
		}
	}

	public bool IsThrowOnUnmappableCharEnabled
	{
		get
		{
			return attributes.GetMaskedAttributes(12288, 4096u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(12288, 4096u, value);
		}
	}

	public bool IsThrowOnUnmappableCharDisabled
	{
		get
		{
			return attributes.GetMaskedAttributes(12288, 8192u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(12288, 8192u, value);
		}
	}

	public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module)
	{
		this.attributes = (ushort)attributes;
		entry_point = entryPoint;
		this.module = module;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class PointerType : TypeSpecification
{
	public override string Name => base.Name + "*";

	public override string FullName => base.FullName + "*";

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsPointer => true;

	public PointerType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Ptr;
	}
}


using System;

[Flags]
internal enum PropertyAttributes : ushort
{
	None = 0,
	SpecialName = 0x200,
	RTSpecialName = 0x400,
	HasDefault = 0x1000,
	Unused = 0xE9FF
}


using System.Text;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class PropertyDefinition : PropertyReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider
{
	private bool? has_this;

	private ushort attributes;

	private Collection<CustomAttribute> custom_attributes;

	internal MethodDefinition get_method;

	internal MethodDefinition set_method;

	internal Collection<MethodDefinition> other_methods;

	private object constant = Mixin.NotResolved;

	public PropertyAttributes Attributes
	{
		get
		{
			return (PropertyAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public bool HasThis
	{
		get
		{
			if (has_this.HasValue)
			{
				return has_this.Value;
			}
			if (GetMethod != null)
			{
				return get_method.HasThis;
			}
			if (SetMethod != null)
			{
				return set_method.HasThis;
			}
			return false;
		}
		set
		{
			has_this = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public MethodDefinition GetMethod
	{
		get
		{
			if (get_method != null)
			{
				return get_method;
			}
			InitializeMethods();
			return get_method;
		}
		set
		{
			get_method = value;
		}
	}

	public MethodDefinition SetMethod
	{
		get
		{
			if (set_method != null)
			{
				return set_method;
			}
			InitializeMethods();
			return set_method;
		}
		set
		{
			set_method = value;
		}
	}

	public bool HasOtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods.Count > 0;
			}
			InitializeMethods();
			return !other_methods.IsNullOrEmpty();
		}
	}

	public Collection<MethodDefinition> OtherMethods
	{
		get
		{
			if (other_methods != null)
			{
				return other_methods;
			}
			InitializeMethods();
			if (other_methods != null)
			{
				return other_methods;
			}
			Interlocked.CompareExchange(ref other_methods, new Collection<MethodDefinition>(), null);
			return other_methods;
		}
	}

	public bool HasParameters
	{
		get
		{
			InitializeMethods();
			if (get_method != null)
			{
				return get_method.HasParameters;
			}
			if (set_method != null)
			{
				if (set_method.HasParameters)
				{
					return set_method.Parameters.Count > 1;
				}
				return false;
			}
			return false;
		}
	}

	public override Collection<ParameterDefinition> Parameters
	{
		get
		{
			InitializeMethods();
			if (get_method != null)
			{
				return MirrorParameters(get_method, 0);
			}
			if (set_method != null)
			{
				return MirrorParameters(set_method, 1);
			}
			return new Collection<ParameterDefinition>();
		}
	}

	public bool HasConstant
	{
		get
		{
			this.ResolveConstant(ref constant, Module);
			return constant != Mixin.NoValue;
		}
		set
		{
			if (!value)
			{
				constant = Mixin.NoValue;
			}
		}
	}

	public object Constant
	{
		get
		{
			if (!HasConstant)
			{
				return null;
			}
			return constant;
		}
		set
		{
			constant = value;
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(512);
		}
		set
		{
			attributes = attributes.SetAttributes(512, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024);
		}
		set
		{
			attributes = attributes.SetAttributes(1024, value);
		}
	}

	public bool HasDefault
	{
		get
		{
			return attributes.GetAttributes(4096);
		}
		set
		{
			attributes = attributes.SetAttributes(4096, value);
		}
	}

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	public override bool IsDefinition => true;

	public override string FullName
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(base.PropertyType.ToString());
			stringBuilder.Append(' ');
			stringBuilder.Append(MemberFullName());
			stringBuilder.Append('(');
			if (HasParameters)
			{
				Collection<ParameterDefinition> parameters = Parameters;
				for (int i = 0; i < parameters.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append(',');
					}
					stringBuilder.Append(parameters[i].ParameterType.FullName);
				}
			}
			stringBuilder.Append(')');
			return stringBuilder.ToString();
		}
	}

	private static Collection<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound)
	{
		Collection<ParameterDefinition> collection = new Collection<ParameterDefinition>();
		if (!method.HasParameters)
		{
			return collection;
		}
		Collection<ParameterDefinition> parameters = method.Parameters;
		int num = parameters.Count - bound;
		for (int i = 0; i < num; i++)
		{
			collection.Add(parameters[i]);
		}
		return collection;
	}

	public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType)
		: base(name, propertyType)
	{
		this.attributes = (ushort)attributes;
		token = new MetadataToken(TokenType.Property);
	}

	private void InitializeMethods()
	{
		ModuleDefinition module = Module;
		if (module == null)
		{
			return;
		}
		lock (module.SyncRoot)
		{
			if (get_method == null && set_method == null && module.HasImage())
			{
				module.Read(this, delegate(PropertyDefinition property, MetadataReader reader)
				{
					reader.ReadMethods(property);
				});
			}
		}
	}

	public override PropertyDefinition Resolve()
	{
		return this;
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal abstract class PropertyReference : MemberReference
{
	private TypeReference property_type;

	public TypeReference PropertyType
	{
		get
		{
			return property_type;
		}
		set
		{
			property_type = value;
		}
	}

	public abstract Collection<ParameterDefinition> Parameters { get; }

	internal PropertyReference(string name, TypeReference propertyType)
		: base(name)
	{
		Mixin.CheckType(propertyType, Mixin.Argument.propertyType);
		property_type = propertyType;
	}

	protected override IMemberDefinition ResolveDefinition()
	{
		return Resolve();
	}

	public new abstract PropertyDefinition Resolve();
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class ByReferenceType : TypeSpecification
{
	public override string Name => base.Name + "&";

	public override string FullName => base.FullName + "&";

	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsByReference => true;

	public ByReferenceType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.ByRef;
	}
}


internal enum ResourceType
{
	Linked,
	Embedded,
	AssemblyLinked
}


using Mono.Cecil;

internal abstract class Resource
{
	private string name;

	private uint attributes;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public ManifestResourceAttributes Attributes
	{
		get
		{
			return (ManifestResourceAttributes)attributes;
		}
		set
		{
			attributes = (uint)value;
		}
	}

	public abstract ResourceType ResourceType { get; }

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 1u, value);
		}
	}

	public bool IsPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 2u, value);
		}
	}

	internal Resource(string name, ManifestResourceAttributes attributes)
	{
		this.name = name;
		this.attributes = (uint)attributes;
	}
}


internal enum SecurityAction : ushort
{
	Request = 1,
	Demand,
	Assert,
	Deny,
	PermitOnly,
	LinkDemand,
	InheritDemand,
	RequestMinimum,
	RequestOptional,
	RequestRefuse,
	PreJitGrant,
	PreJitDeny,
	NonCasDemand,
	NonCasLinkDemand,
	NonCasInheritance
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal interface ISecurityDeclarationProvider : IMetadataTokenProvider
{
	bool HasSecurityDeclarations { get; }

	Collection<SecurityDeclaration> SecurityDeclarations { get; }
}


using System;
using System.Diagnostics;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

[DebuggerDisplay("{AttributeType}")]
internal sealed class SecurityAttribute : ICustomAttribute
{
	private TypeReference attribute_type;

	internal Collection<CustomAttributeNamedArgument> fields;

	internal Collection<CustomAttributeNamedArgument> properties;

	public TypeReference AttributeType
	{
		get
		{
			return attribute_type;
		}
		set
		{
			attribute_type = value;
		}
	}

	public bool HasFields => !fields.IsNullOrEmpty();

	public Collection<CustomAttributeNamedArgument> Fields
	{
		get
		{
			if (fields == null)
			{
				Interlocked.CompareExchange(ref fields, new Collection<CustomAttributeNamedArgument>(), null);
			}
			return fields;
		}
	}

	public bool HasProperties => !properties.IsNullOrEmpty();

	public Collection<CustomAttributeNamedArgument> Properties
	{
		get
		{
			if (properties == null)
			{
				Interlocked.CompareExchange(ref properties, new Collection<CustomAttributeNamedArgument>(), null);
			}
			return properties;
		}
	}

	bool ICustomAttribute.HasConstructorArguments => false;

	Collection<CustomAttributeArgument> ICustomAttribute.ConstructorArguments
	{
		get
		{
			throw new NotSupportedException();
		}
	}

	public SecurityAttribute(TypeReference attributeType)
	{
		attribute_type = attributeType;
	}
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class SecurityDeclaration
{
	internal readonly uint signature;

	private byte[] blob;

	private readonly ModuleDefinition module;

	internal bool resolved;

	private SecurityAction action;

	internal Collection<SecurityAttribute> security_attributes;

	public SecurityAction Action
	{
		get
		{
			return action;
		}
		set
		{
			action = value;
		}
	}

	public bool HasSecurityAttributes
	{
		get
		{
			Resolve();
			return !security_attributes.IsNullOrEmpty();
		}
	}

	public Collection<SecurityAttribute> SecurityAttributes
	{
		get
		{
			Resolve();
			if (security_attributes == null)
			{
				Interlocked.CompareExchange(ref security_attributes, new Collection<SecurityAttribute>(), null);
			}
			return security_attributes;
		}
	}

	internal bool HasImage
	{
		get
		{
			if (module != null)
			{
				return module.HasImage;
			}
			return false;
		}
	}

	internal SecurityDeclaration(SecurityAction action, uint signature, ModuleDefinition module)
	{
		this.action = action;
		this.signature = signature;
		this.module = module;
	}

	public SecurityDeclaration(SecurityAction action)
	{
		this.action = action;
		resolved = true;
	}

	public SecurityDeclaration(SecurityAction action, byte[] blob)
	{
		this.action = action;
		resolved = false;
		this.blob = blob;
	}

	public byte[] GetBlob()
	{
		if (blob != null)
		{
			return blob;
		}
		if (!HasImage || signature == 0)
		{
			throw new NotSupportedException();
		}
		return module.Read(ref blob, this, (SecurityDeclaration declaration, MetadataReader reader) => reader.ReadSecurityDeclarationBlob(declaration.signature));
	}

	private void Resolve()
	{
		if (resolved || !HasImage)
		{
			return;
		}
		lock (module.SyncRoot)
		{
			if (!resolved)
			{
				module.Read(this, delegate(SecurityDeclaration declaration, MetadataReader reader)
				{
					reader.ReadSecurityDeclarationSignature(declaration);
				});
				resolved = true;
			}
		}
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class SentinelType : TypeSpecification
{
	public override bool IsValueType
	{
		get
		{
			return false;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override bool IsSentinel => true;

	public SentinelType(TypeReference type)
		: base(type)
	{
		Mixin.CheckType(type);
		etype = Mono.Cecil.Metadata.ElementType.Sentinel;
	}
}


internal enum TargetRuntime
{
	Net_1_0,
	Net_1_1,
	Net_2_0,
	Net_4_0
}


using System;

[Flags]
internal enum TypeDefinitionTreatment
{
	None = 0,
	KindMask = 0xF,
	NormalType = 1,
	NormalAttribute = 2,
	UnmangleWindowsRuntimeName = 3,
	PrefixWindowsRuntimeName = 4,
	RedirectToClrType = 5,
	RedirectToClrAttribute = 6,
	RedirectImplementedMethods = 7,
	Abstract = 0x10,
	Internal = 0x20
}


internal enum TypeReferenceTreatment
{
	None,
	SystemDelegate,
	SystemAttribute,
	UseProjectionInfo
}


using System;

[Flags]
internal enum MethodDefinitionTreatment
{
	None = 0,
	Abstract = 2,
	Private = 4,
	Public = 8,
	Runtime = 0x10,
	InternalCall = 0x20
}


internal enum FieldDefinitionTreatment
{
	None,
	Public
}


internal enum CustomAttributeValueTreatment
{
	None,
	AllowSingle,
	AllowMultiple,
	VersionAttribute,
	DeprecatedAttribute
}


using System;

[Flags]
internal enum TypeAttributes : uint
{
	VisibilityMask = 7u,
	NotPublic = 0u,
	Public = 1u,
	NestedPublic = 2u,
	NestedPrivate = 3u,
	NestedFamily = 4u,
	NestedAssembly = 5u,
	NestedFamANDAssem = 6u,
	NestedFamORAssem = 7u,
	LayoutMask = 0x18u,
	AutoLayout = 0u,
	SequentialLayout = 8u,
	ExplicitLayout = 0x10u,
	ClassSemanticMask = 0x20u,
	Class = 0u,
	Interface = 0x20u,
	Abstract = 0x80u,
	Sealed = 0x100u,
	SpecialName = 0x400u,
	Import = 0x1000u,
	Serializable = 0x2000u,
	WindowsRuntime = 0x4000u,
	StringFormatMask = 0x30000u,
	AnsiClass = 0u,
	UnicodeClass = 0x10000u,
	AutoClass = 0x20000u,
	BeforeFieldInit = 0x100000u,
	RTSpecialName = 0x800u,
	HasSecurity = 0x40000u,
	Forwarder = 0x200000u
}


internal enum TypeComparisonMode
{
	Exact,
	SignatureOnly,
	SignatureOnlyLoose
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class TypeDefinition : TypeReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
{
	private uint attributes;

	private TypeReference base_type;

	internal Mono.Cecil.Range fields_range;

	internal Mono.Cecil.Range methods_range;

	private short packing_size = -2;

	private int class_size = -2;

	private InterfaceImplementationCollection interfaces;

	private Collection<TypeDefinition> nested_types;

	private Collection<MethodDefinition> methods;

	private Collection<FieldDefinition> fields;

	private Collection<EventDefinition> events;

	private Collection<PropertyDefinition> properties;

	private Collection<CustomAttribute> custom_attributes;

	private Collection<SecurityDeclaration> security_declarations;

	public TypeAttributes Attributes
	{
		get
		{
			return (TypeAttributes)attributes;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && (ushort)value != attributes)
			{
				throw new InvalidOperationException();
			}
			attributes = (uint)value;
		}
	}

	public TypeReference BaseType
	{
		get
		{
			return base_type;
		}
		set
		{
			base_type = value;
		}
	}

	public override string Name
	{
		get
		{
			return base.Name;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && value != base.Name)
			{
				throw new InvalidOperationException();
			}
			base.Name = value;
		}
	}

	public bool HasLayoutInfo
	{
		get
		{
			if (packing_size >= 0 || class_size >= 0)
			{
				return true;
			}
			ResolveLayout();
			if (packing_size < 0)
			{
				return class_size >= 0;
			}
			return true;
		}
	}

	public short PackingSize
	{
		get
		{
			if (packing_size >= 0)
			{
				return packing_size;
			}
			ResolveLayout();
			if (packing_size < 0)
			{
				return -1;
			}
			return packing_size;
		}
		set
		{
			packing_size = value;
		}
	}

	public int ClassSize
	{
		get
		{
			if (class_size >= 0)
			{
				return class_size;
			}
			ResolveLayout();
			if (class_size < 0)
			{
				return -1;
			}
			return class_size;
		}
		set
		{
			class_size = value;
		}
	}

	public bool HasInterfaces
	{
		get
		{
			if (interfaces != null)
			{
				return interfaces.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasInterfaces(type));
			}
			return false;
		}
	}

	public Collection<InterfaceImplementation> Interfaces
	{
		get
		{
			if (interfaces != null)
			{
				return interfaces;
			}
			if (base.HasImage)
			{
				return Module.Read(ref interfaces, this, (TypeDefinition type, MetadataReader reader) => reader.ReadInterfaces(type));
			}
			Interlocked.CompareExchange(ref interfaces, new InterfaceImplementationCollection(this), null);
			return interfaces;
		}
	}

	public bool HasNestedTypes
	{
		get
		{
			if (nested_types != null)
			{
				return nested_types.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasNestedTypes(type));
			}
			return false;
		}
	}

	public Collection<TypeDefinition> NestedTypes
	{
		get
		{
			if (nested_types != null)
			{
				return nested_types;
			}
			if (base.HasImage)
			{
				return Module.Read(ref nested_types, this, (TypeDefinition type, MetadataReader reader) => reader.ReadNestedTypes(type));
			}
			Interlocked.CompareExchange(ref nested_types, new MemberDefinitionCollection<TypeDefinition>(this), null);
			return nested_types;
		}
	}

	public bool HasMethods
	{
		get
		{
			if (methods != null)
			{
				return methods.Count > 0;
			}
			if (base.HasImage)
			{
				return methods_range.Length != 0;
			}
			return false;
		}
	}

	public Collection<MethodDefinition> Methods
	{
		get
		{
			if (methods != null)
			{
				return methods;
			}
			if (base.HasImage)
			{
				return Module.Read(ref methods, this, (TypeDefinition type, MetadataReader reader) => reader.ReadMethods(type));
			}
			Interlocked.CompareExchange(ref methods, new MemberDefinitionCollection<MethodDefinition>(this), null);
			return methods;
		}
	}

	public bool HasFields
	{
		get
		{
			if (fields != null)
			{
				return fields.Count > 0;
			}
			if (base.HasImage)
			{
				return fields_range.Length != 0;
			}
			return false;
		}
	}

	public Collection<FieldDefinition> Fields
	{
		get
		{
			if (fields != null)
			{
				return fields;
			}
			if (base.HasImage)
			{
				return Module.Read(ref fields, this, (TypeDefinition type, MetadataReader reader) => reader.ReadFields(type));
			}
			Interlocked.CompareExchange(ref fields, new MemberDefinitionCollection<FieldDefinition>(this), null);
			return fields;
		}
	}

	public bool HasEvents
	{
		get
		{
			if (events != null)
			{
				return events.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasEvents(type));
			}
			return false;
		}
	}

	public Collection<EventDefinition> Events
	{
		get
		{
			if (events != null)
			{
				return events;
			}
			if (base.HasImage)
			{
				return Module.Read(ref events, this, (TypeDefinition type, MetadataReader reader) => reader.ReadEvents(type));
			}
			Interlocked.CompareExchange(ref events, new MemberDefinitionCollection<EventDefinition>(this), null);
			return events;
		}
	}

	public bool HasProperties
	{
		get
		{
			if (properties != null)
			{
				return properties.Count > 0;
			}
			if (base.HasImage)
			{
				return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasProperties(type));
			}
			return false;
		}
	}

	public Collection<PropertyDefinition> Properties
	{
		get
		{
			if (properties != null)
			{
				return properties;
			}
			if (base.HasImage)
			{
				return Module.Read(ref properties, this, (TypeDefinition type, MetadataReader reader) => reader.ReadProperties(type));
			}
			Interlocked.CompareExchange(ref properties, new MemberDefinitionCollection<PropertyDefinition>(this), null);
			return properties;
		}
	}

	public bool HasSecurityDeclarations
	{
		get
		{
			if (security_declarations != null)
			{
				return security_declarations.Count > 0;
			}
			return this.GetHasSecurityDeclarations(Module);
		}
	}

	public Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, Module);

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			return this.GetHasCustomAttributes(Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

	public override bool HasGenericParameters
	{
		get
		{
			if (generic_parameters != null)
			{
				return generic_parameters.Count > 0;
			}
			return this.GetHasGenericParameters(Module);
		}
	}

	public override Collection<GenericParameter> GenericParameters => generic_parameters ?? this.GetGenericParameters(ref generic_parameters, Module);

	public bool IsNotPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 0u, value);
		}
	}

	public bool IsPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 1u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 1u, value);
		}
	}

	public bool IsNestedPublic
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 2u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 2u, value);
		}
	}

	public bool IsNestedPrivate
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 3u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 3u, value);
		}
	}

	public bool IsNestedFamily
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 4u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 4u, value);
		}
	}

	public bool IsNestedAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 5u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 5u, value);
		}
	}

	public bool IsNestedFamilyAndAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 6u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 6u, value);
		}
	}

	public bool IsNestedFamilyOrAssembly
	{
		get
		{
			return attributes.GetMaskedAttributes(7u, 7u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(7u, 7u, value);
		}
	}

	public bool IsAutoLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 0u, value);
		}
	}

	public bool IsSequentialLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 8u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 8u, value);
		}
	}

	public bool IsExplicitLayout
	{
		get
		{
			return attributes.GetMaskedAttributes(24u, 16u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(24u, 16u, value);
		}
	}

	public bool IsClass
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 0u, value);
		}
	}

	public bool IsInterface
	{
		get
		{
			return attributes.GetMaskedAttributes(32u, 32u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(32u, 32u, value);
		}
	}

	public bool IsAbstract
	{
		get
		{
			return attributes.GetAttributes(128u);
		}
		set
		{
			attributes = attributes.SetAttributes(128u, value);
		}
	}

	public bool IsSealed
	{
		get
		{
			return attributes.GetAttributes(256u);
		}
		set
		{
			attributes = attributes.SetAttributes(256u, value);
		}
	}

	public bool IsSpecialName
	{
		get
		{
			return attributes.GetAttributes(1024u);
		}
		set
		{
			attributes = attributes.SetAttributes(1024u, value);
		}
	}

	public bool IsImport
	{
		get
		{
			return attributes.GetAttributes(4096u);
		}
		set
		{
			attributes = attributes.SetAttributes(4096u, value);
		}
	}

	public bool IsSerializable
	{
		get
		{
			return attributes.GetAttributes(8192u);
		}
		set
		{
			attributes = attributes.SetAttributes(8192u, value);
		}
	}

	public bool IsWindowsRuntime
	{
		get
		{
			return attributes.GetAttributes(16384u);
		}
		set
		{
			attributes = attributes.SetAttributes(16384u, value);
		}
	}

	public bool IsAnsiClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 0u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 0u, value);
		}
	}

	public bool IsUnicodeClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 65536u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 65536u, value);
		}
	}

	public bool IsAutoClass
	{
		get
		{
			return attributes.GetMaskedAttributes(196608u, 131072u);
		}
		set
		{
			attributes = attributes.SetMaskedAttributes(196608u, 131072u, value);
		}
	}

	public bool IsBeforeFieldInit
	{
		get
		{
			return attributes.GetAttributes(1048576u);
		}
		set
		{
			attributes = attributes.SetAttributes(1048576u, value);
		}
	}

	public bool IsRuntimeSpecialName
	{
		get
		{
			return attributes.GetAttributes(2048u);
		}
		set
		{
			attributes = attributes.SetAttributes(2048u, value);
		}
	}

	public bool HasSecurity
	{
		get
		{
			return attributes.GetAttributes(262144u);
		}
		set
		{
			attributes = attributes.SetAttributes(262144u, value);
		}
	}

	public bool IsEnum
	{
		get
		{
			if (base_type != null)
			{
				return base_type.IsTypeOf("System", "Enum");
			}
			return false;
		}
	}

	public override bool IsValueType
	{
		get
		{
			if (base_type == null)
			{
				return false;
			}
			if (!base_type.IsTypeOf("System", "Enum"))
			{
				if (base_type.IsTypeOf("System", "ValueType"))
				{
					return !this.IsTypeOf("System", "Enum");
				}
				return false;
			}
			return true;
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public override bool IsPrimitive
	{
		get
		{
			if (MetadataSystem.TryGetPrimitiveElementType(this, out var self))
			{
				return self.IsPrimitive();
			}
			return false;
		}
	}

	public override MetadataType MetadataType
	{
		get
		{
			if (MetadataSystem.TryGetPrimitiveElementType(this, out var result))
			{
				return (MetadataType)result;
			}
			return base.MetadataType;
		}
	}

	public override bool IsDefinition => true;

	public new TypeDefinition DeclaringType
	{
		get
		{
			return (TypeDefinition)base.DeclaringType;
		}
		set
		{
			base.DeclaringType = value;
		}
	}

	internal new TypeDefinitionProjection WindowsRuntimeProjection
	{
		get
		{
			return (TypeDefinitionProjection)projection;
		}
		set
		{
			projection = value;
		}
	}

	private void ResolveLayout()
	{
		if (!base.HasImage)
		{
			packing_size = -1;
			class_size = -1;
			return;
		}
		lock (Module.SyncRoot)
		{
			if (packing_size == -2 && class_size == -2)
			{
				Row<short, int> row = Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.ReadTypeLayout(type));
				packing_size = row.Col1;
				class_size = row.Col2;
			}
		}
	}

	public TypeDefinition(string @namespace, string name, TypeAttributes attributes)
		: base(@namespace, name)
	{
		this.attributes = (uint)attributes;
		token = new MetadataToken(TokenType.TypeDef);
	}

	public TypeDefinition(string @namespace, string name, TypeAttributes attributes, TypeReference baseType)
		: this(@namespace, name, attributes)
	{
		BaseType = baseType;
	}

	protected override void ClearFullName()
	{
		base.ClearFullName();
		if (HasNestedTypes)
		{
			Collection<TypeDefinition> nestedTypes = NestedTypes;
			for (int i = 0; i < nestedTypes.Count; i++)
			{
				nestedTypes[i].ClearFullName();
			}
		}
	}

	public override TypeDefinition Resolve()
	{
		return this;
	}
}


using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class InterfaceImplementation : ICustomAttributeProvider, IMetadataTokenProvider
{
	internal TypeDefinition type;

	internal MetadataToken token;

	private TypeReference interface_type;

	private Collection<CustomAttribute> custom_attributes;

	public TypeReference InterfaceType
	{
		get
		{
			return interface_type;
		}
		set
		{
			interface_type = value;
		}
	}

	public bool HasCustomAttributes
	{
		get
		{
			if (custom_attributes != null)
			{
				return custom_attributes.Count > 0;
			}
			if (type == null)
			{
				return false;
			}
			return this.GetHasCustomAttributes(type.Module);
		}
	}

	public Collection<CustomAttribute> CustomAttributes
	{
		get
		{
			if (type == null)
			{
				if (custom_attributes == null)
				{
					Interlocked.CompareExchange(ref custom_attributes, new Collection<CustomAttribute>(), null);
				}
				return custom_attributes;
			}
			return custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, type.Module);
		}
	}

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	internal InterfaceImplementation(TypeReference interfaceType, MetadataToken token)
	{
		interface_type = interfaceType;
		this.token = token;
	}

	public InterfaceImplementation(TypeReference interfaceType)
	{
		Mixin.CheckType(interfaceType, Mixin.Argument.interfaceType);
		interface_type = interfaceType;
		token = new MetadataToken(TokenType.InterfaceImpl);
	}
}


using Mono.Cecil;
using Mono.Collections.Generic;

internal class InterfaceImplementationCollection : Collection<InterfaceImplementation>
{
	private readonly TypeDefinition type;

	internal InterfaceImplementationCollection(TypeDefinition type)
	{
		this.type = type;
	}

	internal InterfaceImplementationCollection(TypeDefinition type, int length)
		: base(length)
	{
		this.type = type;
	}

	protected override void OnAdd(InterfaceImplementation item, int index)
	{
		item.type = type;
	}

	protected override void OnInsert(InterfaceImplementation item, int index)
	{
		item.type = type;
	}

	protected override void OnSet(InterfaceImplementation item, int index)
	{
		item.type = type;
	}

	protected override void OnRemove(InterfaceImplementation item, int index)
	{
		item.type = null;
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal sealed class TypeDefinitionCollection : Collection<TypeDefinition>
{
	private readonly ModuleDefinition container;

	private readonly Dictionary<Row<string, string>, TypeDefinition> name_cache;

	internal TypeDefinitionCollection(ModuleDefinition container)
	{
		this.container = container;
		name_cache = new Dictionary<Row<string, string>, TypeDefinition>(new RowEqualityComparer());
	}

	internal TypeDefinitionCollection(ModuleDefinition container, int capacity)
		: base(capacity)
	{
		this.container = container;
		name_cache = new Dictionary<Row<string, string>, TypeDefinition>(capacity, new RowEqualityComparer());
	}

	protected override void OnAdd(TypeDefinition item, int index)
	{
		Attach(item);
	}

	protected override void OnSet(TypeDefinition item, int index)
	{
		Attach(item);
	}

	protected override void OnInsert(TypeDefinition item, int index)
	{
		Attach(item);
	}

	protected override void OnRemove(TypeDefinition item, int index)
	{
		Detach(item);
	}

	protected override void OnClear()
	{
		using Enumerator enumerator = GetEnumerator();
		while (enumerator.MoveNext())
		{
			TypeDefinition current = enumerator.Current;
			Detach(current);
		}
	}

	private void Attach(TypeDefinition type)
	{
		if (type.Module != null && type.Module != container)
		{
			throw new ArgumentException("Type already attached");
		}
		type.module = container;
		type.scope = container;
		name_cache[new Row<string, string>(type.Namespace, type.Name)] = type;
	}

	private void Detach(TypeDefinition type)
	{
		type.module = null;
		type.scope = null;
		name_cache.Remove(new Row<string, string>(type.Namespace, type.Name));
	}

	public TypeDefinition GetType(string fullname)
	{
		TypeParser.SplitFullName(fullname, out var @namespace, out var name);
		return GetType(@namespace, name);
	}

	public TypeDefinition GetType(string @namespace, string name)
	{
		if (name_cache.TryGetValue(new Row<string, string>(@namespace, name), out var value))
		{
			return value;
		}
		return null;
	}
}


using System;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal class TypeParser
{
	private class Type
	{
		public const int Ptr = -1;

		public const int ByRef = -2;

		public const int SzArray = -3;

		public string type_fullname;

		public string[] nested_names;

		public int arity;

		public int[] specs;

		public Type[] generic_arguments;

		public string assembly;
	}

	private readonly string fullname;

	private readonly int length;

	private int position;

	private TypeParser(string fullname)
	{
		this.fullname = fullname;
		length = fullname.Length;
	}

	private Type ParseType(bool fq_name)
	{
		Type type = new Type();
		type.type_fullname = ParsePart();
		type.nested_names = ParseNestedNames();
		if (TryGetArity(type))
		{
			type.generic_arguments = ParseGenericArguments(type.arity);
		}
		type.specs = ParseSpecs();
		if (fq_name)
		{
			type.assembly = ParseAssemblyName();
		}
		return type;
	}

	private static bool TryGetArity(Type type)
	{
		int arity = 0;
		TryAddArity(type.type_fullname, ref arity);
		string[] nested_names = type.nested_names;
		if (!nested_names.IsNullOrEmpty())
		{
			for (int i = 0; i < nested_names.Length; i++)
			{
				TryAddArity(nested_names[i], ref arity);
			}
		}
		type.arity = arity;
		return arity > 0;
	}

	private static bool TryGetArity(string name, out int arity)
	{
		arity = 0;
		int num = name.LastIndexOf('`');
		if (num == -1)
		{
			return false;
		}
		return ParseInt32(name.Substring(num + 1), out arity);
	}

	private static bool ParseInt32(string value, out int result)
	{
		return int.TryParse(value, out result);
	}

	private static void TryAddArity(string name, ref int arity)
	{
		if (TryGetArity(name, out var arity2))
		{
			arity += arity2;
		}
	}

	private string ParsePart()
	{
		StringBuilder stringBuilder = new StringBuilder();
		while (position < length && !IsDelimiter(fullname[position]))
		{
			if (fullname[position] == '\\')
			{
				position++;
			}
			stringBuilder.Append(fullname[position++]);
		}
		return stringBuilder.ToString();
	}

	private static bool IsDelimiter(char chr)
	{
		return "+,[]*&".IndexOf(chr) != -1;
	}

	private void TryParseWhiteSpace()
	{
		while (position < length && char.IsWhiteSpace(fullname[position]))
		{
			position++;
		}
	}

	private string[] ParseNestedNames()
	{
		string[] array = null;
		while (TryParse('+'))
		{
			Add(ref array, ParsePart());
		}
		return array;
	}

	private bool TryParse(char chr)
	{
		if (position < length && fullname[position] == chr)
		{
			position++;
			return true;
		}
		return false;
	}

	private static void Add<T>(ref T[] array, T item)
	{
		array = array.Add(item);
	}

	private int[] ParseSpecs()
	{
		int[] array = null;
		while (position < length)
		{
			switch (fullname[position])
			{
			case '*':
				position++;
				Add(ref array, -1);
				break;
			case '&':
				position++;
				Add(ref array, -2);
				break;
			case '[':
				position++;
				switch (fullname[position])
				{
				case ']':
					position++;
					Add(ref array, -3);
					break;
				case '*':
					position++;
					Add(ref array, 1);
					break;
				default:
				{
					int num = 1;
					while (TryParse(','))
					{
						num++;
					}
					Add(ref array, num);
					TryParse(']');
					break;
				}
				}
				break;
			default:
				return array;
			}
		}
		return array;
	}

	private Type[] ParseGenericArguments(int arity)
	{
		Type[] array = null;
		if (position == length || fullname[position] != '[')
		{
			return array;
		}
		TryParse('[');
		for (int i = 0; i < arity; i++)
		{
			bool flag = TryParse('[');
			Add(ref array, ParseType(flag));
			if (flag)
			{
				TryParse(']');
			}
			TryParse(',');
			TryParseWhiteSpace();
		}
		TryParse(']');
		return array;
	}

	private string ParseAssemblyName()
	{
		if (!TryParse(','))
		{
			return string.Empty;
		}
		TryParseWhiteSpace();
		int num = position;
		while (position < length)
		{
			char c = fullname[position];
			if (c == '[' || c == ']')
			{
				break;
			}
			position++;
		}
		return fullname.Substring(num, position - num);
	}

	public static TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly = false)
	{
		if (string.IsNullOrEmpty(fullname))
		{
			return null;
		}
		TypeParser typeParser = new TypeParser(fullname);
		return GetTypeReference(module, typeParser.ParseType(fq_name: true), typeDefinitionOnly);
	}

	private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only)
	{
		if (!TryGetDefinition(module, type_info, out var type))
		{
			if (type_def_only)
			{
				return null;
			}
			type = CreateReference(type_info, module, GetMetadataScope(module, type_info));
		}
		return CreateSpecs(type, type_info);
	}

	private static TypeReference CreateSpecs(TypeReference type, Type type_info)
	{
		type = TryCreateGenericInstanceType(type, type_info);
		int[] specs = type_info.specs;
		if (specs.IsNullOrEmpty())
		{
			return type;
		}
		for (int i = 0; i < specs.Length; i++)
		{
			switch (specs[i])
			{
			case -1:
				type = new PointerType(type);
				continue;
			case -2:
				type = new ByReferenceType(type);
				continue;
			case -3:
				type = new ArrayType(type);
				continue;
			}
			ArrayType arrayType = new ArrayType(type);
			arrayType.Dimensions.Clear();
			for (int j = 0; j < specs[i]; j++)
			{
				arrayType.Dimensions.Add(default(ArrayDimension));
			}
			type = arrayType;
		}
		return type;
	}

	private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info)
	{
		Type[] generic_arguments = type_info.generic_arguments;
		if (generic_arguments.IsNullOrEmpty())
		{
			return type;
		}
		GenericInstanceType genericInstanceType = new GenericInstanceType(type, generic_arguments.Length);
		Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
		for (int i = 0; i < generic_arguments.Length; i++)
		{
			genericArguments.Add(GetTypeReference(type.Module, generic_arguments[i], type_def_only: false));
		}
		return genericInstanceType;
	}

	public static void SplitFullName(string fullname, out string @namespace, out string name)
	{
		int num = fullname.LastIndexOf('.');
		if (num == -1)
		{
			@namespace = string.Empty;
			name = fullname;
		}
		else
		{
			@namespace = fullname.Substring(0, num);
			name = fullname.Substring(num + 1);
		}
	}

	private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope)
	{
		SplitFullName(type_info.type_fullname, out var @namespace, out var name);
		TypeReference typeReference = new TypeReference(@namespace, name, module, scope);
		MetadataSystem.TryProcessPrimitiveTypeReference(typeReference);
		AdjustGenericParameters(typeReference);
		string[] nested_names = type_info.nested_names;
		if (nested_names.IsNullOrEmpty())
		{
			return typeReference;
		}
		for (int i = 0; i < nested_names.Length; i++)
		{
			typeReference = new TypeReference(string.Empty, nested_names[i], module, null)
			{
				DeclaringType = typeReference
			};
			AdjustGenericParameters(typeReference);
		}
		return typeReference;
	}

	private static void AdjustGenericParameters(TypeReference type)
	{
		if (TryGetArity(type.Name, out var arity))
		{
			for (int i = 0; i < arity; i++)
			{
				type.GenericParameters.Add(new GenericParameter(type));
			}
		}
	}

	private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info)
	{
		if (string.IsNullOrEmpty(type_info.assembly))
		{
			return module.TypeSystem.CoreLibrary;
		}
		AssemblyNameReference assemblyNameReference = AssemblyNameReference.Parse(type_info.assembly);
		if (!module.TryGetAssemblyNameReference(assemblyNameReference, out var assembly_reference))
		{
			return assemblyNameReference;
		}
		return assembly_reference;
	}

	private static bool TryGetDefinition(ModuleDefinition module, Type type_info, out TypeReference type)
	{
		type = null;
		if (!TryCurrentModule(module, type_info))
		{
			return false;
		}
		TypeDefinition typeDefinition = module.GetType(type_info.type_fullname);
		if (typeDefinition == null)
		{
			return false;
		}
		string[] nested_names = type_info.nested_names;
		if (!nested_names.IsNullOrEmpty())
		{
			for (int i = 0; i < nested_names.Length; i++)
			{
				TypeDefinition nestedType = typeDefinition.GetNestedType(nested_names[i]);
				if (nestedType == null)
				{
					return false;
				}
				typeDefinition = nestedType;
			}
		}
		type = typeDefinition;
		return true;
	}

	private static bool TryCurrentModule(ModuleDefinition module, Type type_info)
	{
		if (string.IsNullOrEmpty(type_info.assembly))
		{
			return true;
		}
		if (module.assembly != null && module.assembly.Name.FullName == type_info.assembly)
		{
			return true;
		}
		return false;
	}

	public static string ToParseable(TypeReference type, bool top_level = true)
	{
		if (type == null)
		{
			return null;
		}
		StringBuilder stringBuilder = new StringBuilder();
		AppendType(type, stringBuilder, fq_name: true, top_level);
		return stringBuilder.ToString();
	}

	private static void AppendNamePart(string part, StringBuilder name)
	{
		foreach (char c in part)
		{
			if (IsDelimiter(c))
			{
				name.Append('\\');
			}
			name.Append(c);
		}
	}

	private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level)
	{
		TypeReference elementType = type.GetElementType();
		TypeReference declaringType = elementType.DeclaringType;
		if (declaringType != null)
		{
			AppendType(declaringType, name, fq_name: false, top_level);
			name.Append('+');
		}
		string @namespace = type.Namespace;
		if (!string.IsNullOrEmpty(@namespace))
		{
			AppendNamePart(@namespace, name);
			name.Append('.');
		}
		AppendNamePart(elementType.Name, name);
		if (fq_name)
		{
			if (type.IsTypeSpecification())
			{
				AppendTypeSpecification((TypeSpecification)type, name);
			}
			if (RequiresFullyQualifiedName(type, top_level))
			{
				name.Append(", ");
				name.Append(GetScopeFullName(type));
			}
		}
	}

	private static string GetScopeFullName(TypeReference type)
	{
		IMetadataScope scope = type.Scope;
		return scope.MetadataScopeType switch
		{
			MetadataScopeType.AssemblyNameReference => ((AssemblyNameReference)scope).FullName, 
			MetadataScopeType.ModuleDefinition => ((ModuleDefinition)scope).Assembly.Name.FullName, 
			_ => throw new ArgumentException(), 
		};
	}

	private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name)
	{
		if (type.ElementType.IsTypeSpecification())
		{
			AppendTypeSpecification((TypeSpecification)type.ElementType, name);
		}
		switch (type.etype)
		{
		case ElementType.Ptr:
			name.Append('*');
			break;
		case ElementType.ByRef:
			name.Append('&');
			break;
		case ElementType.Array:
		case ElementType.SzArray:
		{
			ArrayType arrayType = (ArrayType)type;
			if (arrayType.IsVector)
			{
				name.Append("[]");
				break;
			}
			name.Append('[');
			for (int j = 1; j < arrayType.Rank; j++)
			{
				name.Append(',');
			}
			name.Append(']');
			break;
		}
		case ElementType.GenericInst:
		{
			Collection<TypeReference> genericArguments = ((GenericInstanceType)type).GenericArguments;
			name.Append('[');
			for (int i = 0; i < genericArguments.Count; i++)
			{
				if (i > 0)
				{
					name.Append(',');
				}
				TypeReference typeReference = genericArguments[i];
				bool num = typeReference.Scope != typeReference.Module;
				if (num)
				{
					name.Append('[');
				}
				AppendType(typeReference, name, fq_name: true, top_level: false);
				if (num)
				{
					name.Append(']');
				}
			}
			name.Append(']');
			break;
		}
		}
	}

	private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level)
	{
		if (type.Scope == type.Module)
		{
			return false;
		}
		if (type.Scope.Name == "mscorlib" && top_level)
		{
			return false;
		}
		return true;
	}
}


private class Type
{
	public const int Ptr = -1;

	public const int ByRef = -2;

	public const int SzArray = -3;

	public string type_fullname;

	public string[] nested_names;

	public int arity;

	public int[] specs;

	public Type[] generic_arguments;

	public string assembly;
}


internal enum MetadataType : byte
{
	Void = 1,
	Boolean = 2,
	Char = 3,
	SByte = 4,
	Byte = 5,
	Int16 = 6,
	UInt16 = 7,
	Int32 = 8,
	UInt32 = 9,
	Int64 = 10,
	UInt64 = 11,
	Single = 12,
	Double = 13,
	String = 14,
	Pointer = 15,
	ByReference = 16,
	ValueType = 17,
	Class = 18,
	Var = 19,
	Array = 20,
	GenericInstance = 21,
	TypedByReference = 22,
	IntPtr = 24,
	UIntPtr = 25,
	FunctionPointer = 27,
	Object = 28,
	MVar = 30,
	RequiredModifier = 31,
	OptionalModifier = 32,
	Sentinel = 65,
	Pinned = 69
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal class TypeReference : MemberReference, IGenericParameterProvider, IMetadataTokenProvider, IGenericContext
{
	private string @namespace;

	private bool value_type;

	internal IMetadataScope scope;

	internal ModuleDefinition module;

	internal ElementType etype;

	private string fullname;

	protected Collection<GenericParameter> generic_parameters;

	public override string Name
	{
		get
		{
			return base.Name;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && value != base.Name)
			{
				throw new InvalidOperationException("Projected type reference name can't be changed.");
			}
			base.Name = value;
			ClearFullName();
		}
	}

	public virtual string Namespace
	{
		get
		{
			return @namespace;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && value != @namespace)
			{
				throw new InvalidOperationException("Projected type reference namespace can't be changed.");
			}
			@namespace = value;
			ClearFullName();
		}
	}

	public virtual bool IsValueType
	{
		get
		{
			return value_type;
		}
		set
		{
			value_type = value;
		}
	}

	public override ModuleDefinition Module
	{
		get
		{
			if (module != null)
			{
				return module;
			}
			return DeclaringType?.Module;
		}
	}

	internal TypeReferenceProjection WindowsRuntimeProjection
	{
		get
		{
			return (TypeReferenceProjection)projection;
		}
		set
		{
			projection = value;
		}
	}

	IGenericParameterProvider IGenericContext.Type => this;

	IGenericParameterProvider IGenericContext.Method => null;

	GenericParameterType IGenericParameterProvider.GenericParameterType => GenericParameterType.Type;

	public virtual bool HasGenericParameters => !generic_parameters.IsNullOrEmpty();

	public virtual Collection<GenericParameter> GenericParameters
	{
		get
		{
			if (generic_parameters == null)
			{
				Interlocked.CompareExchange(ref generic_parameters, new GenericParameterCollection(this), null);
			}
			return generic_parameters;
		}
	}

	public virtual IMetadataScope Scope
	{
		get
		{
			TypeReference declaringType = DeclaringType;
			if (declaringType != null)
			{
				return declaringType.Scope;
			}
			return scope;
		}
		set
		{
			TypeReference declaringType = DeclaringType;
			if (declaringType != null)
			{
				if (base.IsWindowsRuntimeProjection && value != declaringType.Scope)
				{
					throw new InvalidOperationException("Projected type scope can't be changed.");
				}
				declaringType.Scope = value;
			}
			else
			{
				if (base.IsWindowsRuntimeProjection && value != scope)
				{
					throw new InvalidOperationException("Projected type scope can't be changed.");
				}
				scope = value;
			}
		}
	}

	public bool IsNested => DeclaringType != null;

	public override TypeReference DeclaringType
	{
		get
		{
			return base.DeclaringType;
		}
		set
		{
			if (base.IsWindowsRuntimeProjection && value != base.DeclaringType)
			{
				throw new InvalidOperationException("Projected type declaring type can't be changed.");
			}
			base.DeclaringType = value;
			ClearFullName();
		}
	}

	public override string FullName
	{
		get
		{
			if (fullname != null)
			{
				return fullname;
			}
			string text = this.TypeFullName();
			if (IsNested)
			{
				text = DeclaringType.FullName + "/" + text;
			}
			Interlocked.CompareExchange(ref fullname, text, null);
			return fullname;
		}
	}

	public virtual bool IsByReference => false;

	public virtual bool IsPointer => false;

	public virtual bool IsSentinel => false;

	public virtual bool IsArray => false;

	public virtual bool IsGenericParameter => false;

	public virtual bool IsGenericInstance => false;

	public virtual bool IsRequiredModifier => false;

	public virtual bool IsOptionalModifier => false;

	public virtual bool IsPinned => false;

	public virtual bool IsFunctionPointer => false;

	public virtual bool IsPrimitive => etype.IsPrimitive();

	public virtual MetadataType MetadataType
	{
		get
		{
			if (etype == ElementType.None)
			{
				if (!IsValueType)
				{
					return MetadataType.Class;
				}
				return MetadataType.ValueType;
			}
			return (MetadataType)etype;
		}
	}

	protected TypeReference(string @namespace, string name)
		: base(name)
	{
		this.@namespace = @namespace ?? string.Empty;
		token = new MetadataToken(TokenType.TypeRef, 0);
	}

	public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
		: this(@namespace, name)
	{
		this.module = module;
		this.scope = scope;
	}

	public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType)
		: this(@namespace, name, module, scope)
	{
		value_type = valueType;
	}

	protected virtual void ClearFullName()
	{
		fullname = null;
	}

	public virtual TypeReference GetElementType()
	{
		return this;
	}

	protected override IMemberDefinition ResolveDefinition()
	{
		return Resolve();
	}

	public new virtual TypeDefinition Resolve()
	{
		return (Module ?? throw new NotSupportedException()).Resolve(this);
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;

internal sealed class TypeReferenceEqualityComparer : EqualityComparer<TypeReference>
{
	public override bool Equals(TypeReference x, TypeReference y)
	{
		return AreEqual(x, y);
	}

	public override int GetHashCode(TypeReference obj)
	{
		return GetHashCodeFor(obj);
	}

	public static bool AreEqual(TypeReference a, TypeReference b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
	{
		if (a == b)
		{
			return true;
		}
		if (a == null || b == null)
		{
			return false;
		}
		MetadataType metadataType = a.MetadataType;
		MetadataType metadataType2 = b.MetadataType;
		if (metadataType == MetadataType.GenericInstance || metadataType2 == MetadataType.GenericInstance)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual((GenericInstanceType)a, (GenericInstanceType)b, comparisonMode);
		}
		if (metadataType == MetadataType.Array || metadataType2 == MetadataType.Array)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			ArrayType arrayType = (ArrayType)a;
			ArrayType arrayType2 = (ArrayType)b;
			if (arrayType.Rank != arrayType2.Rank)
			{
				return false;
			}
			return AreEqual(arrayType.ElementType, arrayType2.ElementType, comparisonMode);
		}
		if (metadataType == MetadataType.Var || metadataType2 == MetadataType.Var)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual((GenericParameter)a, (GenericParameter)b, comparisonMode);
		}
		if (metadataType == MetadataType.MVar || metadataType2 == MetadataType.MVar)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual((GenericParameter)a, (GenericParameter)b, comparisonMode);
		}
		if (metadataType == MetadataType.ByReference || metadataType2 == MetadataType.ByReference)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual(((ByReferenceType)a).ElementType, ((ByReferenceType)b).ElementType, comparisonMode);
		}
		if (metadataType == MetadataType.Pointer || metadataType2 == MetadataType.Pointer)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual(((PointerType)a).ElementType, ((PointerType)b).ElementType, comparisonMode);
		}
		if (metadataType == MetadataType.RequiredModifier || metadataType2 == MetadataType.RequiredModifier)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			RequiredModifierType requiredModifierType = (RequiredModifierType)a;
			RequiredModifierType requiredModifierType2 = (RequiredModifierType)b;
			if (AreEqual(requiredModifierType.ModifierType, requiredModifierType2.ModifierType, comparisonMode))
			{
				return AreEqual(requiredModifierType.ElementType, requiredModifierType2.ElementType, comparisonMode);
			}
			return false;
		}
		if (metadataType == MetadataType.OptionalModifier || metadataType2 == MetadataType.OptionalModifier)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			OptionalModifierType optionalModifierType = (OptionalModifierType)a;
			OptionalModifierType optionalModifierType2 = (OptionalModifierType)b;
			if (AreEqual(optionalModifierType.ModifierType, optionalModifierType2.ModifierType, comparisonMode))
			{
				return AreEqual(optionalModifierType.ElementType, optionalModifierType2.ElementType, comparisonMode);
			}
			return false;
		}
		if (metadataType == MetadataType.Pinned || metadataType2 == MetadataType.Pinned)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual(((PinnedType)a).ElementType, ((PinnedType)b).ElementType, comparisonMode);
		}
		if (metadataType == MetadataType.Sentinel || metadataType2 == MetadataType.Sentinel)
		{
			if (metadataType != metadataType2)
			{
				return false;
			}
			return AreEqual(((SentinelType)a).ElementType, ((SentinelType)b).ElementType, comparisonMode);
		}
		if (!a.Name.Equals(b.Name) || !a.Namespace.Equals(b.Namespace))
		{
			return false;
		}
		TypeDefinition typeDefinition = a.Resolve();
		TypeDefinition typeDefinition2 = b.Resolve();
		if (comparisonMode == TypeComparisonMode.SignatureOnlyLoose)
		{
			if (typeDefinition.Module.Name != typeDefinition2.Module.Name)
			{
				return false;
			}
			if (typeDefinition.Module.Assembly.Name.Name != typeDefinition2.Module.Assembly.Name.Name)
			{
				return false;
			}
			return typeDefinition.FullName == typeDefinition2.FullName;
		}
		return typeDefinition == typeDefinition2;
	}

	private static bool AreEqual(GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
	{
		if (a == b)
		{
			return true;
		}
		if (a.Position != b.Position)
		{
			return false;
		}
		if (a.Type != b.Type)
		{
			return false;
		}
		if (a.Owner is TypeReference a2 && AreEqual(a2, b.Owner as TypeReference, comparisonMode))
		{
			return true;
		}
		if (a.Owner is MethodReference x && comparisonMode != TypeComparisonMode.SignatureOnlyLoose && MethodReferenceComparer.AreEqual(x, b.Owner as MethodReference))
		{
			return true;
		}
		if (comparisonMode != TypeComparisonMode.SignatureOnly)
		{
			return comparisonMode == TypeComparisonMode.SignatureOnlyLoose;
		}
		return true;
	}

	private static bool AreEqual(GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode = TypeComparisonMode.Exact)
	{
		if (a == b)
		{
			return true;
		}
		int count = a.GenericArguments.Count;
		if (count != b.GenericArguments.Count)
		{
			return false;
		}
		if (!AreEqual(a.ElementType, b.ElementType, comparisonMode))
		{
			return false;
		}
		for (int i = 0; i < count; i++)
		{
			if (!AreEqual(a.GenericArguments[i], b.GenericArguments[i], comparisonMode))
			{
				return false;
			}
		}
		return true;
	}

	public static int GetHashCodeFor(TypeReference obj)
	{
		MetadataType metadataType = obj.MetadataType;
		switch (metadataType)
		{
		case MetadataType.GenericInstance:
		{
			GenericInstanceType genericInstanceType = (GenericInstanceType)obj;
			int num4 = GetHashCodeFor(genericInstanceType.ElementType) * 486187739 + 31;
			for (int i = 0; i < genericInstanceType.GenericArguments.Count; i++)
			{
				num4 = num4 * 486187739 + GetHashCodeFor(genericInstanceType.GenericArguments[i]);
			}
			return num4;
		}
		case MetadataType.Array:
		{
			ArrayType arrayType = (ArrayType)obj;
			return GetHashCodeFor(arrayType.ElementType) * 486187739 + arrayType.Rank.GetHashCode();
		}
		case MetadataType.Var:
		case MetadataType.MVar:
		{
			GenericParameter genericParameter = (GenericParameter)obj;
			int num = genericParameter.Position.GetHashCode() * 486187739;
			int num2 = (int)metadataType;
			int num3 = num + num2.GetHashCode();
			if (genericParameter.Owner is TypeReference obj2)
			{
				return num3 * 486187739 + GetHashCodeFor(obj2);
			}
			if (genericParameter.Owner is MethodReference obj3)
			{
				return num3 * 486187739 + MethodReferenceComparer.GetHashCodeFor(obj3);
			}
			throw new InvalidOperationException("Generic parameter encountered with invalid owner");
		}
		case MetadataType.ByReference:
			return GetHashCodeFor(((ByReferenceType)obj).ElementType) * 486187739 * 37;
		case MetadataType.Pointer:
			return GetHashCodeFor(((PointerType)obj).ElementType) * 486187739 * 41;
		case MetadataType.RequiredModifier:
		{
			RequiredModifierType requiredModifierType = (RequiredModifierType)obj;
			return GetHashCodeFor(requiredModifierType.ElementType) * 43 * 486187739 + GetHashCodeFor(requiredModifierType.ModifierType);
		}
		case MetadataType.OptionalModifier:
		{
			OptionalModifierType optionalModifierType = (OptionalModifierType)obj;
			return GetHashCodeFor(optionalModifierType.ElementType) * 47 * 486187739 + GetHashCodeFor(optionalModifierType.ModifierType);
		}
		case MetadataType.Pinned:
			return GetHashCodeFor(((PinnedType)obj).ElementType) * 486187739 * 53;
		case MetadataType.Sentinel:
			return GetHashCodeFor(((SentinelType)obj).ElementType) * 486187739 * 59;
		case MetadataType.FunctionPointer:
			throw new NotImplementedException("We currently don't handle function pointer types.");
		default:
			return obj.Namespace.GetHashCode() * 486187739 + obj.FullName.GetHashCode();
		}
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class TypeResolver
{
	private readonly IGenericInstance _typeDefinitionContext;

	private readonly IGenericInstance _methodDefinitionContext;

	public static TypeResolver For(TypeReference typeReference)
	{
		if (!typeReference.IsGenericInstance)
		{
			return new TypeResolver();
		}
		return new TypeResolver((GenericInstanceType)typeReference);
	}

	public static TypeResolver For(TypeReference typeReference, MethodReference methodReference)
	{
		return new TypeResolver(typeReference as GenericInstanceType, methodReference as GenericInstanceMethod);
	}

	public TypeResolver()
	{
	}

	public TypeResolver(GenericInstanceType typeDefinitionContext)
	{
		_typeDefinitionContext = typeDefinitionContext;
	}

	public TypeResolver(GenericInstanceMethod methodDefinitionContext)
	{
		_methodDefinitionContext = methodDefinitionContext;
	}

	public TypeResolver(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext)
	{
		_typeDefinitionContext = typeDefinitionContext;
		_methodDefinitionContext = methodDefinitionContext;
	}

	public MethodReference Resolve(MethodReference method)
	{
		MethodReference result = method;
		if (IsDummy())
		{
			return result;
		}
		TypeReference declaringType = Resolve(method.DeclaringType);
		if (method is GenericInstanceMethod genericInstanceMethod)
		{
			result = new MethodReference(method.Name, method.ReturnType, declaringType);
			foreach (ParameterDefinition parameter in method.Parameters)
			{
				result.Parameters.Add(new ParameterDefinition(parameter.Name, parameter.Attributes, parameter.ParameterType));
			}
			foreach (GenericParameter genericParameter in genericInstanceMethod.ElementMethod.GenericParameters)
			{
				result.GenericParameters.Add(new GenericParameter(genericParameter.Name, result));
			}
			result.HasThis = method.HasThis;
			GenericInstanceMethod genericInstanceMethod2 = new GenericInstanceMethod(result);
			foreach (TypeReference genericArgument in genericInstanceMethod.GenericArguments)
			{
				genericInstanceMethod2.GenericArguments.Add(Resolve(genericArgument));
			}
			result = genericInstanceMethod2;
		}
		else
		{
			result = new MethodReference(method.Name, method.ReturnType, declaringType);
			foreach (GenericParameter genericParameter2 in method.GenericParameters)
			{
				result.GenericParameters.Add(new GenericParameter(genericParameter2.Name, result));
			}
			foreach (ParameterDefinition parameter2 in method.Parameters)
			{
				result.Parameters.Add(new ParameterDefinition(parameter2.Name, parameter2.Attributes, parameter2.ParameterType));
			}
			result.HasThis = method.HasThis;
		}
		return result;
	}

	public FieldReference Resolve(FieldReference field)
	{
		TypeReference typeReference = Resolve(field.DeclaringType);
		if (typeReference == field.DeclaringType)
		{
			return field;
		}
		return new FieldReference(field.Name, field.FieldType, typeReference);
	}

	public TypeReference ResolveReturnType(MethodReference method)
	{
		return Resolve(GenericParameterResolver.ResolveReturnTypeIfNeeded(method));
	}

	public TypeReference ResolveParameterType(MethodReference method, ParameterReference parameter)
	{
		return Resolve(GenericParameterResolver.ResolveParameterTypeIfNeeded(method, parameter));
	}

	public TypeReference ResolveVariableType(MethodReference method, VariableReference variable)
	{
		return Resolve(GenericParameterResolver.ResolveVariableTypeIfNeeded(method, variable));
	}

	public TypeReference ResolveFieldType(FieldReference field)
	{
		return Resolve(GenericParameterResolver.ResolveFieldTypeIfNeeded(field));
	}

	public TypeReference Resolve(TypeReference typeReference)
	{
		return Resolve(typeReference, includeTypeDefinitions: true);
	}

	public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions)
	{
		if (IsDummy())
		{
			return typeReference;
		}
		if (_typeDefinitionContext != null && _typeDefinitionContext.GenericArguments.Contains(typeReference))
		{
			return typeReference;
		}
		if (_methodDefinitionContext != null && _methodDefinitionContext.GenericArguments.Contains(typeReference))
		{
			return typeReference;
		}
		if (typeReference is GenericParameter genericParameter)
		{
			if (_typeDefinitionContext != null && _typeDefinitionContext.GenericArguments.Contains(genericParameter))
			{
				return genericParameter;
			}
			if (_methodDefinitionContext != null && _methodDefinitionContext.GenericArguments.Contains(genericParameter))
			{
				return genericParameter;
			}
			return ResolveGenericParameter(genericParameter);
		}
		if (typeReference is ArrayType arrayType)
		{
			return new ArrayType(Resolve(arrayType.ElementType), arrayType.Rank);
		}
		if (typeReference is PointerType pointerType)
		{
			return new PointerType(Resolve(pointerType.ElementType));
		}
		if (typeReference is ByReferenceType byReferenceType)
		{
			return new ByReferenceType(Resolve(byReferenceType.ElementType));
		}
		if (typeReference is PinnedType pinnedType)
		{
			return new PinnedType(Resolve(pinnedType.ElementType));
		}
		if (typeReference is GenericInstanceType genericInstanceType)
		{
			GenericInstanceType genericInstanceType2 = new GenericInstanceType(genericInstanceType.ElementType);
			{
				foreach (TypeReference genericArgument in genericInstanceType.GenericArguments)
				{
					genericInstanceType2.GenericArguments.Add(Resolve(genericArgument));
				}
				return genericInstanceType2;
			}
		}
		if (typeReference is RequiredModifierType requiredModifierType)
		{
			return Resolve(requiredModifierType.ElementType, includeTypeDefinitions);
		}
		if (includeTypeDefinitions && typeReference is TypeDefinition { HasGenericParameters: not false } typeDefinition)
		{
			GenericInstanceType genericInstanceType3 = new GenericInstanceType(typeDefinition);
			{
				foreach (GenericParameter genericParameter2 in typeDefinition.GenericParameters)
				{
					genericInstanceType3.GenericArguments.Add(Resolve(genericParameter2));
				}
				return genericInstanceType3;
			}
		}
		if (typeReference is TypeSpecification)
		{
			throw new NotSupportedException($"The type {typeReference.FullName} cannot be resolved correctly.");
		}
		return typeReference;
	}

	internal TypeResolver Nested(GenericInstanceMethod genericInstanceMethod)
	{
		return new TypeResolver(_typeDefinitionContext as GenericInstanceType, genericInstanceMethod);
	}

	private TypeReference ResolveGenericParameter(GenericParameter genericParameter)
	{
		if (genericParameter.Owner == null)
		{
			return HandleOwnerlessInvalidILCode(genericParameter);
		}
		if (!(genericParameter.Owner is MemberReference))
		{
			throw new NotSupportedException();
		}
		if (genericParameter.Type != 0)
		{
			if (_methodDefinitionContext == null)
			{
				return genericParameter;
			}
			return _methodDefinitionContext.GenericArguments[genericParameter.Position];
		}
		return _typeDefinitionContext.GenericArguments[genericParameter.Position];
	}

	private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter)
	{
		if (genericParameter.Type == GenericParameterType.Method && _typeDefinitionContext != null && genericParameter.Position < _typeDefinitionContext.GenericArguments.Count)
		{
			return _typeDefinitionContext.GenericArguments[genericParameter.Position];
		}
		return genericParameter.Module.TypeSystem.Object;
	}

	private bool IsDummy()
	{
		if (_typeDefinitionContext == null)
		{
			return _methodDefinitionContext == null;
		}
		return false;
	}
}


using System;
using Mono.Cecil;

internal abstract class TypeSpecification : TypeReference
{
	private readonly TypeReference element_type;

	public TypeReference ElementType => element_type;

	public override string Name
	{
		get
		{
			return element_type.Name;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override string Namespace
	{
		get
		{
			return element_type.Namespace;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override IMetadataScope Scope
	{
		get
		{
			return element_type.Scope;
		}
		set
		{
			throw new InvalidOperationException();
		}
	}

	public override ModuleDefinition Module => element_type.Module;

	public override string FullName => element_type.FullName;

	public override bool ContainsGenericParameter => element_type.ContainsGenericParameter;

	public override MetadataType MetadataType => (MetadataType)etype;

	internal TypeSpecification(TypeReference type)
		: base(null, null)
	{
		element_type = type;
		token = new MetadataToken(TokenType.TypeSpec);
	}

	public override TypeReference GetElementType()
	{
		return element_type.GetElementType();
	}
}


