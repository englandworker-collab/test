using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

internal abstract class TypeSystem
{
	private sealed class CoreTypeSystem : TypeSystem
	{
		public CoreTypeSystem(ModuleDefinition module)
			: base(module)
		{
		}

		internal override TypeReference LookupType(string @namespace, string name)
		{
			TypeReference typeReference = LookupTypeDefinition(@namespace, name) ?? LookupTypeForwarded(@namespace, name);
			if (typeReference != null)
			{
				return typeReference;
			}
			throw new NotSupportedException();
		}

		private TypeReference LookupTypeDefinition(string @namespace, string name)
		{
			if (module.MetadataSystem.Types == null)
			{
				Initialize(module.Types);
			}
			return module.Read(new Row<string, string>(@namespace, name), delegate(Row<string, string> row, MetadataReader reader)
			{
				TypeDefinition[] types = reader.metadata.Types;
				for (int i = 0; i < types.Length; i++)
				{
					if (types[i] == null)
					{
						types[i] = reader.GetTypeDefinition((uint)(i + 1));
					}
					TypeDefinition typeDefinition = types[i];
					if (typeDefinition.Name == row.Col2 && typeDefinition.Namespace == row.Col1)
					{
						return typeDefinition;
					}
				}
				return (TypeDefinition)null;
			});
		}

		private TypeReference LookupTypeForwarded(string @namespace, string name)
		{
			if (!module.HasExportedTypes)
			{
				return null;
			}
			Collection<ExportedType> exportedTypes = module.ExportedTypes;
			for (int i = 0; i < exportedTypes.Count; i++)
			{
				ExportedType exportedType = exportedTypes[i];
				if (exportedType.Name == name && exportedType.Namespace == @namespace)
				{
					return exportedType.CreateReference();
				}
			}
			return null;
		}

		private static void Initialize(object obj)
		{
		}
	}

	private sealed class CommonTypeSystem : TypeSystem
	{
		private AssemblyNameReference core_library;

		public CommonTypeSystem(ModuleDefinition module)
			: base(module)
		{
		}

		internal override TypeReference LookupType(string @namespace, string name)
		{
			return CreateTypeReference(@namespace, name);
		}

		public AssemblyNameReference GetCoreLibraryReference()
		{
			if (core_library != null)
			{
				return core_library;
			}
			if (module.TryGetCoreLibraryReference(out core_library))
			{
				return core_library;
			}
			core_library = new AssemblyNameReference
			{
				Name = "mscorlib",
				Version = GetCorlibVersion(),
				PublicKeyToken = new byte[8] { 183, 122, 92, 86, 25, 52, 224, 137 }
			};
			module.AssemblyReferences.Add(core_library);
			return core_library;
		}

		private Version GetCorlibVersion()
		{
			switch (module.Runtime)
			{
			case TargetRuntime.Net_1_0:
			case TargetRuntime.Net_1_1:
				return new Version(1, 0, 0, 0);
			case TargetRuntime.Net_2_0:
				return new Version(2, 0, 0, 0);
			case TargetRuntime.Net_4_0:
				return new Version(4, 0, 0, 0);
			default:
				throw new NotSupportedException();
			}
		}

		private TypeReference CreateTypeReference(string @namespace, string name)
		{
			return new TypeReference(@namespace, name, module, GetCoreLibraryReference());
		}
	}

	private readonly ModuleDefinition module;

	private TypeReference type_object;

	private TypeReference type_void;

	private TypeReference type_bool;

	private TypeReference type_char;

	private TypeReference type_sbyte;

	private TypeReference type_byte;

	private TypeReference type_int16;

	private TypeReference type_uint16;

	private TypeReference type_int32;

	private TypeReference type_uint32;

	private TypeReference type_int64;

	private TypeReference type_uint64;

	private TypeReference type_single;

	private TypeReference type_double;

	private TypeReference type_intptr;

	private TypeReference type_uintptr;

	private TypeReference type_string;

	private TypeReference type_typedref;

	[Obsolete("Use CoreLibrary")]
	public IMetadataScope Corlib => CoreLibrary;

	public IMetadataScope CoreLibrary
	{
		get
		{
			if (!(this is CommonTypeSystem commonTypeSystem))
			{
				return module;
			}
			return commonTypeSystem.GetCoreLibraryReference();
		}
	}

	public TypeReference Object => type_object ?? LookupSystemType(ref type_object, "Object", ElementType.Object);

	public TypeReference Void => type_void ?? LookupSystemType(ref type_void, "Void", ElementType.Void);

	public TypeReference Boolean => type_bool ?? LookupSystemValueType(ref type_bool, "Boolean", ElementType.Boolean);

	public TypeReference Char => type_char ?? LookupSystemValueType(ref type_char, "Char", ElementType.Char);

	public TypeReference SByte => type_sbyte ?? LookupSystemValueType(ref type_sbyte, "SByte", ElementType.I1);

	public TypeReference Byte => type_byte ?? LookupSystemValueType(ref type_byte, "Byte", ElementType.U1);

	public TypeReference Int16 => type_int16 ?? LookupSystemValueType(ref type_int16, "Int16", ElementType.I2);

	public TypeReference UInt16 => type_uint16 ?? LookupSystemValueType(ref type_uint16, "UInt16", ElementType.U2);

	public TypeReference Int32 => type_int32 ?? LookupSystemValueType(ref type_int32, "Int32", ElementType.I4);

	public TypeReference UInt32 => type_uint32 ?? LookupSystemValueType(ref type_uint32, "UInt32", ElementType.U4);

	public TypeReference Int64 => type_int64 ?? LookupSystemValueType(ref type_int64, "Int64", ElementType.I8);

	public TypeReference UInt64 => type_uint64 ?? LookupSystemValueType(ref type_uint64, "UInt64", ElementType.U8);

	public TypeReference Single => type_single ?? LookupSystemValueType(ref type_single, "Single", ElementType.R4);

	public TypeReference Double => type_double ?? LookupSystemValueType(ref type_double, "Double", ElementType.R8);

	public TypeReference IntPtr => type_intptr ?? LookupSystemValueType(ref type_intptr, "IntPtr", ElementType.I);

	public TypeReference UIntPtr => type_uintptr ?? LookupSystemValueType(ref type_uintptr, "UIntPtr", ElementType.U);

	public TypeReference String => type_string ?? LookupSystemType(ref type_string, "String", ElementType.String);

	public TypeReference TypedReference => type_typedref ?? LookupSystemValueType(ref type_typedref, "TypedReference", ElementType.TypedByRef);

	private TypeSystem(ModuleDefinition module)
	{
		this.module = module;
	}

	internal static TypeSystem CreateTypeSystem(ModuleDefinition module)
	{
		if (module.IsCoreLibrary())
		{
			return new CoreTypeSystem(module);
		}
		return new CommonTypeSystem(module);
	}

	internal abstract TypeReference LookupType(string @namespace, string name);

	private TypeReference LookupSystemType(ref TypeReference reference, string name, ElementType element_type)
	{
		lock (module.SyncRoot)
		{
			if (reference != null)
			{
				return reference;
			}
			TypeReference typeReference = LookupType("System", name);
			typeReference.etype = element_type;
			return reference = typeReference;
		}
	}

	private TypeReference LookupSystemValueType(ref TypeReference typeRef, string name, ElementType element_type)
	{
		lock (module.SyncRoot)
		{
			if (typeRef != null)
			{
				return typeRef;
			}
			TypeReference typeReference = LookupType("System", name);
			typeReference.etype = element_type;
			typeReference.KnownValueType();
			return typeRef = typeReference;
		}
	}
}


using System;
using Mono.Cecil.Metadata;
using Mono.Collections.Generic;

private sealed class CoreTypeSystem : TypeSystem
{
	public CoreTypeSystem(ModuleDefinition module)
		: base(module)
	{
	}

	internal override TypeReference LookupType(string @namespace, string name)
	{
		TypeReference typeReference = LookupTypeDefinition(@namespace, name) ?? LookupTypeForwarded(@namespace, name);
		if (typeReference != null)
		{
			return typeReference;
		}
		throw new NotSupportedException();
	}

	private TypeReference LookupTypeDefinition(string @namespace, string name)
	{
		if (module.MetadataSystem.Types == null)
		{
			Initialize(module.Types);
		}
		return module.Read(new Row<string, string>(@namespace, name), delegate(Row<string, string> row, MetadataReader reader)
		{
			TypeDefinition[] types = reader.metadata.Types;
			for (int i = 0; i < types.Length; i++)
			{
				if (types[i] == null)
				{
					types[i] = reader.GetTypeDefinition((uint)(i + 1));
				}
				TypeDefinition typeDefinition = types[i];
				if (typeDefinition.Name == row.Col2 && typeDefinition.Namespace == row.Col1)
				{
					return typeDefinition;
				}
			}
			return (TypeDefinition)null;
		});
	}

	private TypeReference LookupTypeForwarded(string @namespace, string name)
	{
		if (!module.HasExportedTypes)
		{
			return null;
		}
		Collection<ExportedType> exportedTypes = module.ExportedTypes;
		for (int i = 0; i < exportedTypes.Count; i++)
		{
			ExportedType exportedType = exportedTypes[i];
			if (exportedType.Name == name && exportedType.Namespace == @namespace)
			{
				return exportedType.CreateReference();
			}
		}
		return null;
	}

	private static void Initialize(object obj)
	{
	}
}


using System;

private sealed class CommonTypeSystem : TypeSystem
{
	private AssemblyNameReference core_library;

	public CommonTypeSystem(ModuleDefinition module)
		: base(module)
	{
	}

	internal override TypeReference LookupType(string @namespace, string name)
	{
		return CreateTypeReference(@namespace, name);
	}

	public AssemblyNameReference GetCoreLibraryReference()
	{
		if (core_library != null)
		{
			return core_library;
		}
		if (module.TryGetCoreLibraryReference(out core_library))
		{
			return core_library;
		}
		core_library = new AssemblyNameReference
		{
			Name = "mscorlib",
			Version = GetCorlibVersion(),
			PublicKeyToken = new byte[8] { 183, 122, 92, 86, 25, 52, 224, 137 }
		};
		module.AssemblyReferences.Add(core_library);
		return core_library;
	}

	private Version GetCorlibVersion()
	{
		switch (module.Runtime)
		{
		case TargetRuntime.Net_1_0:
		case TargetRuntime.Net_1_1:
			return new Version(1, 0, 0, 0);
		case TargetRuntime.Net_2_0:
			return new Version(2, 0, 0, 0);
		case TargetRuntime.Net_4_0:
			return new Version(4, 0, 0, 0);
		default:
			throw new NotSupportedException();
		}
	}

	private TypeReference CreateTypeReference(string @namespace, string name)
	{
		return new TypeReference(@namespace, name, module, GetCoreLibraryReference());
	}
}


internal enum VariantType
{
	None = 0,
	I2 = 2,
	I4 = 3,
	R4 = 4,
	R8 = 5,
	CY = 6,
	Date = 7,
	BStr = 8,
	Dispatch = 9,
	Error = 10,
	Bool = 11,
	Variant = 12,
	Unknown = 13,
	Decimal = 14,
	I1 = 16,
	UI1 = 17,
	UI2 = 18,
	UI4 = 19,
	I8 = 20,
	UI8 = 21,
	Int = 22,
	UInt = 23
}


using System.Collections.Generic;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class TypeDefinitionProjection
{
	public readonly TypeAttributes Attributes;

	public readonly string Name;

	public readonly TypeDefinitionTreatment Treatment;

	public readonly Collection<MethodDefinition> RedirectedMethods;

	public readonly Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces;

	public TypeDefinitionProjection(TypeDefinition type, TypeDefinitionTreatment treatment, Collection<MethodDefinition> redirectedMethods, Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
	{
		Attributes = type.Attributes;
		Name = type.Name;
		Treatment = treatment;
		RedirectedMethods = redirectedMethods;
		RedirectedInterfaces = redirectedInterfaces;
	}
}


using Mono.Cecil;

internal sealed class TypeReferenceProjection
{
	public readonly string Name;

	public readonly string Namespace;

	public readonly IMetadataScope Scope;

	public readonly TypeReferenceTreatment Treatment;

	public TypeReferenceProjection(TypeReference type, TypeReferenceTreatment treatment)
	{
		Name = type.Name;
		Namespace = type.Namespace;
		Scope = type.Scope;
		Treatment = treatment;
	}
}


using Mono.Cecil;

internal sealed class MethodDefinitionProjection
{
	public readonly MethodAttributes Attributes;

	public readonly MethodImplAttributes ImplAttributes;

	public readonly string Name;

	public readonly MethodDefinitionTreatment Treatment;

	public MethodDefinitionProjection(MethodDefinition method, MethodDefinitionTreatment treatment)
	{
		Attributes = method.Attributes;
		ImplAttributes = method.ImplAttributes;
		Name = method.Name;
		Treatment = treatment;
	}
}


using Mono.Cecil;

internal sealed class FieldDefinitionProjection
{
	public readonly FieldAttributes Attributes;

	public readonly FieldDefinitionTreatment Treatment;

	public FieldDefinitionProjection(FieldDefinition field, FieldDefinitionTreatment treatment)
	{
		Attributes = field.Attributes;
		Treatment = treatment;
	}
}


using System;
using Mono.Cecil;

internal sealed class CustomAttributeValueProjection
{
	public readonly AttributeTargets Targets;

	public readonly CustomAttributeValueTreatment Treatment;

	public CustomAttributeValueProjection(AttributeTargets targets, CustomAttributeValueTreatment treatment)
	{
		Targets = targets;
		Treatment = treatment;
	}
}


using System;
using System.Collections.Generic;
using System.Threading;
using Mono.Cecil;
using Mono.Collections.Generic;

internal sealed class WindowsRuntimeProjections
{
	private struct ProjectionInfo
	{
		public readonly string WinRTNamespace;

		public readonly string ClrNamespace;

		public readonly string ClrName;

		public readonly string ClrAssembly;

		public readonly bool Attribute;

		public ProjectionInfo(string winrt_namespace, string clr_namespace, string clr_name, string clr_assembly, bool attribute = false)
		{
			WinRTNamespace = winrt_namespace;
			ClrNamespace = clr_namespace;
			ClrName = clr_name;
			ClrAssembly = clr_assembly;
			Attribute = attribute;
		}
	}

	private static readonly Version version = new Version(4, 0, 0, 0);

	private static readonly byte[] contract_pk_token = new byte[8] { 176, 63, 95, 127, 17, 213, 10, 58 };

	private static readonly byte[] contract_pk = new byte[160]
	{
		0, 36, 0, 0, 4, 128, 0, 0, 148, 0,
		0, 0, 6, 2, 0, 0, 0, 36, 0, 0,
		82, 83, 65, 49, 0, 4, 0, 0, 1, 0,
		1, 0, 7, 209, 250, 87, 196, 174, 217, 240,
		163, 46, 132, 170, 15, 174, 253, 13, 233, 232,
		253, 106, 236, 143, 135, 251, 3, 118, 108, 131,
		76, 153, 146, 30, 178, 59, 231, 154, 217, 213,
		220, 193, 221, 154, 210, 54, 19, 33, 2, 144,
		11, 114, 60, 249, 128, 149, 127, 196, 225, 119,
		16, 143, 198, 7, 119, 79, 41, 232, 50, 14,
		146, 234, 5, 236, 228, 232, 33, 192, 165, 239,
		232, 241, 100, 92, 76, 12, 147, 193, 171, 153,
		40, 93, 98, 44, 170, 101, 44, 29, 250, 214,
		61, 116, 93, 111, 45, 229, 241, 126, 94, 175,
		15, 196, 150, 61, 38, 28, 138, 18, 67, 101,
		24, 32, 109, 192, 147, 52, 77, 90, 210, 147
	};

	private static Dictionary<string, ProjectionInfo> projections;

	private readonly ModuleDefinition module;

	private Version corlib_version = new Version(255, 255, 255, 255);

	private AssemblyNameReference[] virtual_references;

	private static Dictionary<string, ProjectionInfo> Projections
	{
		get
		{
			if (projections != null)
			{
				return projections;
			}
			Dictionary<string, ProjectionInfo> value = new Dictionary<string, ProjectionInfo>
			{
				{
					"AttributeTargets",
					new ProjectionInfo("Windows.Foundation.Metadata", "System", "AttributeTargets", "System.Runtime")
				},
				{
					"AttributeUsageAttribute",
					new ProjectionInfo("Windows.Foundation.Metadata", "System", "AttributeUsageAttribute", "System.Runtime", attribute: true)
				},
				{
					"Color",
					new ProjectionInfo("Windows.UI", "Windows.UI", "Color", "System.Runtime.WindowsRuntime")
				},
				{
					"CornerRadius",
					new ProjectionInfo("Windows.UI.Xaml", "Windows.UI.Xaml", "CornerRadius", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"DateTime",
					new ProjectionInfo("Windows.Foundation", "System", "DateTimeOffset", "System.Runtime")
				},
				{
					"Duration",
					new ProjectionInfo("Windows.UI.Xaml", "Windows.UI.Xaml", "Duration", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"DurationType",
					new ProjectionInfo("Windows.UI.Xaml", "Windows.UI.Xaml", "DurationType", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"EventHandler`1",
					new ProjectionInfo("Windows.Foundation", "System", "EventHandler`1", "System.Runtime")
				},
				{
					"EventRegistrationToken",
					new ProjectionInfo("Windows.Foundation", "System.Runtime.InteropServices.WindowsRuntime", "EventRegistrationToken", "System.Runtime.InteropServices.WindowsRuntime")
				},
				{
					"GeneratorPosition",
					new ProjectionInfo("Windows.UI.Xaml.Controls.Primitives", "Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"GridLength",
					new ProjectionInfo("Windows.UI.Xaml", "Windows.UI.Xaml", "GridLength", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"GridUnitType",
					new ProjectionInfo("Windows.UI.Xaml", "Windows.UI.Xaml", "GridUnitType", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"HResult",
					new ProjectionInfo("Windows.Foundation", "System", "Exception", "System.Runtime")
				},
				{
					"IBindableIterable",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System.Collections", "IEnumerable", "System.Runtime")
				},
				{
					"IBindableVector",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System.Collections", "IList", "System.Runtime")
				},
				{
					"IClosable",
					new ProjectionInfo("Windows.Foundation", "System", "IDisposable", "System.Runtime")
				},
				{
					"ICommand",
					new ProjectionInfo("Windows.UI.Xaml.Input", "System.Windows.Input", "ICommand", "System.ObjectModel")
				},
				{
					"IIterable`1",
					new ProjectionInfo("Windows.Foundation.Collections", "System.Collections.Generic", "IEnumerable`1", "System.Runtime")
				},
				{
					"IKeyValuePair`2",
					new ProjectionInfo("Windows.Foundation.Collections", "System.Collections.Generic", "KeyValuePair`2", "System.Runtime")
				},
				{
					"IMapView`2",
					new ProjectionInfo("Windows.Foundation.Collections", "System.Collections.Generic", "IReadOnlyDictionary`2", "System.Runtime")
				},
				{
					"IMap`2",
					new ProjectionInfo("Windows.Foundation.Collections", "System.Collections.Generic", "IDictionary`2", "System.Runtime")
				},
				{
					"INotifyCollectionChanged",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "INotifyCollectionChanged", "System.ObjectModel")
				},
				{
					"INotifyPropertyChanged",
					new ProjectionInfo("Windows.UI.Xaml.Data", "System.ComponentModel", "INotifyPropertyChanged", "System.ObjectModel")
				},
				{
					"IReference`1",
					new ProjectionInfo("Windows.Foundation", "System", "Nullable`1", "System.Runtime")
				},
				{
					"IVectorView`1",
					new ProjectionInfo("Windows.Foundation.Collections", "System.Collections.Generic", "IReadOnlyList`1", "System.Runtime")
				},
				{
					"IVector`1",
					new ProjectionInfo("Windows.Foundation.Collections", "System.Collections.Generic", "IList`1", "System.Runtime")
				},
				{
					"KeyTime",
					new ProjectionInfo("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "KeyTime", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"Matrix",
					new ProjectionInfo("Windows.UI.Xaml.Media", "Windows.UI.Xaml.Media", "Matrix", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"Matrix3D",
					new ProjectionInfo("Windows.UI.Xaml.Media.Media3D", "Windows.UI.Xaml.Media.Media3D", "Matrix3D", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"Matrix3x2",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Matrix3x2", "System.Numerics.Vectors")
				},
				{
					"Matrix4x4",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Matrix4x4", "System.Numerics.Vectors")
				},
				{
					"NotifyCollectionChangedAction",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedAction", "System.ObjectModel")
				},
				{
					"NotifyCollectionChangedEventArgs",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedEventArgs", "System.ObjectModel")
				},
				{
					"NotifyCollectionChangedEventHandler",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System.Collections.Specialized", "NotifyCollectionChangedEventHandler", "System.ObjectModel")
				},
				{
					"Plane",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Plane", "System.Numerics.Vectors")
				},
				{
					"Point",
					new ProjectionInfo("Windows.Foundation", "Windows.Foundation", "Point", "System.Runtime.WindowsRuntime")
				},
				{
					"PropertyChangedEventArgs",
					new ProjectionInfo("Windows.UI.Xaml.Data", "System.ComponentModel", "PropertyChangedEventArgs", "System.ObjectModel")
				},
				{
					"PropertyChangedEventHandler",
					new ProjectionInfo("Windows.UI.Xaml.Data", "System.ComponentModel", "PropertyChangedEventHandler", "System.ObjectModel")
				},
				{
					"Quaternion",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Quaternion", "System.Numerics.Vectors")
				},
				{
					"Rect",
					new ProjectionInfo("Windows.Foundation", "Windows.Foundation", "Rect", "System.Runtime.WindowsRuntime")
				},
				{
					"RepeatBehavior",
					new ProjectionInfo("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "RepeatBehavior", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"RepeatBehaviorType",
					new ProjectionInfo("Windows.UI.Xaml.Media.Animation", "Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"Size",
					new ProjectionInfo("Windows.Foundation", "Windows.Foundation", "Size", "System.Runtime.WindowsRuntime")
				},
				{
					"Thickness",
					new ProjectionInfo("Windows.UI.Xaml", "Windows.UI.Xaml", "Thickness", "System.Runtime.WindowsRuntime.UI.Xaml")
				},
				{
					"TimeSpan",
					new ProjectionInfo("Windows.Foundation", "System", "TimeSpan", "System.Runtime")
				},
				{
					"TypeName",
					new ProjectionInfo("Windows.UI.Xaml.Interop", "System", "Type", "System.Runtime")
				},
				{
					"Uri",
					new ProjectionInfo("Windows.Foundation", "System", "Uri", "System.Runtime")
				},
				{
					"Vector2",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Vector2", "System.Numerics.Vectors")
				},
				{
					"Vector3",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Vector3", "System.Numerics.Vectors")
				},
				{
					"Vector4",
					new ProjectionInfo("Windows.Foundation.Numerics", "System.Numerics", "Vector4", "System.Numerics.Vectors")
				}
			};
			Interlocked.CompareExchange(ref projections, value, null);
			return projections;
		}
	}

	private AssemblyNameReference[] VirtualReferences
	{
		get
		{
			if (virtual_references == null)
			{
				Mixin.Read(module.AssemblyReferences);
			}
			return virtual_references;
		}
	}

	public WindowsRuntimeProjections(ModuleDefinition module)
	{
		this.module = module;
	}

	public static void Project(TypeDefinition type)
	{
		TypeDefinitionTreatment typeDefinitionTreatment = TypeDefinitionTreatment.None;
		MetadataKind metadataKind = type.Module.MetadataKind;
		Collection<MethodDefinition> redirectedMethods = null;
		Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces = null;
		if (type.IsWindowsRuntime)
		{
			switch (metadataKind)
			{
			case MetadataKind.WindowsMetadata:
			{
				typeDefinitionTreatment = GetWellKnownTypeDefinitionTreatment(type);
				if (typeDefinitionTreatment != 0)
				{
					ApplyProjection(type, new TypeDefinitionProjection(type, typeDefinitionTreatment, redirectedMethods, redirectedInterfaces));
					return;
				}
				TypeReference baseType = type.BaseType;
				typeDefinitionTreatment = ((baseType == null || !IsAttribute(baseType)) ? GenerateRedirectionInformation(type, out redirectedMethods, out redirectedInterfaces) : TypeDefinitionTreatment.NormalAttribute);
				break;
			}
			case MetadataKind.ManagedWindowsMetadata:
				if (NeedsWindowsRuntimePrefix(type))
				{
					typeDefinitionTreatment = TypeDefinitionTreatment.PrefixWindowsRuntimeName;
				}
				break;
			}
			if ((typeDefinitionTreatment == TypeDefinitionTreatment.PrefixWindowsRuntimeName || typeDefinitionTreatment == TypeDefinitionTreatment.NormalType) && !type.IsInterface && HasAttribute(type.CustomAttributes, "Windows.UI.Xaml", "TreatAsAbstractComposableClassAttribute"))
			{
				typeDefinitionTreatment |= TypeDefinitionTreatment.Abstract;
			}
		}
		else if (metadataKind == MetadataKind.ManagedWindowsMetadata && IsClrImplementationType(type))
		{
			typeDefinitionTreatment = TypeDefinitionTreatment.UnmangleWindowsRuntimeName;
		}
		if (typeDefinitionTreatment != 0)
		{
			ApplyProjection(type, new TypeDefinitionProjection(type, typeDefinitionTreatment, redirectedMethods, redirectedInterfaces));
		}
	}

	private static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type)
	{
		if (!Projections.TryGetValue(type.Name, out var value))
		{
			return TypeDefinitionTreatment.None;
		}
		TypeDefinitionTreatment typeDefinitionTreatment = (value.Attribute ? TypeDefinitionTreatment.RedirectToClrAttribute : TypeDefinitionTreatment.RedirectToClrType);
		if (type.Namespace == value.ClrNamespace)
		{
			return typeDefinitionTreatment;
		}
		if (type.Namespace == value.WinRTNamespace)
		{
			return typeDefinitionTreatment | TypeDefinitionTreatment.Internal;
		}
		return TypeDefinitionTreatment.None;
	}

	private static TypeDefinitionTreatment GenerateRedirectionInformation(TypeDefinition type, out Collection<MethodDefinition> redirectedMethods, out Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces)
	{
		bool flag = false;
		redirectedMethods = null;
		redirectedInterfaces = null;
		foreach (InterfaceImplementation @interface in type.Interfaces)
		{
			if (IsRedirectedType(@interface.InterfaceType))
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			return TypeDefinitionTreatment.NormalType;
		}
		HashSet<TypeReference> hashSet = new HashSet<TypeReference>(new TypeReferenceEqualityComparer());
		redirectedMethods = new Collection<MethodDefinition>();
		redirectedInterfaces = new Collection<KeyValuePair<InterfaceImplementation, InterfaceImplementation>>();
		foreach (InterfaceImplementation interface2 in type.Interfaces)
		{
			TypeReference interfaceType = interface2.InterfaceType;
			if (IsRedirectedType(interfaceType))
			{
				hashSet.Add(interfaceType);
				CollectImplementedInterfaces(interfaceType, hashSet);
			}
		}
		foreach (InterfaceImplementation interface3 in type.Interfaces)
		{
			TypeReference interfaceType2 = interface3.InterfaceType;
			if (!IsRedirectedType(interface3.InterfaceType))
			{
				continue;
			}
			TypeReference elementType = interfaceType2.GetElementType();
			TypeReference typeReference = new TypeReference(elementType.Namespace, elementType.Name, elementType.Module, elementType.Scope)
			{
				DeclaringType = elementType.DeclaringType,
				projection = elementType.projection
			};
			RemoveProjection(typeReference);
			if (interfaceType2 is GenericInstanceType genericInstanceType)
			{
				GenericInstanceType genericInstanceType2 = new GenericInstanceType(typeReference);
				foreach (TypeReference genericArgument in genericInstanceType.GenericArguments)
				{
					genericInstanceType2.GenericArguments.Add(genericArgument);
				}
				typeReference = genericInstanceType2;
			}
			InterfaceImplementation value = new InterfaceImplementation(typeReference);
			redirectedInterfaces.Add(new KeyValuePair<InterfaceImplementation, InterfaceImplementation>(interface3, value));
		}
		if (!type.IsInterface)
		{
			foreach (TypeReference item in hashSet)
			{
				RedirectInterfaceMethods(item, redirectedMethods);
			}
		}
		return TypeDefinitionTreatment.RedirectImplementedMethods;
	}

	private static void CollectImplementedInterfaces(TypeReference type, HashSet<TypeReference> results)
	{
		TypeResolver typeResolver = TypeResolver.For(type);
		foreach (InterfaceImplementation @interface in type.Resolve().Interfaces)
		{
			TypeReference typeReference = typeResolver.Resolve(@interface.InterfaceType);
			results.Add(typeReference);
			CollectImplementedInterfaces(typeReference, results);
		}
	}

	private static void RedirectInterfaceMethods(TypeReference interfaceType, Collection<MethodDefinition> redirectedMethods)
	{
		TypeResolver typeResolver = TypeResolver.For(interfaceType);
		foreach (MethodDefinition method in interfaceType.Resolve().Methods)
		{
			MethodDefinition methodDefinition = new MethodDefinition(method.Name, MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual | MethodAttributes.VtableLayoutMask, typeResolver.Resolve(method.ReturnType));
			methodDefinition.ImplAttributes = MethodImplAttributes.CodeTypeMask;
			foreach (ParameterDefinition parameter in method.Parameters)
			{
				methodDefinition.Parameters.Add(new ParameterDefinition(parameter.Name, parameter.Attributes, typeResolver.Resolve(parameter.ParameterType)));
			}
			methodDefinition.Overrides.Add(typeResolver.Resolve(method));
			redirectedMethods.Add(methodDefinition);
		}
	}

	private static bool IsRedirectedType(TypeReference type)
	{
		if (type.GetElementType().projection is TypeReferenceProjection typeReferenceProjection)
		{
			return typeReferenceProjection.Treatment == TypeReferenceTreatment.UseProjectionInfo;
		}
		return false;
	}

	private static bool NeedsWindowsRuntimePrefix(TypeDefinition type)
	{
		if ((type.Attributes & (TypeAttributes.VisibilityMask | TypeAttributes.ClassSemanticMask)) != TypeAttributes.Public)
		{
			return false;
		}
		TypeReference baseType = type.BaseType;
		if (baseType == null || baseType.MetadataToken.TokenType != TokenType.TypeRef)
		{
			return false;
		}
		if (baseType.Namespace == "System")
		{
			switch (baseType.Name)
			{
			case "Attribute":
			case "MulticastDelegate":
			case "ValueType":
				return false;
			}
		}
		return true;
	}

	public static bool IsClrImplementationType(TypeDefinition type)
	{
		if ((type.Attributes & (TypeAttributes.VisibilityMask | TypeAttributes.SpecialName)) != TypeAttributes.SpecialName)
		{
			return false;
		}
		return type.Name.StartsWith("<CLR>");
	}

	public static void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection)
	{
		if (projection == null)
		{
			return;
		}
		TypeDefinitionTreatment treatment = projection.Treatment;
		switch (treatment & TypeDefinitionTreatment.KindMask)
		{
		case TypeDefinitionTreatment.NormalType:
			type.Attributes |= TypeAttributes.Import | TypeAttributes.WindowsRuntime;
			break;
		case TypeDefinitionTreatment.NormalAttribute:
			type.Attributes |= TypeAttributes.Sealed | TypeAttributes.WindowsRuntime;
			break;
		case TypeDefinitionTreatment.UnmangleWindowsRuntimeName:
			type.Attributes = (TypeAttributes)(((uint)type.Attributes & 0xFFFFFBFFu) | 1);
			type.Name = type.Name.Substring("<CLR>".Length);
			break;
		case TypeDefinitionTreatment.PrefixWindowsRuntimeName:
			type.Attributes = (TypeAttributes)(((uint)type.Attributes & 0xFFFFFFFEu) | 0x1000);
			type.Name = "<WinRT>" + type.Name;
			break;
		case TypeDefinitionTreatment.RedirectToClrType:
			type.Attributes = (TypeAttributes)(((uint)type.Attributes & 0xFFFFFFFEu) | 0x1000);
			break;
		case TypeDefinitionTreatment.RedirectToClrAttribute:
			type.Attributes &= ~TypeAttributes.Public;
			break;
		case TypeDefinitionTreatment.RedirectImplementedMethods:
			type.Attributes |= TypeAttributes.Import | TypeAttributes.WindowsRuntime;
			foreach (KeyValuePair<InterfaceImplementation, InterfaceImplementation> redirectedInterface in projection.RedirectedInterfaces)
			{
				type.Interfaces.Add(redirectedInterface.Value);
				foreach (CustomAttribute customAttribute in redirectedInterface.Key.CustomAttributes)
				{
					redirectedInterface.Value.CustomAttributes.Add(customAttribute);
				}
				redirectedInterface.Key.CustomAttributes.Clear();
				foreach (MethodDefinition method in type.Methods)
				{
					foreach (MethodReference @override in method.Overrides)
					{
						if (TypeReferenceEqualityComparer.AreEqual(@override.DeclaringType, redirectedInterface.Key.InterfaceType))
						{
							@override.DeclaringType = redirectedInterface.Value.InterfaceType;
						}
					}
				}
			}
			foreach (MethodDefinition redirectedMethod in projection.RedirectedMethods)
			{
				type.Methods.Add(redirectedMethod);
			}
			break;
		}
		if ((treatment & TypeDefinitionTreatment.Abstract) != 0)
		{
			type.Attributes |= TypeAttributes.Abstract;
		}
		if ((treatment & TypeDefinitionTreatment.Internal) != 0)
		{
			type.Attributes &= ~TypeAttributes.Public;
		}
		type.WindowsRuntimeProjection = projection;
	}

	public static TypeDefinitionProjection RemoveProjection(TypeDefinition type)
	{
		if (!type.IsWindowsRuntimeProjection)
		{
			return null;
		}
		TypeDefinitionProjection windowsRuntimeProjection = type.WindowsRuntimeProjection;
		type.WindowsRuntimeProjection = null;
		type.Attributes = windowsRuntimeProjection.Attributes;
		type.Name = windowsRuntimeProjection.Name;
		if (windowsRuntimeProjection.Treatment == TypeDefinitionTreatment.RedirectImplementedMethods)
		{
			foreach (MethodDefinition redirectedMethod in windowsRuntimeProjection.RedirectedMethods)
			{
				type.Methods.Remove(redirectedMethod);
			}
			foreach (KeyValuePair<InterfaceImplementation, InterfaceImplementation> redirectedInterface in windowsRuntimeProjection.RedirectedInterfaces)
			{
				foreach (MethodDefinition method in type.Methods)
				{
					foreach (MethodReference @override in method.Overrides)
					{
						if (TypeReferenceEqualityComparer.AreEqual(@override.DeclaringType, redirectedInterface.Value.InterfaceType))
						{
							@override.DeclaringType = redirectedInterface.Key.InterfaceType;
						}
					}
				}
				foreach (CustomAttribute customAttribute in redirectedInterface.Value.CustomAttributes)
				{
					redirectedInterface.Key.CustomAttributes.Add(customAttribute);
				}
				redirectedInterface.Value.CustomAttributes.Clear();
				type.Interfaces.Remove(redirectedInterface.Value);
			}
		}
		return windowsRuntimeProjection;
	}

	public static void Project(TypeReference type)
	{
		ProjectionInfo value;
		TypeReferenceTreatment typeReferenceTreatment = ((!Projections.TryGetValue(type.Name, out value) || !(value.WinRTNamespace == type.Namespace)) ? GetSpecialTypeReferenceTreatment(type) : TypeReferenceTreatment.UseProjectionInfo);
		if (typeReferenceTreatment != 0)
		{
			ApplyProjection(type, new TypeReferenceProjection(type, typeReferenceTreatment));
		}
	}

	private static TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type)
	{
		if (type.Namespace == "System")
		{
			if (type.Name == "MulticastDelegate")
			{
				return TypeReferenceTreatment.SystemDelegate;
			}
			if (type.Name == "Attribute")
			{
				return TypeReferenceTreatment.SystemAttribute;
			}
		}
		return TypeReferenceTreatment.None;
	}

	private static bool IsAttribute(TypeReference type)
	{
		if (type.MetadataToken.TokenType != TokenType.TypeRef)
		{
			return false;
		}
		if (type.Name == "Attribute")
		{
			return type.Namespace == "System";
		}
		return false;
	}

	private static bool IsEnum(TypeReference type)
	{
		if (type.MetadataToken.TokenType != TokenType.TypeRef)
		{
			return false;
		}
		if (type.Name == "Enum")
		{
			return type.Namespace == "System";
		}
		return false;
	}

	public static void ApplyProjection(TypeReference type, TypeReferenceProjection projection)
	{
		if (projection != null)
		{
			switch (projection.Treatment)
			{
			case TypeReferenceTreatment.SystemDelegate:
			case TypeReferenceTreatment.SystemAttribute:
				type.Scope = type.Module.Projections.GetAssemblyReference("System.Runtime");
				break;
			case TypeReferenceTreatment.UseProjectionInfo:
			{
				ProjectionInfo projectionInfo = Projections[type.Name];
				type.Name = projectionInfo.ClrName;
				type.Namespace = projectionInfo.ClrNamespace;
				type.Scope = type.Module.Projections.GetAssemblyReference(projectionInfo.ClrAssembly);
				break;
			}
			}
			type.WindowsRuntimeProjection = projection;
		}
	}

	public static TypeReferenceProjection RemoveProjection(TypeReference type)
	{
		if (!type.IsWindowsRuntimeProjection)
		{
			return null;
		}
		TypeReferenceProjection windowsRuntimeProjection = type.WindowsRuntimeProjection;
		type.WindowsRuntimeProjection = null;
		type.Name = windowsRuntimeProjection.Name;
		type.Namespace = windowsRuntimeProjection.Namespace;
		type.Scope = windowsRuntimeProjection.Scope;
		return windowsRuntimeProjection;
	}

	public static void Project(MethodDefinition method)
	{
		MethodDefinitionTreatment methodDefinitionTreatment = MethodDefinitionTreatment.None;
		bool flag = false;
		TypeDefinition declaringType = method.DeclaringType;
		if (declaringType.IsWindowsRuntime)
		{
			if (IsClrImplementationType(declaringType))
			{
				methodDefinitionTreatment = MethodDefinitionTreatment.None;
			}
			else if (declaringType.IsNested)
			{
				methodDefinitionTreatment = MethodDefinitionTreatment.None;
			}
			else if (declaringType.IsInterface)
			{
				methodDefinitionTreatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
			}
			else if (declaringType.Module.MetadataKind == MetadataKind.ManagedWindowsMetadata && !method.IsPublic)
			{
				methodDefinitionTreatment = MethodDefinitionTreatment.None;
			}
			else
			{
				flag = true;
				TypeReference baseType = declaringType.BaseType;
				if (baseType != null && baseType.MetadataToken.TokenType == TokenType.TypeRef)
				{
					switch (GetSpecialTypeReferenceTreatment(baseType))
					{
					case TypeReferenceTreatment.SystemDelegate:
						methodDefinitionTreatment = MethodDefinitionTreatment.Public | MethodDefinitionTreatment.Runtime;
						flag = false;
						break;
					case TypeReferenceTreatment.SystemAttribute:
						methodDefinitionTreatment = MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
						flag = false;
						break;
					}
				}
			}
		}
		if (flag)
		{
			bool flag2 = false;
			bool flag3 = false;
			foreach (MethodReference @override in method.Overrides)
			{
				if (@override.MetadataToken.TokenType == TokenType.MemberRef && ImplementsRedirectedInterface(@override))
				{
					flag2 = true;
				}
				else
				{
					flag3 = true;
				}
			}
			if (flag2 && !flag3)
			{
				methodDefinitionTreatment = MethodDefinitionTreatment.Private | MethodDefinitionTreatment.Runtime | MethodDefinitionTreatment.InternalCall;
				flag = false;
			}
		}
		if (flag)
		{
			methodDefinitionTreatment |= GetMethodDefinitionTreatmentFromCustomAttributes(method);
		}
		if (methodDefinitionTreatment != 0)
		{
			ApplyProjection(method, new MethodDefinitionProjection(method, methodDefinitionTreatment));
		}
	}

	private static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method)
	{
		MethodDefinitionTreatment methodDefinitionTreatment = MethodDefinitionTreatment.None;
		foreach (CustomAttribute customAttribute in method.CustomAttributes)
		{
			TypeReference attributeType = customAttribute.AttributeType;
			if (!(attributeType.Namespace != "Windows.UI.Xaml"))
			{
				if (attributeType.Name == "TreatAsPublicMethodAttribute")
				{
					methodDefinitionTreatment |= MethodDefinitionTreatment.Public;
				}
				else if (attributeType.Name == "TreatAsAbstractMethodAttribute")
				{
					methodDefinitionTreatment |= MethodDefinitionTreatment.Abstract;
				}
			}
		}
		return methodDefinitionTreatment;
	}

	public static void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection)
	{
		if (projection != null)
		{
			MethodDefinitionTreatment treatment = projection.Treatment;
			if ((treatment & MethodDefinitionTreatment.Abstract) != 0)
			{
				method.Attributes |= MethodAttributes.Abstract;
			}
			if ((treatment & MethodDefinitionTreatment.Private) != 0)
			{
				method.Attributes = (method.Attributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Private;
			}
			if ((treatment & MethodDefinitionTreatment.Public) != 0)
			{
				method.Attributes = (method.Attributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Public;
			}
			if ((treatment & MethodDefinitionTreatment.Runtime) != 0)
			{
				method.ImplAttributes |= MethodImplAttributes.CodeTypeMask;
			}
			if ((treatment & MethodDefinitionTreatment.InternalCall) != 0)
			{
				method.ImplAttributes |= MethodImplAttributes.InternalCall;
			}
			method.WindowsRuntimeProjection = projection;
		}
	}

	public static MethodDefinitionProjection RemoveProjection(MethodDefinition method)
	{
		if (!method.IsWindowsRuntimeProjection)
		{
			return null;
		}
		MethodDefinitionProjection windowsRuntimeProjection = method.WindowsRuntimeProjection;
		method.WindowsRuntimeProjection = null;
		method.Attributes = windowsRuntimeProjection.Attributes;
		method.ImplAttributes = windowsRuntimeProjection.ImplAttributes;
		method.Name = windowsRuntimeProjection.Name;
		return windowsRuntimeProjection;
	}

	public static void Project(FieldDefinition field)
	{
		FieldDefinitionTreatment fieldDefinitionTreatment = FieldDefinitionTreatment.None;
		TypeDefinition declaringType = field.DeclaringType;
		if (declaringType.Module.MetadataKind == MetadataKind.WindowsMetadata && field.IsRuntimeSpecialName && field.Name == "value__")
		{
			TypeReference baseType = declaringType.BaseType;
			if (baseType != null && IsEnum(baseType))
			{
				fieldDefinitionTreatment = FieldDefinitionTreatment.Public;
			}
		}
		if (fieldDefinitionTreatment != 0)
		{
			ApplyProjection(field, new FieldDefinitionProjection(field, fieldDefinitionTreatment));
		}
	}

	public static void ApplyProjection(FieldDefinition field, FieldDefinitionProjection projection)
	{
		if (projection != null)
		{
			if (projection.Treatment == FieldDefinitionTreatment.Public)
			{
				field.Attributes = (field.Attributes & ~FieldAttributes.FieldAccessMask) | FieldAttributes.Public;
			}
			field.WindowsRuntimeProjection = projection;
		}
	}

	public static FieldDefinitionProjection RemoveProjection(FieldDefinition field)
	{
		if (!field.IsWindowsRuntimeProjection)
		{
			return null;
		}
		FieldDefinitionProjection windowsRuntimeProjection = field.WindowsRuntimeProjection;
		field.WindowsRuntimeProjection = null;
		field.Attributes = windowsRuntimeProjection.Attributes;
		return windowsRuntimeProjection;
	}

	private static bool ImplementsRedirectedInterface(MemberReference member)
	{
		TypeReference declaringType = member.DeclaringType;
		TypeReference typeReference;
		switch (declaringType.MetadataToken.TokenType)
		{
		case TokenType.TypeRef:
			typeReference = declaringType;
			break;
		case TokenType.TypeSpec:
			if (!declaringType.IsGenericInstance)
			{
				return false;
			}
			typeReference = ((TypeSpecification)declaringType).ElementType;
			if (typeReference.MetadataType != MetadataType.Class || typeReference.MetadataToken.TokenType != TokenType.TypeRef)
			{
				return false;
			}
			break;
		default:
			return false;
		}
		TypeReferenceProjection projection = RemoveProjection(typeReference);
		bool result = false;
		if (Projections.TryGetValue(typeReference.Name, out var value) && typeReference.Namespace == value.WinRTNamespace)
		{
			result = true;
		}
		ApplyProjection(typeReference, projection);
		return result;
	}

	public void AddVirtualReferences(Collection<AssemblyNameReference> references)
	{
		AssemblyNameReference coreLibrary = GetCoreLibrary(references);
		corlib_version = coreLibrary.Version;
		coreLibrary.Version = version;
		if (virtual_references == null)
		{
			AssemblyNameReference[] assemblyReferences = GetAssemblyReferences(coreLibrary);
			Interlocked.CompareExchange(ref virtual_references, assemblyReferences, null);
		}
		AssemblyNameReference[] array = virtual_references;
		foreach (AssemblyNameReference item in array)
		{
			references.Add(item);
		}
	}

	public void RemoveVirtualReferences(Collection<AssemblyNameReference> references)
	{
		GetCoreLibrary(references).Version = corlib_version;
		AssemblyNameReference[] virtualReferences = VirtualReferences;
		foreach (AssemblyNameReference item in virtualReferences)
		{
			references.Remove(item);
		}
	}

	private static AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib)
	{
		AssemblyNameReference assemblyNameReference = new AssemblyNameReference("System.Runtime", version);
		AssemblyNameReference assemblyNameReference2 = new AssemblyNameReference("System.Runtime.InteropServices.WindowsRuntime", version);
		AssemblyNameReference assemblyNameReference3 = new AssemblyNameReference("System.ObjectModel", version);
		AssemblyNameReference assemblyNameReference4 = new AssemblyNameReference("System.Runtime.WindowsRuntime", version);
		AssemblyNameReference assemblyNameReference5 = new AssemblyNameReference("System.Runtime.WindowsRuntime.UI.Xaml", version);
		AssemblyNameReference assemblyNameReference6 = new AssemblyNameReference("System.Numerics.Vectors", version);
		if (corlib.HasPublicKey)
		{
			byte[] publicKey2 = (assemblyNameReference5.PublicKey = corlib.PublicKey);
			assemblyNameReference4.PublicKey = publicKey2;
			byte[] array2 = (assemblyNameReference6.PublicKey = contract_pk);
			byte[] array4 = (assemblyNameReference3.PublicKey = array2);
			publicKey2 = (assemblyNameReference2.PublicKey = array4);
			assemblyNameReference.PublicKey = publicKey2;
		}
		else
		{
			byte[] publicKey2 = (assemblyNameReference5.PublicKeyToken = corlib.PublicKeyToken);
			assemblyNameReference4.PublicKeyToken = publicKey2;
			byte[] array2 = (assemblyNameReference6.PublicKeyToken = contract_pk_token);
			byte[] array4 = (assemblyNameReference3.PublicKeyToken = array2);
			publicKey2 = (assemblyNameReference2.PublicKeyToken = array4);
			assemblyNameReference.PublicKeyToken = publicKey2;
		}
		return new AssemblyNameReference[6] { assemblyNameReference, assemblyNameReference2, assemblyNameReference3, assemblyNameReference4, assemblyNameReference5, assemblyNameReference6 };
	}

	private static AssemblyNameReference GetCoreLibrary(Collection<AssemblyNameReference> references)
	{
		foreach (AssemblyNameReference reference in references)
		{
			if (reference.Name == "mscorlib")
			{
				return reference;
			}
		}
		throw new BadImageFormatException("Missing mscorlib reference in AssemblyRef table.");
	}

	private AssemblyNameReference GetAssemblyReference(string name)
	{
		AssemblyNameReference[] virtualReferences = VirtualReferences;
		foreach (AssemblyNameReference assemblyNameReference in virtualReferences)
		{
			if (assemblyNameReference.Name == name)
			{
				return assemblyNameReference;
			}
		}
		throw new Exception();
	}

	public static void Project(ICustomAttributeProvider owner, Collection<CustomAttribute> owner_attributes, CustomAttribute attribute)
	{
		if (!IsWindowsAttributeUsageAttribute(owner, attribute))
		{
			return;
		}
		CustomAttributeValueTreatment customAttributeValueTreatment = CustomAttributeValueTreatment.None;
		TypeDefinition typeDefinition = (TypeDefinition)owner;
		if (typeDefinition.Namespace == "Windows.Foundation.Metadata")
		{
			if (typeDefinition.Name == "VersionAttribute")
			{
				customAttributeValueTreatment = CustomAttributeValueTreatment.VersionAttribute;
			}
			else if (typeDefinition.Name == "DeprecatedAttribute")
			{
				customAttributeValueTreatment = CustomAttributeValueTreatment.DeprecatedAttribute;
			}
		}
		if (customAttributeValueTreatment == CustomAttributeValueTreatment.None)
		{
			customAttributeValueTreatment = ((!HasAttribute(owner_attributes, "Windows.Foundation.Metadata", "AllowMultipleAttribute")) ? CustomAttributeValueTreatment.AllowSingle : CustomAttributeValueTreatment.AllowMultiple);
		}
		if (customAttributeValueTreatment != 0)
		{
			AttributeTargets targets = (AttributeTargets)attribute.ConstructorArguments[0].Value;
			ApplyProjection(attribute, new CustomAttributeValueProjection(targets, customAttributeValueTreatment));
		}
	}

	private static bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute)
	{
		if (owner.MetadataToken.TokenType != TokenType.TypeDef)
		{
			return false;
		}
		MethodReference constructor = attribute.Constructor;
		if (constructor.MetadataToken.TokenType != TokenType.MemberRef)
		{
			return false;
		}
		TypeReference declaringType = constructor.DeclaringType;
		if (declaringType.MetadataToken.TokenType != TokenType.TypeRef)
		{
			return false;
		}
		if (declaringType.Name == "AttributeUsageAttribute")
		{
			return declaringType.Namespace == "System";
		}
		return false;
	}

	private static bool HasAttribute(Collection<CustomAttribute> attributes, string @namespace, string name)
	{
		foreach (CustomAttribute attribute in attributes)
		{
			TypeReference attributeType = attribute.AttributeType;
			if (attributeType.Name == name && attributeType.Namespace == @namespace)
			{
				return true;
			}
		}
		return false;
	}

	public static void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection)
	{
		if (projection != null)
		{
			bool flag;
			bool flag2;
			switch (projection.Treatment)
			{
			case CustomAttributeValueTreatment.AllowSingle:
				flag = false;
				flag2 = false;
				break;
			case CustomAttributeValueTreatment.AllowMultiple:
				flag = false;
				flag2 = true;
				break;
			case CustomAttributeValueTreatment.VersionAttribute:
			case CustomAttributeValueTreatment.DeprecatedAttribute:
				flag = true;
				flag2 = true;
				break;
			default:
				throw new ArgumentException();
			}
			AttributeTargets attributeTargets = (AttributeTargets)attribute.ConstructorArguments[0].Value;
			if (flag)
			{
				attributeTargets |= AttributeTargets.Constructor | AttributeTargets.Property;
			}
			attribute.ConstructorArguments[0] = new CustomAttributeArgument(attribute.ConstructorArguments[0].Type, attributeTargets);
			attribute.Properties.Add(new CustomAttributeNamedArgument("AllowMultiple", new CustomAttributeArgument(attribute.Module.TypeSystem.Boolean, flag2)));
			attribute.projection = projection;
		}
	}

	public static CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute)
	{
		if (attribute.projection == null)
		{
			return null;
		}
		CustomAttributeValueProjection projection = attribute.projection;
		attribute.projection = null;
		attribute.ConstructorArguments[0] = new CustomAttributeArgument(attribute.ConstructorArguments[0].Type, projection.Targets);
		attribute.Properties.Clear();
		return projection;
	}
}


private struct ProjectionInfo
{
	public readonly string WinRTNamespace;

	public readonly string ClrNamespace;

	public readonly string ClrName;

	public readonly string ClrAssembly;

	public readonly bool Attribute;

	public ProjectionInfo(string winrt_namespace, string clr_namespace, string clr_name, string clr_assembly, bool attribute = false)
	{
		WinRTNamespace = winrt_namespace;
		ClrNamespace = clr_namespace;
		ClrName = clr_name;
		ClrAssembly = clr_assembly;
		Attribute = attribute;
	}
}


using System;
using Mono.Cecil;

internal struct MetadataToken : IEquatable<MetadataToken>
{
	private readonly uint token;

	public static readonly MetadataToken Zero = new MetadataToken(0u);

	public uint RID => token & 0xFFFFFF;

	public TokenType TokenType => (TokenType)(token & 0xFF000000u);

	public MetadataToken(uint token)
	{
		this.token = token;
	}

	public MetadataToken(TokenType type)
		: this(type, 0)
	{
	}

	public MetadataToken(TokenType type, uint rid)
	{
		token = (uint)type | rid;
	}

	public MetadataToken(TokenType type, int rid)
	{
		token = (uint)type | (uint)rid;
	}

	public int ToInt32()
	{
		return (int)token;
	}

	public uint ToUInt32()
	{
		return token;
	}

	public override int GetHashCode()
	{
		return (int)token;
	}

	public bool Equals(MetadataToken other)
	{
		return other.token == token;
	}

	public override bool Equals(object obj)
	{
		if (obj is MetadataToken)
		{
			return ((MetadataToken)obj).token == token;
		}
		return false;
	}

	public static bool operator ==(MetadataToken one, MetadataToken other)
	{
		return one.token == other.token;
	}

	public static bool operator !=(MetadataToken one, MetadataToken other)
	{
		return one.token != other.token;
	}

	public override string ToString()
	{
		return string.Format("[{0}:0x{1}]", TokenType, RID.ToString("x4"));
	}
}


internal enum TokenType : uint
{
	Module = 0u,
	TypeRef = 16777216u,
	TypeDef = 33554432u,
	Field = 67108864u,
	Method = 100663296u,
	Param = 134217728u,
	InterfaceImpl = 150994944u,
	MemberRef = 167772160u,
	CustomAttribute = 201326592u,
	Permission = 234881024u,
	Signature = 285212672u,
	Event = 335544320u,
	Property = 385875968u,
	ModuleRef = 436207616u,
	TypeSpec = 452984832u,
	Assembly = 536870912u,
	AssemblyRef = 587202560u,
	File = 637534208u,
	ExportedType = 654311424u,
	ManifestResource = 671088640u,
	GenericParam = 704643072u,
	MethodSpec = 721420288u,
	GenericParamConstraint = 738197504u,
	Document = 805306368u,
	MethodDebugInformation = 822083584u,
	LocalScope = 838860800u,
	LocalVariable = 855638016u,
	LocalConstant = 872415232u,
	ImportScope = 889192448u,
	StateMachineMethod = 905969664u,
	CustomDebugInformation = 922746880u,
	String = 1879048192u
}


using System;
using System.IO;
using System.Security.Cryptography;
using Mono;
using Mono.Cecil;
using Mono.Cecil.PE;
using Mono.Security.Cryptography;

internal static class CryptoService
{
	public static byte[] GetPublicKey(WriterParameters parameters)
	{
		using RSA rsa = parameters.CreateRSA();
		byte[] array = CryptoConvert.ToCapiPublicKeyBlob(rsa);
		byte[] array2 = new byte[12 + array.Length];
		Buffer.BlockCopy(array, 0, array2, 12, array.Length);
		array2[1] = 36;
		array2[4] = 4;
		array2[5] = 128;
		array2[8] = (byte)array.Length;
		array2[9] = (byte)(array.Length >> 8);
		array2[10] = (byte)(array.Length >> 16);
		array2[11] = (byte)(array.Length >> 24);
		return array2;
	}

	public static void StrongName(Stream stream, ImageWriter writer, WriterParameters parameters)
	{
		int strong_name_pointer;
		byte[] strong_name = CreateStrongName(parameters, HashStream(stream, writer, out strong_name_pointer));
		PatchStrongName(stream, strong_name_pointer, strong_name);
	}

	private static void PatchStrongName(Stream stream, int strong_name_pointer, byte[] strong_name)
	{
		stream.Seek(strong_name_pointer, SeekOrigin.Begin);
		stream.Write(strong_name, 0, strong_name.Length);
	}

	private static byte[] CreateStrongName(WriterParameters parameters, byte[] hash)
	{
		using RSA key = parameters.CreateRSA();
		RSAPKCS1SignatureFormatter rSAPKCS1SignatureFormatter = new RSAPKCS1SignatureFormatter(key);
		rSAPKCS1SignatureFormatter.SetHashAlgorithm("SHA1");
		byte[] array = rSAPKCS1SignatureFormatter.CreateSignature(hash);
		Array.Reverse((Array)array);
		return array;
	}

	private static byte[] HashStream(Stream stream, ImageWriter writer, out int strong_name_pointer)
	{
		Section text = writer.text;
		int headerSize = (int)writer.GetHeaderSize();
		int pointerToRawData = (int)text.PointerToRawData;
		DataDirectory strongNameSignatureDirectory = writer.GetStrongNameSignatureDirectory();
		if (strongNameSignatureDirectory.Size == 0)
		{
			throw new InvalidOperationException();
		}
		strong_name_pointer = (int)(pointerToRawData + (strongNameSignatureDirectory.VirtualAddress - text.VirtualAddress));
		int size = (int)strongNameSignatureDirectory.Size;
		SHA1Managed sHA1Managed = new SHA1Managed();
		byte[] buffer = new byte[8192];
		using (CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write))
		{
			stream.Seek(0L, SeekOrigin.Begin);
			CopyStreamChunk(stream, dest_stream, buffer, headerSize);
			stream.Seek(pointerToRawData, SeekOrigin.Begin);
			CopyStreamChunk(stream, dest_stream, buffer, strong_name_pointer - pointerToRawData);
			stream.Seek(size, SeekOrigin.Current);
			CopyStreamChunk(stream, dest_stream, buffer, (int)(stream.Length - (strong_name_pointer + size)));
		}
		return sHA1Managed.Hash;
	}

	public static void CopyStreamChunk(Stream stream, Stream dest_stream, byte[] buffer, int length)
	{
		while (length > 0)
		{
			int num = stream.Read(buffer, 0, Math.Min(buffer.Length, length));
			dest_stream.Write(buffer, 0, num);
			length -= num;
		}
	}

	public static byte[] ComputeHash(string file)
	{
		if (!File.Exists(file))
		{
			return Empty<byte>.Array;
		}
		using FileStream stream = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.Read);
		return ComputeHash(stream);
	}

	public static byte[] ComputeHash(Stream stream)
	{
		SHA1Managed sHA1Managed = new SHA1Managed();
		byte[] buffer = new byte[8192];
		using (CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write))
		{
			CopyStreamChunk(stream, dest_stream, buffer, (int)stream.Length);
		}
		return sHA1Managed.Hash;
	}

	public static byte[] ComputeHash(params ByteBuffer[] buffers)
	{
		SHA1Managed sHA1Managed = new SHA1Managed();
		using (CryptoStream cryptoStream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write))
		{
			for (int i = 0; i < buffers.Length; i++)
			{
				cryptoStream.Write(buffers[i].buffer, 0, buffers[i].length);
			}
		}
		return sHA1Managed.Hash;
	}

	public static Guid ComputeGuid(byte[] hash)
	{
		byte[] array = new byte[16];
		Buffer.BlockCopy(hash, 0, array, 0, 16);
		array[7] = (byte)((array[7] & 0xF) | 0x40);
		array[8] = (byte)((array[8] & 0x3F) | 0x80);
		return new Guid(array);
	}
}


using System.IO;
using Mono.Cecil.PE;

internal class BinaryStreamReader : BinaryReader
{
	public int Position
	{
		get
		{
			return (int)BaseStream.Position;
		}
		set
		{
			BaseStream.Position = value;
		}
	}

	public int Length => (int)BaseStream.Length;

	public BinaryStreamReader(Stream stream)
		: base(stream)
	{
	}

	public void Advance(int bytes)
	{
		BaseStream.Seek(bytes, SeekOrigin.Current);
	}

	public void MoveTo(uint position)
	{
		BaseStream.Seek(position, SeekOrigin.Begin);
	}

	public void Align(int align)
	{
		align--;
		int position = Position;
		Advance(((position + align) & ~align) - position);
	}

	public DataDirectory ReadDataDirectory()
	{
		return new DataDirectory(ReadUInt32(), ReadUInt32());
	}
}


using System.IO;
using Mono.Cecil.PE;

internal class BinaryStreamWriter : BinaryWriter
{
	public int Position
	{
		get
		{
			return (int)BaseStream.Position;
		}
		set
		{
			BaseStream.Position = value;
		}
	}

	public BinaryStreamWriter(Stream stream)
		: base(stream)
	{
	}

	public void WriteByte(byte value)
	{
		Write(value);
	}

	public void WriteUInt16(ushort value)
	{
		Write(value);
	}

	public void WriteInt16(short value)
	{
		Write(value);
	}

	public void WriteUInt32(uint value)
	{
		Write(value);
	}

	public void WriteInt32(int value)
	{
		Write(value);
	}

	public void WriteUInt64(ulong value)
	{
		Write(value);
	}

	public void WriteBytes(byte[] bytes)
	{
		Write(bytes);
	}

	public void WriteDataDirectory(DataDirectory directory)
	{
		Write(directory.VirtualAddress);
		Write(directory.Size);
	}

	public void WriteBuffer(ByteBuffer buffer)
	{
		Write(buffer.buffer, 0, buffer.length);
	}

	protected void Advance(int bytes)
	{
		BaseStream.Seek(bytes, SeekOrigin.Current);
	}

	public void Align(int align)
	{
		align--;
		int position = Position;
		int num = ((position + align) & ~align) - position;
		for (int i = 0; i < num; i++)
		{
			WriteByte(0);
		}
	}
}


using System;
using Mono;
using Mono.Cecil.PE;

internal class ByteBuffer
{
	internal byte[] buffer;

	internal int length;

	internal int position;

	public ByteBuffer()
	{
		buffer = Empty<byte>.Array;
	}

	public ByteBuffer(int length)
	{
		buffer = new byte[length];
	}

	public ByteBuffer(byte[] buffer)
	{
		this.buffer = buffer ?? Empty<byte>.Array;
		length = this.buffer.Length;
	}

	public void Advance(int length)
	{
		position += length;
	}

	public byte ReadByte()
	{
		return buffer[position++];
	}

	public sbyte ReadSByte()
	{
		return (sbyte)ReadByte();
	}

	public byte[] ReadBytes(int length)
	{
		byte[] array = new byte[length];
		Buffer.BlockCopy(buffer, position, array, 0, length);
		position += length;
		return array;
	}

	public ushort ReadUInt16()
	{
		ushort result = (ushort)(buffer[position] | (buffer[position + 1] << 8));
		position += 2;
		return result;
	}

	public short ReadInt16()
	{
		return (short)ReadUInt16();
	}

	public uint ReadUInt32()
	{
		int result = buffer[position] | (buffer[position + 1] << 8) | (buffer[position + 2] << 16) | (buffer[position + 3] << 24);
		position += 4;
		return (uint)result;
	}

	public int ReadInt32()
	{
		return (int)ReadUInt32();
	}

	public ulong ReadUInt64()
	{
		uint num = ReadUInt32();
		return ((ulong)ReadUInt32() << 32) | num;
	}

	public long ReadInt64()
	{
		return (long)ReadUInt64();
	}

	public uint ReadCompressedUInt32()
	{
		byte b = ReadByte();
		if ((b & 0x80) == 0)
		{
			return b;
		}
		if ((b & 0x40) == 0)
		{
			return (uint)(((b & -129) << 8) | ReadByte());
		}
		return (uint)(((b & -193) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte());
	}

	public int ReadCompressedInt32()
	{
		byte b = buffer[position];
		uint num = ReadCompressedUInt32();
		int num2 = (int)num >> 1;
		if ((num & 1) == 0)
		{
			return num2;
		}
		switch (b & 0xC0)
		{
		case 0:
		case 64:
			return num2 - 64;
		case 128:
			return num2 - 8192;
		default:
			return num2 - 268435456;
		}
	}

	public float ReadSingle()
	{
		if (!BitConverter.IsLittleEndian)
		{
			byte[] array = ReadBytes(4);
			Array.Reverse((Array)array);
			return BitConverter.ToSingle(array, 0);
		}
		float result = BitConverter.ToSingle(buffer, position);
		position += 4;
		return result;
	}

	public double ReadDouble()
	{
		if (!BitConverter.IsLittleEndian)
		{
			byte[] array = ReadBytes(8);
			Array.Reverse((Array)array);
			return BitConverter.ToDouble(array, 0);
		}
		double result = BitConverter.ToDouble(buffer, position);
		position += 8;
		return result;
	}

	public void WriteByte(byte value)
	{
		if (position == buffer.Length)
		{
			Grow(1);
		}
		buffer[position++] = value;
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteSByte(sbyte value)
	{
		WriteByte((byte)value);
	}

	public void WriteUInt16(ushort value)
	{
		if (position + 2 > buffer.Length)
		{
			Grow(2);
		}
		buffer[position++] = (byte)value;
		buffer[position++] = (byte)(value >> 8);
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteInt16(short value)
	{
		WriteUInt16((ushort)value);
	}

	public void WriteUInt32(uint value)
	{
		if (position + 4 > buffer.Length)
		{
			Grow(4);
		}
		buffer[position++] = (byte)value;
		buffer[position++] = (byte)(value >> 8);
		buffer[position++] = (byte)(value >> 16);
		buffer[position++] = (byte)(value >> 24);
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteInt32(int value)
	{
		WriteUInt32((uint)value);
	}

	public void WriteUInt64(ulong value)
	{
		if (position + 8 > buffer.Length)
		{
			Grow(8);
		}
		buffer[position++] = (byte)value;
		buffer[position++] = (byte)(value >> 8);
		buffer[position++] = (byte)(value >> 16);
		buffer[position++] = (byte)(value >> 24);
		buffer[position++] = (byte)(value >> 32);
		buffer[position++] = (byte)(value >> 40);
		buffer[position++] = (byte)(value >> 48);
		buffer[position++] = (byte)(value >> 56);
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteInt64(long value)
	{
		WriteUInt64((ulong)value);
	}

	public void WriteCompressedUInt32(uint value)
	{
		if (value < 128)
		{
			WriteByte((byte)value);
			return;
		}
		if (value < 16384)
		{
			WriteByte((byte)(0x80 | (value >> 8)));
			WriteByte((byte)(value & 0xFF));
			return;
		}
		WriteByte((byte)((value >> 24) | 0xC0));
		WriteByte((byte)((value >> 16) & 0xFF));
		WriteByte((byte)((value >> 8) & 0xFF));
		WriteByte((byte)(value & 0xFF));
	}

	public void WriteCompressedInt32(int value)
	{
		if (value >= 0)
		{
			WriteCompressedUInt32((uint)(value << 1));
			return;
		}
		if (value > -64)
		{
			value = 64 + value;
		}
		else if (value >= -8192)
		{
			value = 8192 + value;
		}
		else if (value >= -536870912)
		{
			value = 536870912 + value;
		}
		WriteCompressedUInt32((uint)((value << 1) | 1));
	}

	public void WriteBytes(byte[] bytes)
	{
		int num = bytes.Length;
		if (position + num > buffer.Length)
		{
			Grow(num);
		}
		Buffer.BlockCopy(bytes, 0, buffer, position, num);
		position += num;
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteBytes(int length)
	{
		if (position + length > buffer.Length)
		{
			Grow(length);
		}
		position += length;
		if (position > this.length)
		{
			this.length = position;
		}
	}

	public void WriteBytes(ByteBuffer buffer)
	{
		if (position + buffer.length > this.buffer.Length)
		{
			Grow(buffer.length);
		}
		Buffer.BlockCopy(buffer.buffer, 0, this.buffer, position, buffer.length);
		position += buffer.length;
		if (position > length)
		{
			length = position;
		}
	}

	public void WriteSingle(float value)
	{
		byte[] bytes = BitConverter.GetBytes(value);
		if (!BitConverter.IsLittleEndian)
		{
			Array.Reverse((Array)bytes);
		}
		WriteBytes(bytes);
	}

	public void WriteDouble(double value)
	{
		byte[] bytes = BitConverter.GetBytes(value);
		if (!BitConverter.IsLittleEndian)
		{
			Array.Reverse((Array)bytes);
		}
		WriteBytes(bytes);
	}

	private void Grow(int desired)
	{
		byte[] array = buffer;
		int num = array.Length;
		byte[] dst = new byte[Math.Max(num + desired, num * 2)];
		Buffer.BlockCopy(array, 0, dst, 0, num);
		buffer = dst;
	}
}


using System.Collections.Generic;
using Mono.Cecil.PE;

internal sealed class ByteBufferEqualityComparer : IEqualityComparer<ByteBuffer>
{
	public bool Equals(ByteBuffer x, ByteBuffer y)
	{
		if (x.length != y.length)
		{
			return false;
		}
		byte[] buffer = x.buffer;
		byte[] buffer2 = y.buffer;
		for (int i = 0; i < x.length; i++)
		{
			if (buffer[i] != buffer2[i])
			{
				return false;
			}
		}
		return true;
	}

	public int GetHashCode(ByteBuffer buffer)
	{
		int num = -2128831035;
		byte[] buffer2 = buffer.buffer;
		for (int i = 0; i < buffer.length; i++)
		{
			num = (num ^ buffer2[i]) * 16777619;
		}
		return num;
	}
}


internal struct DataDirectory
{
	public readonly uint VirtualAddress;

	public readonly uint Size;

	public bool IsZero
	{
		get
		{
			if (VirtualAddress == 0)
			{
				return Size == 0;
			}
			return false;
		}
	}

	public DataDirectory(uint rva, uint size)
	{
		VirtualAddress = rva;
		Size = size;
	}
}


using System;
using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class Image : IDisposable
{
	public Disposable<Stream> Stream;

	public string FileName;

	public ModuleKind Kind;

	public uint Characteristics;

	public string RuntimeVersion;

	public TargetArchitecture Architecture;

	public ModuleCharacteristics DllCharacteristics;

	public ushort LinkerVersion;

	public ushort SubSystemMajor;

	public ushort SubSystemMinor;

	public ImageDebugHeader DebugHeader;

	public Section[] Sections;

	public Section MetadataSection;

	public uint EntryPointToken;

	public uint Timestamp;

	public ModuleAttributes Attributes;

	public DataDirectory Win32Resources;

	public DataDirectory Debug;

	public DataDirectory Resources;

	public DataDirectory StrongName;

	public StringHeap StringHeap;

	public BlobHeap BlobHeap;

	public UserStringHeap UserStringHeap;

	public GuidHeap GuidHeap;

	public TableHeap TableHeap;

	public PdbHeap PdbHeap;

	private readonly int[] coded_index_sizes = new int[14];

	private readonly Func<Table, int> counter;

	public Image()
	{
		counter = GetTableLength;
	}

	public bool HasTable(Table table)
	{
		return GetTableLength(table) > 0;
	}

	public int GetTableLength(Table table)
	{
		return (int)TableHeap[table].Length;
	}

	public int GetTableIndexSize(Table table)
	{
		if (GetTableLength(table) >= 65536)
		{
			return 4;
		}
		return 2;
	}

	public int GetCodedIndexSize(CodedIndex coded_index)
	{
		int num = coded_index_sizes[(int)coded_index];
		if (num != 0)
		{
			return num;
		}
		return coded_index_sizes[(int)coded_index] = coded_index.GetSize(counter);
	}

	public uint ResolveVirtualAddress(uint rva)
	{
		Section sectionAtVirtualAddress = GetSectionAtVirtualAddress(rva);
		if (sectionAtVirtualAddress == null)
		{
			throw new ArgumentOutOfRangeException();
		}
		return ResolveVirtualAddressInSection(rva, sectionAtVirtualAddress);
	}

	public uint ResolveVirtualAddressInSection(uint rva, Section section)
	{
		return rva + section.PointerToRawData - section.VirtualAddress;
	}

	public Section GetSection(string name)
	{
		Section[] sections = Sections;
		foreach (Section section in sections)
		{
			if (section.Name == name)
			{
				return section;
			}
		}
		return null;
	}

	public Section GetSectionAtVirtualAddress(uint rva)
	{
		Section[] sections = Sections;
		foreach (Section section in sections)
		{
			if (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.SizeOfRawData)
			{
				return section;
			}
		}
		return null;
	}

	private BinaryStreamReader GetReaderAt(uint rva)
	{
		Section sectionAtVirtualAddress = GetSectionAtVirtualAddress(rva);
		if (sectionAtVirtualAddress == null)
		{
			return null;
		}
		BinaryStreamReader binaryStreamReader = new BinaryStreamReader(Stream.value);
		binaryStreamReader.MoveTo(ResolveVirtualAddressInSection(rva, sectionAtVirtualAddress));
		return binaryStreamReader;
	}

	public TRet GetReaderAt<TItem, TRet>(uint rva, TItem item, Func<TItem, BinaryStreamReader, TRet> read) where TRet : class
	{
		long position = Stream.value.Position;
		try
		{
			BinaryStreamReader readerAt = GetReaderAt(rva);
			if (readerAt == null)
			{
				return null;
			}
			return read(item, readerAt);
		}
		finally
		{
			Stream.value.Position = position;
		}
	}

	public bool HasDebugTables()
	{
		if (!HasTable(Table.Document) && !HasTable(Table.MethodDebugInformation) && !HasTable(Table.LocalScope) && !HasTable(Table.LocalVariable) && !HasTable(Table.LocalConstant) && !HasTable(Table.StateMachineMethod))
		{
			return HasTable(Table.CustomDebugInformation);
		}
		return true;
	}

	public void Dispose()
	{
		Stream.Dispose();
	}
}


using System;
using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class ImageReader : BinaryStreamReader
{
	private readonly Image image;

	private DataDirectory cli;

	private DataDirectory metadata;

	private uint table_heap_offset;

	private uint pdb_heap_offset;

	public ImageReader(Disposable<Stream> stream, string file_name)
		: base(stream.value)
	{
		image = new Image();
		image.Stream = stream;
		image.FileName = file_name;
	}

	private void MoveTo(DataDirectory directory)
	{
		BaseStream.Position = image.ResolveVirtualAddress(directory.VirtualAddress);
	}

	private void ReadImage()
	{
		if (BaseStream.Length < 128)
		{
			throw new BadImageFormatException();
		}
		if (ReadUInt16() != 23117)
		{
			throw new BadImageFormatException();
		}
		Advance(58);
		MoveTo(ReadUInt32());
		if (ReadUInt32() != 17744)
		{
			throw new BadImageFormatException();
		}
		image.Architecture = ReadArchitecture();
		ushort count = ReadUInt16();
		image.Timestamp = ReadUInt32();
		Advance(10);
		ushort characteristics = ReadUInt16();
		ReadOptionalHeaders(out var subsystem, out var dll_characteristics);
		ReadSections(count);
		ReadCLIHeader();
		ReadMetadata();
		ReadDebugHeader();
		image.Characteristics = characteristics;
		image.Kind = GetModuleKind(characteristics, subsystem);
		image.DllCharacteristics = (ModuleCharacteristics)dll_characteristics;
	}

	private TargetArchitecture ReadArchitecture()
	{
		return (TargetArchitecture)ReadUInt16();
	}

	private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem)
	{
		if ((characteristics & 0x2000) != 0)
		{
			return ModuleKind.Dll;
		}
		if (subsystem == 2 || subsystem == 9)
		{
			return ModuleKind.Windows;
		}
		return ModuleKind.Console;
	}

	private void ReadOptionalHeaders(out ushort subsystem, out ushort dll_characteristics)
	{
		bool flag = ReadUInt16() == 523;
		image.LinkerVersion = ReadUInt16();
		Advance(44);
		image.SubSystemMajor = ReadUInt16();
		image.SubSystemMinor = ReadUInt16();
		Advance(16);
		subsystem = ReadUInt16();
		dll_characteristics = ReadUInt16();
		Advance(flag ? 56 : 40);
		image.Win32Resources = ReadDataDirectory();
		Advance(24);
		image.Debug = ReadDataDirectory();
		Advance(56);
		cli = ReadDataDirectory();
		if (cli.IsZero)
		{
			throw new BadImageFormatException();
		}
		Advance(8);
	}

	private string ReadAlignedString(int length)
	{
		int num = 0;
		char[] array = new char[length];
		while (num < length)
		{
			byte b = ReadByte();
			if (b == 0)
			{
				break;
			}
			array[num++] = (char)b;
		}
		Advance(-1 + ((num + 4) & -4) - num);
		return new string(array, 0, num);
	}

	private string ReadZeroTerminatedString(int length)
	{
		int num = 0;
		char[] array = new char[length];
		byte[] array2 = ReadBytes(length);
		while (num < length)
		{
			byte b = array2[num];
			if (b == 0)
			{
				break;
			}
			array[num++] = (char)b;
		}
		return new string(array, 0, num);
	}

	private void ReadSections(ushort count)
	{
		Section[] array = new Section[count];
		for (int i = 0; i < count; i++)
		{
			Section section = new Section();
			section.Name = ReadZeroTerminatedString(8);
			Advance(4);
			section.VirtualAddress = ReadUInt32();
			section.SizeOfRawData = ReadUInt32();
			section.PointerToRawData = ReadUInt32();
			Advance(16);
			array[i] = section;
		}
		image.Sections = array;
	}

	private void ReadCLIHeader()
	{
		MoveTo(cli);
		Advance(8);
		metadata = ReadDataDirectory();
		image.Attributes = (ModuleAttributes)ReadUInt32();
		image.EntryPointToken = ReadUInt32();
		image.Resources = ReadDataDirectory();
		image.StrongName = ReadDataDirectory();
	}

	private void ReadMetadata()
	{
		MoveTo(metadata);
		if (ReadUInt32() != 1112167234)
		{
			throw new BadImageFormatException();
		}
		Advance(8);
		image.RuntimeVersion = ReadZeroTerminatedString(ReadInt32());
		Advance(2);
		ushort num = ReadUInt16();
		Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(metadata.VirtualAddress);
		if (sectionAtVirtualAddress == null)
		{
			throw new BadImageFormatException();
		}
		image.MetadataSection = sectionAtVirtualAddress;
		for (int i = 0; i < num; i++)
		{
			ReadMetadataStream(sectionAtVirtualAddress);
		}
		if (image.PdbHeap != null)
		{
			ReadPdbHeap();
		}
		if (image.TableHeap != null)
		{
			ReadTableHeap();
		}
	}

	private void ReadDebugHeader()
	{
		if (image.Debug.IsZero)
		{
			image.DebugHeader = new ImageDebugHeader(Empty<ImageDebugHeaderEntry>.Array);
			return;
		}
		MoveTo(image.Debug);
		ImageDebugHeaderEntry[] array = new ImageDebugHeaderEntry[(int)image.Debug.Size / 28];
		for (int i = 0; i < array.Length; i++)
		{
			ImageDebugDirectory imageDebugDirectory = default(ImageDebugDirectory);
			imageDebugDirectory.Characteristics = ReadInt32();
			imageDebugDirectory.TimeDateStamp = ReadInt32();
			imageDebugDirectory.MajorVersion = ReadInt16();
			imageDebugDirectory.MinorVersion = ReadInt16();
			imageDebugDirectory.Type = (ImageDebugType)ReadInt32();
			imageDebugDirectory.SizeOfData = ReadInt32();
			imageDebugDirectory.AddressOfRawData = ReadInt32();
			imageDebugDirectory.PointerToRawData = ReadInt32();
			ImageDebugDirectory directory = imageDebugDirectory;
			if (directory.PointerToRawData == 0 || directory.SizeOfData < 0)
			{
				array[i] = new ImageDebugHeaderEntry(directory, Empty<byte>.Array);
				continue;
			}
			int position = base.Position;
			try
			{
				MoveTo((uint)directory.PointerToRawData);
				byte[] data = ReadBytes(directory.SizeOfData);
				array[i] = new ImageDebugHeaderEntry(directory, data);
			}
			finally
			{
				base.Position = position;
			}
		}
		image.DebugHeader = new ImageDebugHeader(array);
	}

	private void ReadMetadataStream(Section section)
	{
		uint offset = metadata.VirtualAddress - section.VirtualAddress + ReadUInt32();
		uint size = ReadUInt32();
		byte[] data = ReadHeapData(offset, size);
		switch (ReadAlignedString(16))
		{
		case "#~":
		case "#-":
			image.TableHeap = new TableHeap(data);
			table_heap_offset = offset;
			break;
		case "#Strings":
			image.StringHeap = new StringHeap(data);
			break;
		case "#Blob":
			image.BlobHeap = new BlobHeap(data);
			break;
		case "#GUID":
			image.GuidHeap = new GuidHeap(data);
			break;
		case "#US":
			image.UserStringHeap = new UserStringHeap(data);
			break;
		case "#Pdb":
			image.PdbHeap = new PdbHeap(data);
			pdb_heap_offset = offset;
			break;
		}
	}

	private byte[] ReadHeapData(uint offset, uint size)
	{
		long position = BaseStream.Position;
		MoveTo(offset + image.MetadataSection.PointerToRawData);
		byte[] result = ReadBytes((int)size);
		BaseStream.Position = position;
		return result;
	}

	private void ReadTableHeap()
	{
		TableHeap tableHeap = image.TableHeap;
		MoveTo(table_heap_offset + image.MetadataSection.PointerToRawData);
		Advance(6);
		byte sizes = ReadByte();
		Advance(1);
		tableHeap.Valid = ReadInt64();
		tableHeap.Sorted = ReadInt64();
		if (image.PdbHeap != null)
		{
			for (int i = 0; i < 58; i++)
			{
				if (image.PdbHeap.HasTable((Table)i))
				{
					tableHeap.Tables[i].Length = image.PdbHeap.TypeSystemTableRows[i];
				}
			}
		}
		for (int j = 0; j < 58; j++)
		{
			if (tableHeap.HasTable((Table)j))
			{
				tableHeap.Tables[j].Length = ReadUInt32();
			}
		}
		SetIndexSize(image.StringHeap, sizes, 1);
		SetIndexSize(image.GuidHeap, sizes, 2);
		SetIndexSize(image.BlobHeap, sizes, 4);
		ComputeTableInformations();
	}

	private static void SetIndexSize(Heap heap, uint sizes, byte flag)
	{
		if (heap != null)
		{
			heap.IndexSize = (((sizes & flag) != 0) ? 4 : 2);
		}
	}

	private int GetTableIndexSize(Table table)
	{
		return image.GetTableIndexSize(table);
	}

	private int GetCodedIndexSize(CodedIndex index)
	{
		return image.GetCodedIndexSize(index);
	}

	private void ComputeTableInformations()
	{
		uint num = (uint)((int)BaseStream.Position - (int)table_heap_offset) - image.MetadataSection.PointerToRawData;
		int num2 = ((image.StringHeap != null) ? image.StringHeap.IndexSize : 2);
		int num3 = ((image.GuidHeap != null) ? image.GuidHeap.IndexSize : 2);
		int num4 = ((image.BlobHeap != null) ? image.BlobHeap.IndexSize : 2);
		TableHeap tableHeap = image.TableHeap;
		TableInformation[] tables = tableHeap.Tables;
		for (int i = 0; i < 58; i++)
		{
			Table table = (Table)i;
			if (tableHeap.HasTable(table))
			{
				int num5 = table switch
				{
					Table.Module => 2 + num2 + num3 * 3, 
					Table.TypeRef => GetCodedIndexSize(CodedIndex.ResolutionScope) + num2 * 2, 
					Table.TypeDef => 4 + num2 * 2 + GetCodedIndexSize(CodedIndex.TypeDefOrRef) + GetTableIndexSize(Table.Field) + GetTableIndexSize(Table.Method), 
					Table.FieldPtr => GetTableIndexSize(Table.Field), 
					Table.Field => 2 + num2 + num4, 
					Table.MethodPtr => GetTableIndexSize(Table.Method), 
					Table.Method => 8 + num2 + num4 + GetTableIndexSize(Table.Param), 
					Table.ParamPtr => GetTableIndexSize(Table.Param), 
					Table.Param => 4 + num2, 
					Table.InterfaceImpl => GetTableIndexSize(Table.TypeDef) + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
					Table.MemberRef => GetCodedIndexSize(CodedIndex.MemberRefParent) + num2 + num4, 
					Table.Constant => 2 + GetCodedIndexSize(CodedIndex.HasConstant) + num4, 
					Table.CustomAttribute => GetCodedIndexSize(CodedIndex.HasCustomAttribute) + GetCodedIndexSize(CodedIndex.CustomAttributeType) + num4, 
					Table.FieldMarshal => GetCodedIndexSize(CodedIndex.HasFieldMarshal) + num4, 
					Table.DeclSecurity => 2 + GetCodedIndexSize(CodedIndex.HasDeclSecurity) + num4, 
					Table.ClassLayout => 6 + GetTableIndexSize(Table.TypeDef), 
					Table.FieldLayout => 4 + GetTableIndexSize(Table.Field), 
					Table.StandAloneSig => num4, 
					Table.EventMap => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.Event), 
					Table.EventPtr => GetTableIndexSize(Table.Event), 
					Table.Event => 2 + num2 + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
					Table.PropertyMap => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.Property), 
					Table.PropertyPtr => GetTableIndexSize(Table.Property), 
					Table.Property => 2 + num2 + num4, 
					Table.MethodSemantics => 2 + GetTableIndexSize(Table.Method) + GetCodedIndexSize(CodedIndex.HasSemantics), 
					Table.MethodImpl => GetTableIndexSize(Table.TypeDef) + GetCodedIndexSize(CodedIndex.MethodDefOrRef) + GetCodedIndexSize(CodedIndex.MethodDefOrRef), 
					Table.ModuleRef => num2, 
					Table.TypeSpec => num4, 
					Table.ImplMap => 2 + GetCodedIndexSize(CodedIndex.MemberForwarded) + num2 + GetTableIndexSize(Table.ModuleRef), 
					Table.FieldRVA => 4 + GetTableIndexSize(Table.Field), 
					Table.EncLog => 8, 
					Table.EncMap => 4, 
					Table.Assembly => 16 + num4 + num2 * 2, 
					Table.AssemblyProcessor => 4, 
					Table.AssemblyOS => 12, 
					Table.AssemblyRef => 12 + num4 * 2 + num2 * 2, 
					Table.AssemblyRefProcessor => 4 + GetTableIndexSize(Table.AssemblyRef), 
					Table.AssemblyRefOS => 12 + GetTableIndexSize(Table.AssemblyRef), 
					Table.File => 4 + num2 + num4, 
					Table.ExportedType => 8 + num2 * 2 + GetCodedIndexSize(CodedIndex.Implementation), 
					Table.ManifestResource => 8 + num2 + GetCodedIndexSize(CodedIndex.Implementation), 
					Table.NestedClass => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.TypeDef), 
					Table.GenericParam => 4 + GetCodedIndexSize(CodedIndex.TypeOrMethodDef) + num2, 
					Table.MethodSpec => GetCodedIndexSize(CodedIndex.MethodDefOrRef) + num4, 
					Table.GenericParamConstraint => GetTableIndexSize(Table.GenericParam) + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
					Table.Document => num4 + num3 + num4 + num3, 
					Table.MethodDebugInformation => GetTableIndexSize(Table.Document) + num4, 
					Table.LocalScope => GetTableIndexSize(Table.Method) + GetTableIndexSize(Table.ImportScope) + GetTableIndexSize(Table.LocalVariable) + GetTableIndexSize(Table.LocalConstant) + 8, 
					Table.LocalVariable => 4 + num2, 
					Table.LocalConstant => num2 + num4, 
					Table.ImportScope => GetTableIndexSize(Table.ImportScope) + num4, 
					Table.StateMachineMethod => GetTableIndexSize(Table.Method) + GetTableIndexSize(Table.Method), 
					Table.CustomDebugInformation => GetCodedIndexSize(CodedIndex.HasCustomDebugInformation) + num3 + num4, 
					_ => throw new NotSupportedException(), 
				};
				tables[i].RowSize = (uint)num5;
				tables[i].Offset = num;
				num += (uint)(num5 * (int)tables[i].Length);
			}
		}
	}

	private void ReadPdbHeap()
	{
		PdbHeap pdbHeap = image.PdbHeap;
		ByteBuffer byteBuffer = new ByteBuffer(pdbHeap.data);
		pdbHeap.Id = byteBuffer.ReadBytes(20);
		pdbHeap.EntryPoint = byteBuffer.ReadUInt32();
		pdbHeap.TypeSystemTables = byteBuffer.ReadInt64();
		pdbHeap.TypeSystemTableRows = new uint[58];
		for (int i = 0; i < 58; i++)
		{
			Table table = (Table)i;
			if (pdbHeap.HasTable(table))
			{
				pdbHeap.TypeSystemTableRows[i] = byteBuffer.ReadUInt32();
			}
		}
	}

	public static Image ReadImage(Disposable<Stream> stream, string file_name)
	{
		try
		{
			ImageReader imageReader = new ImageReader(stream, file_name);
			imageReader.ReadImage();
			return imageReader.image;
		}
		catch (EndOfStreamException inner)
		{
			throw new BadImageFormatException(stream.value.GetFileName(), inner);
		}
	}

	public static Image ReadPortablePdb(Disposable<Stream> stream, string file_name, out uint pdb_heap_offset)
	{
		try
		{
			ImageReader imageReader = new ImageReader(stream, file_name);
			uint num = (uint)stream.value.Length;
			imageReader.image.Sections = new Section[1]
			{
				new Section
				{
					PointerToRawData = 0u,
					SizeOfRawData = num,
					VirtualAddress = 0u,
					VirtualSize = num
				}
			};
			imageReader.metadata = new DataDirectory(0u, num);
			imageReader.ReadMetadata();
			pdb_heap_offset = imageReader.pdb_heap_offset;
			return imageReader.image;
		}
		catch (EndOfStreamException inner)
		{
			throw new BadImageFormatException(stream.value.GetFileName(), inner);
		}
	}
}


using System;
using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class ImageWriter : BinaryStreamWriter
{
	private readonly ModuleDefinition module;

	private readonly MetadataBuilder metadata;

	private readonly TextMap text_map;

	internal readonly Disposable<Stream> stream;

	private readonly string runtime_version;

	private ImageDebugHeader debug_header;

	private ByteBuffer win32_resources;

	private const uint pe_header_size = 152u;

	private const uint section_header_size = 40u;

	private const uint file_alignment = 512u;

	private const uint section_alignment = 8192u;

	private const ulong image_base = 4194304uL;

	internal const uint text_rva = 8192u;

	private readonly bool pe64;

	private readonly bool has_reloc;

	internal Section text;

	internal Section rsrc;

	internal Section reloc;

	private ushort sections;

	internal long debug_header_entries_position;

	private ImageWriter(ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable<Stream> stream, bool metadataOnly = false)
		: base(stream.value)
	{
		this.module = module;
		this.runtime_version = runtime_version;
		text_map = metadata.text_map;
		this.stream = stream;
		this.metadata = metadata;
		if (!metadataOnly)
		{
			pe64 = module.Architecture == TargetArchitecture.AMD64 || module.Architecture == TargetArchitecture.IA64 || module.Architecture == TargetArchitecture.ARM64;
			has_reloc = module.Architecture == TargetArchitecture.I386;
			GetDebugHeader();
			GetWin32Resources();
			BuildTextMap();
			sections = (ushort)((!has_reloc) ? 1u : 2u);
		}
	}

	private void GetDebugHeader()
	{
		ISymbolWriter symbol_writer = metadata.symbol_writer;
		if (symbol_writer != null)
		{
			debug_header = symbol_writer.GetDebugHeader();
		}
		if (module.HasDebugHeader && module.GetDebugHeader().GetDeterministicEntry() != null)
		{
			debug_header = debug_header.AddDeterministicEntry();
		}
	}

	private void GetWin32Resources()
	{
		if (!module.HasImage)
		{
			return;
		}
		DataDirectory win32Resources = module.Image.Win32Resources;
		uint size = win32Resources.Size;
		if (size != 0)
		{
			win32_resources = module.Image.GetReaderAt(win32Resources.VirtualAddress, size, (uint s, BinaryStreamReader reader) => new ByteBuffer(reader.ReadBytes((int)s)));
		}
	}

	public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable<Stream> stream)
	{
		ImageWriter imageWriter = new ImageWriter(module, module.runtime_version, metadata, stream);
		imageWriter.BuildSections();
		return imageWriter;
	}

	public static ImageWriter CreateDebugWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable<Stream> stream)
	{
		ImageWriter imageWriter = new ImageWriter(module, "PDB v1.0", metadata, stream, metadataOnly: true);
		uint length = metadata.text_map.GetLength();
		imageWriter.text = new Section
		{
			SizeOfRawData = length,
			VirtualSize = length
		};
		return imageWriter;
	}

	private void BuildSections()
	{
		bool num = win32_resources != null;
		if (num)
		{
			sections++;
		}
		text = CreateSection(".text", text_map.GetLength(), null);
		Section previous = text;
		if (num)
		{
			rsrc = CreateSection(".rsrc", (uint)win32_resources.length, previous);
			PatchWin32Resources(win32_resources);
			previous = rsrc;
		}
		if (has_reloc)
		{
			reloc = CreateSection(".reloc", 12u, previous);
		}
	}

	private Section CreateSection(string name, uint size, Section previous)
	{
		return new Section
		{
			Name = name,
			VirtualAddress = ((previous != null) ? (previous.VirtualAddress + Align(previous.VirtualSize, 8192u)) : 8192u),
			VirtualSize = size,
			PointerToRawData = ((previous != null) ? (previous.PointerToRawData + previous.SizeOfRawData) : Align(GetHeaderSize(), 512u)),
			SizeOfRawData = Align(size, 512u)
		};
	}

	private static uint Align(uint value, uint align)
	{
		align--;
		return (value + align) & ~align;
	}

	private void WriteDOSHeader()
	{
		Write(new byte[128]
		{
			77, 90, 144, 0, 3, 0, 0, 0, 4, 0,
			0, 0, 255, 255, 0, 0, 184, 0, 0, 0,
			0, 0, 0, 0, 64, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			128, 0, 0, 0, 14, 31, 186, 14, 0, 180,
			9, 205, 33, 184, 1, 76, 205, 33, 84, 104,
			105, 115, 32, 112, 114, 111, 103, 114, 97, 109,
			32, 99, 97, 110, 110, 111, 116, 32, 98, 101,
			32, 114, 117, 110, 32, 105, 110, 32, 68, 79,
			83, 32, 109, 111, 100, 101, 46, 13, 13, 10,
			36, 0, 0, 0, 0, 0, 0, 0
		});
	}

	private ushort SizeOfOptionalHeader()
	{
		return (ushort)((!pe64) ? 224u : 240u);
	}

	private void WritePEFileHeader()
	{
		WriteUInt32(17744u);
		WriteUInt16((ushort)module.Architecture);
		WriteUInt16(sections);
		WriteUInt32(metadata.timestamp);
		WriteUInt32(0u);
		WriteUInt32(0u);
		WriteUInt16(SizeOfOptionalHeader());
		ushort num = (ushort)(2 | ((!pe64) ? 256 : 32));
		if (module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule)
		{
			num |= 0x2000;
		}
		if (module.Image != null && (module.Image.Characteristics & 0x20) != 0)
		{
			num |= 0x20;
		}
		WriteUInt16(num);
	}

	private Section LastSection()
	{
		if (reloc != null)
		{
			return reloc;
		}
		if (rsrc != null)
		{
			return rsrc;
		}
		return text;
	}

	private void WriteOptionalHeaders()
	{
		WriteUInt16((ushort)((!pe64) ? 267u : 523u));
		WriteUInt16(module.linker_version);
		WriteUInt32(text.SizeOfRawData);
		WriteUInt32(((reloc != null) ? reloc.SizeOfRawData : 0) + ((rsrc != null) ? rsrc.SizeOfRawData : 0));
		WriteUInt32(0u);
		Mono.Cecil.Range range = text_map.GetRange(TextSegment.StartupStub);
		WriteUInt32((range.Length != 0) ? range.Start : 0u);
		WriteUInt32(8192u);
		if (!pe64)
		{
			WriteUInt32(0u);
			WriteUInt32(4194304u);
		}
		else
		{
			WriteUInt64(4194304uL);
		}
		WriteUInt32(8192u);
		WriteUInt32(512u);
		WriteUInt16(4);
		WriteUInt16(0);
		WriteUInt16(0);
		WriteUInt16(0);
		WriteUInt16(module.subsystem_major);
		WriteUInt16(module.subsystem_minor);
		WriteUInt32(0u);
		Section section = LastSection();
		WriteUInt32(section.VirtualAddress + Align(section.VirtualSize, 8192u));
		WriteUInt32(text.PointerToRawData);
		WriteUInt32(0u);
		WriteUInt16(GetSubSystem());
		WriteUInt16((ushort)module.Characteristics);
		if (!pe64)
		{
			WriteUInt32(1048576u);
			WriteUInt32(4096u);
			WriteUInt32(1048576u);
			WriteUInt32(4096u);
		}
		else
		{
			WriteUInt64(4194304uL);
			WriteUInt64(16384uL);
			WriteUInt64(1048576uL);
			WriteUInt64(8192uL);
		}
		WriteUInt32(0u);
		WriteUInt32(16u);
		WriteZeroDataDirectory();
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportDirectory));
		if (rsrc != null)
		{
			WriteUInt32(rsrc.VirtualAddress);
			WriteUInt32(rsrc.VirtualSize);
		}
		else
		{
			WriteZeroDataDirectory();
		}
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteUInt32((reloc != null) ? reloc.VirtualAddress : 0u);
		WriteUInt32((reloc != null) ? reloc.VirtualSize : 0u);
		if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
		{
			WriteUInt32(text_map.GetRVA(TextSegment.DebugDirectory));
			WriteUInt32((uint)(debug_header.Entries.Length * 28));
		}
		else
		{
			WriteZeroDataDirectory();
		}
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportAddressTable));
		WriteZeroDataDirectory();
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.CLIHeader));
		WriteZeroDataDirectory();
	}

	private void WriteZeroDataDirectory()
	{
		WriteUInt32(0u);
		WriteUInt32(0u);
	}

	private ushort GetSubSystem()
	{
		switch (module.Kind)
		{
		case ModuleKind.Dll:
		case ModuleKind.Console:
		case ModuleKind.NetModule:
			return 3;
		case ModuleKind.Windows:
			return 2;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}

	private void WriteSectionHeaders()
	{
		WriteSection(text, 1610612768u);
		if (rsrc != null)
		{
			WriteSection(rsrc, 1073741888u);
		}
		if (reloc != null)
		{
			WriteSection(reloc, 1107296320u);
		}
	}

	private void WriteSection(Section section, uint characteristics)
	{
		byte[] array = new byte[8];
		string name = section.Name;
		for (int i = 0; i < name.Length; i++)
		{
			array[i] = (byte)name[i];
		}
		WriteBytes(array);
		WriteUInt32(section.VirtualSize);
		WriteUInt32(section.VirtualAddress);
		WriteUInt32(section.SizeOfRawData);
		WriteUInt32(section.PointerToRawData);
		WriteUInt32(0u);
		WriteUInt32(0u);
		WriteUInt16(0);
		WriteUInt16(0);
		WriteUInt32(characteristics);
	}

	private uint GetRVAFileOffset(Section section, uint rva)
	{
		return section.PointerToRawData + rva - section.VirtualAddress;
	}

	private void MoveTo(uint pointer)
	{
		BaseStream.Seek(pointer, SeekOrigin.Begin);
	}

	private void MoveToRVA(Section section, uint rva)
	{
		BaseStream.Seek(GetRVAFileOffset(section, rva), SeekOrigin.Begin);
	}

	internal void MoveToRVA(TextSegment segment)
	{
		MoveToRVA(text, text_map.GetRVA(segment));
	}

	private void WriteRVA(uint rva)
	{
		if (!pe64)
		{
			WriteUInt32(rva);
		}
		else
		{
			WriteUInt64(rva);
		}
	}

	private void PrepareSection(Section section)
	{
		MoveTo(section.PointerToRawData);
		if (section.SizeOfRawData <= 4096)
		{
			Write(new byte[section.SizeOfRawData]);
			MoveTo(section.PointerToRawData);
			return;
		}
		int i = 0;
		byte[] buffer = new byte[4096];
		int num;
		for (; i != section.SizeOfRawData; i += num)
		{
			num = Math.Min((int)section.SizeOfRawData - i, 4096);
			Write(buffer, 0, num);
		}
		MoveTo(section.PointerToRawData);
	}

	private void WriteText()
	{
		PrepareSection(text);
		if (has_reloc)
		{
			WriteRVA(text_map.GetRVA(TextSegment.ImportHintNameTable));
			WriteRVA(0u);
		}
		WriteUInt32(72u);
		WriteUInt16(2);
		WriteUInt16((ushort)((module.Runtime > TargetRuntime.Net_1_1) ? 5u : 0u));
		WriteUInt32(text_map.GetRVA(TextSegment.MetadataHeader));
		WriteUInt32(GetMetadataLength());
		WriteUInt32((uint)module.Attributes);
		WriteUInt32(metadata.entry_point.ToUInt32());
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.Resources));
		WriteDataDirectory(text_map.GetDataDirectory(TextSegment.StrongNameSignature));
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		WriteZeroDataDirectory();
		MoveToRVA(TextSegment.Code);
		WriteBuffer(metadata.code);
		MoveToRVA(TextSegment.Resources);
		WriteBuffer(metadata.resources);
		if (metadata.data.length > 0)
		{
			MoveToRVA(TextSegment.Data);
			WriteBuffer(metadata.data);
		}
		MoveToRVA(TextSegment.MetadataHeader);
		WriteMetadataHeader();
		WriteMetadata();
		if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
		{
			MoveToRVA(TextSegment.DebugDirectory);
			WriteDebugDirectory();
		}
		if (has_reloc)
		{
			MoveToRVA(TextSegment.ImportDirectory);
			WriteImportDirectory();
			MoveToRVA(TextSegment.StartupStub);
			WriteStartupStub();
		}
	}

	private uint GetMetadataLength()
	{
		return text_map.GetRVA(TextSegment.DebugDirectory) - text_map.GetRVA(TextSegment.MetadataHeader);
	}

	public void WriteMetadataHeader()
	{
		WriteUInt32(1112167234u);
		WriteUInt16(1);
		WriteUInt16(1);
		WriteUInt32(0u);
		byte[] zeroTerminatedString = GetZeroTerminatedString(runtime_version);
		WriteUInt32((uint)zeroTerminatedString.Length);
		WriteBytes(zeroTerminatedString);
		WriteUInt16(0);
		WriteUInt16(GetStreamCount());
		uint offset = text_map.GetRVA(TextSegment.TableHeap) - text_map.GetRVA(TextSegment.MetadataHeader);
		WriteStreamHeader(ref offset, TextSegment.TableHeap, "#~");
		WriteStreamHeader(ref offset, TextSegment.StringHeap, "#Strings");
		WriteStreamHeader(ref offset, TextSegment.UserStringHeap, "#US");
		WriteStreamHeader(ref offset, TextSegment.GuidHeap, "#GUID");
		WriteStreamHeader(ref offset, TextSegment.BlobHeap, "#Blob");
		WriteStreamHeader(ref offset, TextSegment.PdbHeap, "#Pdb");
	}

	private ushort GetStreamCount()
	{
		return (ushort)((uint)(2 + ((!metadata.user_string_heap.IsEmpty) ? 1 : 0) + ((!metadata.guid_heap.IsEmpty) ? 1 : 0) + ((!metadata.blob_heap.IsEmpty) ? 1 : 0)) + ((metadata.pdb_heap != null) ? 1u : 0u));
	}

	private void WriteStreamHeader(ref uint offset, TextSegment heap, string name)
	{
		uint length = (uint)text_map.GetLength(heap);
		if (length != 0)
		{
			WriteUInt32(offset);
			WriteUInt32(length);
			WriteBytes(GetZeroTerminatedString(name));
			offset += length;
		}
	}

	private static int GetZeroTerminatedStringLength(string @string)
	{
		return (@string.Length + 1 + 3) & -4;
	}

	private static byte[] GetZeroTerminatedString(string @string)
	{
		return GetString(@string, GetZeroTerminatedStringLength(@string));
	}

	private static byte[] GetSimpleString(string @string)
	{
		return GetString(@string, @string.Length);
	}

	private static byte[] GetString(string @string, int length)
	{
		byte[] array = new byte[length];
		for (int i = 0; i < @string.Length; i++)
		{
			array[i] = (byte)@string[i];
		}
		return array;
	}

	public void WriteMetadata()
	{
		WriteHeap(TextSegment.TableHeap, metadata.table_heap);
		WriteHeap(TextSegment.StringHeap, metadata.string_heap);
		WriteHeap(TextSegment.UserStringHeap, metadata.user_string_heap);
		WriteHeap(TextSegment.GuidHeap, metadata.guid_heap);
		WriteHeap(TextSegment.BlobHeap, metadata.blob_heap);
		WriteHeap(TextSegment.PdbHeap, metadata.pdb_heap);
	}

	private void WriteHeap(TextSegment heap, HeapBuffer buffer)
	{
		if (buffer != null && !buffer.IsEmpty)
		{
			MoveToRVA(heap);
			WriteBuffer(buffer);
		}
	}

	private void WriteDebugDirectory()
	{
		int num = (int)BaseStream.Position + debug_header.Entries.Length * 28;
		for (int i = 0; i < debug_header.Entries.Length; i++)
		{
			ImageDebugHeaderEntry imageDebugHeaderEntry = debug_header.Entries[i];
			ImageDebugDirectory directory = imageDebugHeaderEntry.Directory;
			WriteInt32(directory.Characteristics);
			WriteInt32(directory.TimeDateStamp);
			WriteInt16(directory.MajorVersion);
			WriteInt16(directory.MinorVersion);
			WriteInt32((int)directory.Type);
			WriteInt32(directory.SizeOfData);
			WriteInt32(directory.AddressOfRawData);
			WriteInt32(num);
			num += imageDebugHeaderEntry.Data.Length;
		}
		debug_header_entries_position = BaseStream.Position;
		for (int j = 0; j < debug_header.Entries.Length; j++)
		{
			ImageDebugHeaderEntry imageDebugHeaderEntry2 = debug_header.Entries[j];
			WriteBytes(imageDebugHeaderEntry2.Data);
		}
	}

	private void WriteImportDirectory()
	{
		WriteUInt32(text_map.GetRVA(TextSegment.ImportDirectory) + 40);
		WriteUInt32(0u);
		WriteUInt32(0u);
		WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable) + 14);
		WriteUInt32(text_map.GetRVA(TextSegment.ImportAddressTable));
		Advance(20);
		WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable));
		MoveToRVA(TextSegment.ImportHintNameTable);
		WriteUInt16(0);
		WriteBytes(GetRuntimeMain());
		WriteByte(0);
		WriteBytes(GetSimpleString("mscoree.dll"));
		WriteUInt16(0);
	}

	private byte[] GetRuntimeMain()
	{
		if (module.Kind != 0 && module.Kind != ModuleKind.NetModule)
		{
			return GetSimpleString("_CorExeMain");
		}
		return GetSimpleString("_CorDllMain");
	}

	private void WriteStartupStub()
	{
		if (module.Architecture == TargetArchitecture.I386)
		{
			WriteUInt16(9727);
			WriteUInt32(4194304 + text_map.GetRVA(TextSegment.ImportAddressTable));
			return;
		}
		throw new NotSupportedException();
	}

	private void WriteRsrc()
	{
		PrepareSection(rsrc);
		WriteBuffer(win32_resources);
	}

	private void WriteReloc()
	{
		PrepareSection(reloc);
		uint rVA = text_map.GetRVA(TextSegment.StartupStub);
		rVA += (uint)((module.Architecture == TargetArchitecture.IA64) ? 32 : 2);
		uint num = rVA & 0xFFFFF000u;
		WriteUInt32(num);
		WriteUInt32(12u);
		if (module.Architecture == TargetArchitecture.I386)
		{
			WriteUInt32(12288 + rVA - num);
			return;
		}
		throw new NotSupportedException();
	}

	public void WriteImage()
	{
		WriteDOSHeader();
		WritePEFileHeader();
		WriteOptionalHeaders();
		WriteSectionHeaders();
		WriteText();
		if (rsrc != null)
		{
			WriteRsrc();
		}
		if (reloc != null)
		{
			WriteReloc();
		}
		Flush();
	}

	private void BuildTextMap()
	{
		TextMap textMap = text_map;
		textMap.AddMap(TextSegment.Code, metadata.code.length, (!pe64) ? 4 : 16);
		textMap.AddMap(TextSegment.Resources, metadata.resources.length, 8);
		textMap.AddMap(TextSegment.Data, metadata.data.length, metadata.data.BufferAlign);
		if (metadata.data.length > 0)
		{
			metadata.table_heap.FixupData(textMap.GetRVA(TextSegment.Data));
		}
		textMap.AddMap(TextSegment.StrongNameSignature, GetStrongNameLength(), 4);
		BuildMetadataTextMap();
		int length = 0;
		if (debug_header != null && debug_header.HasEntries)
		{
			int num = debug_header.Entries.Length * 28;
			int num2 = (int)textMap.GetNextRVA(TextSegment.BlobHeap) + num;
			int num3 = 0;
			for (int i = 0; i < debug_header.Entries.Length; i++)
			{
				ImageDebugHeaderEntry imageDebugHeaderEntry = debug_header.Entries[i];
				ImageDebugDirectory directory = imageDebugHeaderEntry.Directory;
				directory.AddressOfRawData = ((imageDebugHeaderEntry.Data.Length != 0) ? num2 : 0);
				imageDebugHeaderEntry.Directory = directory;
				num3 += imageDebugHeaderEntry.Data.Length;
				num2 += imageDebugHeaderEntry.Data.Length;
			}
			length = num + num3;
		}
		textMap.AddMap(TextSegment.DebugDirectory, length, 4);
		if (!has_reloc)
		{
			uint nextRVA = textMap.GetNextRVA(TextSegment.DebugDirectory);
			textMap.AddMap(TextSegment.ImportDirectory, new Mono.Cecil.Range(nextRVA, 0u));
			textMap.AddMap(TextSegment.ImportHintNameTable, new Mono.Cecil.Range(nextRVA, 0u));
			textMap.AddMap(TextSegment.StartupStub, new Mono.Cecil.Range(nextRVA, 0u));
			return;
		}
		uint nextRVA2 = textMap.GetNextRVA(TextSegment.DebugDirectory);
		uint num4 = nextRVA2 + 48;
		num4 = (num4 + 15) & 0xFFFFFFF0u;
		uint num5 = num4 - nextRVA2 + 27;
		uint num6 = nextRVA2 + num5;
		num6 = ((module.Architecture == TargetArchitecture.IA64) ? ((num6 + 15) & 0xFFFFFFF0u) : (2 + ((num6 + 3) & 0xFFFFFFFCu)));
		textMap.AddMap(TextSegment.ImportDirectory, new Mono.Cecil.Range(nextRVA2, num5));
		textMap.AddMap(TextSegment.ImportHintNameTable, new Mono.Cecil.Range(num4, 0u));
		textMap.AddMap(TextSegment.StartupStub, new Mono.Cecil.Range(num6, GetStartupStubLength()));
	}

	public void BuildMetadataTextMap()
	{
		TextMap textMap = text_map;
		textMap.AddMap(TextSegment.MetadataHeader, GetMetadataHeaderLength(module.RuntimeVersion));
		textMap.AddMap(TextSegment.TableHeap, metadata.table_heap.length, 4);
		textMap.AddMap(TextSegment.StringHeap, metadata.string_heap.length, 4);
		textMap.AddMap(TextSegment.UserStringHeap, (!metadata.user_string_heap.IsEmpty) ? metadata.user_string_heap.length : 0, 4);
		textMap.AddMap(TextSegment.GuidHeap, metadata.guid_heap.length, 4);
		textMap.AddMap(TextSegment.BlobHeap, (!metadata.blob_heap.IsEmpty) ? metadata.blob_heap.length : 0, 4);
		textMap.AddMap(TextSegment.PdbHeap, (metadata.pdb_heap != null) ? metadata.pdb_heap.length : 0, 4);
	}

	private uint GetStartupStubLength()
	{
		if (module.Architecture == TargetArchitecture.I386)
		{
			return 6u;
		}
		throw new NotSupportedException();
	}

	private int GetMetadataHeaderLength(string runtimeVersion)
	{
		return 20 + GetZeroTerminatedStringLength(runtimeVersion) + 12 + 20 + ((!metadata.user_string_heap.IsEmpty) ? 12 : 0) + 16 + ((!metadata.blob_heap.IsEmpty) ? 16 : 0) + ((metadata.pdb_heap != null) ? 16 : 0);
	}

	private int GetStrongNameLength()
	{
		if (module.kind == ModuleKind.NetModule || module.Assembly == null)
		{
			return 0;
		}
		byte[] publicKey = module.Assembly.Name.PublicKey;
		if (publicKey.IsNullOrEmpty())
		{
			return 0;
		}
		int num = publicKey.Length;
		if (num > 32)
		{
			return num - 32;
		}
		return 128;
	}

	public DataDirectory GetStrongNameSignatureDirectory()
	{
		return text_map.GetDataDirectory(TextSegment.StrongNameSignature);
	}

	public uint GetHeaderSize()
	{
		return (uint)(152 + SizeOfOptionalHeader() + sections * 40);
	}

	private void PatchWin32Resources(ByteBuffer resources)
	{
		PatchResourceDirectoryTable(resources);
	}

	private void PatchResourceDirectoryTable(ByteBuffer resources)
	{
		resources.Advance(12);
		int num = resources.ReadUInt16() + resources.ReadUInt16();
		for (int i = 0; i < num; i++)
		{
			PatchResourceDirectoryEntry(resources);
		}
	}

	private void PatchResourceDirectoryEntry(ByteBuffer resources)
	{
		resources.Advance(4);
		uint num = resources.ReadUInt32();
		int position = resources.position;
		resources.position = (int)(num & 0x7FFFFFFF);
		if ((num & 0x80000000u) != 0)
		{
			PatchResourceDirectoryTable(resources);
		}
		else
		{
			PatchResourceDataEntry(resources);
		}
		resources.position = position;
	}

	private void PatchResourceDataEntry(ByteBuffer resources)
	{
		uint num = resources.ReadUInt32();
		resources.position -= 4;
		resources.WriteUInt32(num - module.Image.Win32Resources.VirtualAddress + rsrc.VirtualAddress);
	}
}


internal sealed class Section
{
	public string Name;

	public uint VirtualAddress;

	public uint VirtualSize;

	public uint SizeOfRawData;

	public uint PointerToRawData;
}


internal enum TextSegment
{
	ImportAddressTable,
	CLIHeader,
	Code,
	Resources,
	Data,
	StrongNameSignature,
	MetadataHeader,
	TableHeap,
	StringHeap,
	UserStringHeap,
	GuidHeap,
	BlobHeap,
	PdbHeap,
	DebugDirectory,
	ImportDirectory,
	ImportHintNameTable,
	StartupStub
}


using Mono.Cecil;
using Mono.Cecil.PE;

internal sealed class TextMap
{
	private readonly Range[] map = new Range[17];

	public void AddMap(TextSegment segment, int length)
	{
		map[(int)segment] = new Range(GetStart(segment), (uint)length);
	}

	private uint AlignUp(uint value, uint align)
	{
		align--;
		return (value + align) & ~align;
	}

	public void AddMap(TextSegment segment, int length, int align)
	{
		int num = (int)segment;
		uint num2;
		if (num != 0)
		{
			num--;
			Range range = map[num];
			num2 = AlignUp(range.Start + range.Length, (uint)align);
			map[num].Length = num2 - range.Start;
		}
		else
		{
			num2 = 8192u;
		}
		map[(int)segment] = new Range(num2, (uint)length);
	}

	public void AddMap(TextSegment segment, Range range)
	{
		map[(int)segment] = range;
	}

	public Range GetRange(TextSegment segment)
	{
		return map[(int)segment];
	}

	public DataDirectory GetDataDirectory(TextSegment segment)
	{
		Range range = map[(int)segment];
		return new DataDirectory((range.Length != 0) ? range.Start : 0u, range.Length);
	}

	public uint GetRVA(TextSegment segment)
	{
		return map[(int)segment].Start;
	}

	public uint GetNextRVA(TextSegment segment)
	{
		return map[(int)segment].Start + map[(int)segment].Length;
	}

	public int GetLength(TextSegment segment)
	{
		return (int)map[(int)segment].Length;
	}

	private uint GetStart(TextSegment segment)
	{
		if (segment != 0)
		{
			return ComputeStart((int)segment);
		}
		return 8192u;
	}

	private uint ComputeStart(int index)
	{
		index--;
		return map[index].Start + map[index].Length;
	}

	public uint GetLength()
	{
		Range range = map[16];
		return range.Start - 8192 + range.Length;
	}
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class BlobHeap : Heap
{
	public BlobHeap(byte[] data)
		: base(data)
	{
	}

	public byte[] Read(uint index)
	{
		if (index == 0 || index > data.Length - 1)
		{
			return Empty<byte>.Array;
		}
		int position = (int)index;
		int num = (int)data.ReadCompressedUInt32(ref position);
		if (num > data.Length - position)
		{
			return Empty<byte>.Array;
		}
		byte[] array = new byte[num];
		Buffer.BlockCopy(data, position, array, 0, num);
		return array;
	}

	public void GetView(uint signature, out byte[] buffer, out int index, out int length)
	{
		if (signature == 0 || signature > data.Length - 1)
		{
			buffer = null;
			index = (length = 0);
		}
		else
		{
			buffer = data;
			index = (int)signature;
			length = (int)buffer.ReadCompressedUInt32(ref index);
		}
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class TableHeapBuffer : HeapBuffer
{
	private readonly ModuleDefinition module;

	private readonly MetadataBuilder metadata;

	internal readonly TableInformation[] table_infos = new TableInformation[58];

	internal readonly MetadataTable[] tables = new MetadataTable[58];

	private bool large_string;

	private bool large_blob;

	private bool large_guid;

	private readonly int[] coded_index_sizes = new int[14];

	private readonly Func<Table, int> counter;

	internal uint[] string_offsets;

	public override bool IsEmpty => false;

	public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata)
		: base(24)
	{
		this.module = module;
		this.metadata = metadata;
		counter = GetTableLength;
	}

	private int GetTableLength(Table table)
	{
		return (int)table_infos[(uint)table].Length;
	}

	public TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
	{
		TTable val = (TTable)tables[(uint)table];
		if (val != null)
		{
			return val;
		}
		val = new TTable();
		tables[(uint)table] = val;
		return val;
	}

	public void WriteBySize(uint value, int size)
	{
		if (size == 4)
		{
			WriteUInt32(value);
		}
		else
		{
			WriteUInt16((ushort)value);
		}
	}

	public void WriteBySize(uint value, bool large)
	{
		if (large)
		{
			WriteUInt32(value);
		}
		else
		{
			WriteUInt16((ushort)value);
		}
	}

	public void WriteString(uint @string)
	{
		WriteBySize(string_offsets[@string], large_string);
	}

	public void WriteBlob(uint blob)
	{
		WriteBySize(blob, large_blob);
	}

	public void WriteGuid(uint guid)
	{
		WriteBySize(guid, large_guid);
	}

	public void WriteRID(uint rid, Table table)
	{
		WriteBySize(rid, table_infos[(uint)table].IsLarge);
	}

	private int GetCodedIndexSize(CodedIndex coded_index)
	{
		int num = coded_index_sizes[(int)coded_index];
		if (num != 0)
		{
			return num;
		}
		return coded_index_sizes[(int)coded_index] = coded_index.GetSize(counter);
	}

	public void WriteCodedRID(uint rid, CodedIndex coded_index)
	{
		WriteBySize(rid, GetCodedIndexSize(coded_index));
	}

	public void WriteTableHeap()
	{
		WriteUInt32(0u);
		WriteByte(GetTableHeapVersion());
		WriteByte(0);
		WriteByte(GetHeapSizes());
		WriteByte(10);
		WriteUInt64(GetValid());
		WriteUInt64(55193285546867200uL);
		WriteRowCount();
		WriteTables();
	}

	private void WriteRowCount()
	{
		for (int i = 0; i < tables.Length; i++)
		{
			MetadataTable metadataTable = tables[i];
			if (metadataTable != null && metadataTable.Length != 0)
			{
				WriteUInt32((uint)metadataTable.Length);
			}
		}
	}

	private void WriteTables()
	{
		for (int i = 0; i < tables.Length; i++)
		{
			MetadataTable metadataTable = tables[i];
			if (metadataTable != null && metadataTable.Length != 0)
			{
				metadataTable.Write(this);
			}
		}
	}

	private ulong GetValid()
	{
		ulong num = 0uL;
		for (int i = 0; i < tables.Length; i++)
		{
			MetadataTable metadataTable = tables[i];
			if (metadataTable != null && metadataTable.Length != 0)
			{
				metadataTable.Sort();
				num |= (ulong)(1L << i);
			}
		}
		return num;
	}

	public void ComputeTableInformations()
	{
		if (metadata.metadata_builder != null)
		{
			ComputeTableInformations(metadata.metadata_builder.table_heap);
		}
		ComputeTableInformations(metadata.table_heap);
	}

	private void ComputeTableInformations(TableHeapBuffer table_heap)
	{
		MetadataTable[] array = table_heap.tables;
		for (int i = 0; i < array.Length; i++)
		{
			MetadataTable metadataTable = array[i];
			if (metadataTable != null && metadataTable.Length > 0)
			{
				table_infos[i].Length = (uint)metadataTable.Length;
			}
		}
	}

	private byte GetHeapSizes()
	{
		byte b = 0;
		if (metadata.string_heap.IsLarge)
		{
			large_string = true;
			b |= 1;
		}
		if (metadata.guid_heap.IsLarge)
		{
			large_guid = true;
			b |= 2;
		}
		if (metadata.blob_heap.IsLarge)
		{
			large_blob = true;
			b |= 4;
		}
		return b;
	}

	private byte GetTableHeapVersion()
	{
		TargetRuntime runtime = module.Runtime;
		if ((uint)runtime <= 1u)
		{
			return 1;
		}
		return 2;
	}

	public void FixupData(uint data_rva)
	{
		FieldRVATable table = GetTable<FieldRVATable>(Table.FieldRVA);
		if (table.length != 0)
		{
			int num = (GetTable<FieldTable>(Table.Field).IsLarge ? 4 : 2);
			int num2 = position;
			position = table.position;
			for (int i = 0; i < table.length; i++)
			{
				uint num3 = ReadUInt32();
				position -= 4;
				WriteUInt32(num3 + data_rva);
				position += num;
			}
			position = num2;
		}
	}
}


using Mono.Cecil.PE;

internal sealed class ResourceBuffer : ByteBuffer
{
	public ResourceBuffer()
		: base(0)
	{
	}

	public uint AddResource(byte[] resource)
	{
		int result = position;
		WriteInt32(resource.Length);
		WriteBytes(resource);
		return (uint)result;
	}
}


using Mono.Cecil.PE;

internal sealed class DataBuffer : ByteBuffer
{
	private int buffer_align = 4;

	public int BufferAlign => buffer_align;

	public DataBuffer()
		: base(0)
	{
	}

	private void Align(int align)
	{
		align--;
		WriteBytes(((position + align) & ~align) - position);
	}

	public uint AddData(byte[] data, int align)
	{
		if (buffer_align < align)
		{
			buffer_align = align;
		}
		Align(align);
		int result = position;
		WriteBytes(data);
		return (uint)result;
	}
}


using Mono.Cecil.PE;

internal abstract class HeapBuffer : ByteBuffer
{
	public bool IsLarge => length > 65535;

	public abstract bool IsEmpty { get; }

	protected HeapBuffer(int length)
		: base(length)
	{
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil.Metadata;

internal sealed class GuidHeapBuffer : HeapBuffer
{
	private readonly Dictionary<Guid, uint> guids = new Dictionary<Guid, uint>();

	public override bool IsEmpty => length == 0;

	public GuidHeapBuffer()
		: base(16)
	{
	}

	public uint GetGuidIndex(Guid guid)
	{
		if (guids.TryGetValue(guid, out var value))
		{
			return value;
		}
		value = (uint)(guids.Count + 1);
		WriteGuid(guid);
		guids.Add(guid, value);
		return value;
	}

	private void WriteGuid(Guid guid)
	{
		WriteBytes(guid.ToByteArray());
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Metadata;

internal class StringHeapBuffer : HeapBuffer
{
	private class SuffixSort : IComparer<KeyValuePair<string, uint>>
	{
		public int Compare(KeyValuePair<string, uint> xPair, KeyValuePair<string, uint> yPair)
		{
			string key = xPair.Key;
			string key2 = yPair.Key;
			int num = key.Length - 1;
			int num2 = key2.Length - 1;
			while (num >= 0 && num2 >= 0)
			{
				if (key[num] < key2[num2])
				{
					return -1;
				}
				if (key[num] > key2[num2])
				{
					return 1;
				}
				num--;
				num2--;
			}
			return key2.Length.CompareTo(key.Length);
		}
	}

	protected Dictionary<string, uint> strings = new Dictionary<string, uint>(StringComparer.Ordinal);

	public sealed override bool IsEmpty => length <= 1;

	public StringHeapBuffer()
		: base(1)
	{
		WriteByte(0);
	}

	public virtual uint GetStringIndex(string @string)
	{
		if (strings.TryGetValue(@string, out var value))
		{
			return value;
		}
		value = (uint)(strings.Count + 1);
		strings.Add(@string, value);
		return value;
	}

	public uint[] WriteStrings()
	{
		List<KeyValuePair<string, uint>> list = SortStrings(strings);
		strings = null;
		uint[] array = new uint[list.Count + 1];
		array[0] = 0u;
		string text = string.Empty;
		foreach (KeyValuePair<string, uint> item in list)
		{
			string key = item.Key;
			uint value = item.Value;
			int num = position;
			if (text.EndsWith(key, StringComparison.Ordinal) && !IsLowSurrogateChar(item.Key[0]))
			{
				array[value] = (uint)(num - (Encoding.UTF8.GetByteCount(item.Key) + 1));
			}
			else
			{
				array[value] = (uint)num;
				WriteString(key);
			}
			text = item.Key;
		}
		return array;
	}

	private static List<KeyValuePair<string, uint>> SortStrings(Dictionary<string, uint> strings)
	{
		List<KeyValuePair<string, uint>> list = new List<KeyValuePair<string, uint>>(strings);
		list.Sort(new SuffixSort());
		return list;
	}

	private static bool IsLowSurrogateChar(int c)
	{
		return (uint)(c - 56320) <= 1023u;
	}

	protected virtual void WriteString(string @string)
	{
		WriteBytes(Encoding.UTF8.GetBytes(@string));
		WriteByte(0);
	}
}


using System.Collections.Generic;

private class SuffixSort : IComparer<KeyValuePair<string, uint>>
{
	public int Compare(KeyValuePair<string, uint> xPair, KeyValuePair<string, uint> yPair)
	{
		string key = xPair.Key;
		string key2 = yPair.Key;
		int num = key.Length - 1;
		int num2 = key2.Length - 1;
		while (num >= 0 && num2 >= 0)
		{
			if (key[num] < key2[num2])
			{
				return -1;
			}
			if (key[num] > key2[num2])
			{
				return 1;
			}
			num--;
			num2--;
		}
		return key2.Length.CompareTo(key.Length);
	}
}


using System.Collections.Generic;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class BlobHeapBuffer : HeapBuffer
{
	private readonly Dictionary<ByteBuffer, uint> blobs = new Dictionary<ByteBuffer, uint>(new ByteBufferEqualityComparer());

	public override bool IsEmpty => length <= 1;

	public BlobHeapBuffer()
		: base(1)
	{
		WriteByte(0);
	}

	public uint GetBlobIndex(ByteBuffer blob)
	{
		if (blobs.TryGetValue(blob, out var value))
		{
			return value;
		}
		value = (uint)position;
		WriteBlob(blob);
		blobs.Add(blob, value);
		return value;
	}

	private void WriteBlob(ByteBuffer blob)
	{
		WriteCompressedUInt32((uint)blob.length);
		WriteBytes(blob);
	}
}


using Mono.Cecil.Metadata;

internal sealed class UserStringHeapBuffer : StringHeapBuffer
{
	public override uint GetStringIndex(string @string)
	{
		if (strings.TryGetValue(@string, out var value))
		{
			return value;
		}
		value = (uint)position;
		WriteString(@string);
		strings.Add(@string, value);
		return value;
	}

	protected override void WriteString(string @string)
	{
		WriteCompressedUInt32((uint)(@string.Length * 2 + 1));
		byte b = 0;
		foreach (char c in @string)
		{
			WriteUInt16(c);
			if (b != 1 && (c < ' ' || c > '~') && (c > '~' || (c >= '\u0001' && c <= '\b') || (c >= '\u000e' && c <= '\u001f') || c == '\'' || c == '-'))
			{
				b = 1;
			}
		}
		WriteByte(b);
	}
}


using Mono.Cecil.Metadata;

internal sealed class PdbHeapBuffer : HeapBuffer
{
	public override bool IsEmpty => false;

	public PdbHeapBuffer()
		: base(0)
	{
	}
}


internal enum CodedIndex
{
	TypeDefOrRef,
	HasConstant,
	HasCustomAttribute,
	HasFieldMarshal,
	HasDeclSecurity,
	MemberRefParent,
	HasSemantics,
	MethodDefOrRef,
	MemberForwarded,
	Implementation,
	CustomAttributeType,
	ResolutionScope,
	TypeOrMethodDef,
	HasCustomDebugInformation
}


internal enum ElementType : byte
{
	None = 0,
	Void = 1,
	Boolean = 2,
	Char = 3,
	I1 = 4,
	U1 = 5,
	I2 = 6,
	U2 = 7,
	I4 = 8,
	U4 = 9,
	I8 = 10,
	U8 = 11,
	R4 = 12,
	R8 = 13,
	String = 14,
	Ptr = 15,
	ByRef = 16,
	ValueType = 17,
	Class = 18,
	Var = 19,
	Array = 20,
	GenericInst = 21,
	TypedByRef = 22,
	I = 24,
	U = 25,
	FnPtr = 27,
	Object = 28,
	SzArray = 29,
	MVar = 30,
	CModReqD = 31,
	CModOpt = 32,
	Internal = 33,
	Modifier = 64,
	Sentinel = 65,
	Pinned = 69,
	Type = 80,
	Boxed = 81,
	Enum = 85
}


using System;
using Mono.Cecil.Metadata;

internal sealed class GuidHeap : Heap
{
	public GuidHeap(byte[] data)
		: base(data)
	{
	}

	public Guid Read(uint index)
	{
		if (index == 0 || index - 1 + 16 > data.Length)
		{
			return default(Guid);
		}
		byte[] array = new byte[16];
		Buffer.BlockCopy(data, (int)((index - 1) * 16), array, 0, 16);
		return new Guid(array);
	}
}


internal abstract class Heap
{
	public int IndexSize;

	internal readonly byte[] data;

	protected Heap(byte[] data)
	{
		this.data = data;
	}
}


using Mono.Cecil.Metadata;

internal sealed class PdbHeap : Heap
{
	public byte[] Id;

	public uint EntryPoint;

	public long TypeSystemTables;

	public uint[] TypeSystemTableRows;

	public PdbHeap(byte[] data)
		: base(data)
	{
	}

	public bool HasTable(Table table)
	{
		return (TypeSystemTables & (1L << (int)table)) != 0;
	}
}


internal struct Row<T1, T2>
{
	internal T1 Col1;

	internal T2 Col2;

	public Row(T1 col1, T2 col2)
	{
		Col1 = col1;
		Col2 = col2;
	}
}


internal struct Row<T1, T2, T3>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	public Row(T1 col1, T2 col2, T3 col3)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
	}
}


internal struct Row<T1, T2, T3, T4>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
	}
}


internal struct Row<T1, T2, T3, T4, T5>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	internal T5 Col5;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
		Col5 = col5;
	}
}


internal struct Row<T1, T2, T3, T4, T5, T6>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	internal T5 Col5;

	internal T6 Col6;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
		Col5 = col5;
		Col6 = col6;
	}
}


internal struct Row<T1, T2, T3, T4, T5, T6, T7, T8, T9>
{
	internal T1 Col1;

	internal T2 Col2;

	internal T3 Col3;

	internal T4 Col4;

	internal T5 Col5;

	internal T6 Col6;

	internal T7 Col7;

	internal T8 Col8;

	internal T9 Col9;

	public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
	{
		Col1 = col1;
		Col2 = col2;
		Col3 = col3;
		Col4 = col4;
		Col5 = col5;
		Col6 = col6;
		Col7 = col7;
		Col8 = col8;
		Col9 = col9;
	}
}


using System.Collections.Generic;
using Mono.Cecil.Metadata;

internal sealed class RowEqualityComparer : IEqualityComparer<Row<string, string>>, IEqualityComparer<Row<uint, uint>>, IEqualityComparer<Row<uint, uint, uint>>
{
	public bool Equals(Row<string, string> x, Row<string, string> y)
	{
		if (x.Col1 == y.Col1)
		{
			return x.Col2 == y.Col2;
		}
		return false;
	}

	public int GetHashCode(Row<string, string> obj)
	{
		string col = obj.Col1;
		string col2 = obj.Col2;
		return (col?.GetHashCode() ?? 0) ^ (col2?.GetHashCode() ?? 0);
	}

	public bool Equals(Row<uint, uint> x, Row<uint, uint> y)
	{
		if (x.Col1 == y.Col1)
		{
			return x.Col2 == y.Col2;
		}
		return false;
	}

	public int GetHashCode(Row<uint, uint> obj)
	{
		return (int)(obj.Col1 ^ obj.Col2);
	}

	public bool Equals(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
	{
		if (x.Col1 == y.Col1 && x.Col2 == y.Col2)
		{
			return x.Col3 == y.Col3;
		}
		return false;
	}

	public int GetHashCode(Row<uint, uint, uint> obj)
	{
		return (int)(obj.Col1 ^ obj.Col2 ^ obj.Col3);
	}
}


using System.Collections.Generic;
using System.Text;
using Mono.Cecil.Metadata;

internal class StringHeap : Heap
{
	private readonly Dictionary<uint, string> strings = new Dictionary<uint, string>();

	public StringHeap(byte[] data)
		: base(data)
	{
	}

	public string Read(uint index)
	{
		if (index == 0)
		{
			return string.Empty;
		}
		if (strings.TryGetValue(index, out var value))
		{
			return value;
		}
		if (index > data.Length - 1)
		{
			return string.Empty;
		}
		value = ReadStringAt(index);
		if (value.Length != 0)
		{
			strings.Add(index, value);
		}
		return value;
	}

	protected virtual string ReadStringAt(uint index)
	{
		int num = 0;
		for (int i = (int)index; data[i] != 0; i++)
		{
			num++;
		}
		return Encoding.UTF8.GetString(data, (int)index, num);
	}
}


internal enum Table : byte
{
	Module = 0,
	TypeRef = 1,
	TypeDef = 2,
	FieldPtr = 3,
	Field = 4,
	MethodPtr = 5,
	Method = 6,
	ParamPtr = 7,
	Param = 8,
	InterfaceImpl = 9,
	MemberRef = 10,
	Constant = 11,
	CustomAttribute = 12,
	FieldMarshal = 13,
	DeclSecurity = 14,
	ClassLayout = 15,
	FieldLayout = 16,
	StandAloneSig = 17,
	EventMap = 18,
	EventPtr = 19,
	Event = 20,
	PropertyMap = 21,
	PropertyPtr = 22,
	Property = 23,
	MethodSemantics = 24,
	MethodImpl = 25,
	ModuleRef = 26,
	TypeSpec = 27,
	ImplMap = 28,
	FieldRVA = 29,
	EncLog = 30,
	EncMap = 31,
	Assembly = 32,
	AssemblyProcessor = 33,
	AssemblyOS = 34,
	AssemblyRef = 35,
	AssemblyRefProcessor = 36,
	AssemblyRefOS = 37,
	File = 38,
	ExportedType = 39,
	ManifestResource = 40,
	NestedClass = 41,
	GenericParam = 42,
	MethodSpec = 43,
	GenericParamConstraint = 44,
	Document = 48,
	MethodDebugInformation = 49,
	LocalScope = 50,
	LocalVariable = 51,
	LocalConstant = 52,
	ImportScope = 53,
	StateMachineMethod = 54,
	CustomDebugInformation = 55
}


internal struct TableInformation
{
	public uint Offset;

	public uint Length;

	public uint RowSize;

	public bool IsLarge => Length > 65535;
}


using Mono.Cecil.Metadata;

internal sealed class TableHeap : Heap
{
	public long Valid;

	public long Sorted;

	public readonly TableInformation[] Tables = new TableInformation[58];

	public TableInformation this[Table table] => Tables[(uint)table];

	public TableHeap(byte[] data)
		: base(data)
	{
	}

	public bool HasTable(Table table)
	{
		return (Valid & (1L << (int)table)) != 0;
	}
}


using Mono.Cecil;
using Mono.Cecil.Metadata;

internal sealed class UserStringHeap : StringHeap
{
	public UserStringHeap(byte[] data)
		: base(data)
	{
	}

	protected override string ReadStringAt(uint index)
	{
		int position = (int)index;
		uint num = (uint)(data.ReadCompressedUInt32(ref position) & -2);
		if (num < 1)
		{
			return string.Empty;
		}
		char[] array = new char[num / 2];
		int i = position;
		int num2 = 0;
		for (; i < position + num; i += 2)
		{
			array[num2++] = (char)(data[i] | (data[i + 1] << 8));
		}
		return new string(array);
	}
}


internal enum Code
{
	Nop,
	Break,
	Ldarg_0,
	Ldarg_1,
	Ldarg_2,
	Ldarg_3,
	Ldloc_0,
	Ldloc_1,
	Ldloc_2,
	Ldloc_3,
	Stloc_0,
	Stloc_1,
	Stloc_2,
	Stloc_3,
	Ldarg_S,
	Ldarga_S,
	Starg_S,
	Ldloc_S,
	Ldloca_S,
	Stloc_S,
	Ldnull,
	Ldc_I4_M1,
	Ldc_I4_0,
	Ldc_I4_1,
	Ldc_I4_2,
	Ldc_I4_3,
	Ldc_I4_4,
	Ldc_I4_5,
	Ldc_I4_6,
	Ldc_I4_7,
	Ldc_I4_8,
	Ldc_I4_S,
	Ldc_I4,
	Ldc_I8,
	Ldc_R4,
	Ldc_R8,
	Dup,
	Pop,
	Jmp,
	Call,
	Calli,
	Ret,
	Br_S,
	Brfalse_S,
	Brtrue_S,
	Beq_S,
	Bge_S,
	Bgt_S,
	Ble_S,
	Blt_S,
	Bne_Un_S,
	Bge_Un_S,
	Bgt_Un_S,
	Ble_Un_S,
	Blt_Un_S,
	Br,
	Brfalse,
	Brtrue,
	Beq,
	Bge,
	Bgt,
	Ble,
	Blt,
	Bne_Un,
	Bge_Un,
	Bgt_Un,
	Ble_Un,
	Blt_Un,
	Switch,
	Ldind_I1,
	Ldind_U1,
	Ldind_I2,
	Ldind_U2,
	Ldind_I4,
	Ldind_U4,
	Ldind_I8,
	Ldind_I,
	Ldind_R4,
	Ldind_R8,
	Ldind_Ref,
	Stind_Ref,
	Stind_I1,
	Stind_I2,
	Stind_I4,
	Stind_I8,
	Stind_R4,
	Stind_R8,
	Add,
	Sub,
	Mul,
	Div,
	Div_Un,
	Rem,
	Rem_Un,
	And,
	Or,
	Xor,
	Shl,
	Shr,
	Shr_Un,
	Neg,
	Not,
	Conv_I1,
	Conv_I2,
	Conv_I4,
	Conv_I8,
	Conv_R4,
	Conv_R8,
	Conv_U4,
	Conv_U8,
	Callvirt,
	Cpobj,
	Ldobj,
	Ldstr,
	Newobj,
	Castclass,
	Isinst,
	Conv_R_Un,
	Unbox,
	Throw,
	Ldfld,
	Ldflda,
	Stfld,
	Ldsfld,
	Ldsflda,
	Stsfld,
	Stobj,
	Conv_Ovf_I1_Un,
	Conv_Ovf_I2_Un,
	Conv_Ovf_I4_Un,
	Conv_Ovf_I8_Un,
	Conv_Ovf_U1_Un,
	Conv_Ovf_U2_Un,
	Conv_Ovf_U4_Un,
	Conv_Ovf_U8_Un,
	Conv_Ovf_I_Un,
	Conv_Ovf_U_Un,
	Box,
	Newarr,
	Ldlen,
	Ldelema,
	Ldelem_I1,
	Ldelem_U1,
	Ldelem_I2,
	Ldelem_U2,
	Ldelem_I4,
	Ldelem_U4,
	Ldelem_I8,
	Ldelem_I,
	Ldelem_R4,
	Ldelem_R8,
	Ldelem_Ref,
	Stelem_I,
	Stelem_I1,
	Stelem_I2,
	Stelem_I4,
	Stelem_I8,
	Stelem_R4,
	Stelem_R8,
	Stelem_Ref,
	Ldelem_Any,
	Stelem_Any,
	Unbox_Any,
	Conv_Ovf_I1,
	Conv_Ovf_U1,
	Conv_Ovf_I2,
	Conv_Ovf_U2,
	Conv_Ovf_I4,
	Conv_Ovf_U4,
	Conv_Ovf_I8,
	Conv_Ovf_U8,
	Refanyval,
	Ckfinite,
	Mkrefany,
	Ldtoken,
	Conv_U2,
	Conv_U1,
	Conv_I,
	Conv_Ovf_I,
	Conv_Ovf_U,
	Add_Ovf,
	Add_Ovf_Un,
	Mul_Ovf,
	Mul_Ovf_Un,
	Sub_Ovf,
	Sub_Ovf_Un,
	Endfinally,
	Leave,
	Leave_S,
	Stind_I,
	Conv_U,
	Arglist,
	Ceq,
	Cgt,
	Cgt_Un,
	Clt,
	Clt_Un,
	Ldftn,
	Ldvirtftn,
	Ldarg,
	Ldarga,
	Starg,
	Ldloc,
	Ldloca,
	Stloc,
	Localloc,
	Endfilter,
	Unaligned,
	Volatile,
	Tail,
	Initobj,
	Constrained,
	Cpblk,
	Initblk,
	No,
	Rethrow,
	Sizeof,
	Refanytype,
	Readonly
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class CodeReader : BinaryStreamReader
{
	internal readonly MetadataReader reader;

	private int start;

	private MethodDefinition method;

	private MethodBody body;

	private int Offset => base.Position - start;

	public CodeReader(MetadataReader reader)
		: base(reader.image.Stream.value)
	{
		this.reader = reader;
	}

	public int MoveTo(MethodDefinition method)
	{
		this.method = method;
		reader.context = method;
		int position = base.Position;
		base.Position = (int)reader.image.ResolveVirtualAddress((uint)method.RVA);
		return position;
	}

	public void MoveBackTo(int position)
	{
		reader.context = null;
		base.Position = position;
	}

	public MethodBody ReadMethodBody(MethodDefinition method)
	{
		int position = MoveTo(method);
		body = new MethodBody(method);
		ReadMethodBody();
		MoveBackTo(position);
		return body;
	}

	public int ReadCodeSize(MethodDefinition method)
	{
		int position = MoveTo(method);
		int result = ReadCodeSize();
		MoveBackTo(position);
		return result;
	}

	private int ReadCodeSize()
	{
		byte b = ReadByte();
		switch (b & 3)
		{
		case 2:
			return b >> 2;
		case 3:
			Advance(3);
			return (int)ReadUInt32();
		default:
			throw new InvalidOperationException();
		}
	}

	private void ReadMethodBody()
	{
		byte b = ReadByte();
		switch (b & 3)
		{
		case 2:
			body.code_size = b >> 2;
			body.MaxStackSize = 8;
			ReadCode();
			break;
		case 3:
			Advance(-1);
			ReadFatMethod();
			break;
		default:
			throw new InvalidOperationException();
		}
		ISymbolReader symbol_reader = reader.module.symbol_reader;
		if (symbol_reader != null && method.debug_info == null)
		{
			method.debug_info = symbol_reader.Read(method);
		}
		if (method.debug_info != null)
		{
			ReadDebugInfo();
		}
	}

	private void ReadFatMethod()
	{
		ushort num = ReadUInt16();
		body.max_stack_size = ReadUInt16();
		body.code_size = (int)ReadUInt32();
		body.local_var_token = new MetadataToken(ReadUInt32());
		body.init_locals = (num & 0x10) != 0;
		if (body.local_var_token.RID != 0)
		{
			body.variables = ReadVariables(body.local_var_token);
		}
		ReadCode();
		if ((num & 8) != 0)
		{
			ReadSection();
		}
	}

	public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
	{
		int position = reader.position;
		VariableDefinitionCollection result = reader.ReadVariables(local_var_token, method);
		reader.position = position;
		return result;
	}

	private void ReadCode()
	{
		start = base.Position;
		int num = body.code_size;
		if (num < 0 || base.Length <= (uint)(num + base.Position))
		{
			num = 0;
		}
		int num2 = start + num;
		Collection<Instruction> collection = (body.instructions = new InstructionCollection(method, (num + 1) / 2));
		while (base.Position < num2)
		{
			int offset = base.Position - start;
			OpCode opCode = ReadOpCode();
			Instruction instruction = new Instruction(offset, opCode);
			if (opCode.OperandType != OperandType.InlineNone)
			{
				instruction.operand = ReadOperand(instruction);
			}
			collection.Add(instruction);
		}
		ResolveBranches(collection);
	}

	private OpCode ReadOpCode()
	{
		byte b = ReadByte();
		if (b == 254)
		{
			return OpCodes.TwoBytesOpCode[ReadByte()];
		}
		return OpCodes.OneByteOpCode[b];
	}

	private object ReadOperand(Instruction instruction)
	{
		switch (instruction.opcode.OperandType)
		{
		case OperandType.InlineSwitch:
		{
			int num = ReadInt32();
			int num2 = Offset + 4 * num;
			int[] array = new int[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = num2 + ReadInt32();
			}
			return array;
		}
		case OperandType.ShortInlineBrTarget:
			return ReadSByte() + Offset;
		case OperandType.InlineBrTarget:
			return ReadInt32() + Offset;
		case OperandType.ShortInlineI:
			if (instruction.opcode == OpCodes.Ldc_I4_S)
			{
				return ReadSByte();
			}
			return ReadByte();
		case OperandType.InlineI:
			return ReadInt32();
		case OperandType.ShortInlineR:
			return ReadSingle();
		case OperandType.InlineR:
			return ReadDouble();
		case OperandType.InlineI8:
			return ReadInt64();
		case OperandType.ShortInlineVar:
			return GetVariable(ReadByte());
		case OperandType.InlineVar:
			return GetVariable(ReadUInt16());
		case OperandType.ShortInlineArg:
			return GetParameter(ReadByte());
		case OperandType.InlineArg:
			return GetParameter(ReadUInt16());
		case OperandType.InlineSig:
			return GetCallSite(ReadToken());
		case OperandType.InlineString:
			return GetString(ReadToken());
		case OperandType.InlineField:
		case OperandType.InlineMethod:
		case OperandType.InlineTok:
		case OperandType.InlineType:
			return reader.LookupToken(ReadToken());
		default:
			throw new NotSupportedException();
		}
	}

	public string GetString(MetadataToken token)
	{
		return reader.image.UserStringHeap.Read(token.RID);
	}

	public ParameterDefinition GetParameter(int index)
	{
		return body.GetParameter(index);
	}

	public VariableDefinition GetVariable(int index)
	{
		return body.GetVariable(index);
	}

	public CallSite GetCallSite(MetadataToken token)
	{
		return reader.ReadCallSite(token);
	}

	private void ResolveBranches(Collection<Instruction> instructions)
	{
		Instruction[] items = instructions.items;
		int size = instructions.size;
		for (int i = 0; i < size; i++)
		{
			Instruction instruction = items[i];
			switch (instruction.opcode.OperandType)
			{
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				instruction.operand = GetInstruction((int)instruction.operand);
				break;
			case OperandType.InlineSwitch:
			{
				int[] array = (int[])instruction.operand;
				Instruction[] array2 = new Instruction[array.Length];
				for (int j = 0; j < array.Length; j++)
				{
					array2[j] = GetInstruction(array[j]);
				}
				instruction.operand = array2;
				break;
			}
			}
		}
	}

	private Instruction GetInstruction(int offset)
	{
		return GetInstruction(body.Instructions, offset);
	}

	private static Instruction GetInstruction(Collection<Instruction> instructions, int offset)
	{
		int size = instructions.size;
		Instruction[] items = instructions.items;
		if (offset < 0 || offset > items[size - 1].offset)
		{
			return null;
		}
		int num = 0;
		int num2 = size - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			Instruction instruction = items[num3];
			int offset2 = instruction.offset;
			if (offset == offset2)
			{
				return instruction;
			}
			if (offset < offset2)
			{
				num2 = num3 - 1;
			}
			else
			{
				num = num3 + 1;
			}
		}
		return null;
	}

	private void ReadSection()
	{
		Align(4);
		byte num = ReadByte();
		if ((num & 0x40) == 0)
		{
			ReadSmallSection();
		}
		else
		{
			ReadFatSection();
		}
		if ((num & 0x80) != 0)
		{
			ReadSection();
		}
	}

	private void ReadSmallSection()
	{
		int count = ReadByte() / 12;
		Advance(2);
		ReadExceptionHandlers(count, () => ReadUInt16(), () => ReadByte());
	}

	private void ReadFatSection()
	{
		Advance(-1);
		int count = (ReadInt32() >> 8) / 24;
		ReadExceptionHandlers(count, ReadInt32, ReadInt32);
	}

	private void ReadExceptionHandlers(int count, Func<int> read_entry, Func<int> read_length)
	{
		for (int i = 0; i < count; i++)
		{
			ExceptionHandler exceptionHandler = new ExceptionHandler((ExceptionHandlerType)(read_entry() & 7));
			exceptionHandler.TryStart = GetInstruction(read_entry());
			exceptionHandler.TryEnd = GetInstruction(exceptionHandler.TryStart.Offset + read_length());
			exceptionHandler.HandlerStart = GetInstruction(read_entry());
			exceptionHandler.HandlerEnd = GetInstruction(exceptionHandler.HandlerStart.Offset + read_length());
			ReadExceptionHandlerSpecific(exceptionHandler);
			body.ExceptionHandlers.Add(exceptionHandler);
		}
	}

	private void ReadExceptionHandlerSpecific(ExceptionHandler handler)
	{
		switch (handler.HandlerType)
		{
		case ExceptionHandlerType.Catch:
			handler.CatchType = (TypeReference)reader.LookupToken(ReadToken());
			break;
		case ExceptionHandlerType.Filter:
			handler.FilterStart = GetInstruction(ReadInt32());
			break;
		default:
			Advance(4);
			break;
		}
	}

	public MetadataToken ReadToken()
	{
		return new MetadataToken(ReadUInt32());
	}

	private void ReadDebugInfo()
	{
		if (method.debug_info.sequence_points != null)
		{
			ReadSequencePoints();
		}
		if (method.debug_info.scope != null)
		{
			ReadScope(method.debug_info.scope);
		}
		if (method.custom_infos != null)
		{
			ReadCustomDebugInformations(method);
		}
	}

	private void ReadCustomDebugInformations(MethodDefinition method)
	{
		Collection<CustomDebugInformation> custom_infos = method.custom_infos;
		for (int i = 0; i < custom_infos.Count; i++)
		{
			if (custom_infos[i] is StateMachineScopeDebugInformation state_machine_scope)
			{
				ReadStateMachineScope(state_machine_scope);
			}
			if (custom_infos[i] is AsyncMethodBodyDebugInformation async_method)
			{
				ReadAsyncMethodBody(async_method);
			}
		}
	}

	private void ReadAsyncMethodBody(AsyncMethodBodyDebugInformation async_method)
	{
		if (async_method.catch_handler.Offset > -1)
		{
			async_method.catch_handler = new InstructionOffset(GetInstruction(async_method.catch_handler.Offset));
		}
		if (!async_method.yields.IsNullOrEmpty())
		{
			for (int i = 0; i < async_method.yields.Count; i++)
			{
				async_method.yields[i] = new InstructionOffset(GetInstruction(async_method.yields[i].Offset));
			}
		}
		if (!async_method.resumes.IsNullOrEmpty())
		{
			for (int j = 0; j < async_method.resumes.Count; j++)
			{
				async_method.resumes[j] = new InstructionOffset(GetInstruction(async_method.resumes[j].Offset));
			}
		}
	}

	private void ReadStateMachineScope(StateMachineScopeDebugInformation state_machine_scope)
	{
		if (state_machine_scope.scopes.IsNullOrEmpty())
		{
			return;
		}
		foreach (StateMachineScope scope in state_machine_scope.scopes)
		{
			scope.start = new InstructionOffset(GetInstruction(scope.start.Offset));
			Instruction instruction = GetInstruction(scope.end.Offset);
			scope.end = ((instruction == null) ? default(InstructionOffset) : new InstructionOffset(instruction));
		}
	}

	private void ReadSequencePoints()
	{
		MethodDebugInformation debug_info = method.debug_info;
		for (int i = 0; i < debug_info.sequence_points.Count; i++)
		{
			SequencePoint sequencePoint = debug_info.sequence_points[i];
			Instruction instruction = GetInstruction(sequencePoint.Offset);
			if (instruction != null)
			{
				sequencePoint.offset = new InstructionOffset(instruction);
			}
		}
	}

	private void ReadScopes(Collection<ScopeDebugInformation> scopes)
	{
		for (int i = 0; i < scopes.Count; i++)
		{
			ReadScope(scopes[i]);
		}
	}

	private void ReadScope(ScopeDebugInformation scope)
	{
		Instruction instruction = GetInstruction(scope.Start.Offset);
		if (instruction != null)
		{
			scope.Start = new InstructionOffset(instruction);
		}
		Instruction instruction2 = GetInstruction(scope.End.Offset);
		scope.End = ((instruction2 != null) ? new InstructionOffset(instruction2) : default(InstructionOffset));
		if (!scope.variables.IsNullOrEmpty())
		{
			for (int i = 0; i < scope.variables.Count; i++)
			{
				VariableDebugInformation variableDebugInformation = scope.variables[i];
				VariableDefinition variable = GetVariable(variableDebugInformation.Index);
				if (variable != null)
				{
					variableDebugInformation.index = new VariableIndex(variable);
				}
			}
		}
		if (!scope.scopes.IsNullOrEmpty())
		{
			ReadScopes(scope.scopes);
		}
	}

	public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, out int code_size, out MetadataToken local_var_token)
	{
		int position = MoveTo(method);
		ByteBuffer byteBuffer = new ByteBuffer();
		byte b = ReadByte();
		switch (b & 3)
		{
		case 2:
			byteBuffer.WriteByte(b);
			local_var_token = MetadataToken.Zero;
			code_size = b >> 2;
			PatchRawCode(byteBuffer, code_size, writer);
			break;
		case 3:
			Advance(-1);
			PatchRawFatMethod(byteBuffer, writer, out code_size, out local_var_token);
			break;
		default:
			throw new NotSupportedException();
		}
		MoveBackTo(position);
		return byteBuffer;
	}

	private void PatchRawFatMethod(ByteBuffer buffer, CodeWriter writer, out int code_size, out MetadataToken local_var_token)
	{
		ushort num = ReadUInt16();
		buffer.WriteUInt16(num);
		buffer.WriteUInt16(ReadUInt16());
		code_size = ReadInt32();
		buffer.WriteInt32(code_size);
		local_var_token = ReadToken();
		if (local_var_token.RID != 0)
		{
			VariableDefinitionCollection variableDefinitionCollection = ReadVariables(local_var_token);
			buffer.WriteUInt32((variableDefinitionCollection != null) ? writer.GetStandAloneSignature(variableDefinitionCollection).ToUInt32() : 0u);
		}
		else
		{
			buffer.WriteUInt32(0u);
		}
		PatchRawCode(buffer, code_size, writer);
		if ((num & 8) != 0)
		{
			PatchRawSection(buffer, writer.metadata);
		}
	}

	private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer)
	{
		MetadataBuilder metadata = writer.metadata;
		buffer.WriteBytes(ReadBytes(code_size));
		int position = buffer.position;
		buffer.position -= code_size;
		while (buffer.position < position)
		{
			byte b = buffer.ReadByte();
			OpCode opCode;
			if (b != 254)
			{
				opCode = OpCodes.OneByteOpCode[b];
			}
			else
			{
				byte b2 = buffer.ReadByte();
				opCode = OpCodes.TwoBytesOpCode[b2];
			}
			switch (opCode.OperandType)
			{
			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineVar:
			case OperandType.ShortInlineArg:
				buffer.position++;
				break;
			case OperandType.InlineVar:
			case OperandType.InlineArg:
				buffer.position += 2;
				break;
			case OperandType.InlineBrTarget:
			case OperandType.InlineI:
			case OperandType.ShortInlineR:
				buffer.position += 4;
				break;
			case OperandType.InlineI8:
			case OperandType.InlineR:
				buffer.position += 8;
				break;
			case OperandType.InlineSwitch:
			{
				int num = buffer.ReadInt32();
				buffer.position += num * 4;
				break;
			}
			case OperandType.InlineString:
			{
				string @string = GetString(new MetadataToken(buffer.ReadUInt32()));
				buffer.position -= 4;
				buffer.WriteUInt32(new MetadataToken(TokenType.String, metadata.user_string_heap.GetStringIndex(@string)).ToUInt32());
				break;
			}
			case OperandType.InlineSig:
			{
				CallSite callSite = GetCallSite(new MetadataToken(buffer.ReadUInt32()));
				buffer.position -= 4;
				buffer.WriteUInt32(writer.GetStandAloneSignature(callSite).ToUInt32());
				break;
			}
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			{
				IMetadataTokenProvider provider = reader.LookupToken(new MetadataToken(buffer.ReadUInt32()));
				buffer.position -= 4;
				buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
				break;
			}
			}
		}
	}

	private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata)
	{
		int position = base.Position;
		Align(4);
		buffer.WriteBytes(base.Position - position);
		byte b = ReadByte();
		if ((b & 0x40) == 0)
		{
			buffer.WriteByte(b);
			PatchRawSmallSection(buffer, metadata);
		}
		else
		{
			PatchRawFatSection(buffer, metadata);
		}
		if ((b & 0x80) != 0)
		{
			PatchRawSection(buffer, metadata);
		}
	}

	private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata)
	{
		byte b = ReadByte();
		buffer.WriteByte(b);
		Advance(2);
		buffer.WriteUInt16(0);
		int count = b / 12;
		PatchRawExceptionHandlers(buffer, metadata, count, fat_entry: false);
	}

	private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata)
	{
		Advance(-1);
		int num = ReadInt32();
		buffer.WriteInt32(num);
		int count = (num >> 8) / 24;
		PatchRawExceptionHandlers(buffer, metadata, count, fat_entry: true);
	}

	private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
	{
		for (int i = 0; i < count; i++)
		{
			ExceptionHandlerType exceptionHandlerType;
			if (fat_entry)
			{
				uint num = ReadUInt32();
				exceptionHandlerType = (ExceptionHandlerType)(num & 7);
				buffer.WriteUInt32(num);
			}
			else
			{
				ushort num2 = ReadUInt16();
				exceptionHandlerType = (ExceptionHandlerType)(num2 & 7);
				buffer.WriteUInt16(num2);
			}
			buffer.WriteBytes(ReadBytes(fat_entry ? 16 : 6));
			if (exceptionHandlerType == ExceptionHandlerType.Catch)
			{
				IMetadataTokenProvider provider = reader.LookupToken(ReadToken());
				buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
			}
			else
			{
				buffer.WriteUInt32(ReadUInt32());
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal sealed class CodeWriter : ByteBuffer
{
	private readonly uint code_base;

	internal readonly MetadataBuilder metadata;

	private readonly Dictionary<uint, MetadataToken> standalone_signatures;

	private readonly Dictionary<ByteBuffer, uint> tiny_method_bodies;

	private MethodBody body;

	public CodeWriter(MetadataBuilder metadata)
		: base(0)
	{
		code_base = metadata.text_map.GetRVA(TextSegment.Code);
		this.metadata = metadata;
		standalone_signatures = new Dictionary<uint, MetadataToken>();
		tiny_method_bodies = new Dictionary<ByteBuffer, uint>(new ByteBufferEqualityComparer());
	}

	public uint WriteMethodBody(MethodDefinition method)
	{
		if (IsUnresolved(method))
		{
			if (method.rva == 0)
			{
				return 0u;
			}
			return WriteUnresolvedMethodBody(method);
		}
		if (IsEmptyMethodBody(method.Body))
		{
			return 0u;
		}
		return WriteResolvedMethodBody(method);
	}

	private static bool IsEmptyMethodBody(MethodBody body)
	{
		if (body.instructions.IsNullOrEmpty())
		{
			return body.variables.IsNullOrEmpty();
		}
		return false;
	}

	private static bool IsUnresolved(MethodDefinition method)
	{
		if (method.HasBody && method.HasImage)
		{
			return method.body == null;
		}
		return false;
	}

	private uint WriteUnresolvedMethodBody(MethodDefinition method)
	{
		int code_size;
		MetadataToken local_var_token;
		ByteBuffer byteBuffer = metadata.module.reader.code.PatchRawMethodBody(method, this, out code_size, out local_var_token);
		bool num = (byteBuffer.buffer[0] & 3) == 3;
		if (num)
		{
			Align(4);
		}
		uint rva = BeginMethod();
		if (num || !GetOrMapTinyMethodBody(byteBuffer, ref rva))
		{
			WriteBytes(byteBuffer);
		}
		if (method.debug_info == null)
		{
			return rva;
		}
		ISymbolWriter symbol_writer = metadata.symbol_writer;
		if (symbol_writer != null)
		{
			method.debug_info.code_size = code_size;
			method.debug_info.local_var_token = local_var_token;
			symbol_writer.Write(method.debug_info);
		}
		return rva;
	}

	private uint WriteResolvedMethodBody(MethodDefinition method)
	{
		body = method.Body;
		ComputeHeader();
		uint rva;
		if (RequiresFatHeader())
		{
			Align(4);
			rva = BeginMethod();
			WriteFatHeader();
			WriteInstructions();
			if (body.HasExceptionHandlers)
			{
				WriteExceptionHandlers();
			}
		}
		else
		{
			rva = BeginMethod();
			WriteByte((byte)(2 | (body.CodeSize << 2)));
			WriteInstructions();
			int num = (int)(rva - code_base);
			int num2 = position - num;
			byte[] destinationArray = new byte[num2];
			Array.Copy(buffer, num, destinationArray, 0, num2);
			if (GetOrMapTinyMethodBody(new ByteBuffer(destinationArray), ref rva))
			{
				position = num;
			}
		}
		ISymbolWriter symbol_writer = metadata.symbol_writer;
		if (symbol_writer != null && method.debug_info != null)
		{
			method.debug_info.code_size = body.CodeSize;
			method.debug_info.local_var_token = body.local_var_token;
			symbol_writer.Write(method.debug_info);
		}
		return rva;
	}

	private bool GetOrMapTinyMethodBody(ByteBuffer body, ref uint rva)
	{
		if (tiny_method_bodies.TryGetValue(body, out var value))
		{
			rva = value;
			return true;
		}
		tiny_method_bodies.Add(body, rva);
		return false;
	}

	private void WriteFatHeader()
	{
		MethodBody methodBody = body;
		byte b = 3;
		if (methodBody.InitLocals)
		{
			b |= 0x10;
		}
		if (methodBody.HasExceptionHandlers)
		{
			b |= 8;
		}
		WriteByte(b);
		WriteByte(48);
		WriteInt16((short)methodBody.max_stack_size);
		WriteInt32(methodBody.code_size);
		methodBody.local_var_token = (methodBody.HasVariables ? GetStandAloneSignature(methodBody.Variables) : MetadataToken.Zero);
		WriteMetadataToken(methodBody.local_var_token);
	}

	private void WriteInstructions()
	{
		Collection<Instruction> instructions = body.Instructions;
		Instruction[] items = instructions.items;
		int size = instructions.size;
		for (int i = 0; i < size; i++)
		{
			Instruction instruction = items[i];
			WriteOpCode(instruction.opcode);
			WriteOperand(instruction);
		}
	}

	private void WriteOpCode(OpCode opcode)
	{
		if (opcode.Size == 1)
		{
			WriteByte(opcode.Op2);
			return;
		}
		WriteByte(opcode.Op1);
		WriteByte(opcode.Op2);
	}

	private void WriteOperand(Instruction instruction)
	{
		OpCode opcode = instruction.opcode;
		OperandType operandType = opcode.OperandType;
		if (operandType == OperandType.InlineNone)
		{
			return;
		}
		object operand = instruction.operand;
		if (operand == null && operandType != 0 && operandType != OperandType.ShortInlineBrTarget)
		{
			throw new ArgumentException();
		}
		switch (operandType)
		{
		case OperandType.InlineSwitch:
		{
			Instruction[] array = (Instruction[])operand;
			WriteInt32(array.Length);
			int num2 = instruction.Offset + opcode.Size + 4 * (array.Length + 1);
			for (int i = 0; i < array.Length; i++)
			{
				WriteInt32(GetTargetOffset(array[i]) - num2);
			}
			break;
		}
		case OperandType.ShortInlineBrTarget:
		{
			Instruction instruction2 = (Instruction)operand;
			int num = ((instruction2 != null) ? GetTargetOffset(instruction2) : body.code_size);
			WriteSByte((sbyte)(num - (instruction.Offset + opcode.Size + 1)));
			break;
		}
		case OperandType.InlineBrTarget:
		{
			Instruction instruction3 = (Instruction)operand;
			int num3 = ((instruction3 != null) ? GetTargetOffset(instruction3) : body.code_size);
			WriteInt32(num3 - (instruction.Offset + opcode.Size + 4));
			break;
		}
		case OperandType.ShortInlineVar:
			WriteByte((byte)GetVariableIndex((VariableDefinition)operand));
			break;
		case OperandType.ShortInlineArg:
			WriteByte((byte)GetParameterIndex((ParameterDefinition)operand));
			break;
		case OperandType.InlineVar:
			WriteInt16((short)GetVariableIndex((VariableDefinition)operand));
			break;
		case OperandType.InlineArg:
			WriteInt16((short)GetParameterIndex((ParameterDefinition)operand));
			break;
		case OperandType.InlineSig:
			WriteMetadataToken(GetStandAloneSignature((CallSite)operand));
			break;
		case OperandType.ShortInlineI:
			if (opcode == OpCodes.Ldc_I4_S)
			{
				WriteSByte((sbyte)operand);
			}
			else
			{
				WriteByte((byte)operand);
			}
			break;
		case OperandType.InlineI:
			WriteInt32((int)operand);
			break;
		case OperandType.InlineI8:
			WriteInt64((long)operand);
			break;
		case OperandType.ShortInlineR:
			WriteSingle((float)operand);
			break;
		case OperandType.InlineR:
			WriteDouble((double)operand);
			break;
		case OperandType.InlineString:
			WriteMetadataToken(new MetadataToken(TokenType.String, GetUserStringIndex((string)operand)));
			break;
		case OperandType.InlineField:
		case OperandType.InlineMethod:
		case OperandType.InlineTok:
		case OperandType.InlineType:
			WriteMetadataToken(metadata.LookupToken((IMetadataTokenProvider)operand));
			break;
		default:
			throw new ArgumentException();
		}
	}

	private int GetTargetOffset(Instruction instruction)
	{
		if (instruction == null)
		{
			Instruction instruction2 = body.instructions[body.instructions.size - 1];
			return instruction2.offset + instruction2.GetSize();
		}
		return instruction.offset;
	}

	private uint GetUserStringIndex(string @string)
	{
		if (@string == null)
		{
			return 0u;
		}
		return metadata.user_string_heap.GetStringIndex(@string);
	}

	private static int GetVariableIndex(VariableDefinition variable)
	{
		return variable.Index;
	}

	private int GetParameterIndex(ParameterDefinition parameter)
	{
		if (body.method.HasThis)
		{
			if (parameter == body.this_parameter)
			{
				return 0;
			}
			return parameter.Index + 1;
		}
		return parameter.Index;
	}

	private bool RequiresFatHeader()
	{
		MethodBody methodBody = body;
		if (methodBody.CodeSize < 64 && !methodBody.InitLocals && !methodBody.HasVariables && !methodBody.HasExceptionHandlers)
		{
			return methodBody.MaxStackSize > 8;
		}
		return true;
	}

	private void ComputeHeader()
	{
		int num = 0;
		Collection<Instruction> instructions = body.instructions;
		Instruction[] items = instructions.items;
		int size = instructions.size;
		int stack_size = 0;
		int max_stack = 0;
		Dictionary<Instruction, int> stack_sizes = null;
		if (body.HasExceptionHandlers)
		{
			ComputeExceptionHandlerStackSize(ref stack_sizes);
		}
		for (int i = 0; i < size; i++)
		{
			Instruction instruction = items[i];
			instruction.offset = num;
			num += instruction.GetSize();
			ComputeStackSize(instruction, ref stack_sizes, ref stack_size, ref max_stack);
		}
		body.code_size = num;
		body.max_stack_size = max_stack;
	}

	private void ComputeExceptionHandlerStackSize(ref Dictionary<Instruction, int> stack_sizes)
	{
		Collection<ExceptionHandler> exceptionHandlers = body.ExceptionHandlers;
		for (int i = 0; i < exceptionHandlers.Count; i++)
		{
			ExceptionHandler exceptionHandler = exceptionHandlers[i];
			switch (exceptionHandler.HandlerType)
			{
			case ExceptionHandlerType.Catch:
				AddExceptionStackSize(exceptionHandler.HandlerStart, ref stack_sizes);
				break;
			case ExceptionHandlerType.Filter:
				AddExceptionStackSize(exceptionHandler.FilterStart, ref stack_sizes);
				AddExceptionStackSize(exceptionHandler.HandlerStart, ref stack_sizes);
				break;
			}
		}
	}

	private static void AddExceptionStackSize(Instruction handler_start, ref Dictionary<Instruction, int> stack_sizes)
	{
		if (handler_start != null)
		{
			if (stack_sizes == null)
			{
				stack_sizes = new Dictionary<Instruction, int>();
			}
			stack_sizes[handler_start] = 1;
		}
	}

	private static void ComputeStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, ref int stack_size, ref int max_stack)
	{
		if (stack_sizes != null && stack_sizes.TryGetValue(instruction, out var value))
		{
			stack_size = value;
		}
		max_stack = Math.Max(max_stack, stack_size);
		ComputeStackDelta(instruction, ref stack_size);
		max_stack = Math.Max(max_stack, stack_size);
		CopyBranchStackSize(instruction, ref stack_sizes, stack_size);
		ComputeStackSize(instruction, ref stack_size);
	}

	private static void CopyBranchStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, int stack_size)
	{
		if (stack_size == 0)
		{
			return;
		}
		switch (instruction.opcode.OperandType)
		{
		case OperandType.InlineBrTarget:
		case OperandType.ShortInlineBrTarget:
			CopyBranchStackSize(ref stack_sizes, (Instruction)instruction.operand, stack_size);
			break;
		case OperandType.InlineSwitch:
		{
			Instruction[] array = (Instruction[])instruction.operand;
			for (int i = 0; i < array.Length; i++)
			{
				CopyBranchStackSize(ref stack_sizes, array[i], stack_size);
			}
			break;
		}
		}
	}

	private static void CopyBranchStackSize(ref Dictionary<Instruction, int> stack_sizes, Instruction target, int stack_size)
	{
		if (stack_sizes == null)
		{
			stack_sizes = new Dictionary<Instruction, int>();
		}
		int num = stack_size;
		if (stack_sizes.TryGetValue(target, out var value))
		{
			num = Math.Max(num, value);
		}
		stack_sizes[target] = num;
	}

	private static void ComputeStackSize(Instruction instruction, ref int stack_size)
	{
		FlowControl flowControl = instruction.opcode.FlowControl;
		if (flowControl == FlowControl.Branch || (uint)(flowControl - 7) <= 1u)
		{
			stack_size = 0;
		}
	}

	private static void ComputeStackDelta(Instruction instruction, ref int stack_size)
	{
		if (instruction.opcode.FlowControl == FlowControl.Call)
		{
			IMethodSignature methodSignature = (IMethodSignature)instruction.operand;
			if (methodSignature.HasImplicitThis() && instruction.opcode.Code != Code.Newobj)
			{
				stack_size--;
			}
			if (methodSignature.HasParameters)
			{
				stack_size -= methodSignature.Parameters.Count;
			}
			if (instruction.opcode.Code == Code.Calli)
			{
				stack_size--;
			}
			if (methodSignature.ReturnType.etype != ElementType.Void || instruction.opcode.Code == Code.Newobj)
			{
				stack_size++;
			}
		}
		else
		{
			ComputePopDelta(instruction.opcode.StackBehaviourPop, ref stack_size);
			ComputePushDelta(instruction.opcode.StackBehaviourPush, ref stack_size);
		}
	}

	private static void ComputePopDelta(StackBehaviour pop_behavior, ref int stack_size)
	{
		switch (pop_behavior)
		{
		case StackBehaviour.Pop1:
		case StackBehaviour.Popi:
		case StackBehaviour.Popref:
			stack_size--;
			break;
		case StackBehaviour.Pop1_pop1:
		case StackBehaviour.Popi_pop1:
		case StackBehaviour.Popi_popi:
		case StackBehaviour.Popi_popi8:
		case StackBehaviour.Popi_popr4:
		case StackBehaviour.Popi_popr8:
		case StackBehaviour.Popref_pop1:
		case StackBehaviour.Popref_popi:
			stack_size -= 2;
			break;
		case StackBehaviour.Popi_popi_popi:
		case StackBehaviour.Popref_popi_popi:
		case StackBehaviour.Popref_popi_popi8:
		case StackBehaviour.Popref_popi_popr4:
		case StackBehaviour.Popref_popi_popr8:
		case StackBehaviour.Popref_popi_popref:
			stack_size -= 3;
			break;
		case StackBehaviour.PopAll:
			stack_size = 0;
			break;
		}
	}

	private static void ComputePushDelta(StackBehaviour push_behaviour, ref int stack_size)
	{
		switch (push_behaviour)
		{
		case StackBehaviour.Push1:
		case StackBehaviour.Pushi:
		case StackBehaviour.Pushi8:
		case StackBehaviour.Pushr4:
		case StackBehaviour.Pushr8:
		case StackBehaviour.Pushref:
			stack_size++;
			break;
		case StackBehaviour.Push1_push1:
			stack_size += 2;
			break;
		}
	}

	private void WriteExceptionHandlers()
	{
		Align(4);
		Collection<ExceptionHandler> exceptionHandlers = body.ExceptionHandlers;
		if (exceptionHandlers.Count < 21 && !RequiresFatSection(exceptionHandlers))
		{
			WriteSmallSection(exceptionHandlers);
		}
		else
		{
			WriteFatSection(exceptionHandlers);
		}
	}

	private static bool RequiresFatSection(Collection<ExceptionHandler> handlers)
	{
		for (int i = 0; i < handlers.Count; i++)
		{
			ExceptionHandler exceptionHandler = handlers[i];
			if (IsFatRange(exceptionHandler.TryStart, exceptionHandler.TryEnd))
			{
				return true;
			}
			if (IsFatRange(exceptionHandler.HandlerStart, exceptionHandler.HandlerEnd))
			{
				return true;
			}
			if (exceptionHandler.HandlerType == ExceptionHandlerType.Filter && IsFatRange(exceptionHandler.FilterStart, exceptionHandler.HandlerStart))
			{
				return true;
			}
		}
		return false;
	}

	private static bool IsFatRange(Instruction start, Instruction end)
	{
		if (start == null)
		{
			throw new ArgumentException();
		}
		if (end == null)
		{
			return true;
		}
		if (end.Offset - start.Offset <= 255)
		{
			return start.Offset > 65535;
		}
		return true;
	}

	private void WriteSmallSection(Collection<ExceptionHandler> handlers)
	{
		WriteByte(1);
		WriteByte((byte)(handlers.Count * 12 + 4));
		WriteBytes(2);
		WriteExceptionHandlers(handlers, delegate(int i)
		{
			WriteUInt16((ushort)i);
		}, delegate(int i)
		{
			WriteByte((byte)i);
		});
	}

	private void WriteFatSection(Collection<ExceptionHandler> handlers)
	{
		WriteByte(65);
		int num = handlers.Count * 24 + 4;
		WriteByte((byte)(num & 0xFF));
		WriteByte((byte)((num >> 8) & 0xFF));
		WriteByte((byte)((num >> 16) & 0xFF));
		WriteExceptionHandlers(handlers, base.WriteInt32, base.WriteInt32);
	}

	private void WriteExceptionHandlers(Collection<ExceptionHandler> handlers, Action<int> write_entry, Action<int> write_length)
	{
		for (int i = 0; i < handlers.Count; i++)
		{
			ExceptionHandler exceptionHandler = handlers[i];
			write_entry((int)exceptionHandler.HandlerType);
			write_entry(exceptionHandler.TryStart.Offset);
			write_length(GetTargetOffset(exceptionHandler.TryEnd) - exceptionHandler.TryStart.Offset);
			write_entry(exceptionHandler.HandlerStart.Offset);
			write_length(GetTargetOffset(exceptionHandler.HandlerEnd) - exceptionHandler.HandlerStart.Offset);
			WriteExceptionHandlerSpecific(exceptionHandler);
		}
	}

	private void WriteExceptionHandlerSpecific(ExceptionHandler handler)
	{
		switch (handler.HandlerType)
		{
		case ExceptionHandlerType.Catch:
			WriteMetadataToken(metadata.LookupToken(handler.CatchType));
			break;
		case ExceptionHandlerType.Filter:
			WriteInt32(handler.FilterStart.Offset);
			break;
		default:
			WriteInt32(0);
			break;
		}
	}

	public MetadataToken GetStandAloneSignature(Collection<VariableDefinition> variables)
	{
		uint localVariableBlobIndex = metadata.GetLocalVariableBlobIndex(variables);
		return GetStandAloneSignatureToken(localVariableBlobIndex);
	}

	public MetadataToken GetStandAloneSignature(CallSite call_site)
	{
		uint callSiteBlobIndex = metadata.GetCallSiteBlobIndex(call_site);
		return call_site.MetadataToken = GetStandAloneSignatureToken(callSiteBlobIndex);
	}

	private MetadataToken GetStandAloneSignatureToken(uint signature)
	{
		if (standalone_signatures.TryGetValue(signature, out var value))
		{
			return value;
		}
		value = new MetadataToken(TokenType.Signature, metadata.AddStandAloneSignature(signature));
		standalone_signatures.Add(signature, value);
		return value;
	}

	private uint BeginMethod()
	{
		return (uint)(code_base + position);
	}

	private void WriteMetadataToken(MetadataToken token)
	{
		WriteUInt32(token.ToUInt32());
	}

	private void Align(int align)
	{
		align--;
		WriteBytes(((position + align) & ~align) - position);
	}
}


internal enum DocumentType
{
	Other,
	Text
}


internal enum DocumentHashAlgorithm
{
	None,
	MD5,
	SHA1,
	SHA256
}


internal enum DocumentLanguage
{
	Other,
	C,
	Cpp,
	CSharp,
	Basic,
	Java,
	Cobol,
	Pascal,
	Cil,
	JScript,
	Smc,
	MCpp,
	FSharp
}


internal enum DocumentLanguageVendor
{
	Other,
	Microsoft
}


using System;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class Document : DebugInformation
{
	private string url;

	private Guid type;

	private Guid hash_algorithm;

	private Guid language;

	private Guid language_vendor;

	private byte[] hash;

	private byte[] embedded_source;

	public string Url
	{
		get
		{
			return url;
		}
		set
		{
			url = value;
		}
	}

	public DocumentType Type
	{
		get
		{
			return type.ToType();
		}
		set
		{
			type = value.ToGuid();
		}
	}

	public Guid TypeGuid
	{
		get
		{
			return type;
		}
		set
		{
			type = value;
		}
	}

	public DocumentHashAlgorithm HashAlgorithm
	{
		get
		{
			return hash_algorithm.ToHashAlgorithm();
		}
		set
		{
			hash_algorithm = value.ToGuid();
		}
	}

	public Guid HashAlgorithmGuid
	{
		get
		{
			return hash_algorithm;
		}
		set
		{
			hash_algorithm = value;
		}
	}

	public DocumentLanguage Language
	{
		get
		{
			return language.ToLanguage();
		}
		set
		{
			language = value.ToGuid();
		}
	}

	public Guid LanguageGuid
	{
		get
		{
			return language;
		}
		set
		{
			language = value;
		}
	}

	public DocumentLanguageVendor LanguageVendor
	{
		get
		{
			return language_vendor.ToVendor();
		}
		set
		{
			language_vendor = value.ToGuid();
		}
	}

	public Guid LanguageVendorGuid
	{
		get
		{
			return language_vendor;
		}
		set
		{
			language_vendor = value;
		}
	}

	public byte[] Hash
	{
		get
		{
			return hash;
		}
		set
		{
			hash = value;
		}
	}

	public byte[] EmbeddedSource
	{
		get
		{
			return embedded_source;
		}
		set
		{
			embedded_source = value;
		}
	}

	public Document(string url)
	{
		this.url = url;
		hash = Empty<byte>.Array;
		embedded_source = Empty<byte>.Array;
		token = new MetadataToken(TokenType.Document);
	}
}


internal enum ExceptionHandlerType
{
	Catch = 0,
	Filter = 1,
	Finally = 2,
	Fault = 4
}


using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class ExceptionHandler
{
	private Instruction try_start;

	private Instruction try_end;

	private Instruction filter_start;

	private Instruction handler_start;

	private Instruction handler_end;

	private TypeReference catch_type;

	private ExceptionHandlerType handler_type;

	public Instruction TryStart
	{
		get
		{
			return try_start;
		}
		set
		{
			try_start = value;
		}
	}

	public Instruction TryEnd
	{
		get
		{
			return try_end;
		}
		set
		{
			try_end = value;
		}
	}

	public Instruction FilterStart
	{
		get
		{
			return filter_start;
		}
		set
		{
			filter_start = value;
		}
	}

	public Instruction HandlerStart
	{
		get
		{
			return handler_start;
		}
		set
		{
			handler_start = value;
		}
	}

	public Instruction HandlerEnd
	{
		get
		{
			return handler_end;
		}
		set
		{
			handler_end = value;
		}
	}

	public TypeReference CatchType
	{
		get
		{
			return catch_type;
		}
		set
		{
			catch_type = value;
		}
	}

	public ExceptionHandlerType HandlerType
	{
		get
		{
			return handler_type;
		}
		set
		{
			handler_type = value;
		}
	}

	public ExceptionHandler(ExceptionHandlerType handlerType)
	{
		handler_type = handlerType;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class ILProcessor
{
	private readonly MethodBody body;

	private readonly Collection<Instruction> instructions;

	public MethodBody Body => body;

	internal ILProcessor(MethodBody body)
	{
		this.body = body;
		instructions = body.Instructions;
	}

	public Instruction Create(OpCode opcode)
	{
		return Instruction.Create(opcode);
	}

	public Instruction Create(OpCode opcode, TypeReference type)
	{
		return Instruction.Create(opcode, type);
	}

	public Instruction Create(OpCode opcode, CallSite site)
	{
		return Instruction.Create(opcode, site);
	}

	public Instruction Create(OpCode opcode, MethodReference method)
	{
		return Instruction.Create(opcode, method);
	}

	public Instruction Create(OpCode opcode, FieldReference field)
	{
		return Instruction.Create(opcode, field);
	}

	public Instruction Create(OpCode opcode, string value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, sbyte value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, byte value)
	{
		if (opcode.OperandType == OperandType.ShortInlineVar)
		{
			return Instruction.Create(opcode, body.Variables[value]);
		}
		if (opcode.OperandType == OperandType.ShortInlineArg)
		{
			return Instruction.Create(opcode, body.GetParameter(value));
		}
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, int value)
	{
		if (opcode.OperandType == OperandType.InlineVar)
		{
			return Instruction.Create(opcode, body.Variables[value]);
		}
		if (opcode.OperandType == OperandType.InlineArg)
		{
			return Instruction.Create(opcode, body.GetParameter(value));
		}
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, long value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, float value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, double value)
	{
		return Instruction.Create(opcode, value);
	}

	public Instruction Create(OpCode opcode, Instruction target)
	{
		return Instruction.Create(opcode, target);
	}

	public Instruction Create(OpCode opcode, Instruction[] targets)
	{
		return Instruction.Create(opcode, targets);
	}

	public Instruction Create(OpCode opcode, VariableDefinition variable)
	{
		return Instruction.Create(opcode, variable);
	}

	public Instruction Create(OpCode opcode, ParameterDefinition parameter)
	{
		return Instruction.Create(opcode, parameter);
	}

	public void Emit(OpCode opcode)
	{
		Append(Create(opcode));
	}

	public void Emit(OpCode opcode, TypeReference type)
	{
		Append(Create(opcode, type));
	}

	public void Emit(OpCode opcode, MethodReference method)
	{
		Append(Create(opcode, method));
	}

	public void Emit(OpCode opcode, CallSite site)
	{
		Append(Create(opcode, site));
	}

	public void Emit(OpCode opcode, FieldReference field)
	{
		Append(Create(opcode, field));
	}

	public void Emit(OpCode opcode, string value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, byte value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, sbyte value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, int value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, long value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, float value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, double value)
	{
		Append(Create(opcode, value));
	}

	public void Emit(OpCode opcode, Instruction target)
	{
		Append(Create(opcode, target));
	}

	public void Emit(OpCode opcode, Instruction[] targets)
	{
		Append(Create(opcode, targets));
	}

	public void Emit(OpCode opcode, VariableDefinition variable)
	{
		Append(Create(opcode, variable));
	}

	public void Emit(OpCode opcode, ParameterDefinition parameter)
	{
		Append(Create(opcode, parameter));
	}

	public void InsertBefore(Instruction target, Instruction instruction)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		int num = instructions.IndexOf(target);
		if (num == -1)
		{
			throw new ArgumentOutOfRangeException("target");
		}
		instructions.Insert(num, instruction);
	}

	public void InsertAfter(Instruction target, Instruction instruction)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		int num = instructions.IndexOf(target);
		if (num == -1)
		{
			throw new ArgumentOutOfRangeException("target");
		}
		instructions.Insert(num + 1, instruction);
	}

	public void InsertAfter(int index, Instruction instruction)
	{
		if (index < 0 || index >= instructions.Count)
		{
			throw new ArgumentOutOfRangeException("index");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		instructions.Insert(index + 1, instruction);
	}

	public void Append(Instruction instruction)
	{
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		instructions.Add(instruction);
	}

	public void Replace(Instruction target, Instruction instruction)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		InsertAfter(target, instruction);
		Remove(target);
	}

	public void Replace(int index, Instruction instruction)
	{
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		InsertAfter(index, instruction);
		RemoveAt(index);
	}

	public void Remove(Instruction instruction)
	{
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		if (!instructions.Remove(instruction))
		{
			throw new ArgumentOutOfRangeException("instruction");
		}
	}

	public void RemoveAt(int index)
	{
		if (index < 0 || index >= instructions.Count)
		{
			throw new ArgumentOutOfRangeException("index");
		}
		instructions.RemoveAt(index);
	}

	public void Clear()
	{
		instructions.Clear();
	}
}


using System;
using System.Globalization;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class Instruction
{
	internal int offset;

	internal OpCode opcode;

	internal object operand;

	internal Instruction previous;

	internal Instruction next;

	public int Offset
	{
		get
		{
			return offset;
		}
		set
		{
			offset = value;
		}
	}

	public OpCode OpCode
	{
		get
		{
			return opcode;
		}
		set
		{
			opcode = value;
		}
	}

	public object Operand
	{
		get
		{
			return operand;
		}
		set
		{
			operand = value;
		}
	}

	public Instruction Previous
	{
		get
		{
			return previous;
		}
		set
		{
			previous = value;
		}
	}

	public Instruction Next
	{
		get
		{
			return next;
		}
		set
		{
			next = value;
		}
	}

	internal Instruction(int offset, OpCode opCode)
	{
		this.offset = offset;
		opcode = opCode;
	}

	internal Instruction(OpCode opcode, object operand)
	{
		this.opcode = opcode;
		this.operand = operand;
	}

	public int GetSize()
	{
		int size = opcode.Size;
		switch (opcode.OperandType)
		{
		case OperandType.InlineSwitch:
			return size + (1 + ((Instruction[])operand).Length) * 4;
		case OperandType.InlineI8:
		case OperandType.InlineR:
			return size + 8;
		case OperandType.InlineBrTarget:
		case OperandType.InlineField:
		case OperandType.InlineI:
		case OperandType.InlineMethod:
		case OperandType.InlineSig:
		case OperandType.InlineString:
		case OperandType.InlineTok:
		case OperandType.InlineType:
		case OperandType.ShortInlineR:
			return size + 4;
		case OperandType.InlineVar:
		case OperandType.InlineArg:
			return size + 2;
		case OperandType.ShortInlineBrTarget:
		case OperandType.ShortInlineI:
		case OperandType.ShortInlineVar:
		case OperandType.ShortInlineArg:
			return size + 1;
		default:
			return size;
		}
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		AppendLabel(stringBuilder, this);
		stringBuilder.Append(':');
		stringBuilder.Append(' ');
		stringBuilder.Append(opcode.Name);
		if (operand == null)
		{
			return stringBuilder.ToString();
		}
		stringBuilder.Append(' ');
		switch (opcode.OperandType)
		{
		case OperandType.InlineBrTarget:
		case OperandType.ShortInlineBrTarget:
			AppendLabel(stringBuilder, (Instruction)operand);
			break;
		case OperandType.InlineSwitch:
		{
			Instruction[] array = (Instruction[])operand;
			for (int i = 0; i < array.Length; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(',');
				}
				AppendLabel(stringBuilder, array[i]);
			}
			break;
		}
		case OperandType.InlineString:
			stringBuilder.Append('"');
			stringBuilder.Append(operand);
			stringBuilder.Append('"');
			break;
		default:
			stringBuilder.Append(Convert.ToString(operand, CultureInfo.InvariantCulture));
			break;
		}
		return stringBuilder.ToString();
	}

	private static void AppendLabel(StringBuilder builder, Instruction instruction)
	{
		builder.Append("IL_");
		builder.Append(instruction.offset.ToString("x4"));
	}

	public static Instruction Create(OpCode opcode)
	{
		if (opcode.OperandType != OperandType.InlineNone)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, null);
	}

	public static Instruction Create(OpCode opcode, TypeReference type)
	{
		if (type == null)
		{
			throw new ArgumentNullException("type");
		}
		if (opcode.OperandType != OperandType.InlineType && opcode.OperandType != OperandType.InlineTok)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, type);
	}

	public static Instruction Create(OpCode opcode, CallSite site)
	{
		if (site == null)
		{
			throw new ArgumentNullException("site");
		}
		if (opcode.Code != Code.Calli)
		{
			throw new ArgumentException("code");
		}
		return new Instruction(opcode, site);
	}

	public static Instruction Create(OpCode opcode, MethodReference method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		if (opcode.OperandType != OperandType.InlineMethod && opcode.OperandType != OperandType.InlineTok)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, method);
	}

	public static Instruction Create(OpCode opcode, FieldReference field)
	{
		if (field == null)
		{
			throw new ArgumentNullException("field");
		}
		if (opcode.OperandType != OperandType.InlineField && opcode.OperandType != OperandType.InlineTok)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, field);
	}

	public static Instruction Create(OpCode opcode, string value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (opcode.OperandType != OperandType.InlineString)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, sbyte value)
	{
		if (opcode.OperandType != OperandType.ShortInlineI && opcode != OpCodes.Ldc_I4_S)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, byte value)
	{
		if (opcode.OperandType != OperandType.ShortInlineI || opcode == OpCodes.Ldc_I4_S)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, int value)
	{
		if (opcode.OperandType != OperandType.InlineI)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, long value)
	{
		if (opcode.OperandType != OperandType.InlineI8)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, float value)
	{
		if (opcode.OperandType != OperandType.ShortInlineR)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, double value)
	{
		if (opcode.OperandType != OperandType.InlineR)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, value);
	}

	public static Instruction Create(OpCode opcode, Instruction target)
	{
		if (target == null)
		{
			throw new ArgumentNullException("target");
		}
		if (opcode.OperandType != 0 && opcode.OperandType != OperandType.ShortInlineBrTarget)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, target);
	}

	public static Instruction Create(OpCode opcode, Instruction[] targets)
	{
		if (targets == null)
		{
			throw new ArgumentNullException("targets");
		}
		if (opcode.OperandType != OperandType.InlineSwitch)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, targets);
	}

	public static Instruction Create(OpCode opcode, VariableDefinition variable)
	{
		if (variable == null)
		{
			throw new ArgumentNullException("variable");
		}
		if (opcode.OperandType != OperandType.ShortInlineVar && opcode.OperandType != OperandType.InlineVar)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, variable);
	}

	public static Instruction Create(OpCode opcode, ParameterDefinition parameter)
	{
		if (parameter == null)
		{
			throw new ArgumentNullException("parameter");
		}
		if (opcode.OperandType != OperandType.ShortInlineArg && opcode.OperandType != OperandType.InlineArg)
		{
			throw new ArgumentException("opcode");
		}
		return new Instruction(opcode, parameter);
	}
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class MethodBody
{
	internal readonly MethodDefinition method;

	internal ParameterDefinition this_parameter;

	internal int max_stack_size;

	internal int code_size;

	internal bool init_locals;

	internal MetadataToken local_var_token;

	internal Collection<Instruction> instructions;

	internal Collection<ExceptionHandler> exceptions;

	internal Collection<VariableDefinition> variables;

	public MethodDefinition Method => method;

	public int MaxStackSize
	{
		get
		{
			return max_stack_size;
		}
		set
		{
			max_stack_size = value;
		}
	}

	public int CodeSize => code_size;

	public bool InitLocals
	{
		get
		{
			return init_locals;
		}
		set
		{
			init_locals = value;
		}
	}

	public MetadataToken LocalVarToken
	{
		get
		{
			return local_var_token;
		}
		set
		{
			local_var_token = value;
		}
	}

	public Collection<Instruction> Instructions
	{
		get
		{
			if (instructions == null)
			{
				Interlocked.CompareExchange(ref instructions, new InstructionCollection(method), null);
			}
			return instructions;
		}
	}

	public bool HasExceptionHandlers => !exceptions.IsNullOrEmpty();

	public Collection<ExceptionHandler> ExceptionHandlers
	{
		get
		{
			if (exceptions == null)
			{
				Interlocked.CompareExchange(ref exceptions, new Collection<ExceptionHandler>(), null);
			}
			return exceptions;
		}
	}

	public bool HasVariables => !variables.IsNullOrEmpty();

	public Collection<VariableDefinition> Variables
	{
		get
		{
			if (variables == null)
			{
				Interlocked.CompareExchange(ref variables, new VariableDefinitionCollection(method), null);
			}
			return variables;
		}
	}

	public ParameterDefinition ThisParameter
	{
		get
		{
			if (method == null || method.DeclaringType == null)
			{
				throw new NotSupportedException();
			}
			if (!method.HasThis)
			{
				return null;
			}
			if (this_parameter == null)
			{
				Interlocked.CompareExchange(ref this_parameter, CreateThisParameter(method), null);
			}
			return this_parameter;
		}
	}

	private static ParameterDefinition CreateThisParameter(MethodDefinition method)
	{
		TypeReference typeReference = method.DeclaringType;
		if (typeReference.HasGenericParameters)
		{
			GenericInstanceType genericInstanceType = new GenericInstanceType(typeReference, typeReference.GenericParameters.Count);
			for (int i = 0; i < typeReference.GenericParameters.Count; i++)
			{
				genericInstanceType.GenericArguments.Add(typeReference.GenericParameters[i]);
			}
			typeReference = genericInstanceType;
		}
		if (typeReference.IsValueType || typeReference.IsPrimitive)
		{
			typeReference = new ByReferenceType(typeReference);
		}
		return new ParameterDefinition(typeReference, method);
	}

	public MethodBody(MethodDefinition method)
	{
		this.method = method;
	}

	public ILProcessor GetILProcessor()
	{
		return new ILProcessor(this);
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class VariableDefinitionCollection : Collection<VariableDefinition>
{
	private readonly MethodDefinition method;

	internal VariableDefinitionCollection(MethodDefinition method)
	{
		this.method = method;
	}

	internal VariableDefinitionCollection(MethodDefinition method, int capacity)
		: base(capacity)
	{
		this.method = method;
	}

	protected override void OnAdd(VariableDefinition item, int index)
	{
		item.index = index;
	}

	protected override void OnInsert(VariableDefinition item, int index)
	{
		item.index = index;
		UpdateVariableIndices(index, 1);
	}

	protected override void OnSet(VariableDefinition item, int index)
	{
		item.index = index;
	}

	protected override void OnRemove(VariableDefinition item, int index)
	{
		UpdateVariableIndices(index + 1, -1, item);
		item.index = -1;
	}

	private void UpdateVariableIndices(int startIndex, int offset, VariableDefinition variableToRemove = null)
	{
		for (int i = startIndex; i < size; i++)
		{
			items[i].index = i + offset;
		}
		MethodDebugInformation methodDebugInformation = ((method == null) ? null : method.debug_info);
		if (methodDebugInformation == null || methodDebugInformation.Scope == null)
		{
			return;
		}
		foreach (ScopeDebugInformation scope in methodDebugInformation.GetScopes())
		{
			if (!scope.HasVariables)
			{
				continue;
			}
			Collection<VariableDebugInformation> variables = scope.Variables;
			int num = -1;
			for (int j = 0; j < variables.Count; j++)
			{
				VariableDebugInformation variableDebugInformation = variables[j];
				if (variableToRemove != null && ((variableDebugInformation.index.IsResolved && variableDebugInformation.index.ResolvedVariable == variableToRemove) || (!variableDebugInformation.index.IsResolved && variableDebugInformation.Index == variableToRemove.Index)))
				{
					num = j;
				}
				else if (!variableDebugInformation.index.IsResolved && variableDebugInformation.Index >= startIndex)
				{
					variableDebugInformation.index = new VariableIndex(variableDebugInformation.Index + offset);
				}
			}
			if (num >= 0)
			{
				variables.RemoveAt(num);
			}
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal class InstructionCollection : Collection<Instruction>
{
	private struct InstructionOffsetResolver
	{
		private readonly Instruction[] items;

		private readonly Instruction removed_instruction;

		private readonly Instruction existing_instruction;

		private int cache_offset;

		private int cache_index;

		private Instruction cache_instruction;

		public int LastOffset => cache_offset;

		public InstructionOffsetResolver(Instruction[] instructions, Instruction removedInstruction, Instruction existingInstruction)
		{
			items = instructions;
			removed_instruction = removedInstruction;
			existing_instruction = existingInstruction;
			cache_offset = 0;
			cache_index = 0;
			cache_instruction = items[0];
		}

		public void Restart()
		{
			cache_offset = 0;
			cache_index = 0;
			cache_instruction = items[0];
		}

		public InstructionOffset Resolve(InstructionOffset inputOffset)
		{
			InstructionOffset result = ResolveInstructionOffset(inputOffset);
			if (!result.IsEndOfMethod && result.ResolvedInstruction == removed_instruction)
			{
				result = new InstructionOffset(existing_instruction);
			}
			return result;
		}

		private InstructionOffset ResolveInstructionOffset(InstructionOffset inputOffset)
		{
			if (inputOffset.IsResolved)
			{
				return inputOffset;
			}
			int offset = inputOffset.Offset;
			if (cache_offset == offset)
			{
				return new InstructionOffset(cache_instruction);
			}
			if (cache_offset > offset)
			{
				int num = 0;
				for (int i = 0; i < items.Length; i++)
				{
					if (items[i] == null)
					{
						return new InstructionOffset((i == 0) ? items[0] : items[i - 1]);
					}
					if (num == offset)
					{
						return new InstructionOffset(items[i]);
					}
					if (num > offset)
					{
						return new InstructionOffset((i == 0) ? items[0] : items[i - 1]);
					}
					num += items[i].GetSize();
				}
				return default(InstructionOffset);
			}
			int num2 = cache_offset;
			for (int j = cache_index; j < items.Length; j++)
			{
				cache_index = j;
				cache_offset = num2;
				Instruction instruction = items[j];
				if (instruction == null)
				{
					return new InstructionOffset((j == 0) ? items[0] : items[j - 1]);
				}
				cache_instruction = instruction;
				if (cache_offset == offset)
				{
					return new InstructionOffset(cache_instruction);
				}
				if (cache_offset > offset)
				{
					return new InstructionOffset((j == 0) ? items[0] : items[j - 1]);
				}
				num2 += instruction.GetSize();
			}
			return default(InstructionOffset);
		}
	}

	private readonly MethodDefinition method;

	internal InstructionCollection(MethodDefinition method)
	{
		this.method = method;
	}

	internal InstructionCollection(MethodDefinition method, int capacity)
		: base(capacity)
	{
		this.method = method;
	}

	protected override void OnAdd(Instruction item, int index)
	{
		if (index != 0)
		{
			Instruction instruction = items[index - 1];
			instruction.next = item;
			item.previous = instruction;
		}
	}

	protected override void OnInsert(Instruction item, int index)
	{
		if (size != 0)
		{
			Instruction instruction = items[index];
			if (instruction == null)
			{
				Instruction instruction2 = items[index - 1];
				instruction2.next = item;
				item.previous = instruction2;
				return;
			}
			_ = instruction.Offset;
			Instruction previous = instruction.previous;
			if (previous != null)
			{
				previous.next = item;
				item.previous = previous;
			}
			instruction.previous = item;
			item.next = instruction;
		}
		UpdateDebugInformation(null, null);
	}

	protected override void OnSet(Instruction item, int index)
	{
		Instruction instruction = items[index];
		item.previous = instruction.previous;
		item.next = instruction.next;
		instruction.previous = null;
		instruction.next = null;
		UpdateDebugInformation(item, instruction);
	}

	protected override void OnRemove(Instruction item, int index)
	{
		Instruction previous = item.previous;
		if (previous != null)
		{
			previous.next = item.next;
		}
		Instruction next = item.next;
		if (next != null)
		{
			next.previous = item.previous;
		}
		RemoveSequencePoint(item);
		UpdateDebugInformation(item, next ?? previous);
		item.previous = null;
		item.next = null;
	}

	private void RemoveSequencePoint(Instruction instruction)
	{
		MethodDebugInformation debug_info = method.debug_info;
		if (debug_info == null || !debug_info.HasSequencePoints)
		{
			return;
		}
		Collection<SequencePoint> sequence_points = debug_info.sequence_points;
		for (int i = 0; i < sequence_points.Count; i++)
		{
			if (sequence_points[i].Offset == instruction.offset)
			{
				sequence_points.RemoveAt(i);
				break;
			}
		}
	}

	private void UpdateDebugInformation(Instruction removedInstruction, Instruction existingInstruction)
	{
		InstructionOffsetResolver resolver = new InstructionOffsetResolver(items, removedInstruction, existingInstruction);
		if (method.debug_info != null)
		{
			UpdateLocalScope(method.debug_info.Scope, ref resolver);
		}
		Collection<CustomDebugInformation> collection = method.custom_infos ?? method.debug_info?.custom_infos;
		if (collection == null)
		{
			return;
		}
		foreach (CustomDebugInformation item in collection)
		{
			if (!(item is StateMachineScopeDebugInformation debugInfo))
			{
				if (item is AsyncMethodBodyDebugInformation debugInfo2)
				{
					UpdateAsyncMethodBody(debugInfo2, ref resolver);
				}
			}
			else
			{
				UpdateStateMachineScope(debugInfo, ref resolver);
			}
		}
	}

	private void UpdateLocalScope(ScopeDebugInformation scope, ref InstructionOffsetResolver resolver)
	{
		if (scope == null)
		{
			return;
		}
		scope.Start = resolver.Resolve(scope.Start);
		if (scope.HasScopes)
		{
			foreach (ScopeDebugInformation scope2 in scope.Scopes)
			{
				UpdateLocalScope(scope2, ref resolver);
			}
		}
		scope.End = resolver.Resolve(scope.End);
	}

	private void UpdateStateMachineScope(StateMachineScopeDebugInformation debugInfo, ref InstructionOffsetResolver resolver)
	{
		resolver.Restart();
		foreach (StateMachineScope scope in debugInfo.Scopes)
		{
			scope.Start = resolver.Resolve(scope.Start);
			scope.End = resolver.Resolve(scope.End);
		}
	}

	private void UpdateAsyncMethodBody(AsyncMethodBodyDebugInformation debugInfo, ref InstructionOffsetResolver resolver)
	{
		if (!debugInfo.CatchHandler.IsResolved)
		{
			resolver.Restart();
			debugInfo.CatchHandler = resolver.Resolve(debugInfo.CatchHandler);
		}
		resolver.Restart();
		for (int i = 0; i < debugInfo.Yields.Count; i++)
		{
			debugInfo.Yields[i] = resolver.Resolve(debugInfo.Yields[i]);
		}
		resolver.Restart();
		for (int j = 0; j < debugInfo.Resumes.Count; j++)
		{
			debugInfo.Resumes[j] = resolver.Resolve(debugInfo.Resumes[j]);
		}
	}
}


private struct InstructionOffsetResolver
{
	private readonly Instruction[] items;

	private readonly Instruction removed_instruction;

	private readonly Instruction existing_instruction;

	private int cache_offset;

	private int cache_index;

	private Instruction cache_instruction;

	public int LastOffset => cache_offset;

	public InstructionOffsetResolver(Instruction[] instructions, Instruction removedInstruction, Instruction existingInstruction)
	{
		items = instructions;
		removed_instruction = removedInstruction;
		existing_instruction = existingInstruction;
		cache_offset = 0;
		cache_index = 0;
		cache_instruction = items[0];
	}

	public void Restart()
	{
		cache_offset = 0;
		cache_index = 0;
		cache_instruction = items[0];
	}

	public InstructionOffset Resolve(InstructionOffset inputOffset)
	{
		InstructionOffset result = ResolveInstructionOffset(inputOffset);
		if (!result.IsEndOfMethod && result.ResolvedInstruction == removed_instruction)
		{
			result = new InstructionOffset(existing_instruction);
		}
		return result;
	}

	private InstructionOffset ResolveInstructionOffset(InstructionOffset inputOffset)
	{
		if (inputOffset.IsResolved)
		{
			return inputOffset;
		}
		int offset = inputOffset.Offset;
		if (cache_offset == offset)
		{
			return new InstructionOffset(cache_instruction);
		}
		if (cache_offset > offset)
		{
			int num = 0;
			for (int i = 0; i < items.Length; i++)
			{
				if (items[i] == null)
				{
					return new InstructionOffset((i == 0) ? items[0] : items[i - 1]);
				}
				if (num == offset)
				{
					return new InstructionOffset(items[i]);
				}
				if (num > offset)
				{
					return new InstructionOffset((i == 0) ? items[0] : items[i - 1]);
				}
				num += items[i].GetSize();
			}
			return default(InstructionOffset);
		}
		int num2 = cache_offset;
		for (int j = cache_index; j < items.Length; j++)
		{
			cache_index = j;
			cache_offset = num2;
			Instruction instruction = items[j];
			if (instruction == null)
			{
				return new InstructionOffset((j == 0) ? items[0] : items[j - 1]);
			}
			cache_instruction = instruction;
			if (cache_offset == offset)
			{
				return new InstructionOffset(cache_instruction);
			}
			if (cache_offset > offset)
			{
				return new InstructionOffset((j == 0) ? items[0] : items[j - 1]);
			}
			num2 += instruction.GetSize();
		}
		return default(InstructionOffset);
	}
}


internal enum FlowControl
{
	Branch,
	Break,
	Call,
	Cond_Branch,
	Meta,
	Next,
	Phi,
	Return,
	Throw
}


internal enum OpCodeType
{
	Annotation,
	Macro,
	Nternal,
	Objmodel,
	Prefix,
	Primitive
}


internal enum OperandType
{
	InlineBrTarget,
	InlineField,
	InlineI,
	InlineI8,
	InlineMethod,
	InlineNone,
	InlinePhi,
	InlineR,
	InlineSig,
	InlineString,
	InlineSwitch,
	InlineTok,
	InlineType,
	InlineVar,
	InlineArg,
	ShortInlineBrTarget,
	ShortInlineI,
	ShortInlineR,
	ShortInlineVar,
	ShortInlineArg
}


internal enum StackBehaviour
{
	Pop0,
	Pop1,
	Pop1_pop1,
	Popi,
	Popi_pop1,
	Popi_popi,
	Popi_popi8,
	Popi_popi_popi,
	Popi_popr4,
	Popi_popr8,
	Popref,
	Popref_pop1,
	Popref_popi,
	Popref_popi_popi,
	Popref_popi_popi8,
	Popref_popi_popr4,
	Popref_popi_popr8,
	Popref_popi_popref,
	PopAll,
	Push0,
	Push1,
	Push1_push1,
	Pushi,
	Pushi8,
	Pushr4,
	Pushr8,
	Pushref,
	Varpop,
	Varpush
}


using System;
using Mono.Cecil.Cil;

internal struct OpCode : IEquatable<OpCode>
{
	private readonly byte op1;

	private readonly byte op2;

	private readonly byte code;

	private readonly byte flow_control;

	private readonly byte opcode_type;

	private readonly byte operand_type;

	private readonly byte stack_behavior_pop;

	private readonly byte stack_behavior_push;

	public string Name => OpCodeNames.names[(int)Code];

	public int Size
	{
		get
		{
			if (op1 != byte.MaxValue)
			{
				return 2;
			}
			return 1;
		}
	}

	public byte Op1 => op1;

	public byte Op2 => op2;

	public short Value
	{
		get
		{
			if (op1 != byte.MaxValue)
			{
				return (short)((op1 << 8) | op2);
			}
			return op2;
		}
	}

	public Code Code => (Code)code;

	public FlowControl FlowControl => (FlowControl)flow_control;

	public OpCodeType OpCodeType => (OpCodeType)opcode_type;

	public OperandType OperandType => (OperandType)operand_type;

	public StackBehaviour StackBehaviourPop => (StackBehaviour)stack_behavior_pop;

	public StackBehaviour StackBehaviourPush => (StackBehaviour)stack_behavior_push;

	internal OpCode(int x, int y)
	{
		op1 = (byte)(x & 0xFF);
		op2 = (byte)((x >> 8) & 0xFF);
		code = (byte)((x >> 16) & 0xFF);
		flow_control = (byte)((x >> 24) & 0xFF);
		opcode_type = (byte)(y & 0xFF);
		operand_type = (byte)((y >> 8) & 0xFF);
		stack_behavior_pop = (byte)((y >> 16) & 0xFF);
		stack_behavior_push = (byte)((y >> 24) & 0xFF);
		if (op1 == byte.MaxValue)
		{
			OpCodes.OneByteOpCode[op2] = this;
		}
		else
		{
			OpCodes.TwoBytesOpCode[op2] = this;
		}
	}

	public override int GetHashCode()
	{
		return Value;
	}

	public override bool Equals(object obj)
	{
		if (!(obj is OpCode opCode))
		{
			return false;
		}
		if (op1 == opCode.op1)
		{
			return op2 == opCode.op2;
		}
		return false;
	}

	public bool Equals(OpCode opcode)
	{
		if (op1 == opcode.op1)
		{
			return op2 == opcode.op2;
		}
		return false;
	}

	public static bool operator ==(OpCode one, OpCode other)
	{
		if (one.op1 == other.op1)
		{
			return one.op2 == other.op2;
		}
		return false;
	}

	public static bool operator !=(OpCode one, OpCode other)
	{
		if (one.op1 == other.op1)
		{
			return one.op2 != other.op2;
		}
		return true;
	}

	public override string ToString()
	{
		return Name;
	}
}


internal static class OpCodeNames
{
	internal static readonly string[] names;

	static OpCodeNames()
	{
		byte[] array = new byte[1790]
		{
			3, 110, 111, 112, 5, 98, 114, 101, 97, 107,
			7, 108, 100, 97, 114, 103, 46, 48, 7, 108,
			100, 97, 114, 103, 46, 49, 7, 108, 100, 97,
			114, 103, 46, 50, 7, 108, 100, 97, 114, 103,
			46, 51, 7, 108, 100, 108, 111, 99, 46, 48,
			7, 108, 100, 108, 111, 99, 46, 49, 7, 108,
			100, 108, 111, 99, 46, 50, 7, 108, 100, 108,
			111, 99, 46, 51, 7, 115, 116, 108, 111, 99,
			46, 48, 7, 115, 116, 108, 111, 99, 46, 49,
			7, 115, 116, 108, 111, 99, 46, 50, 7, 115,
			116, 108, 111, 99, 46, 51, 7, 108, 100, 97,
			114, 103, 46, 115, 8, 108, 100, 97, 114, 103,
			97, 46, 115, 7, 115, 116, 97, 114, 103, 46,
			115, 7, 108, 100, 108, 111, 99, 46, 115, 8,
			108, 100, 108, 111, 99, 97, 46, 115, 7, 115,
			116, 108, 111, 99, 46, 115, 6, 108, 100, 110,
			117, 108, 108, 9, 108, 100, 99, 46, 105, 52,
			46, 109, 49, 8, 108, 100, 99, 46, 105, 52,
			46, 48, 8, 108, 100, 99, 46, 105, 52, 46,
			49, 8, 108, 100, 99, 46, 105, 52, 46, 50,
			8, 108, 100, 99, 46, 105, 52, 46, 51, 8,
			108, 100, 99, 46, 105, 52, 46, 52, 8, 108,
			100, 99, 46, 105, 52, 46, 53, 8, 108, 100,
			99, 46, 105, 52, 46, 54, 8, 108, 100, 99,
			46, 105, 52, 46, 55, 8, 108, 100, 99, 46,
			105, 52, 46, 56, 8, 108, 100, 99, 46, 105,
			52, 46, 115, 6, 108, 100, 99, 46, 105, 52,
			6, 108, 100, 99, 46, 105, 56, 6, 108, 100,
			99, 46, 114, 52, 6, 108, 100, 99, 46, 114,
			56, 3, 100, 117, 112, 3, 112, 111, 112, 3,
			106, 109, 112, 4, 99, 97, 108, 108, 5, 99,
			97, 108, 108, 105, 3, 114, 101, 116, 4, 98,
			114, 46, 115, 9, 98, 114, 102, 97, 108, 115,
			101, 46, 115, 8, 98, 114, 116, 114, 117, 101,
			46, 115, 5, 98, 101, 113, 46, 115, 5, 98,
			103, 101, 46, 115, 5, 98, 103, 116, 46, 115,
			5, 98, 108, 101, 46, 115, 5, 98, 108, 116,
			46, 115, 8, 98, 110, 101, 46, 117, 110, 46,
			115, 8, 98, 103, 101, 46, 117, 110, 46, 115,
			8, 98, 103, 116, 46, 117, 110, 46, 115, 8,
			98, 108, 101, 46, 117, 110, 46, 115, 8, 98,
			108, 116, 46, 117, 110, 46, 115, 2, 98, 114,
			7, 98, 114, 102, 97, 108, 115, 101, 6, 98,
			114, 116, 114, 117, 101, 3, 98, 101, 113, 3,
			98, 103, 101, 3, 98, 103, 116, 3, 98, 108,
			101, 3, 98, 108, 116, 6, 98, 110, 101, 46,
			117, 110, 6, 98, 103, 101, 46, 117, 110, 6,
			98, 103, 116, 46, 117, 110, 6, 98, 108, 101,
			46, 117, 110, 6, 98, 108, 116, 46, 117, 110,
			6, 115, 119, 105, 116, 99, 104, 8, 108, 100,
			105, 110, 100, 46, 105, 49, 8, 108, 100, 105,
			110, 100, 46, 117, 49, 8, 108, 100, 105, 110,
			100, 46, 105, 50, 8, 108, 100, 105, 110, 100,
			46, 117, 50, 8, 108, 100, 105, 110, 100, 46,
			105, 52, 8, 108, 100, 105, 110, 100, 46, 117,
			52, 8, 108, 100, 105, 110, 100, 46, 105, 56,
			7, 108, 100, 105, 110, 100, 46, 105, 8, 108,
			100, 105, 110, 100, 46, 114, 52, 8, 108, 100,
			105, 110, 100, 46, 114, 56, 9, 108, 100, 105,
			110, 100, 46, 114, 101, 102, 9, 115, 116, 105,
			110, 100, 46, 114, 101, 102, 8, 115, 116, 105,
			110, 100, 46, 105, 49, 8, 115, 116, 105, 110,
			100, 46, 105, 50, 8, 115, 116, 105, 110, 100,
			46, 105, 52, 8, 115, 116, 105, 110, 100, 46,
			105, 56, 8, 115, 116, 105, 110, 100, 46, 114,
			52, 8, 115, 116, 105, 110, 100, 46, 114, 56,
			3, 97, 100, 100, 3, 115, 117, 98, 3, 109,
			117, 108, 3, 100, 105, 118, 6, 100, 105, 118,
			46, 117, 110, 3, 114, 101, 109, 6, 114, 101,
			109, 46, 117, 110, 3, 97, 110, 100, 2, 111,
			114, 3, 120, 111, 114, 3, 115, 104, 108, 3,
			115, 104, 114, 6, 115, 104, 114, 46, 117, 110,
			3, 110, 101, 103, 3, 110, 111, 116, 7, 99,
			111, 110, 118, 46, 105, 49, 7, 99, 111, 110,
			118, 46, 105, 50, 7, 99, 111, 110, 118, 46,
			105, 52, 7, 99, 111, 110, 118, 46, 105, 56,
			7, 99, 111, 110, 118, 46, 114, 52, 7, 99,
			111, 110, 118, 46, 114, 56, 7, 99, 111, 110,
			118, 46, 117, 52, 7, 99, 111, 110, 118, 46,
			117, 56, 8, 99, 97, 108, 108, 118, 105, 114,
			116, 5, 99, 112, 111, 98, 106, 5, 108, 100,
			111, 98, 106, 5, 108, 100, 115, 116, 114, 6,
			110, 101, 119, 111, 98, 106, 9, 99, 97, 115,
			116, 99, 108, 97, 115, 115, 6, 105, 115, 105,
			110, 115, 116, 9, 99, 111, 110, 118, 46, 114,
			46, 117, 110, 5, 117, 110, 98, 111, 120, 5,
			116, 104, 114, 111, 119, 5, 108, 100, 102, 108,
			100, 6, 108, 100, 102, 108, 100, 97, 5, 115,
			116, 102, 108, 100, 6, 108, 100, 115, 102, 108,
			100, 7, 108, 100, 115, 102, 108, 100, 97, 6,
			115, 116, 115, 102, 108, 100, 5, 115, 116, 111,
			98, 106, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 49, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 105, 50, 46,
			117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 52, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 105, 56, 46,
			117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 117, 49, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 117, 50, 46,
			117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 117, 52, 46, 117, 110, 14, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 117, 56, 46,
			117, 110, 13, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 46, 117, 110, 13, 99, 111, 110,
			118, 46, 111, 118, 102, 46, 117, 46, 117, 110,
			3, 98, 111, 120, 6, 110, 101, 119, 97, 114,
			114, 5, 108, 100, 108, 101, 110, 7, 108, 100,
			101, 108, 101, 109, 97, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 49, 9, 108, 100, 101, 108,
			101, 109, 46, 117, 49, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 50, 9, 108, 100, 101, 108,
			101, 109, 46, 117, 50, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 52, 9, 108, 100, 101, 108,
			101, 109, 46, 117, 52, 9, 108, 100, 101, 108,
			101, 109, 46, 105, 56, 8, 108, 100, 101, 108,
			101, 109, 46, 105, 9, 108, 100, 101, 108, 101,
			109, 46, 114, 52, 9, 108, 100, 101, 108, 101,
			109, 46, 114, 56, 10, 108, 100, 101, 108, 101,
			109, 46, 114, 101, 102, 8, 115, 116, 101, 108,
			101, 109, 46, 105, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 49, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 50, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 52, 9, 115, 116, 101, 108, 101,
			109, 46, 105, 56, 9, 115, 116, 101, 108, 101,
			109, 46, 114, 52, 9, 115, 116, 101, 108, 101,
			109, 46, 114, 56, 10, 115, 116, 101, 108, 101,
			109, 46, 114, 101, 102, 10, 108, 100, 101, 108,
			101, 109, 46, 97, 110, 121, 10, 115, 116, 101,
			108, 101, 109, 46, 97, 110, 121, 9, 117, 110,
			98, 111, 120, 46, 97, 110, 121, 11, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 105, 49, 11,
			99, 111, 110, 118, 46, 111, 118, 102, 46, 117,
			49, 11, 99, 111, 110, 118, 46, 111, 118, 102,
			46, 105, 50, 11, 99, 111, 110, 118, 46, 111,
			118, 102, 46, 117, 50, 11, 99, 111, 110, 118,
			46, 111, 118, 102, 46, 105, 52, 11, 99, 111,
			110, 118, 46, 111, 118, 102, 46, 117, 52, 11,
			99, 111, 110, 118, 46, 111, 118, 102, 46, 105,
			56, 11, 99, 111, 110, 118, 46, 111, 118, 102,
			46, 117, 56, 9, 114, 101, 102, 97, 110, 121,
			118, 97, 108, 8, 99, 107, 102, 105, 110, 105,
			116, 101, 8, 109, 107, 114, 101, 102, 97, 110,
			121, 7, 108, 100, 116, 111, 107, 101, 110, 7,
			99, 111, 110, 118, 46, 117, 50, 7, 99, 111,
			110, 118, 46, 117, 49, 6, 99, 111, 110, 118,
			46, 105, 10, 99, 111, 110, 118, 46, 111, 118,
			102, 46, 105, 10, 99, 111, 110, 118, 46, 111,
			118, 102, 46, 117, 7, 97, 100, 100, 46, 111,
			118, 102, 10, 97, 100, 100, 46, 111, 118, 102,
			46, 117, 110, 7, 109, 117, 108, 46, 111, 118,
			102, 10, 109, 117, 108, 46, 111, 118, 102, 46,
			117, 110, 7, 115, 117, 98, 46, 111, 118, 102,
			10, 115, 117, 98, 46, 111, 118, 102, 46, 117,
			110, 10, 101, 110, 100, 102, 105, 110, 97, 108,
			108, 121, 5, 108, 101, 97, 118, 101, 7, 108,
			101, 97, 118, 101, 46, 115, 7, 115, 116, 105,
			110, 100, 46, 105, 6, 99, 111, 110, 118, 46,
			117, 7, 97, 114, 103, 108, 105, 115, 116, 3,
			99, 101, 113, 3, 99, 103, 116, 6, 99, 103,
			116, 46, 117, 110, 3, 99, 108, 116, 6, 99,
			108, 116, 46, 117, 110, 5, 108, 100, 102, 116,
			110, 9, 108, 100, 118, 105, 114, 116, 102, 116,
			110, 5, 108, 100, 97, 114, 103, 6, 108, 100,
			97, 114, 103, 97, 5, 115, 116, 97, 114, 103,
			5, 108, 100, 108, 111, 99, 6, 108, 100, 108,
			111, 99, 97, 5, 115, 116, 108, 111, 99, 8,
			108, 111, 99, 97, 108, 108, 111, 99, 9, 101,
			110, 100, 102, 105, 108, 116, 101, 114, 10, 117,
			110, 97, 108, 105, 103, 110, 101, 100, 46, 9,
			118, 111, 108, 97, 116, 105, 108, 101, 46, 5,
			116, 97, 105, 108, 46, 7, 105, 110, 105, 116,
			111, 98, 106, 12, 99, 111, 110, 115, 116, 114,
			97, 105, 110, 101, 100, 46, 5, 99, 112, 98,
			108, 107, 7, 105, 110, 105, 116, 98, 108, 107,
			3, 110, 111, 46, 7, 114, 101, 116, 104, 114,
			111, 119, 6, 115, 105, 122, 101, 111, 102, 10,
			114, 101, 102, 97, 110, 121, 116, 121, 112, 101,
			9, 114, 101, 97, 100, 111, 110, 108, 121, 46
		};
		names = new string[219];
		int i = 0;
		int num = 0;
		for (; i < names.Length; i++)
		{
			char[] array2 = new char[array[num++]];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = (char)array[num++];
			}
			names[i] = new string(array2);
		}
	}
}


using Mono.Cecil.Cil;

internal static class OpCodes
{
	internal static readonly OpCode[] OneByteOpCode = new OpCode[225];

	internal static readonly OpCode[] TwoBytesOpCode = new OpCode[31];

	public static readonly OpCode Nop = new OpCode(83886335, 318768389);

	public static readonly OpCode Break = new OpCode(16843263, 318768389);

	public static readonly OpCode Ldarg_0 = new OpCode(84017919, 335545601);

	public static readonly OpCode Ldarg_1 = new OpCode(84083711, 335545601);

	public static readonly OpCode Ldarg_2 = new OpCode(84149503, 335545601);

	public static readonly OpCode Ldarg_3 = new OpCode(84215295, 335545601);

	public static readonly OpCode Ldloc_0 = new OpCode(84281087, 335545601);

	public static readonly OpCode Ldloc_1 = new OpCode(84346879, 335545601);

	public static readonly OpCode Ldloc_2 = new OpCode(84412671, 335545601);

	public static readonly OpCode Ldloc_3 = new OpCode(84478463, 335545601);

	public static readonly OpCode Stloc_0 = new OpCode(84544255, 318833921);

	public static readonly OpCode Stloc_1 = new OpCode(84610047, 318833921);

	public static readonly OpCode Stloc_2 = new OpCode(84675839, 318833921);

	public static readonly OpCode Stloc_3 = new OpCode(84741631, 318833921);

	public static readonly OpCode Ldarg_S = new OpCode(84807423, 335549185);

	public static readonly OpCode Ldarga_S = new OpCode(84873215, 369103617);

	public static readonly OpCode Starg_S = new OpCode(84939007, 318837505);

	public static readonly OpCode Ldloc_S = new OpCode(85004799, 335548929);

	public static readonly OpCode Ldloca_S = new OpCode(85070591, 369103361);

	public static readonly OpCode Stloc_S = new OpCode(85136383, 318837249);

	public static readonly OpCode Ldnull = new OpCode(85202175, 436208901);

	public static readonly OpCode Ldc_I4_M1 = new OpCode(85267967, 369100033);

	public static readonly OpCode Ldc_I4_0 = new OpCode(85333759, 369100033);

	public static readonly OpCode Ldc_I4_1 = new OpCode(85399551, 369100033);

	public static readonly OpCode Ldc_I4_2 = new OpCode(85465343, 369100033);

	public static readonly OpCode Ldc_I4_3 = new OpCode(85531135, 369100033);

	public static readonly OpCode Ldc_I4_4 = new OpCode(85596927, 369100033);

	public static readonly OpCode Ldc_I4_5 = new OpCode(85662719, 369100033);

	public static readonly OpCode Ldc_I4_6 = new OpCode(85728511, 369100033);

	public static readonly OpCode Ldc_I4_7 = new OpCode(85794303, 369100033);

	public static readonly OpCode Ldc_I4_8 = new OpCode(85860095, 369100033);

	public static readonly OpCode Ldc_I4_S = new OpCode(85925887, 369102849);

	public static readonly OpCode Ldc_I4 = new OpCode(85991679, 369099269);

	public static readonly OpCode Ldc_I8 = new OpCode(86057471, 385876741);

	public static readonly OpCode Ldc_R4 = new OpCode(86123263, 402657541);

	public static readonly OpCode Ldc_R8 = new OpCode(86189055, 419432197);

	public static readonly OpCode Dup = new OpCode(86255103, 352388357);

	public static readonly OpCode Pop = new OpCode(86320895, 318833925);

	public static readonly OpCode Jmp = new OpCode(36055039, 318768133);

	public static readonly OpCode Call = new OpCode(36120831, 471532549);

	public static readonly OpCode Calli = new OpCode(36186623, 471533573);

	public static readonly OpCode Ret = new OpCode(120138495, 320537861);

	public static readonly OpCode Br_S = new OpCode(2763775, 318770945);

	public static readonly OpCode Brfalse_S = new OpCode(53161215, 318967553);

	public static readonly OpCode Brtrue_S = new OpCode(53227007, 318967553);

	public static readonly OpCode Beq_S = new OpCode(53292799, 318902017);

	public static readonly OpCode Bge_S = new OpCode(53358591, 318902017);

	public static readonly OpCode Bgt_S = new OpCode(53424383, 318902017);

	public static readonly OpCode Ble_S = new OpCode(53490175, 318902017);

	public static readonly OpCode Blt_S = new OpCode(53555967, 318902017);

	public static readonly OpCode Bne_Un_S = new OpCode(53621759, 318902017);

	public static readonly OpCode Bge_Un_S = new OpCode(53687551, 318902017);

	public static readonly OpCode Bgt_Un_S = new OpCode(53753343, 318902017);

	public static readonly OpCode Ble_Un_S = new OpCode(53819135, 318902017);

	public static readonly OpCode Blt_Un_S = new OpCode(53884927, 318902017);

	public static readonly OpCode Br = new OpCode(3619071, 318767109);

	public static readonly OpCode Brfalse = new OpCode(54016511, 318963717);

	public static readonly OpCode Brtrue = new OpCode(54082303, 318963717);

	public static readonly OpCode Beq = new OpCode(54148095, 318898177);

	public static readonly OpCode Bge = new OpCode(54213887, 318898177);

	public static readonly OpCode Bgt = new OpCode(54279679, 318898177);

	public static readonly OpCode Ble = new OpCode(54345471, 318898177);

	public static readonly OpCode Blt = new OpCode(54411263, 318898177);

	public static readonly OpCode Bne_Un = new OpCode(54477055, 318898177);

	public static readonly OpCode Bge_Un = new OpCode(54542847, 318898177);

	public static readonly OpCode Bgt_Un = new OpCode(54608639, 318898177);

	public static readonly OpCode Ble_Un = new OpCode(54674431, 318898177);

	public static readonly OpCode Blt_Un = new OpCode(54740223, 318898177);

	public static readonly OpCode Switch = new OpCode(54806015, 318966277);

	public static readonly OpCode Ldind_I1 = new OpCode(88426239, 369296645);

	public static readonly OpCode Ldind_U1 = new OpCode(88492031, 369296645);

	public static readonly OpCode Ldind_I2 = new OpCode(88557823, 369296645);

	public static readonly OpCode Ldind_U2 = new OpCode(88623615, 369296645);

	public static readonly OpCode Ldind_I4 = new OpCode(88689407, 369296645);

	public static readonly OpCode Ldind_U4 = new OpCode(88755199, 369296645);

	public static readonly OpCode Ldind_I8 = new OpCode(88820991, 386073861);

	public static readonly OpCode Ldind_I = new OpCode(88886783, 369296645);

	public static readonly OpCode Ldind_R4 = new OpCode(88952575, 402851077);

	public static readonly OpCode Ldind_R8 = new OpCode(89018367, 419628293);

	public static readonly OpCode Ldind_Ref = new OpCode(89084159, 436405509);

	public static readonly OpCode Stind_Ref = new OpCode(89149951, 319096069);

	public static readonly OpCode Stind_I1 = new OpCode(89215743, 319096069);

	public static readonly OpCode Stind_I2 = new OpCode(89281535, 319096069);

	public static readonly OpCode Stind_I4 = new OpCode(89347327, 319096069);

	public static readonly OpCode Stind_I8 = new OpCode(89413119, 319161605);

	public static readonly OpCode Stind_R4 = new OpCode(89478911, 319292677);

	public static readonly OpCode Stind_R8 = new OpCode(89544703, 319358213);

	public static readonly OpCode Add = new OpCode(89610495, 335676677);

	public static readonly OpCode Sub = new OpCode(89676287, 335676677);

	public static readonly OpCode Mul = new OpCode(89742079, 335676677);

	public static readonly OpCode Div = new OpCode(89807871, 335676677);

	public static readonly OpCode Div_Un = new OpCode(89873663, 335676677);

	public static readonly OpCode Rem = new OpCode(89939455, 335676677);

	public static readonly OpCode Rem_Un = new OpCode(90005247, 335676677);

	public static readonly OpCode And = new OpCode(90071039, 335676677);

	public static readonly OpCode Or = new OpCode(90136831, 335676677);

	public static readonly OpCode Xor = new OpCode(90202623, 335676677);

	public static readonly OpCode Shl = new OpCode(90268415, 335676677);

	public static readonly OpCode Shr = new OpCode(90334207, 335676677);

	public static readonly OpCode Shr_Un = new OpCode(90399999, 335676677);

	public static readonly OpCode Neg = new OpCode(90465791, 335611141);

	public static readonly OpCode Not = new OpCode(90531583, 335611141);

	public static readonly OpCode Conv_I1 = new OpCode(90597375, 369165573);

	public static readonly OpCode Conv_I2 = new OpCode(90663167, 369165573);

	public static readonly OpCode Conv_I4 = new OpCode(90728959, 369165573);

	public static readonly OpCode Conv_I8 = new OpCode(90794751, 385942789);

	public static readonly OpCode Conv_R4 = new OpCode(90860543, 402720005);

	public static readonly OpCode Conv_R8 = new OpCode(90926335, 419497221);

	public static readonly OpCode Conv_U4 = new OpCode(90992127, 369165573);

	public static readonly OpCode Conv_U8 = new OpCode(91057919, 385942789);

	public static readonly OpCode Callvirt = new OpCode(40792063, 471532547);

	public static readonly OpCode Cpobj = new OpCode(91189503, 319097859);

	public static readonly OpCode Ldobj = new OpCode(91255295, 335744003);

	public static readonly OpCode Ldstr = new OpCode(91321087, 436209923);

	public static readonly OpCode Newobj = new OpCode(41055231, 437978115);

	public static readonly OpCode Castclass = new OpCode(91452671, 436866051);

	public static readonly OpCode Isinst = new OpCode(91518463, 369757187);

	public static readonly OpCode Conv_R_Un = new OpCode(91584255, 419497221);

	public static readonly OpCode Unbox = new OpCode(91650559, 369757189);

	public static readonly OpCode Throw = new OpCode(142047999, 319423747);

	public static readonly OpCode Ldfld = new OpCode(91782143, 336199939);

	public static readonly OpCode Ldflda = new OpCode(91847935, 369754371);

	public static readonly OpCode Stfld = new OpCode(91913727, 319488259);

	public static readonly OpCode Ldsfld = new OpCode(91979519, 335544579);

	public static readonly OpCode Ldsflda = new OpCode(92045311, 369099011);

	public static readonly OpCode Stsfld = new OpCode(92111103, 318832899);

	public static readonly OpCode Stobj = new OpCode(92176895, 319032323);

	public static readonly OpCode Conv_Ovf_I1_Un = new OpCode(92242687, 369165573);

	public static readonly OpCode Conv_Ovf_I2_Un = new OpCode(92308479, 369165573);

	public static readonly OpCode Conv_Ovf_I4_Un = new OpCode(92374271, 369165573);

	public static readonly OpCode Conv_Ovf_I8_Un = new OpCode(92440063, 385942789);

	public static readonly OpCode Conv_Ovf_U1_Un = new OpCode(92505855, 369165573);

	public static readonly OpCode Conv_Ovf_U2_Un = new OpCode(92571647, 369165573);

	public static readonly OpCode Conv_Ovf_U4_Un = new OpCode(92637439, 369165573);

	public static readonly OpCode Conv_Ovf_U8_Un = new OpCode(92703231, 385942789);

	public static readonly OpCode Conv_Ovf_I_Un = new OpCode(92769023, 369165573);

	public static readonly OpCode Conv_Ovf_U_Un = new OpCode(92834815, 369165573);

	public static readonly OpCode Box = new OpCode(92900607, 436276229);

	public static readonly OpCode Newarr = new OpCode(92966399, 436407299);

	public static readonly OpCode Ldlen = new OpCode(93032191, 369755395);

	public static readonly OpCode Ldelema = new OpCode(93097983, 369888259);

	public static readonly OpCode Ldelem_I1 = new OpCode(93163775, 369886467);

	public static readonly OpCode Ldelem_U1 = new OpCode(93229567, 369886467);

	public static readonly OpCode Ldelem_I2 = new OpCode(93295359, 369886467);

	public static readonly OpCode Ldelem_U2 = new OpCode(93361151, 369886467);

	public static readonly OpCode Ldelem_I4 = new OpCode(93426943, 369886467);

	public static readonly OpCode Ldelem_U4 = new OpCode(93492735, 369886467);

	public static readonly OpCode Ldelem_I8 = new OpCode(93558527, 386663683);

	public static readonly OpCode Ldelem_I = new OpCode(93624319, 369886467);

	public static readonly OpCode Ldelem_R4 = new OpCode(93690111, 403440899);

	public static readonly OpCode Ldelem_R8 = new OpCode(93755903, 420218115);

	public static readonly OpCode Ldelem_Ref = new OpCode(93821695, 436995331);

	public static readonly OpCode Stelem_I = new OpCode(93887487, 319620355);

	public static readonly OpCode Stelem_I1 = new OpCode(93953279, 319620355);

	public static readonly OpCode Stelem_I2 = new OpCode(94019071, 319620355);

	public static readonly OpCode Stelem_I4 = new OpCode(94084863, 319620355);

	public static readonly OpCode Stelem_I8 = new OpCode(94150655, 319685891);

	public static readonly OpCode Stelem_R4 = new OpCode(94216447, 319751427);

	public static readonly OpCode Stelem_R8 = new OpCode(94282239, 319816963);

	public static readonly OpCode Stelem_Ref = new OpCode(94348031, 319882499);

	public static readonly OpCode Ldelem_Any = new OpCode(94413823, 336333827);

	public static readonly OpCode Stelem_Any = new OpCode(94479615, 319884291);

	public static readonly OpCode Unbox_Any = new OpCode(94545407, 336202755);

	public static readonly OpCode Conv_Ovf_I1 = new OpCode(94614527, 369165573);

	public static readonly OpCode Conv_Ovf_U1 = new OpCode(94680319, 369165573);

	public static readonly OpCode Conv_Ovf_I2 = new OpCode(94746111, 369165573);

	public static readonly OpCode Conv_Ovf_U2 = new OpCode(94811903, 369165573);

	public static readonly OpCode Conv_Ovf_I4 = new OpCode(94877695, 369165573);

	public static readonly OpCode Conv_Ovf_U4 = new OpCode(94943487, 369165573);

	public static readonly OpCode Conv_Ovf_I8 = new OpCode(95009279, 385942789);

	public static readonly OpCode Conv_Ovf_U8 = new OpCode(95075071, 385942789);

	public static readonly OpCode Refanyval = new OpCode(95142655, 369167365);

	public static readonly OpCode Ckfinite = new OpCode(95208447, 419497221);

	public static readonly OpCode Mkrefany = new OpCode(95274751, 335744005);

	public static readonly OpCode Ldtoken = new OpCode(95342847, 369101573);

	public static readonly OpCode Conv_U2 = new OpCode(95408639, 369165573);

	public static readonly OpCode Conv_U1 = new OpCode(95474431, 369165573);

	public static readonly OpCode Conv_I = new OpCode(95540223, 369165573);

	public static readonly OpCode Conv_Ovf_I = new OpCode(95606015, 369165573);

	public static readonly OpCode Conv_Ovf_U = new OpCode(95671807, 369165573);

	public static readonly OpCode Add_Ovf = new OpCode(95737599, 335676677);

	public static readonly OpCode Add_Ovf_Un = new OpCode(95803391, 335676677);

	public static readonly OpCode Mul_Ovf = new OpCode(95869183, 335676677);

	public static readonly OpCode Mul_Ovf_Un = new OpCode(95934975, 335676677);

	public static readonly OpCode Sub_Ovf = new OpCode(96000767, 335676677);

	public static readonly OpCode Sub_Ovf_Un = new OpCode(96066559, 335676677);

	public static readonly OpCode Endfinally = new OpCode(129686783, 318768389);

	public static readonly OpCode Leave = new OpCode(12312063, 319946757);

	public static readonly OpCode Leave_S = new OpCode(12377855, 319950593);

	public static readonly OpCode Stind_I = new OpCode(96329727, 319096069);

	public static readonly OpCode Conv_U = new OpCode(96395519, 369165573);

	public static readonly OpCode Arglist = new OpCode(96403710, 369100037);

	public static readonly OpCode Ceq = new OpCode(96469502, 369231109);

	public static readonly OpCode Cgt = new OpCode(96535294, 369231109);

	public static readonly OpCode Cgt_Un = new OpCode(96601086, 369231109);

	public static readonly OpCode Clt = new OpCode(96666878, 369231109);

	public static readonly OpCode Clt_Un = new OpCode(96732670, 369231109);

	public static readonly OpCode Ldftn = new OpCode(96798462, 369099781);

	public static readonly OpCode Ldvirtftn = new OpCode(96864254, 369755141);

	public static readonly OpCode Ldarg = new OpCode(96930302, 335547909);

	public static readonly OpCode Ldarga = new OpCode(96996094, 369102341);

	public static readonly OpCode Starg = new OpCode(97061886, 318836229);

	public static readonly OpCode Ldloc = new OpCode(97127678, 335547653);

	public static readonly OpCode Ldloca = new OpCode(97193470, 369102085);

	public static readonly OpCode Stloc = new OpCode(97259262, 318835973);

	public static readonly OpCode Localloc = new OpCode(97325054, 369296645);

	public static readonly OpCode Endfilter = new OpCode(130945534, 318964997);

	public static readonly OpCode Unaligned = new OpCode(80679678, 318771204);

	public static readonly OpCode Volatile = new OpCode(80745470, 318768388);

	public static readonly OpCode Tail = new OpCode(80811262, 318768388);

	public static readonly OpCode Initobj = new OpCode(97654270, 318966787);

	public static readonly OpCode Constrained = new OpCode(97720062, 318770180);

	public static readonly OpCode Cpblk = new OpCode(97785854, 319227141);

	public static readonly OpCode Initblk = new OpCode(97851646, 319227141);

	public static readonly OpCode No = new OpCode(97917438, 318771204);

	public static readonly OpCode Rethrow = new OpCode(148314878, 318768387);

	public static readonly OpCode Sizeof = new OpCode(98049278, 369101829);

	public static readonly OpCode Refanytype = new OpCode(98115070, 369165573);

	public static readonly OpCode Readonly = new OpCode(98180862, 318768388);
}


using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal sealed class PortablePdbReaderProvider : ISymbolReaderProvider
{
	public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		FileStream fileStream = File.OpenRead(Mixin.GetPdbFileName(fileName));
		return GetSymbolReader(module, Disposable.Owned((Stream)fileStream), fileStream.Name);
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
	{
		Mixin.CheckModule(module);
		Mixin.CheckStream(symbolStream);
		return GetSymbolReader(module, Disposable.NotOwned(symbolStream), symbolStream.GetFileName());
	}

	private ISymbolReader GetSymbolReader(ModuleDefinition module, Disposable<Stream> symbolStream, string fileName)
	{
		uint pdb_heap_offset;
		return new PortablePdbReader(ImageReader.ReadPortablePdb(symbolStream, fileName, out pdb_heap_offset), module);
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class PortablePdbReader : ISymbolReader, IDisposable
{
	private readonly Image image;

	private readonly ModuleDefinition module;

	private readonly MetadataReader reader;

	private readonly MetadataReader debug_reader;

	private bool IsEmbedded => reader.image == debug_reader.image;

	internal PortablePdbReader(Image image, ModuleDefinition module)
	{
		this.image = image;
		this.module = module;
		reader = module.reader;
		debug_reader = new MetadataReader(image, module, reader);
	}

	public ISymbolWriterProvider GetWriterProvider()
	{
		return new PortablePdbWriterProvider();
	}

	public bool ProcessDebugHeader(ImageDebugHeader header)
	{
		if (image == module.Image)
		{
			return true;
		}
		ImageDebugHeaderEntry[] entries = header.Entries;
		foreach (ImageDebugHeaderEntry entry in entries)
		{
			if (IsMatchingEntry(image.PdbHeap, entry))
			{
				ReadModule();
				return true;
			}
		}
		return false;
	}

	private static bool IsMatchingEntry(PdbHeap heap, ImageDebugHeaderEntry entry)
	{
		if (entry.Directory.Type != ImageDebugType.CodeView)
		{
			return false;
		}
		byte[] data = entry.Data;
		if (data.Length < 24)
		{
			return false;
		}
		if (ReadInt32(data, 0) != 1396986706)
		{
			return false;
		}
		byte[] array = new byte[16];
		Buffer.BlockCopy(data, 4, array, 0, 16);
		Guid guid = new Guid(array);
		Buffer.BlockCopy(heap.Id, 0, array, 0, 16);
		Guid guid2 = new Guid(array);
		return guid == guid2;
	}

	private static int ReadInt32(byte[] bytes, int start)
	{
		return bytes[start] | (bytes[start + 1] << 8) | (bytes[start + 2] << 16) | (bytes[start + 3] << 24);
	}

	private void ReadModule()
	{
		module.custom_infos = debug_reader.GetCustomDebugInformation(module);
	}

	public MethodDebugInformation Read(MethodDefinition method)
	{
		MethodDebugInformation methodDebugInformation = new MethodDebugInformation(method);
		ReadSequencePoints(methodDebugInformation);
		ReadScope(methodDebugInformation);
		ReadStateMachineKickOffMethod(methodDebugInformation);
		ReadCustomDebugInformations(methodDebugInformation);
		return methodDebugInformation;
	}

	private void ReadSequencePoints(MethodDebugInformation method_info)
	{
		method_info.sequence_points = debug_reader.ReadSequencePoints(method_info.method);
	}

	private void ReadScope(MethodDebugInformation method_info)
	{
		method_info.scope = debug_reader.ReadScope(method_info.method);
	}

	private void ReadStateMachineKickOffMethod(MethodDebugInformation method_info)
	{
		method_info.kickoff_method = debug_reader.ReadStateMachineKickoffMethod(method_info.method);
	}

	private void ReadCustomDebugInformations(MethodDebugInformation info)
	{
		info.method.custom_infos = debug_reader.GetCustomDebugInformation(info.method);
	}

	public void Dispose()
	{
		if (!IsEmbedded)
		{
			image.Dispose();
		}
	}
}


using System;
using System.IO;
using System.IO.Compression;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal sealed class EmbeddedPortablePdbReaderProvider : ISymbolReaderProvider
{
	public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		ImageDebugHeaderEntry embeddedPortablePdbEntry = module.GetDebugHeader().GetEmbeddedPortablePdbEntry();
		if (embeddedPortablePdbEntry == null)
		{
			throw new InvalidOperationException();
		}
		return new EmbeddedPortablePdbReader((PortablePdbReader)new PortablePdbReaderProvider().GetSymbolReader(module, GetPortablePdbStream(embeddedPortablePdbEntry)));
	}

	private static Stream GetPortablePdbStream(ImageDebugHeaderEntry entry)
	{
		MemoryStream stream = new MemoryStream(entry.Data);
		BinaryStreamReader binaryStreamReader = new BinaryStreamReader(stream);
		binaryStreamReader.ReadInt32();
		MemoryStream memoryStream = new MemoryStream(binaryStreamReader.ReadInt32());
		using DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress, leaveOpen: true);
		deflateStream.CopyTo(memoryStream);
		return memoryStream;
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
	{
		throw new NotSupportedException();
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class EmbeddedPortablePdbReader : ISymbolReader, IDisposable
{
	private readonly PortablePdbReader reader;

	internal EmbeddedPortablePdbReader(PortablePdbReader reader)
	{
		if (reader == null)
		{
			throw new ArgumentNullException();
		}
		this.reader = reader;
	}

	public ISymbolWriterProvider GetWriterProvider()
	{
		return new EmbeddedPortablePdbWriterProvider();
	}

	public bool ProcessDebugHeader(ImageDebugHeader header)
	{
		return reader.ProcessDebugHeader(header);
	}

	public MethodDebugInformation Read(MethodDefinition method)
	{
		return reader.Read(method);
	}

	public void Dispose()
	{
		reader.Dispose();
	}
}


using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal sealed class PortablePdbWriterProvider : ISymbolWriterProvider
{
	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		FileStream value = File.Open(Mixin.GetPdbFileName(fileName), FileMode.OpenOrCreate, FileAccess.ReadWrite);
		return GetSymbolWriter(module, Disposable.Owned((Stream)value), Disposable.NotOwned<Stream>(null));
	}

	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
	{
		Mixin.CheckModule(module);
		Mixin.CheckStream(symbolStream);
		return GetSymbolWriter(module, Disposable.Owned((Stream)new MemoryStream()), Disposable.NotOwned(symbolStream));
	}

	private ISymbolWriter GetSymbolWriter(ModuleDefinition module, Disposable<Stream> stream, Disposable<Stream> final_stream)
	{
		MetadataBuilder metadataBuilder = new MetadataBuilder(module, this);
		ImageWriter writer = ImageWriter.CreateDebugWriter(module, metadataBuilder, stream);
		return new PortablePdbWriter(metadataBuilder, module, writer, final_stream);
	}
}


using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;

internal sealed class PortablePdbWriter : ISymbolWriter, IDisposable
{
	private readonly MetadataBuilder pdb_metadata;

	private readonly ModuleDefinition module;

	private readonly ImageWriter writer;

	private readonly Disposable<Stream> final_stream;

	private MetadataBuilder module_metadata;

	internal byte[] pdb_checksum;

	internal Guid pdb_id_guid;

	internal uint pdb_id_stamp;

	private bool IsEmbedded => writer == null;

	internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module)
	{
		this.pdb_metadata = pdb_metadata;
		this.module = module;
		module_metadata = module.metadata_builder;
		if (module_metadata != pdb_metadata)
		{
			this.pdb_metadata.metadata_builder = module_metadata;
		}
		pdb_metadata.AddCustomDebugInformations(module);
	}

	internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer, Disposable<Stream> final_stream)
		: this(pdb_metadata, module)
	{
		this.writer = writer;
		this.final_stream = final_stream;
	}

	public ISymbolReaderProvider GetReaderProvider()
	{
		return new PortablePdbReaderProvider();
	}

	public void Write(MethodDebugInformation info)
	{
		CheckMethodDebugInformationTable();
		pdb_metadata.AddMethodDebugInformation(info);
	}

	public void Write()
	{
		if (!IsEmbedded)
		{
			WritePdbFile();
			if (final_stream.value != null)
			{
				writer.BaseStream.Seek(0L, SeekOrigin.Begin);
				byte[] buffer = new byte[8192];
				CryptoService.CopyStreamChunk(writer.BaseStream, final_stream.value, buffer, (int)writer.BaseStream.Length);
			}
		}
	}

	public ImageDebugHeader GetDebugHeader()
	{
		if (IsEmbedded)
		{
			return new ImageDebugHeader();
		}
		ImageDebugDirectory imageDebugDirectory = default(ImageDebugDirectory);
		imageDebugDirectory.MajorVersion = 256;
		imageDebugDirectory.MinorVersion = 20557;
		imageDebugDirectory.Type = ImageDebugType.CodeView;
		imageDebugDirectory.TimeDateStamp = (int)pdb_id_stamp;
		ImageDebugDirectory directory = imageDebugDirectory;
		ByteBuffer byteBuffer = new ByteBuffer();
		byteBuffer.WriteUInt32(1396986706u);
		byteBuffer.WriteBytes(pdb_id_guid.ToByteArray());
		byteBuffer.WriteUInt32(1u);
		string text = writer.BaseStream.GetFileName();
		if (string.IsNullOrEmpty(text))
		{
			text = module.Assembly.Name.Name + ".pdb";
		}
		byteBuffer.WriteBytes(Encoding.UTF8.GetBytes(text));
		byteBuffer.WriteByte(0);
		byte[] array = new byte[byteBuffer.length];
		Buffer.BlockCopy(byteBuffer.buffer, 0, array, 0, byteBuffer.length);
		directory.SizeOfData = array.Length;
		ImageDebugHeaderEntry imageDebugHeaderEntry = new ImageDebugHeaderEntry(directory, array);
		imageDebugDirectory = default(ImageDebugDirectory);
		imageDebugDirectory.MajorVersion = 1;
		imageDebugDirectory.MinorVersion = 0;
		imageDebugDirectory.Type = ImageDebugType.PdbChecksum;
		imageDebugDirectory.TimeDateStamp = 0;
		ImageDebugDirectory directory2 = imageDebugDirectory;
		ByteBuffer byteBuffer2 = new ByteBuffer();
		byteBuffer2.WriteBytes(Encoding.UTF8.GetBytes("SHA256"));
		byteBuffer2.WriteByte(0);
		byteBuffer2.WriteBytes(pdb_checksum);
		byte[] array2 = new byte[byteBuffer2.length];
		Buffer.BlockCopy(byteBuffer2.buffer, 0, array2, 0, byteBuffer2.length);
		directory2.SizeOfData = array2.Length;
		ImageDebugHeaderEntry imageDebugHeaderEntry2 = new ImageDebugHeaderEntry(directory2, array2);
		return new ImageDebugHeader(new ImageDebugHeaderEntry[2] { imageDebugHeaderEntry, imageDebugHeaderEntry2 });
	}

	private void CheckMethodDebugInformationTable()
	{
		MethodDebugInformationTable table = pdb_metadata.table_heap.GetTable<MethodDebugInformationTable>(Table.MethodDebugInformation);
		if (table.length <= 0)
		{
			table.rows = new Row<uint, uint>[module_metadata.method_rid - 1];
			table.length = table.rows.Length;
		}
	}

	public void Dispose()
	{
		writer.stream.Dispose();
		final_stream.Dispose();
	}

	private void WritePdbFile()
	{
		WritePdbHeap();
		WriteTableHeap();
		writer.BuildMetadataTextMap();
		writer.WriteMetadataHeader();
		writer.WriteMetadata();
		writer.Flush();
		ComputeChecksumAndPdbId();
		WritePdbId();
	}

	private void WritePdbHeap()
	{
		PdbHeapBuffer pdb_heap = pdb_metadata.pdb_heap;
		pdb_heap.WriteBytes(20);
		pdb_heap.WriteUInt32(module_metadata.entry_point.ToUInt32());
		MetadataTable[] tables = module_metadata.table_heap.tables;
		ulong num = 0uL;
		for (int i = 0; i < tables.Length; i++)
		{
			if (tables[i] != null && tables[i].Length != 0)
			{
				num |= (ulong)(1L << i);
			}
		}
		pdb_heap.WriteUInt64(num);
		for (int j = 0; j < tables.Length; j++)
		{
			if (tables[j] != null && tables[j].Length != 0)
			{
				pdb_heap.WriteUInt32((uint)tables[j].Length);
			}
		}
	}

	private void WriteTableHeap()
	{
		pdb_metadata.table_heap.string_offsets = pdb_metadata.string_heap.WriteStrings();
		pdb_metadata.table_heap.ComputeTableInformations();
		pdb_metadata.table_heap.WriteTableHeap();
	}

	private void ComputeChecksumAndPdbId()
	{
		byte[] buffer = new byte[8192];
		writer.BaseStream.Seek(0L, SeekOrigin.Begin);
		SHA256 sHA = SHA256.Create();
		using (CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA, CryptoStreamMode.Write))
		{
			CryptoService.CopyStreamChunk(writer.BaseStream, dest_stream, buffer, (int)writer.BaseStream.Length);
		}
		pdb_checksum = sHA.Hash;
		ByteBuffer byteBuffer = new ByteBuffer(pdb_checksum);
		pdb_id_guid = new Guid(byteBuffer.ReadBytes(16));
		pdb_id_stamp = byteBuffer.ReadUInt32();
	}

	private void WritePdbId()
	{
		writer.MoveToRVA(TextSegment.PdbHeap);
		writer.WriteBytes(pdb_id_guid.ToByteArray());
		writer.WriteUInt32(pdb_id_stamp);
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class EmbeddedPortablePdbWriterProvider : ISymbolWriterProvider
{
	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		MemoryStream memoryStream = new MemoryStream();
		PortablePdbWriter writer = (PortablePdbWriter)new PortablePdbWriterProvider().GetSymbolWriter(module, memoryStream);
		return new EmbeddedPortablePdbWriter(memoryStream, writer);
	}

	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
	{
		throw new NotSupportedException();
	}
}


using System;
using System.IO;
using System.IO.Compression;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal sealed class EmbeddedPortablePdbWriter : ISymbolWriter, IDisposable
{
	private readonly Stream stream;

	private readonly PortablePdbWriter writer;

	internal EmbeddedPortablePdbWriter(Stream stream, PortablePdbWriter writer)
	{
		this.stream = stream;
		this.writer = writer;
	}

	public ISymbolReaderProvider GetReaderProvider()
	{
		return new EmbeddedPortablePdbReaderProvider();
	}

	public void Write(MethodDebugInformation info)
	{
		writer.Write(info);
	}

	public ImageDebugHeader GetDebugHeader()
	{
		ImageDebugHeader debugHeader = writer.GetDebugHeader();
		ImageDebugDirectory imageDebugDirectory = default(ImageDebugDirectory);
		imageDebugDirectory.Type = ImageDebugType.EmbeddedPortablePdb;
		imageDebugDirectory.MajorVersion = 256;
		imageDebugDirectory.MinorVersion = 256;
		ImageDebugDirectory directory = imageDebugDirectory;
		MemoryStream memoryStream = new MemoryStream();
		BinaryStreamWriter binaryStreamWriter = new BinaryStreamWriter(memoryStream);
		binaryStreamWriter.WriteByte(77);
		binaryStreamWriter.WriteByte(80);
		binaryStreamWriter.WriteByte(68);
		binaryStreamWriter.WriteByte(66);
		binaryStreamWriter.WriteInt32((int)stream.Length);
		stream.Position = 0L;
		using (DeflateStream destination = new DeflateStream(memoryStream, CompressionMode.Compress, leaveOpen: true))
		{
			stream.CopyTo(destination);
		}
		directory.SizeOfData = (int)memoryStream.Length;
		ImageDebugHeaderEntry[] array = new ImageDebugHeaderEntry[debugHeader.Entries.Length + 1];
		for (int i = 0; i < debugHeader.Entries.Length; i++)
		{
			array[i] = debugHeader.Entries[i];
		}
		array[^1] = new ImageDebugHeaderEntry(directory, memoryStream.ToArray());
		return new ImageDebugHeader(array);
	}

	public void Write()
	{
		writer.Write();
	}

	public void Dispose()
	{
		writer.Dispose();
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil.Cil;

internal static class PdbGuidMapping
{
	private static readonly Dictionary<Guid, DocumentLanguage> guid_language;

	private static readonly Dictionary<DocumentLanguage, Guid> language_guid;

	private static readonly Guid type_text;

	private static readonly Guid hash_md5;

	private static readonly Guid hash_sha1;

	private static readonly Guid hash_sha256;

	private static readonly Guid vendor_ms;

	static PdbGuidMapping()
	{
		guid_language = new Dictionary<Guid, DocumentLanguage>();
		language_guid = new Dictionary<DocumentLanguage, Guid>();
		type_text = new Guid("5a869d0b-6611-11d3-bd2a-0000f80849bd");
		hash_md5 = new Guid("406ea660-64cf-4c82-b6f0-42d48172a799");
		hash_sha1 = new Guid("ff1816ec-aa5e-4d10-87f7-6f4963833460");
		hash_sha256 = new Guid("8829d00f-11b8-4213-878b-770e8597ac16");
		vendor_ms = new Guid("994b45c4-e6e9-11d2-903f-00c04fa302a1");
		AddMapping(DocumentLanguage.C, new Guid("63a08714-fc37-11d2-904c-00c04fa302a1"));
		AddMapping(DocumentLanguage.Cpp, new Guid("3a12d0b7-c26c-11d0-b442-00a0244a1dd2"));
		AddMapping(DocumentLanguage.CSharp, new Guid("3f5162f8-07c6-11d3-9053-00c04fa302a1"));
		AddMapping(DocumentLanguage.Basic, new Guid("3a12d0b8-c26c-11d0-b442-00a0244a1dd2"));
		AddMapping(DocumentLanguage.Java, new Guid("3a12d0b4-c26c-11d0-b442-00a0244a1dd2"));
		AddMapping(DocumentLanguage.Cobol, new Guid("af046cd1-d0e1-11d2-977c-00a0c9b4d50c"));
		AddMapping(DocumentLanguage.Pascal, new Guid("af046cd2-d0e1-11d2-977c-00a0c9b4d50c"));
		AddMapping(DocumentLanguage.Cil, new Guid("af046cd3-d0e1-11d2-977c-00a0c9b4d50c"));
		AddMapping(DocumentLanguage.JScript, new Guid("3a12d0b6-c26c-11d0-b442-00a0244a1dd2"));
		AddMapping(DocumentLanguage.Smc, new Guid("0d9b9f7b-6611-11d3-bd2a-0000f80849bd"));
		AddMapping(DocumentLanguage.MCpp, new Guid("4b35fde8-07c6-11d3-9053-00c04fa302a1"));
		AddMapping(DocumentLanguage.FSharp, new Guid("ab4f38c9-b6e6-43ba-be3b-58080b2ccce3"));
	}

	private static void AddMapping(DocumentLanguage language, Guid guid)
	{
		guid_language.Add(guid, language);
		language_guid.Add(language, guid);
	}

	public static DocumentType ToType(this Guid guid)
	{
		if (guid == type_text)
		{
			return DocumentType.Text;
		}
		return DocumentType.Other;
	}

	public static Guid ToGuid(this DocumentType type)
	{
		if (type == DocumentType.Text)
		{
			return type_text;
		}
		return default(Guid);
	}

	public static DocumentHashAlgorithm ToHashAlgorithm(this Guid guid)
	{
		if (guid == hash_md5)
		{
			return DocumentHashAlgorithm.MD5;
		}
		if (guid == hash_sha1)
		{
			return DocumentHashAlgorithm.SHA1;
		}
		if (guid == hash_sha256)
		{
			return DocumentHashAlgorithm.SHA256;
		}
		return DocumentHashAlgorithm.None;
	}

	public static Guid ToGuid(this DocumentHashAlgorithm hash_algo)
	{
		return hash_algo switch
		{
			DocumentHashAlgorithm.MD5 => hash_md5, 
			DocumentHashAlgorithm.SHA1 => hash_sha1, 
			DocumentHashAlgorithm.SHA256 => hash_sha256, 
			_ => default(Guid), 
		};
	}

	public static DocumentLanguage ToLanguage(this Guid guid)
	{
		if (!guid_language.TryGetValue(guid, out var value))
		{
			return DocumentLanguage.Other;
		}
		return value;
	}

	public static Guid ToGuid(this DocumentLanguage language)
	{
		if (!language_guid.TryGetValue(language, out var value))
		{
			return default(Guid);
		}
		return value;
	}

	public static DocumentLanguageVendor ToVendor(this Guid guid)
	{
		if (guid == vendor_ms)
		{
			return DocumentLanguageVendor.Microsoft;
		}
		return DocumentLanguageVendor.Other;
	}

	public static Guid ToGuid(this DocumentLanguageVendor vendor)
	{
		if (vendor == DocumentLanguageVendor.Microsoft)
		{
			return vendor_ms;
		}
		return default(Guid);
	}
}


using System;
using Mono.Cecil.Cil;

internal sealed class SequencePoint
{
	internal InstructionOffset offset;

	private Document document;

	private int start_line;

	private int start_column;

	private int end_line;

	private int end_column;

	public int Offset => offset.Offset;

	public int StartLine
	{
		get
		{
			return start_line;
		}
		set
		{
			start_line = value;
		}
	}

	public int StartColumn
	{
		get
		{
			return start_column;
		}
		set
		{
			start_column = value;
		}
	}

	public int EndLine
	{
		get
		{
			return end_line;
		}
		set
		{
			end_line = value;
		}
	}

	public int EndColumn
	{
		get
		{
			return end_column;
		}
		set
		{
			end_column = value;
		}
	}

	public bool IsHidden
	{
		get
		{
			if (start_line == 16707566)
			{
				return start_line == end_line;
			}
			return false;
		}
	}

	public Document Document
	{
		get
		{
			return document;
		}
		set
		{
			document = value;
		}
	}

	internal SequencePoint(int offset, Document document)
	{
		if (document == null)
		{
			throw new ArgumentNullException("document");
		}
		this.offset = new InstructionOffset(offset);
		this.document = document;
	}

	public SequencePoint(Instruction instruction, Document document)
	{
		if (document == null)
		{
			throw new ArgumentNullException("document");
		}
		offset = new InstructionOffset(instruction);
		this.document = document;
	}
}


using Mono.Cecil.Cil;

internal struct ImageDebugDirectory
{
	public const int Size = 28;

	public int Characteristics;

	public int TimeDateStamp;

	public short MajorVersion;

	public short MinorVersion;

	public ImageDebugType Type;

	public int SizeOfData;

	public int AddressOfRawData;

	public int PointerToRawData;
}


internal enum ImageDebugType
{
	CodeView = 2,
	Deterministic = 16,
	EmbeddedPortablePdb = 17,
	PdbChecksum = 19
}


using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class ImageDebugHeader
{
	private readonly ImageDebugHeaderEntry[] entries;

	public bool HasEntries => !entries.IsNullOrEmpty();

	public ImageDebugHeaderEntry[] Entries => entries;

	public ImageDebugHeader(ImageDebugHeaderEntry[] entries)
	{
		this.entries = entries ?? Empty<ImageDebugHeaderEntry>.Array;
	}

	public ImageDebugHeader()
		: this(Empty<ImageDebugHeaderEntry>.Array)
	{
	}

	public ImageDebugHeader(ImageDebugHeaderEntry entry)
		: this(new ImageDebugHeaderEntry[1] { entry })
	{
	}
}


using Mono;
using Mono.Cecil.Cil;

internal sealed class ImageDebugHeaderEntry
{
	private ImageDebugDirectory directory;

	private readonly byte[] data;

	public ImageDebugDirectory Directory
	{
		get
		{
			return directory;
		}
		internal set
		{
			directory = value;
		}
	}

	public byte[] Data => data;

	public ImageDebugHeaderEntry(ImageDebugDirectory directory, byte[] data)
	{
		this.directory = directory;
		this.data = data ?? Empty<byte>.Array;
	}
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class ScopeDebugInformation : DebugInformation
{
	internal InstructionOffset start;

	internal InstructionOffset end;

	internal ImportDebugInformation import;

	internal Collection<ScopeDebugInformation> scopes;

	internal Collection<VariableDebugInformation> variables;

	internal Collection<ConstantDebugInformation> constants;

	public InstructionOffset Start
	{
		get
		{
			return start;
		}
		set
		{
			start = value;
		}
	}

	public InstructionOffset End
	{
		get
		{
			return end;
		}
		set
		{
			end = value;
		}
	}

	public ImportDebugInformation Import
	{
		get
		{
			return import;
		}
		set
		{
			import = value;
		}
	}

	public bool HasScopes => !scopes.IsNullOrEmpty();

	public Collection<ScopeDebugInformation> Scopes
	{
		get
		{
			if (scopes == null)
			{
				Interlocked.CompareExchange(ref scopes, new Collection<ScopeDebugInformation>(), null);
			}
			return scopes;
		}
	}

	public bool HasVariables => !variables.IsNullOrEmpty();

	public Collection<VariableDebugInformation> Variables
	{
		get
		{
			if (variables == null)
			{
				Interlocked.CompareExchange(ref variables, new Collection<VariableDebugInformation>(), null);
			}
			return variables;
		}
	}

	public bool HasConstants => !constants.IsNullOrEmpty();

	public Collection<ConstantDebugInformation> Constants
	{
		get
		{
			if (constants == null)
			{
				Interlocked.CompareExchange(ref constants, new Collection<ConstantDebugInformation>(), null);
			}
			return constants;
		}
	}

	internal ScopeDebugInformation()
	{
		token = new MetadataToken(TokenType.LocalScope);
	}

	public ScopeDebugInformation(Instruction start, Instruction end)
		: this()
	{
		if (start == null)
		{
			throw new ArgumentNullException("start");
		}
		this.start = new InstructionOffset(start);
		if (end != null)
		{
			this.end = new InstructionOffset(end);
		}
	}

	public bool TryGetName(VariableDefinition variable, out string name)
	{
		name = null;
		if (variables == null || variables.Count == 0)
		{
			return false;
		}
		for (int i = 0; i < variables.Count; i++)
		{
			if (variables[i].Index == variable.Index)
			{
				name = variables[i].Name;
				return true;
			}
		}
		return false;
	}
}


using System;
using Mono.Cecil.Cil;

internal struct InstructionOffset
{
	private readonly Instruction instruction;

	private readonly int? offset;

	public int Offset
	{
		get
		{
			if (instruction != null)
			{
				return instruction.Offset;
			}
			if (offset.HasValue)
			{
				return offset.Value;
			}
			throw new NotSupportedException();
		}
	}

	public bool IsEndOfMethod
	{
		get
		{
			if (instruction == null)
			{
				return !offset.HasValue;
			}
			return false;
		}
	}

	internal bool IsResolved
	{
		get
		{
			if (instruction == null)
			{
				return !offset.HasValue;
			}
			return true;
		}
	}

	internal Instruction ResolvedInstruction => instruction;

	public InstructionOffset(Instruction instruction)
	{
		if (instruction == null)
		{
			throw new ArgumentNullException("instruction");
		}
		this.instruction = instruction;
		offset = null;
	}

	public InstructionOffset(int offset)
	{
		instruction = null;
		this.offset = offset;
	}
}


using System;

[Flags]
internal enum VariableAttributes : ushort
{
	None = 0,
	DebuggerHidden = 1
}


using System;
using Mono.Cecil.Cil;

internal struct VariableIndex
{
	private readonly VariableDefinition variable;

	private readonly int? index;

	public int Index
	{
		get
		{
			if (variable != null)
			{
				return variable.Index;
			}
			if (index.HasValue)
			{
				return index.Value;
			}
			throw new NotSupportedException();
		}
	}

	internal bool IsResolved => variable != null;

	internal VariableDefinition ResolvedVariable => variable;

	public VariableIndex(VariableDefinition variable)
	{
		if (variable == null)
		{
			throw new ArgumentNullException("variable");
		}
		this.variable = variable;
		index = null;
	}

	public VariableIndex(int index)
	{
		variable = null;
		this.index = index;
	}
}


using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal abstract class DebugInformation : ICustomDebugInformationProvider, IMetadataTokenProvider
{
	internal MetadataToken token;

	internal Collection<CustomDebugInformation> custom_infos;

	public MetadataToken MetadataToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	public bool HasCustomDebugInformations => !custom_infos.IsNullOrEmpty();

	public Collection<CustomDebugInformation> CustomDebugInformations
	{
		get
		{
			if (custom_infos == null)
			{
				Interlocked.CompareExchange(ref custom_infos, new Collection<CustomDebugInformation>(), null);
			}
			return custom_infos;
		}
	}

	internal DebugInformation()
	{
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class VariableDebugInformation : DebugInformation
{
	private string name;

	private ushort attributes;

	internal VariableIndex index;

	public int Index => index.Index;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public VariableAttributes Attributes
	{
		get
		{
			return (VariableAttributes)attributes;
		}
		set
		{
			attributes = (ushort)value;
		}
	}

	public bool IsDebuggerHidden
	{
		get
		{
			return attributes.GetAttributes(1);
		}
		set
		{
			attributes = attributes.SetAttributes(1, value);
		}
	}

	internal VariableDebugInformation(int index, string name)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		this.index = new VariableIndex(index);
		this.name = name;
	}

	public VariableDebugInformation(VariableDefinition variable, string name)
	{
		if (variable == null)
		{
			throw new ArgumentNullException("variable");
		}
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		index = new VariableIndex(variable);
		this.name = name;
		token = new MetadataToken(TokenType.LocalVariable);
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class ConstantDebugInformation : DebugInformation
{
	private string name;

	private TypeReference constant_type;

	private object value;

	public string Name
	{
		get
		{
			return name;
		}
		set
		{
			name = value;
		}
	}

	public TypeReference ConstantType
	{
		get
		{
			return constant_type;
		}
		set
		{
			constant_type = value;
		}
	}

	public object Value
	{
		get
		{
			return value;
		}
		set
		{
			this.value = value;
		}
	}

	public ConstantDebugInformation(string name, TypeReference constant_type, object value)
	{
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		this.name = name;
		this.constant_type = constant_type;
		this.value = value;
		token = new MetadataToken(TokenType.LocalConstant);
	}
}


internal enum ImportTargetKind : byte
{
	ImportNamespace = 1,
	ImportNamespaceInAssembly,
	ImportType,
	ImportXmlNamespaceWithAlias,
	ImportAlias,
	DefineAssemblyAlias,
	DefineNamespaceAlias,
	DefineNamespaceInAssemblyAlias,
	DefineTypeAlias
}


using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class ImportTarget
{
	internal ImportTargetKind kind;

	internal string @namespace;

	internal TypeReference type;

	internal AssemblyNameReference reference;

	internal string alias;

	public string Namespace
	{
		get
		{
			return @namespace;
		}
		set
		{
			@namespace = value;
		}
	}

	public TypeReference Type
	{
		get
		{
			return type;
		}
		set
		{
			type = value;
		}
	}

	public AssemblyNameReference AssemblyReference
	{
		get
		{
			return reference;
		}
		set
		{
			reference = value;
		}
	}

	public string Alias
	{
		get
		{
			return alias;
		}
		set
		{
			alias = value;
		}
	}

	public ImportTargetKind Kind
	{
		get
		{
			return kind;
		}
		set
		{
			kind = value;
		}
	}

	public ImportTarget(ImportTargetKind kind)
	{
		this.kind = kind;
	}
}


using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class ImportDebugInformation : DebugInformation
{
	internal ImportDebugInformation parent;

	internal Collection<ImportTarget> targets;

	public bool HasTargets => !targets.IsNullOrEmpty();

	public Collection<ImportTarget> Targets
	{
		get
		{
			if (targets == null)
			{
				Interlocked.CompareExchange(ref targets, new Collection<ImportTarget>(), null);
			}
			return targets;
		}
	}

	public ImportDebugInformation Parent
	{
		get
		{
			return parent;
		}
		set
		{
			parent = value;
		}
	}

	public ImportDebugInformation()
	{
		token = new MetadataToken(TokenType.ImportScope);
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal interface ICustomDebugInformationProvider : IMetadataTokenProvider
{
	bool HasCustomDebugInformations { get; }

	Collection<CustomDebugInformation> CustomDebugInformations { get; }
}


internal enum CustomDebugInformationKind
{
	Binary,
	StateMachineScope,
	DynamicVariable,
	DefaultNamespace,
	AsyncMethodBody,
	EmbeddedSource,
	SourceLink
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal abstract class CustomDebugInformation : DebugInformation
{
	private Guid identifier;

	public Guid Identifier => identifier;

	public abstract CustomDebugInformationKind Kind { get; }

	internal CustomDebugInformation(Guid identifier)
	{
		this.identifier = identifier;
		token = new MetadataToken(TokenType.CustomDebugInformation);
	}
}


using System;
using Mono.Cecil.Cil;

internal sealed class BinaryCustomDebugInformation : CustomDebugInformation
{
	private byte[] data;

	public byte[] Data
	{
		get
		{
			return data;
		}
		set
		{
			data = value;
		}
	}

	public override CustomDebugInformationKind Kind => CustomDebugInformationKind.Binary;

	public BinaryCustomDebugInformation(Guid identifier, byte[] data)
		: base(identifier)
	{
		this.data = data;
	}
}


using System;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class AsyncMethodBodyDebugInformation : CustomDebugInformation
{
	internal InstructionOffset catch_handler;

	internal Collection<InstructionOffset> yields;

	internal Collection<InstructionOffset> resumes;

	internal Collection<MethodDefinition> resume_methods;

	public static Guid KindIdentifier = new Guid("{54FD2AC5-E925-401A-9C2A-F94F171072F8}");

	public InstructionOffset CatchHandler
	{
		get
		{
			return catch_handler;
		}
		set
		{
			catch_handler = value;
		}
	}

	public Collection<InstructionOffset> Yields
	{
		get
		{
			if (yields == null)
			{
				Interlocked.CompareExchange(ref yields, new Collection<InstructionOffset>(), null);
			}
			return yields;
		}
	}

	public Collection<InstructionOffset> Resumes
	{
		get
		{
			if (resumes == null)
			{
				Interlocked.CompareExchange(ref resumes, new Collection<InstructionOffset>(), null);
			}
			return resumes;
		}
	}

	public Collection<MethodDefinition> ResumeMethods => resume_methods ?? (resume_methods = new Collection<MethodDefinition>());

	public override CustomDebugInformationKind Kind => CustomDebugInformationKind.AsyncMethodBody;

	internal AsyncMethodBodyDebugInformation(int catchHandler)
		: base(KindIdentifier)
	{
		catch_handler = new InstructionOffset(catchHandler);
	}

	public AsyncMethodBodyDebugInformation(Instruction catchHandler)
		: base(KindIdentifier)
	{
		catch_handler = new InstructionOffset(catchHandler);
	}

	public AsyncMethodBodyDebugInformation()
		: base(KindIdentifier)
	{
		catch_handler = new InstructionOffset(-1);
	}
}


using Mono.Cecil.Cil;

internal sealed class StateMachineScope
{
	internal InstructionOffset start;

	internal InstructionOffset end;

	public InstructionOffset Start
	{
		get
		{
			return start;
		}
		set
		{
			start = value;
		}
	}

	public InstructionOffset End
	{
		get
		{
			return end;
		}
		set
		{
			end = value;
		}
	}

	internal StateMachineScope(int start, int end)
	{
		this.start = new InstructionOffset(start);
		this.end = new InstructionOffset(end);
	}

	public StateMachineScope(Instruction start, Instruction end)
	{
		this.start = new InstructionOffset(start);
		this.end = ((end != null) ? new InstructionOffset(end) : default(InstructionOffset));
	}
}


using System;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class StateMachineScopeDebugInformation : CustomDebugInformation
{
	internal Collection<StateMachineScope> scopes;

	public static Guid KindIdentifier = new Guid("{6DA9A61E-F8C7-4874-BE62-68BC5630DF71}");

	public Collection<StateMachineScope> Scopes => scopes ?? (scopes = new Collection<StateMachineScope>());

	public override CustomDebugInformationKind Kind => CustomDebugInformationKind.StateMachineScope;

	public StateMachineScopeDebugInformation()
		: base(KindIdentifier)
	{
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;

internal sealed class EmbeddedSourceDebugInformation : CustomDebugInformation
{
	internal uint index;

	internal MetadataReader debug_reader;

	internal bool resolved;

	internal byte[] content;

	internal bool compress;

	public static Guid KindIdentifier = new Guid("{0E8A571B-6926-466E-B4AD-8AB04611F5FE}");

	public byte[] Content
	{
		get
		{
			if (!resolved)
			{
				Resolve();
			}
			return content;
		}
		set
		{
			content = value;
			resolved = true;
		}
	}

	public bool Compress
	{
		get
		{
			if (!resolved)
			{
				Resolve();
			}
			return compress;
		}
		set
		{
			compress = value;
			resolved = true;
		}
	}

	public override CustomDebugInformationKind Kind => CustomDebugInformationKind.EmbeddedSource;

	internal EmbeddedSourceDebugInformation(uint index, MetadataReader debug_reader)
		: base(KindIdentifier)
	{
		this.index = index;
		this.debug_reader = debug_reader;
	}

	public EmbeddedSourceDebugInformation(byte[] content, bool compress)
		: base(KindIdentifier)
	{
		resolved = true;
		this.content = content;
		this.compress = compress;
	}

	internal byte[] ReadRawEmbeddedSourceDebugInformation()
	{
		if (debug_reader == null)
		{
			throw new InvalidOperationException();
		}
		return debug_reader.ReadRawEmbeddedSourceDebugInformation(index);
	}

	private void Resolve()
	{
		if (!resolved)
		{
			if (debug_reader == null)
			{
				throw new InvalidOperationException();
			}
			Row<byte[], bool> row = debug_reader.ReadEmbeddedSourceDebugInformation(index);
			content = row.Col1;
			compress = row.Col2;
			resolved = true;
		}
	}
}


using System;
using Mono.Cecil.Cil;

internal sealed class SourceLinkDebugInformation : CustomDebugInformation
{
	internal string content;

	public static Guid KindIdentifier = new Guid("{CC110556-A091-4D38-9FEC-25AB9A351A6A}");

	public string Content
	{
		get
		{
			return content;
		}
		set
		{
			content = value;
		}
	}

	public override CustomDebugInformationKind Kind => CustomDebugInformationKind.SourceLink;

	public SourceLinkDebugInformation(string content)
		: base(KindIdentifier)
	{
		this.content = content;
	}
}


using System;
using System.Collections.Generic;
using System.Threading;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;

internal sealed class MethodDebugInformation : DebugInformation
{
	internal MethodDefinition method;

	internal Collection<SequencePoint> sequence_points;

	internal ScopeDebugInformation scope;

	internal MethodDefinition kickoff_method;

	internal int code_size;

	internal MetadataToken local_var_token;

	public MethodDefinition Method => method;

	public bool HasSequencePoints => !sequence_points.IsNullOrEmpty();

	public Collection<SequencePoint> SequencePoints
	{
		get
		{
			if (sequence_points == null)
			{
				Interlocked.CompareExchange(ref sequence_points, new Collection<SequencePoint>(), null);
			}
			return sequence_points;
		}
	}

	public ScopeDebugInformation Scope
	{
		get
		{
			return scope;
		}
		set
		{
			scope = value;
		}
	}

	public MethodDefinition StateMachineKickOffMethod
	{
		get
		{
			return kickoff_method;
		}
		set
		{
			kickoff_method = value;
		}
	}

	internal MethodDebugInformation(MethodDefinition method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		this.method = method;
		token = new MetadataToken(TokenType.MethodDebugInformation, method.MetadataToken.RID);
	}

	public SequencePoint GetSequencePoint(Instruction instruction)
	{
		if (!HasSequencePoints)
		{
			return null;
		}
		for (int i = 0; i < sequence_points.Count; i++)
		{
			if (sequence_points[i].Offset == instruction.Offset)
			{
				return sequence_points[i];
			}
		}
		return null;
	}

	public IDictionary<Instruction, SequencePoint> GetSequencePointMapping()
	{
		Dictionary<Instruction, SequencePoint> dictionary = new Dictionary<Instruction, SequencePoint>();
		if (!HasSequencePoints || !method.HasBody)
		{
			return dictionary;
		}
		Dictionary<int, SequencePoint> dictionary2 = new Dictionary<int, SequencePoint>(sequence_points.Count);
		for (int i = 0; i < sequence_points.Count; i++)
		{
			if (!dictionary2.ContainsKey(sequence_points[i].Offset))
			{
				dictionary2.Add(sequence_points[i].Offset, sequence_points[i]);
			}
		}
		Collection<Instruction> instructions = method.Body.Instructions;
		for (int j = 0; j < instructions.Count; j++)
		{
			if (dictionary2.TryGetValue(instructions[j].Offset, out var value))
			{
				dictionary.Add(instructions[j], value);
			}
		}
		return dictionary;
	}

	public IEnumerable<ScopeDebugInformation> GetScopes()
	{
		if (scope == null)
		{
			return Empty<ScopeDebugInformation>.Array;
		}
		return GetScopes(new ScopeDebugInformation[1] { scope });
	}

	private static IEnumerable<ScopeDebugInformation> GetScopes(IList<ScopeDebugInformation> scopes)
	{
		for (int i = 0; i < scopes.Count; i++)
		{
			ScopeDebugInformation scope = scopes[i];
			yield return scope;
			if (!scope.HasScopes)
			{
				continue;
			}
			foreach (ScopeDebugInformation scope2 in GetScopes(scope.Scopes))
			{
				yield return scope2;
			}
		}
	}

	public bool TryGetName(VariableDefinition variable, out string name)
	{
		name = null;
		bool flag = false;
		string text = "";
		foreach (ScopeDebugInformation scope in GetScopes())
		{
			if (scope.TryGetName(variable, out var name2))
			{
				if (!flag)
				{
					flag = true;
					text = name2;
				}
				else if (text != name2)
				{
					return false;
				}
			}
		}
		name = text;
		return flag;
	}
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal interface ISymbolReader : IDisposable
{
	ISymbolWriterProvider GetWriterProvider();

	bool ProcessDebugHeader(ImageDebugHeader header);

	MethodDebugInformation Read(MethodDefinition method);
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal interface ISymbolReaderProvider
{
	ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);

	ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}


using System;
using System.IO;
using System.Runtime.Serialization;

[Serializable]
internal sealed class SymbolsNotFoundException : FileNotFoundException
{
	public SymbolsNotFoundException(string message)
		: base(message)
	{
	}

	private SymbolsNotFoundException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using System.Runtime.Serialization;

[Serializable]
internal sealed class SymbolsNotMatchingException : InvalidOperationException
{
	public SymbolsNotMatchingException(string message)
		: base(message)
	{
	}

	private SymbolsNotMatchingException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.PE;

internal class DefaultSymbolReaderProvider : ISymbolReaderProvider
{
	private readonly bool throw_if_no_symbol;

	public DefaultSymbolReaderProvider()
		: this(throwIfNoSymbol: true)
	{
	}

	public DefaultSymbolReaderProvider(bool throwIfNoSymbol)
	{
		throw_if_no_symbol = throwIfNoSymbol;
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
	{
		if (module.Image.HasDebugTables())
		{
			return null;
		}
		if (module.HasDebugHeader && module.GetDebugHeader().GetEmbeddedPortablePdbEntry() != null)
		{
			return new EmbeddedPortablePdbReaderProvider().GetSymbolReader(module, fileName);
		}
		if (File.Exists(Mixin.GetPdbFileName(fileName)))
		{
			if (Mixin.IsPortablePdb(Mixin.GetPdbFileName(fileName)))
			{
				return new PortablePdbReaderProvider().GetSymbolReader(module, fileName);
			}
			try
			{
				return SymbolProvider.GetReaderProvider(SymbolKind.NativePdb).GetSymbolReader(module, fileName);
			}
			catch (Exception)
			{
			}
		}
		if (File.Exists(Mixin.GetMdbFileName(fileName)))
		{
			try
			{
				return SymbolProvider.GetReaderProvider(SymbolKind.Mdb).GetSymbolReader(module, fileName);
			}
			catch (Exception)
			{
			}
		}
		if (throw_if_no_symbol)
		{
			throw new SymbolsNotFoundException($"No symbol found for file: {fileName}");
		}
		return null;
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
	{
		if (module.Image.HasDebugTables())
		{
			return null;
		}
		if (module.HasDebugHeader && module.GetDebugHeader().GetEmbeddedPortablePdbEntry() != null)
		{
			return new EmbeddedPortablePdbReaderProvider().GetSymbolReader(module, "");
		}
		Mixin.CheckStream(symbolStream);
		Mixin.CheckReadSeek(symbolStream);
		long position = symbolStream.Position;
		BinaryStreamReader binaryStreamReader = new BinaryStreamReader(symbolStream);
		int num = binaryStreamReader.ReadInt32();
		symbolStream.Position = position;
		if (num == 1112167234)
		{
			return new PortablePdbReaderProvider().GetSymbolReader(module, symbolStream);
		}
		byte[] array = binaryStreamReader.ReadBytes("Microsoft C/C++ MSF 7.00".Length);
		symbolStream.Position = position;
		bool flag = true;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] != (byte)"Microsoft C/C++ MSF 7.00"[i])
			{
				flag = false;
				break;
			}
		}
		if (flag)
		{
			try
			{
				return SymbolProvider.GetReaderProvider(SymbolKind.NativePdb).GetSymbolReader(module, symbolStream);
			}
			catch (Exception)
			{
			}
		}
		long num2 = binaryStreamReader.ReadInt64();
		symbolStream.Position = position;
		if (num2 == 5037318119232611860L)
		{
			try
			{
				return SymbolProvider.GetReaderProvider(SymbolKind.Mdb).GetSymbolReader(module, symbolStream);
			}
			catch (Exception)
			{
			}
		}
		if (throw_if_no_symbol)
		{
			throw new SymbolsNotFoundException($"No symbols found in stream");
		}
		return null;
	}
}


internal enum SymbolKind
{
	NativePdb,
	PortablePdb,
	EmbeddedPortablePdb,
	Mdb
}


using System;
using System.IO;
using System.Reflection;
using Mono.Cecil.Cil;

internal static class SymbolProvider
{
	private static AssemblyName GetSymbolAssemblyName(SymbolKind kind)
	{
		if (kind == SymbolKind.PortablePdb)
		{
			throw new ArgumentException();
		}
		string symbolNamespace = GetSymbolNamespace(kind);
		AssemblyName name = typeof(SymbolProvider).Assembly.GetName();
		AssemblyName assemblyName = new AssemblyName();
		assemblyName.Name = name.Name + "." + symbolNamespace;
		assemblyName.Version = name.Version;
		assemblyName.CultureInfo = name.CultureInfo;
		assemblyName.SetPublicKeyToken(name.GetPublicKeyToken());
		return assemblyName;
	}

	private static Type GetSymbolType(SymbolKind kind, string fullname)
	{
		Type type = Type.GetType(fullname);
		if (type != null)
		{
			return type;
		}
		AssemblyName symbolAssemblyName = GetSymbolAssemblyName(kind);
		type = Type.GetType(fullname + ", " + symbolAssemblyName.FullName);
		if (type != null)
		{
			return type;
		}
		try
		{
			Assembly assembly = Assembly.Load(symbolAssemblyName);
			if (assembly != null)
			{
				return assembly.GetType(fullname);
			}
		}
		catch (FileNotFoundException)
		{
		}
		catch (FileLoadException)
		{
		}
		return null;
	}

	public static ISymbolReaderProvider GetReaderProvider(SymbolKind kind)
	{
		switch (kind)
		{
		case SymbolKind.PortablePdb:
			return new PortablePdbReaderProvider();
		case SymbolKind.EmbeddedPortablePdb:
			return new EmbeddedPortablePdbReaderProvider();
		default:
		{
			string symbolTypeName = GetSymbolTypeName(kind, "ReaderProvider");
			Type symbolType = GetSymbolType(kind, symbolTypeName);
			if (symbolType == null)
			{
				throw new TypeLoadException("Could not find symbol provider type " + symbolTypeName);
			}
			return (ISymbolReaderProvider)Activator.CreateInstance(symbolType);
		}
		}
	}

	private static string GetSymbolTypeName(SymbolKind kind, string name)
	{
		return "Mono.Cecil." + GetSymbolNamespace(kind) + "." + kind.ToString() + name;
	}

	private static string GetSymbolNamespace(SymbolKind kind)
	{
		switch (kind)
		{
		case SymbolKind.PortablePdb:
		case SymbolKind.EmbeddedPortablePdb:
			return "Cil";
		case SymbolKind.NativePdb:
			return "Pdb";
		case SymbolKind.Mdb:
			return "Mdb";
		default:
			throw new ArgumentException();
		}
	}
}


using System;
using Mono.Cecil.Cil;

internal interface ISymbolWriter : IDisposable
{
	ISymbolReaderProvider GetReaderProvider();

	ImageDebugHeader GetDebugHeader();

	void Write(MethodDebugInformation info);

	void Write();
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal interface ISymbolWriterProvider
{
	ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);

	ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal class DefaultSymbolWriterProvider : ISymbolWriterProvider
{
	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
	{
		ISymbolReader symbolReader = module.SymbolReader;
		if (symbolReader == null)
		{
			throw new InvalidOperationException();
		}
		if (module.Image != null && module.Image.HasDebugTables())
		{
			return null;
		}
		return symbolReader.GetWriterProvider().GetSymbolWriter(module, fileName);
	}

	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
	{
		throw new NotSupportedException();
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;

internal sealed class VariableDefinition : VariableReference
{
	public bool IsPinned => variable_type.IsPinned;

	public VariableDefinition(TypeReference variableType)
		: base(variableType)
	{
	}

	public override VariableDefinition Resolve()
	{
		return this;
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;

internal abstract class VariableReference
{
	internal int index = -1;

	protected TypeReference variable_type;

	public TypeReference VariableType
	{
		get
		{
			return variable_type;
		}
		set
		{
			variable_type = value;
		}
	}

	public int Index => index;

	internal VariableReference(TypeReference variable_type)
	{
		this.variable_type = variable_type;
	}

	public abstract VariableDefinition Resolve();

	public override string ToString()
	{
		if (index >= 0)
		{
			return "V_" + index;
		}
		return string.Empty;
	}
}


using System;

internal class MonoSymbolFileException : Exception
{
	public MonoSymbolFileException()
	{
	}

	public MonoSymbolFileException(string message, params object[] args)
		: base(string.Format(message, args))
	{
	}

	public MonoSymbolFileException(string message, Exception innerException)
		: base(message, innerException)
	{
	}
}


using System.IO;

internal sealed class MyBinaryWriter : BinaryWriter
{
	public MyBinaryWriter(Stream stream)
		: base(stream)
	{
	}

	public void WriteLeb128(int value)
	{
		Write7BitEncodedInt(value);
	}
}


using System.IO;

internal class MyBinaryReader : BinaryReader
{
	public MyBinaryReader(Stream stream)
		: base(stream)
	{
	}

	public int ReadLeb128()
	{
		return Read7BitEncodedInt();
	}

	public string ReadString(int offset)
	{
		long position = BaseStream.Position;
		BaseStream.Position = offset;
		string result = ReadString();
		BaseStream.Position = position;
		return result;
	}
}


using Mono.CompilerServices.SymbolWriter;

internal interface ISourceFile
{
	SourceFileEntry Entry { get; }
}


using Mono.CompilerServices.SymbolWriter;

internal interface ICompileUnit
{
	CompileUnitEntry Entry { get; }
}


internal interface IMethodDef
{
	string Name { get; }

	int Token { get; }
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using Mono.CompilerServices.SymbolWriter;

internal class MonoSymbolFile : IDisposable
{
	private List<MethodEntry> methods = new List<MethodEntry>();

	private List<SourceFileEntry> sources = new List<SourceFileEntry>();

	private List<CompileUnitEntry> comp_units = new List<CompileUnitEntry>();

	private Dictionary<int, AnonymousScopeEntry> anonymous_scopes;

	private OffsetTable ot;

	private int last_type_index;

	private int last_method_index;

	private int last_namespace_index;

	public readonly int MajorVersion = 50;

	public readonly int MinorVersion;

	public int NumLineNumbers;

	private MyBinaryReader reader;

	private Dictionary<int, SourceFileEntry> source_file_hash;

	private Dictionary<int, CompileUnitEntry> compile_unit_hash;

	private List<MethodEntry> method_list;

	private Dictionary<int, MethodEntry> method_token_hash;

	private Dictionary<string, int> source_name_hash;

	private Guid guid;

	internal int LineNumberCount;

	internal int LocalCount;

	internal int StringSize;

	internal int LineNumberSize;

	internal int ExtendedLineNumberSize;

	public int CompileUnitCount => ot.CompileUnitCount;

	public int SourceCount => ot.SourceCount;

	public int MethodCount => ot.MethodCount;

	public int TypeCount => ot.TypeCount;

	public int AnonymousScopeCount => ot.AnonymousScopeCount;

	public int NamespaceCount => last_namespace_index;

	public Guid Guid => guid;

	public OffsetTable OffsetTable => ot;

	public SourceFileEntry[] Sources
	{
		get
		{
			if (reader == null)
			{
				throw new InvalidOperationException();
			}
			SourceFileEntry[] array = new SourceFileEntry[SourceCount];
			for (int i = 0; i < SourceCount; i++)
			{
				array[i] = GetSourceFile(i + 1);
			}
			return array;
		}
	}

	public CompileUnitEntry[] CompileUnits
	{
		get
		{
			if (reader == null)
			{
				throw new InvalidOperationException();
			}
			CompileUnitEntry[] array = new CompileUnitEntry[CompileUnitCount];
			for (int i = 0; i < CompileUnitCount; i++)
			{
				array[i] = GetCompileUnit(i + 1);
			}
			return array;
		}
	}

	public MethodEntry[] Methods
	{
		get
		{
			if (reader == null)
			{
				throw new InvalidOperationException();
			}
			lock (this)
			{
				read_methods();
				MethodEntry[] array = new MethodEntry[MethodCount];
				method_list.CopyTo(array, 0);
				return array;
			}
		}
	}

	internal MyBinaryReader BinaryReader
	{
		get
		{
			if (reader == null)
			{
				throw new InvalidOperationException();
			}
			return reader;
		}
	}

	public MonoSymbolFile()
	{
		ot = new OffsetTable();
	}

	public int AddSource(SourceFileEntry source)
	{
		sources.Add(source);
		return sources.Count;
	}

	public int AddCompileUnit(CompileUnitEntry entry)
	{
		comp_units.Add(entry);
		return comp_units.Count;
	}

	public void AddMethod(MethodEntry entry)
	{
		methods.Add(entry);
	}

	public MethodEntry DefineMethod(CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, MethodEntry.Flags flags, int namespace_id)
	{
		if (reader != null)
		{
			throw new InvalidOperationException();
		}
		MethodEntry methodEntry = new MethodEntry(this, comp_unit, token, scope_vars, locals, lines, code_blocks, real_name, flags, namespace_id);
		AddMethod(methodEntry);
		return methodEntry;
	}

	internal void DefineAnonymousScope(int id)
	{
		if (reader != null)
		{
			throw new InvalidOperationException();
		}
		if (anonymous_scopes == null)
		{
			anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>();
		}
		anonymous_scopes.Add(id, new AnonymousScopeEntry(id));
	}

	internal void DefineCapturedVariable(int scope_id, string name, string captured_name, CapturedVariable.CapturedKind kind)
	{
		if (reader != null)
		{
			throw new InvalidOperationException();
		}
		anonymous_scopes[scope_id].AddCapturedVariable(name, captured_name, kind);
	}

	internal void DefineCapturedScope(int scope_id, int id, string captured_name)
	{
		if (reader != null)
		{
			throw new InvalidOperationException();
		}
		anonymous_scopes[scope_id].AddCapturedScope(id, captured_name);
	}

	internal int GetNextTypeIndex()
	{
		return ++last_type_index;
	}

	internal int GetNextMethodIndex()
	{
		return ++last_method_index;
	}

	internal int GetNextNamespaceIndex()
	{
		return ++last_namespace_index;
	}

	private void Write(MyBinaryWriter bw, Guid guid)
	{
		bw.Write(5037318119232611860L);
		bw.Write(MajorVersion);
		bw.Write(MinorVersion);
		bw.Write(guid.ToByteArray());
		long position = bw.BaseStream.Position;
		ot.Write(bw, MajorVersion, MinorVersion);
		methods.Sort();
		for (int i = 0; i < methods.Count; i++)
		{
			methods[i].Index = i + 1;
		}
		ot.DataSectionOffset = (int)bw.BaseStream.Position;
		foreach (SourceFileEntry source in sources)
		{
			source.WriteData(bw);
		}
		foreach (CompileUnitEntry comp_unit in comp_units)
		{
			comp_unit.WriteData(bw);
		}
		foreach (MethodEntry method in methods)
		{
			method.WriteData(this, bw);
		}
		ot.DataSectionSize = (int)bw.BaseStream.Position - ot.DataSectionOffset;
		ot.MethodTableOffset = (int)bw.BaseStream.Position;
		for (int j = 0; j < methods.Count; j++)
		{
			methods[j].Write(bw);
		}
		ot.MethodTableSize = (int)bw.BaseStream.Position - ot.MethodTableOffset;
		ot.SourceTableOffset = (int)bw.BaseStream.Position;
		for (int k = 0; k < sources.Count; k++)
		{
			sources[k].Write(bw);
		}
		ot.SourceTableSize = (int)bw.BaseStream.Position - ot.SourceTableOffset;
		ot.CompileUnitTableOffset = (int)bw.BaseStream.Position;
		for (int l = 0; l < comp_units.Count; l++)
		{
			comp_units[l].Write(bw);
		}
		ot.CompileUnitTableSize = (int)bw.BaseStream.Position - ot.CompileUnitTableOffset;
		ot.AnonymousScopeCount = ((anonymous_scopes != null) ? anonymous_scopes.Count : 0);
		ot.AnonymousScopeTableOffset = (int)bw.BaseStream.Position;
		if (anonymous_scopes != null)
		{
			foreach (AnonymousScopeEntry value in anonymous_scopes.Values)
			{
				value.Write(bw);
			}
		}
		ot.AnonymousScopeTableSize = (int)bw.BaseStream.Position - ot.AnonymousScopeTableOffset;
		ot.TypeCount = last_type_index;
		ot.MethodCount = methods.Count;
		ot.SourceCount = sources.Count;
		ot.CompileUnitCount = comp_units.Count;
		ot.TotalFileSize = (int)bw.BaseStream.Position;
		bw.Seek((int)position, SeekOrigin.Begin);
		ot.Write(bw, MajorVersion, MinorVersion);
		bw.Seek(0, SeekOrigin.End);
	}

	public void CreateSymbolFile(Guid guid, FileStream fs)
	{
		if (reader != null)
		{
			throw new InvalidOperationException();
		}
		Write(new MyBinaryWriter(fs), guid);
	}

	private MonoSymbolFile(Stream stream)
	{
		reader = new MyBinaryReader(stream);
		try
		{
			long num = reader.ReadInt64();
			int num2 = reader.ReadInt32();
			int num3 = reader.ReadInt32();
			if (num != 5037318119232611860L)
			{
				throw new MonoSymbolFileException("Symbol file is not a valid");
			}
			if (num2 != 50)
			{
				throw new MonoSymbolFileException("Symbol file has version {0} but expected {1}", num2, 50);
			}
			if (num3 != 0)
			{
				throw new MonoSymbolFileException("Symbol file has version {0}.{1} but expected {2}.{3}", num2, num3, 50, 0);
			}
			MajorVersion = num2;
			MinorVersion = num3;
			guid = new Guid(reader.ReadBytes(16));
			ot = new OffsetTable(reader, num2, num3);
		}
		catch (Exception innerException)
		{
			throw new MonoSymbolFileException("Cannot read symbol file", innerException);
		}
		source_file_hash = new Dictionary<int, SourceFileEntry>();
		compile_unit_hash = new Dictionary<int, CompileUnitEntry>();
	}

	public static MonoSymbolFile ReadSymbolFile(Assembly assembly)
	{
		string mdbFilename = assembly.Location + ".mdb";
		Guid moduleVersionId = assembly.GetModules()[0].ModuleVersionId;
		return ReadSymbolFile(mdbFilename, moduleVersionId);
	}

	public static MonoSymbolFile ReadSymbolFile(string mdbFilename)
	{
		return ReadSymbolFile(new FileStream(mdbFilename, FileMode.Open, FileAccess.Read));
	}

	public static MonoSymbolFile ReadSymbolFile(string mdbFilename, Guid assemblyGuid)
	{
		MonoSymbolFile monoSymbolFile = ReadSymbolFile(mdbFilename);
		if (assemblyGuid != monoSymbolFile.guid)
		{
			throw new MonoSymbolFileException("Symbol file `{0}' does not match assembly", mdbFilename);
		}
		return monoSymbolFile;
	}

	public static MonoSymbolFile ReadSymbolFile(Stream stream)
	{
		return new MonoSymbolFile(stream);
	}

	public SourceFileEntry GetSourceFile(int index)
	{
		if (index < 1 || index > ot.SourceCount)
		{
			throw new ArgumentException();
		}
		if (reader == null)
		{
			throw new InvalidOperationException();
		}
		lock (this)
		{
			if (source_file_hash.TryGetValue(index, out var value))
			{
				return value;
			}
			long position = reader.BaseStream.Position;
			reader.BaseStream.Position = ot.SourceTableOffset + SourceFileEntry.Size * (index - 1);
			value = new SourceFileEntry(this, reader);
			source_file_hash.Add(index, value);
			reader.BaseStream.Position = position;
			return value;
		}
	}

	public CompileUnitEntry GetCompileUnit(int index)
	{
		if (index < 1 || index > ot.CompileUnitCount)
		{
			throw new ArgumentException();
		}
		if (reader == null)
		{
			throw new InvalidOperationException();
		}
		lock (this)
		{
			if (compile_unit_hash.TryGetValue(index, out var value))
			{
				return value;
			}
			long position = reader.BaseStream.Position;
			reader.BaseStream.Position = ot.CompileUnitTableOffset + CompileUnitEntry.Size * (index - 1);
			value = new CompileUnitEntry(this, reader);
			compile_unit_hash.Add(index, value);
			reader.BaseStream.Position = position;
			return value;
		}
	}

	private void read_methods()
	{
		lock (this)
		{
			if (method_token_hash == null)
			{
				method_token_hash = new Dictionary<int, MethodEntry>();
				method_list = new List<MethodEntry>();
				long position = reader.BaseStream.Position;
				reader.BaseStream.Position = ot.MethodTableOffset;
				for (int i = 0; i < MethodCount; i++)
				{
					MethodEntry methodEntry = new MethodEntry(this, reader, i + 1);
					method_token_hash.Add(methodEntry.Token, methodEntry);
					method_list.Add(methodEntry);
				}
				reader.BaseStream.Position = position;
			}
		}
	}

	public MethodEntry GetMethodByToken(int token)
	{
		if (reader == null)
		{
			throw new InvalidOperationException();
		}
		lock (this)
		{
			read_methods();
			method_token_hash.TryGetValue(token, out var value);
			return value;
		}
	}

	public MethodEntry GetMethod(int index)
	{
		if (index < 1 || index > ot.MethodCount)
		{
			throw new ArgumentException();
		}
		if (reader == null)
		{
			throw new InvalidOperationException();
		}
		lock (this)
		{
			read_methods();
			return method_list[index - 1];
		}
	}

	public int FindSource(string file_name)
	{
		if (reader == null)
		{
			throw new InvalidOperationException();
		}
		lock (this)
		{
			if (source_name_hash == null)
			{
				source_name_hash = new Dictionary<string, int>();
				for (int i = 0; i < ot.SourceCount; i++)
				{
					SourceFileEntry sourceFile = GetSourceFile(i + 1);
					source_name_hash.Add(sourceFile.FileName, i);
				}
			}
			if (!source_name_hash.TryGetValue(file_name, out var value))
			{
				return -1;
			}
			return value;
		}
	}

	public AnonymousScopeEntry GetAnonymousScope(int id)
	{
		if (reader == null)
		{
			throw new InvalidOperationException();
		}
		lock (this)
		{
			if (anonymous_scopes != null)
			{
				anonymous_scopes.TryGetValue(id, out var value);
				return value;
			}
			anonymous_scopes = new Dictionary<int, AnonymousScopeEntry>();
			reader.BaseStream.Position = ot.AnonymousScopeTableOffset;
			for (int i = 0; i < ot.AnonymousScopeCount; i++)
			{
				AnonymousScopeEntry value = new AnonymousScopeEntry(reader);
				anonymous_scopes.Add(value.ID, value);
			}
			return anonymous_scopes[id];
		}
	}

	public void Dispose()
	{
		Dispose(disposing: true);
	}

	protected virtual void Dispose(bool disposing)
	{
		if (disposing && reader != null)
		{
			reader.Close();
			reader = null;
		}
	}
}


using System;
using System.IO;
using Mono.CompilerServices.SymbolWriter;

internal class OffsetTable
{
	[Flags]
	public enum Flags
	{
		IsAspxSource = 1,
		WindowsFileNames = 2
	}

	public const int MajorVersion = 50;

	public const int MinorVersion = 0;

	public const long Magic = 5037318119232611860L;

	public int TotalFileSize;

	public int DataSectionOffset;

	public int DataSectionSize;

	public int CompileUnitCount;

	public int CompileUnitTableOffset;

	public int CompileUnitTableSize;

	public int SourceCount;

	public int SourceTableOffset;

	public int SourceTableSize;

	public int MethodCount;

	public int MethodTableOffset;

	public int MethodTableSize;

	public int TypeCount;

	public int AnonymousScopeCount;

	public int AnonymousScopeTableOffset;

	public int AnonymousScopeTableSize;

	public Flags FileFlags;

	public int LineNumberTable_LineBase = -1;

	public int LineNumberTable_LineRange = 8;

	public int LineNumberTable_OpcodeBase = 9;

	internal OffsetTable()
	{
		int platform = (int)Environment.OSVersion.Platform;
		if (platform != 4 && platform != 128)
		{
			FileFlags |= Flags.WindowsFileNames;
		}
	}

	internal OffsetTable(BinaryReader reader, int major_version, int minor_version)
	{
		TotalFileSize = reader.ReadInt32();
		DataSectionOffset = reader.ReadInt32();
		DataSectionSize = reader.ReadInt32();
		CompileUnitCount = reader.ReadInt32();
		CompileUnitTableOffset = reader.ReadInt32();
		CompileUnitTableSize = reader.ReadInt32();
		SourceCount = reader.ReadInt32();
		SourceTableOffset = reader.ReadInt32();
		SourceTableSize = reader.ReadInt32();
		MethodCount = reader.ReadInt32();
		MethodTableOffset = reader.ReadInt32();
		MethodTableSize = reader.ReadInt32();
		TypeCount = reader.ReadInt32();
		AnonymousScopeCount = reader.ReadInt32();
		AnonymousScopeTableOffset = reader.ReadInt32();
		AnonymousScopeTableSize = reader.ReadInt32();
		LineNumberTable_LineBase = reader.ReadInt32();
		LineNumberTable_LineRange = reader.ReadInt32();
		LineNumberTable_OpcodeBase = reader.ReadInt32();
		FileFlags = (Flags)reader.ReadInt32();
	}

	internal void Write(BinaryWriter bw, int major_version, int minor_version)
	{
		bw.Write(TotalFileSize);
		bw.Write(DataSectionOffset);
		bw.Write(DataSectionSize);
		bw.Write(CompileUnitCount);
		bw.Write(CompileUnitTableOffset);
		bw.Write(CompileUnitTableSize);
		bw.Write(SourceCount);
		bw.Write(SourceTableOffset);
		bw.Write(SourceTableSize);
		bw.Write(MethodCount);
		bw.Write(MethodTableOffset);
		bw.Write(MethodTableSize);
		bw.Write(TypeCount);
		bw.Write(AnonymousScopeCount);
		bw.Write(AnonymousScopeTableOffset);
		bw.Write(AnonymousScopeTableSize);
		bw.Write(LineNumberTable_LineBase);
		bw.Write(LineNumberTable_LineRange);
		bw.Write(LineNumberTable_OpcodeBase);
		bw.Write((int)FileFlags);
	}

	public override string ToString()
	{
		return $"OffsetTable [{TotalFileSize} - {DataSectionOffset}:{DataSectionSize} - {SourceCount}:{SourceTableOffset}:{SourceTableSize} - {MethodCount}:{MethodTableOffset}:{MethodTableSize} - {TypeCount}]";
	}
}


using System;

[Flags]
public enum Flags
{
	IsAspxSource = 1,
	WindowsFileNames = 2
}


using System.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal class LineNumberEntry
{
	public sealed class LocationComparer : IComparer<LineNumberEntry>
	{
		public static readonly LocationComparer Default = new LocationComparer();

		public int Compare(LineNumberEntry l1, LineNumberEntry l2)
		{
			if (l1.Row != l2.Row)
			{
				int row = l1.Row;
				return row.CompareTo(l2.Row);
			}
			return l1.Column.CompareTo(l2.Column);
		}
	}

	public readonly int Row;

	public int Column;

	public int EndRow;

	public int EndColumn;

	public readonly int File;

	public readonly int Offset;

	public readonly bool IsHidden;

	public static readonly LineNumberEntry Null = new LineNumberEntry(0, 0, 0, 0);

	public LineNumberEntry(int file, int row, int column, int offset)
		: this(file, row, column, offset, is_hidden: false)
	{
	}

	public LineNumberEntry(int file, int row, int offset)
		: this(file, row, -1, offset, is_hidden: false)
	{
	}

	public LineNumberEntry(int file, int row, int column, int offset, bool is_hidden)
		: this(file, row, column, -1, -1, offset, is_hidden)
	{
	}

	public LineNumberEntry(int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden)
	{
		File = file;
		Row = row;
		Column = column;
		EndRow = end_row;
		EndColumn = end_column;
		Offset = offset;
		IsHidden = is_hidden;
	}

	public override string ToString()
	{
		return $"[Line {File}:{Row},{Column}-{EndRow},{EndColumn}:{Offset}]";
	}
}


using System.Collections.Generic;

public sealed class LocationComparer : IComparer<LineNumberEntry>
{
	public static readonly LocationComparer Default = new LocationComparer();

	public int Compare(LineNumberEntry l1, LineNumberEntry l2)
	{
		if (l1.Row != l2.Row)
		{
			int row = l1.Row;
			return row.CompareTo(l2.Row);
		}
		return l1.Column.CompareTo(l2.Column);
	}
}


using Mono.CompilerServices.SymbolWriter;

internal class CodeBlockEntry
{
	public enum Type
	{
		Lexical = 1,
		CompilerGenerated,
		IteratorBody,
		IteratorDispatcher
	}

	public int Index;

	public int Parent;

	public Type BlockType;

	public int StartOffset;

	public int EndOffset;

	public CodeBlockEntry(int index, int parent, Type type, int start_offset)
	{
		Index = index;
		Parent = parent;
		BlockType = type;
		StartOffset = start_offset;
	}

	internal CodeBlockEntry(int index, MyBinaryReader reader)
	{
		Index = index;
		int num = reader.ReadLeb128();
		BlockType = (Type)(num & 0x3F);
		Parent = reader.ReadLeb128();
		StartOffset = reader.ReadLeb128();
		EndOffset = reader.ReadLeb128();
		if ((num & 0x40) != 0)
		{
			int num2 = reader.ReadInt16();
			reader.BaseStream.Position += num2;
		}
	}

	public void Close(int end_offset)
	{
		EndOffset = end_offset;
	}

	internal void Write(MyBinaryWriter bw)
	{
		bw.WriteLeb128((int)BlockType);
		bw.WriteLeb128(Parent);
		bw.WriteLeb128(StartOffset);
		bw.WriteLeb128(EndOffset);
	}

	public override string ToString()
	{
		return $"[CodeBlock {Index}:{Parent}:{BlockType}:{StartOffset}:{EndOffset}]";
	}
}


public enum Type
{
	Lexical = 1,
	CompilerGenerated,
	IteratorBody,
	IteratorDispatcher
}


using Mono.CompilerServices.SymbolWriter;

internal struct LocalVariableEntry
{
	public readonly int Index;

	public readonly string Name;

	public readonly int BlockIndex;

	public LocalVariableEntry(int index, string name, int block)
	{
		Index = index;
		Name = name;
		BlockIndex = block;
	}

	internal LocalVariableEntry(MonoSymbolFile file, MyBinaryReader reader)
	{
		Index = reader.ReadLeb128();
		Name = reader.ReadString();
		BlockIndex = reader.ReadLeb128();
	}

	internal void Write(MonoSymbolFile file, MyBinaryWriter bw)
	{
		bw.WriteLeb128(Index);
		bw.Write(Name);
		bw.WriteLeb128(BlockIndex);
	}

	public override string ToString()
	{
		return $"[LocalVariable {Name}:{Index}:{BlockIndex - 1}]";
	}
}


using Mono.CompilerServices.SymbolWriter;

internal struct CapturedVariable
{
	public enum CapturedKind : byte
	{
		Local,
		Parameter,
		This
	}

	public readonly string Name;

	public readonly string CapturedName;

	public readonly CapturedKind Kind;

	public CapturedVariable(string name, string captured_name, CapturedKind kind)
	{
		Name = name;
		CapturedName = captured_name;
		Kind = kind;
	}

	internal CapturedVariable(MyBinaryReader reader)
	{
		Name = reader.ReadString();
		CapturedName = reader.ReadString();
		Kind = (CapturedKind)reader.ReadByte();
	}

	internal void Write(MyBinaryWriter bw)
	{
		bw.Write(Name);
		bw.Write(CapturedName);
		bw.Write((byte)Kind);
	}

	public override string ToString()
	{
		return $"[CapturedVariable {Name}:{CapturedName}:{Kind}]";
	}
}


public enum CapturedKind : byte
{
	Local,
	Parameter,
	This
}


using Mono.CompilerServices.SymbolWriter;

internal struct CapturedScope
{
	public readonly int Scope;

	public readonly string CapturedName;

	public CapturedScope(int scope, string captured_name)
	{
		Scope = scope;
		CapturedName = captured_name;
	}

	internal CapturedScope(MyBinaryReader reader)
	{
		Scope = reader.ReadLeb128();
		CapturedName = reader.ReadString();
	}

	internal void Write(MyBinaryWriter bw)
	{
		bw.WriteLeb128(Scope);
		bw.Write(CapturedName);
	}

	public override string ToString()
	{
		return $"[CapturedScope {Scope}:{CapturedName}]";
	}
}


using Mono.CompilerServices.SymbolWriter;

internal struct ScopeVariable
{
	public readonly int Scope;

	public readonly int Index;

	public ScopeVariable(int scope, int index)
	{
		Scope = scope;
		Index = index;
	}

	internal ScopeVariable(MyBinaryReader reader)
	{
		Scope = reader.ReadLeb128();
		Index = reader.ReadLeb128();
	}

	internal void Write(MyBinaryWriter bw)
	{
		bw.WriteLeb128(Scope);
		bw.WriteLeb128(Index);
	}

	public override string ToString()
	{
		return $"[ScopeVariable {Scope}:{Index}]";
	}
}


using System.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal class AnonymousScopeEntry
{
	public readonly int ID;

	private List<CapturedVariable> captured_vars = new List<CapturedVariable>();

	private List<CapturedScope> captured_scopes = new List<CapturedScope>();

	public CapturedVariable[] CapturedVariables
	{
		get
		{
			CapturedVariable[] array = new CapturedVariable[captured_vars.Count];
			captured_vars.CopyTo(array, 0);
			return array;
		}
	}

	public CapturedScope[] CapturedScopes
	{
		get
		{
			CapturedScope[] array = new CapturedScope[captured_scopes.Count];
			captured_scopes.CopyTo(array, 0);
			return array;
		}
	}

	public AnonymousScopeEntry(int id)
	{
		ID = id;
	}

	internal AnonymousScopeEntry(MyBinaryReader reader)
	{
		ID = reader.ReadLeb128();
		int num = reader.ReadLeb128();
		for (int i = 0; i < num; i++)
		{
			captured_vars.Add(new CapturedVariable(reader));
		}
		int num2 = reader.ReadLeb128();
		for (int j = 0; j < num2; j++)
		{
			captured_scopes.Add(new CapturedScope(reader));
		}
	}

	internal void AddCapturedVariable(string name, string captured_name, CapturedVariable.CapturedKind kind)
	{
		captured_vars.Add(new CapturedVariable(name, captured_name, kind));
	}

	internal void AddCapturedScope(int scope, string captured_name)
	{
		captured_scopes.Add(new CapturedScope(scope, captured_name));
	}

	internal void Write(MyBinaryWriter bw)
	{
		bw.WriteLeb128(ID);
		bw.WriteLeb128(captured_vars.Count);
		foreach (CapturedVariable captured_var in captured_vars)
		{
			captured_var.Write(bw);
		}
		bw.WriteLeb128(captured_scopes.Count);
		foreach (CapturedScope captured_scope in captured_scopes)
		{
			captured_scope.Write(bw);
		}
	}

	public override string ToString()
	{
		return $"[AnonymousScope {ID}]";
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Mono.CompilerServices.SymbolWriter;

internal class CompileUnitEntry : ICompileUnit
{
	public readonly int Index;

	private int DataOffset;

	private MonoSymbolFile file;

	private SourceFileEntry source;

	private List<SourceFileEntry> include_files;

	private List<NamespaceEntry> namespaces;

	private bool creating;

	public static int Size => 8;

	CompileUnitEntry ICompileUnit.Entry => this;

	public SourceFileEntry SourceFile
	{
		get
		{
			if (creating)
			{
				return source;
			}
			ReadData();
			return source;
		}
	}

	public NamespaceEntry[] Namespaces
	{
		get
		{
			ReadData();
			NamespaceEntry[] array = new NamespaceEntry[namespaces.Count];
			namespaces.CopyTo(array, 0);
			return array;
		}
	}

	public SourceFileEntry[] IncludeFiles
	{
		get
		{
			ReadData();
			if (include_files == null)
			{
				return new SourceFileEntry[0];
			}
			SourceFileEntry[] array = new SourceFileEntry[include_files.Count];
			include_files.CopyTo(array, 0);
			return array;
		}
	}

	public CompileUnitEntry(MonoSymbolFile file, SourceFileEntry source)
	{
		this.file = file;
		this.source = source;
		Index = file.AddCompileUnit(this);
		creating = true;
		namespaces = new List<NamespaceEntry>();
	}

	public void AddFile(SourceFileEntry file)
	{
		if (!creating)
		{
			throw new InvalidOperationException();
		}
		if (include_files == null)
		{
			include_files = new List<SourceFileEntry>();
		}
		include_files.Add(file);
	}

	public int DefineNamespace(string name, string[] using_clauses, int parent)
	{
		if (!creating)
		{
			throw new InvalidOperationException();
		}
		int nextNamespaceIndex = file.GetNextNamespaceIndex();
		NamespaceEntry item = new NamespaceEntry(name, nextNamespaceIndex, using_clauses, parent);
		namespaces.Add(item);
		return nextNamespaceIndex;
	}

	internal void WriteData(MyBinaryWriter bw)
	{
		DataOffset = (int)bw.BaseStream.Position;
		bw.WriteLeb128(source.Index);
		int value = ((include_files != null) ? include_files.Count : 0);
		bw.WriteLeb128(value);
		if (include_files != null)
		{
			foreach (SourceFileEntry include_file in include_files)
			{
				bw.WriteLeb128(include_file.Index);
			}
		}
		bw.WriteLeb128(namespaces.Count);
		foreach (NamespaceEntry @namespace in namespaces)
		{
			@namespace.Write(file, bw);
		}
	}

	internal void Write(BinaryWriter bw)
	{
		bw.Write(Index);
		bw.Write(DataOffset);
	}

	internal CompileUnitEntry(MonoSymbolFile file, MyBinaryReader reader)
	{
		this.file = file;
		Index = reader.ReadInt32();
		DataOffset = reader.ReadInt32();
	}

	public void ReadAll()
	{
		ReadData();
	}

	private void ReadData()
	{
		if (creating)
		{
			throw new InvalidOperationException();
		}
		lock (file)
		{
			if (namespaces != null)
			{
				return;
			}
			MyBinaryReader binaryReader = file.BinaryReader;
			int num = (int)binaryReader.BaseStream.Position;
			binaryReader.BaseStream.Position = DataOffset;
			int index = binaryReader.ReadLeb128();
			source = file.GetSourceFile(index);
			int num2 = binaryReader.ReadLeb128();
			if (num2 > 0)
			{
				include_files = new List<SourceFileEntry>();
				for (int i = 0; i < num2; i++)
				{
					include_files.Add(file.GetSourceFile(binaryReader.ReadLeb128()));
				}
			}
			int num3 = binaryReader.ReadLeb128();
			namespaces = new List<NamespaceEntry>();
			for (int j = 0; j < num3; j++)
			{
				namespaces.Add(new NamespaceEntry(file, binaryReader));
			}
			binaryReader.BaseStream.Position = num;
		}
	}
}


using System;
using System.IO;
using System.Security.Cryptography;
using Mono.CompilerServices.SymbolWriter;

internal class SourceFileEntry
{
	public readonly int Index;

	private int DataOffset;

	private MonoSymbolFile file;

	private string file_name;

	private byte[] guid;

	private byte[] hash;

	private bool creating;

	private bool auto_generated;

	private readonly string sourceFile;

	public static int Size => 8;

	public byte[] Checksum => hash;

	public string FileName
	{
		get
		{
			return file_name;
		}
		set
		{
			file_name = value;
		}
	}

	public bool AutoGenerated => auto_generated;

	public SourceFileEntry(MonoSymbolFile file, string file_name)
	{
		this.file = file;
		this.file_name = file_name;
		Index = file.AddSource(this);
		creating = true;
	}

	public SourceFileEntry(MonoSymbolFile file, string sourceFile, byte[] guid, byte[] checksum)
		: this(file, sourceFile, sourceFile, guid, checksum)
	{
	}

	public SourceFileEntry(MonoSymbolFile file, string fileName, string sourceFile, byte[] guid, byte[] checksum)
		: this(file, fileName)
	{
		this.guid = guid;
		hash = checksum;
		this.sourceFile = sourceFile;
	}

	internal void WriteData(MyBinaryWriter bw)
	{
		DataOffset = (int)bw.BaseStream.Position;
		bw.Write(file_name);
		if (guid == null)
		{
			guid = new byte[16];
		}
		if (hash == null)
		{
			try
			{
				using FileStream inputStream = new FileStream(sourceFile, FileMode.Open, FileAccess.Read);
				MD5 mD = MD5.Create();
				hash = mD.ComputeHash(inputStream);
			}
			catch
			{
				hash = new byte[16];
			}
		}
		bw.Write(guid);
		bw.Write(hash);
		bw.Write((byte)(auto_generated ? 1u : 0u));
	}

	internal void Write(BinaryWriter bw)
	{
		bw.Write(Index);
		bw.Write(DataOffset);
	}

	internal SourceFileEntry(MonoSymbolFile file, MyBinaryReader reader)
	{
		this.file = file;
		Index = reader.ReadInt32();
		DataOffset = reader.ReadInt32();
		int num = (int)reader.BaseStream.Position;
		reader.BaseStream.Position = DataOffset;
		sourceFile = (file_name = reader.ReadString());
		guid = reader.ReadBytes(16);
		hash = reader.ReadBytes(16);
		auto_generated = reader.ReadByte() == 1;
		reader.BaseStream.Position = num;
	}

	public void SetAutoGenerated()
	{
		if (!creating)
		{
			throw new InvalidOperationException();
		}
		auto_generated = true;
		file.OffsetTable.FileFlags |= OffsetTable.Flags.IsAspxSource;
	}

	public bool CheckChecksum()
	{
		try
		{
			using FileStream inputStream = new FileStream(sourceFile, FileMode.Open);
			byte[] array = MD5.Create().ComputeHash(inputStream);
			for (int i = 0; i < 16; i++)
			{
				if (array[i] != hash[i])
				{
					return false;
				}
			}
			return true;
		}
		catch
		{
			return false;
		}
	}

	public override string ToString()
	{
		return $"SourceFileEntry ({Index}:{DataOffset})";
	}
}


using System.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal class LineNumberTable
{
	protected LineNumberEntry[] _line_numbers;

	public readonly int LineBase;

	public readonly int LineRange;

	public readonly byte OpcodeBase;

	public readonly int MaxAddressIncrement;

	public const int Default_LineBase = -1;

	public const int Default_LineRange = 8;

	public const byte Default_OpcodeBase = 9;

	public const byte DW_LNS_copy = 1;

	public const byte DW_LNS_advance_pc = 2;

	public const byte DW_LNS_advance_line = 3;

	public const byte DW_LNS_set_file = 4;

	public const byte DW_LNS_const_add_pc = 8;

	public const byte DW_LNE_end_sequence = 1;

	public const byte DW_LNE_MONO_negate_is_hidden = 64;

	internal const byte DW_LNE_MONO__extensions_start = 64;

	internal const byte DW_LNE_MONO__extensions_end = 127;

	public LineNumberEntry[] LineNumbers => _line_numbers;

	protected LineNumberTable(MonoSymbolFile file)
	{
		LineBase = file.OffsetTable.LineNumberTable_LineBase;
		LineRange = file.OffsetTable.LineNumberTable_LineRange;
		OpcodeBase = (byte)file.OffsetTable.LineNumberTable_OpcodeBase;
		MaxAddressIncrement = (255 - OpcodeBase) / LineRange;
	}

	internal LineNumberTable(MonoSymbolFile file, LineNumberEntry[] lines)
		: this(file)
	{
		_line_numbers = lines;
	}

	internal void Write(MonoSymbolFile file, MyBinaryWriter bw, bool hasColumnsInfo, bool hasEndInfo)
	{
		int num = (int)bw.BaseStream.Position;
		bool flag = false;
		int num2 = 1;
		int num3 = 0;
		int num4 = 1;
		for (int i = 0; i < LineNumbers.Length; i++)
		{
			int num5 = LineNumbers[i].Row - num2;
			int num6 = LineNumbers[i].Offset - num3;
			if (LineNumbers[i].File != num4)
			{
				bw.Write((byte)4);
				bw.WriteLeb128(LineNumbers[i].File);
				num4 = LineNumbers[i].File;
			}
			if (LineNumbers[i].IsHidden != flag)
			{
				bw.Write((byte)0);
				bw.Write((byte)1);
				bw.Write((byte)64);
				flag = LineNumbers[i].IsHidden;
			}
			if (num6 >= MaxAddressIncrement)
			{
				if (num6 < 2 * MaxAddressIncrement)
				{
					bw.Write((byte)8);
					num6 -= MaxAddressIncrement;
				}
				else
				{
					bw.Write((byte)2);
					bw.WriteLeb128(num6);
					num6 = 0;
				}
			}
			if (num5 < LineBase || num5 >= LineBase + LineRange)
			{
				bw.Write((byte)3);
				bw.WriteLeb128(num5);
				if (num6 != 0)
				{
					bw.Write((byte)2);
					bw.WriteLeb128(num6);
				}
				bw.Write((byte)1);
			}
			else
			{
				byte value = (byte)(num5 - LineBase + LineRange * num6 + OpcodeBase);
				bw.Write(value);
			}
			num2 = LineNumbers[i].Row;
			num3 = LineNumbers[i].Offset;
		}
		bw.Write((byte)0);
		bw.Write((byte)1);
		bw.Write((byte)1);
		if (hasColumnsInfo)
		{
			for (int j = 0; j < LineNumbers.Length; j++)
			{
				LineNumberEntry lineNumberEntry = LineNumbers[j];
				if (lineNumberEntry.Row >= 0)
				{
					bw.WriteLeb128(lineNumberEntry.Column);
				}
			}
		}
		if (hasEndInfo)
		{
			for (int k = 0; k < LineNumbers.Length; k++)
			{
				LineNumberEntry lineNumberEntry2 = LineNumbers[k];
				if (lineNumberEntry2.EndRow == -1 || lineNumberEntry2.EndColumn == -1 || lineNumberEntry2.Row > lineNumberEntry2.EndRow)
				{
					bw.WriteLeb128(16777215);
					continue;
				}
				bw.WriteLeb128(lineNumberEntry2.EndRow - lineNumberEntry2.Row);
				bw.WriteLeb128(lineNumberEntry2.EndColumn);
			}
		}
		file.ExtendedLineNumberSize += (int)bw.BaseStream.Position - num;
	}

	internal static LineNumberTable Read(MonoSymbolFile file, MyBinaryReader br, bool readColumnsInfo, bool readEndInfo)
	{
		LineNumberTable lineNumberTable = new LineNumberTable(file);
		lineNumberTable.DoRead(file, br, readColumnsInfo, readEndInfo);
		return lineNumberTable;
	}

	private void DoRead(MonoSymbolFile file, MyBinaryReader br, bool includesColumns, bool includesEnds)
	{
		List<LineNumberEntry> list = new List<LineNumberEntry>();
		bool flag = false;
		bool flag2 = false;
		int num = 1;
		int num2 = 0;
		int file2 = 1;
		while (true)
		{
			byte b = br.ReadByte();
			if (b == 0)
			{
				byte b2 = br.ReadByte();
				long position = br.BaseStream.Position + b2;
				b = br.ReadByte();
				switch (b)
				{
				case 1:
				{
					if (flag2)
					{
						list.Add(new LineNumberEntry(file2, num, -1, num2, flag));
					}
					_line_numbers = list.ToArray();
					if (includesColumns)
					{
						for (int i = 0; i < _line_numbers.Length; i++)
						{
							LineNumberEntry lineNumberEntry = _line_numbers[i];
							if (lineNumberEntry.Row >= 0)
							{
								lineNumberEntry.Column = br.ReadLeb128();
							}
						}
					}
					if (!includesEnds)
					{
						return;
					}
					for (int j = 0; j < _line_numbers.Length; j++)
					{
						LineNumberEntry lineNumberEntry2 = _line_numbers[j];
						int num3 = br.ReadLeb128();
						if (num3 == 16777215)
						{
							lineNumberEntry2.EndRow = -1;
							lineNumberEntry2.EndColumn = -1;
						}
						else
						{
							lineNumberEntry2.EndRow = lineNumberEntry2.Row + num3;
							lineNumberEntry2.EndColumn = br.ReadLeb128();
						}
					}
					return;
				}
				case 64:
					flag = !flag;
					flag2 = true;
					break;
				default:
					throw new MonoSymbolFileException("Unknown extended opcode {0:x}", b);
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
				case 75:
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 91:
				case 92:
				case 93:
				case 94:
				case 95:
				case 96:
				case 97:
				case 98:
				case 99:
				case 100:
				case 101:
				case 102:
				case 103:
				case 104:
				case 105:
				case 106:
				case 107:
				case 108:
				case 109:
				case 110:
				case 111:
				case 112:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 119:
				case 120:
				case 121:
				case 122:
				case 123:
				case 124:
				case 125:
				case 126:
				case 127:
					break;
				}
				br.BaseStream.Position = position;
			}
			else if (b < OpcodeBase)
			{
				switch (b)
				{
				case 1:
					list.Add(new LineNumberEntry(file2, num, -1, num2, flag));
					flag2 = false;
					break;
				case 2:
					num2 += br.ReadLeb128();
					flag2 = true;
					break;
				case 3:
					num += br.ReadLeb128();
					flag2 = true;
					break;
				case 4:
					file2 = br.ReadLeb128();
					flag2 = true;
					break;
				case 8:
					num2 += MaxAddressIncrement;
					flag2 = true;
					break;
				default:
					throw new MonoSymbolFileException("Unknown standard opcode {0:x} in LNT", b);
				}
			}
			else
			{
				b -= OpcodeBase;
				num2 += b / LineRange;
				num += LineBase + b % LineRange;
				list.Add(new LineNumberEntry(file2, num, -1, num2, flag));
				flag2 = false;
			}
		}
	}

	public bool GetMethodBounds(out LineNumberEntry start, out LineNumberEntry end)
	{
		if (_line_numbers.Length > 1)
		{
			start = _line_numbers[0];
			end = _line_numbers[_line_numbers.Length - 1];
			return true;
		}
		start = LineNumberEntry.Null;
		end = LineNumberEntry.Null;
		return false;
	}
}


using System;
using System.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal class MethodEntry : IComparable
{
	[Flags]
	public enum Flags
	{
		LocalNamesAmbiguous = 1,
		ColumnsInfoIncluded = 2,
		EndInfoIncluded = 4
	}

	public readonly int CompileUnitIndex;

	public readonly int Token;

	public readonly int NamespaceID;

	private int DataOffset;

	private int LocalVariableTableOffset;

	private int LineNumberTableOffset;

	private int CodeBlockTableOffset;

	private int ScopeVariableTableOffset;

	private int RealNameOffset;

	private Flags flags;

	private int index;

	public readonly CompileUnitEntry CompileUnit;

	private LocalVariableEntry[] locals;

	private CodeBlockEntry[] code_blocks;

	private ScopeVariable[] scope_vars;

	private LineNumberTable lnt;

	private string real_name;

	public readonly MonoSymbolFile SymbolFile;

	public const int Size = 12;

	public Flags MethodFlags => flags;

	public int Index
	{
		get
		{
			return index;
		}
		set
		{
			index = value;
		}
	}

	internal MethodEntry(MonoSymbolFile file, MyBinaryReader reader, int index)
	{
		SymbolFile = file;
		this.index = index;
		Token = reader.ReadInt32();
		DataOffset = reader.ReadInt32();
		LineNumberTableOffset = reader.ReadInt32();
		long position = reader.BaseStream.Position;
		reader.BaseStream.Position = DataOffset;
		CompileUnitIndex = reader.ReadLeb128();
		LocalVariableTableOffset = reader.ReadLeb128();
		NamespaceID = reader.ReadLeb128();
		CodeBlockTableOffset = reader.ReadLeb128();
		ScopeVariableTableOffset = reader.ReadLeb128();
		RealNameOffset = reader.ReadLeb128();
		flags = (Flags)reader.ReadLeb128();
		reader.BaseStream.Position = position;
		CompileUnit = file.GetCompileUnit(CompileUnitIndex);
	}

	internal MethodEntry(MonoSymbolFile file, CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id)
	{
		SymbolFile = file;
		this.real_name = real_name;
		this.locals = locals;
		this.code_blocks = code_blocks;
		this.scope_vars = scope_vars;
		this.flags = flags;
		index = -1;
		Token = token;
		CompileUnitIndex = comp_unit.Index;
		CompileUnit = comp_unit;
		NamespaceID = namespace_id;
		CheckLineNumberTable(lines);
		lnt = new LineNumberTable(file, lines);
		file.NumLineNumbers += lines.Length;
		int num = ((locals != null) ? locals.Length : 0);
		if (num <= 32)
		{
			for (int i = 0; i < num; i++)
			{
				string name = locals[i].Name;
				for (int j = i + 1; j < num; j++)
				{
					if (locals[j].Name == name)
					{
						flags |= Flags.LocalNamesAmbiguous;
						return;
					}
				}
			}
			return;
		}
		Dictionary<string, LocalVariableEntry> dictionary = new Dictionary<string, LocalVariableEntry>();
		for (int k = 0; k < locals.Length; k++)
		{
			LocalVariableEntry value = locals[k];
			if (dictionary.ContainsKey(value.Name))
			{
				flags |= Flags.LocalNamesAmbiguous;
				break;
			}
			dictionary.Add(value.Name, value);
		}
	}

	private static void CheckLineNumberTable(LineNumberEntry[] line_numbers)
	{
		int num = -1;
		int num2 = -1;
		if (line_numbers == null)
		{
			return;
		}
		foreach (LineNumberEntry lineNumberEntry in line_numbers)
		{
			if (lineNumberEntry.Equals(LineNumberEntry.Null))
			{
				throw new MonoSymbolFileException();
			}
			if (lineNumberEntry.Offset < num)
			{
				throw new MonoSymbolFileException();
			}
			if (lineNumberEntry.Offset > num)
			{
				num2 = lineNumberEntry.Row;
				num = lineNumberEntry.Offset;
			}
			else if (lineNumberEntry.Row > num2)
			{
				num2 = lineNumberEntry.Row;
			}
		}
	}

	internal void Write(MyBinaryWriter bw)
	{
		if (index <= 0 || DataOffset == 0)
		{
			throw new InvalidOperationException();
		}
		bw.Write(Token);
		bw.Write(DataOffset);
		bw.Write(LineNumberTableOffset);
	}

	internal void WriteData(MonoSymbolFile file, MyBinaryWriter bw)
	{
		if (index <= 0)
		{
			throw new InvalidOperationException();
		}
		LocalVariableTableOffset = (int)bw.BaseStream.Position;
		int num = ((locals != null) ? locals.Length : 0);
		bw.WriteLeb128(num);
		for (int i = 0; i < num; i++)
		{
			locals[i].Write(file, bw);
		}
		file.LocalCount += num;
		CodeBlockTableOffset = (int)bw.BaseStream.Position;
		int num2 = ((code_blocks != null) ? code_blocks.Length : 0);
		bw.WriteLeb128(num2);
		for (int j = 0; j < num2; j++)
		{
			code_blocks[j].Write(bw);
		}
		ScopeVariableTableOffset = (int)bw.BaseStream.Position;
		int num3 = ((scope_vars != null) ? scope_vars.Length : 0);
		bw.WriteLeb128(num3);
		for (int k = 0; k < num3; k++)
		{
			scope_vars[k].Write(bw);
		}
		if (real_name != null)
		{
			RealNameOffset = (int)bw.BaseStream.Position;
			bw.Write(real_name);
		}
		LineNumberEntry[] lineNumbers = lnt.LineNumbers;
		foreach (LineNumberEntry lineNumberEntry in lineNumbers)
		{
			if (lineNumberEntry.EndRow != -1 || lineNumberEntry.EndColumn != -1)
			{
				flags |= Flags.EndInfoIncluded;
			}
		}
		LineNumberTableOffset = (int)bw.BaseStream.Position;
		lnt.Write(file, bw, (flags & Flags.ColumnsInfoIncluded) != 0, (flags & Flags.EndInfoIncluded) != 0);
		DataOffset = (int)bw.BaseStream.Position;
		bw.WriteLeb128(CompileUnitIndex);
		bw.WriteLeb128(LocalVariableTableOffset);
		bw.WriteLeb128(NamespaceID);
		bw.WriteLeb128(CodeBlockTableOffset);
		bw.WriteLeb128(ScopeVariableTableOffset);
		bw.WriteLeb128(RealNameOffset);
		bw.WriteLeb128((int)flags);
	}

	public void ReadAll()
	{
		GetLineNumberTable();
		GetLocals();
		GetCodeBlocks();
		GetScopeVariables();
		GetRealName();
	}

	public LineNumberTable GetLineNumberTable()
	{
		lock (SymbolFile)
		{
			if (lnt != null)
			{
				return lnt;
			}
			if (LineNumberTableOffset == 0)
			{
				return null;
			}
			MyBinaryReader binaryReader = SymbolFile.BinaryReader;
			long position = binaryReader.BaseStream.Position;
			binaryReader.BaseStream.Position = LineNumberTableOffset;
			lnt = LineNumberTable.Read(SymbolFile, binaryReader, (flags & Flags.ColumnsInfoIncluded) != 0, (flags & Flags.EndInfoIncluded) != 0);
			binaryReader.BaseStream.Position = position;
			return lnt;
		}
	}

	public LocalVariableEntry[] GetLocals()
	{
		lock (SymbolFile)
		{
			if (locals != null)
			{
				return locals;
			}
			if (LocalVariableTableOffset == 0)
			{
				return null;
			}
			MyBinaryReader binaryReader = SymbolFile.BinaryReader;
			long position = binaryReader.BaseStream.Position;
			binaryReader.BaseStream.Position = LocalVariableTableOffset;
			int num = binaryReader.ReadLeb128();
			locals = new LocalVariableEntry[num];
			for (int i = 0; i < num; i++)
			{
				locals[i] = new LocalVariableEntry(SymbolFile, binaryReader);
			}
			binaryReader.BaseStream.Position = position;
			return locals;
		}
	}

	public CodeBlockEntry[] GetCodeBlocks()
	{
		lock (SymbolFile)
		{
			if (code_blocks != null)
			{
				return code_blocks;
			}
			if (CodeBlockTableOffset == 0)
			{
				return null;
			}
			MyBinaryReader binaryReader = SymbolFile.BinaryReader;
			long position = binaryReader.BaseStream.Position;
			binaryReader.BaseStream.Position = CodeBlockTableOffset;
			int num = binaryReader.ReadLeb128();
			code_blocks = new CodeBlockEntry[num];
			for (int i = 0; i < num; i++)
			{
				code_blocks[i] = new CodeBlockEntry(i, binaryReader);
			}
			binaryReader.BaseStream.Position = position;
			return code_blocks;
		}
	}

	public ScopeVariable[] GetScopeVariables()
	{
		lock (SymbolFile)
		{
			if (scope_vars != null)
			{
				return scope_vars;
			}
			if (ScopeVariableTableOffset == 0)
			{
				return null;
			}
			MyBinaryReader binaryReader = SymbolFile.BinaryReader;
			long position = binaryReader.BaseStream.Position;
			binaryReader.BaseStream.Position = ScopeVariableTableOffset;
			int num = binaryReader.ReadLeb128();
			scope_vars = new ScopeVariable[num];
			for (int i = 0; i < num; i++)
			{
				scope_vars[i] = new ScopeVariable(binaryReader);
			}
			binaryReader.BaseStream.Position = position;
			return scope_vars;
		}
	}

	public string GetRealName()
	{
		lock (SymbolFile)
		{
			if (real_name != null)
			{
				return real_name;
			}
			if (RealNameOffset == 0)
			{
				return null;
			}
			real_name = SymbolFile.BinaryReader.ReadString(RealNameOffset);
			return real_name;
		}
	}

	public int CompareTo(object obj)
	{
		MethodEntry methodEntry = (MethodEntry)obj;
		if (methodEntry.Token < Token)
		{
			return 1;
		}
		if (methodEntry.Token > Token)
		{
			return -1;
		}
		return 0;
	}

	public override string ToString()
	{
		return $"[Method {index}:{Token:x}:{CompileUnitIndex}:{CompileUnit}]";
	}
}


using System;

[Flags]
public enum Flags
{
	LocalNamesAmbiguous = 1,
	ColumnsInfoIncluded = 2,
	EndInfoIncluded = 4
}


using Mono.CompilerServices.SymbolWriter;

internal struct NamespaceEntry
{
	public readonly string Name;

	public readonly int Index;

	public readonly int Parent;

	public readonly string[] UsingClauses;

	public NamespaceEntry(string name, int index, string[] using_clauses, int parent)
	{
		Name = name;
		Index = index;
		Parent = parent;
		UsingClauses = ((using_clauses != null) ? using_clauses : new string[0]);
	}

	internal NamespaceEntry(MonoSymbolFile file, MyBinaryReader reader)
	{
		Name = reader.ReadString();
		Index = reader.ReadLeb128();
		Parent = reader.ReadLeb128();
		int num = reader.ReadLeb128();
		UsingClauses = new string[num];
		for (int i = 0; i < num; i++)
		{
			UsingClauses[i] = reader.ReadString();
		}
	}

	internal void Write(MonoSymbolFile file, MyBinaryWriter bw)
	{
		bw.Write(Name);
		bw.WriteLeb128(Index);
		bw.WriteLeb128(Parent);
		bw.WriteLeb128(UsingClauses.Length);
		string[] usingClauses = UsingClauses;
		foreach (string value in usingClauses)
		{
			bw.Write(value);
		}
	}

	public override string ToString()
	{
		return $"[Namespace {Name}:{Index}:{Parent}]";
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Mono.CompilerServices.SymbolWriter;

internal class MonoSymbolWriter
{
	private List<SourceMethodBuilder> methods;

	private List<SourceFileEntry> sources;

	private List<CompileUnitEntry> comp_units;

	protected readonly MonoSymbolFile file;

	private string filename;

	private SourceMethodBuilder current_method;

	private Stack<SourceMethodBuilder> current_method_stack = new Stack<SourceMethodBuilder>();

	public MonoSymbolFile SymbolFile => file;

	public MonoSymbolWriter(string filename)
	{
		methods = new List<SourceMethodBuilder>();
		sources = new List<SourceFileEntry>();
		comp_units = new List<CompileUnitEntry>();
		file = new MonoSymbolFile();
		this.filename = filename + ".mdb";
	}

	public void CloseNamespace()
	{
	}

	public void DefineLocalVariable(int index, string name)
	{
		if (current_method != null)
		{
			current_method.AddLocal(index, name);
		}
	}

	public void DefineCapturedLocal(int scope_id, string name, string captured_name)
	{
		file.DefineCapturedVariable(scope_id, name, captured_name, CapturedVariable.CapturedKind.Local);
	}

	public void DefineCapturedParameter(int scope_id, string name, string captured_name)
	{
		file.DefineCapturedVariable(scope_id, name, captured_name, CapturedVariable.CapturedKind.Parameter);
	}

	public void DefineCapturedThis(int scope_id, string captured_name)
	{
		file.DefineCapturedVariable(scope_id, "this", captured_name, CapturedVariable.CapturedKind.This);
	}

	public void DefineCapturedScope(int scope_id, int id, string captured_name)
	{
		file.DefineCapturedScope(scope_id, id, captured_name);
	}

	public void DefineScopeVariable(int scope, int index)
	{
		if (current_method != null)
		{
			current_method.AddScopeVariable(scope, index);
		}
	}

	public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden)
	{
		if (current_method != null)
		{
			current_method.MarkSequencePoint(offset, file, line, column, is_hidden);
		}
	}

	public SourceMethodBuilder OpenMethod(ICompileUnit file, int ns_id, IMethodDef method)
	{
		SourceMethodBuilder result = new SourceMethodBuilder(file, ns_id, method);
		current_method_stack.Push(current_method);
		current_method = result;
		methods.Add(current_method);
		return result;
	}

	public void CloseMethod()
	{
		current_method = current_method_stack.Pop();
	}

	public SourceFileEntry DefineDocument(string url)
	{
		SourceFileEntry sourceFileEntry = new SourceFileEntry(file, url);
		sources.Add(sourceFileEntry);
		return sourceFileEntry;
	}

	public SourceFileEntry DefineDocument(string url, byte[] guid, byte[] checksum)
	{
		SourceFileEntry sourceFileEntry = new SourceFileEntry(file, url, guid, checksum);
		sources.Add(sourceFileEntry);
		return sourceFileEntry;
	}

	public CompileUnitEntry DefineCompilationUnit(SourceFileEntry source)
	{
		CompileUnitEntry compileUnitEntry = new CompileUnitEntry(file, source);
		comp_units.Add(compileUnitEntry);
		return compileUnitEntry;
	}

	public int DefineNamespace(string name, CompileUnitEntry unit, string[] using_clauses, int parent)
	{
		if (unit == null || using_clauses == null)
		{
			throw new NullReferenceException();
		}
		return unit.DefineNamespace(name, using_clauses, parent);
	}

	public int OpenScope(int start_offset)
	{
		if (current_method == null)
		{
			return 0;
		}
		current_method.StartBlock(CodeBlockEntry.Type.Lexical, start_offset);
		return 0;
	}

	public void CloseScope(int end_offset)
	{
		if (current_method != null)
		{
			current_method.EndBlock(end_offset);
		}
	}

	public void OpenCompilerGeneratedBlock(int start_offset)
	{
		if (current_method != null)
		{
			current_method.StartBlock(CodeBlockEntry.Type.CompilerGenerated, start_offset);
		}
	}

	public void CloseCompilerGeneratedBlock(int end_offset)
	{
		if (current_method != null)
		{
			current_method.EndBlock(end_offset);
		}
	}

	public void StartIteratorBody(int start_offset)
	{
		current_method.StartBlock(CodeBlockEntry.Type.IteratorBody, start_offset);
	}

	public void EndIteratorBody(int end_offset)
	{
		current_method.EndBlock(end_offset);
	}

	public void StartIteratorDispatcher(int start_offset)
	{
		current_method.StartBlock(CodeBlockEntry.Type.IteratorDispatcher, start_offset);
	}

	public void EndIteratorDispatcher(int end_offset)
	{
		current_method.EndBlock(end_offset);
	}

	public void DefineAnonymousScope(int id)
	{
		file.DefineAnonymousScope(id);
	}

	public void WriteSymbolFile(Guid guid)
	{
		foreach (SourceMethodBuilder method in methods)
		{
			method.DefineMethod(file);
		}
		try
		{
			File.Delete(filename);
		}
		catch
		{
		}
		using FileStream fs = new FileStream(filename, FileMode.Create, FileAccess.Write);
		file.CreateSymbolFile(guid, fs);
	}
}


using System;
using System.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal class SourceMethodBuilder
{
	private List<LocalVariableEntry> _locals;

	private List<CodeBlockEntry> _blocks;

	private List<ScopeVariable> _scope_vars;

	private Stack<CodeBlockEntry> _block_stack;

	private readonly List<LineNumberEntry> method_lines;

	private readonly ICompileUnit _comp_unit;

	private readonly int ns_id;

	private readonly IMethodDef method;

	public CodeBlockEntry[] Blocks
	{
		get
		{
			if (_blocks == null)
			{
				return new CodeBlockEntry[0];
			}
			CodeBlockEntry[] array = new CodeBlockEntry[_blocks.Count];
			_blocks.CopyTo(array, 0);
			return array;
		}
	}

	public CodeBlockEntry CurrentBlock
	{
		get
		{
			if (_block_stack != null && _block_stack.Count > 0)
			{
				return _block_stack.Peek();
			}
			return null;
		}
	}

	public LocalVariableEntry[] Locals
	{
		get
		{
			if (_locals == null)
			{
				return new LocalVariableEntry[0];
			}
			return _locals.ToArray();
		}
	}

	public ICompileUnit SourceFile => _comp_unit;

	public ScopeVariable[] ScopeVariables
	{
		get
		{
			if (_scope_vars == null)
			{
				return new ScopeVariable[0];
			}
			return _scope_vars.ToArray();
		}
	}

	public SourceMethodBuilder(ICompileUnit comp_unit)
	{
		_comp_unit = comp_unit;
		method_lines = new List<LineNumberEntry>();
	}

	public SourceMethodBuilder(ICompileUnit comp_unit, int ns_id, IMethodDef method)
		: this(comp_unit)
	{
		this.ns_id = ns_id;
		this.method = method;
	}

	public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden)
	{
		MarkSequencePoint(offset, file, line, column, -1, -1, is_hidden);
	}

	public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, int end_line, int end_column, bool is_hidden)
	{
		LineNumberEntry lineNumberEntry = new LineNumberEntry(file?.Index ?? 0, line, column, end_line, end_column, offset, is_hidden);
		if (method_lines.Count > 0)
		{
			LineNumberEntry lineNumberEntry2 = method_lines[method_lines.Count - 1];
			if (lineNumberEntry2.Offset == offset)
			{
				if (LineNumberEntry.LocationComparer.Default.Compare(lineNumberEntry, lineNumberEntry2) > 0)
				{
					method_lines[method_lines.Count - 1] = lineNumberEntry;
				}
				return;
			}
		}
		method_lines.Add(lineNumberEntry);
	}

	public void StartBlock(CodeBlockEntry.Type type, int start_offset)
	{
		StartBlock(type, start_offset, (_blocks == null) ? 1 : (_blocks.Count + 1));
	}

	public void StartBlock(CodeBlockEntry.Type type, int start_offset, int scopeIndex)
	{
		if (_block_stack == null)
		{
			_block_stack = new Stack<CodeBlockEntry>();
		}
		if (_blocks == null)
		{
			_blocks = new List<CodeBlockEntry>();
		}
		int parent = ((CurrentBlock != null) ? CurrentBlock.Index : (-1));
		CodeBlockEntry item = new CodeBlockEntry(scopeIndex, parent, type, start_offset);
		_block_stack.Push(item);
		_blocks.Add(item);
	}

	public void EndBlock(int end_offset)
	{
		_block_stack.Pop().Close(end_offset);
	}

	public void AddLocal(int index, string name)
	{
		if (_locals == null)
		{
			_locals = new List<LocalVariableEntry>();
		}
		int block = ((CurrentBlock != null) ? CurrentBlock.Index : 0);
		_locals.Add(new LocalVariableEntry(index, name, block));
	}

	public void AddScopeVariable(int scope, int index)
	{
		if (_scope_vars == null)
		{
			_scope_vars = new List<ScopeVariable>();
		}
		_scope_vars.Add(new ScopeVariable(scope, index));
	}

	public void DefineMethod(MonoSymbolFile file)
	{
		DefineMethod(file, method.Token);
	}

	public void DefineMethod(MonoSymbolFile file, int token)
	{
		CodeBlockEntry[] array = Blocks;
		if (array.Length != 0)
		{
			List<CodeBlockEntry> list = new List<CodeBlockEntry>(array.Length);
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				num = Math.Max(num, array[i].Index);
			}
			for (int j = 0; j < num; j++)
			{
				int num2 = j + 1;
				if (j < array.Length && array[j].Index == num2)
				{
					list.Add(array[j]);
					continue;
				}
				bool flag = false;
				for (int k = 0; k < array.Length; k++)
				{
					if (array[k].Index == num2)
					{
						list.Add(array[k]);
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					list.Add(new CodeBlockEntry(num2, -1, CodeBlockEntry.Type.CompilerGenerated, 0));
				}
			}
			array = list.ToArray();
		}
		MethodEntry entry = new MethodEntry(file, _comp_unit.Entry, token, ScopeVariables, Locals, method_lines.ToArray(), array, null, MethodEntry.Flags.ColumnsInfoIncluded, ns_id);
		file.AddMethod(entry);
	}
}


using System;
using System.Collections;
using System.Diagnostics.SymbolStore;
using System.Reflection;
using System.Text;
using Mono.CompilerServices.SymbolWriter;

internal class SymbolWriterImpl : ISymbolWriter
{
	private MonoSymbolWriter msw;

	private int nextLocalIndex;

	private int currentToken;

	private string methodName;

	private Stack namespaceStack = new Stack();

	private bool methodOpened;

	private Hashtable documents = new Hashtable();

	private Guid guid;

	public SymbolWriterImpl(Guid guid)
	{
		this.guid = guid;
	}

	public void Close()
	{
		msw.WriteSymbolFile(guid);
	}

	public void CloseMethod()
	{
		if (methodOpened)
		{
			methodOpened = false;
			nextLocalIndex = 0;
			msw.CloseMethod();
		}
	}

	public void CloseNamespace()
	{
		namespaceStack.Pop();
		msw.CloseNamespace();
	}

	public void CloseScope(int endOffset)
	{
		msw.CloseScope(endOffset);
	}

	public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
	{
		SymbolDocumentWriterImpl symbolDocumentWriterImpl = (SymbolDocumentWriterImpl)documents[url];
		if (symbolDocumentWriterImpl == null)
		{
			SourceFileEntry source = msw.DefineDocument(url);
			symbolDocumentWriterImpl = new SymbolDocumentWriterImpl(msw.DefineCompilationUnit(source));
			documents[url] = symbolDocumentWriterImpl;
		}
		return symbolDocumentWriterImpl;
	}

	public void DefineField(SymbolToken parent, string name, FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
	{
	}

	public void DefineGlobalVariable(string name, FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3)
	{
	}

	public void DefineLocalVariable(string name, FieldAttributes attributes, byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset)
	{
		msw.DefineLocalVariable(nextLocalIndex++, name);
	}

	public void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3)
	{
	}

	public void DefineSequencePoints(ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns)
	{
		SourceFileEntry file = ((SymbolDocumentWriterImpl)document)?.Entry.SourceFile;
		for (int i = 0; i < offsets.Length; i++)
		{
			if (i <= 0 || offsets[i] != offsets[i - 1] || lines[i] != lines[i - 1] || columns[i] != columns[i - 1])
			{
				msw.MarkSequencePoint(offsets[i], file, lines[i], columns[i], is_hidden: false);
			}
		}
	}

	public void Initialize(IntPtr emitter, string filename, bool fFullBuild)
	{
		msw = new MonoSymbolWriter(filename);
	}

	public void OpenMethod(SymbolToken method)
	{
		currentToken = method.GetToken();
	}

	public void OpenNamespace(string name)
	{
		NamespaceInfo namespaceInfo = new NamespaceInfo();
		namespaceInfo.NamespaceID = -1;
		namespaceInfo.Name = name;
		namespaceStack.Push(namespaceInfo);
	}

	public int OpenScope(int startOffset)
	{
		return msw.OpenScope(startOffset);
	}

	public void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn)
	{
		int currentNamespace = GetCurrentNamespace(startDoc);
		SourceMethodImpl method = new SourceMethodImpl(methodName, currentToken, currentNamespace);
		msw.OpenMethod(((ICompileUnit)startDoc).Entry, currentNamespace, method);
		methodOpened = true;
	}

	public void SetScopeRange(int scopeID, int startOffset, int endOffset)
	{
	}

	public void SetSymAttribute(SymbolToken parent, string name, byte[] data)
	{
		if (name == "__name")
		{
			methodName = Encoding.UTF8.GetString(data);
		}
	}

	public void SetUnderlyingWriter(IntPtr underlyingWriter)
	{
	}

	public void SetUserEntryPoint(SymbolToken entryMethod)
	{
	}

	public void UsingNamespace(string fullName)
	{
		if (namespaceStack.Count == 0)
		{
			OpenNamespace("");
		}
		NamespaceInfo namespaceInfo = (NamespaceInfo)namespaceStack.Peek();
		if (namespaceInfo.NamespaceID != -1)
		{
			NamespaceInfo namespaceInfo2 = namespaceInfo;
			CloseNamespace();
			OpenNamespace(namespaceInfo2.Name);
			namespaceInfo = (NamespaceInfo)namespaceStack.Peek();
			namespaceInfo.UsingClauses = namespaceInfo2.UsingClauses;
		}
		namespaceInfo.UsingClauses.Add(fullName);
	}

	private int GetCurrentNamespace(ISymbolDocumentWriter doc)
	{
		if (namespaceStack.Count == 0)
		{
			OpenNamespace("");
		}
		NamespaceInfo namespaceInfo = (NamespaceInfo)namespaceStack.Peek();
		if (namespaceInfo.NamespaceID == -1)
		{
			string[] using_clauses = (string[])namespaceInfo.UsingClauses.ToArray(typeof(string));
			int parent = 0;
			if (namespaceStack.Count > 1)
			{
				namespaceStack.Pop();
				parent = ((NamespaceInfo)namespaceStack.Peek()).NamespaceID;
				namespaceStack.Push(namespaceInfo);
			}
			namespaceInfo.NamespaceID = msw.DefineNamespace(namespaceInfo.Name, ((ICompileUnit)doc).Entry, using_clauses, parent);
		}
		return namespaceInfo.NamespaceID;
	}
}


using System;
using System.Diagnostics.SymbolStore;
using Mono.CompilerServices.SymbolWriter;

internal class SymbolDocumentWriterImpl : ISymbolDocumentWriter, ISourceFile, ICompileUnit
{
	private CompileUnitEntry comp_unit;

	SourceFileEntry ISourceFile.Entry => comp_unit.SourceFile;

	public CompileUnitEntry Entry => comp_unit;

	public SymbolDocumentWriterImpl(CompileUnitEntry comp_unit)
	{
		this.comp_unit = comp_unit;
	}

	public void SetCheckSum(Guid algorithmId, byte[] checkSum)
	{
	}

	public void SetSource(byte[] source)
	{
	}
}


using Mono.CompilerServices.SymbolWriter;

internal class SourceMethodImpl : IMethodDef
{
	private string name;

	private int token;

	private int namespaceID;

	public string Name => name;

	public int NamespaceID => namespaceID;

	public int Token => token;

	public SourceMethodImpl(string name, int token, int namespaceID)
	{
		this.name = name;
		this.token = token;
		this.namespaceID = namespaceID;
	}
}


using System.Collections;

internal class NamespaceInfo
{
	public string Name;

	public int NamespaceID;

	public ArrayList UsingClauses = new ArrayList();
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Mdb;
using Mono.CompilerServices.SymbolWriter;

internal sealed class MdbReaderProvider : ISymbolReaderProvider
{
	public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		return new MdbReader(module, MonoSymbolFile.ReadSymbolFile(Mixin.GetMdbFileName(fileName)));
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
	{
		Mixin.CheckModule(module);
		Mixin.CheckStream(symbolStream);
		return new MdbReader(module, MonoSymbolFile.ReadSymbolFile(symbolStream));
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Mdb;
using Mono.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal sealed class MdbReader : ISymbolReader, IDisposable
{
	private readonly ModuleDefinition module;

	private readonly MonoSymbolFile symbol_file;

	private readonly Dictionary<string, Document> documents;

	public MdbReader(ModuleDefinition module, MonoSymbolFile symFile)
	{
		this.module = module;
		symbol_file = symFile;
		documents = new Dictionary<string, Document>();
	}

	public ISymbolWriterProvider GetWriterProvider()
	{
		return new MdbWriterProvider();
	}

	public bool ProcessDebugHeader(ImageDebugHeader header)
	{
		return symbol_file.Guid == module.Mvid;
	}

	public MethodDebugInformation Read(MethodDefinition method)
	{
		MetadataToken metadataToken = method.MetadataToken;
		MethodEntry methodByToken = symbol_file.GetMethodByToken(metadataToken.ToInt32());
		if (methodByToken == null)
		{
			return null;
		}
		MethodDebugInformation methodDebugInformation = new MethodDebugInformation(method);
		methodDebugInformation.code_size = ReadCodeSize(method);
		ScopeDebugInformation[] scopes = ReadScopes(methodByToken, methodDebugInformation);
		ReadLineNumbers(methodByToken, methodDebugInformation);
		ReadLocalVariables(methodByToken, scopes);
		return methodDebugInformation;
	}

	private static int ReadCodeSize(MethodDefinition method)
	{
		return method.Module.Read(method, (MethodDefinition m, MetadataReader reader) => reader.ReadCodeSize(m));
	}

	private static void ReadLocalVariables(MethodEntry entry, ScopeDebugInformation[] scopes)
	{
		LocalVariableEntry[] locals = entry.GetLocals();
		for (int i = 0; i < locals.Length; i++)
		{
			LocalVariableEntry localVariableEntry = locals[i];
			VariableDebugInformation item = new VariableDebugInformation(localVariableEntry.Index, localVariableEntry.Name);
			int blockIndex = localVariableEntry.BlockIndex;
			if (blockIndex >= 0 && blockIndex < scopes.Length)
			{
				scopes[blockIndex]?.Variables.Add(item);
			}
		}
	}

	private void ReadLineNumbers(MethodEntry entry, MethodDebugInformation info)
	{
		LineNumberTable lineNumberTable = entry.GetLineNumberTable();
		info.sequence_points = new Collection<SequencePoint>(lineNumberTable.LineNumbers.Length);
		for (int i = 0; i < lineNumberTable.LineNumbers.Length; i++)
		{
			LineNumberEntry lineNumberEntry = lineNumberTable.LineNumbers[i];
			if (i <= 0 || lineNumberTable.LineNumbers[i - 1].Offset != lineNumberEntry.Offset)
			{
				info.sequence_points.Add(LineToSequencePoint(lineNumberEntry));
			}
		}
	}

	private Document GetDocument(SourceFileEntry file)
	{
		string fileName = file.FileName;
		if (documents.TryGetValue(fileName, out var value))
		{
			return value;
		}
		value = new Document(fileName)
		{
			Hash = file.Checksum
		};
		documents.Add(fileName, value);
		return value;
	}

	private static ScopeDebugInformation[] ReadScopes(MethodEntry entry, MethodDebugInformation info)
	{
		CodeBlockEntry[] codeBlocks = entry.GetCodeBlocks();
		ScopeDebugInformation[] array = new ScopeDebugInformation[codeBlocks.Length + 1];
		ScopeDebugInformation obj = new ScopeDebugInformation
		{
			Start = new InstructionOffset(0),
			End = new InstructionOffset(info.code_size)
		};
		ScopeDebugInformation scope = obj;
		array[0] = obj;
		info.scope = scope;
		CodeBlockEntry[] array2 = codeBlocks;
		foreach (CodeBlockEntry codeBlockEntry in array2)
		{
			if (codeBlockEntry.BlockType == CodeBlockEntry.Type.Lexical || codeBlockEntry.BlockType == CodeBlockEntry.Type.CompilerGenerated)
			{
				ScopeDebugInformation scopeDebugInformation = new ScopeDebugInformation();
				scopeDebugInformation.Start = new InstructionOffset(codeBlockEntry.StartOffset);
				scopeDebugInformation.End = new InstructionOffset(codeBlockEntry.EndOffset);
				array[codeBlockEntry.Index + 1] = scopeDebugInformation;
				if (!AddScope(info.scope.Scopes, scopeDebugInformation))
				{
					info.scope.Scopes.Add(scopeDebugInformation);
				}
			}
		}
		return array;
	}

	private static bool AddScope(Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
	{
		foreach (ScopeDebugInformation scope2 in scopes)
		{
			if (scope2.HasScopes && AddScope(scope2.Scopes, scope))
			{
				return true;
			}
			if (scope.Start.Offset >= scope2.Start.Offset && scope.End.Offset <= scope2.End.Offset)
			{
				scope2.Scopes.Add(scope);
				return true;
			}
		}
		return false;
	}

	private SequencePoint LineToSequencePoint(LineNumberEntry line)
	{
		SourceFileEntry sourceFile = symbol_file.GetSourceFile(line.File);
		return new SequencePoint(line.Offset, GetDocument(sourceFile))
		{
			StartLine = line.Row,
			EndLine = line.EndRow,
			StartColumn = line.Column,
			EndColumn = line.EndColumn
		};
	}

	public void Dispose()
	{
		symbol_file.Dispose();
	}
}


using Mono.CompilerServices.SymbolWriter;

internal static class MethodEntryExtensions
{
	public static bool HasColumnInfo(this MethodEntry entry)
	{
		return (entry.MethodFlags & MethodEntry.Flags.ColumnsInfoIncluded) != 0;
	}

	public static bool HasEndInfo(this MethodEntry entry)
	{
		return (entry.MethodFlags & MethodEntry.Flags.EndInfoIncluded) != 0;
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Mdb;

internal sealed class MdbWriterProvider : ISymbolWriterProvider
{
	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		return new MdbWriter(module, fileName);
	}

	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
	{
		throw new NotImplementedException();
	}
}


using System;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Mdb;
using Mono.Collections.Generic;
using Mono.CompilerServices.SymbolWriter;

internal sealed class MdbWriter : ISymbolWriter, IDisposable
{
	private class SourceFile : ISourceFile
	{
		private readonly CompileUnitEntry compilation_unit;

		private readonly SourceFileEntry entry;

		public SourceFileEntry Entry => entry;

		public CompileUnitEntry CompilationUnit => compilation_unit;

		public SourceFile(CompileUnitEntry comp_unit, SourceFileEntry entry)
		{
			compilation_unit = comp_unit;
			this.entry = entry;
		}
	}

	private class SourceMethod : IMethodDef
	{
		private readonly MethodDefinition method;

		public string Name => method.Name;

		public int Token => method.MetadataToken.ToInt32();

		public SourceMethod(MethodDefinition method)
		{
			this.method = method;
		}
	}

	private readonly ModuleDefinition module;

	private readonly MonoSymbolWriter writer;

	private readonly Dictionary<string, SourceFile> source_files;

	public MdbWriter(ModuleDefinition module, string assembly)
	{
		this.module = module;
		writer = new MonoSymbolWriter(assembly);
		source_files = new Dictionary<string, SourceFile>();
	}

	public ISymbolReaderProvider GetReaderProvider()
	{
		return new MdbReaderProvider();
	}

	private SourceFile GetSourceFile(Document document)
	{
		string url = document.Url;
		if (source_files.TryGetValue(url, out var value))
		{
			return value;
		}
		SourceFileEntry sourceFileEntry = writer.DefineDocument(url, null, (document.Hash != null && document.Hash.Length == 16) ? document.Hash : null);
		value = new SourceFile(writer.DefineCompilationUnit(sourceFileEntry), sourceFileEntry);
		source_files.Add(url, value);
		return value;
	}

	private void Populate(Collection<SequencePoint> sequencePoints, int[] offsets, int[] startRows, int[] endRows, int[] startCols, int[] endCols, out SourceFile file)
	{
		SourceFile sourceFile = null;
		for (int i = 0; i < sequencePoints.Count; i++)
		{
			SequencePoint sequencePoint = sequencePoints[i];
			offsets[i] = sequencePoint.Offset;
			if (sourceFile == null)
			{
				sourceFile = GetSourceFile(sequencePoint.Document);
			}
			startRows[i] = sequencePoint.StartLine;
			endRows[i] = sequencePoint.EndLine;
			startCols[i] = sequencePoint.StartColumn;
			endCols[i] = sequencePoint.EndColumn;
		}
		file = sourceFile;
	}

	public void Write(MethodDebugInformation info)
	{
		SourceMethod method = new SourceMethod(info.method);
		Collection<SequencePoint> sequencePoints = info.SequencePoints;
		int count = sequencePoints.Count;
		if (count != 0)
		{
			int[] array = new int[count];
			int[] array2 = new int[count];
			int[] array3 = new int[count];
			int[] array4 = new int[count];
			int[] array5 = new int[count];
			Populate(sequencePoints, array, array2, array3, array4, array5, out var file);
			SourceMethodBuilder sourceMethodBuilder = writer.OpenMethod(file.CompilationUnit, 0, method);
			for (int i = 0; i < count; i++)
			{
				sourceMethodBuilder.MarkSequencePoint(array[i], file.CompilationUnit.SourceFile, array2[i], array4[i], array3[i], array5[i], is_hidden: false);
			}
			if (info.scope != null)
			{
				WriteRootScope(info.scope, info);
			}
			writer.CloseMethod();
		}
	}

	private void WriteRootScope(ScopeDebugInformation scope, MethodDebugInformation info)
	{
		WriteScopeVariables(scope);
		if (scope.HasScopes)
		{
			WriteScopes(scope.Scopes, info);
		}
	}

	private void WriteScope(ScopeDebugInformation scope, MethodDebugInformation info)
	{
		writer.OpenScope(scope.Start.Offset);
		WriteScopeVariables(scope);
		if (scope.HasScopes)
		{
			WriteScopes(scope.Scopes, info);
		}
		writer.CloseScope(scope.End.IsEndOfMethod ? info.code_size : scope.End.Offset);
	}

	private void WriteScopes(Collection<ScopeDebugInformation> scopes, MethodDebugInformation info)
	{
		for (int i = 0; i < scopes.Count; i++)
		{
			WriteScope(scopes[i], info);
		}
	}

	private void WriteScopeVariables(ScopeDebugInformation scope)
	{
		if (!scope.HasVariables)
		{
			return;
		}
		foreach (VariableDebugInformation variable in scope.variables)
		{
			if (!string.IsNullOrEmpty(variable.Name))
			{
				writer.DefineLocalVariable(variable.Index, variable.Name);
			}
		}
	}

	public ImageDebugHeader GetDebugHeader()
	{
		return new ImageDebugHeader();
	}

	public void Write()
	{
	}

	public void Dispose()
	{
		writer.WriteSymbolFile(module.Mvid);
	}
}


using Mono.CompilerServices.SymbolWriter;

private class SourceFile : ISourceFile
{
	private readonly CompileUnitEntry compilation_unit;

	private readonly SourceFileEntry entry;

	public SourceFileEntry Entry => entry;

	public CompileUnitEntry CompilationUnit => compilation_unit;

	public SourceFile(CompileUnitEntry comp_unit, SourceFileEntry entry)
	{
		compilation_unit = comp_unit;
		this.entry = entry;
	}
}


using Mono.CompilerServices.SymbolWriter;

private class SourceMethod : IMethodDef
{
	private readonly MethodDefinition method;

	public string Name => method.Name;

	public int Token => method.MetadataToken.ToInt32();

	public SourceMethod(MethodDefinition method)
	{
		this.method = method;
	}
}


using System;
using System.Runtime.InteropServices;

[ComImport]
[Guid("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
internal interface ISymUnmanagedDocumentWriter
{
	void SetSource(uint sourceSize, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] source);

	void SetCheckSum(Guid algorithmId, uint checkSumSize, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] checkSum);
}


using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;

[ComImport]
[Guid("0B97726E-9E6D-4f05-9A26-424022093CAA")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
internal interface ISymUnmanagedWriter2
{
	void DefineDocument([In][MarshalAs(UnmanagedType.LPWStr)] string url, [In] ref Guid langauge, [In] ref Guid languageVendor, [In] ref Guid documentType, [MarshalAs(UnmanagedType.Interface)] out ISymUnmanagedDocumentWriter pRetVal);

	void SetUserEntryPoint([In] int methodToken);

	void OpenMethod([In] int methodToken);

	void CloseMethod();

	void OpenScope([In] int startOffset, out int pRetVal);

	void CloseScope([In] int endOffset);

	void SetScopeRange_Placeholder();

	void DefineLocalVariable_Placeholder();

	void DefineParameter_Placeholder();

	void DefineField_Placeholder();

	void DefineGlobalVariable_Placeholder();

	void Close();

	void SetSymAttribute(uint parent, string name, uint data, IntPtr signature);

	void OpenNamespace([In][MarshalAs(UnmanagedType.LPWStr)] string name);

	void CloseNamespace();

	void UsingNamespace([In][MarshalAs(UnmanagedType.LPWStr)] string fullName);

	void SetMethodSourceRange_Placeholder();

	void Initialize([In][MarshalAs(UnmanagedType.IUnknown)] object emitter, [In][MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream, [In] bool fFullBuild);

	void GetDebugInfo(out ImageDebugDirectory pIDD, [In] int cData, out int pcData, [In][Out][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data);

	void DefineSequencePoints([In][MarshalAs(UnmanagedType.Interface)] ISymUnmanagedDocumentWriter document, [In] int spCount, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] offsets, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lines, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] columns, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endLines, [In][MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endColumns);

	void RemapToken_Placeholder();

	void Initialize2_Placeholder();

	void DefineConstant_Placeholder();

	void Abort_Placeholder();

	void DefineLocalVariable2([In][MarshalAs(UnmanagedType.LPWStr)] string name, [In] int attributes, [In] int sigToken, [In] int addrKind, [In] int addr1, [In] int addr2, [In] int addr3, [In] int startOffset, [In] int endOffset);

	void DefineGlobalVariable2_Placeholder();

	void DefineConstant2([In][MarshalAs(UnmanagedType.LPWStr)] string name, [In][MarshalAs(UnmanagedType.Struct)] object variant, [In] int sigToken);
}


using System;
using System.Runtime.InteropServices;
using Mono.Cecil.Pdb;

[ComImport]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
[Guid("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
internal interface IMetaDataEmit
{
	void SetModuleProps(string szName);

	void Save(string szFile, uint dwSaveFlags);

	void SaveToStream(IntPtr pIStream, uint dwSaveFlags);

	uint GetSaveSize(uint fSave);

	uint DefineTypeDef(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements);

	uint DefineNestedType(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements, uint tdEncloser);

	void SetHandler([In][MarshalAs(UnmanagedType.IUnknown)] object pUnk);

	uint DefineMethod(uint td, IntPtr zName, uint dwMethodFlags, IntPtr pvSigBlob, uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags);

	void DefineMethodImpl(uint td, uint tkBody, uint tkDecl);

	uint DefineTypeRefByName(uint tkResolutionScope, IntPtr szName);

	uint DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint tdImport, IntPtr pAssemEmit);

	uint DefineMemberRef(uint tkImport, string szName, IntPtr pvSigBlob, uint cbSigBlob);

	uint DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint mbMember, IntPtr pAssemEmit, uint tkParent);

	uint DefineEvent(uint td, string szEvent, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr rmdOtherMethods);

	void SetClassLayout(uint td, uint dwPackSize, IntPtr rFieldOffsets, uint ulClassSize);

	void DeleteClassLayout(uint td);

	void SetFieldMarshal(uint tk, IntPtr pvNativeType, uint cbNativeType);

	void DeleteFieldMarshal(uint tk);

	uint DefinePermissionSet(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission);

	void SetRVA(uint md, uint ulRVA);

	uint GetTokenFromSig(IntPtr pvSig, uint cbSig);

	uint DefineModuleRef(string szName);

	void SetParent(uint mr, uint tk);

	uint GetTokenFromTypeSpec(IntPtr pvSig, uint cbSig);

	void SaveToMemory(IntPtr pbData, uint cbData);

	uint DefineUserString(string szString, uint cchString);

	void DeleteToken(uint tkObj);

	void SetMethodProps(uint md, uint dwMethodFlags, uint ulCodeRVA, uint dwImplFlags);

	void SetTypeDefProps(uint td, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements);

	void SetEventProps(uint ev, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr rmdOtherMethods);

	uint SetPermissionSetProps(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission);

	void DefinePinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL);

	void SetPinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL);

	void DeletePinvokeMap(uint tk);

	uint DefineCustomAttribute(uint tkObj, uint tkType, IntPtr pCustomAttribute, uint cbCustomAttribute);

	void SetCustomAttributeValue(uint pcv, IntPtr pCustomAttribute, uint cbCustomAttribute);

	uint DefineField(uint td, string szName, uint dwFieldFlags, IntPtr pvSigBlob, uint cbSigBlob, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue);

	uint DefineProperty(uint td, string szProperty, uint dwPropFlags, IntPtr pvSig, uint cbSig, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr rmdOtherMethods);

	uint DefineParam(uint md, uint ulParamSeq, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue);

	void SetFieldProps(uint fd, uint dwFieldFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue);

	void SetPropertyProps(uint pr, uint dwPropFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr rmdOtherMethods);

	void SetParamProps(uint pd, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue);

	uint DefineSecurityAttributeSet(uint tkObj, IntPtr rSecAttrs, uint cSecAttrs);

	void ApplyEditAndContinue([MarshalAs(UnmanagedType.IUnknown)] object pImport);

	uint TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, uint cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, uint cbTranslatedSigMax);

	void SetMethodImplFlags(uint md, uint dwImplFlags);

	void SetFieldRVA(uint fd, uint ulRVA);

	void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, [MarshalAs(UnmanagedType.IUnknown)] object pHandler);

	void MergeEnd();
}


using System;
using System.Runtime.InteropServices;
using System.Text;

[ComImport]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
[Guid("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
internal interface IMetaDataImport
{
	[PreserveSig]
	void CloseEnum(uint hEnum);

	uint CountEnum(uint hEnum);

	void ResetEnum(uint hEnum, uint ulPos);

	uint EnumTypeDefs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeDefs, uint cMax);

	uint EnumInterfaceImpls(ref uint phEnum, uint td, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rImpls, uint cMax);

	uint EnumTypeRefs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeRefs, uint cMax);

	uint FindTypeDefByName(string szTypeDef, uint tkEnclosingClass);

	Guid GetScopeProps(StringBuilder szName, uint cchName, out uint pchName);

	uint GetModuleFromScope();

	[PreserveSig]
	unsafe uint GetTypeDefProps(uint td, char* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends);

	uint GetInterfaceImplProps(uint iiImpl, out uint pClass);

	uint GetTypeRefProps(uint tr, out uint ptkResolutionScope, StringBuilder szName, uint cchName);

	uint ResolveTypeRef(uint tr, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ppIScope);

	uint EnumMembers(ref uint phEnum, uint cl, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMembers, uint cMax);

	uint EnumMembersWithName(ref uint phEnum, uint cl, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMembers, uint cMax);

	uint EnumMethods(ref uint phEnum, uint cl, IntPtr rMethods, uint cMax);

	uint EnumMethodsWithName(ref uint phEnum, uint cl, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethods, uint cMax);

	uint EnumFields(ref uint phEnum, uint cl, IntPtr rFields, uint cMax);

	uint EnumFieldsWithName(ref uint phEnum, uint cl, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rFields, uint cMax);

	uint EnumParams(ref uint phEnum, uint mb, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rParams, uint cMax);

	uint EnumMemberRefs(ref uint phEnum, uint tkParent, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rMemberRefs, uint cMax);

	uint EnumMethodImpls(ref uint phEnum, uint td, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethodBody, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rMethodDecl, uint cMax);

	uint EnumPermissionSets(ref uint phEnum, uint tk, uint dwActions, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rPermission, uint cMax);

	uint FindMember(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);

	uint FindMethod(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);

	uint FindField(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);

	uint FindMemberRef(uint td, string szName, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] pvSigBlob, uint cbSigBlob);

	[PreserveSig]
	unsafe uint GetMethodProps(uint mb, uint* pClass, char* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, uint* pulCodeRVA, uint* pdwImplFlags);

	uint GetMemberRefProps(uint mr, ref uint ptk, StringBuilder szMember, uint cchMember, out uint pchMember, out IntPtr ppvSigBlob);

	uint EnumProperties(ref uint phEnum, uint td, IntPtr rProperties, uint cMax);

	uint EnumEvents(ref uint phEnum, uint td, IntPtr rEvents, uint cMax);

	uint GetEventProps(uint ev, out uint pClass, StringBuilder szEvent, uint cchEvent, out uint pchEvent, out uint pdwEventFlags, out uint ptkEventType, out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 11)] uint[] rmdOtherMethod, uint cMax);

	uint EnumMethodSemantics(ref uint phEnum, uint mb, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] uint[] rEventProp, uint cMax);

	uint GetMethodSemantics(uint mb, uint tkEventProp);

	uint GetClassLayout(uint td, out uint pdwPackSize, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] IntPtr rFieldOffset, uint cMax, out uint pcFieldOffset);

	uint GetFieldMarshal(uint tk, out IntPtr ppvNativeType);

	uint GetRVA(uint tk, out uint pulCodeRVA);

	uint GetPermissionSetProps(uint pm, out uint pdwAction, out IntPtr ppvPermission);

	uint GetSigFromToken(uint mdSig, out IntPtr ppvSig);

	uint GetModuleRefProps(uint mur, StringBuilder szName, uint cchName);

	uint EnumModuleRefs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rModuleRefs, uint cmax);

	uint GetTypeSpecFromToken(uint typespec, out IntPtr ppvSig);

	uint GetNameFromToken(uint tk);

	uint EnumUnresolvedMethods(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rMethods, uint cMax);

	uint GetUserString(uint stk, StringBuilder szString, uint cchString);

	uint GetPinvokeMap(uint tk, out uint pdwMappingFlags, StringBuilder szImportName, uint cchImportName, out uint pchImportName);

	uint EnumSignatures(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rSignatures, uint cmax);

	uint EnumTypeSpecs(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rTypeSpecs, uint cmax);

	uint EnumUserStrings(ref uint phEnum, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] uint[] rStrings, uint cmax);

	[PreserveSig]
	int GetParamForMethodIndex(uint md, uint ulParamSeq, out uint pParam);

	uint EnumCustomAttributes(ref uint phEnum, uint tk, uint tkType, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] uint[] rCustomAttributes, uint cMax);

	uint GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType, out IntPtr ppBlob);

	uint FindTypeRef(uint tkResolutionScope, string szName);

	uint GetMemberProps(uint mb, out uint pClass, StringBuilder szMember, uint cchMember, out uint pchMember, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pulCodeRVA, out uint pdwImplFlags, out uint pdwCPlusTypeFlag, out IntPtr ppValue);

	uint GetFieldProps(uint mb, out uint pClass, StringBuilder szField, uint cchField, out uint pchField, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pdwCPlusTypeFlag, out IntPtr ppValue);

	uint GetPropertyProps(uint prop, out uint pClass, StringBuilder szProperty, uint cchProperty, out uint pchProperty, out uint pdwPropFlags, out IntPtr ppvSig, out uint pbSig, out uint pdwCPlusTypeFlag, out IntPtr ppDefaultValue, out uint pcchDefaultValue, out uint pmdSetter, out uint pmdGetter, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 14)] uint[] rmdOtherMethod, uint cMax);

	uint GetParamProps(uint tk, out uint pmd, out uint pulSequence, StringBuilder szName, uint cchName, out uint pchName, out uint pdwAttr, out uint pdwCPlusTypeFlag, out IntPtr ppValue);

	uint GetCustomAttributeByName(uint tkObj, string szName, out IntPtr ppData);

	[PreserveSig]
	[return: MarshalAs(UnmanagedType.Bool)]
	bool IsValidToken(uint tk);

	[PreserveSig]
	unsafe uint GetNestedClassProps(uint tdNestedClass, uint* ptdEnclosingClass);

	uint GetNativeCallConvFromSig(IntPtr pvSig, uint cbSig);

	int IsGlobal(uint pd);
}


using System;
using System.Collections.Generic;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Pdb;

internal class ModuleMetadata : IMetaDataEmit, IMetaDataImport
{
	private readonly ModuleDefinition module;

	private Dictionary<uint, TypeDefinition> types;

	private Dictionary<uint, MethodDefinition> methods;

	private const uint S_OK = 0u;

	private const uint E_FAIL = 2147500037u;

	public ModuleMetadata(ModuleDefinition module)
	{
		this.module = module;
	}

	private bool TryGetType(uint token, out TypeDefinition type)
	{
		if (types == null)
		{
			InitializeMetadata(module);
		}
		return types.TryGetValue(token, out type);
	}

	private bool TryGetMethod(uint token, out MethodDefinition method)
	{
		if (methods == null)
		{
			InitializeMetadata(module);
		}
		return methods.TryGetValue(token, out method);
	}

	private void InitializeMetadata(ModuleDefinition module)
	{
		types = new Dictionary<uint, TypeDefinition>();
		methods = new Dictionary<uint, MethodDefinition>();
		foreach (TypeDefinition type in module.GetTypes())
		{
			types.Add(type.MetadataToken.ToUInt32(), type);
			InitializeMethods(type);
		}
	}

	private void InitializeMethods(TypeDefinition type)
	{
		foreach (MethodDefinition method in type.Methods)
		{
			methods.Add(method.MetadataToken.ToUInt32(), method);
		}
	}

	public void SetModuleProps(string szName)
	{
		throw new NotImplementedException();
	}

	public void Save(string szFile, uint dwSaveFlags)
	{
		throw new NotImplementedException();
	}

	public void SaveToStream(IntPtr pIStream, uint dwSaveFlags)
	{
		throw new NotImplementedException();
	}

	public uint GetSaveSize(uint fSave)
	{
		throw new NotImplementedException();
	}

	public uint DefineTypeDef(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements)
	{
		throw new NotImplementedException();
	}

	public uint DefineNestedType(IntPtr szTypeDef, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements, uint tdEncloser)
	{
		throw new NotImplementedException();
	}

	public void SetHandler(object pUnk)
	{
		throw new NotImplementedException();
	}

	public uint DefineMethod(uint td, IntPtr zName, uint dwMethodFlags, IntPtr pvSigBlob, uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags)
	{
		throw new NotImplementedException();
	}

	public void DefineMethodImpl(uint td, uint tkBody, uint tkDecl)
	{
		throw new NotImplementedException();
	}

	public uint DefineTypeRefByName(uint tkResolutionScope, IntPtr szName)
	{
		throw new NotImplementedException();
	}

	public uint DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint tdImport, IntPtr pAssemEmit)
	{
		throw new NotImplementedException();
	}

	public uint DefineMemberRef(uint tkImport, string szName, IntPtr pvSigBlob, uint cbSigBlob)
	{
		throw new NotImplementedException();
	}

	public uint DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint mbMember, IntPtr pAssemEmit, uint tkParent)
	{
		throw new NotImplementedException();
	}

	public uint DefineEvent(uint td, string szEvent, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr rmdOtherMethods)
	{
		throw new NotImplementedException();
	}

	public void SetClassLayout(uint td, uint dwPackSize, IntPtr rFieldOffsets, uint ulClassSize)
	{
		throw new NotImplementedException();
	}

	public void DeleteClassLayout(uint td)
	{
		throw new NotImplementedException();
	}

	public void SetFieldMarshal(uint tk, IntPtr pvNativeType, uint cbNativeType)
	{
		throw new NotImplementedException();
	}

	public void DeleteFieldMarshal(uint tk)
	{
		throw new NotImplementedException();
	}

	public uint DefinePermissionSet(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission)
	{
		throw new NotImplementedException();
	}

	public void SetRVA(uint md, uint ulRVA)
	{
		throw new NotImplementedException();
	}

	public uint GetTokenFromSig(IntPtr pvSig, uint cbSig)
	{
		throw new NotImplementedException();
	}

	public uint DefineModuleRef(string szName)
	{
		throw new NotImplementedException();
	}

	public void SetParent(uint mr, uint tk)
	{
		throw new NotImplementedException();
	}

	public uint GetTokenFromTypeSpec(IntPtr pvSig, uint cbSig)
	{
		throw new NotImplementedException();
	}

	public void SaveToMemory(IntPtr pbData, uint cbData)
	{
		throw new NotImplementedException();
	}

	public uint DefineUserString(string szString, uint cchString)
	{
		throw new NotImplementedException();
	}

	public void DeleteToken(uint tkObj)
	{
		throw new NotImplementedException();
	}

	public void SetMethodProps(uint md, uint dwMethodFlags, uint ulCodeRVA, uint dwImplFlags)
	{
		throw new NotImplementedException();
	}

	public void SetTypeDefProps(uint td, uint dwTypeDefFlags, uint tkExtends, IntPtr rtkImplements)
	{
		throw new NotImplementedException();
	}

	public void SetEventProps(uint ev, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, IntPtr rmdOtherMethods)
	{
		throw new NotImplementedException();
	}

	public uint SetPermissionSetProps(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission)
	{
		throw new NotImplementedException();
	}

	public void DefinePinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL)
	{
		throw new NotImplementedException();
	}

	public void SetPinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL)
	{
		throw new NotImplementedException();
	}

	public void DeletePinvokeMap(uint tk)
	{
		throw new NotImplementedException();
	}

	public uint DefineCustomAttribute(uint tkObj, uint tkType, IntPtr pCustomAttribute, uint cbCustomAttribute)
	{
		throw new NotImplementedException();
	}

	public void SetCustomAttributeValue(uint pcv, IntPtr pCustomAttribute, uint cbCustomAttribute)
	{
		throw new NotImplementedException();
	}

	public uint DefineField(uint td, string szName, uint dwFieldFlags, IntPtr pvSigBlob, uint cbSigBlob, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
	{
		throw new NotImplementedException();
	}

	public uint DefineProperty(uint td, string szProperty, uint dwPropFlags, IntPtr pvSig, uint cbSig, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr rmdOtherMethods)
	{
		throw new NotImplementedException();
	}

	public uint DefineParam(uint md, uint ulParamSeq, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
	{
		throw new NotImplementedException();
	}

	public void SetFieldProps(uint fd, uint dwFieldFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
	{
		throw new NotImplementedException();
	}

	public void SetPropertyProps(uint pr, uint dwPropFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, IntPtr rmdOtherMethods)
	{
		throw new NotImplementedException();
	}

	public void SetParamProps(uint pd, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue)
	{
		throw new NotImplementedException();
	}

	public uint DefineSecurityAttributeSet(uint tkObj, IntPtr rSecAttrs, uint cSecAttrs)
	{
		throw new NotImplementedException();
	}

	public void ApplyEditAndContinue(object pImport)
	{
		throw new NotImplementedException();
	}

	public uint TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, uint cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, uint cbTranslatedSigMax)
	{
		throw new NotImplementedException();
	}

	public void SetMethodImplFlags(uint md, uint dwImplFlags)
	{
		throw new NotImplementedException();
	}

	public void SetFieldRVA(uint fd, uint ulRVA)
	{
		throw new NotImplementedException();
	}

	public void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler)
	{
		throw new NotImplementedException();
	}

	public void MergeEnd()
	{
		throw new NotImplementedException();
	}

	public void CloseEnum(uint hEnum)
	{
		throw new NotImplementedException();
	}

	public uint CountEnum(uint hEnum)
	{
		throw new NotImplementedException();
	}

	public void ResetEnum(uint hEnum, uint ulPos)
	{
		throw new NotImplementedException();
	}

	public uint EnumTypeDefs(ref uint phEnum, uint[] rTypeDefs, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumInterfaceImpls(ref uint phEnum, uint td, uint[] rImpls, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumTypeRefs(ref uint phEnum, uint[] rTypeRefs, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint FindTypeDefByName(string szTypeDef, uint tkEnclosingClass)
	{
		throw new NotImplementedException();
	}

	public Guid GetScopeProps(StringBuilder szName, uint cchName, out uint pchName)
	{
		throw new NotImplementedException();
	}

	public uint GetModuleFromScope()
	{
		throw new NotImplementedException();
	}

	public unsafe uint GetTypeDefProps(uint td, char* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends)
	{
		if (!TryGetType(td, out var type))
		{
			return 2147500037u;
		}
		WriteNameBuffer(type.IsNested ? type.Name : type.FullName, szTypeDef, cchTypeDef, pchTypeDef);
		if (pdwTypeDefFlags != null)
		{
			*pdwTypeDefFlags = (uint)type.Attributes;
		}
		if (ptkExtends != null)
		{
			*ptkExtends = ((type.BaseType != null) ? type.BaseType.MetadataToken.ToUInt32() : 0u);
		}
		return 0u;
	}

	public uint GetInterfaceImplProps(uint iiImpl, out uint pClass)
	{
		throw new NotImplementedException();
	}

	public uint GetTypeRefProps(uint tr, out uint ptkResolutionScope, StringBuilder szName, uint cchName)
	{
		throw new NotImplementedException();
	}

	public uint ResolveTypeRef(uint tr, ref Guid riid, out object ppIScope)
	{
		throw new NotImplementedException();
	}

	public uint EnumMembers(ref uint phEnum, uint cl, uint[] rMembers, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumMembersWithName(ref uint phEnum, uint cl, string szName, uint[] rMembers, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumMethods(ref uint phEnum, uint cl, IntPtr rMethods, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumMethodsWithName(ref uint phEnum, uint cl, string szName, uint[] rMethods, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumFields(ref uint phEnum, uint cl, IntPtr rFields, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumFieldsWithName(ref uint phEnum, uint cl, string szName, uint[] rFields, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumParams(ref uint phEnum, uint mb, uint[] rParams, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumMemberRefs(ref uint phEnum, uint tkParent, uint[] rMemberRefs, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumMethodImpls(ref uint phEnum, uint td, uint[] rMethodBody, uint[] rMethodDecl, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumPermissionSets(ref uint phEnum, uint tk, uint dwActions, uint[] rPermission, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint FindMember(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
	{
		throw new NotImplementedException();
	}

	public uint FindMethod(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
	{
		throw new NotImplementedException();
	}

	public uint FindField(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
	{
		throw new NotImplementedException();
	}

	public uint FindMemberRef(uint td, string szName, byte[] pvSigBlob, uint cbSigBlob)
	{
		throw new NotImplementedException();
	}

	public unsafe uint GetMethodProps(uint mb, uint* pClass, char* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, uint* pulCodeRVA, uint* pdwImplFlags)
	{
		if (!TryGetMethod(mb, out var method))
		{
			return 2147500037u;
		}
		if (pClass != null)
		{
			*pClass = method.DeclaringType.MetadataToken.ToUInt32();
		}
		WriteNameBuffer(method.Name, szMethod, cchMethod, pchMethod);
		if (pdwAttr != null)
		{
			*pdwAttr = (uint)method.Attributes;
		}
		if (pulCodeRVA != null)
		{
			*pulCodeRVA = (uint)method.RVA;
		}
		if (pdwImplFlags != null)
		{
			*pdwImplFlags = (uint)method.ImplAttributes;
		}
		return 0u;
	}

	private unsafe static void WriteNameBuffer(string name, char* buffer, uint bufferLength, uint* actualLength)
	{
		long num = Math.Min(name.Length, bufferLength - 1);
		if (actualLength != null)
		{
			*actualLength = (uint)num;
		}
		if (buffer != null && bufferLength != 0)
		{
			for (int i = 0; i < num; i++)
			{
				buffer[i] = name[i];
			}
			buffer[num + 1] = '\0';
		}
	}

	public uint GetMemberRefProps(uint mr, ref uint ptk, StringBuilder szMember, uint cchMember, out uint pchMember, out IntPtr ppvSigBlob)
	{
		throw new NotImplementedException();
	}

	public uint EnumProperties(ref uint phEnum, uint td, IntPtr rProperties, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumEvents(ref uint phEnum, uint td, IntPtr rEvents, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint GetEventProps(uint ev, out uint pClass, StringBuilder szEvent, uint cchEvent, out uint pchEvent, out uint pdwEventFlags, out uint ptkEventType, out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire, uint[] rmdOtherMethod, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint EnumMethodSemantics(ref uint phEnum, uint mb, uint[] rEventProp, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint GetMethodSemantics(uint mb, uint tkEventProp)
	{
		throw new NotImplementedException();
	}

	public uint GetClassLayout(uint td, out uint pdwPackSize, IntPtr rFieldOffset, uint cMax, out uint pcFieldOffset)
	{
		throw new NotImplementedException();
	}

	public uint GetFieldMarshal(uint tk, out IntPtr ppvNativeType)
	{
		throw new NotImplementedException();
	}

	public uint GetRVA(uint tk, out uint pulCodeRVA)
	{
		throw new NotImplementedException();
	}

	public uint GetPermissionSetProps(uint pm, out uint pdwAction, out IntPtr ppvPermission)
	{
		throw new NotImplementedException();
	}

	public uint GetSigFromToken(uint mdSig, out IntPtr ppvSig)
	{
		throw new NotImplementedException();
	}

	public uint GetModuleRefProps(uint mur, StringBuilder szName, uint cchName)
	{
		throw new NotImplementedException();
	}

	public uint EnumModuleRefs(ref uint phEnum, uint[] rModuleRefs, uint cmax)
	{
		throw new NotImplementedException();
	}

	public uint GetTypeSpecFromToken(uint typespec, out IntPtr ppvSig)
	{
		throw new NotImplementedException();
	}

	public uint GetNameFromToken(uint tk)
	{
		throw new NotImplementedException();
	}

	public uint EnumUnresolvedMethods(ref uint phEnum, uint[] rMethods, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint GetUserString(uint stk, StringBuilder szString, uint cchString)
	{
		throw new NotImplementedException();
	}

	public uint GetPinvokeMap(uint tk, out uint pdwMappingFlags, StringBuilder szImportName, uint cchImportName, out uint pchImportName)
	{
		throw new NotImplementedException();
	}

	public uint EnumSignatures(ref uint phEnum, uint[] rSignatures, uint cmax)
	{
		throw new NotImplementedException();
	}

	public uint EnumTypeSpecs(ref uint phEnum, uint[] rTypeSpecs, uint cmax)
	{
		throw new NotImplementedException();
	}

	public uint EnumUserStrings(ref uint phEnum, uint[] rStrings, uint cmax)
	{
		throw new NotImplementedException();
	}

	public int GetParamForMethodIndex(uint md, uint ulParamSeq, out uint pParam)
	{
		throw new NotImplementedException();
	}

	public uint EnumCustomAttributes(ref uint phEnum, uint tk, uint tkType, uint[] rCustomAttributes, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType, out IntPtr ppBlob)
	{
		throw new NotImplementedException();
	}

	public uint FindTypeRef(uint tkResolutionScope, string szName)
	{
		throw new NotImplementedException();
	}

	public uint GetMemberProps(uint mb, out uint pClass, StringBuilder szMember, uint cchMember, out uint pchMember, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pulCodeRVA, out uint pdwImplFlags, out uint pdwCPlusTypeFlag, out IntPtr ppValue)
	{
		throw new NotImplementedException();
	}

	public uint GetFieldProps(uint mb, out uint pClass, StringBuilder szField, uint cchField, out uint pchField, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pdwCPlusTypeFlag, out IntPtr ppValue)
	{
		throw new NotImplementedException();
	}

	public uint GetPropertyProps(uint prop, out uint pClass, StringBuilder szProperty, uint cchProperty, out uint pchProperty, out uint pdwPropFlags, out IntPtr ppvSig, out uint pbSig, out uint pdwCPlusTypeFlag, out IntPtr ppDefaultValue, out uint pcchDefaultValue, out uint pmdSetter, out uint pmdGetter, uint[] rmdOtherMethod, uint cMax)
	{
		throw new NotImplementedException();
	}

	public uint GetParamProps(uint tk, out uint pmd, out uint pulSequence, StringBuilder szName, uint cchName, out uint pchName, out uint pdwAttr, out uint pdwCPlusTypeFlag, out IntPtr ppValue)
	{
		throw new NotImplementedException();
	}

	public uint GetCustomAttributeByName(uint tkObj, string szName, out IntPtr ppData)
	{
		throw new NotImplementedException();
	}

	public bool IsValidToken(uint tk)
	{
		throw new NotImplementedException();
	}

	public unsafe uint GetNestedClassProps(uint tdNestedClass, uint* ptdEnclosingClass)
	{
		if (!TryGetType(tdNestedClass, out var type))
		{
			return 2147500037u;
		}
		if (ptdEnclosingClass != null)
		{
			*ptdEnclosingClass = (type.IsNested ? type.DeclaringType.MetadataToken.ToUInt32() : 0u);
		}
		return 0u;
	}

	public uint GetNativeCallConvFromSig(IntPtr pvSig, uint cbSig)
	{
		throw new NotImplementedException();
	}

	public int IsGlobal(uint pd)
	{
		throw new NotImplementedException();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Cci.Pdb;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;
using Mono.Collections.Generic;

internal class NativePdbReader : ISymbolReader, IDisposable
{
	private readonly Disposable<Stream> pdb_file;

	private readonly Dictionary<string, Document> documents = new Dictionary<string, Document>();

	private readonly Dictionary<uint, PdbFunction> functions = new Dictionary<uint, PdbFunction>();

	private readonly Dictionary<PdbScope, ImportDebugInformation> imports = new Dictionary<PdbScope, ImportDebugInformation>();

	internal NativePdbReader(Disposable<Stream> file)
	{
		pdb_file = file;
	}

	public ISymbolWriterProvider GetWriterProvider()
	{
		return new NativePdbWriterProvider();
	}

	public bool ProcessDebugHeader(ImageDebugHeader header)
	{
		if (!header.HasEntries)
		{
			return false;
		}
		using (pdb_file)
		{
			PdbInfo pdbInfo = PdbFile.LoadFunctions(pdb_file.value);
			ImageDebugHeaderEntry[] entries = header.Entries;
			foreach (ImageDebugHeaderEntry entry in entries)
			{
				if (IsMatchingEntry(pdbInfo, entry))
				{
					PdbFunction[] array = pdbInfo.Functions;
					foreach (PdbFunction pdbFunction in array)
					{
						functions.Add(pdbFunction.token, pdbFunction);
					}
					return true;
				}
			}
		}
		return false;
	}

	private static bool IsMatchingEntry(PdbInfo info, ImageDebugHeaderEntry entry)
	{
		if (entry.Directory.Type != ImageDebugType.CodeView)
		{
			return false;
		}
		byte[] data = entry.Data;
		if (data.Length < 24)
		{
			return false;
		}
		if (ReadInt32(data, 0) != 1396986706)
		{
			return false;
		}
		byte[] array = new byte[16];
		Buffer.BlockCopy(data, 4, array, 0, 16);
		return info.Guid == new Guid(array);
	}

	private static int ReadInt32(byte[] bytes, int start)
	{
		return bytes[start] | (bytes[start + 1] << 8) | (bytes[start + 2] << 16) | (bytes[start + 3] << 24);
	}

	public MethodDebugInformation Read(MethodDefinition method)
	{
		MetadataToken metadataToken = method.MetadataToken;
		if (!functions.TryGetValue(metadataToken.ToUInt32(), out var value))
		{
			return null;
		}
		MethodDebugInformation methodDebugInformation = new MethodDebugInformation(method);
		ReadSequencePoints(value, methodDebugInformation);
		methodDebugInformation.scope = ((!value.scopes.IsNullOrEmpty()) ? ReadScopeAndLocals(value.scopes[0], methodDebugInformation) : new ScopeDebugInformation
		{
			Start = new InstructionOffset(0),
			End = new InstructionOffset((int)value.length)
		});
		if (value.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != method.MetadataToken.ToUInt32() && value.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != 0)
		{
			methodDebugInformation.scope.import = GetImport(value.tokenOfMethodWhoseUsingInfoAppliesToThisMethod, method.Module);
		}
		if (value.scopes.Length > 1)
		{
			for (int i = 1; i < value.scopes.Length; i++)
			{
				ScopeDebugInformation scopeDebugInformation = ReadScopeAndLocals(value.scopes[i], methodDebugInformation);
				if (!AddScope(methodDebugInformation.scope.Scopes, scopeDebugInformation))
				{
					methodDebugInformation.scope.Scopes.Add(scopeDebugInformation);
				}
			}
		}
		if (value.iteratorScopes != null)
		{
			StateMachineScopeDebugInformation stateMachineScopeDebugInformation = new StateMachineScopeDebugInformation();
			foreach (ILocalScope iteratorScope in value.iteratorScopes)
			{
				stateMachineScopeDebugInformation.Scopes.Add(new StateMachineScope((int)iteratorScope.Offset, (int)(iteratorScope.Offset + iteratorScope.Length + 1)));
			}
			methodDebugInformation.CustomDebugInformations.Add(stateMachineScopeDebugInformation);
		}
		if (value.synchronizationInformation != null)
		{
			AsyncMethodBodyDebugInformation asyncMethodBodyDebugInformation = new AsyncMethodBodyDebugInformation((int)value.synchronizationInformation.GeneratedCatchHandlerOffset);
			PdbSynchronizationPoint[] synchronizationPoints = value.synchronizationInformation.synchronizationPoints;
			foreach (PdbSynchronizationPoint pdbSynchronizationPoint in synchronizationPoints)
			{
				asyncMethodBodyDebugInformation.Yields.Add(new InstructionOffset((int)pdbSynchronizationPoint.SynchronizeOffset));
				asyncMethodBodyDebugInformation.Resumes.Add(new InstructionOffset((int)pdbSynchronizationPoint.ContinuationOffset));
				asyncMethodBodyDebugInformation.ResumeMethods.Add(method);
			}
			methodDebugInformation.CustomDebugInformations.Add(asyncMethodBodyDebugInformation);
			methodDebugInformation.StateMachineKickOffMethod = (MethodDefinition)method.Module.LookupToken((int)value.synchronizationInformation.kickoffMethodToken);
		}
		return methodDebugInformation;
	}

	private Collection<ScopeDebugInformation> ReadScopeAndLocals(PdbScope[] scopes, MethodDebugInformation info)
	{
		Collection<ScopeDebugInformation> collection = new Collection<ScopeDebugInformation>(scopes.Length);
		foreach (PdbScope pdbScope in scopes)
		{
			if (pdbScope != null)
			{
				collection.Add(ReadScopeAndLocals(pdbScope, info));
			}
		}
		return collection;
	}

	private ScopeDebugInformation ReadScopeAndLocals(PdbScope scope, MethodDebugInformation info)
	{
		ScopeDebugInformation scopeDebugInformation = new ScopeDebugInformation();
		scopeDebugInformation.Start = new InstructionOffset((int)scope.offset);
		scopeDebugInformation.End = new InstructionOffset((int)(scope.offset + scope.length));
		if (!scope.slots.IsNullOrEmpty())
		{
			scopeDebugInformation.variables = new Collection<VariableDebugInformation>(scope.slots.Length);
			PdbSlot[] slots = scope.slots;
			foreach (PdbSlot pdbSlot in slots)
			{
				if ((pdbSlot.flags & 1) == 0)
				{
					VariableDebugInformation variableDebugInformation = new VariableDebugInformation((int)pdbSlot.slot, pdbSlot.name);
					if ((pdbSlot.flags & 4) != 0)
					{
						variableDebugInformation.IsDebuggerHidden = true;
					}
					scopeDebugInformation.variables.Add(variableDebugInformation);
				}
			}
		}
		if (!scope.constants.IsNullOrEmpty())
		{
			scopeDebugInformation.constants = new Collection<ConstantDebugInformation>(scope.constants.Length);
			PdbConstant[] constants = scope.constants;
			foreach (PdbConstant pdbConstant in constants)
			{
				TypeReference typeReference = info.Method.Module.Read(pdbConstant, (PdbConstant c, MetadataReader r) => r.ReadConstantSignature(new MetadataToken(c.token)));
				object obj = pdbConstant.value;
				if (typeReference != null && !typeReference.IsValueType && obj is int && (int)obj == 0)
				{
					obj = null;
				}
				scopeDebugInformation.constants.Add(new ConstantDebugInformation(pdbConstant.name, typeReference, obj));
			}
		}
		if (!scope.usedNamespaces.IsNullOrEmpty())
		{
			if (imports.TryGetValue(scope, out var value))
			{
				scopeDebugInformation.import = value;
			}
			else
			{
				value = GetImport(scope, info.Method.Module);
				imports.Add(scope, value);
				scopeDebugInformation.import = value;
			}
		}
		scopeDebugInformation.scopes = ReadScopeAndLocals(scope.scopes, info);
		return scopeDebugInformation;
	}

	private static bool AddScope(Collection<ScopeDebugInformation> scopes, ScopeDebugInformation scope)
	{
		foreach (ScopeDebugInformation scope2 in scopes)
		{
			if (scope2.HasScopes && AddScope(scope2.Scopes, scope))
			{
				return true;
			}
			if (scope.Start.Offset >= scope2.Start.Offset && scope.End.Offset <= scope2.End.Offset)
			{
				scope2.Scopes.Add(scope);
				return true;
			}
		}
		return false;
	}

	private ImportDebugInformation GetImport(uint token, ModuleDefinition module)
	{
		if (!functions.TryGetValue(token, out var value))
		{
			return null;
		}
		if (value.scopes.Length != 1)
		{
			return null;
		}
		PdbScope pdbScope = value.scopes[0];
		if (imports.TryGetValue(pdbScope, out var value2))
		{
			return value2;
		}
		value2 = GetImport(pdbScope, module);
		imports.Add(pdbScope, value2);
		return value2;
	}

	private static ImportDebugInformation GetImport(PdbScope scope, ModuleDefinition module)
	{
		if (scope.usedNamespaces.IsNullOrEmpty())
		{
			return null;
		}
		ImportDebugInformation importDebugInformation = new ImportDebugInformation();
		string[] usedNamespaces = scope.usedNamespaces;
		foreach (string text in usedNamespaces)
		{
			if (string.IsNullOrEmpty(text))
			{
				continue;
			}
			ImportTarget importTarget = null;
			string text2 = text.Substring(1);
			switch (text[0])
			{
			case 'U':
				importTarget = new ImportTarget(ImportTargetKind.ImportNamespace)
				{
					@namespace = text2
				};
				break;
			case 'T':
			{
				TypeReference typeReference2 = TypeParser.ParseType(module, text2);
				if (typeReference2 != null)
				{
					importTarget = new ImportTarget(ImportTargetKind.ImportType)
					{
						type = typeReference2
					};
				}
				break;
			}
			case 'A':
			{
				int num = text.IndexOf(' ');
				if (num < 0)
				{
					importTarget = new ImportTarget(ImportTargetKind.ImportNamespace)
					{
						@namespace = text
					};
					break;
				}
				string alias = text.Substring(1, num - 1);
				string text3 = text.Substring(num + 2);
				switch (text[num + 1])
				{
				case 'U':
					importTarget = new ImportTarget(ImportTargetKind.DefineNamespaceAlias)
					{
						alias = alias,
						@namespace = text3
					};
					break;
				case 'T':
				{
					TypeReference typeReference = TypeParser.ParseType(module, text3);
					if (typeReference != null)
					{
						importTarget = new ImportTarget(ImportTargetKind.DefineTypeAlias)
						{
							alias = alias,
							type = typeReference
						};
					}
					break;
				}
				}
				break;
			}
			case '*':
				importTarget = new ImportTarget(ImportTargetKind.ImportNamespace)
				{
					@namespace = text2
				};
				break;
			case '@':
				if (!text2.StartsWith("P:"))
				{
					continue;
				}
				importTarget = new ImportTarget(ImportTargetKind.ImportNamespace)
				{
					@namespace = text2.Substring(2)
				};
				break;
			}
			if (importTarget != null)
			{
				importDebugInformation.Targets.Add(importTarget);
			}
		}
		return importDebugInformation;
	}

	private void ReadSequencePoints(PdbFunction function, MethodDebugInformation info)
	{
		if (function.lines != null)
		{
			info.sequence_points = new Collection<SequencePoint>();
			PdbLines[] lines = function.lines;
			foreach (PdbLines lines2 in lines)
			{
				ReadLines(lines2, info);
			}
		}
	}

	private void ReadLines(PdbLines lines, MethodDebugInformation info)
	{
		Document document = GetDocument(lines.file);
		PdbLine[] lines2 = lines.lines;
		for (int i = 0; i < lines2.Length; i++)
		{
			ReadLine(lines2[i], document, info);
		}
	}

	private static void ReadLine(PdbLine line, Document document, MethodDebugInformation info)
	{
		SequencePoint sequencePoint = new SequencePoint((int)line.offset, document);
		sequencePoint.StartLine = (int)line.lineBegin;
		sequencePoint.StartColumn = line.colBegin;
		sequencePoint.EndLine = (int)line.lineEnd;
		sequencePoint.EndColumn = line.colEnd;
		info.sequence_points.Add(sequencePoint);
	}

	private Document GetDocument(PdbSource source)
	{
		string name = source.name;
		if (documents.TryGetValue(name, out var value))
		{
			return value;
		}
		value = new Document(name)
		{
			LanguageGuid = source.language,
			LanguageVendorGuid = source.vendor,
			TypeGuid = source.doctype,
			HashAlgorithmGuid = source.checksumAlgorithm,
			Hash = source.checksum
		};
		documents.Add(name, value);
		return value;
	}

	public void Dispose()
	{
		pdb_file.Dispose();
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal class NativePdbWriter : ISymbolWriter, IDisposable
{
	private readonly ModuleDefinition module;

	private readonly MetadataBuilder metadata;

	private readonly SymWriter writer;

	private readonly Dictionary<string, SymDocumentWriter> documents;

	private readonly Dictionary<ImportDebugInformation, MetadataToken> import_info_to_parent;

	private ImageDebugDirectory debug_directory;

	private byte[] debug_info;

	internal NativePdbWriter(ModuleDefinition module, SymWriter writer)
	{
		this.module = module;
		metadata = module.metadata_builder;
		this.writer = writer;
		documents = new Dictionary<string, SymDocumentWriter>();
		import_info_to_parent = new Dictionary<ImportDebugInformation, MetadataToken>();
	}

	public ISymbolReaderProvider GetReaderProvider()
	{
		return new NativePdbReaderProvider();
	}

	public ImageDebugHeader GetDebugHeader()
	{
		return new ImageDebugHeader(new ImageDebugHeaderEntry(debug_directory, debug_info));
	}

	public void Write(MethodDebugInformation info)
	{
		int methodToken = info.method.MetadataToken.ToInt32();
		if (info.HasSequencePoints || info.scope != null || info.HasCustomDebugInformations || info.StateMachineKickOffMethod != null)
		{
			writer.OpenMethod(methodToken);
			if (!info.sequence_points.IsNullOrEmpty())
			{
				DefineSequencePoints(info.sequence_points);
			}
			MetadataToken import_parent = default(MetadataToken);
			if (info.scope != null)
			{
				DefineScope(info.scope, info, out import_parent);
			}
			DefineCustomMetadata(info, import_parent);
			writer.CloseMethod();
		}
	}

	private void DefineCustomMetadata(MethodDebugInformation info, MetadataToken import_parent)
	{
		CustomMetadataWriter customMetadataWriter = new CustomMetadataWriter(writer);
		if (import_parent.RID != 0)
		{
			customMetadataWriter.WriteForwardInfo(import_parent);
		}
		else if (info.scope != null && info.scope.Import != null && info.scope.Import.HasTargets)
		{
			customMetadataWriter.WriteUsingInfo(info.scope.Import);
		}
		if (info.Method.HasCustomAttributes)
		{
			foreach (CustomAttribute customAttribute in info.Method.CustomAttributes)
			{
				TypeReference attributeType = customAttribute.AttributeType;
				if ((attributeType.IsTypeOf("System.Runtime.CompilerServices", "IteratorStateMachineAttribute") || attributeType.IsTypeOf("System.Runtime.CompilerServices", "AsyncStateMachineAttribute")) && customAttribute.ConstructorArguments[0].Value is TypeReference type)
				{
					customMetadataWriter.WriteForwardIterator(type);
				}
			}
		}
		if (info.HasCustomDebugInformations && info.CustomDebugInformations.FirstOrDefault((CustomDebugInformation cdi) => cdi.Kind == CustomDebugInformationKind.StateMachineScope) is StateMachineScopeDebugInformation state_machine)
		{
			customMetadataWriter.WriteIteratorScopes(state_machine, info);
		}
		customMetadataWriter.WriteCustomMetadata();
		DefineAsyncCustomMetadata(info);
	}

	private void DefineAsyncCustomMetadata(MethodDebugInformation info)
	{
		if (!info.HasCustomDebugInformations)
		{
			return;
		}
		foreach (CustomDebugInformation customDebugInformation in info.CustomDebugInformations)
		{
			if (!(customDebugInformation is AsyncMethodBodyDebugInformation asyncMethodBodyDebugInformation))
			{
				continue;
			}
			using MemoryStream memoryStream = new MemoryStream();
			BinaryStreamWriter binaryStreamWriter = new BinaryStreamWriter(memoryStream);
			binaryStreamWriter.WriteUInt32((info.StateMachineKickOffMethod != null) ? info.StateMachineKickOffMethod.MetadataToken.ToUInt32() : 0u);
			binaryStreamWriter.WriteUInt32((uint)asyncMethodBodyDebugInformation.CatchHandler.Offset);
			binaryStreamWriter.WriteUInt32((uint)asyncMethodBodyDebugInformation.Resumes.Count);
			for (int i = 0; i < asyncMethodBodyDebugInformation.Resumes.Count; i++)
			{
				binaryStreamWriter.WriteUInt32((uint)asyncMethodBodyDebugInformation.Yields[i].Offset);
				binaryStreamWriter.WriteUInt32(asyncMethodBodyDebugInformation.resume_methods[i].MetadataToken.ToUInt32());
				binaryStreamWriter.WriteUInt32((uint)asyncMethodBodyDebugInformation.Resumes[i].Offset);
			}
			writer.DefineCustomMetadata("asyncMethodInfo", memoryStream.ToArray());
		}
	}

	private void DefineScope(ScopeDebugInformation scope, MethodDebugInformation info, out MetadataToken import_parent)
	{
		int offset = scope.Start.Offset;
		int num = (scope.End.IsEndOfMethod ? info.code_size : scope.End.Offset);
		import_parent = new MetadataToken(0u);
		writer.OpenScope(offset);
		if (scope.Import != null && scope.Import.HasTargets && !import_info_to_parent.TryGetValue(info.scope.Import, out import_parent))
		{
			foreach (ImportTarget target in scope.Import.Targets)
			{
				switch (target.Kind)
				{
				case ImportTargetKind.ImportNamespace:
					writer.UsingNamespace("U" + target.@namespace);
					break;
				case ImportTargetKind.ImportType:
					writer.UsingNamespace("T" + TypeParser.ToParseable(target.type));
					break;
				case ImportTargetKind.DefineNamespaceAlias:
					writer.UsingNamespace("A" + target.Alias + " U" + target.@namespace);
					break;
				case ImportTargetKind.DefineTypeAlias:
					writer.UsingNamespace("A" + target.Alias + " T" + TypeParser.ToParseable(target.type));
					break;
				}
			}
			import_info_to_parent.Add(info.scope.Import, info.method.MetadataToken);
		}
		int local_var_token = info.local_var_token.ToInt32();
		if (!scope.variables.IsNullOrEmpty())
		{
			for (int i = 0; i < scope.variables.Count; i++)
			{
				VariableDebugInformation variable = scope.variables[i];
				DefineLocalVariable(variable, local_var_token, offset, num);
			}
		}
		if (!scope.constants.IsNullOrEmpty())
		{
			for (int j = 0; j < scope.constants.Count; j++)
			{
				ConstantDebugInformation constant = scope.constants[j];
				DefineConstant(constant);
			}
		}
		if (!scope.scopes.IsNullOrEmpty())
		{
			for (int k = 0; k < scope.scopes.Count; k++)
			{
				DefineScope(scope.scopes[k], info, out var _);
			}
		}
		writer.CloseScope(num);
	}

	private void DefineSequencePoints(Collection<SequencePoint> sequence_points)
	{
		for (int i = 0; i < sequence_points.Count; i++)
		{
			SequencePoint sequencePoint = sequence_points[i];
			writer.DefineSequencePoints(GetDocument(sequencePoint.Document), new int[1] { sequencePoint.Offset }, new int[1] { sequencePoint.StartLine }, new int[1] { sequencePoint.StartColumn }, new int[1] { sequencePoint.EndLine }, new int[1] { sequencePoint.EndColumn });
		}
	}

	private void DefineLocalVariable(VariableDebugInformation variable, int local_var_token, int start_offset, int end_offset)
	{
		writer.DefineLocalVariable2(variable.Name, variable.Attributes, local_var_token, variable.Index, 0, 0, start_offset, end_offset);
	}

	private void DefineConstant(ConstantDebugInformation constant)
	{
		uint rid = metadata.AddStandAloneSignature(metadata.GetConstantTypeBlobIndex(constant.ConstantType));
		MetadataToken metadataToken = new MetadataToken(TokenType.Signature, rid);
		writer.DefineConstant2(constant.Name, constant.Value, metadataToken.ToInt32());
	}

	private SymDocumentWriter GetDocument(Document document)
	{
		if (document == null)
		{
			return null;
		}
		if (documents.TryGetValue(document.Url, out var value))
		{
			return value;
		}
		value = writer.DefineDocument(document.Url, document.LanguageGuid, document.LanguageVendorGuid, document.TypeGuid);
		if (!document.Hash.IsNullOrEmpty())
		{
			value.SetCheckSum(document.HashAlgorithmGuid, document.Hash);
		}
		documents[document.Url] = value;
		return value;
	}

	public void Write()
	{
		MethodDefinition entryPoint = module.EntryPoint;
		if (entryPoint != null)
		{
			writer.SetUserEntryPoint(entryPoint.MetadataToken.ToInt32());
		}
		debug_info = writer.GetDebugInfo(out debug_directory);
		debug_directory.TimeDateStamp = (int)module.timestamp;
		writer.Close();
	}

	public void Dispose()
	{
	}
}


internal enum CustomMetadataType : byte
{
	UsingInfo = 0,
	ForwardInfo = 1,
	IteratorScopes = 3,
	ForwardIterator = 4
}


using System;
using System.IO;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;
using Mono.Cecil.PE;
using Mono.Collections.Generic;

internal class CustomMetadataWriter : IDisposable
{
	private readonly SymWriter sym_writer;

	private readonly MemoryStream stream;

	private readonly BinaryStreamWriter writer;

	private int count;

	private const byte version = 4;

	public CustomMetadataWriter(SymWriter sym_writer)
	{
		this.sym_writer = sym_writer;
		stream = new MemoryStream();
		writer = new BinaryStreamWriter(stream);
		writer.WriteByte(4);
		writer.WriteByte(0);
		writer.Align(4);
	}

	public void WriteUsingInfo(ImportDebugInformation import_info)
	{
		Write(CustomMetadataType.UsingInfo, delegate
		{
			writer.WriteUInt16(1);
			writer.WriteUInt16((ushort)import_info.Targets.Count);
		});
	}

	public void WriteForwardInfo(MetadataToken import_parent)
	{
		Write(CustomMetadataType.ForwardInfo, delegate
		{
			writer.WriteUInt32(import_parent.ToUInt32());
		});
	}

	public void WriteIteratorScopes(StateMachineScopeDebugInformation state_machine, MethodDebugInformation debug_info)
	{
		Write(CustomMetadataType.IteratorScopes, delegate
		{
			Collection<StateMachineScope> scopes = state_machine.Scopes;
			writer.WriteInt32(scopes.Count);
			foreach (StateMachineScope item in scopes)
			{
				int offset = item.Start.Offset;
				int num = (item.End.IsEndOfMethod ? debug_info.code_size : item.End.Offset);
				writer.WriteInt32(offset);
				writer.WriteInt32(num - 1);
			}
		});
	}

	public void WriteForwardIterator(TypeReference type)
	{
		Write(CustomMetadataType.ForwardIterator, delegate
		{
			writer.WriteBytes(Encoding.Unicode.GetBytes(type.Name));
		});
	}

	private void Write(CustomMetadataType type, Action write)
	{
		count++;
		writer.WriteByte(4);
		writer.WriteByte((byte)type);
		writer.Align(4);
		int position = writer.Position;
		writer.WriteUInt32(0u);
		write();
		writer.Align(4);
		int position2 = writer.Position;
		int value = position2 - position + 4;
		writer.Position = position;
		writer.WriteInt32(value);
		writer.Position = position2;
	}

	public void WriteCustomMetadata()
	{
		if (count != 0)
		{
			writer.BaseStream.Position = 1L;
			writer.WriteByte((byte)count);
			writer.Flush();
			sym_writer.DefineCustomMetadata("MD2", stream.ToArray());
		}
	}

	public void Dispose()
	{
		stream.Dispose();
	}
}


using System.IO;
using Mono;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;

internal sealed class NativePdbReaderProvider : ISymbolReaderProvider
{
	public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		return new NativePdbReader(Disposable.Owned((Stream)File.OpenRead(Mixin.GetPdbFileName(fileName))));
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
	{
		Mixin.CheckModule(module);
		Mixin.CheckStream(symbolStream);
		return new NativePdbReader(Disposable.NotOwned(symbolStream));
	}
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;

internal sealed class PdbReaderProvider : ISymbolReaderProvider
{
	public ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		if (module.HasDebugHeader && module.GetDebugHeader().GetEmbeddedPortablePdbEntry() != null)
		{
			return new EmbeddedPortablePdbReaderProvider().GetSymbolReader(module, fileName);
		}
		Mixin.CheckFileName(fileName);
		if (!Mixin.IsPortablePdb(Mixin.GetPdbFileName(fileName)))
		{
			return new NativePdbReaderProvider().GetSymbolReader(module, fileName);
		}
		return new PortablePdbReaderProvider().GetSymbolReader(module, fileName);
	}

	public ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream)
	{
		Mixin.CheckModule(module);
		Mixin.CheckStream(symbolStream);
		Mixin.CheckReadSeek(symbolStream);
		if (!Mixin.IsPortablePdb(symbolStream))
		{
			return new NativePdbReaderProvider().GetSymbolReader(module, symbolStream);
		}
		return new PortablePdbReaderProvider().GetSymbolReader(module, symbolStream);
	}
}


using System;
using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;

internal sealed class NativePdbWriterProvider : ISymbolWriterProvider
{
	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		return new NativePdbWriter(module, CreateWriter(module, Mixin.GetPdbFileName(fileName)));
	}

	private static SymWriter CreateWriter(ModuleDefinition module, string pdb)
	{
		SymWriter symWriter = new SymWriter();
		if (File.Exists(pdb))
		{
			File.Delete(pdb);
		}
		symWriter.Initialize(new ModuleMetadata(module), pdb, fFullBuild: true);
		return symWriter;
	}

	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
	{
		throw new NotImplementedException();
	}
}


using System.IO;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;

internal sealed class PdbWriterProvider : ISymbolWriterProvider
{
	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName)
	{
		Mixin.CheckModule(module);
		Mixin.CheckFileName(fileName);
		if (HasPortablePdbSymbols(module))
		{
			return new PortablePdbWriterProvider().GetSymbolWriter(module, fileName);
		}
		return new NativePdbWriterProvider().GetSymbolWriter(module, fileName);
	}

	private static bool HasPortablePdbSymbols(ModuleDefinition module)
	{
		if (module.symbol_reader != null)
		{
			return module.symbol_reader is PortablePdbReader;
		}
		return false;
	}

	public ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream)
	{
		Mixin.CheckModule(module);
		Mixin.CheckStream(symbolStream);
		Mixin.CheckReadSeek(symbolStream);
		if (HasPortablePdbSymbols(module))
		{
			return new PortablePdbWriterProvider().GetSymbolWriter(module, symbolStream);
		}
		return new NativePdbWriterProvider().GetSymbolWriter(module, symbolStream);
	}
}


using System;
using Mono.Cecil.Pdb;

internal class SymDocumentWriter
{
	private readonly ISymUnmanagedDocumentWriter writer;

	public ISymUnmanagedDocumentWriter Writer => writer;

	public SymDocumentWriter(ISymUnmanagedDocumentWriter writer)
	{
		this.writer = writer;
	}

	public void SetSource(byte[] source)
	{
		writer.SetSource((uint)source.Length, source);
	}

	public void SetCheckSum(Guid hashAlgo, byte[] checkSum)
	{
		writer.SetCheckSum(hashAlgo, (uint)checkSum.Length, checkSum);
	}
}


using System;
using System.Runtime.InteropServices;
using Mono.Cecil.Cil;
using Mono.Cecil.Pdb;
using Mono.Collections.Generic;

internal class SymWriter
{
	private static Guid s_symUnmangedWriterIID = new Guid("0b97726e-9e6d-4f05-9a26-424022093caa");

	private static Guid s_CorSymWriter_SxS_ClassID = new Guid("108296c1-281e-11d3-bd22-0000f80849bd");

	private readonly ISymUnmanagedWriter2 writer;

	private readonly Collection<ISymUnmanagedDocumentWriter> documents;

	[DllImport("ole32.dll")]
	private static extern int CoCreateInstance([In] ref Guid rclsid, [In][MarshalAs(UnmanagedType.IUnknown)] object pUnkOuter, [In] uint dwClsContext, [In] ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out object ppv);

	public SymWriter()
	{
		CoCreateInstance(ref s_CorSymWriter_SxS_ClassID, null, 1u, ref s_symUnmangedWriterIID, out var ppv);
		writer = (ISymUnmanagedWriter2)ppv;
		documents = new Collection<ISymUnmanagedDocumentWriter>();
	}

	public byte[] GetDebugInfo(out ImageDebugDirectory idd)
	{
		writer.GetDebugInfo(out idd, 0, out var pcData, null);
		byte[] array = new byte[pcData];
		writer.GetDebugInfo(out idd, pcData, out pcData, array);
		return array;
	}

	public void DefineLocalVariable2(string name, VariableAttributes attributes, int sigToken, int addr1, int addr2, int addr3, int startOffset, int endOffset)
	{
		writer.DefineLocalVariable2(name, (int)attributes, sigToken, 1, addr1, addr2, addr3, startOffset, endOffset);
	}

	public void DefineConstant2(string name, object value, int sigToken)
	{
		if (value == null)
		{
			writer.DefineConstant2(name, 0, sigToken);
		}
		else
		{
			writer.DefineConstant2(name, value, sigToken);
		}
	}

	public void Close()
	{
		writer.Close();
		Marshal.ReleaseComObject(writer);
		foreach (ISymUnmanagedDocumentWriter document in documents)
		{
			Marshal.ReleaseComObject(document);
		}
	}

	public void CloseMethod()
	{
		writer.CloseMethod();
	}

	public void CloseNamespace()
	{
		writer.CloseNamespace();
	}

	public void CloseScope(int endOffset)
	{
		writer.CloseScope(endOffset);
	}

	public SymDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType)
	{
		writer.DefineDocument(url, ref language, ref languageVendor, ref documentType, out var pRetVal);
		documents.Add(pRetVal);
		return new SymDocumentWriter(pRetVal);
	}

	public void DefineSequencePoints(SymDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns)
	{
		writer.DefineSequencePoints(document.Writer, offsets.Length, offsets, lines, columns, endLines, endColumns);
	}

	public void Initialize(object emitter, string filename, bool fFullBuild)
	{
		writer.Initialize(emitter, filename, null, fFullBuild);
	}

	public void SetUserEntryPoint(int methodToken)
	{
		writer.SetUserEntryPoint(methodToken);
	}

	public void OpenMethod(int methodToken)
	{
		writer.OpenMethod(methodToken);
	}

	public void OpenNamespace(string name)
	{
		writer.OpenNamespace(name);
	}

	public int OpenScope(int startOffset)
	{
		writer.OpenScope(startOffset, out var pRetVal);
		return pRetVal;
	}

	public void UsingNamespace(string fullName)
	{
		writer.UsingNamespace(fullName);
	}

	public void DefineCustomMetadata(string name, byte[] metadata)
	{
		GCHandle gCHandle = GCHandle.Alloc(metadata, GCHandleType.Pinned);
		writer.SetSymAttribute(0u, name, (uint)metadata.Length, gCHandle.AddrOfPinnedObject());
		gCHandle.Free();
	}
}


using System;
using System.IO;
using System.Text;

internal class BitAccess
{
	private byte[] buffer;

	private int offset;

	internal byte[] Buffer => buffer;

	internal int Position
	{
		get
		{
			return offset;
		}
		set
		{
			offset = value;
		}
	}

	internal BitAccess(int capacity)
	{
		buffer = new byte[capacity];
	}

	internal BitAccess(byte[] buffer)
	{
		this.buffer = buffer;
		offset = 0;
	}

	internal void FillBuffer(Stream stream, int capacity)
	{
		MinCapacity(capacity);
		stream.Read(buffer, 0, capacity);
		offset = 0;
	}

	internal void Append(Stream stream, int count)
	{
		int num = offset + count;
		if (buffer.Length < num)
		{
			byte[] destinationArray = new byte[num];
			Array.Copy(buffer, destinationArray, buffer.Length);
			buffer = destinationArray;
		}
		stream.Read(buffer, offset, count);
		offset += count;
	}

	internal void MinCapacity(int capacity)
	{
		if (buffer.Length < capacity)
		{
			buffer = new byte[capacity];
		}
		offset = 0;
	}

	internal void Align(int alignment)
	{
		while (offset % alignment != 0)
		{
			offset++;
		}
	}

	internal void ReadInt16(out short value)
	{
		value = (short)((buffer[offset] & 0xFF) | (buffer[offset + 1] << 8));
		offset += 2;
	}

	internal void ReadInt8(out sbyte value)
	{
		value = (sbyte)buffer[offset];
		offset++;
	}

	internal void ReadInt32(out int value)
	{
		value = (buffer[offset] & 0xFF) | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24);
		offset += 4;
	}

	internal void ReadInt64(out long value)
	{
		value = (long)(((ulong)buffer[offset] & 0xFFuL) | ((ulong)buffer[offset + 1] << 8) | ((ulong)buffer[offset + 2] << 16) | ((ulong)buffer[offset + 3] << 24) | ((ulong)buffer[offset + 4] << 32) | ((ulong)buffer[offset + 5] << 40) | ((ulong)buffer[offset + 6] << 48) | ((ulong)buffer[offset + 7] << 56));
		offset += 8;
	}

	internal void ReadUInt16(out ushort value)
	{
		value = (ushort)((buffer[offset] & 0xFF) | (buffer[offset + 1] << 8));
		offset += 2;
	}

	internal void ReadUInt8(out byte value)
	{
		value = (byte)(buffer[offset] & 0xFF);
		offset++;
	}

	internal void ReadUInt32(out uint value)
	{
		value = (uint)((buffer[offset] & 0xFF) | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24));
		offset += 4;
	}

	internal void ReadUInt64(out ulong value)
	{
		value = ((ulong)buffer[offset] & 0xFFuL) | ((ulong)buffer[offset + 1] << 8) | ((ulong)buffer[offset + 2] << 16) | ((ulong)buffer[offset + 3] << 24) | ((ulong)buffer[offset + 4] << 32) | ((ulong)buffer[offset + 5] << 40) | ((ulong)buffer[offset + 6] << 48) | ((ulong)buffer[offset + 7] << 56);
		offset += 8;
	}

	internal void ReadInt32(int[] values)
	{
		for (int i = 0; i < values.Length; i++)
		{
			ReadInt32(out values[i]);
		}
	}

	internal void ReadUInt32(uint[] values)
	{
		for (int i = 0; i < values.Length; i++)
		{
			ReadUInt32(out values[i]);
		}
	}

	internal void ReadBytes(byte[] bytes)
	{
		for (int i = 0; i < bytes.Length; i++)
		{
			bytes[i] = buffer[offset++];
		}
	}

	internal float ReadFloat()
	{
		float result = BitConverter.ToSingle(buffer, offset);
		offset += 4;
		return result;
	}

	internal double ReadDouble()
	{
		double result = BitConverter.ToDouble(buffer, offset);
		offset += 8;
		return result;
	}

	internal decimal ReadDecimal()
	{
		int[] array = new int[4];
		ReadInt32(array);
		return new decimal(array[2], array[3], array[1], array[0] < 0, (byte)((array[0] & 0xFF0000) >> 16));
	}

	internal void ReadBString(out string value)
	{
		ReadUInt16(out var value2);
		value = Encoding.UTF8.GetString(buffer, offset, value2);
		offset += value2;
	}

	internal string ReadBString(int len)
	{
		string @string = Encoding.UTF8.GetString(buffer, offset, len);
		offset += len;
		return @string;
	}

	internal void ReadCString(out string value)
	{
		int i;
		for (i = 0; offset + i < buffer.Length && buffer[offset + i] != 0; i++)
		{
		}
		value = Encoding.UTF8.GetString(buffer, offset, i);
		offset += i + 1;
	}

	internal void SkipCString(out string value)
	{
		int i;
		for (i = 0; offset + i < buffer.Length && buffer[offset + i] != 0; i++)
		{
		}
		offset += i + 1;
		value = null;
	}

	internal void ReadGuid(out Guid guid)
	{
		ReadUInt32(out var value);
		ReadUInt16(out var value2);
		ReadUInt16(out var value3);
		ReadUInt8(out var value4);
		ReadUInt8(out var value5);
		ReadUInt8(out var value6);
		ReadUInt8(out var value7);
		ReadUInt8(out var value8);
		ReadUInt8(out var value9);
		ReadUInt8(out var value10);
		ReadUInt8(out var value11);
		guid = new Guid(value, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
	}

	internal string ReadString()
	{
		int i;
		for (i = 0; offset + i < buffer.Length && buffer[offset + i] != 0; i += 2)
		{
		}
		string @string = Encoding.Unicode.GetString(buffer, offset, i);
		offset += i + 2;
		return @string;
	}
}


using Microsoft.Cci.Pdb;

internal struct BitSet
{
	private int size;

	private uint[] words;

	internal bool IsEmpty => size == 0;

	internal BitSet(BitAccess bits)
	{
		bits.ReadInt32(out size);
		words = new uint[size];
		bits.ReadUInt32(words);
	}

	internal bool IsSet(int index)
	{
		int num = index / 32;
		if (num >= size)
		{
			return false;
		}
		return (words[num] & GetBit(index)) != 0;
	}

	private static uint GetBit(int index)
	{
		return (uint)(1 << index % 32);
	}
}


internal struct FLOAT10
{
	internal byte Data_0;

	internal byte Data_1;

	internal byte Data_2;

	internal byte Data_3;

	internal byte Data_4;

	internal byte Data_5;

	internal byte Data_6;

	internal byte Data_7;

	internal byte Data_8;

	internal byte Data_9;
}


internal enum CV_SIGNATURE
{
	C6 = 0,
	C7 = 1,
	C11 = 2,
	C13 = 4,
	RESERVERD = 5
}


internal enum CV_prmode
{
	CV_TM_DIRECT = 0,
	CV_TM_NPTR32 = 4,
	CV_TM_NPTR64 = 6,
	CV_TM_NPTR128 = 7
}


internal enum CV_type
{
	CV_SPECIAL = 0,
	CV_SIGNED = 1,
	CV_UNSIGNED = 2,
	CV_BOOLEAN = 3,
	CV_REAL = 4,
	CV_COMPLEX = 5,
	CV_SPECIAL2 = 6,
	CV_INT = 7,
	CV_CVRESERVED = 15
}


internal enum CV_special
{
	CV_SP_NOTYPE,
	CV_SP_ABS,
	CV_SP_SEGMENT,
	CV_SP_VOID,
	CV_SP_CURRENCY,
	CV_SP_NBASICSTR,
	CV_SP_FBASICSTR,
	CV_SP_NOTTRANS,
	CV_SP_HRESULT
}


internal enum CV_special2
{
	CV_S2_BIT,
	CV_S2_PASCHAR
}


internal enum CV_integral
{
	CV_IN_1BYTE,
	CV_IN_2BYTE,
	CV_IN_4BYTE,
	CV_IN_8BYTE,
	CV_IN_16BYTE
}


internal enum CV_real
{
	CV_RC_REAL32,
	CV_RC_REAL64,
	CV_RC_REAL80,
	CV_RC_REAL128
}


internal enum CV_int
{
	CV_RI_CHAR = 0,
	CV_RI_INT1 = 0,
	CV_RI_WCHAR = 1,
	CV_RI_UINT1 = 1,
	CV_RI_INT2 = 2,
	CV_RI_UINT2 = 3,
	CV_RI_INT4 = 4,
	CV_RI_UINT4 = 5,
	CV_RI_INT8 = 6,
	CV_RI_UINT8 = 7,
	CV_RI_INT16 = 8,
	CV_RI_UINT16 = 9
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct CV_PRIMITIVE_TYPE
{
	private const uint CV_MMASK = 1792u;

	private const uint CV_TMASK = 240u;

	private const uint CV_SMASK = 15u;

	private const int CV_MSHIFT = 8;

	private const int CV_TSHIFT = 4;

	private const int CV_SSHIFT = 0;

	private const uint CV_FIRST_NONPRIM = 4096u;
}


internal enum TYPE_ENUM
{
	T_NOTYPE = 0,
	T_ABS = 1,
	T_SEGMENT = 2,
	T_VOID = 3,
	T_HRESULT = 8,
	T_32PHRESULT = 1032,
	T_64PHRESULT = 1544,
	T_PVOID = 259,
	T_PFVOID = 515,
	T_PHVOID = 771,
	T_32PVOID = 1027,
	T_64PVOID = 1539,
	T_CURRENCY = 4,
	T_NOTTRANS = 7,
	T_BIT = 96,
	T_PASCHAR = 97,
	T_CHAR = 16,
	T_32PCHAR = 1040,
	T_64PCHAR = 1552,
	T_UCHAR = 32,
	T_32PUCHAR = 1056,
	T_64PUCHAR = 1568,
	T_RCHAR = 112,
	T_32PRCHAR = 1136,
	T_64PRCHAR = 1648,
	T_WCHAR = 113,
	T_32PWCHAR = 1137,
	T_64PWCHAR = 1649,
	T_INT1 = 104,
	T_32PINT1 = 1128,
	T_64PINT1 = 1640,
	T_UINT1 = 105,
	T_32PUINT1 = 1129,
	T_64PUINT1 = 1641,
	T_SHORT = 17,
	T_32PSHORT = 1041,
	T_64PSHORT = 1553,
	T_USHORT = 33,
	T_32PUSHORT = 1057,
	T_64PUSHORT = 1569,
	T_INT2 = 114,
	T_32PINT2 = 1138,
	T_64PINT2 = 1650,
	T_UINT2 = 115,
	T_32PUINT2 = 1139,
	T_64PUINT2 = 1651,
	T_LONG = 18,
	T_ULONG = 34,
	T_32PLONG = 1042,
	T_32PULONG = 1058,
	T_64PLONG = 1554,
	T_64PULONG = 1570,
	T_INT4 = 116,
	T_32PINT4 = 1140,
	T_64PINT4 = 1652,
	T_UINT4 = 117,
	T_32PUINT4 = 1141,
	T_64PUINT4 = 1653,
	T_QUAD = 19,
	T_32PQUAD = 1043,
	T_64PQUAD = 1555,
	T_UQUAD = 35,
	T_32PUQUAD = 1059,
	T_64PUQUAD = 1571,
	T_INT8 = 118,
	T_32PINT8 = 1142,
	T_64PINT8 = 1654,
	T_UINT8 = 119,
	T_32PUINT8 = 1143,
	T_64PUINT8 = 1655,
	T_OCT = 20,
	T_32POCT = 1044,
	T_64POCT = 1556,
	T_UOCT = 36,
	T_32PUOCT = 1060,
	T_64PUOCT = 1572,
	T_INT16 = 120,
	T_32PINT16 = 1144,
	T_64PINT16 = 1656,
	T_UINT16 = 121,
	T_32PUINT16 = 1145,
	T_64PUINT16 = 1657,
	T_REAL32 = 64,
	T_32PREAL32 = 1088,
	T_64PREAL32 = 1600,
	T_REAL64 = 65,
	T_32PREAL64 = 1089,
	T_64PREAL64 = 1601,
	T_REAL80 = 66,
	T_32PREAL80 = 1090,
	T_64PREAL80 = 1602,
	T_REAL128 = 67,
	T_32PREAL128 = 1091,
	T_64PREAL128 = 1603,
	T_CPLX32 = 80,
	T_32PCPLX32 = 1104,
	T_64PCPLX32 = 1616,
	T_CPLX64 = 81,
	T_32PCPLX64 = 1105,
	T_64PCPLX64 = 1617,
	T_CPLX80 = 82,
	T_32PCPLX80 = 1106,
	T_64PCPLX80 = 1618,
	T_CPLX128 = 83,
	T_32PCPLX128 = 1107,
	T_64PCPLX128 = 1619,
	T_BOOL08 = 48,
	T_32PBOOL08 = 1072,
	T_64PBOOL08 = 1584,
	T_BOOL16 = 49,
	T_32PBOOL16 = 1073,
	T_64PBOOL16 = 1585,
	T_BOOL32 = 50,
	T_32PBOOL32 = 1074,
	T_64PBOOL32 = 1586,
	T_BOOL64 = 51,
	T_32PBOOL64 = 1075,
	T_64PBOOL64 = 1587
}


internal enum LEAF
{
	LF_VTSHAPE = 10,
	LF_COBOL1 = 12,
	LF_LABEL = 14,
	LF_NULL = 15,
	LF_NOTTRAN = 16,
	LF_ENDPRECOMP = 20,
	LF_TYPESERVER_ST = 22,
	LF_LIST = 515,
	LF_REFSYM = 524,
	LF_ENUMERATE_ST = 1027,
	LF_TI16_MAX = 4096,
	LF_MODIFIER = 4097,
	LF_POINTER = 4098,
	LF_ARRAY_ST = 4099,
	LF_CLASS_ST = 4100,
	LF_STRUCTURE_ST = 4101,
	LF_UNION_ST = 4102,
	LF_ENUM_ST = 4103,
	LF_PROCEDURE = 4104,
	LF_MFUNCTION = 4105,
	LF_COBOL0 = 4106,
	LF_BARRAY = 4107,
	LF_DIMARRAY_ST = 4108,
	LF_VFTPATH = 4109,
	LF_PRECOMP_ST = 4110,
	LF_OEM = 4111,
	LF_ALIAS_ST = 4112,
	LF_OEM2 = 4113,
	LF_SKIP = 4608,
	LF_ARGLIST = 4609,
	LF_DEFARG_ST = 4610,
	LF_FIELDLIST = 4611,
	LF_DERIVED = 4612,
	LF_BITFIELD = 4613,
	LF_METHODLIST = 4614,
	LF_DIMCONU = 4615,
	LF_DIMCONLU = 4616,
	LF_DIMVARU = 4617,
	LF_DIMVARLU = 4618,
	LF_BCLASS = 5120,
	LF_VBCLASS = 5121,
	LF_IVBCLASS = 5122,
	LF_FRIENDFCN_ST = 5123,
	LF_INDEX = 5124,
	LF_MEMBER_ST = 5125,
	LF_STMEMBER_ST = 5126,
	LF_METHOD_ST = 5127,
	LF_NESTTYPE_ST = 5128,
	LF_VFUNCTAB = 5129,
	LF_FRIENDCLS = 5130,
	LF_ONEMETHOD_ST = 5131,
	LF_VFUNCOFF = 5132,
	LF_NESTTYPEEX_ST = 5133,
	LF_MEMBERMODIFY_ST = 5134,
	LF_MANAGED_ST = 5135,
	LF_ST_MAX = 5376,
	LF_TYPESERVER = 5377,
	LF_ENUMERATE = 5378,
	LF_ARRAY = 5379,
	LF_CLASS = 5380,
	LF_STRUCTURE = 5381,
	LF_UNION = 5382,
	LF_ENUM = 5383,
	LF_DIMARRAY = 5384,
	LF_PRECOMP = 5385,
	LF_ALIAS = 5386,
	LF_DEFARG = 5387,
	LF_FRIENDFCN = 5388,
	LF_MEMBER = 5389,
	LF_STMEMBER = 5390,
	LF_METHOD = 5391,
	LF_NESTTYPE = 5392,
	LF_ONEMETHOD = 5393,
	LF_NESTTYPEEX = 5394,
	LF_MEMBERMODIFY = 5395,
	LF_MANAGED = 5396,
	LF_TYPESERVER2 = 5397,
	LF_NUMERIC = 32768,
	LF_CHAR = 32768,
	LF_SHORT = 32769,
	LF_USHORT = 32770,
	LF_LONG = 32771,
	LF_ULONG = 32772,
	LF_REAL32 = 32773,
	LF_REAL64 = 32774,
	LF_REAL80 = 32775,
	LF_REAL128 = 32776,
	LF_QUADWORD = 32777,
	LF_UQUADWORD = 32778,
	LF_COMPLEX32 = 32780,
	LF_COMPLEX64 = 32781,
	LF_COMPLEX80 = 32782,
	LF_COMPLEX128 = 32783,
	LF_VARSTRING = 32784,
	LF_OCTWORD = 32791,
	LF_UOCTWORD = 32792,
	LF_DECIMAL = 32793,
	LF_DATE = 32794,
	LF_UTF8STRING = 32795,
	LF_PAD0 = 240,
	LF_PAD1 = 241,
	LF_PAD2 = 242,
	LF_PAD3 = 243,
	LF_PAD4 = 244,
	LF_PAD5 = 245,
	LF_PAD6 = 246,
	LF_PAD7 = 247,
	LF_PAD8 = 248,
	LF_PAD9 = 249,
	LF_PAD10 = 250,
	LF_PAD11 = 251,
	LF_PAD12 = 252,
	LF_PAD13 = 253,
	LF_PAD14 = 254,
	LF_PAD15 = 255
}


internal enum CV_ptrtype
{
	CV_PTR_BASE_SEG = 3,
	CV_PTR_BASE_VAL = 4,
	CV_PTR_BASE_SEGVAL = 5,
	CV_PTR_BASE_ADDR = 6,
	CV_PTR_BASE_SEGADDR = 7,
	CV_PTR_BASE_TYPE = 8,
	CV_PTR_BASE_SELF = 9,
	CV_PTR_NEAR32 = 10,
	CV_PTR_64 = 12,
	CV_PTR_UNUSEDPTR = 13
}


internal enum CV_ptrmode
{
	CV_PTR_MODE_PTR,
	CV_PTR_MODE_REF,
	CV_PTR_MODE_PMEM,
	CV_PTR_MODE_PMFUNC,
	CV_PTR_MODE_RESERVED
}


internal enum CV_pmtype
{
	CV_PMTYPE_Undef,
	CV_PMTYPE_D_Single,
	CV_PMTYPE_D_Multiple,
	CV_PMTYPE_D_Virtual,
	CV_PMTYPE_D_General,
	CV_PMTYPE_F_Single,
	CV_PMTYPE_F_Multiple,
	CV_PMTYPE_F_Virtual,
	CV_PMTYPE_F_General
}


internal enum CV_methodprop
{
	CV_MTvanilla,
	CV_MTvirtual,
	CV_MTstatic,
	CV_MTfriend,
	CV_MTintro,
	CV_MTpurevirt,
	CV_MTpureintro
}


internal enum CV_VTS_desc
{
	CV_VTS_near,
	CV_VTS_far,
	CV_VTS_thin,
	CV_VTS_outer,
	CV_VTS_meta,
	CV_VTS_near32,
	CV_VTS_far32,
	CV_VTS_unused
}


internal enum CV_LABEL_TYPE
{
	CV_LABEL_NEAR = 0,
	CV_LABEL_FAR = 4
}


using System;

[Flags]
internal enum CV_modifier : ushort
{
	MOD_const = 1,
	MOD_volatile = 2,
	MOD_unaligned = 4
}


using System;

[Flags]
internal enum CV_prop : ushort
{
	packed = 1,
	ctor = 2,
	ovlops = 4,
	isnested = 8,
	cnested = 0x10,
	opassign = 0x20,
	opcast = 0x40,
	fwdref = 0x80,
	scoped = 0x100
}


using System;

[Flags]
internal enum CV_fldattr
{
	access = 3,
	mprop = 0x1C,
	pseudo = 0x20,
	noinherit = 0x40,
	noconstruct = 0x80,
	compgenx = 0x100
}


internal struct TYPTYPE
{
	internal ushort len;

	internal ushort leaf;
}


internal struct CV_PDMR32_NVVFCN
{
	internal int mdisp;
}


internal struct CV_PDMR32_VBASE
{
	internal int mdisp;

	internal int pdisp;

	internal int vdisp;
}


internal struct CV_PMFR32_NVSA
{
	internal uint off;
}


internal struct CV_PMFR32_NVMA
{
	internal uint off;

	internal int disp;
}


internal struct CV_PMFR32_VBASE
{
	internal uint off;

	internal int mdisp;

	internal int pdisp;

	internal int vdisp;
}


using Microsoft.Cci.Pdb;

internal struct LeafModifier
{
	internal uint type;

	internal CV_modifier attr;
}


using System;

[Flags]
internal enum LeafPointerAttr : uint
{
	ptrtype = 0x1Fu,
	ptrmode = 0xE0u,
	isflat32 = 0x100u,
	isvolatile = 0x200u,
	isconst = 0x400u,
	isunaligned = 0x800u,
	isrestrict = 0x1000u
}


using System.Runtime.InteropServices;
using Microsoft.Cci.Pdb;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct LeafPointer
{
	internal struct LeafPointerBody
	{
		internal uint utype;

		internal LeafPointerAttr attr;
	}
}


internal struct LeafPointerBody
{
	internal uint utype;

	internal LeafPointerAttr attr;
}


internal struct LeafArray
{
	internal uint elemtype;

	internal uint idxtype;

	internal byte[] data;

	internal string name;
}


internal struct LeafClass
{
	internal ushort count;

	internal ushort property;

	internal uint field;

	internal uint derived;

	internal uint vshape;

	internal byte[] data;

	internal string name;
}


internal struct LeafUnion
{
	internal ushort count;

	internal ushort property;

	internal uint field;

	internal byte[] data;

	internal string name;
}


internal struct LeafAlias
{
	internal uint utype;

	internal string name;
}


internal struct LeafManaged
{
	internal string name;
}


internal struct LeafEnum
{
	internal ushort count;

	internal ushort property;

	internal uint utype;

	internal uint field;

	internal string name;
}


internal struct LeafProc
{
	internal uint rvtype;

	internal byte calltype;

	internal byte reserved;

	internal ushort parmcount;

	internal uint arglist;
}


internal struct LeafMFunc
{
	internal uint rvtype;

	internal uint classtype;

	internal uint thistype;

	internal byte calltype;

	internal byte reserved;

	internal ushort parmcount;

	internal uint arglist;

	internal int thisadjust;
}


internal struct LeafVTShape
{
	internal ushort count;

	internal byte[] desc;
}


internal struct LeafCobol0
{
	internal uint type;

	internal byte[] data;
}


internal struct LeafCobol1
{
	internal byte[] data;
}


internal struct LeafBArray
{
	internal uint utype;
}


internal struct LeafLabel
{
	internal ushort mode;
}


internal struct LeafDimArray
{
	internal uint utype;

	internal uint diminfo;

	internal string name;
}


internal struct LeafVFTPath
{
	internal uint count;

	internal uint[] bases;
}


internal struct LeafPreComp
{
	internal uint start;

	internal uint count;

	internal uint signature;

	internal string name;
}


internal struct LeafEndPreComp
{
	internal uint signature;
}


internal struct LeafOEM
{
	internal ushort cvOEM;

	internal ushort recOEM;

	internal uint count;

	internal uint[] index;
}


internal enum OEM_ID
{
	OEM_MS_FORTRAN90 = 61584,
	OEM_ODI = 16,
	OEM_THOMSON_SOFTWARE = 21587,
	OEM_ODI_REC_BASELIST = 0
}


using System;

internal struct LeafOEM2
{
	internal Guid idOem;

	internal uint count;

	internal uint[] index;
}


internal struct LeafTypeServer
{
	internal uint signature;

	internal uint age;

	internal string name;
}


using System;

internal struct LeafTypeServer2
{
	internal Guid sig70;

	internal uint age;

	internal string name;
}


internal struct LeafSkip
{
	internal uint type;

	internal byte[] data;
}


internal struct LeafArgList
{
	internal uint count;

	internal uint[] arg;
}


internal struct LeafDerived
{
	internal uint count;

	internal uint[] drvdcls;
}


internal struct LeafDefArg
{
	internal uint type;

	internal byte[] expr;
}


internal struct LeafList
{
	internal byte[] data;
}


internal struct LeafFieldList
{
	internal char[] data;
}


internal struct mlMethod
{
	internal ushort attr;

	internal ushort pad0;

	internal uint index;

	internal uint[] vbaseoff;
}


internal struct LeafMethodList
{
	internal byte[] mList;
}


internal struct LeafBitfield
{
	internal uint type;

	internal byte length;

	internal byte position;
}


internal struct LeafDimCon
{
	internal uint typ;

	internal ushort rank;

	internal byte[] dim;
}


internal struct LeafDimVar
{
	internal uint rank;

	internal uint typ;

	internal uint[] dim;
}


internal struct LeafRefSym
{
	internal byte[] Sym;
}


internal struct LeafChar
{
	internal sbyte val;
}


internal struct LeafShort
{
	internal short val;
}


internal struct LeafUShort
{
	internal ushort val;
}


internal struct LeafLong
{
	internal int val;
}


internal struct LeafULong
{
	internal uint val;
}


internal struct LeafQuad
{
	internal long val;
}


internal struct LeafUQuad
{
	internal ulong val;
}


internal struct LeafOct
{
	internal ulong val0;

	internal ulong val1;
}


internal struct LeafUOct
{
	internal ulong val0;

	internal ulong val1;
}


internal struct LeafReal32
{
	internal float val;
}


internal struct LeafReal64
{
	internal double val;
}


using Microsoft.Cci.Pdb;

internal struct LeafReal80
{
	internal FLOAT10 val;
}


internal struct LeafReal128
{
	internal ulong val0;

	internal ulong val1;
}


internal struct LeafCmplx32
{
	internal float val_real;

	internal float val_imag;
}


internal struct LeafCmplx64
{
	internal double val_real;

	internal double val_imag;
}


using Microsoft.Cci.Pdb;

internal struct LeafCmplx80
{
	internal FLOAT10 val_real;

	internal FLOAT10 val_imag;
}


internal struct LeafCmplx128
{
	internal ulong val0_real;

	internal ulong val1_real;

	internal ulong val0_imag;

	internal ulong val1_imag;
}


internal struct LeafVarString
{
	internal ushort len;

	internal byte[] value;
}


internal struct LeafIndex
{
	internal ushort pad0;

	internal uint index;
}


internal struct LeafBClass
{
	internal ushort attr;

	internal uint index;

	internal byte[] offset;
}


internal struct LeafVBClass
{
	internal ushort attr;

	internal uint index;

	internal uint vbptr;

	internal byte[] vbpoff;
}


internal struct LeafFriendCls
{
	internal ushort pad0;

	internal uint index;
}


internal struct LeafFriendFcn
{
	internal ushort pad0;

	internal uint index;

	internal string name;
}


internal struct LeafMember
{
	internal ushort attr;

	internal uint index;

	internal byte[] offset;

	internal string name;
}


internal struct LeafSTMember
{
	internal ushort attr;

	internal uint index;

	internal string name;
}


internal struct LeafVFuncTab
{
	internal ushort pad0;

	internal uint type;
}


internal struct LeafVFuncOff
{
	internal ushort pad0;

	internal uint type;

	internal int offset;
}


internal struct LeafMethod
{
	internal ushort count;

	internal uint mList;

	internal string name;
}


internal struct LeafOneMethod
{
	internal ushort attr;

	internal uint index;

	internal uint[] vbaseoff;

	internal string name;
}


internal struct LeafEnumerate
{
	internal ushort attr;

	internal byte[] value;

	internal string name;
}


internal struct LeafNestType
{
	internal ushort pad0;

	internal uint index;

	internal string name;
}


internal struct LeafNestTypeEx
{
	internal ushort attr;

	internal uint index;

	internal string name;
}


internal struct LeafMemberModify
{
	internal ushort attr;

	internal uint index;

	internal string name;
}


internal struct LeafPad
{
	internal byte leaf;
}


internal enum SYM
{
	S_END = 6,
	S_OEM = 1028,
	S_REGISTER_ST = 4097,
	S_CONSTANT_ST = 4098,
	S_UDT_ST = 4099,
	S_COBOLUDT_ST = 4100,
	S_MANYREG_ST = 4101,
	S_BPREL32_ST = 4102,
	S_LDATA32_ST = 4103,
	S_GDATA32_ST = 4104,
	S_PUB32_ST = 4105,
	S_LPROC32_ST = 4106,
	S_GPROC32_ST = 4107,
	S_VFTABLE32 = 4108,
	S_REGREL32_ST = 4109,
	S_LTHREAD32_ST = 4110,
	S_GTHREAD32_ST = 4111,
	S_LPROCMIPS_ST = 4112,
	S_GPROCMIPS_ST = 4113,
	S_FRAMEPROC = 4114,
	S_COMPILE2_ST = 4115,
	S_MANYREG2_ST = 4116,
	S_LPROCIA64_ST = 4117,
	S_GPROCIA64_ST = 4118,
	S_LOCALSLOT_ST = 4119,
	S_PARAMSLOT_ST = 4120,
	S_ANNOTATION = 4121,
	S_GMANPROC_ST = 4122,
	S_LMANPROC_ST = 4123,
	S_RESERVED1 = 4124,
	S_RESERVED2 = 4125,
	S_RESERVED3 = 4126,
	S_RESERVED4 = 4127,
	S_LMANDATA_ST = 4128,
	S_GMANDATA_ST = 4129,
	S_MANFRAMEREL_ST = 4130,
	S_MANREGISTER_ST = 4131,
	S_MANSLOT_ST = 4132,
	S_MANMANYREG_ST = 4133,
	S_MANREGREL_ST = 4134,
	S_MANMANYREG2_ST = 4135,
	S_MANTYPREF = 4136,
	S_UNAMESPACE_ST = 4137,
	S_ST_MAX = 4352,
	S_OBJNAME = 4353,
	S_THUNK32 = 4354,
	S_BLOCK32 = 4355,
	S_WITH32 = 4356,
	S_LABEL32 = 4357,
	S_REGISTER = 4358,
	S_CONSTANT = 4359,
	S_UDT = 4360,
	S_COBOLUDT = 4361,
	S_MANYREG = 4362,
	S_BPREL32 = 4363,
	S_LDATA32 = 4364,
	S_GDATA32 = 4365,
	S_PUB32 = 4366,
	S_LPROC32 = 4367,
	S_GPROC32 = 4368,
	S_REGREL32 = 4369,
	S_LTHREAD32 = 4370,
	S_GTHREAD32 = 4371,
	S_LPROCMIPS = 4372,
	S_GPROCMIPS = 4373,
	S_COMPILE2 = 4374,
	S_MANYREG2 = 4375,
	S_LPROCIA64 = 4376,
	S_GPROCIA64 = 4377,
	S_LOCALSLOT = 4378,
	S_SLOT = 4378,
	S_PARAMSLOT = 4379,
	S_LMANDATA = 4380,
	S_GMANDATA = 4381,
	S_MANFRAMEREL = 4382,
	S_MANREGISTER = 4383,
	S_MANSLOT = 4384,
	S_MANMANYREG = 4385,
	S_MANREGREL = 4386,
	S_MANMANYREG2 = 4387,
	S_UNAMESPACE = 4388,
	S_PROCREF = 4389,
	S_DATAREF = 4390,
	S_LPROCREF = 4391,
	S_ANNOTATIONREF = 4392,
	S_TOKENREF = 4393,
	S_GMANPROC = 4394,
	S_LMANPROC = 4395,
	S_TRAMPOLINE = 4396,
	S_MANCONSTANT = 4397,
	S_ATTR_FRAMEREL = 4398,
	S_ATTR_REGISTER = 4399,
	S_ATTR_REGREL = 4400,
	S_ATTR_MANYREG = 4401,
	S_SEPCODE = 4402,
	S_LOCAL = 4403,
	S_DEFRANGE = 4404,
	S_DEFRANGE2 = 4405,
	S_SECTION = 4406,
	S_COFFGROUP = 4407,
	S_EXPORT = 4408,
	S_CALLSITEINFO = 4409,
	S_FRAMECOOKIE = 4410,
	S_DISCARDED = 4411,
	S_RECTYPE_MAX = 4412,
	S_RECTYPE_LAST = 4411
}


internal enum CV_CFL_DATA
{
	CV_CFL_DNEAR,
	CV_CFL_DFAR,
	CV_CFL_DHUGE
}


internal enum CV_CFL_CODE
{
	CV_CFL_CNEAR,
	CV_CFL_CFAR,
	CV_CFL_CHUGE
}


internal enum CV_CFL_FPKG
{
	CV_CFL_NDP,
	CV_CFL_EMU,
	CV_CFL_ALT
}


using System;

[Flags]
internal enum CV_PROCFLAGS : byte
{
	CV_PFLAG_NOFPO = 1,
	CV_PFLAG_INT = 2,
	CV_PFLAG_FAR = 4,
	CV_PFLAG_NEVER = 8,
	CV_PFLAG_NOTREACHED = 0x10,
	CV_PFLAG_CUST_CALL = 0x20,
	CV_PFLAG_NOINLINE = 0x40,
	CV_PFLAG_OPTDBGINFO = 0x80
}


internal struct CV_EXPROCFLAGS
{
	internal byte flags;

	internal byte reserved;
}


using System;

[Flags]
internal enum CV_LVARFLAGS : ushort
{
	fIsParam = 1,
	fAddrTaken = 2,
	fCompGenx = 4,
	fIsAggregate = 8,
	fIsAggregated = 0x10,
	fIsAliased = 0x20,
	fIsAlias = 0x40
}


internal struct CV_lvar_addr_range
{
	internal uint offStart;

	internal ushort isectStart;

	internal uint cbRange;
}


internal enum CV_GENERIC_STYLE
{
	CV_GENERIC_VOID,
	CV_GENERIC_REG,
	CV_GENERIC_ICAN,
	CV_GENERIC_ICAF,
	CV_GENERIC_IRAN,
	CV_GENERIC_IRAF,
	CV_GENERIC_UNUSED
}


using System;

[Flags]
internal enum CV_GENERIC_FLAG : ushort
{
	cstyle = 1,
	rsclean = 2
}


using System;

[Flags]
internal enum CV_SEPCODEFLAGS : uint
{
	fIsLexicalScope = 1u,
	fReturnsToParent = 2u
}


internal struct SYMTYPE
{
	internal ushort reclen;

	internal ushort rectyp;
}


internal struct RegSym
{
	internal uint typind;

	internal ushort reg;

	internal string name;
}


internal struct AttrRegSym
{
	internal uint typind;

	internal uint offCod;

	internal ushort segCod;

	internal ushort flags;

	internal ushort reg;

	internal string name;
}


internal struct ManyRegSym
{
	internal uint typind;

	internal byte count;

	internal byte[] reg;

	internal string name;
}


internal struct ManyRegSym2
{
	internal uint typind;

	internal ushort count;

	internal ushort[] reg;

	internal string name;
}


internal struct AttrManyRegSym
{
	internal uint typind;

	internal uint offCod;

	internal ushort segCod;

	internal ushort flags;

	internal byte count;

	internal byte[] reg;

	internal string name;
}


internal struct AttrManyRegSym2
{
	internal uint typind;

	internal uint offCod;

	internal ushort segCod;

	internal ushort flags;

	internal ushort count;

	internal ushort[] reg;

	internal string name;
}


internal struct ConstSym
{
	internal uint typind;

	internal ushort value;

	internal string name;
}


internal struct UdtSym
{
	internal uint typind;

	internal string name;
}


internal struct ManyTypRef
{
	internal uint typind;
}


internal struct SearchSym
{
	internal uint startsym;

	internal ushort seg;
}


using System;

[Flags]
internal enum CFLAGSYM_FLAGS : ushort
{
	pcode = 1,
	floatprec = 6,
	floatpkg = 0x18,
	ambdata = 0xE0,
	ambcode = 0x700,
	mode32 = 0x800
}


internal struct CFlagSym
{
	internal byte machine;

	internal byte language;

	internal ushort flags;

	internal string ver;
}


using System;

[Flags]
internal enum COMPILESYM_FLAGS : uint
{
	iLanguage = 0xFFu,
	fEC = 0x100u,
	fNoDbgInfo = 0x200u,
	fLTCG = 0x400u,
	fNoDataAlign = 0x800u,
	fManagedPresent = 0x1000u,
	fSecurityChecks = 0x2000u,
	fHotPatch = 0x4000u,
	fCVTCIL = 0x8000u,
	fMSILModule = 0x10000u
}


internal struct CompileSym
{
	internal uint flags;

	internal ushort machine;

	internal ushort verFEMajor;

	internal ushort verFEMinor;

	internal ushort verFEBuild;

	internal ushort verMajor;

	internal ushort verMinor;

	internal ushort verBuild;

	internal string verSt;

	internal string[] verArgs;
}


internal struct ObjNameSym
{
	internal uint signature;

	internal string name;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct EndArgSym
{
}


using Microsoft.Cci.Pdb;

internal struct ReturnSym
{
	internal CV_GENERIC_FLAG flags;

	internal byte style;
}


internal struct EntryThisSym
{
	internal byte thissym;
}


internal struct BpRelSym32
{
	internal int off;

	internal uint typind;

	internal string name;
}


internal struct FrameRelSym
{
	internal int off;

	internal uint typind;

	internal uint offCod;

	internal ushort segCod;

	internal ushort flags;

	internal string name;
}


internal struct SlotSym32
{
	internal uint index;

	internal uint typind;

	internal string name;
}


internal struct AttrSlotSym
{
	internal uint index;

	internal uint typind;

	internal uint offCod;

	internal ushort segCod;

	internal ushort flags;

	internal string name;
}


internal struct AnnotationSym
{
	internal uint off;

	internal ushort seg;

	internal ushort csz;

	internal string[] rgsz;
}


internal struct DatasSym32
{
	internal uint typind;

	internal uint off;

	internal ushort seg;

	internal string name;
}


using System;

[Flags]
internal enum CV_PUBSYMFLAGS : uint
{
	fNone = 0u,
	fCode = 1u,
	fFunction = 2u,
	fManaged = 4u,
	fMSIL = 8u
}


internal struct PubSym32
{
	internal uint flags;

	internal uint off;

	internal ushort seg;

	internal string name;
}


internal struct ProcSym32
{
	internal uint parent;

	internal uint end;

	internal uint next;

	internal uint len;

	internal uint dbgStart;

	internal uint dbgEnd;

	internal uint typind;

	internal uint off;

	internal ushort seg;

	internal byte flags;

	internal string name;
}


internal struct ManProcSym
{
	internal uint parent;

	internal uint end;

	internal uint next;

	internal uint len;

	internal uint dbgStart;

	internal uint dbgEnd;

	internal uint token;

	internal uint off;

	internal ushort seg;

	internal byte flags;

	internal ushort retReg;

	internal string name;
}


internal struct ManProcSymMips
{
	internal uint parent;

	internal uint end;

	internal uint next;

	internal uint len;

	internal uint dbgStart;

	internal uint dbgEnd;

	internal uint regSave;

	internal uint fpSave;

	internal uint intOff;

	internal uint fpOff;

	internal uint token;

	internal uint off;

	internal ushort seg;

	internal byte retReg;

	internal byte frameReg;

	internal string name;
}


internal struct ThunkSym32
{
	internal uint parent;

	internal uint end;

	internal uint next;

	internal uint off;

	internal ushort seg;

	internal ushort len;

	internal byte ord;

	internal string name;

	internal byte[] variant;
}


internal enum TRAMP
{
	trampIncremental,
	trampBranchIsland
}


internal struct TrampolineSym
{
	internal ushort trampType;

	internal ushort cbThunk;

	internal uint offThunk;

	internal uint offTarget;

	internal ushort sectThunk;

	internal ushort sectTarget;
}


internal struct LabelSym32
{
	internal uint off;

	internal ushort seg;

	internal byte flags;

	internal string name;
}


internal struct BlockSym32
{
	internal uint parent;

	internal uint end;

	internal uint len;

	internal uint off;

	internal ushort seg;

	internal string name;
}


internal struct WithSym32
{
	internal uint parent;

	internal uint end;

	internal uint len;

	internal uint off;

	internal ushort seg;

	internal string expr;
}


internal struct VpathSym32
{
	internal uint root;

	internal uint path;

	internal uint off;

	internal ushort seg;
}


internal struct RegRel32
{
	internal uint off;

	internal uint typind;

	internal ushort reg;

	internal string name;
}


internal struct AttrRegRel
{
	internal uint off;

	internal uint typind;

	internal ushort reg;

	internal uint offCod;

	internal ushort segCod;

	internal ushort flags;

	internal string name;
}


internal struct ThreadSym32
{
	internal uint typind;

	internal uint off;

	internal ushort seg;

	internal string name;
}


internal struct Slink32
{
	internal uint framesize;

	internal int off;

	internal ushort reg;
}


internal struct ProcSymMips
{
	internal uint parent;

	internal uint end;

	internal uint next;

	internal uint len;

	internal uint dbgStart;

	internal uint dbgEnd;

	internal uint regSave;

	internal uint fpSave;

	internal uint intOff;

	internal uint fpOff;

	internal uint typind;

	internal uint off;

	internal ushort seg;

	internal byte retReg;

	internal byte frameReg;

	internal string name;
}


internal struct ProcSymIa64
{
	internal uint parent;

	internal uint end;

	internal uint next;

	internal uint len;

	internal uint dbgStart;

	internal uint dbgEnd;

	internal uint typind;

	internal uint off;

	internal ushort seg;

	internal ushort retReg;

	internal byte flags;

	internal string name;
}


internal struct RefSym
{
	internal uint sumName;

	internal uint ibSym;

	internal ushort imod;

	internal ushort usFill;
}


internal struct RefSym2
{
	internal uint sumName;

	internal uint ibSym;

	internal ushort imod;

	internal string name;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct AlignSym
{
}


using System;

internal struct OemSymbol
{
	internal Guid idOem;

	internal uint typind;

	internal byte[] rgl;
}


using System;

[Flags]
internal enum FRAMEPROCSYM_FLAGS : uint
{
	fHasAlloca = 1u,
	fHasSetJmp = 2u,
	fHasLongJmp = 4u,
	fHasInlAsm = 8u,
	fHasEH = 0x10u,
	fInlSpec = 0x20u,
	fHasSEH = 0x40u,
	fNaked = 0x80u,
	fSecurityChecks = 0x100u,
	fAsyncEH = 0x200u,
	fGSNoStackOrdering = 0x400u,
	fWasInlined = 0x800u
}


internal struct FrameProcSym
{
	internal uint cbFrame;

	internal uint cbPad;

	internal uint offPad;

	internal uint cbSaveRegs;

	internal uint offExHdlr;

	internal ushort secExHdlr;

	internal uint flags;
}


internal struct UnamespaceSym
{
	internal string name;
}


internal struct SepCodSym
{
	internal uint parent;

	internal uint end;

	internal uint length;

	internal uint scf;

	internal uint off;

	internal uint offParent;

	internal ushort sec;

	internal ushort secParent;
}


internal struct LocalSym
{
	internal uint id;

	internal uint typind;

	internal ushort flags;

	internal uint idParent;

	internal uint offParent;

	internal uint expr;

	internal uint pad0;

	internal uint pad1;

	internal string name;
}


using Microsoft.Cci.Pdb;

internal struct DefRangeSym
{
	internal uint id;

	internal uint program;

	internal CV_lvar_addr_range range;
}


using Microsoft.Cci.Pdb;

internal struct DefRangeSym2
{
	internal uint id;

	internal uint program;

	internal ushort count;

	internal CV_lvar_addr_range[] range;
}


internal struct SectionSym
{
	internal ushort isec;

	internal byte align;

	internal byte bReserved;

	internal uint rva;

	internal uint cb;

	internal uint characteristics;

	internal string name;
}


internal struct CoffGroupSym
{
	internal uint cb;

	internal uint characteristics;

	internal uint off;

	internal ushort seg;

	internal string name;
}


using System;

[Flags]
internal enum EXPORTSYM_FLAGS : ushort
{
	fConstant = 1,
	fData = 2,
	fPrivate = 4,
	fNoName = 8,
	fOrdinal = 0x10,
	fForwarder = 0x20
}


internal struct ExportSym
{
	internal ushort ordinal;

	internal ushort flags;

	internal string name;
}


internal struct CallsiteInfo
{
	internal int off;

	internal ushort ect;

	internal ushort pad0;

	internal uint typind;
}


internal enum CV_cookietype
{
	CV_COOKIETYPE_COPY,
	CV_COOKIETYPE_XOR_SP,
	CV_COOKIETYPE_XOR_BP,
	CV_COOKIETYPE_XOR_R13
}


internal struct FrameCookie
{
	internal int off;

	internal ushort reg;

	internal int cookietype;

	internal byte flags;
}


internal enum CV_DISCARDED : uint
{
	CV_DISCARDED_UNKNOWN,
	CV_DISCARDED_NOT_SELECTED,
	CV_DISCARDED_NOT_REFERENCED
}


using Microsoft.Cci.Pdb;

internal struct DiscardedSym
{
	internal CV_DISCARDED iscarded;

	internal uint fileid;

	internal uint linenum;

	internal byte[] data;
}


internal enum DEBUG_S_SUBSECTION_TYPE : uint
{
	DEBUG_S_IGNORE = 2147483648u,
	DEBUG_S_SYMBOLS = 241u,
	DEBUG_S_LINES = 242u,
	DEBUG_S_STRINGTABLE = 243u,
	DEBUG_S_FILECHKSMS = 244u,
	DEBUG_S_FRAMEDATA = 245u
}


internal enum CV_LINE_SUBSECTION_FLAGS : ushort
{
	CV_LINES_HAVE_COLUMNS = 1
}


internal struct CV_LineSection
{
	internal uint off;

	internal ushort sec;

	internal ushort flags;

	internal uint cod;
}


internal struct CV_SourceFile
{
	internal uint index;

	internal uint count;

	internal uint linsiz;
}


using System;

[Flags]
internal enum CV_Line_Flags : uint
{
	linenumStart = 0xFFFFFFu,
	deltaLineEnd = 0x7F000000u,
	fStatement = 0x80000000u
}


internal struct CV_Line
{
	internal uint offset;

	internal uint flags;
}


internal struct CV_Column
{
	internal ushort offColumnStart;

	internal ushort offColumnEnd;
}


internal enum CV_FILE_CHECKSUM_TYPE : byte
{
	None,
	MD5
}


internal struct CV_FileCheckSum
{
	internal uint name;

	internal byte len;

	internal byte type;
}


using System;

[Flags]
internal enum FRAMEDATA_FLAGS : uint
{
	fHasSEH = 1u,
	fHasEH = 2u,
	fIsFunctionStart = 4u
}


internal struct FrameData
{
	internal uint ulRvaStart;

	internal uint cbBlock;

	internal uint cbLocals;

	internal uint cbParams;

	internal uint cbStkMax;

	internal uint frameFunc;

	internal ushort cbProlog;

	internal ushort cbSavedRegs;

	internal uint flags;
}


internal struct XFixupData
{
	internal ushort wType;

	internal ushort wExtra;

	internal uint rva;

	internal uint rvaTarget;
}


internal enum DEBUG_S_SUBSECTION
{
	SYMBOLS = 241,
	LINES,
	STRINGTABLE,
	FILECHKSMS,
	FRAMEDATA
}


using Microsoft.Cci.Pdb;

internal class DataStream
{
	internal int contentSize;

	internal int[] pages;

	internal int Length => contentSize;

	internal DataStream()
	{
	}

	internal DataStream(int contentSize, BitAccess bits, int count)
	{
		this.contentSize = contentSize;
		if (count > 0)
		{
			pages = new int[count];
			bits.ReadInt32(pages);
		}
	}

	internal void Read(PdbReader reader, BitAccess bits)
	{
		bits.MinCapacity(contentSize);
		Read(reader, 0, bits.Buffer, 0, contentSize);
	}

	internal void Read(PdbReader reader, int position, byte[] bytes, int offset, int data)
	{
		if (position + data > contentSize)
		{
			throw new PdbException("DataStream can't read off end of stream. (pos={0},siz={1})", position, data);
		}
		if (position == contentSize)
		{
			return;
		}
		int num = data;
		int num2 = position / reader.pageSize;
		int num3 = position % reader.pageSize;
		if (num3 != 0)
		{
			int num4 = reader.pageSize - num3;
			if (num4 > num)
			{
				num4 = num;
			}
			reader.Seek(pages[num2], num3);
			reader.Read(bytes, offset, num4);
			offset += num4;
			num -= num4;
			num2++;
		}
		while (num > 0)
		{
			int num5 = reader.pageSize;
			if (num5 > num)
			{
				num5 = num;
			}
			reader.Seek(pages[num2], 0);
			reader.Read(bytes, offset, num5);
			offset += num5;
			num -= num5;
			num2++;
		}
	}
}


using Microsoft.Cci.Pdb;

internal struct DbiDbgHdr
{
	internal ushort snFPO;

	internal ushort snException;

	internal ushort snFixup;

	internal ushort snOmapToSrc;

	internal ushort snOmapFromSrc;

	internal ushort snSectionHdr;

	internal ushort snTokenRidMap;

	internal ushort snXdata;

	internal ushort snPdata;

	internal ushort snNewFPO;

	internal ushort snSectionHdrOrig;

	internal DbiDbgHdr(BitAccess bits)
	{
		bits.ReadUInt16(out snFPO);
		bits.ReadUInt16(out snException);
		bits.ReadUInt16(out snFixup);
		bits.ReadUInt16(out snOmapToSrc);
		bits.ReadUInt16(out snOmapFromSrc);
		bits.ReadUInt16(out snSectionHdr);
		bits.ReadUInt16(out snTokenRidMap);
		bits.ReadUInt16(out snXdata);
		bits.ReadUInt16(out snPdata);
		bits.ReadUInt16(out snNewFPO);
		bits.ReadUInt16(out snSectionHdrOrig);
	}
}


using Microsoft.Cci.Pdb;

internal struct DbiHeader
{
	internal int sig;

	internal int ver;

	internal int age;

	internal short gssymStream;

	internal ushort vers;

	internal short pssymStream;

	internal ushort pdbver;

	internal short symrecStream;

	internal ushort pdbver2;

	internal int gpmodiSize;

	internal int secconSize;

	internal int secmapSize;

	internal int filinfSize;

	internal int tsmapSize;

	internal int mfcIndex;

	internal int dbghdrSize;

	internal int ecinfoSize;

	internal ushort flags;

	internal ushort machine;

	internal int reserved;

	internal DbiHeader(BitAccess bits)
	{
		bits.ReadInt32(out sig);
		bits.ReadInt32(out ver);
		bits.ReadInt32(out age);
		bits.ReadInt16(out gssymStream);
		bits.ReadUInt16(out vers);
		bits.ReadInt16(out pssymStream);
		bits.ReadUInt16(out pdbver);
		bits.ReadInt16(out symrecStream);
		bits.ReadUInt16(out pdbver2);
		bits.ReadInt32(out gpmodiSize);
		bits.ReadInt32(out secconSize);
		bits.ReadInt32(out secmapSize);
		bits.ReadInt32(out filinfSize);
		bits.ReadInt32(out tsmapSize);
		bits.ReadInt32(out mfcIndex);
		bits.ReadInt32(out dbghdrSize);
		bits.ReadInt32(out ecinfoSize);
		bits.ReadUInt16(out flags);
		bits.ReadUInt16(out machine);
		bits.ReadInt32(out reserved);
	}
}


using Microsoft.Cci.Pdb;

internal class DbiModuleInfo
{
	internal int opened;

	internal ushort flags;

	internal short stream;

	internal int cbSyms;

	internal int cbOldLines;

	internal int cbLines;

	internal short files;

	internal short pad1;

	internal uint offsets;

	internal int niSource;

	internal int niCompiler;

	internal string moduleName;

	internal string objectName;

	internal DbiModuleInfo(BitAccess bits, bool readStrings)
	{
		bits.ReadInt32(out opened);
		new DbiSecCon(bits);
		bits.ReadUInt16(out flags);
		bits.ReadInt16(out stream);
		bits.ReadInt32(out cbSyms);
		bits.ReadInt32(out cbOldLines);
		bits.ReadInt32(out cbLines);
		bits.ReadInt16(out files);
		bits.ReadInt16(out pad1);
		bits.ReadUInt32(out offsets);
		bits.ReadInt32(out niSource);
		bits.ReadInt32(out niCompiler);
		if (readStrings)
		{
			bits.ReadCString(out moduleName);
			bits.ReadCString(out objectName);
		}
		else
		{
			bits.SkipCString(out moduleName);
			bits.SkipCString(out objectName);
		}
		bits.Align(4);
	}
}


using Microsoft.Cci.Pdb;

internal struct DbiSecCon
{
	internal short section;

	internal short pad1;

	internal int offset;

	internal int size;

	internal uint flags;

	internal short module;

	internal short pad2;

	internal uint dataCrc;

	internal uint relocCrc;

	internal DbiSecCon(BitAccess bits)
	{
		bits.ReadInt16(out section);
		bits.ReadInt16(out pad1);
		bits.ReadInt32(out offset);
		bits.ReadInt32(out size);
		bits.ReadUInt32(out flags);
		bits.ReadInt16(out module);
		bits.ReadInt16(out pad2);
		bits.ReadUInt32(out dataCrc);
		bits.ReadUInt32(out relocCrc);
	}
}


internal interface ILocalScope
{
	uint Offset { get; }

	uint Length { get; }
}


using System.Collections.Generic;
using Microsoft.Cci.Pdb;

internal interface INamespaceScope
{
	IEnumerable<IUsedNamespace> UsedNamespaces { get; }
}


using Microsoft.Cci.Pdb;

internal interface IUsedNamespace
{
	IName Alias { get; }

	IName NamespaceName { get; }
}


internal interface IName
{
	int UniqueKey { get; }

	int UniqueKeyIgnoringCase { get; }

	string Value { get; }
}


using System;
using Microsoft.Cci.Pdb;

internal class IntHashTable
{
	private struct bucket
	{
		internal int key;

		internal int hash_coll;

		internal object val;
	}

	private static readonly int[] primes = new int[72]
	{
		3, 7, 11, 17, 23, 29, 37, 47, 59, 71,
		89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
		631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371,
		4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591, 17519, 21023,
		25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363,
		156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403,
		968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559,
		5999471, 7199369
	};

	private bucket[] buckets;

	private int count;

	private int occupancy;

	private int loadsize;

	private int loadFactorPerc;

	private int version;

	internal object this[int key]
	{
		get
		{
			if (key < 0)
			{
				throw new ArgumentException("Argument_KeyLessThanZero");
			}
			bucket[] array = buckets;
			uint seed;
			uint incr;
			uint num = InitHash(key, array.Length, out seed, out incr);
			int num2 = 0;
			bucket bucket;
			do
			{
				int num3 = (int)(seed % (uint)array.Length);
				bucket = array[num3];
				if (bucket.val == null)
				{
					return null;
				}
				if ((bucket.hash_coll & 0x7FFFFFFF) == num && key == bucket.key)
				{
					return bucket.val;
				}
				seed += incr;
			}
			while (bucket.hash_coll < 0 && ++num2 < array.Length);
			return null;
		}
	}

	private static int GetPrime(int minSize)
	{
		if (minSize < 0)
		{
			throw new ArgumentException("Arg_HTCapacityOverflow");
		}
		for (int i = 0; i < primes.Length; i++)
		{
			int num = primes[i];
			if (num >= minSize)
			{
				return num;
			}
		}
		throw new ArgumentException("Arg_HTCapacityOverflow");
	}

	internal IntHashTable()
		: this(0, 100)
	{
	}

	internal IntHashTable(int capacity, int loadFactorPerc)
	{
		if (capacity < 0)
		{
			throw new ArgumentOutOfRangeException("capacity", "ArgumentOutOfRange_NeedNonNegNum");
		}
		if (loadFactorPerc < 10 || loadFactorPerc > 100)
		{
			throw new ArgumentOutOfRangeException("loadFactorPerc", string.Format("ArgumentOutOfRange_IntHashTableLoadFactor", 10, 100));
		}
		this.loadFactorPerc = loadFactorPerc * 72 / 100;
		int prime = GetPrime(capacity / this.loadFactorPerc);
		buckets = new bucket[prime];
		loadsize = this.loadFactorPerc * prime / 100;
		if (loadsize >= prime)
		{
			loadsize = prime - 1;
		}
	}

	private static uint InitHash(int key, int hashsize, out uint seed, out uint incr)
	{
		uint result = (seed = (uint)(key & 0x7FFFFFFF));
		incr = 1 + ((seed >> 5) + 1) % (uint)(hashsize - 1);
		return result;
	}

	internal void Add(int key, object value)
	{
		Insert(key, value, add: true);
	}

	private void expand()
	{
		rehash(GetPrime(1 + buckets.Length * 2));
	}

	private void rehash()
	{
		rehash(buckets.Length);
	}

	private void rehash(int newsize)
	{
		occupancy = 0;
		bucket[] newBuckets = new bucket[newsize];
		for (int i = 0; i < buckets.Length; i++)
		{
			bucket bucket = buckets[i];
			if (bucket.val != null)
			{
				putEntry(newBuckets, bucket.key, bucket.val, bucket.hash_coll & 0x7FFFFFFF);
			}
		}
		version++;
		buckets = newBuckets;
		loadsize = loadFactorPerc * newsize / 100;
		if (loadsize >= newsize)
		{
			loadsize = newsize - 1;
		}
	}

	private void Insert(int key, object nvalue, bool add)
	{
		if (key < 0)
		{
			throw new ArgumentException("Argument_KeyLessThanZero");
		}
		if (nvalue == null)
		{
			throw new ArgumentNullException("nvalue", "ArgumentNull_Value");
		}
		if (count >= loadsize)
		{
			expand();
		}
		else if (occupancy > loadsize && count > 100)
		{
			rehash();
		}
		uint seed;
		uint incr;
		uint num = InitHash(key, buckets.Length, out seed, out incr);
		int num2 = 0;
		int num3 = -1;
		do
		{
			int num4 = (int)(seed % (uint)buckets.Length);
			if (buckets[num4].val == null)
			{
				if (num3 != -1)
				{
					num4 = num3;
				}
				buckets[num4].val = nvalue;
				buckets[num4].key = key;
				buckets[num4].hash_coll |= (int)num;
				count++;
				version++;
				return;
			}
			if ((buckets[num4].hash_coll & 0x7FFFFFFF) == num && key == buckets[num4].key)
			{
				if (add)
				{
					throw new ArgumentException("Argument_AddingDuplicate__" + buckets[num4].key);
				}
				buckets[num4].val = nvalue;
				version++;
				return;
			}
			if (num3 == -1 && buckets[num4].hash_coll >= 0)
			{
				buckets[num4].hash_coll |= int.MinValue;
				occupancy++;
			}
			seed += incr;
		}
		while (++num2 < buckets.Length);
		if (num3 != -1)
		{
			buckets[num3].val = nvalue;
			buckets[num3].key = key;
			buckets[num3].hash_coll |= (int)num;
			count++;
			version++;
			return;
		}
		throw new InvalidOperationException("InvalidOperation_HashInsertFailed");
	}

	private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode)
	{
		uint num = (uint)hashcode;
		uint num2 = 1 + ((num >> 5) + 1) % (uint)(newBuckets.Length - 1);
		int num3;
		while (true)
		{
			num3 = (int)(num % (uint)newBuckets.Length);
			if (newBuckets[num3].val == null)
			{
				break;
			}
			if (newBuckets[num3].hash_coll >= 0)
			{
				newBuckets[num3].hash_coll |= int.MinValue;
				occupancy++;
			}
			num += num2;
		}
		newBuckets[num3].val = nvalue;
		newBuckets[num3].key = key;
		newBuckets[num3].hash_coll |= hashcode;
	}
}


private struct bucket
{
	internal int key;

	internal int hash_coll;

	internal object val;
}


using Microsoft.Cci.Pdb;

internal class MsfDirectory
{
	internal DataStream[] streams;

	internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits)
	{
		int num = reader.PagesFromSize(head.directorySize);
		bits.MinCapacity(head.directorySize);
		int num2 = head.directoryRoot.Length;
		int num3 = head.pageSize / 4;
		int num4 = num;
		for (int i = 0; i < num2; i++)
		{
			int num5 = ((num4 <= num3) ? num4 : num3);
			reader.Seek(head.directoryRoot[i], 0);
			bits.Append(reader.reader, num5 * 4);
			num4 -= num5;
		}
		bits.Position = 0;
		DataStream dataStream = new DataStream(head.directorySize, bits, num);
		bits.MinCapacity(head.directorySize);
		dataStream.Read(reader, bits);
		bits.ReadInt32(out var value);
		int[] array = new int[value];
		bits.ReadInt32(array);
		streams = new DataStream[value];
		for (int j = 0; j < value; j++)
		{
			if (array[j] <= 0)
			{
				streams[j] = new DataStream();
			}
			else
			{
				streams[j] = new DataStream(array[j], bits, reader.PagesFromSize(array[j]));
			}
		}
	}
}


using Microsoft.Cci.Pdb;

internal class PdbConstant
{
	internal string name;

	internal uint token;

	internal object value;

	internal PdbConstant(string name, uint token, object value)
	{
		this.name = name;
		this.token = token;
		this.value = value;
	}

	internal PdbConstant(BitAccess bits)
	{
		bits.ReadUInt32(out token);
		bits.ReadUInt8(out var b);
		bits.ReadUInt8(out var b2);
		switch (b2)
		{
		case 0:
			value = b;
			break;
		case 128:
			switch (b)
			{
			case 0:
			{
				bits.ReadInt8(out var b3);
				value = b3;
				break;
			}
			case 1:
			{
				bits.ReadInt16(out var num6);
				value = num6;
				break;
			}
			case 2:
			{
				bits.ReadUInt16(out var num5);
				value = num5;
				break;
			}
			case 3:
			{
				bits.ReadInt32(out var num4);
				value = num4;
				break;
			}
			case 4:
			{
				bits.ReadUInt32(out var num3);
				value = num3;
				break;
			}
			case 5:
				value = bits.ReadFloat();
				break;
			case 6:
				value = bits.ReadDouble();
				break;
			case 9:
			{
				bits.ReadInt64(out var num2);
				value = num2;
				break;
			}
			case 10:
			{
				bits.ReadUInt64(out var num);
				value = num;
				break;
			}
			case 16:
			{
				bits.ReadBString(out var text);
				value = text;
				break;
			}
			case 25:
				value = bits.ReadDecimal();
				break;
			}
			break;
		}
		bits.ReadCString(out name);
	}
}


using System.IO;

internal class PdbDebugException : IOException
{
	internal PdbDebugException(string format, params object[] args)
		: base(string.Format(format, args))
	{
	}
}


using System.IO;

internal class PdbException : IOException
{
	internal PdbException(string format, params object[] args)
		: base(string.Format(format, args))
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Cci.Pdb;

internal class PdbFile
{
	private static readonly Guid BasicLanguageGuid = new Guid(974311608, -15764, 4560, 180, 66, 0, 160, 36, 74, 29, 210);

	public static readonly Guid SymDocumentType_Text = new Guid(1518771467, 26129, 4563, 189, 42, 0, 0, 248, 8, 73, 189);

	private PdbFile()
	{
	}

	private static void LoadInjectedSourceInformation(BitAccess bits, out Guid doctype, out Guid language, out Guid vendor, out Guid checksumAlgo, out byte[] checksum)
	{
		checksum = null;
		bits.ReadGuid(out language);
		bits.ReadGuid(out vendor);
		bits.ReadGuid(out doctype);
		bits.ReadGuid(out checksumAlgo);
		bits.ReadInt32(out var value);
		bits.ReadInt32(out var _);
		if (value > 0)
		{
			checksum = new byte[value];
			bits.ReadBytes(checksum);
		}
	}

	private static Dictionary<string, int> LoadNameIndex(BitAccess bits, out int age, out Guid guid)
	{
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		bits.ReadInt32(out var _);
		bits.ReadInt32(out var _);
		bits.ReadInt32(out age);
		bits.ReadGuid(out guid);
		bits.ReadInt32(out var value3);
		int position = bits.Position;
		int position2 = bits.Position + value3;
		bits.Position = position2;
		bits.ReadInt32(out var value4);
		bits.ReadInt32(out var value5);
		BitSet bitSet = new BitSet(bits);
		new BitSet(bits);
		int num = 0;
		for (int i = 0; i < value5; i++)
		{
			if (bitSet.IsSet(i))
			{
				bits.ReadInt32(out var value6);
				bits.ReadInt32(out var value7);
				int position3 = bits.Position;
				bits.Position = position + value6;
				bits.ReadCString(out var value8);
				bits.Position = position3;
				dictionary.Add(value8.ToUpperInvariant(), value7);
				num++;
			}
		}
		if (num != value4)
		{
			throw new PdbDebugException("Count mismatch. ({0} != {1})", num, value4);
		}
		return dictionary;
	}

	private static IntHashTable LoadNameStream(BitAccess bits)
	{
		IntHashTable intHashTable = new IntHashTable();
		bits.ReadUInt32(out var value);
		bits.ReadInt32(out var value2);
		bits.ReadInt32(out var value3);
		if (value != 4026462206u || value2 != 1)
		{
			throw new PdbDebugException("Unsupported Name Stream version. (sig={0:x8}, ver={1})", value, value2);
		}
		int position = bits.Position;
		int position2 = bits.Position + value3;
		bits.Position = position2;
		bits.ReadInt32(out var value4);
		position2 = bits.Position;
		for (int i = 0; i < value4; i++)
		{
			bits.ReadInt32(out var value5);
			if (value5 != 0)
			{
				int position3 = bits.Position;
				bits.Position = position + value5;
				bits.ReadCString(out var value6);
				bits.Position = position3;
				intHashTable.Add(value5, value6);
			}
		}
		bits.Position = position2;
		return intHashTable;
	}

	private static int FindFunction(PdbFunction[] funcs, ushort sec, uint off)
	{
		PdbFunction value = new PdbFunction
		{
			segment = sec,
			address = off
		};
		return Array.BinarySearch(funcs, value, PdbFunction.byAddress);
	}

	private static void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary<string, int> nameIndex, PdbReader reader, uint limit, Dictionary<string, PdbSource> sourceCache)
	{
		Array.Sort(funcs, PdbFunction.byAddressAndToken);
		int position = bits.Position;
		IntHashTable intHashTable = ReadSourceFileInfo(bits, limit, names, dir, nameIndex, reader, sourceCache);
		bits.Position = position;
		CV_LineSection cV_LineSection = default(CV_LineSection);
		CV_SourceFile cV_SourceFile = default(CV_SourceFile);
		CV_SourceFile cV_SourceFile2 = default(CV_SourceFile);
		CV_Line cV_Line = default(CV_Line);
		while (bits.Position < limit)
		{
			bits.ReadInt32(out var value);
			bits.ReadInt32(out var value2);
			int num = bits.Position + value2;
			if (value == 242)
			{
				bits.ReadUInt32(out cV_LineSection.off);
				bits.ReadUInt16(out cV_LineSection.sec);
				bits.ReadUInt16(out cV_LineSection.flags);
				bits.ReadUInt32(out cV_LineSection.cod);
				int i = FindFunction(funcs, cV_LineSection.sec, cV_LineSection.off);
				if (i >= 0)
				{
					PdbFunction pdbFunction = funcs[i];
					if (pdbFunction.lines == null)
					{
						while (i > 0)
						{
							PdbFunction pdbFunction2 = funcs[i - 1];
							if (pdbFunction2.lines != null || pdbFunction2.segment != cV_LineSection.sec || pdbFunction2.address != cV_LineSection.off)
							{
								break;
							}
							pdbFunction = pdbFunction2;
							i--;
						}
					}
					else
					{
						for (; i < funcs.Length - 1; i++)
						{
							if (pdbFunction.lines == null)
							{
								break;
							}
							PdbFunction pdbFunction3 = funcs[i + 1];
							if (pdbFunction3.segment != cV_LineSection.sec || pdbFunction3.address != cV_LineSection.off)
							{
								break;
							}
							pdbFunction = pdbFunction3;
						}
					}
					if (pdbFunction.lines == null)
					{
						int position2 = bits.Position;
						int num2 = 0;
						while (bits.Position < num)
						{
							bits.ReadUInt32(out cV_SourceFile.index);
							bits.ReadUInt32(out cV_SourceFile.count);
							bits.ReadUInt32(out cV_SourceFile.linsiz);
							int num3 = (int)cV_SourceFile.count * (8 + (((cV_LineSection.flags & 1) != 0) ? 4 : 0));
							bits.Position += num3;
							num2++;
						}
						pdbFunction.lines = new PdbLines[num2];
						int num4 = 0;
						bits.Position = position2;
						while (bits.Position < num)
						{
							bits.ReadUInt32(out cV_SourceFile2.index);
							bits.ReadUInt32(out cV_SourceFile2.count);
							bits.ReadUInt32(out cV_SourceFile2.linsiz);
							PdbSource obj = (PdbSource)intHashTable[(int)cV_SourceFile2.index];
							if (obj.language.Equals(BasicLanguageGuid))
							{
								pdbFunction.AdjustVisualBasicScopes();
							}
							PdbLines pdbLines = new PdbLines(obj, cV_SourceFile2.count);
							pdbFunction.lines[num4++] = pdbLines;
							PdbLine[] lines = pdbLines.lines;
							int position3 = bits.Position;
							int num5 = bits.Position + (int)(8 * cV_SourceFile2.count);
							for (int j = 0; j < cV_SourceFile2.count; j++)
							{
								CV_Column cV_Column = default(CV_Column);
								bits.Position = position3 + 8 * j;
								bits.ReadUInt32(out cV_Line.offset);
								bits.ReadUInt32(out cV_Line.flags);
								uint num6 = cV_Line.flags & 0xFFFFFF;
								uint num7 = (cV_Line.flags & 0x7F000000) >> 24;
								if ((cV_LineSection.flags & 1) != 0)
								{
									bits.Position = num5 + 4 * j;
									bits.ReadUInt16(out cV_Column.offColumnStart);
									bits.ReadUInt16(out cV_Column.offColumnEnd);
								}
								lines[j] = new PdbLine(cV_Line.offset, num6, cV_Column.offColumnStart, num6 + num7, cV_Column.offColumnEnd);
							}
						}
					}
				}
			}
			bits.Position = num;
		}
	}

	private static void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, List<PdbFunction> funcList, bool readStrings, MsfDirectory dir, Dictionary<string, int> nameIndex, PdbReader reader, Dictionary<string, PdbSource> sourceCache)
	{
		PdbFunction[] array = null;
		bits.Position = 0;
		bits.ReadInt32(out var value);
		if (value != 4)
		{
			throw new PdbDebugException("Invalid signature. (sig={0})", value);
		}
		bits.Position = 4;
		array = PdbFunction.LoadManagedFunctions(bits, (uint)info.cbSyms, readStrings);
		if (array != null)
		{
			bits.Position = info.cbSyms + info.cbOldLines;
			LoadManagedLines(array, names, bits, dir, nameIndex, reader, (uint)(info.cbSyms + info.cbOldLines + info.cbLines), sourceCache);
			for (int i = 0; i < array.Length; i++)
			{
				funcList.Add(array[i]);
			}
		}
	}

	private static void LoadDbiStream(BitAccess bits, out DbiModuleInfo[] modules, out DbiDbgHdr header, bool readStrings)
	{
		DbiHeader dbiHeader = new DbiHeader(bits);
		header = default(DbiDbgHdr);
		List<DbiModuleInfo> list = new List<DbiModuleInfo>();
		int num = bits.Position + dbiHeader.gpmodiSize;
		while (bits.Position < num)
		{
			DbiModuleInfo item = new DbiModuleInfo(bits, readStrings);
			list.Add(item);
		}
		if (bits.Position != num)
		{
			throw new PdbDebugException("Error reading DBI stream, pos={0} != {1}", bits.Position, num);
		}
		if (list.Count > 0)
		{
			modules = list.ToArray();
		}
		else
		{
			modules = null;
		}
		bits.Position += dbiHeader.secconSize;
		bits.Position += dbiHeader.secmapSize;
		bits.Position += dbiHeader.filinfSize;
		bits.Position += dbiHeader.tsmapSize;
		bits.Position += dbiHeader.ecinfoSize;
		num = bits.Position + dbiHeader.dbghdrSize;
		if (dbiHeader.dbghdrSize > 0)
		{
			header = new DbiDbgHdr(bits);
		}
		bits.Position = num;
	}

	internal static PdbInfo LoadFunctions(Stream read)
	{
		PdbInfo pdbInfo = new PdbInfo();
		pdbInfo.TokenToSourceMapping = new Dictionary<uint, PdbTokenLine>();
		BitAccess bitAccess = new BitAccess(65536);
		PdbFileHeader pdbFileHeader = new PdbFileHeader(read, bitAccess);
		PdbReader reader = new PdbReader(read, pdbFileHeader.pageSize);
		MsfDirectory msfDirectory = new MsfDirectory(reader, pdbFileHeader, bitAccess);
		DbiModuleInfo[] modules = null;
		Dictionary<string, PdbSource> sourceCache = new Dictionary<string, PdbSource>();
		msfDirectory.streams[1].Read(reader, bitAccess);
		Dictionary<string, int> dictionary = LoadNameIndex(bitAccess, out pdbInfo.Age, out pdbInfo.Guid);
		if (!dictionary.TryGetValue("/NAMES", out var value))
		{
			throw new PdbException("Could not find the '/NAMES' stream: the PDB file may be a public symbol file instead of a private symbol file");
		}
		msfDirectory.streams[value].Read(reader, bitAccess);
		IntHashTable names = LoadNameStream(bitAccess);
		if (!dictionary.TryGetValue("SRCSRV", out var value2))
		{
			pdbInfo.SourceServerData = string.Empty;
		}
		else
		{
			DataStream obj = msfDirectory.streams[value2];
			byte[] array = new byte[obj.contentSize];
			obj.Read(reader, bitAccess);
			pdbInfo.SourceServerData = bitAccess.ReadBString(array.Length);
		}
		if (dictionary.TryGetValue("SOURCELINK", out var value3))
		{
			DataStream dataStream = msfDirectory.streams[value3];
			pdbInfo.SourceLinkData = new byte[dataStream.contentSize];
			dataStream.Read(reader, bitAccess);
			bitAccess.ReadBytes(pdbInfo.SourceLinkData);
		}
		msfDirectory.streams[3].Read(reader, bitAccess);
		LoadDbiStream(bitAccess, out modules, out var header, readStrings: true);
		List<PdbFunction> list = new List<PdbFunction>();
		if (modules != null)
		{
			foreach (DbiModuleInfo dbiModuleInfo in modules)
			{
				if (dbiModuleInfo.stream > 0)
				{
					msfDirectory.streams[dbiModuleInfo.stream].Read(reader, bitAccess);
					if (dbiModuleInfo.moduleName == "TokenSourceLineInfo")
					{
						LoadTokenToSourceInfo(bitAccess, dbiModuleInfo, names, msfDirectory, dictionary, reader, pdbInfo.TokenToSourceMapping, sourceCache);
					}
					else
					{
						LoadFuncsFromDbiModule(bitAccess, dbiModuleInfo, names, list, readStrings: true, msfDirectory, dictionary, reader, sourceCache);
					}
				}
			}
		}
		PdbFunction[] array2 = list.ToArray();
		if (header.snTokenRidMap != 0 && header.snTokenRidMap != ushort.MaxValue)
		{
			msfDirectory.streams[header.snTokenRidMap].Read(reader, bitAccess);
			uint[] array3 = new uint[msfDirectory.streams[header.snTokenRidMap].Length / 4];
			bitAccess.ReadUInt32(array3);
			PdbFunction[] array4 = array2;
			foreach (PdbFunction pdbFunction in array4)
			{
				pdbFunction.token = 0x6000000 | array3[pdbFunction.token & 0xFFFFFF];
			}
		}
		Array.Sort(array2, PdbFunction.byAddressAndToken);
		pdbInfo.Functions = array2;
		return pdbInfo;
	}

	private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary<string, int> nameIndex, PdbReader reader, Dictionary<uint, PdbTokenLine> tokenToSourceMapping, Dictionary<string, PdbSource> sourceCache)
	{
		bits.Position = 0;
		bits.ReadInt32(out var value);
		if (value != 4)
		{
			throw new PdbDebugException("Invalid signature. (sig={0})", value);
		}
		bits.Position = 4;
		OemSymbol oemSymbol = default(OemSymbol);
		while (bits.Position < module.cbSyms)
		{
			bits.ReadUInt16(out var value2);
			int position = bits.Position;
			int position2 = bits.Position + value2;
			bits.Position = position;
			bits.ReadUInt16(out var value3);
			switch ((SYM)value3)
			{
			case SYM.S_OEM:
				bits.ReadGuid(out oemSymbol.idOem);
				bits.ReadUInt32(out oemSymbol.typind);
				if (oemSymbol.idOem == PdbFunction.msilMetaData)
				{
					if (bits.ReadString() == "TSLI")
					{
						bits.ReadUInt32(out var value4);
						bits.ReadUInt32(out var value5);
						bits.ReadUInt32(out var value6);
						bits.ReadUInt32(out var value7);
						bits.ReadUInt32(out var value8);
						bits.ReadUInt32(out var value9);
						if (!tokenToSourceMapping.TryGetValue(value4, out var value10))
						{
							tokenToSourceMapping.Add(value4, new PdbTokenLine(value4, value5, value6, value7, value8, value9));
						}
						else
						{
							while (value10.nextLine != null)
							{
								value10 = value10.nextLine;
							}
							value10.nextLine = new PdbTokenLine(value4, value5, value6, value7, value8, value9);
						}
					}
					bits.Position = position2;
					break;
				}
				throw new PdbDebugException("OEM section: guid={0} ti={1}", oemSymbol.idOem, oemSymbol.typind);
			case SYM.S_END:
				bits.Position = position2;
				break;
			default:
				bits.Position = position2;
				break;
			}
		}
		bits.Position = module.cbSyms + module.cbOldLines;
		int limit = module.cbSyms + module.cbOldLines + module.cbLines;
		IntHashTable intHashTable = ReadSourceFileInfo(bits, (uint)limit, names, dir, nameIndex, reader, sourceCache);
		foreach (PdbTokenLine value11 in tokenToSourceMapping.Values)
		{
			value11.sourceFile = (PdbSource)intHashTable[(int)value11.file_id];
		}
	}

	private static IntHashTable ReadSourceFileInfo(BitAccess bits, uint limit, IntHashTable names, MsfDirectory dir, Dictionary<string, int> nameIndex, PdbReader reader, Dictionary<string, PdbSource> sourceCache)
	{
		IntHashTable intHashTable = new IntHashTable();
		_ = bits.Position;
		CV_FileCheckSum cV_FileCheckSum = default(CV_FileCheckSum);
		while (bits.Position < limit)
		{
			bits.ReadInt32(out var value);
			bits.ReadInt32(out var value2);
			int position = bits.Position;
			int num = bits.Position + value2;
			if (value == 244)
			{
				while (bits.Position < num)
				{
					int key = bits.Position - position;
					bits.ReadUInt32(out cV_FileCheckSum.name);
					bits.ReadUInt8(out cV_FileCheckSum.len);
					bits.ReadUInt8(out cV_FileCheckSum.type);
					string text = (string)names[(int)cV_FileCheckSum.name];
					if (!sourceCache.TryGetValue(text, out var value3))
					{
						Guid doctype = SymDocumentType_Text;
						Guid language = Guid.Empty;
						Guid vendor = Guid.Empty;
						Guid checksumAlgo = Guid.Empty;
						byte[] checksum = null;
						if (nameIndex.TryGetValue("/SRC/FILES/" + text.ToUpperInvariant(), out var value4))
						{
							BitAccess bits2 = new BitAccess(256);
							dir.streams[value4].Read(reader, bits2);
							LoadInjectedSourceInformation(bits2, out doctype, out language, out vendor, out checksumAlgo, out checksum);
						}
						value3 = new PdbSource(text, doctype, language, vendor, checksumAlgo, checksum);
						sourceCache.Add(text, value3);
					}
					intHashTable.Add(key, value3);
					bits.Position += cV_FileCheckSum.len;
					bits.Align(4);
				}
				bits.Position = num;
			}
			else
			{
				bits.Position = num;
			}
		}
		return intHashTable;
	}
}


using System.IO;
using System.Linq;
using Microsoft.Cci.Pdb;

internal class PdbFileHeader
{
	private readonly byte[] windowsPdbMagic = new byte[32]
	{
		77, 105, 99, 114, 111, 115, 111, 102, 116, 32,
		67, 47, 67, 43, 43, 32, 77, 83, 70, 32,
		55, 46, 48, 48, 13, 10, 26, 68, 83, 0,
		0, 0
	};

	internal readonly byte[] magic;

	internal readonly int pageSize;

	internal int freePageMap;

	internal int pagesUsed;

	internal int directorySize;

	internal readonly int zero;

	internal int[] directoryRoot;

	internal PdbFileHeader(Stream reader, BitAccess bits)
	{
		bits.MinCapacity(56);
		reader.Seek(0L, SeekOrigin.Begin);
		bits.FillBuffer(reader, 52);
		magic = new byte[32];
		bits.ReadBytes(magic);
		bits.ReadInt32(out pageSize);
		bits.ReadInt32(out freePageMap);
		bits.ReadInt32(out pagesUsed);
		bits.ReadInt32(out directorySize);
		bits.ReadInt32(out zero);
		if (!magic.SequenceEqual(windowsPdbMagic))
		{
			throw new PdbException("The PDB file is not recognized as a Windows PDB file");
		}
		int num = ((directorySize + pageSize - 1) / pageSize * 4 + pageSize - 1) / pageSize;
		directoryRoot = new int[num];
		bits.FillBuffer(reader, num * 4);
		bits.ReadInt32(directoryRoot);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Cci.Pdb;

internal class PdbFunction
{
	internal class PdbFunctionsByAddress : IComparer
	{
		public int Compare(object x, object y)
		{
			PdbFunction pdbFunction = (PdbFunction)x;
			PdbFunction pdbFunction2 = (PdbFunction)y;
			if (pdbFunction.segment < pdbFunction2.segment)
			{
				return -1;
			}
			if (pdbFunction.segment > pdbFunction2.segment)
			{
				return 1;
			}
			if (pdbFunction.address < pdbFunction2.address)
			{
				return -1;
			}
			if (pdbFunction.address > pdbFunction2.address)
			{
				return 1;
			}
			return 0;
		}
	}

	internal class PdbFunctionsByAddressAndToken : IComparer
	{
		public int Compare(object x, object y)
		{
			PdbFunction pdbFunction = (PdbFunction)x;
			PdbFunction pdbFunction2 = (PdbFunction)y;
			if (pdbFunction.segment < pdbFunction2.segment)
			{
				return -1;
			}
			if (pdbFunction.segment > pdbFunction2.segment)
			{
				return 1;
			}
			if (pdbFunction.address < pdbFunction2.address)
			{
				return -1;
			}
			if (pdbFunction.address > pdbFunction2.address)
			{
				return 1;
			}
			if (pdbFunction.token < pdbFunction2.token)
			{
				return -1;
			}
			if (pdbFunction.token > pdbFunction2.token)
			{
				return 1;
			}
			return 0;
		}
	}

	internal static readonly Guid msilMetaData = new Guid(3337240521u, 22963, 18902, 188, 37, 9, 2, 187, 171, 180, 96);

	internal static readonly IComparer byAddress = new PdbFunctionsByAddress();

	internal static readonly IComparer byAddressAndToken = new PdbFunctionsByAddressAndToken();

	internal uint token;

	internal uint slotToken;

	internal uint tokenOfMethodWhoseUsingInfoAppliesToThisMethod;

	internal uint segment;

	internal uint address;

	internal uint length;

	internal PdbScope[] scopes;

	internal PdbSlot[] slots;

	internal PdbConstant[] constants;

	internal string[] usedNamespaces;

	internal PdbLines[] lines;

	internal ushort[] usingCounts;

	internal IEnumerable<INamespaceScope> namespaceScopes;

	internal string iteratorClass;

	internal List<ILocalScope> iteratorScopes;

	internal PdbSynchronizationInformation synchronizationInformation;

	private bool visualBasicScopesAdjusted;

	private static string StripNamespace(string module)
	{
		int num = module.LastIndexOf('.');
		if (num > 0)
		{
			return module.Substring(num + 1);
		}
		return module;
	}

	internal void AdjustVisualBasicScopes()
	{
		if (!visualBasicScopesAdjusted)
		{
			visualBasicScopesAdjusted = true;
			PdbScope[] array = scopes;
			foreach (PdbScope pdbScope in array)
			{
				AdjustVisualBasicScopes(pdbScope.scopes);
			}
		}
	}

	private void AdjustVisualBasicScopes(PdbScope[] scopes)
	{
		foreach (PdbScope pdbScope in scopes)
		{
			pdbScope.length++;
			AdjustVisualBasicScopes(pdbScope.scopes);
		}
	}

	internal static PdbFunction[] LoadManagedFunctions(BitAccess bits, uint limit, bool readStrings)
	{
		int position = bits.Position;
		int num = 0;
		ManProcSym manProcSym = default(ManProcSym);
		while (bits.Position < limit)
		{
			bits.ReadUInt16(out var value);
			int position2 = bits.Position;
			int position3 = bits.Position + value;
			bits.Position = position2;
			bits.ReadUInt16(out var value2);
			switch ((SYM)value2)
			{
			case SYM.S_GMANPROC:
			case SYM.S_LMANPROC:
				bits.ReadUInt32(out manProcSym.parent);
				bits.ReadUInt32(out manProcSym.end);
				bits.Position = (int)manProcSym.end;
				num++;
				break;
			case SYM.S_END:
				bits.Position = position3;
				break;
			default:
				bits.Position = position3;
				break;
			}
		}
		if (num == 0)
		{
			return null;
		}
		bits.Position = position;
		PdbFunction[] array = new PdbFunction[num];
		int num2 = 0;
		ManProcSym proc = default(ManProcSym);
		while (bits.Position < limit)
		{
			bits.ReadUInt16(out var value3);
			_ = bits.Position;
			int position4 = bits.Position + value3;
			bits.ReadUInt16(out var value4);
			SYM sYM = (SYM)value4;
			if ((uint)(sYM - 4394) <= 1u)
			{
				bits.ReadUInt32(out proc.parent);
				bits.ReadUInt32(out proc.end);
				bits.ReadUInt32(out proc.next);
				bits.ReadUInt32(out proc.len);
				bits.ReadUInt32(out proc.dbgStart);
				bits.ReadUInt32(out proc.dbgEnd);
				bits.ReadUInt32(out proc.token);
				bits.ReadUInt32(out proc.off);
				bits.ReadUInt16(out proc.seg);
				bits.ReadUInt8(out proc.flags);
				bits.ReadUInt16(out proc.retReg);
				if (readStrings)
				{
					bits.ReadCString(out proc.name);
				}
				else
				{
					bits.SkipCString(out proc.name);
				}
				bits.Position = position4;
				array[num2++] = new PdbFunction(proc, bits);
			}
			else
			{
				bits.Position = position4;
			}
		}
		return array;
	}

	internal static void CountScopesAndSlots(BitAccess bits, uint limit, out int constants, out int scopes, out int slots, out int usedNamespaces)
	{
		int position = bits.Position;
		constants = 0;
		slots = 0;
		scopes = 0;
		usedNamespaces = 0;
		BlockSym32 blockSym = default(BlockSym32);
		while (bits.Position < limit)
		{
			bits.ReadUInt16(out var value);
			int position2 = bits.Position;
			int position3 = bits.Position + value;
			bits.Position = position2;
			bits.ReadUInt16(out var value2);
			switch ((SYM)value2)
			{
			case SYM.S_BLOCK32:
				bits.ReadUInt32(out blockSym.parent);
				bits.ReadUInt32(out blockSym.end);
				scopes++;
				bits.Position = (int)blockSym.end;
				break;
			case SYM.S_MANSLOT:
				slots++;
				bits.Position = position3;
				break;
			case SYM.S_UNAMESPACE:
				usedNamespaces++;
				bits.Position = position3;
				break;
			case SYM.S_MANCONSTANT:
				constants++;
				bits.Position = position3;
				break;
			default:
				bits.Position = position3;
				break;
			}
		}
		bits.Position = position;
	}

	internal PdbFunction()
	{
	}

	internal PdbFunction(ManProcSym proc, BitAccess bits)
	{
		token = proc.token;
		segment = proc.seg;
		address = proc.off;
		length = proc.len;
		if (proc.seg != 1)
		{
			throw new PdbDebugException("Segment is {0}, not 1.", proc.seg);
		}
		if (proc.parent != 0 || proc.next != 0)
		{
			throw new PdbDebugException("Warning parent={0}, next={1}", proc.parent, proc.next);
		}
		CountScopesAndSlots(bits, proc.end, out var num, out var num2, out var num3, out var num4);
		int num5 = ((num > 0 || num3 > 0 || num4 > 0) ? 1 : 0);
		int num6 = 0;
		int num7 = 0;
		int num8 = 0;
		scopes = new PdbScope[num2 + num5];
		slots = new PdbSlot[num3];
		constants = new PdbConstant[num];
		usedNamespaces = new string[num4];
		if (num5 > 0)
		{
			scopes[0] = new PdbScope(address, proc.len, slots, constants, usedNamespaces);
		}
		OemSymbol oemSymbol = default(OemSymbol);
		while (bits.Position < proc.end)
		{
			bits.ReadUInt16(out var value);
			int position = bits.Position;
			int position2 = bits.Position + value;
			bits.Position = position;
			bits.ReadUInt16(out var value2);
			switch ((SYM)value2)
			{
			case SYM.S_OEM:
				bits.ReadGuid(out oemSymbol.idOem);
				bits.ReadUInt32(out oemSymbol.typind);
				if (oemSymbol.idOem == msilMetaData)
				{
					string text = bits.ReadString();
					if (text == "MD2")
					{
						ReadMD2CustomMetadata(bits);
					}
					else if (text == "asyncMethodInfo")
					{
						synchronizationInformation = new PdbSynchronizationInformation(bits);
					}
					bits.Position = position2;
					break;
				}
				throw new PdbDebugException("OEM section: guid={0} ti={1}", oemSymbol.idOem, oemSymbol.typind);
			case SYM.S_BLOCK32:
			{
				BlockSym32 block = default(BlockSym32);
				bits.ReadUInt32(out block.parent);
				bits.ReadUInt32(out block.end);
				bits.ReadUInt32(out block.len);
				bits.ReadUInt32(out block.off);
				bits.ReadUInt16(out block.seg);
				bits.SkipCString(out block.name);
				bits.Position = position2;
				scopes[num5++] = new PdbScope(address, block, bits, out slotToken);
				bits.Position = (int)block.end;
				break;
			}
			case SYM.S_MANSLOT:
				slots[num6++] = new PdbSlot(bits);
				bits.Position = position2;
				break;
			case SYM.S_MANCONSTANT:
				constants[num7++] = new PdbConstant(bits);
				bits.Position = position2;
				break;
			case SYM.S_UNAMESPACE:
				bits.ReadCString(out usedNamespaces[num8++]);
				bits.Position = position2;
				break;
			case SYM.S_END:
				bits.Position = position2;
				break;
			default:
				bits.Position = position2;
				break;
			}
		}
		if (bits.Position != proc.end)
		{
			throw new PdbDebugException("Not at S_END");
		}
		bits.ReadUInt16(out var _);
		bits.ReadUInt16(out var value4);
		if (value4 != 6)
		{
			throw new PdbDebugException("Missing S_END");
		}
	}

	internal void ReadMD2CustomMetadata(BitAccess bits)
	{
		bits.ReadUInt8(out var value);
		if (value == 4)
		{
			bits.ReadUInt8(out var value2);
			bits.Align(4);
			while (value2-- > 0)
			{
				ReadCustomMetadata(bits);
			}
		}
	}

	private void ReadCustomMetadata(BitAccess bits)
	{
		int position = bits.Position;
		bits.ReadUInt8(out var value);
		bits.ReadUInt8(out var value2);
		bits.Position += 2;
		bits.ReadUInt32(out var value3);
		if (value == 4)
		{
			switch (value2)
			{
			case 0:
				ReadUsingInfo(bits);
				break;
			case 1:
				ReadForwardInfo(bits);
				break;
			case 3:
				ReadIteratorLocals(bits);
				break;
			case 4:
				ReadForwardIterator(bits);
				break;
			}
		}
		bits.Position = position + (int)value3;
	}

	private void ReadForwardIterator(BitAccess bits)
	{
		iteratorClass = bits.ReadString();
	}

	private void ReadIteratorLocals(BitAccess bits)
	{
		bits.ReadUInt32(out var value);
		iteratorScopes = new List<ILocalScope>((int)value);
		while (value-- != 0)
		{
			bits.ReadUInt32(out var value2);
			bits.ReadUInt32(out var value3);
			iteratorScopes.Add(new PdbIteratorScope(value2, value3 - value2));
		}
	}

	private void ReadForwardInfo(BitAccess bits)
	{
		bits.ReadUInt32(out tokenOfMethodWhoseUsingInfoAppliesToThisMethod);
	}

	private void ReadUsingInfo(BitAccess bits)
	{
		bits.ReadUInt16(out var value);
		usingCounts = new ushort[value];
		for (ushort num = 0; num < value; num++)
		{
			bits.ReadUInt16(out usingCounts[num]);
		}
	}
}


using System.Collections;

internal class PdbFunctionsByAddress : IComparer
{
	public int Compare(object x, object y)
	{
		PdbFunction pdbFunction = (PdbFunction)x;
		PdbFunction pdbFunction2 = (PdbFunction)y;
		if (pdbFunction.segment < pdbFunction2.segment)
		{
			return -1;
		}
		if (pdbFunction.segment > pdbFunction2.segment)
		{
			return 1;
		}
		if (pdbFunction.address < pdbFunction2.address)
		{
			return -1;
		}
		if (pdbFunction.address > pdbFunction2.address)
		{
			return 1;
		}
		return 0;
	}
}


using System.Collections;

internal class PdbFunctionsByAddressAndToken : IComparer
{
	public int Compare(object x, object y)
	{
		PdbFunction pdbFunction = (PdbFunction)x;
		PdbFunction pdbFunction2 = (PdbFunction)y;
		if (pdbFunction.segment < pdbFunction2.segment)
		{
			return -1;
		}
		if (pdbFunction.segment > pdbFunction2.segment)
		{
			return 1;
		}
		if (pdbFunction.address < pdbFunction2.address)
		{
			return -1;
		}
		if (pdbFunction.address > pdbFunction2.address)
		{
			return 1;
		}
		if (pdbFunction.token < pdbFunction2.token)
		{
			return -1;
		}
		if (pdbFunction.token > pdbFunction2.token)
		{
			return 1;
		}
		return 0;
	}
}


using Microsoft.Cci.Pdb;

internal class PdbSynchronizationInformation
{
	internal uint kickoffMethodToken;

	internal uint generatedCatchHandlerIlOffset;

	internal PdbSynchronizationPoint[] synchronizationPoints;

	public uint GeneratedCatchHandlerOffset => generatedCatchHandlerIlOffset;

	internal PdbSynchronizationInformation(BitAccess bits)
	{
		bits.ReadUInt32(out kickoffMethodToken);
		bits.ReadUInt32(out generatedCatchHandlerIlOffset);
		bits.ReadUInt32(out var value);
		synchronizationPoints = new PdbSynchronizationPoint[value];
		for (uint num = 0u; num < value; num++)
		{
			synchronizationPoints[num] = new PdbSynchronizationPoint(bits);
		}
	}
}


using Microsoft.Cci.Pdb;

internal class PdbSynchronizationPoint
{
	internal uint synchronizeOffset;

	internal uint continuationMethodToken;

	internal uint continuationOffset;

	public uint SynchronizeOffset => synchronizeOffset;

	public uint ContinuationOffset => continuationOffset;

	internal PdbSynchronizationPoint(BitAccess bits)
	{
		bits.ReadUInt32(out synchronizeOffset);
		bits.ReadUInt32(out continuationMethodToken);
		bits.ReadUInt32(out continuationOffset);
	}
}


using System;
using System.Collections.Generic;
using Microsoft.Cci.Pdb;

internal class PdbInfo
{
	public PdbFunction[] Functions;

	public Dictionary<uint, PdbTokenLine> TokenToSourceMapping;

	public string SourceServerData;

	public int Age;

	public Guid Guid;

	public byte[] SourceLinkData;
}


internal struct PdbLine
{
	internal uint offset;

	internal uint lineBegin;

	internal uint lineEnd;

	internal ushort colBegin;

	internal ushort colEnd;

	internal PdbLine(uint offset, uint lineBegin, ushort colBegin, uint lineEnd, ushort colEnd)
	{
		this.offset = offset;
		this.lineBegin = lineBegin;
		this.colBegin = colBegin;
		this.lineEnd = lineEnd;
		this.colEnd = colEnd;
	}
}


using Microsoft.Cci.Pdb;

internal class PdbLines
{
	internal PdbSource file;

	internal PdbLine[] lines;

	internal PdbLines(PdbSource file, uint count)
	{
		this.file = file;
		lines = new PdbLine[count];
	}
}


using System.IO;

internal class PdbReader
{
	internal readonly int pageSize;

	internal readonly Stream reader;

	internal PdbReader(Stream reader, int pageSize)
	{
		this.pageSize = pageSize;
		this.reader = reader;
	}

	internal void Seek(int page, int offset)
	{
		reader.Seek(page * pageSize + offset, SeekOrigin.Begin);
	}

	internal void Read(byte[] bytes, int offset, int count)
	{
		reader.Read(bytes, offset, count);
	}

	internal int PagesFromSize(int size)
	{
		return (size + pageSize - 1) / pageSize;
	}
}


using System;
using Microsoft.Cci.Pdb;

internal class PdbScope
{
	internal PdbConstant[] constants;

	internal PdbSlot[] slots;

	internal PdbScope[] scopes;

	internal string[] usedNamespaces;

	internal uint address;

	internal uint offset;

	internal uint length;

	internal PdbScope(uint address, uint offset, uint length, PdbSlot[] slots, PdbConstant[] constants, string[] usedNamespaces)
	{
		this.constants = constants;
		this.slots = slots;
		scopes = new PdbScope[0];
		this.usedNamespaces = usedNamespaces;
		this.address = address;
		this.offset = offset;
		this.length = length;
	}

	internal PdbScope(uint address, uint length, PdbSlot[] slots, PdbConstant[] constants, string[] usedNamespaces)
		: this(address, 0u, length, slots, constants, usedNamespaces)
	{
	}

	internal PdbScope(uint funcOffset, BlockSym32 block, BitAccess bits, out uint typind)
	{
		address = block.off;
		offset = block.off - funcOffset;
		length = block.len;
		typind = 0u;
		PdbFunction.CountScopesAndSlots(bits, block.end, out var num, out var num2, out var num3, out var num4);
		constants = new PdbConstant[num];
		scopes = new PdbScope[num2];
		slots = new PdbSlot[num3];
		usedNamespaces = new string[num4];
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		int num8 = 0;
		while (bits.Position < block.end)
		{
			bits.ReadUInt16(out var value);
			int position = bits.Position;
			int position2 = bits.Position + value;
			bits.Position = position;
			bits.ReadUInt16(out var value2);
			switch ((SYM)value2)
			{
			case SYM.S_BLOCK32:
			{
				BlockSym32 block2 = default(BlockSym32);
				bits.ReadUInt32(out block2.parent);
				bits.ReadUInt32(out block2.end);
				bits.ReadUInt32(out block2.len);
				bits.ReadUInt32(out block2.off);
				bits.ReadUInt16(out block2.seg);
				bits.SkipCString(out block2.name);
				bits.Position = position2;
				scopes[num6++] = new PdbScope(funcOffset, block2, bits, out typind);
				break;
			}
			case SYM.S_MANSLOT:
				slots[num7++] = new PdbSlot(bits);
				bits.Position = position2;
				break;
			case SYM.S_UNAMESPACE:
				bits.ReadCString(out usedNamespaces[num8++]);
				bits.Position = position2;
				break;
			case SYM.S_END:
				bits.Position = position2;
				break;
			case SYM.S_MANCONSTANT:
				constants[num5++] = new PdbConstant(bits);
				bits.Position = position2;
				break;
			default:
				bits.Position = position2;
				break;
			}
		}
		if (bits.Position != block.end)
		{
			throw new Exception("Not at S_END");
		}
		bits.ReadUInt16(out var _);
		bits.ReadUInt16(out var value4);
		if (value4 != 6)
		{
			throw new Exception("Missing S_END");
		}
	}
}


using Microsoft.Cci.Pdb;

internal class PdbSlot
{
	internal uint slot;

	internal uint typeToken;

	internal string name;

	internal ushort flags;

	internal PdbSlot(uint slot, uint typeToken, string name, ushort flags)
	{
		this.slot = slot;
		this.typeToken = typeToken;
		this.name = name;
		this.flags = flags;
	}

	internal PdbSlot(BitAccess bits)
	{
		AttrSlotSym attrSlotSym = default(AttrSlotSym);
		bits.ReadUInt32(out attrSlotSym.index);
		bits.ReadUInt32(out attrSlotSym.typind);
		bits.ReadUInt32(out attrSlotSym.offCod);
		bits.ReadUInt16(out attrSlotSym.segCod);
		bits.ReadUInt16(out attrSlotSym.flags);
		bits.ReadCString(out attrSlotSym.name);
		slot = attrSlotSym.index;
		typeToken = attrSlotSym.typind;
		name = attrSlotSym.name;
		flags = attrSlotSym.flags;
	}
}


using System;

internal class PdbSource
{
	internal string name;

	internal Guid doctype;

	internal Guid language;

	internal Guid vendor;

	internal Guid checksumAlgorithm;

	internal byte[] checksum;

	internal PdbSource(string name, Guid doctype, Guid language, Guid vendor, Guid checksumAlgorithm, byte[] checksum)
	{
		this.name = name;
		this.doctype = doctype;
		this.language = language;
		this.vendor = vendor;
		this.checksumAlgorithm = checksumAlgorithm;
		this.checksum = checksum;
	}
}


using Microsoft.Cci.Pdb;

internal class PdbTokenLine
{
	internal uint token;

	internal uint file_id;

	internal uint line;

	internal uint column;

	internal uint endLine;

	internal uint endColumn;

	internal PdbSource sourceFile;

	internal PdbTokenLine nextLine;

	internal PdbTokenLine(uint token, uint file_id, uint line, uint column, uint endLine, uint endColumn)
	{
		this.token = token;
		this.file_id = file_id;
		this.line = line;
		this.column = column;
		this.endLine = endLine;
		this.endColumn = endColumn;
	}
}


using Microsoft.Cci.Pdb;

internal sealed class PdbIteratorScope : ILocalScope
{
	private uint offset;

	private uint length;

	public uint Offset => offset;

	public uint Length => length;

	internal PdbIteratorScope(uint offset, uint length)
	{
		this.offset = offset;
		this.length = length;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Rocks;

internal class DocCommentId
{
	private class GenericTypeOptions
	{
		public bool IsArgument { get; set; }

		public bool IsNestedType { get; set; }

		public IList<TypeReference> Arguments { get; set; }

		public int ArgumentIndex { get; set; }

		public static GenericTypeOptions Empty()
		{
			return new GenericTypeOptions();
		}
	}

	private IMemberDefinition commentMember;

	private StringBuilder id;

	private DocCommentId(IMemberDefinition member)
	{
		commentMember = member;
		id = new StringBuilder();
	}

	private void WriteField(FieldDefinition field)
	{
		WriteDefinition('F', field);
	}

	private void WriteEvent(EventDefinition @event)
	{
		WriteDefinition('E', @event);
	}

	private void WriteType(TypeDefinition type)
	{
		id.Append('T').Append(':');
		WriteTypeFullName(type);
	}

	private void WriteMethod(MethodDefinition method)
	{
		WriteDefinition('M', method);
		if (method.HasGenericParameters)
		{
			id.Append('`').Append('`');
			id.Append(method.GenericParameters.Count);
		}
		if (method.HasParameters)
		{
			WriteParameters(method.Parameters);
		}
		if (IsConversionOperator(method))
		{
			WriteReturnType(method);
		}
	}

	private static bool IsConversionOperator(MethodDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (self.IsSpecialName)
		{
			if (!(self.Name == "op_Explicit"))
			{
				return self.Name == "op_Implicit";
			}
			return true;
		}
		return false;
	}

	private void WriteReturnType(MethodDefinition method)
	{
		id.Append('~');
		WriteTypeSignature(method.ReturnType);
	}

	private void WriteProperty(PropertyDefinition property)
	{
		WriteDefinition('P', property);
		if (property.HasParameters)
		{
			WriteParameters(property.Parameters);
		}
	}

	private void WriteParameters(IList<ParameterDefinition> parameters)
	{
		id.Append('(');
		WriteList(parameters, delegate(ParameterDefinition p)
		{
			WriteTypeSignature(p.ParameterType);
		});
		id.Append(')');
	}

	private void WriteTypeSignature(TypeReference type)
	{
		switch (type.MetadataType)
		{
		case MetadataType.Array:
			WriteArrayTypeSignature((ArrayType)type);
			break;
		case MetadataType.ByReference:
			WriteTypeSignature(((ByReferenceType)type).ElementType);
			id.Append('@');
			break;
		case MetadataType.FunctionPointer:
			WriteFunctionPointerTypeSignature((FunctionPointerType)type);
			break;
		case MetadataType.GenericInstance:
			WriteGenericInstanceTypeSignature((GenericInstanceType)type);
			break;
		case MetadataType.Var:
			if (IsGenericMethodTypeParameter(type))
			{
				id.Append('`');
			}
			id.Append('`');
			id.Append(((GenericParameter)type).Position);
			break;
		case MetadataType.MVar:
			id.Append('`').Append('`');
			id.Append(((GenericParameter)type).Position);
			break;
		case MetadataType.OptionalModifier:
			WriteModiferTypeSignature((OptionalModifierType)type, '!');
			break;
		case MetadataType.RequiredModifier:
			WriteModiferTypeSignature((RequiredModifierType)type, '|');
			break;
		case MetadataType.Pointer:
			WriteTypeSignature(((PointerType)type).ElementType);
			id.Append('*');
			break;
		default:
			WriteTypeFullName(type);
			break;
		}
	}

	private bool IsGenericMethodTypeParameter(TypeReference type)
	{
		if (commentMember is MethodDefinition methodDefinition)
		{
			GenericParameter genericParameter = type as GenericParameter;
			if (genericParameter != null)
			{
				return methodDefinition.GenericParameters.Any((GenericParameter i) => i.Name == genericParameter.Name);
			}
		}
		return false;
	}

	private void WriteGenericInstanceTypeSignature(GenericInstanceType type)
	{
		if (type.ElementType.IsTypeSpecification())
		{
			throw new NotSupportedException();
		}
		GenericTypeOptions options = new GenericTypeOptions
		{
			IsArgument = true,
			IsNestedType = type.IsNested,
			Arguments = type.GenericArguments
		};
		WriteTypeFullName(type.ElementType, options);
	}

	private void WriteList<T>(IList<T> list, Action<T> action)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (i > 0)
			{
				id.Append(',');
			}
			action(list[i]);
		}
	}

	private void WriteModiferTypeSignature(IModifierType type, char id)
	{
		WriteTypeSignature(type.ElementType);
		this.id.Append(id);
		WriteTypeSignature(type.ModifierType);
	}

	private void WriteFunctionPointerTypeSignature(FunctionPointerType type)
	{
		id.Append("=FUNC:");
		WriteTypeSignature(type.ReturnType);
		if (type.HasParameters)
		{
			WriteParameters(type.Parameters);
		}
	}

	private void WriteArrayTypeSignature(ArrayType type)
	{
		WriteTypeSignature(type.ElementType);
		if (type.IsVector)
		{
			id.Append("[]");
			return;
		}
		id.Append("[");
		WriteList(type.Dimensions, delegate(ArrayDimension dimension)
		{
			if (dimension.LowerBound.HasValue)
			{
				id.Append(dimension.LowerBound.Value);
			}
			id.Append(':');
			if (dimension.UpperBound.HasValue)
			{
				id.Append(dimension.UpperBound.Value - (dimension.LowerBound.GetValueOrDefault() + 1));
			}
		});
		id.Append("]");
	}

	private void WriteDefinition(char id, IMemberDefinition member)
	{
		this.id.Append(id).Append(':');
		WriteTypeFullName(member.DeclaringType);
		this.id.Append('.');
		WriteItemName(member.Name);
	}

	private void WriteTypeFullName(TypeReference type)
	{
		WriteTypeFullName(type, GenericTypeOptions.Empty());
	}

	private void WriteTypeFullName(TypeReference type, GenericTypeOptions options)
	{
		if (type.DeclaringType != null)
		{
			WriteTypeFullName(type.DeclaringType, options);
			id.Append('.');
		}
		if (!string.IsNullOrEmpty(type.Namespace))
		{
			id.Append(type.Namespace);
			id.Append('.');
		}
		string text = type.Name;
		if (options.IsArgument)
		{
			int num = text.LastIndexOf('`');
			if (num > 0)
			{
				text = text.Substring(0, num);
			}
		}
		id.Append(text);
		WriteGenericTypeParameters(type, options);
	}

	private void WriteGenericTypeParameters(TypeReference type, GenericTypeOptions options)
	{
		if (options.IsArgument && IsGenericType(type))
		{
			id.Append('{');
			WriteList(GetGenericTypeArguments(type, options), WriteTypeSignature);
			id.Append('}');
		}
	}

	private static bool IsGenericType(TypeReference type)
	{
		if (type.HasGenericParameters)
		{
			string text = string.Empty;
			int num = type.Name.LastIndexOf('`');
			if (num >= 0)
			{
				text = type.Name.Substring(0, num);
			}
			return type.Name.LastIndexOf('`') == text.Length;
		}
		return false;
	}

	private IList<TypeReference> GetGenericTypeArguments(TypeReference type, GenericTypeOptions options)
	{
		if (options.IsNestedType)
		{
			int count = type.GenericParameters.Count;
			List<TypeReference> result = options.Arguments.Skip(options.ArgumentIndex).Take(count).ToList();
			options.ArgumentIndex += count;
			return result;
		}
		return options.Arguments;
	}

	private void WriteItemName(string name)
	{
		id.Append(name.Replace('.', '#').Replace('<', '{').Replace('>', '}'));
	}

	public override string ToString()
	{
		return id.ToString();
	}

	public static string GetDocCommentId(IMemberDefinition member)
	{
		if (member == null)
		{
			throw new ArgumentNullException("member");
		}
		DocCommentId docCommentId = new DocCommentId(member);
		switch (member.MetadataToken.TokenType)
		{
		case TokenType.Field:
			docCommentId.WriteField((FieldDefinition)member);
			break;
		case TokenType.Method:
			docCommentId.WriteMethod((MethodDefinition)member);
			break;
		case TokenType.TypeDef:
			docCommentId.WriteType((TypeDefinition)member);
			break;
		case TokenType.Event:
			docCommentId.WriteEvent((EventDefinition)member);
			break;
		case TokenType.Property:
			docCommentId.WriteProperty((PropertyDefinition)member);
			break;
		default:
			throw new NotSupportedException(member.FullName);
		}
		return docCommentId.ToString();
	}
}


using System.Collections.Generic;

private class GenericTypeOptions
{
	public bool IsArgument { get; set; }

	public bool IsNestedType { get; set; }

	public IList<TypeReference> Arguments { get; set; }

	public int ArgumentIndex { get; set; }

	public static GenericTypeOptions Empty()
	{
		return new GenericTypeOptions();
	}
}


using System;
using System.Collections.Generic;

internal static class Functional
{
	public static Func<A, R> Y<A, R>(Func<Func<A, R>, Func<A, R>> f)
	{
		Func<A, R> g = null;
		g = f((A a) => g(a));
		return g;
	}

	public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		return PrependIterator(source, element);
	}

	private static IEnumerable<TSource> PrependIterator<TSource>(IEnumerable<TSource> source, TSource element)
	{
		yield return element;
		foreach (TSource item in source)
		{
			yield return item;
		}
	}
}


using Mono.Cecil;
using Mono.Cecil.Cil;

internal interface IILVisitor
{
	void OnInlineNone(OpCode opcode);

	void OnInlineSByte(OpCode opcode, sbyte value);

	void OnInlineByte(OpCode opcode, byte value);

	void OnInlineInt32(OpCode opcode, int value);

	void OnInlineInt64(OpCode opcode, long value);

	void OnInlineSingle(OpCode opcode, float value);

	void OnInlineDouble(OpCode opcode, double value);

	void OnInlineString(OpCode opcode, string value);

	void OnInlineBranch(OpCode opcode, int offset);

	void OnInlineSwitch(OpCode opcode, int[] offsets);

	void OnInlineVariable(OpCode opcode, VariableDefinition variable);

	void OnInlineArgument(OpCode opcode, ParameterDefinition parameter);

	void OnInlineSignature(OpCode opcode, CallSite callSite);

	void OnInlineType(OpCode opcode, TypeReference type);

	void OnInlineField(OpCode opcode, FieldReference field);

	void OnInlineMethod(OpCode opcode, MethodReference method);
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;
using Mono.Collections.Generic;

internal static class ILParser
{
	private class ParseContext
	{
		public CodeReader Code { get; set; }

		public int Position { get; set; }

		public MetadataReader Metadata { get; set; }

		public Collection<VariableDefinition> Variables { get; set; }

		public IILVisitor Visitor { get; set; }
	}

	public static void Parse(MethodDefinition method, IILVisitor visitor)
	{
		if (method == null)
		{
			throw new ArgumentNullException("method");
		}
		if (visitor == null)
		{
			throw new ArgumentNullException("visitor");
		}
		if (!method.HasBody || !method.HasImage)
		{
			throw new ArgumentException();
		}
		method.Module.Read(method, delegate(MethodDefinition m, MetadataReader _)
		{
			ParseMethod(m, visitor);
			return true;
		});
	}

	private static void ParseMethod(MethodDefinition method, IILVisitor visitor)
	{
		ParseContext parseContext = CreateContext(method, visitor);
		CodeReader code = parseContext.Code;
		byte b = code.ReadByte();
		switch (b & 3)
		{
		case 2:
			ParseCode(b >> 2, parseContext);
			break;
		case 3:
			code.Advance(-1);
			ParseFatMethod(parseContext);
			break;
		default:
			throw new NotSupportedException();
		}
		code.MoveBackTo(parseContext.Position);
	}

	private static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor)
	{
		CodeReader codeReader = method.Module.Read(method, (MethodDefinition _, MetadataReader reader) => reader.code);
		int position = codeReader.MoveTo(method);
		return new ParseContext
		{
			Code = codeReader,
			Position = position,
			Metadata = codeReader.reader,
			Visitor = visitor
		};
	}

	private static void ParseFatMethod(ParseContext context)
	{
		CodeReader code = context.Code;
		code.Advance(4);
		int code_size = code.ReadInt32();
		MetadataToken metadataToken = code.ReadToken();
		if (metadataToken != MetadataToken.Zero)
		{
			context.Variables = code.ReadVariables(metadataToken);
		}
		ParseCode(code_size, context);
	}

	private static void ParseCode(int code_size, ParseContext context)
	{
		CodeReader code = context.Code;
		MetadataReader metadata = context.Metadata;
		IILVisitor visitor = context.Visitor;
		int num = code.Position + code_size;
		while (code.Position < num)
		{
			byte b = code.ReadByte();
			OpCode opCode = ((b != 254) ? OpCodes.OneByteOpCode[b] : OpCodes.TwoBytesOpCode[code.ReadByte()]);
			switch (opCode.OperandType)
			{
			case OperandType.InlineNone:
				visitor.OnInlineNone(opCode);
				break;
			case OperandType.InlineSwitch:
			{
				int num2 = code.ReadInt32();
				int[] array = new int[num2];
				for (int i = 0; i < num2; i++)
				{
					array[i] = code.ReadInt32();
				}
				visitor.OnInlineSwitch(opCode, array);
				break;
			}
			case OperandType.ShortInlineBrTarget:
				visitor.OnInlineBranch(opCode, code.ReadSByte());
				break;
			case OperandType.InlineBrTarget:
				visitor.OnInlineBranch(opCode, code.ReadInt32());
				break;
			case OperandType.ShortInlineI:
				if (opCode == OpCodes.Ldc_I4_S)
				{
					visitor.OnInlineSByte(opCode, code.ReadSByte());
				}
				else
				{
					visitor.OnInlineByte(opCode, code.ReadByte());
				}
				break;
			case OperandType.InlineI:
				visitor.OnInlineInt32(opCode, code.ReadInt32());
				break;
			case OperandType.InlineI8:
				visitor.OnInlineInt64(opCode, code.ReadInt64());
				break;
			case OperandType.ShortInlineR:
				visitor.OnInlineSingle(opCode, code.ReadSingle());
				break;
			case OperandType.InlineR:
				visitor.OnInlineDouble(opCode, code.ReadDouble());
				break;
			case OperandType.InlineSig:
				visitor.OnInlineSignature(opCode, code.GetCallSite(code.ReadToken()));
				break;
			case OperandType.InlineString:
				visitor.OnInlineString(opCode, code.GetString(code.ReadToken()));
				break;
			case OperandType.ShortInlineArg:
				visitor.OnInlineArgument(opCode, code.GetParameter(code.ReadByte()));
				break;
			case OperandType.InlineArg:
				visitor.OnInlineArgument(opCode, code.GetParameter(code.ReadInt16()));
				break;
			case OperandType.ShortInlineVar:
				visitor.OnInlineVariable(opCode, GetVariable(context, code.ReadByte()));
				break;
			case OperandType.InlineVar:
				visitor.OnInlineVariable(opCode, GetVariable(context, code.ReadInt16()));
				break;
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			{
				IMetadataTokenProvider metadataTokenProvider = metadata.LookupToken(code.ReadToken());
				switch (metadataTokenProvider.MetadataToken.TokenType)
				{
				case TokenType.TypeRef:
				case TokenType.TypeDef:
				case TokenType.TypeSpec:
					visitor.OnInlineType(opCode, (TypeReference)metadataTokenProvider);
					break;
				case TokenType.Method:
				case TokenType.MethodSpec:
					visitor.OnInlineMethod(opCode, (MethodReference)metadataTokenProvider);
					break;
				case TokenType.Field:
					visitor.OnInlineField(opCode, (FieldReference)metadataTokenProvider);
					break;
				case TokenType.MemberRef:
					if (metadataTokenProvider is FieldReference field)
					{
						visitor.OnInlineField(opCode, field);
						break;
					}
					if (metadataTokenProvider is MethodReference method)
					{
						visitor.OnInlineMethod(opCode, method);
						break;
					}
					throw new InvalidOperationException();
				}
				break;
			}
			}
		}
	}

	private static VariableDefinition GetVariable(ParseContext context, int index)
	{
		return context.Variables[index];
	}
}


using Mono.Cecil.Cil;
using Mono.Collections.Generic;

private class ParseContext
{
	public CodeReader Code { get; set; }

	public int Position { get; set; }

	public MetadataReader Metadata { get; set; }

	public Collection<VariableDefinition> Variables { get; set; }

	public IILVisitor Visitor { get; set; }
}


using System;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal static class MethodBodyRocks
{
	public static void SimplifyMacros(this MethodBody self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		foreach (Instruction instruction in self.Instructions)
		{
			if (instruction.OpCode.OpCodeType == OpCodeType.Macro)
			{
				switch (instruction.OpCode.Code)
				{
				case Code.Ldarg_0:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(0));
					break;
				case Code.Ldarg_1:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(1));
					break;
				case Code.Ldarg_2:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(2));
					break;
				case Code.Ldarg_3:
					ExpandMacro(instruction, OpCodes.Ldarg, self.GetParameter(3));
					break;
				case Code.Ldloc_0:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[0]);
					break;
				case Code.Ldloc_1:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[1]);
					break;
				case Code.Ldloc_2:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[2]);
					break;
				case Code.Ldloc_3:
					ExpandMacro(instruction, OpCodes.Ldloc, self.Variables[3]);
					break;
				case Code.Stloc_0:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[0]);
					break;
				case Code.Stloc_1:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[1]);
					break;
				case Code.Stloc_2:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[2]);
					break;
				case Code.Stloc_3:
					ExpandMacro(instruction, OpCodes.Stloc, self.Variables[3]);
					break;
				case Code.Ldarg_S:
					instruction.OpCode = OpCodes.Ldarg;
					break;
				case Code.Ldarga_S:
					instruction.OpCode = OpCodes.Ldarga;
					break;
				case Code.Starg_S:
					instruction.OpCode = OpCodes.Starg;
					break;
				case Code.Ldloc_S:
					instruction.OpCode = OpCodes.Ldloc;
					break;
				case Code.Ldloca_S:
					instruction.OpCode = OpCodes.Ldloca;
					break;
				case Code.Stloc_S:
					instruction.OpCode = OpCodes.Stloc;
					break;
				case Code.Ldc_I4_M1:
					ExpandMacro(instruction, OpCodes.Ldc_I4, -1);
					break;
				case Code.Ldc_I4_0:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 0);
					break;
				case Code.Ldc_I4_1:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 1);
					break;
				case Code.Ldc_I4_2:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 2);
					break;
				case Code.Ldc_I4_3:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 3);
					break;
				case Code.Ldc_I4_4:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 4);
					break;
				case Code.Ldc_I4_5:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 5);
					break;
				case Code.Ldc_I4_6:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 6);
					break;
				case Code.Ldc_I4_7:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 7);
					break;
				case Code.Ldc_I4_8:
					ExpandMacro(instruction, OpCodes.Ldc_I4, 8);
					break;
				case Code.Ldc_I4_S:
					ExpandMacro(instruction, OpCodes.Ldc_I4, (int)(sbyte)instruction.Operand);
					break;
				case Code.Br_S:
					instruction.OpCode = OpCodes.Br;
					break;
				case Code.Brfalse_S:
					instruction.OpCode = OpCodes.Brfalse;
					break;
				case Code.Brtrue_S:
					instruction.OpCode = OpCodes.Brtrue;
					break;
				case Code.Beq_S:
					instruction.OpCode = OpCodes.Beq;
					break;
				case Code.Bge_S:
					instruction.OpCode = OpCodes.Bge;
					break;
				case Code.Bgt_S:
					instruction.OpCode = OpCodes.Bgt;
					break;
				case Code.Ble_S:
					instruction.OpCode = OpCodes.Ble;
					break;
				case Code.Blt_S:
					instruction.OpCode = OpCodes.Blt;
					break;
				case Code.Bne_Un_S:
					instruction.OpCode = OpCodes.Bne_Un;
					break;
				case Code.Bge_Un_S:
					instruction.OpCode = OpCodes.Bge_Un;
					break;
				case Code.Bgt_Un_S:
					instruction.OpCode = OpCodes.Bgt_Un;
					break;
				case Code.Ble_Un_S:
					instruction.OpCode = OpCodes.Ble_Un;
					break;
				case Code.Blt_Un_S:
					instruction.OpCode = OpCodes.Blt_Un;
					break;
				case Code.Leave_S:
					instruction.OpCode = OpCodes.Leave;
					break;
				}
			}
		}
	}

	private static void ExpandMacro(Instruction instruction, OpCode opcode, object operand)
	{
		instruction.OpCode = opcode;
		instruction.Operand = operand;
	}

	private static void MakeMacro(Instruction instruction, OpCode opcode)
	{
		instruction.OpCode = opcode;
		instruction.Operand = null;
	}

	public static void Optimize(this MethodBody self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		OptimizeLongs(self);
		OptimizeMacros(self);
	}

	private static void OptimizeLongs(this MethodBody self)
	{
		for (int i = 0; i < self.Instructions.Count; i++)
		{
			Instruction instruction = self.Instructions[i];
			if (instruction.OpCode.Code == Code.Ldc_I8)
			{
				long num = (long)instruction.Operand;
				if (num < int.MaxValue && num > int.MinValue)
				{
					ExpandMacro(instruction, OpCodes.Ldc_I4, (int)num);
					self.Instructions.Insert(++i, Instruction.Create(OpCodes.Conv_I8));
				}
			}
		}
	}

	public static void OptimizeMacros(this MethodBody self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		MethodDefinition method = self.Method;
		foreach (Instruction instruction in self.Instructions)
		{
			switch (instruction.OpCode.Code)
			{
			case Code.Ldarg:
			{
				int index = ((ParameterDefinition)instruction.Operand).Index;
				if (index == -1 && instruction.Operand == self.ThisParameter)
				{
					index = 0;
				}
				else if (method.HasThis)
				{
					index++;
				}
				switch (index)
				{
				case 0:
					MakeMacro(instruction, OpCodes.Ldarg_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Ldarg_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Ldarg_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Ldarg_3);
					break;
				default:
					if (index < 256)
					{
						ExpandMacro(instruction, OpCodes.Ldarg_S, instruction.Operand);
					}
					break;
				}
				break;
			}
			case Code.Ldloc:
			{
				int index = ((VariableDefinition)instruction.Operand).Index;
				switch (index)
				{
				case 0:
					MakeMacro(instruction, OpCodes.Ldloc_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Ldloc_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Ldloc_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Ldloc_3);
					break;
				default:
					if (index < 256)
					{
						ExpandMacro(instruction, OpCodes.Ldloc_S, instruction.Operand);
					}
					break;
				}
				break;
			}
			case Code.Stloc:
			{
				int index = ((VariableDefinition)instruction.Operand).Index;
				switch (index)
				{
				case 0:
					MakeMacro(instruction, OpCodes.Stloc_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Stloc_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Stloc_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Stloc_3);
					break;
				default:
					if (index < 256)
					{
						ExpandMacro(instruction, OpCodes.Stloc_S, instruction.Operand);
					}
					break;
				}
				break;
			}
			case Code.Ldarga:
			{
				int index = ((ParameterDefinition)instruction.Operand).Index;
				if (index == -1 && instruction.Operand == self.ThisParameter)
				{
					index = 0;
				}
				else if (method.HasThis)
				{
					index++;
				}
				if (index < 256)
				{
					ExpandMacro(instruction, OpCodes.Ldarga_S, instruction.Operand);
				}
				break;
			}
			case Code.Ldloca:
				if (((VariableDefinition)instruction.Operand).Index < 256)
				{
					ExpandMacro(instruction, OpCodes.Ldloca_S, instruction.Operand);
				}
				break;
			case Code.Ldc_I4:
			{
				int num = (int)instruction.Operand;
				switch (num)
				{
				case -1:
					MakeMacro(instruction, OpCodes.Ldc_I4_M1);
					break;
				case 0:
					MakeMacro(instruction, OpCodes.Ldc_I4_0);
					break;
				case 1:
					MakeMacro(instruction, OpCodes.Ldc_I4_1);
					break;
				case 2:
					MakeMacro(instruction, OpCodes.Ldc_I4_2);
					break;
				case 3:
					MakeMacro(instruction, OpCodes.Ldc_I4_3);
					break;
				case 4:
					MakeMacro(instruction, OpCodes.Ldc_I4_4);
					break;
				case 5:
					MakeMacro(instruction, OpCodes.Ldc_I4_5);
					break;
				case 6:
					MakeMacro(instruction, OpCodes.Ldc_I4_6);
					break;
				case 7:
					MakeMacro(instruction, OpCodes.Ldc_I4_7);
					break;
				case 8:
					MakeMacro(instruction, OpCodes.Ldc_I4_8);
					break;
				default:
					if (num >= -128 && num < 128)
					{
						ExpandMacro(instruction, OpCodes.Ldc_I4_S, (sbyte)num);
					}
					break;
				}
				break;
			}
			}
		}
		OptimizeBranches(self);
	}

	private static void OptimizeBranches(MethodBody body)
	{
		ComputeOffsets(body);
		foreach (Instruction instruction in body.Instructions)
		{
			if (instruction.OpCode.OperandType == OperandType.InlineBrTarget && OptimizeBranch(instruction))
			{
				ComputeOffsets(body);
			}
		}
	}

	private static bool OptimizeBranch(Instruction instruction)
	{
		int num = ((Instruction)instruction.Operand).Offset - (instruction.Offset + instruction.OpCode.Size + 4);
		if (num < -128 || num > 127)
		{
			return false;
		}
		switch (instruction.OpCode.Code)
		{
		case Code.Br:
			instruction.OpCode = OpCodes.Br_S;
			break;
		case Code.Brfalse:
			instruction.OpCode = OpCodes.Brfalse_S;
			break;
		case Code.Brtrue:
			instruction.OpCode = OpCodes.Brtrue_S;
			break;
		case Code.Beq:
			instruction.OpCode = OpCodes.Beq_S;
			break;
		case Code.Bge:
			instruction.OpCode = OpCodes.Bge_S;
			break;
		case Code.Bgt:
			instruction.OpCode = OpCodes.Bgt_S;
			break;
		case Code.Ble:
			instruction.OpCode = OpCodes.Ble_S;
			break;
		case Code.Blt:
			instruction.OpCode = OpCodes.Blt_S;
			break;
		case Code.Bne_Un:
			instruction.OpCode = OpCodes.Bne_Un_S;
			break;
		case Code.Bge_Un:
			instruction.OpCode = OpCodes.Bge_Un_S;
			break;
		case Code.Bgt_Un:
			instruction.OpCode = OpCodes.Bgt_Un_S;
			break;
		case Code.Ble_Un:
			instruction.OpCode = OpCodes.Ble_Un_S;
			break;
		case Code.Blt_Un:
			instruction.OpCode = OpCodes.Blt_Un_S;
			break;
		case Code.Leave:
			instruction.OpCode = OpCodes.Leave_S;
			break;
		}
		return true;
	}

	private static void ComputeOffsets(MethodBody body)
	{
		int num = 0;
		foreach (Instruction instruction in body.Instructions)
		{
			instruction.Offset = num;
			num += instruction.GetSize();
		}
	}
}


using System;
using Mono.Cecil;

internal static class MethodDefinitionRocks
{
	public static MethodDefinition GetBaseMethod(this MethodDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.IsVirtual)
		{
			return self;
		}
		if (self.IsNewSlot)
		{
			return self;
		}
		for (TypeDefinition typeDefinition = ResolveBaseType(self.DeclaringType); typeDefinition != null; typeDefinition = ResolveBaseType(typeDefinition))
		{
			MethodDefinition matchingMethod = GetMatchingMethod(typeDefinition, self);
			if (matchingMethod != null)
			{
				return matchingMethod;
			}
		}
		return self;
	}

	public static MethodDefinition GetOriginalBaseMethod(this MethodDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		while (true)
		{
			MethodDefinition baseMethod = GetBaseMethod(self);
			if (baseMethod == self)
			{
				break;
			}
			self = baseMethod;
		}
		return self;
	}

	private static TypeDefinition ResolveBaseType(TypeDefinition type)
	{
		return type?.BaseType?.Resolve();
	}

	private static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method)
	{
		return MetadataResolver.GetMethod(type.Methods, method);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Mono.Cecil;
using Mono.Cecil.Rocks;

internal static class ModuleDefinitionRocks
{
	public static IEnumerable<TypeDefinition> GetAllTypes(this ModuleDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		return self.Types.SelectMany(Functional.Y((Func<TypeDefinition, IEnumerable<TypeDefinition>> f) => (TypeDefinition type) => Functional.Prepend(type.NestedTypes.SelectMany(f), type)));
	}
}


using Mono.Cecil;

internal static class ParameterReferenceRocks
{
	public static int GetSequence(this ParameterReference self)
	{
		return self.Index + 1;
	}
}


using System;
using System.Security;
using System.Security.Permissions;
using Mono.Cecil;

internal static class SecurityDeclarationRocks
{
	public static PermissionSet ToPermissionSet(this SecurityDeclaration self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (TryProcessPermissionSetAttribute(self, out var set))
		{
			return set;
		}
		return CreatePermissionSet(self);
	}

	private static bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, out PermissionSet set)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		set = null;
		if (!declaration.HasSecurityAttributes && declaration.SecurityAttributes.Count != 1)
		{
			return false;
		}
		Mono.Cecil.SecurityAttribute securityAttribute = declaration.SecurityAttributes[0];
		if (!securityAttribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
		{
			return false;
		}
		PermissionSetAttribute val = new PermissionSetAttribute((System.Security.Permissions.SecurityAction)declaration.Action);
		CustomAttributeNamedArgument customAttributeNamedArgument = securityAttribute.Properties[0];
		string text = (string)customAttributeNamedArgument.Argument.Value;
		string name = customAttributeNamedArgument.Name;
		if (!(name == "XML"))
		{
			if (!(name == "Name"))
			{
				throw new NotImplementedException(customAttributeNamedArgument.Name);
			}
			val.Name = text;
		}
		else
		{
			val.XML = text;
		}
		set = val.CreatePermissionSet();
		return true;
	}

	private static PermissionSet CreatePermissionSet(SecurityDeclaration declaration)
	{
		PermissionSet permissionSet = new PermissionSet(PermissionState.None);
		foreach (Mono.Cecil.SecurityAttribute securityAttribute in declaration.SecurityAttributes)
		{
			IPermission perm = CreatePermission(declaration, securityAttribute);
			permissionSet.AddPermission(perm);
		}
		return permissionSet;
	}

	private static IPermission CreatePermission(SecurityDeclaration declaration, Mono.Cecil.SecurityAttribute attribute)
	{
		Type? type = Type.GetType(attribute.AttributeType.FullName);
		if (type == null)
		{
			throw new ArgumentException("attribute");
		}
		System.Security.Permissions.SecurityAttribute obj = CreateSecurityAttribute(type, declaration) ?? throw new InvalidOperationException();
		CompleteSecurityAttribute(obj, attribute);
		return obj.CreatePermission();
	}

	private static void CompleteSecurityAttribute(System.Security.Permissions.SecurityAttribute security_attribute, Mono.Cecil.SecurityAttribute attribute)
	{
		if (attribute.HasFields)
		{
			CompleteSecurityAttributeFields(security_attribute, attribute);
		}
		if (attribute.HasProperties)
		{
			CompleteSecurityAttributeProperties(security_attribute, attribute);
		}
	}

	private static void CompleteSecurityAttributeFields(System.Security.Permissions.SecurityAttribute security_attribute, Mono.Cecil.SecurityAttribute attribute)
	{
		Type type = security_attribute.GetType();
		foreach (CustomAttributeNamedArgument field in attribute.Fields)
		{
			type.GetField(field.Name).SetValue(security_attribute, field.Argument.Value);
		}
	}

	private static void CompleteSecurityAttributeProperties(System.Security.Permissions.SecurityAttribute security_attribute, Mono.Cecil.SecurityAttribute attribute)
	{
		Type type = security_attribute.GetType();
		foreach (CustomAttributeNamedArgument property in attribute.Properties)
		{
			type.GetProperty(property.Name).SetValue(security_attribute, property.Argument.Value, null);
		}
	}

	private static System.Security.Permissions.SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration)
	{
		try
		{
			return (System.Security.Permissions.SecurityAttribute)Activator.CreateInstance(attribute_type, (System.Security.Permissions.SecurityAction)declaration.Action);
		}
		catch (MissingMethodException)
		{
			return (System.Security.Permissions.SecurityAttribute)Activator.CreateInstance(attribute_type, new object[0]);
		}
	}

	public static SecurityDeclaration ToSecurityDeclaration(this PermissionSet self, Mono.Cecil.SecurityAction action, ModuleDefinition module)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (module == null)
		{
			throw new ArgumentNullException("module");
		}
		SecurityDeclaration securityDeclaration = new SecurityDeclaration(action);
		Mono.Cecil.SecurityAttribute item = new Mono.Cecil.SecurityAttribute(module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"))
		{
			Properties = 
			{
				new CustomAttributeNamedArgument("XML", new CustomAttributeArgument(module.TypeSystem.String, self.ToXml().ToString()))
			}
		};
		securityDeclaration.SecurityAttributes.Add(item);
		return securityDeclaration;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Mono;
using Mono.Cecil;

internal static class TypeDefinitionRocks
{
	public static IEnumerable<MethodDefinition> GetConstructors(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.HasMethods)
		{
			return Empty<MethodDefinition>.Array;
		}
		return self.Methods.Where((MethodDefinition method) => method.IsConstructor);
	}

	public static MethodDefinition GetStaticConstructor(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.HasMethods)
		{
			return null;
		}
		return GetConstructors(self).FirstOrDefault((MethodDefinition ctor) => ctor.IsStatic);
	}

	public static IEnumerable<MethodDefinition> GetMethods(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.HasMethods)
		{
			return Empty<MethodDefinition>.Array;
		}
		return self.Methods.Where((MethodDefinition method) => !method.IsConstructor);
	}

	public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (!self.IsEnum)
		{
			throw new ArgumentException();
		}
		return self.GetEnumUnderlyingType();
	}
}


using System;
using Mono.Cecil;

internal static class TypeReferenceRocks
{
	public static ArrayType MakeArrayType(this TypeReference self)
	{
		return new ArrayType(self);
	}

	public static ArrayType MakeArrayType(this TypeReference self, int rank)
	{
		if (rank == 0)
		{
			throw new ArgumentOutOfRangeException("rank");
		}
		ArrayType arrayType = new ArrayType(self);
		for (int i = 1; i < rank; i++)
		{
			arrayType.Dimensions.Add(default(ArrayDimension));
		}
		return arrayType;
	}

	public static PointerType MakePointerType(this TypeReference self)
	{
		return new PointerType(self);
	}

	public static ByReferenceType MakeByReferenceType(this TypeReference self)
	{
		return new ByReferenceType(self);
	}

	public static OptionalModifierType MakeOptionalModifierType(this TypeReference self, TypeReference modifierType)
	{
		return new OptionalModifierType(modifierType, self);
	}

	public static RequiredModifierType MakeRequiredModifierType(this TypeReference self, TypeReference modifierType)
	{
		return new RequiredModifierType(modifierType, self);
	}

	public static GenericInstanceType MakeGenericInstanceType(this TypeReference self, params TypeReference[] arguments)
	{
		if (self == null)
		{
			throw new ArgumentNullException("self");
		}
		if (arguments == null)
		{
			throw new ArgumentNullException("arguments");
		}
		if (arguments.Length == 0)
		{
			throw new ArgumentException();
		}
		if (self.GenericParameters.Count != arguments.Length)
		{
			throw new ArgumentException();
		}
		GenericInstanceType genericInstanceType = new GenericInstanceType(self, arguments.Length);
		foreach (TypeReference item in arguments)
		{
			genericInstanceType.GenericArguments.Add(item);
		}
		return genericInstanceType;
	}

	public static PinnedType MakePinnedType(this TypeReference self)
	{
		return new PinnedType(self);
	}

	public static SentinelType MakeSentinelType(this TypeReference self)
	{
		return new SentinelType(self);
	}
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
internal sealed class IsByRefLikeAttribute : Attribute
{
}


using System;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;

[CompilerGenerated]
[Embedded]
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
internal sealed class NativeIntegerAttribute : Attribute
{
	public readonly bool[] TransformFlags;

	public NativeIntegerAttribute()
	{
		TransformFlags = new bool[1] { true };
	}

	public NativeIntegerAttribute(bool[] P_0)
	{
		TransformFlags = P_0;
	}
}


using System.Runtime.CompilerServices;

internal static class MethodImplOptionsEx
{
	public const MethodImplOptions Unmanaged = MethodImplOptions.Unmanaged;

	public const MethodImplOptions NoInlining = MethodImplOptions.NoInlining;

	public const MethodImplOptions ForwardRef = MethodImplOptions.ForwardRef;

	public const MethodImplOptions Synchronized = MethodImplOptions.Synchronized;

	public const MethodImplOptions NoOptimization = MethodImplOptions.NoOptimization;

	public const MethodImplOptions PreserveSig = MethodImplOptions.PreserveSig;

	public const MethodImplOptions AggressiveInlining = MethodImplOptions.AggressiveInlining;

	public const MethodImplOptions AggressiveOptimization = MethodImplOptions.AggressiveOptimization;

	public const MethodImplOptions InternalCall = MethodImplOptions.InternalCall;
}


using System;
using System.Runtime.CompilerServices;

internal static class ArrayEx
{
	private static class TypeHolder<T>
	{
		public static readonly T[] Empty = new T[0];
	}

	public static int MaxLength => 1879048191;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static T[] Empty<T>()
	{
		return TypeHolder<T>.Empty;
	}
}


private static class TypeHolder<T>
{
	public static readonly T[] Empty = new T[0];
}


using System;
using System.ComponentModel;

internal readonly struct SequencePosition : IEquatable<SequencePosition>
{
	private readonly object? _object;

	private readonly int _integer;

	public SequencePosition(object? @object, int integer)
	{
		_object = @object;
		_integer = integer;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public object? GetObject()
	{
		return _object;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public int GetInteger()
	{
		return _integer;
	}

	public bool Equals(SequencePosition other)
	{
		if (_integer == other._integer)
		{
			return object.Equals(_object, other._object);
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object? obj)
	{
		if (obj is SequencePosition other)
		{
			return Equals(other);
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		return HashCode.Combine(_object, _integer);
	}
}


using System;

internal static class EnvironmentEx
{
	public static int CurrentManagedThreadId => Environment.CurrentManagedThreadId;
}


using System;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;

internal sealed class Gen2GcCallback : CriticalFinalizerObject
{
	private readonly Func<bool>? _callback0;

	private readonly Func<object, bool>? _callback1;

	private GCHandle _weakTargetObj;

	private Gen2GcCallback(Func<bool> callback)
	{
		_callback0 = callback;
	}

	private Gen2GcCallback(Func<object, bool> callback, object targetObj)
	{
		_callback1 = callback;
		_weakTargetObj = GCHandle.Alloc(targetObj, GCHandleType.Weak);
	}

	public static void Register(Func<bool> callback)
	{
		new System.Gen2GcCallback(callback);
	}

	public static void Register(Func<object, bool> callback, object targetObj)
	{
		new System.Gen2GcCallback(callback, targetObj);
	}

	~Gen2GcCallback()
	{
		if (_weakTargetObj.IsAllocated)
		{
			object target = _weakTargetObj.Target;
			if (target == null)
			{
				_weakTargetObj.Free();
				return;
			}
			try
			{
				if (!_callback1(target))
				{
					_weakTargetObj.Free();
					return;
				}
			}
			catch
			{
			}
		}
		else
		{
			try
			{
				if (!_callback0())
				{
					return;
				}
			}
			catch
			{
			}
		}
		GC.ReRegisterForFinalize(this);
	}
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

internal struct HashCode
{
	private static readonly uint s_seed = GenerateGlobalSeed();

	private const uint Prime1 = 2654435761u;

	private const uint Prime2 = 2246822519u;

	private const uint Prime3 = 3266489917u;

	private const uint Prime4 = 668265263u;

	private const uint Prime5 = 374761393u;

	private uint _v1;

	private uint _v2;

	private uint _v3;

	private uint _v4;

	private uint _queue1;

	private uint _queue2;

	private uint _queue3;

	private uint _length;

	private static uint GenerateGlobalSeed()
	{
		Span<byte> destination = stackalloc byte[4];
		using (RandomNumberGenerator randomNumberGenerator = RandomNumberGenerator.Create())
		{
			byte[] array = new byte[destination.Length];
			randomNumberGenerator.GetBytes(array);
			MemoryExtensions.AsSpan(array).CopyTo(destination);
		}
		return Unsafe.ReadUnaligned<uint>(ref destination[0]);
	}

	public static int Combine<T1>(T1 value1)
	{
		uint queuedValue = (uint)(value1?.GetHashCode() ?? 0);
		return (int)MixFinal(QueueRound(MixEmptyState() + 4, queuedValue));
	}

	public static int Combine<T1, T2>(T1 value1, T2 value2)
	{
		uint queuedValue = (uint)(value1?.GetHashCode() ?? 0);
		uint queuedValue2 = (uint)(value2?.GetHashCode() ?? 0);
		return (int)MixFinal(QueueRound(QueueRound(MixEmptyState() + 8, queuedValue), queuedValue2));
	}

	public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3)
	{
		uint queuedValue = (uint)(value1?.GetHashCode() ?? 0);
		uint queuedValue2 = (uint)(value2?.GetHashCode() ?? 0);
		uint queuedValue3 = (uint)(value3?.GetHashCode() ?? 0);
		return (int)MixFinal(QueueRound(QueueRound(QueueRound(MixEmptyState() + 12, queuedValue), queuedValue2), queuedValue3));
	}

	public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4)
	{
		uint input = (uint)(value1?.GetHashCode() ?? 0);
		uint input2 = (uint)(value2?.GetHashCode() ?? 0);
		uint input3 = (uint)(value3?.GetHashCode() ?? 0);
		uint input4 = (uint)(value4?.GetHashCode() ?? 0);
		Initialize(out var v, out var v2, out var v3, out var v4);
		v = Round(v, input);
		v2 = Round(v2, input2);
		v3 = Round(v3, input3);
		v4 = Round(v4, input4);
		return (int)MixFinal(MixState(v, v2, v3, v4) + 16);
	}

	public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
	{
		uint input = (uint)(value1?.GetHashCode() ?? 0);
		uint input2 = (uint)(value2?.GetHashCode() ?? 0);
		uint input3 = (uint)(value3?.GetHashCode() ?? 0);
		uint input4 = (uint)(value4?.GetHashCode() ?? 0);
		uint queuedValue = (uint)(value5?.GetHashCode() ?? 0);
		Initialize(out var v, out var v2, out var v3, out var v4);
		v = Round(v, input);
		v2 = Round(v2, input2);
		v3 = Round(v3, input3);
		v4 = Round(v4, input4);
		return (int)MixFinal(QueueRound(MixState(v, v2, v3, v4) + 20, queuedValue));
	}

	public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)
	{
		uint input = (uint)(value1?.GetHashCode() ?? 0);
		uint input2 = (uint)(value2?.GetHashCode() ?? 0);
		uint input3 = (uint)(value3?.GetHashCode() ?? 0);
		uint input4 = (uint)(value4?.GetHashCode() ?? 0);
		uint queuedValue = (uint)(value5?.GetHashCode() ?? 0);
		uint queuedValue2 = (uint)(value6?.GetHashCode() ?? 0);
		Initialize(out var v, out var v2, out var v3, out var v4);
		v = Round(v, input);
		v2 = Round(v2, input2);
		v3 = Round(v3, input3);
		v4 = Round(v4, input4);
		return (int)MixFinal(QueueRound(QueueRound(MixState(v, v2, v3, v4) + 24, queuedValue), queuedValue2));
	}

	public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)
	{
		uint input = (uint)(value1?.GetHashCode() ?? 0);
		uint input2 = (uint)(value2?.GetHashCode() ?? 0);
		uint input3 = (uint)(value3?.GetHashCode() ?? 0);
		uint input4 = (uint)(value4?.GetHashCode() ?? 0);
		uint queuedValue = (uint)(value5?.GetHashCode() ?? 0);
		uint queuedValue2 = (uint)(value6?.GetHashCode() ?? 0);
		uint queuedValue3 = (uint)(value7?.GetHashCode() ?? 0);
		Initialize(out var v, out var v2, out var v3, out var v4);
		v = Round(v, input);
		v2 = Round(v2, input2);
		v3 = Round(v3, input3);
		v4 = Round(v4, input4);
		return (int)MixFinal(QueueRound(QueueRound(QueueRound(MixState(v, v2, v3, v4) + 28, queuedValue), queuedValue2), queuedValue3));
	}

	public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)
	{
		uint input = (uint)(value1?.GetHashCode() ?? 0);
		uint input2 = (uint)(value2?.GetHashCode() ?? 0);
		uint input3 = (uint)(value3?.GetHashCode() ?? 0);
		uint input4 = (uint)(value4?.GetHashCode() ?? 0);
		uint input5 = (uint)(value5?.GetHashCode() ?? 0);
		uint input6 = (uint)(value6?.GetHashCode() ?? 0);
		uint input7 = (uint)(value7?.GetHashCode() ?? 0);
		uint input8 = (uint)(value8?.GetHashCode() ?? 0);
		Initialize(out var v, out var v2, out var v3, out var v4);
		v = Round(v, input);
		v2 = Round(v2, input2);
		v3 = Round(v3, input3);
		v4 = Round(v4, input4);
		v = Round(v, input5);
		v2 = Round(v2, input6);
		v3 = Round(v3, input7);
		v4 = Round(v4, input8);
		return (int)MixFinal(MixState(v, v2, v3, v4) + 32);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void Initialize(out uint v1, out uint v2, out uint v3, out uint v4)
	{
		v1 = (uint)((int)s_seed + -1640531535 + -2048144777);
		v2 = s_seed + 2246822519u;
		v3 = s_seed;
		v4 = s_seed - 2654435761u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint Round(uint hash, uint input)
	{
		return BitOperations.RotateLeft(hash + (uint)((int)input * -2048144777), 13) * 2654435761u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint QueueRound(uint hash, uint queuedValue)
	{
		return BitOperations.RotateLeft(hash + (uint)((int)queuedValue * -1028477379), 17) * 668265263;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint MixState(uint v1, uint v2, uint v3, uint v4)
	{
		return BitOperations.RotateLeft(v1, 1) + BitOperations.RotateLeft(v2, 7) + BitOperations.RotateLeft(v3, 12) + BitOperations.RotateLeft(v4, 18);
	}

	private static uint MixEmptyState()
	{
		return s_seed + 374761393;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static uint MixFinal(uint hash)
	{
		hash ^= hash >> 15;
		hash *= 2246822519u;
		hash ^= hash >> 13;
		hash *= 3266489917u;
		hash ^= hash >> 16;
		return hash;
	}

	public void Add<T>(T value)
	{
		Add(value?.GetHashCode() ?? 0);
	}

	public void Add<T>(T value, IEqualityComparer<T>? comparer)
	{
		Add((value != null) ? (comparer?.GetHashCode(value) ?? value.GetHashCode()) : 0);
	}

	public void AddBytes(ReadOnlySpan<byte> value)
	{
		ref byte reference = ref MemoryMarshal.GetReference(value);
		ref byte reference2 = ref Unsafe.Add(ref reference, value.Length);
		while ((nint)Unsafe.ByteOffset(ref reference, ref reference2) >= 4)
		{
			Add(Unsafe.ReadUnaligned<int>(ref reference));
			reference = ref Unsafe.Add(ref reference, 4);
		}
		while (Unsafe.IsAddressLessThan(ref reference, ref reference2))
		{
			Add((int)reference);
			reference = ref Unsafe.Add(ref reference, 1);
		}
	}

	private void Add(int value)
	{
		uint num = _length++;
		switch (num % 4)
		{
		case 0u:
			_queue1 = (uint)value;
			return;
		case 1u:
			_queue2 = (uint)value;
			return;
		case 2u:
			_queue3 = (uint)value;
			return;
		}
		if (num == 3)
		{
			Initialize(out _v1, out _v2, out _v3, out _v4);
		}
		_v1 = Round(_v1, _queue1);
		_v2 = Round(_v2, _queue2);
		_v3 = Round(_v3, _queue3);
		_v4 = Round(_v4, (uint)value);
	}

	public int ToHashCode()
	{
		uint length = _length;
		uint num = length % 4;
		uint num2 = ((length < 4) ? MixEmptyState() : MixState(_v1, _v2, _v3, _v4));
		num2 += length * 4;
		if (num != 0)
		{
			num2 = QueueRound(num2, _queue1);
			if (num > 1)
			{
				num2 = QueueRound(num2, _queue2);
				if (num > 2)
				{
					num2 = QueueRound(num2, _queue3);
				}
			}
		}
		return (int)MixFinal(num2);
	}

	[Obsolete("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		throw new NotSupportedException("GetHashCode on HashCode is not supported");
	}

	[Obsolete("HashCode is a mutable struct and should not be compared with other HashCodes.", true)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object? obj)
	{
		throw new NotSupportedException("Equals on HashCode is not supported");
	}
}


using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

internal static class MathEx
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static byte Clamp(byte value, byte min, byte max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static decimal Clamp(decimal value, decimal min, decimal max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static double Clamp(double value, double min, double max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static short Clamp(short value, short min, short max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int Clamp(int value, int min, int max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static long Clamp(long value, long min, long max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static nint Clamp(nint value, nint min, nint max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static sbyte Clamp(sbyte value, sbyte min, sbyte max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float Clamp(float value, float min, float max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ushort Clamp(ushort value, ushort min, ushort max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint Clamp(uint value, uint min, uint max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong Clamp(ulong value, ulong min, ulong max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static nuint Clamp(nuint value, nuint min, nuint max)
	{
		if (min > max)
		{
			ThrowMinMaxException(min, max);
		}
		if (value < min)
		{
			return min;
		}
		if (value > max)
		{
			return max;
		}
		return value;
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	private static void ThrowMinMaxException<T>(T min, T max)
	{
		throw new ArgumentException($"Minimum {min} is less than maximum {max}");
	}
}


using System;
using System.Buffers;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[DebuggerTypeProxy(typeof(System.MemoryDebugView<>))]
[DebuggerDisplay("{ToString(),raw}")]
internal readonly struct Memory<T>
{
	private readonly object? _object;

	private readonly int _index;

	private readonly int _length;

	private const int RemoveFlagsBitMask = int.MaxValue;

	public static Memory<T> Empty => default(Memory<T>);

	public int Length => _length & 0x7FFFFFFF;

	public bool IsEmpty => (_length & 0x7FFFFFFF) == 0;

	public Span<T> Span
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			Span<T> result;
			if (_index < 0)
			{
				result = ((MemoryManager<T>)_object).GetSpan();
				return result.Slice(_index & 0x7FFFFFFF, _length);
			}
			if (typeof(T) == typeof(char) && _object is string text)
			{
				result = new Span<T>(Unsafe.As<Pinnable<T>>(text), MemoryExtensions.StringAdjustment, text.Length);
				return result.Slice(_index, _length);
			}
			if (_object != null)
			{
				return new Span<T>((T[])_object, _index, _length & 0x7FFFFFFF);
			}
			result = default(Span<T>);
			return result;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory(T[]? array)
	{
		if (array == null)
		{
			this = default(Memory<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		_object = array;
		_index = 0;
		_length = array.Length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(T[]? array, int start)
	{
		if (array == null)
		{
			if (start != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			this = default(Memory<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = array;
		_index = start;
		_length = array.Length - start;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory(T[]? array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			this = default(Memory<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = array;
		_index = start;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(MemoryManager<T> manager, int length)
	{
		if (length < 0)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = manager;
		_index = int.MinValue;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(MemoryManager<T> manager, int start, int length)
	{
		if (length < 0 || start < 0)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = manager;
		_index = start | int.MinValue;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Memory(object? obj, int start, int length)
	{
		_object = obj;
		_index = start;
		_length = length;
	}

	public static implicit operator Memory<T>(T[]? array)
	{
		return new Memory<T>(array);
	}

	public static implicit operator Memory<T>(ArraySegment<T> segment)
	{
		return new Memory<T>(segment.Array, segment.Offset, segment.Count);
	}

	public static implicit operator ReadOnlyMemory<T>(Memory<T> memory)
	{
		return Unsafe.As<Memory<T>, ReadOnlyMemory<T>>(ref memory);
	}

	public override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			if (!(_object is string text))
			{
				return Span.ToString();
			}
			return text.Substring(_index, _length & 0x7FFFFFFF);
		}
		return $"System.Memory<{typeof(T).Name}>[{_length & 0x7FFFFFFF}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory<T> Slice(int start)
	{
		int length = _length;
		int num = length & 0x7FFFFFFF;
		if ((uint)start > (uint)num)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new Memory<T>(_object, _index + start, length - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Memory<T> Slice(int start, int length)
	{
		int length2 = _length;
		int num = length2 & 0x7FFFFFFF;
		if ((uint)start > (uint)num || (uint)length > (uint)(num - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		return new Memory<T>(_object, _index + start, length | (length2 & int.MinValue));
	}

	public void CopyTo(Memory<T> destination)
	{
		Span.CopyTo(destination.Span);
	}

	public bool TryCopyTo(Memory<T> destination)
	{
		return Span.TryCopyTo(destination.Span);
	}

	public unsafe MemoryHandle Pin()
	{
		if (_index < 0)
		{
			return ((MemoryManager<T>)_object).Pin(_index & 0x7FFFFFFF);
		}
		if (typeof(T) == typeof(char) && _object is string value)
		{
			GCHandle handle = GCHandle.Alloc(value, GCHandleType.Pinned);
			return new MemoryHandle(Unsafe.Add<T>((void*)handle.AddrOfPinnedObject(), _index), handle);
		}
		if (_object is T[] array)
		{
			if (_length < 0)
			{
				return new MemoryHandle(Unsafe.Add<T>(Unsafe.AsPointer(ref MemoryMarshal.GetReference<T>(array)), _index));
			}
			GCHandle handle2 = GCHandle.Alloc(array, GCHandleType.Pinned);
			return new MemoryHandle(Unsafe.Add<T>((void*)handle2.AddrOfPinnedObject(), _index), handle2);
		}
		return default(MemoryHandle);
	}

	public T[] ToArray()
	{
		return Span.ToArray();
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object? obj)
	{
		if (obj is ReadOnlyMemory<T> readOnlyMemory)
		{
			return readOnlyMemory.Equals(this);
		}
		if (obj is Memory<T> other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(Memory<T> other)
	{
		if (_object == other._object && _index == other._index)
		{
			return _length == other._length;
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		if (_object == null)
		{
			return 0;
		}
		return HashCode.Combine(_object, _index, _length);
	}
}


using System;
using System.Diagnostics;

internal sealed class MemoryDebugView<T>
{
	private readonly ReadOnlyMemory<T> _memory;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public T[] Items => _memory.ToArray();

	public MemoryDebugView(Memory<T> memory)
	{
		_memory = memory;
	}

	public MemoryDebugView(ReadOnlyMemory<T> memory)
	{
		_memory = memory;
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class MemoryExtensions
{
	internal static readonly nint StringAdjustment = MeasureStringAdjustment();

	public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span)
	{
		return span.TrimStart().TrimEnd();
	}

	public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span)
	{
		int i;
		for (i = 0; i < span.Length && char.IsWhiteSpace(span[i]); i++)
		{
		}
		return span.Slice(i);
	}

	public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span)
	{
		int num = span.Length - 1;
		while (num >= 0 && char.IsWhiteSpace(span[num]))
		{
			num--;
		}
		return span.Slice(0, num + 1);
	}

	public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, char trimChar)
	{
		return span.TrimStart(trimChar).TrimEnd(trimChar);
	}

	public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, char trimChar)
	{
		int i;
		for (i = 0; i < span.Length && span[i] == trimChar; i++)
		{
		}
		return span.Slice(i);
	}

	public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, char trimChar)
	{
		int num = span.Length - 1;
		while (num >= 0 && span[num] == trimChar)
		{
			num--;
		}
		return span.Slice(0, num + 1);
	}

	public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars)
	{
		return span.TrimStart(trimChars).TrimEnd(trimChars);
	}

	public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars)
	{
		if (trimChars.IsEmpty)
		{
			return span.TrimStart();
		}
		int i;
		for (i = 0; i < span.Length; i++)
		{
			int num = 0;
			while (num < trimChars.Length)
			{
				if (span[i] != trimChars[num])
				{
					num++;
					continue;
				}
				goto IL_003c;
			}
			break;
			IL_003c:;
		}
		return span.Slice(i);
	}

	public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars)
	{
		if (trimChars.IsEmpty)
		{
			return span.TrimEnd();
		}
		int num;
		for (num = span.Length - 1; num >= 0; num--)
		{
			int num2 = 0;
			while (num2 < trimChars.Length)
			{
				if (span[num] != trimChars[num2])
				{
					num2++;
					continue;
				}
				goto IL_0044;
			}
			break;
			IL_0044:;
		}
		return span.Slice(0, num + 1);
	}

	public static bool IsWhiteSpace(this ReadOnlySpan<char> span)
	{
		for (int i = 0; i < span.Length; i++)
		{
			if (!char.IsWhiteSpace(span[i]))
			{
				return false;
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool SequenceEqual<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>
	{
		int length = span.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length == other.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), (nuint)length * size);
			}
			return false;
		}
		if (length == other.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other), length);
		}
		return false;
	}

	public static int SequenceCompareTo<T>(this Span<T> span, ReadOnlySpan<T> other) where T : IComparable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		return System.SpanHelpers.SequenceCompareTo(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(other), other.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.IndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value), span.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, char>(ref value), span.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), value, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOf(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), value.Length);
		}
		return System.SpanHelpers.LastIndexOf(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(value), value.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.IndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.IndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), Unsafe.As<T, byte>(ref value0), Unsafe.As<T, byte>(ref value1), Unsafe.As<T, byte>(ref value2), span.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), value0, value1, value2, span.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.LastIndexOfAny(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(values)), values.Length);
		}
		return System.SpanHelpers.LastIndexOfAny(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(values), values.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool SequenceEqual<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IEquatable<T>
	{
		int length = span.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length == other.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), (nuint)length * size);
			}
			return false;
		}
		if (length == other.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other), length);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int SequenceCompareTo<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other) where T : IComparable<T>
	{
		if (typeof(T) == typeof(byte))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		if (typeof(T) == typeof(char))
		{
			return System.SpanHelpers.SequenceCompareTo(ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(span)), span.Length, ref Unsafe.As<T, char>(ref MemoryMarshal.GetReference(other)), other.Length);
		}
		return System.SpanHelpers.SequenceCompareTo(ref MemoryMarshal.GetReference(span), span.Length, ref MemoryMarshal.GetReference(other), other.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length <= span.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (nuint)length * size);
			}
			return false;
		}
		if (length <= span.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), length);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length <= span.Length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(span)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (nuint)length * size);
			}
			return false;
		}
		if (length <= span.Length)
		{
			return System.SpanHelpers.SequenceEqual(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(value), length);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = span.Length;
		int length2 = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length2 <= length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (nuint)length2 * size);
			}
			return false;
		}
		if (length2 <= length)
		{
			return System.SpanHelpers.SequenceEqual(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2), ref MemoryMarshal.GetReference(value), length2);
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>
	{
		int length = span.Length;
		int length2 = value.Length;
		if (default(T) != null && IsTypeComparableAsBytes<T>(out var size))
		{
			if (length2 <= length)
			{
				return System.SpanHelpers.SequenceEqual(ref Unsafe.As<T, byte>(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2)), ref Unsafe.As<T, byte>(ref MemoryMarshal.GetReference(value)), (nuint)length2 * size);
			}
			return false;
		}
		if (length2 <= length)
		{
			return System.SpanHelpers.SequenceEqual(ref Unsafe.Add(ref MemoryMarshal.GetReference(span), length - length2), ref MemoryMarshal.GetReference(value), length2);
		}
		return false;
	}

	public static void Reverse<T>(this Span<T> span)
	{
		if (span.Length > 1)
		{
			ref T reference = ref MemoryMarshal.GetReference(span);
			ref T reference2 = ref Unsafe.Add(ref Unsafe.Add(ref reference, span.Length), -1);
			do
			{
				T val = reference;
				reference = reference2;
				reference2 = val;
				reference = ref Unsafe.Add(ref reference, 1);
				reference2 = ref Unsafe.Add(ref reference2, -1);
			}
			while (Unsafe.IsAddressLessThan(ref reference, ref reference2));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this T[]? array)
	{
		return new Span<T>(array);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this T[]? array, int start, int length)
	{
		return new Span<T>(array, start, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this ArraySegment<T> segment)
	{
		return new Span<T>(segment.Array, segment.Offset, segment.Count);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start)
	{
		if ((uint)start > segment.Count)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new Span<T>(segment.Array, segment.Offset + start, segment.Count - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start, int length)
	{
		if ((uint)start > segment.Count)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		if ((uint)length > segment.Count - start)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.length);
		}
		return new Span<T>(segment.Array, segment.Offset + start, length);
	}

	public static Memory<T> AsMemory<T>(this T[]? array)
	{
		return new Memory<T>(array);
	}

	public static Memory<T> AsMemory<T>(this T[]? array, int start)
	{
		return new Memory<T>(array, start);
	}

	public static Memory<T> AsMemory<T>(this T[]? array, int start, int length)
	{
		return new Memory<T>(array, start, length);
	}

	public static Memory<T> AsMemory<T>(this ArraySegment<T> segment)
	{
		return new Memory<T>(segment.Array, segment.Offset, segment.Count);
	}

	public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start)
	{
		if ((uint)start > segment.Count)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new Memory<T>(segment.Array, segment.Offset + start, segment.Count - start);
	}

	public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start, int length)
	{
		if ((uint)start > segment.Count)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		if ((uint)length > segment.Count - start)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.length);
		}
		return new Memory<T>(segment.Array, segment.Offset + start, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void CopyTo<T>(this T[]? source, Span<T> destination)
	{
		new ReadOnlySpan<T>(source).CopyTo(destination);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void CopyTo<T>(this T[]? source, Memory<T> destination)
	{
		source.CopyTo(destination.Span);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Overlaps<T>(this Span<T> span, ReadOnlySpan<T> other)
	{
		return ((ReadOnlySpan<T>)span).Overlaps(other);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Overlaps<T>(this Span<T> span, ReadOnlySpan<T> other, out int elementOffset)
	{
		return ((ReadOnlySpan<T>)span).Overlaps(other, out elementOffset);
	}

	public static bool Overlaps<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other)
	{
		if (span.IsEmpty || other.IsEmpty)
		{
			return false;
		}
		IntPtr intPtr = Unsafe.ByteOffset(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other));
		if (Unsafe.SizeOf<IntPtr>() == 4)
		{
			if ((uint)(int)intPtr >= (uint)(span.Length * Unsafe.SizeOf<T>()))
			{
				return (uint)(int)intPtr > (uint)(-(other.Length * Unsafe.SizeOf<T>()));
			}
			return true;
		}
		if ((ulong)(long)intPtr >= (ulong)((long)span.Length * (long)Unsafe.SizeOf<T>()))
		{
			return (ulong)(long)intPtr > (ulong)(-((long)other.Length * (long)Unsafe.SizeOf<T>()));
		}
		return true;
	}

	public static bool Overlaps<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> other, out int elementOffset)
	{
		if (span.IsEmpty || other.IsEmpty)
		{
			elementOffset = 0;
			return false;
		}
		IntPtr intPtr = Unsafe.ByteOffset(ref MemoryMarshal.GetReference(span), ref MemoryMarshal.GetReference(other));
		if (Unsafe.SizeOf<IntPtr>() == 4)
		{
			if ((uint)(int)intPtr < (uint)(span.Length * Unsafe.SizeOf<T>()) || (uint)(int)intPtr > (uint)(-(other.Length * Unsafe.SizeOf<T>())))
			{
				if ((int)intPtr % Unsafe.SizeOf<T>() != 0)
				{
					System.ThrowHelper.ThrowArgumentException_OverlapAlignmentMismatch();
				}
				elementOffset = (int)intPtr / Unsafe.SizeOf<T>();
				return true;
			}
			elementOffset = 0;
			return false;
		}
		if ((ulong)(long)intPtr < (ulong)((long)span.Length * (long)Unsafe.SizeOf<T>()) || (ulong)(long)intPtr > (ulong)(-((long)other.Length * (long)Unsafe.SizeOf<T>())))
		{
			if ((long)intPtr % Unsafe.SizeOf<T>() != 0L)
			{
				System.ThrowHelper.ThrowArgumentException_OverlapAlignmentMismatch();
			}
			elementOffset = (int)((long)intPtr / Unsafe.SizeOf<T>());
			return true;
		}
		elementOffset = 0;
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T>(this Span<T> span, IComparable<T> comparable)
	{
		return span.BinarySearch<T, IComparable<T>>(comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparable>(this Span<T> span, TComparable comparable) where TComparable : IComparable<T>
	{
		return BinarySearch((ReadOnlySpan<T>)span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparer>(this Span<T> span, T value, TComparer comparer) where TComparer : IComparer<T>
	{
		return ((ReadOnlySpan<T>)span).BinarySearch(value, comparer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T>(this ReadOnlySpan<T> span, IComparable<T> comparable)
	{
		return MemoryExtensions.BinarySearch<T, IComparable<T>>(span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparable>(this ReadOnlySpan<T> span, TComparable comparable) where TComparable : IComparable<T>
	{
		return System.SpanHelpers.BinarySearch(span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparer>(this ReadOnlySpan<T> span, T value, TComparer comparer) where TComparer : IComparer<T>
	{
		if (comparer == null)
		{
			System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.comparer);
		}
		System.SpanHelpers.ComparerComparable<T, TComparer> comparable = new System.SpanHelpers.ComparerComparable<T, TComparer>(value, comparer);
		return BinarySearch(span, comparable);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool IsTypeComparableAsBytes<T>(out nuint size)
	{
		if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
		{
			size = 1u;
			return true;
		}
		if (typeof(T) == typeof(char) || typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
		{
			size = 2u;
			return true;
		}
		if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
		{
			size = 4u;
			return true;
		}
		if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
		{
			size = 8u;
			return true;
		}
		size = 0u;
		return false;
	}

	public static Span<T> AsSpan<T>(this T[]? array, int start)
	{
		return Span<T>.Create(array, start);
	}

	public static bool Contains(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		return span.IndexOf(value, comparisonType) >= 0;
	}

	public static bool Equals(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType)
	{
		switch (comparisonType)
		{
		case StringComparison.Ordinal:
			return span.SequenceEqual(other);
		case StringComparison.OrdinalIgnoreCase:
			if (span.Length != other.Length)
			{
				return false;
			}
			return EqualsOrdinalIgnoreCase(span, other);
		default:
			return span.ToString().Equals(other.ToString(), comparisonType);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool EqualsOrdinalIgnoreCase(ReadOnlySpan<char> span, ReadOnlySpan<char> other)
	{
		if (other.Length == 0)
		{
			return true;
		}
		return CompareToOrdinalIgnoreCase(span, other) == 0;
	}

	public static int CompareTo(this ReadOnlySpan<char> span, ReadOnlySpan<char> other, StringComparison comparisonType)
	{
		return comparisonType switch
		{
			StringComparison.Ordinal => span.SequenceCompareTo(other), 
			StringComparison.OrdinalIgnoreCase => CompareToOrdinalIgnoreCase(span, other), 
			_ => string.Compare(span.ToString(), other.ToString(), comparisonType), 
		};
	}

	private unsafe static int CompareToOrdinalIgnoreCase(ReadOnlySpan<char> strA, ReadOnlySpan<char> strB)
	{
		int num = Math.Min(strA.Length, strB.Length);
		int num2 = num;
		fixed (char* reference = &MemoryMarshal.GetReference(strA))
		{
			fixed (char* reference2 = &MemoryMarshal.GetReference(strB))
			{
				char* ptr = reference;
				char* ptr2 = reference2;
				while (num != 0 && *ptr <= '\u007f' && *ptr2 <= '\u007f')
				{
					int num3 = *ptr;
					int num4 = *ptr2;
					if (num3 == num4)
					{
						ptr++;
						ptr2++;
						num--;
						continue;
					}
					if ((uint)(num3 - 97) <= 25u)
					{
						num3 -= 32;
					}
					if ((uint)(num4 - 97) <= 25u)
					{
						num4 -= 32;
					}
					if (num3 != num4)
					{
						return num3 - num4;
					}
					ptr++;
					ptr2++;
					num--;
				}
				if (num == 0)
				{
					return strA.Length - strB.Length;
				}
				num2 -= num;
				return string.Compare(strA.Slice(num2).ToString(), strB.Slice(num2).ToString(), StringComparison.OrdinalIgnoreCase);
			}
		}
	}

	public static int IndexOf(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		if (comparisonType == StringComparison.Ordinal)
		{
			return span.IndexOf(value);
		}
		return span.ToString().IndexOf(value.ToString(), comparisonType);
	}

	public static int ToLower(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture)
	{
		System.ThrowHelper.ThrowIfArgumentNull(culture, System.ExceptionArgument.culture);
		if (destination.Length < source.Length)
		{
			return -1;
		}
		string str = source.ToString();
		AsSpan(culture.TextInfo.ToLower(str)).CopyTo(destination);
		return source.Length;
	}

	public static int ToLowerInvariant(this ReadOnlySpan<char> source, Span<char> destination)
	{
		return source.ToLower(destination, CultureInfo.InvariantCulture);
	}

	public static int ToUpper(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture)
	{
		System.ThrowHelper.ThrowIfArgumentNull(culture, System.ExceptionArgument.culture);
		if (destination.Length < source.Length)
		{
			return -1;
		}
		string str = source.ToString();
		AsSpan(culture.TextInfo.ToUpper(str)).CopyTo(destination);
		return source.Length;
	}

	public static int ToUpperInvariant(this ReadOnlySpan<char> source, Span<char> destination)
	{
		return source.ToUpper(destination, CultureInfo.InvariantCulture);
	}

	public static bool EndsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		switch (comparisonType)
		{
		case StringComparison.Ordinal:
			return span.EndsWith(value);
		case StringComparison.OrdinalIgnoreCase:
			if (value.Length <= span.Length)
			{
				return EqualsOrdinalIgnoreCase(span.Slice(span.Length - value.Length), value);
			}
			return false;
		default:
		{
			string text = span.ToString();
			string value2 = value.ToString();
			return text.EndsWith(value2, comparisonType);
		}
		}
	}

	public static bool StartsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType)
	{
		switch (comparisonType)
		{
		case StringComparison.Ordinal:
			return span.StartsWith(value);
		case StringComparison.OrdinalIgnoreCase:
			if (value.Length <= span.Length)
			{
				return EqualsOrdinalIgnoreCase(span.Slice(0, value.Length), value);
			}
			return false;
		default:
		{
			string text = span.ToString();
			string value2 = value.ToString();
			return text.StartsWith(value2, comparisonType);
		}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> AsSpan(this string? text)
	{
		if (text == null)
		{
			return default(ReadOnlySpan<char>);
		}
		return new ReadOnlySpan<char>(Unsafe.As<Pinnable<char>>(text), StringAdjustment, text.Length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> AsSpan(this string? text, int start)
	{
		if (text == null)
		{
			if (start != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			return default(ReadOnlySpan<char>);
		}
		if ((uint)start > (uint)text.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new ReadOnlySpan<char>(Unsafe.As<Pinnable<char>>(text), StringAdjustment + start * 2, text.Length - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<char> AsSpan(this string? text, int start, int length)
	{
		if (text == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			return default(ReadOnlySpan<char>);
		}
		if ((uint)start > (uint)text.Length || (uint)length > (uint)(text.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new ReadOnlySpan<char>(Unsafe.As<Pinnable<char>>(text), StringAdjustment + start * 2, length);
	}

	public static ReadOnlyMemory<char> AsMemory(this string? text)
	{
		if (text == null)
		{
			return default(ReadOnlyMemory<char>);
		}
		return new ReadOnlyMemory<char>(text, 0, text.Length);
	}

	public static ReadOnlyMemory<char> AsMemory(this string? text, int start)
	{
		if (text == null)
		{
			if (start != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			return default(ReadOnlyMemory<char>);
		}
		if ((uint)start > (uint)text.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new ReadOnlyMemory<char>(text, start, text.Length - start);
	}

	public static ReadOnlyMemory<char> AsMemory(this string? text, int start, int length)
	{
		if (text == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			return default(ReadOnlyMemory<char>);
		}
		if ((uint)start > (uint)text.Length || (uint)length > (uint)(text.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new ReadOnlyMemory<char>(text, start, length);
	}

	private unsafe static nint MeasureStringAdjustment()
	{
		fixed (char* source = "a")
		{
			return Unsafe.ByteOffset(ref Unsafe.As<Pinnable<char>>("a").Data, ref Unsafe.AsRef<char>(source));
		}
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential)]
internal sealed class Pinnable<T>
{
	public T Data;
}


using System;
using System.Buffers;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[DebuggerTypeProxy(typeof(System.MemoryDebugView<>))]
[DebuggerDisplay("{ToString(),raw}")]
internal readonly struct ReadOnlyMemory<T>
{
	private readonly object? _object;

	private readonly int _index;

	private readonly int _length;

	internal const int RemoveFlagsBitMask = int.MaxValue;

	public static ReadOnlyMemory<T> Empty => default(ReadOnlyMemory<T>);

	public int Length => _length & 0x7FFFFFFF;

	public bool IsEmpty => (_length & 0x7FFFFFFF) == 0;

	public ReadOnlySpan<T> Span
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if (_index < 0)
			{
				return ((MemoryManager<T>)_object).GetSpan().Slice(_index & 0x7FFFFFFF, _length);
			}
			ReadOnlySpan<T> result;
			if (typeof(T) == typeof(char) && _object is string text)
			{
				result = new ReadOnlySpan<T>(Unsafe.As<Pinnable<T>>(text), MemoryExtensions.StringAdjustment, text.Length);
				return result.Slice(_index, _length);
			}
			if (_object != null)
			{
				return new ReadOnlySpan<T>((T[])_object, _index, _length & 0x7FFFFFFF);
			}
			result = default(ReadOnlySpan<T>);
			return result;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory(T[]? array)
	{
		if (array == null)
		{
			this = default(ReadOnlyMemory<T>);
			return;
		}
		_object = array;
		_index = 0;
		_length = array.Length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory(T[]? array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			this = default(ReadOnlyMemory<T>);
			return;
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		_object = array;
		_index = start;
		_length = length;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ReadOnlyMemory(object? obj, int start, int length)
	{
		_object = obj;
		_index = start;
		_length = length;
	}

	public static implicit operator ReadOnlyMemory<T>(T[]? array)
	{
		return new ReadOnlyMemory<T>(array);
	}

	public static implicit operator ReadOnlyMemory<T>(ArraySegment<T> segment)
	{
		return new ReadOnlyMemory<T>(segment.Array, segment.Offset, segment.Count);
	}

	public override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			if (!(_object is string text))
			{
				return Span.ToString();
			}
			return text.Substring(_index, _length & 0x7FFFFFFF);
		}
		return $"System.ReadOnlyMemory<{typeof(T).Name}>[{_length & 0x7FFFFFFF}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory<T> Slice(int start)
	{
		int length = _length;
		int num = length & 0x7FFFFFFF;
		if ((uint)start > (uint)num)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new ReadOnlyMemory<T>(_object, _index + start, length - start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlyMemory<T> Slice(int start, int length)
	{
		int length2 = _length;
		int num = _length & 0x7FFFFFFF;
		if ((uint)start > (uint)num || (uint)length > (uint)(num - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return new ReadOnlyMemory<T>(_object, _index + start, length | (length2 & int.MinValue));
	}

	public void CopyTo(Memory<T> destination)
	{
		Span.CopyTo(destination.Span);
	}

	public bool TryCopyTo(Memory<T> destination)
	{
		return Span.TryCopyTo(destination.Span);
	}

	public unsafe MemoryHandle Pin()
	{
		if (_index < 0)
		{
			return ((MemoryManager<T>)_object).Pin(_index & 0x7FFFFFFF);
		}
		if (typeof(T) == typeof(char) && _object is string value)
		{
			GCHandle handle = GCHandle.Alloc(value, GCHandleType.Pinned);
			return new MemoryHandle(Unsafe.Add<T>((void*)handle.AddrOfPinnedObject(), _index), handle);
		}
		if (_object is T[] array)
		{
			if (_length < 0)
			{
				return new MemoryHandle(Unsafe.Add<T>(Unsafe.AsPointer(ref MemoryMarshal.GetReference<T>(array)), _index));
			}
			GCHandle handle2 = GCHandle.Alloc(array, GCHandleType.Pinned);
			return new MemoryHandle(Unsafe.Add<T>((void*)handle2.AddrOfPinnedObject(), _index), handle2);
		}
		return default(MemoryHandle);
	}

	public T[] ToArray()
	{
		return Span.ToArray();
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object? obj)
	{
		if (obj is ReadOnlyMemory<T> other)
		{
			return Equals(other);
		}
		if (obj is Memory<T> memory)
		{
			return Equals(memory);
		}
		return false;
	}

	public bool Equals(ReadOnlyMemory<T> other)
	{
		if (_object == other._object && _index == other._index)
		{
			return _length == other._length;
		}
		return false;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		if (_object == null)
		{
			return 0;
		}
		return HashCode.Combine(_object, _index, _length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal object? GetObjectStartLength(out int start, out int length)
	{
		start = _index;
		length = _length;
		return _object;
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[DebuggerTypeProxy(typeof(System.SpanDebugView<>))]
[DebuggerDisplay("{ToString(),raw}")]
internal readonly ref struct ReadOnlySpan<T>
{
	public ref struct Enumerator
	{
		private readonly ReadOnlySpan<T> _span;

		private int _index;

		public ref readonly T Current
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref _span[_index];
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal Enumerator(ReadOnlySpan<T> span)
		{
			_span = span;
			_index = -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool MoveNext()
		{
			int num = _index + 1;
			if (num < _span.Length)
			{
				_index = num;
				return true;
			}
			return false;
		}
	}

	private readonly Pinnable<T>? _pinnable;

	private readonly IntPtr _byteOffset;

	private readonly int _length;

	public int Length => _length;

	public bool IsEmpty => _length == 0;

	public static ReadOnlySpan<T> Empty => default(ReadOnlySpan<T>);

	public unsafe ref readonly T this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= (uint)_length)
			{
				System.ThrowHelper.ThrowIndexOutOfRangeException();
			}
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.Add(ref Unsafe.AsRef<T>(byteOffset.ToPointer()), index);
			}
			return ref Unsafe.Add(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset), index);
		}
	}

	internal Pinnable<T>? Pinnable => _pinnable;

	internal IntPtr ByteOffset => _byteOffset;

	public static bool operator !=(ReadOnlySpan<T> left, ReadOnlySpan<T> right)
	{
		return !(left == right);
	}

	[Obsolete("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object? obj)
	{
		throw new NotSupportedException("Cannot call Equals on Span");
	}

	[Obsolete("GetHashCode() on ReadOnlySpan will always throw an exception.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		throw new NotSupportedException("Cannot call GetHashCodee on Span");
	}

	public static implicit operator ReadOnlySpan<T>(T[]? array)
	{
		return new ReadOnlySpan<T>(array);
	}

	public static implicit operator ReadOnlySpan<T>(ArraySegment<T> segment)
	{
		return new ReadOnlySpan<T>(segment.Array ?? throw new ArgumentNullException("segment"), segment.Offset, segment.Count);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan(T[]? array)
	{
		if (array == null)
		{
			this = default(ReadOnlySpan<T>);
			return;
		}
		_length = array.Length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan(T[]? array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			this = default(ReadOnlySpan<T>);
			return;
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		_length = length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment.Add<T>(start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public unsafe ReadOnlySpan(void* pointer, int length)
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (length < 0)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		_length = length;
		_pinnable = null;
		_byteOffset = new IntPtr(pointer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ReadOnlySpan(Pinnable<T>? pinnable, IntPtr byteOffset, int length)
	{
		_length = length;
		_pinnable = pinnable;
		_byteOffset = byteOffset;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public unsafe ref readonly T GetPinnableReference()
	{
		if (_length != 0)
		{
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
			}
			return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
		}
		return ref Unsafe.AsRef<T>(null);
	}

	public void CopyTo(Span<T> destination)
	{
		if (!TryCopyTo(destination))
		{
			System.ThrowHelper.ThrowArgumentException_DestinationTooShort();
		}
	}

	public bool TryCopyTo(Span<T> destination)
	{
		int length = _length;
		int length2 = destination.Length;
		if (length == 0)
		{
			return true;
		}
		if ((uint)length > (uint)length2)
		{
			return false;
		}
		ref T src = ref DangerousGetPinnableReference();
		System.SpanHelpers.CopyTo(ref destination.DangerousGetPinnableReference(), length2, ref src, length);
		return true;
	}

	public static bool operator ==(ReadOnlySpan<T> left, ReadOnlySpan<T> right)
	{
		if (left._length == right._length)
		{
			return Unsafe.AreSame(ref left.DangerousGetPinnableReference(), ref right.DangerousGetPinnableReference());
		}
		return false;
	}

	public unsafe override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			if (_byteOffset == MemoryExtensions.StringAdjustment && Unsafe.As<object>(_pinnable) is string text && _length == text.Length)
			{
				return text;
			}
			fixed (char* value = &Unsafe.As<T, char>(ref DangerousGetPinnableReference()))
			{
				return new string(value, 0, _length);
			}
		}
		return $"System.ReadOnlySpan<{typeof(T).Name}>[{_length}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan<T> Slice(int start)
	{
		if ((uint)start > (uint)_length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		int length = _length - start;
		return new ReadOnlySpan<T>(_pinnable, byteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySpan<T> Slice(int start, int length)
	{
		if ((uint)start > (uint)_length || (uint)length > (uint)(_length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		return new ReadOnlySpan<T>(_pinnable, byteOffset, length);
	}

	public T[] ToArray()
	{
		if (_length == 0)
		{
			return System.SpanHelpers.PerTypeValues<T>.EmptyArray;
		}
		T[] array = new T[_length];
		CopyTo(array);
		return array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal unsafe ref T DangerousGetPinnableReference()
	{
		if (_pinnable == null)
		{
			IntPtr byteOffset = _byteOffset;
			return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
	}
}


using System.Runtime.CompilerServices;

public ref struct Enumerator
{
	private readonly ReadOnlySpan<T> _span;

	private int _index;

	public ref readonly T Current
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref _span[_index];
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Enumerator(ReadOnlySpan<T> span)
	{
		_span = span;
		_index = -1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool MoveNext()
	{
		int num = _index + 1;
		if (num < _span.Length)
		{
			_index = num;
			return true;
		}
		return false;
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[DebuggerTypeProxy(typeof(System.SpanDebugView<>))]
[DebuggerDisplay("{ToString(),raw}")]
internal readonly ref struct Span<T>
{
	public ref struct Enumerator
	{
		private readonly Span<T> _span;

		private int _index;

		public ref T Current
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref _span[_index];
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal Enumerator(Span<T> span)
		{
			_span = span;
			_index = -1;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool MoveNext()
		{
			int num = _index + 1;
			if (num < _span.Length)
			{
				_index = num;
				return true;
			}
			return false;
		}
	}

	private readonly Pinnable<T>? _pinnable;

	private readonly IntPtr _byteOffset;

	private readonly int _length;

	public int Length => _length;

	public bool IsEmpty => _length == 0;

	public static Span<T> Empty => default(Span<T>);

	public unsafe ref T this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= (uint)_length)
			{
				System.ThrowHelper.ThrowIndexOutOfRangeException();
			}
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.Add(ref Unsafe.AsRef<T>(byteOffset.ToPointer()), index);
			}
			return ref Unsafe.Add(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset), index);
		}
	}

	internal Pinnable<T>? Pinnable => _pinnable;

	internal IntPtr ByteOffset => _byteOffset;

	public static bool operator !=(Span<T> left, Span<T> right)
	{
		return !(left == right);
	}

	[Obsolete("Equals() on Span will always throw an exception. Use == instead.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override bool Equals(object? obj)
	{
		throw new NotSupportedException("Cannot call Equals on Span");
	}

	[Obsolete("GetHashCode() on Span will always throw an exception.")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public override int GetHashCode()
	{
		throw new NotSupportedException("Cannot call GetHashCode on Span");
	}

	public static implicit operator Span<T>(T[]? array)
	{
		return new Span<T>(array);
	}

	public static implicit operator Span<T>(ArraySegment<T> segment)
	{
		return new Span<T>(segment.Array, segment.Offset, segment.Count);
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span(T[]? array)
	{
		if (array == null)
		{
			this = default(Span<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		_length = array.Length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static Span<T> Create(T[]? array, int start)
	{
		if (array == null)
		{
			if (start != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			return default(Span<T>);
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		IntPtr byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment.Add<T>(start);
		int length = array.Length - start;
		return new Span<T>(Unsafe.As<Pinnable<T>>(array), byteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span(T[]? array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			this = default(Span<T>);
			return;
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		_length = length;
		_pinnable = Unsafe.As<Pinnable<T>>(array);
		_byteOffset = System.SpanHelpers.PerTypeValues<T>.ArrayAdjustment.Add<T>(start);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public unsafe Span(void* pointer, int length)
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (length < 0)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		_length = length;
		_pinnable = null;
		_byteOffset = new IntPtr(pointer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Span(Pinnable<T>? pinnable, IntPtr byteOffset, int length)
	{
		_length = length;
		_pinnable = pinnable;
		_byteOffset = byteOffset;
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public unsafe ref T GetPinnableReference()
	{
		if (_length != 0)
		{
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
			}
			return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
		}
		return ref Unsafe.AsRef<T>(null);
	}

	public unsafe void Clear()
	{
		int length = _length;
		if (length == 0)
		{
			return;
		}
		nuint byteLength = (UIntPtr)(ulong)((uint)length * Unsafe.SizeOf<T>());
		if ((Unsafe.SizeOf<T>() & (sizeof(IntPtr) - 1)) != 0)
		{
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				byte* ptr = (byte*)byteOffset.ToPointer();
				System.SpanHelpers.ClearLessThanPointerSized(ptr, byteLength);
			}
			else
			{
				System.SpanHelpers.ClearLessThanPointerSized(ref Unsafe.As<T, byte>(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset)), byteLength);
			}
		}
		else if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			nuint pointerSizeLength = (UIntPtr)(ulong)(length * Unsafe.SizeOf<T>() / sizeof(IntPtr));
			System.SpanHelpers.ClearPointerSizedWithReferences(ref Unsafe.As<T, IntPtr>(ref DangerousGetPinnableReference()), pointerSizeLength);
		}
		else
		{
			System.SpanHelpers.ClearPointerSizedWithoutReferences(ref Unsafe.As<T, byte>(ref DangerousGetPinnableReference()), byteLength);
		}
	}

	public unsafe void Fill(T value)
	{
		int length = _length;
		if (length == 0)
		{
			return;
		}
		if (Unsafe.SizeOf<T>() == 1)
		{
			byte value2 = Unsafe.As<T, byte>(ref value);
			if (_pinnable == null)
			{
				IntPtr byteOffset = _byteOffset;
				Unsafe.InitBlockUnaligned(byteOffset.ToPointer(), value2, (uint)length);
			}
			else
			{
				Unsafe.InitBlockUnaligned(ref Unsafe.As<T, byte>(ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset)), value2, (uint)length);
			}
			return;
		}
		ref T source = ref DangerousGetPinnableReference();
		int i;
		for (i = 0; i < (length & -8); i += 8)
		{
			Unsafe.Add(ref source, i) = value;
			Unsafe.Add(ref source, i + 1) = value;
			Unsafe.Add(ref source, i + 2) = value;
			Unsafe.Add(ref source, i + 3) = value;
			Unsafe.Add(ref source, i + 4) = value;
			Unsafe.Add(ref source, i + 5) = value;
			Unsafe.Add(ref source, i + 6) = value;
			Unsafe.Add(ref source, i + 7) = value;
		}
		if (i < (length & -4))
		{
			Unsafe.Add(ref source, i) = value;
			Unsafe.Add(ref source, i + 1) = value;
			Unsafe.Add(ref source, i + 2) = value;
			Unsafe.Add(ref source, i + 3) = value;
			i += 4;
		}
		for (; i < length; i++)
		{
			Unsafe.Add(ref source, i) = value;
		}
	}

	public void CopyTo(Span<T> destination)
	{
		if (!TryCopyTo(destination))
		{
			System.ThrowHelper.ThrowArgumentException_DestinationTooShort();
		}
	}

	public bool TryCopyTo(Span<T> destination)
	{
		int length = _length;
		int length2 = destination._length;
		if (length == 0)
		{
			return true;
		}
		if ((uint)length > (uint)length2)
		{
			return false;
		}
		ref T src = ref DangerousGetPinnableReference();
		System.SpanHelpers.CopyTo(ref destination.DangerousGetPinnableReference(), length2, ref src, length);
		return true;
	}

	public static bool operator ==(Span<T> left, Span<T> right)
	{
		if (left._length == right._length)
		{
			return Unsafe.AreSame(ref left.DangerousGetPinnableReference(), ref right.DangerousGetPinnableReference());
		}
		return false;
	}

	public static implicit operator ReadOnlySpan<T>(Span<T> span)
	{
		return new ReadOnlySpan<T>(span._pinnable, span._byteOffset, span._length);
	}

	public unsafe override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			fixed (char* value = &Unsafe.As<T, char>(ref DangerousGetPinnableReference()))
			{
				return new string(value, 0, _length);
			}
		}
		return $"System.Span<{typeof(T).Name}>[{_length}]";
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<T> Slice(int start)
	{
		if ((uint)start > (uint)_length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		int length = _length - start;
		return new Span<T>(_pinnable, byteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Span<T> Slice(int start, int length)
	{
		if ((uint)start > (uint)_length || (uint)length > (uint)(_length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		IntPtr byteOffset = _byteOffset.Add<T>(start);
		return new Span<T>(_pinnable, byteOffset, length);
	}

	public T[] ToArray()
	{
		if (_length == 0)
		{
			return System.SpanHelpers.PerTypeValues<T>.EmptyArray;
		}
		T[] array = new T[_length];
		CopyTo(array);
		return array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	internal unsafe ref T DangerousGetPinnableReference()
	{
		if (_pinnable == null)
		{
			IntPtr byteOffset = _byteOffset;
			return ref Unsafe.AsRef<T>(byteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref _pinnable.Data, _byteOffset);
	}
}


using System.Runtime.CompilerServices;

public ref struct Enumerator
{
	private readonly Span<T> _span;

	private int _index;

	public ref T Current
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref _span[_index];
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Enumerator(Span<T> span)
	{
		_span = span;
		_index = -1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool MoveNext()
	{
		int num = _index + 1;
		if (num < _span.Length)
		{
			_index = num;
			return true;
		}
		return false;
	}
}


using System;
using System.Diagnostics;

internal sealed class SpanDebugView<T>
{
	private readonly T[] _array;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public T[] Items => _array;

	public SpanDebugView(Span<T> span)
	{
		_array = span.ToArray();
	}

	public SpanDebugView(ReadOnlySpan<T> span)
	{
		_array = span.ToArray();
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class SpanHelpers
{
	internal struct ComparerComparable<T, TComparer> : IComparable<T> where TComparer : IComparer<T>
	{
		private readonly T _value;

		private readonly TComparer _comparer;

		public ComparerComparable(T value, TComparer comparer)
		{
			_value = value;
			_comparer = comparer;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public int CompareTo(T? other)
		{
			return _comparer.Compare(_value, other);
		}
	}

	[StructLayout(LayoutKind.Sequential, Size = 64)]
	private struct Reg64
	{
	}

	[StructLayout(LayoutKind.Sequential, Size = 32)]
	private struct Reg32
	{
	}

	[StructLayout(LayoutKind.Sequential, Size = 16)]
	private struct Reg16
	{
	}

	public static class PerTypeValues<T>
	{
		public static readonly bool IsReferenceOrContainsReferences = IsReferenceOrContainsReferencesCore(typeof(T));

		public static readonly T[] EmptyArray = ArrayEx.Empty<T>();

		public static readonly IntPtr ArrayAdjustment = MeasureArrayAdjustment();

		private static IntPtr MeasureArrayAdjustment()
		{
			T[] array = new T[1];
			return Unsafe.ByteOffset(ref Unsafe.As<Pinnable<T>>(array).Data, ref array[0]);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int BinarySearch<T, TComparable>(this ReadOnlySpan<T> span, TComparable comparable) where TComparable : IComparable<T>
	{
		if (comparable == null)
		{
			System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.comparable);
		}
		return BinarySearch(ref MemoryMarshal.GetReference(span), span.Length, comparable);
	}

	public static int BinarySearch<T, TComparable>(ref T spanStart, int length, TComparable comparable) where TComparable : IComparable<T>
	{
		int num = 0;
		int num2 = length - 1;
		while (num <= num2)
		{
			int num3 = num2 + num >>> 1;
			ref TComparable reference = ref comparable;
			TComparable val = default(TComparable);
			if (val == null)
			{
				val = reference;
				reference = ref val;
			}
			int num4 = reference.CompareTo(Unsafe.Add(ref spanStart, num3));
			if (num4 == 0)
			{
				return num3;
			}
			if (num4 > 0)
			{
				num = num3 + 1;
			}
			else
			{
				num2 = num3 - 1;
			}
		}
		return ~num;
	}

	public static int IndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		byte value2 = value;
		ref byte second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = IndexOf(ref Unsafe.Add(ref searchSpace, num2), value2, num3);
			if (num4 == -1)
			{
				break;
			}
			num2 += num4;
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num2 + 1), ref second, num))
			{
				return num2;
			}
			num2++;
		}
		return -1;
	}

	public static int IndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = IndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if ((uint)num2 < (uint)num)
			{
				num = num2;
				searchSpaceLength = num2;
				if (num == 0)
				{
					break;
				}
			}
		}
		return num;
	}

	public static int LastIndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = LastIndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if (num2 > num)
			{
				num = num2;
			}
		}
		return num;
	}

	public static int IndexOf(ref byte searchSpace, byte value, int length)
	{
		nint num = 0;
		nint num2 = length;
		while (true)
		{
			if ((nuint)num2 >= (nuint)8u)
			{
				num2 -= 8;
				if (value != Unsafe.AddByteOffset(ref searchSpace, num))
				{
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 1))
					{
						goto IL_0109;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 2))
					{
						goto IL_010f;
					}
					if (value != Unsafe.AddByteOffset(ref searchSpace, num + 3))
					{
						if (value != Unsafe.AddByteOffset(ref searchSpace, num + 4))
						{
							if (value != Unsafe.AddByteOffset(ref searchSpace, num + 5))
							{
								if (value != Unsafe.AddByteOffset(ref searchSpace, num + 6))
								{
									if (value == Unsafe.AddByteOffset(ref searchSpace, num + 7))
									{
										break;
									}
									num += 8;
									continue;
								}
								return (int)(num + 6);
							}
							return (int)(num + 5);
						}
						return (int)(num + 4);
					}
					goto IL_0115;
				}
			}
			else
			{
				if ((nuint)num2 >= (nuint)4u)
				{
					num2 -= 4;
					if (value == Unsafe.AddByteOffset(ref searchSpace, num))
					{
						goto IL_0106;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 1))
					{
						goto IL_0109;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 2))
					{
						goto IL_010f;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 3))
					{
						goto IL_0115;
					}
					num += 4;
				}
				while (true)
				{
					if (num2 != 0)
					{
						num2--;
						if (value == Unsafe.AddByteOffset(ref searchSpace, num))
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_0106;
			IL_010f:
			return (int)(num + 2);
			IL_0106:
			return (int)num;
			IL_0109:
			return (int)(num + 1);
			IL_0115:
			return (int)(num + 3);
		}
		return (int)(num + 7);
	}

	public static int LastIndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength)
	{
		if (valueLength == 0)
		{
			return 0;
		}
		byte value2 = value;
		ref byte second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = LastIndexOf(ref searchSpace, value2, num3);
			if (num4 == -1)
			{
				break;
			}
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num4 + 1), ref second, num))
			{
				return num4;
			}
			num2 += num3 - num4;
		}
		return -1;
	}

	public static int LastIndexOf(ref byte searchSpace, byte value, int length)
	{
		nint num = length;
		nint num2 = length;
		while (true)
		{
			if ((nuint)num2 >= (nuint)8u)
			{
				num2 -= 8;
				num -= 8;
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 7))
				{
					break;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 6))
				{
					return (int)(num + 6);
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 5))
				{
					return (int)(num + 5);
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 4))
				{
					return (int)(num + 4);
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 3))
				{
					goto IL_010f;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 2))
				{
					goto IL_0109;
				}
				if (value == Unsafe.AddByteOffset(ref searchSpace, num + 1))
				{
					goto IL_0103;
				}
				if (value != Unsafe.AddByteOffset(ref searchSpace, num))
				{
					continue;
				}
			}
			else
			{
				if ((nuint)num2 >= (nuint)4u)
				{
					num2 -= 4;
					num -= 4;
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 3))
					{
						goto IL_010f;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 2))
					{
						goto IL_0109;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num + 1))
					{
						goto IL_0103;
					}
					if (value == Unsafe.AddByteOffset(ref searchSpace, num))
					{
						goto IL_0100;
					}
				}
				do
				{
					if (num2 != 0)
					{
						num2--;
						num--;
						continue;
					}
					return -1;
				}
				while (value != Unsafe.AddByteOffset(ref searchSpace, num));
			}
			goto IL_0100;
			IL_0109:
			return (int)(num + 2);
			IL_010f:
			return (int)(num + 3);
			IL_0103:
			return (int)(num + 1);
			IL_0100:
			return (int)num;
		}
		return (int)(num + 7);
	}

	public static int IndexOfAny(ref byte searchSpace, byte value0, byte value1, int length)
	{
		nint num = 0;
		nint num2 = length;
		while (true)
		{
			if ((nuint)num2 >= (nuint)8u)
			{
				num2 -= 8;
				uint num3 = Unsafe.AddByteOffset(ref searchSpace, num);
				if (value0 != num3 && value1 != num3)
				{
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_019b;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_01a1;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
					if (value0 != num3 && value1 != num3)
					{
						num3 = Unsafe.AddByteOffset(ref searchSpace, num + 4);
						if (value0 != num3 && value1 != num3)
						{
							num3 = Unsafe.AddByteOffset(ref searchSpace, num + 5);
							if (value0 != num3 && value1 != num3)
							{
								num3 = Unsafe.AddByteOffset(ref searchSpace, num + 6);
								if (value0 != num3 && value1 != num3)
								{
									num3 = Unsafe.AddByteOffset(ref searchSpace, num + 7);
									if (value0 == num3 || value1 == num3)
									{
										break;
									}
									num += 8;
									continue;
								}
								return (int)(num + 6);
							}
							return (int)(num + 5);
						}
						return (int)(num + 4);
					}
					goto IL_01a7;
				}
			}
			else
			{
				if ((nuint)num2 >= (nuint)4u)
				{
					num2 -= 4;
					uint num3 = Unsafe.AddByteOffset(ref searchSpace, num);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_0198;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_019b;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_01a1;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_01a7;
					}
					num += 4;
				}
				while (true)
				{
					if (num2 != 0)
					{
						num2--;
						uint num3 = Unsafe.AddByteOffset(ref searchSpace, num);
						if (value0 == num3 || value1 == num3)
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_0198;
			IL_01a1:
			return (int)(num + 2);
			IL_019b:
			return (int)(num + 1);
			IL_01a7:
			return (int)(num + 3);
			IL_0198:
			return (int)num;
		}
		return (int)(num + 7);
	}

	public static int IndexOfAny(ref byte searchSpace, byte value0, byte value1, byte value2, int length)
	{
		nint num = 0;
		nint num2 = length;
		while (true)
		{
			if ((nuint)num2 >= (nuint)8u)
			{
				num2 -= 8;
				uint num3 = Unsafe.AddByteOffset(ref searchSpace, num);
				if (value0 != num3 && value1 != num3 && value2 != num3)
				{
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_020a;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0210;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
					if (value0 != num3 && value1 != num3 && value2 != num3)
					{
						num3 = Unsafe.AddByteOffset(ref searchSpace, num + 4);
						if (value0 != num3 && value1 != num3 && value2 != num3)
						{
							num3 = Unsafe.AddByteOffset(ref searchSpace, num + 5);
							if (value0 != num3 && value1 != num3 && value2 != num3)
							{
								num3 = Unsafe.AddByteOffset(ref searchSpace, num + 6);
								if (value0 != num3 && value1 != num3 && value2 != num3)
								{
									num3 = Unsafe.AddByteOffset(ref searchSpace, num + 7);
									if (value0 == num3 || value1 == num3 || value2 == num3)
									{
										break;
									}
									num += 8;
									continue;
								}
								return (int)(num + 6);
							}
							return (int)(num + 5);
						}
						return (int)(num + 4);
					}
					goto IL_0216;
				}
			}
			else
			{
				if ((nuint)num2 >= (nuint)4u)
				{
					num2 -= 4;
					uint num3 = Unsafe.AddByteOffset(ref searchSpace, num);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0207;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_020a;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0210;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0216;
					}
					num += 4;
				}
				while (true)
				{
					if (num2 != 0)
					{
						num2--;
						uint num3 = Unsafe.AddByteOffset(ref searchSpace, num);
						if (value0 == num3 || value1 == num3 || value2 == num3)
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_0207;
			IL_0207:
			return (int)num;
			IL_0210:
			return (int)(num + 2);
			IL_020a:
			return (int)(num + 1);
			IL_0216:
			return (int)(num + 3);
		}
		return (int)(num + 7);
	}

	public static int LastIndexOfAny(ref byte searchSpace, byte value0, byte value1, int length)
	{
		nint num = length;
		nint num2 = length;
		while (true)
		{
			if ((nuint)num2 >= (nuint)8u)
			{
				num2 -= 8;
				num -= 8;
				uint num3 = Unsafe.AddByteOffset(ref searchSpace, num + 7);
				if (value0 == num3 || value1 == num3)
				{
					break;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 6);
				if (value0 == num3 || value1 == num3)
				{
					return (int)(num + 6);
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 5);
				if (value0 == num3 || value1 == num3)
				{
					return (int)(num + 5);
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 4);
				if (value0 == num3 || value1 == num3)
				{
					return (int)(num + 4);
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
				if (value0 == num3 || value1 == num3)
				{
					goto IL_01a7;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
				if (value0 == num3 || value1 == num3)
				{
					goto IL_01a1;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
				if (value0 == num3 || value1 == num3)
				{
					goto IL_019b;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num);
				if (value0 != num3 && value1 != num3)
				{
					continue;
				}
			}
			else
			{
				uint num3;
				if ((nuint)num2 >= (nuint)4u)
				{
					num2 -= 4;
					num -= 4;
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_01a7;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_01a1;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_019b;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num);
					if (value0 == num3 || value1 == num3)
					{
						goto IL_0198;
					}
				}
				do
				{
					if (num2 != 0)
					{
						num2--;
						num--;
						num3 = Unsafe.AddByteOffset(ref searchSpace, num);
						continue;
					}
					return -1;
				}
				while (value0 != num3 && value1 != num3);
			}
			goto IL_0198;
			IL_01a1:
			return (int)(num + 2);
			IL_019b:
			return (int)(num + 1);
			IL_0198:
			return (int)num;
			IL_01a7:
			return (int)(num + 3);
		}
		return (int)(num + 7);
	}

	public static int LastIndexOfAny(ref byte searchSpace, byte value0, byte value1, byte value2, int length)
	{
		nint num = length;
		nint num2 = length;
		while (true)
		{
			if ((nuint)num2 >= (nuint)8u)
			{
				num2 -= 8;
				num -= 8;
				uint num3 = Unsafe.AddByteOffset(ref searchSpace, num + 7);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					break;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 6);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					return (int)(num + 6);
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 5);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					return (int)(num + 5);
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 4);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					return (int)(num + 4);
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					goto IL_0217;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					goto IL_0211;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
				if (value0 == num3 || value1 == num3 || value2 == num3)
				{
					goto IL_020b;
				}
				num3 = Unsafe.AddByteOffset(ref searchSpace, num);
				if (value0 != num3 && value1 != num3 && value2 != num3)
				{
					continue;
				}
			}
			else
			{
				uint num3;
				if ((nuint)num2 >= (nuint)4u)
				{
					num2 -= 4;
					num -= 4;
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 3);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0217;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 2);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0211;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num + 1);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_020b;
					}
					num3 = Unsafe.AddByteOffset(ref searchSpace, num);
					if (value0 == num3 || value1 == num3 || value2 == num3)
					{
						goto IL_0208;
					}
				}
				do
				{
					if (num2 != 0)
					{
						num2--;
						num--;
						num3 = Unsafe.AddByteOffset(ref searchSpace, num);
						continue;
					}
					return -1;
				}
				while (value0 != num3 && value1 != num3 && value2 != num3);
			}
			goto IL_0208;
			IL_020b:
			return (int)(num + 1);
			IL_0211:
			return (int)(num + 2);
			IL_0217:
			return (int)(num + 3);
			IL_0208:
			return (int)num;
		}
		return (int)(num + 7);
	}

	public unsafe static bool SequenceEqual(ref byte first, ref byte second, nuint length)
	{
		if (!Unsafe.AreSame(ref first, ref second))
		{
			nint num = 0;
			nint num2 = (nint)length;
			if ((nuint)num2 >= (nuint)sizeof(UIntPtr))
			{
				num2 -= sizeof(UIntPtr);
				while (true)
				{
					if ((nuint)num2 > (nuint)num)
					{
						if (Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, num)) != Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, num)))
						{
							break;
						}
						num += sizeof(UIntPtr);
						continue;
					}
					return Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, num2)) == Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, num2));
				}
				goto IL_008f;
			}
			while ((nuint)num2 > (nuint)num)
			{
				if (Unsafe.AddByteOffset(ref first, num) == Unsafe.AddByteOffset(ref second, num))
				{
					num++;
					continue;
				}
				goto IL_008f;
			}
		}
		return true;
		IL_008f:
		return false;
	}

	public unsafe static int SequenceCompareTo(ref byte first, int firstLength, ref byte second, int secondLength)
	{
		if (!Unsafe.AreSame(ref first, ref second))
		{
			nint num = ((firstLength < secondLength) ? firstLength : secondLength);
			nint num2 = 0;
			nint num3 = num;
			if ((nuint)num3 > (nuint)sizeof(UIntPtr))
			{
				for (num3 -= sizeof(UIntPtr); (nuint)num3 > (nuint)num2 && !(Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, num2)) != Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, num2))); num2 += sizeof(UIntPtr))
				{
				}
			}
			for (; (nuint)num > (nuint)num2; num2++)
			{
				int num4 = Unsafe.AddByteOffset(ref first, num2).CompareTo(Unsafe.AddByteOffset(ref second, num2));
				if (num4 != 0)
				{
					return num4;
				}
			}
		}
		return firstLength - secondLength;
	}

	public unsafe static int SequenceCompareTo(ref char first, int firstLength, ref char second, int secondLength)
	{
		int result = firstLength - secondLength;
		if (!Unsafe.AreSame(ref first, ref second))
		{
			nint num = ((firstLength < secondLength) ? firstLength : secondLength);
			nint num2 = 0;
			if ((nuint)num >= (nuint)(sizeof(UIntPtr) / 2))
			{
				for (; (nuint)num >= (nuint)(num2 + sizeof(UIntPtr) / 2) && !(Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref first, num2))) != Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref second, num2)))); num2 += sizeof(UIntPtr) / 2)
				{
				}
			}
			if (sizeof(UIntPtr) > 4 && (nuint)num >= (nuint)(num2 + 2) && Unsafe.ReadUnaligned<int>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref first, num2))) == Unsafe.ReadUnaligned<int>(ref Unsafe.As<char, byte>(ref Unsafe.Add(ref second, num2))))
			{
				num2 += 2;
			}
			for (; (nuint)num2 < (nuint)num; num2++)
			{
				int num3 = Unsafe.Add(ref first, num2).CompareTo(Unsafe.Add(ref second, num2));
				if (num3 != 0)
				{
					return num3;
				}
			}
		}
		return result;
	}

	public unsafe static int IndexOf(ref char searchSpace, char value, int length)
	{
		fixed (char* ptr = &searchSpace)
		{
			char* ptr2 = ptr;
			_ = length;
			while (true)
			{
				if (length >= 4)
				{
					length -= 4;
					if (*ptr2 == value)
					{
						break;
					}
					if (ptr2[1] != value)
					{
						if (ptr2[2] != value)
						{
							if (ptr2[3] != value)
							{
								ptr2 += 4;
								continue;
							}
							ptr2++;
						}
						ptr2++;
					}
					ptr2++;
					break;
				}
				while (true)
				{
					if (length > 0)
					{
						length--;
						if (*ptr2 == value)
						{
							break;
						}
						ptr2++;
						continue;
					}
					return -1;
				}
				break;
			}
			return (int)(ptr2 - ptr);
		}
	}

	public unsafe static int LastIndexOf(ref char searchSpace, char value, int length)
	{
		fixed (char* ptr = &searchSpace)
		{
			char* ptr2 = ptr + length;
			char* ptr3 = ptr;
			while (true)
			{
				if (length >= 4)
				{
					length -= 4;
					ptr2 -= 4;
					if (ptr2[3] == value)
					{
						break;
					}
					if (ptr2[2] == value)
					{
						return (int)(ptr2 - ptr3) + 2;
					}
					if (ptr2[1] == value)
					{
						return (int)(ptr2 - ptr3) + 1;
					}
					if (*ptr2 != value)
					{
						continue;
					}
				}
				else
				{
					do
					{
						if (length > 0)
						{
							length--;
							ptr2--;
							continue;
						}
						return -1;
					}
					while (*ptr2 != value);
				}
				return (int)(ptr2 - ptr3);
			}
			return (int)(ptr2 - ptr3) + 3;
		}
	}

	public unsafe static void CopyTo<T>(ref T dst, int dstLength, ref T src, int srcLength)
	{
		IntPtr intPtr = Unsafe.ByteOffset(ref src, ref Unsafe.Add(ref src, srcLength));
		IntPtr intPtr2 = Unsafe.ByteOffset(ref dst, ref Unsafe.Add(ref dst, dstLength));
		IntPtr intPtr3 = Unsafe.ByteOffset(ref src, ref dst);
		bool num;
		if (sizeof(IntPtr) != 4)
		{
			if ((ulong)(long)intPtr3 >= (ulong)(long)intPtr)
			{
				num = (ulong)(long)intPtr3 > (ulong)(-(long)intPtr2);
				goto IL_006f;
			}
		}
		else if ((uint)(int)intPtr3 >= (uint)(int)intPtr)
		{
			num = (uint)(int)intPtr3 > (uint)(-(int)intPtr2);
			goto IL_006f;
		}
		goto IL_00da;
		IL_006f:
		if (!num && !IsReferenceOrContainsReferences<T>())
		{
			ref byte source = ref Unsafe.As<T, byte>(ref dst);
			ref byte source2 = ref Unsafe.As<T, byte>(ref src);
			ulong num2 = (ulong)(long)intPtr;
			uint num4;
			for (ulong num3 = 0uL; num3 < num2; num3 += num4)
			{
				num4 = (uint)((num2 - num3 > uint.MaxValue) ? uint.MaxValue : (num2 - num3));
				Unsafe.CopyBlock(ref Unsafe.Add(ref source, (IntPtr)(long)num3), ref Unsafe.Add(ref source2, (IntPtr)(long)num3), num4);
			}
			return;
		}
		goto IL_00da;
		IL_00da:
		bool num5 = ((sizeof(IntPtr) == 4) ? ((uint)(int)intPtr3 > (uint)(-(int)intPtr2)) : ((ulong)(long)intPtr3 > (ulong)(-(long)intPtr2)));
		int num6 = (num5 ? 1 : (-1));
		int num7 = ((!num5) ? (srcLength - 1) : 0);
		int i;
		for (i = 0; i < (srcLength & -8); i += 8)
		{
			Unsafe.Add(ref dst, num7) = Unsafe.Add(ref src, num7);
			Unsafe.Add(ref dst, num7 + num6) = Unsafe.Add(ref src, num7 + num6);
			Unsafe.Add(ref dst, num7 + num6 * 2) = Unsafe.Add(ref src, num7 + num6 * 2);
			Unsafe.Add(ref dst, num7 + num6 * 3) = Unsafe.Add(ref src, num7 + num6 * 3);
			Unsafe.Add(ref dst, num7 + num6 * 4) = Unsafe.Add(ref src, num7 + num6 * 4);
			Unsafe.Add(ref dst, num7 + num6 * 5) = Unsafe.Add(ref src, num7 + num6 * 5);
			Unsafe.Add(ref dst, num7 + num6 * 6) = Unsafe.Add(ref src, num7 + num6 * 6);
			Unsafe.Add(ref dst, num7 + num6 * 7) = Unsafe.Add(ref src, num7 + num6 * 7);
			num7 += num6 * 8;
		}
		if (i < (srcLength & -4))
		{
			Unsafe.Add(ref dst, num7) = Unsafe.Add(ref src, num7);
			Unsafe.Add(ref dst, num7 + num6) = Unsafe.Add(ref src, num7 + num6);
			Unsafe.Add(ref dst, num7 + num6 * 2) = Unsafe.Add(ref src, num7 + num6 * 2);
			Unsafe.Add(ref dst, num7 + num6 * 3) = Unsafe.Add(ref src, num7 + num6 * 3);
			num7 += num6 * 4;
			i += 4;
		}
		for (; i < srcLength; i++)
		{
			Unsafe.Add(ref dst, num7) = Unsafe.Add(ref src, num7);
			num7 += num6;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static IntPtr Add<T>(this IntPtr start, int index)
	{
		if (sizeof(IntPtr) == 4)
		{
			uint num = (uint)(index * Unsafe.SizeOf<T>());
			return (IntPtr)((byte*)(void*)start + num);
		}
		ulong num2 = (ulong)index * (ulong)Unsafe.SizeOf<T>();
		return (IntPtr)((byte*)(void*)start + num2);
	}

	public static bool IsReferenceOrContainsReferences<T>()
	{
		return PerTypeValues<T>.IsReferenceOrContainsReferences;
	}

	private static bool IsReferenceOrContainsReferencesCore(Type type)
	{
		if (type.GetTypeInfo().IsPrimitive)
		{
			return false;
		}
		if (!type.GetTypeInfo().IsValueType)
		{
			return true;
		}
		Type underlyingType = Nullable.GetUnderlyingType(type);
		if (underlyingType != null)
		{
			type = underlyingType;
		}
		if (type.GetTypeInfo().IsEnum)
		{
			return false;
		}
		foreach (FieldInfo declaredField in type.GetTypeInfo().DeclaredFields)
		{
			if (!declaredField.IsStatic && IsReferenceOrContainsReferencesCore(declaredField.FieldType))
			{
				return true;
			}
		}
		return false;
	}

	public unsafe static void ClearLessThanPointerSized(byte* ptr, UIntPtr byteLength)
	{
		if (sizeof(UIntPtr) == 4)
		{
			Unsafe.InitBlockUnaligned(ptr, 0, (uint)byteLength);
			return;
		}
		ulong num = (ulong)byteLength;
		uint num2 = (uint)(num & 0xFFFFFFFFu);
		Unsafe.InitBlockUnaligned(ptr, 0, num2);
		num -= num2;
		ptr += num2;
		while (num != 0)
		{
			num2 = (uint)((num >= uint.MaxValue) ? uint.MaxValue : num);
			Unsafe.InitBlockUnaligned(ptr, 0, num2);
			ptr += num2;
			num -= num2;
		}
	}

	public unsafe static void ClearLessThanPointerSized(ref byte b, UIntPtr byteLength)
	{
		if (sizeof(UIntPtr) == 4)
		{
			Unsafe.InitBlockUnaligned(ref b, 0, (uint)byteLength);
			return;
		}
		ulong num = (ulong)byteLength;
		uint num2 = (uint)(num & 0xFFFFFFFFu);
		Unsafe.InitBlockUnaligned(ref b, 0, num2);
		num -= num2;
		long num3 = num2;
		while (num != 0)
		{
			num2 = (uint)((num >= uint.MaxValue) ? uint.MaxValue : num);
			Unsafe.InitBlockUnaligned(ref Unsafe.Add(ref b, (IntPtr)num3), 0, num2);
			num3 += num2;
			num -= num2;
		}
	}

	public unsafe static void ClearPointerSizedWithoutReferences(ref byte b, nuint byteLength)
	{
		nint num;
		for (num = 0; num.LessThanEqual(byteLength - (nuint)sizeof(Reg64)); num += sizeof(Reg64))
		{
			Unsafe.As<byte, Reg64>(ref Unsafe.Add(ref b, num)) = default(Reg64);
		}
		if (num.LessThanEqual(byteLength - (nuint)sizeof(Reg32)))
		{
			Unsafe.As<byte, Reg32>(ref Unsafe.Add(ref b, num)) = default(Reg32);
			num += sizeof(Reg32);
		}
		if (num.LessThanEqual(byteLength - (nuint)sizeof(Reg16)))
		{
			Unsafe.As<byte, Reg16>(ref Unsafe.Add(ref b, num)) = default(Reg16);
			num += sizeof(Reg16);
		}
		if (num.LessThanEqual(byteLength - 8))
		{
			Unsafe.As<byte, long>(ref Unsafe.Add(ref b, num)) = 0L;
			num += 8;
		}
		if (sizeof(IntPtr) == 4 && num.LessThanEqual(byteLength - 4))
		{
			Unsafe.As<byte, int>(ref Unsafe.Add(ref b, num)) = 0;
		}
	}

	public static void ClearPointerSizedWithReferences(ref IntPtr ip, nuint pointerSizeLength)
	{
		nint num = 0;
		nint num2;
		while ((num2 = num + 8).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, num + 0) = default(IntPtr);
			Unsafe.Add(ref ip, num + 1) = default(IntPtr);
			Unsafe.Add(ref ip, num + 2) = default(IntPtr);
			Unsafe.Add(ref ip, num + 3) = default(IntPtr);
			Unsafe.Add(ref ip, num + 4) = default(IntPtr);
			Unsafe.Add(ref ip, num + 5) = default(IntPtr);
			Unsafe.Add(ref ip, num + 6) = default(IntPtr);
			Unsafe.Add(ref ip, num + 7) = default(IntPtr);
			num = num2;
		}
		if ((num2 = num + 4).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, num + 0) = default(IntPtr);
			Unsafe.Add(ref ip, num + 1) = default(IntPtr);
			Unsafe.Add(ref ip, num + 2) = default(IntPtr);
			Unsafe.Add(ref ip, num + 3) = default(IntPtr);
			num = num2;
		}
		if ((num2 = num + 2).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, num + 0) = default(IntPtr);
			Unsafe.Add(ref ip, num + 1) = default(IntPtr);
			num = num2;
		}
		if ((num + 1).LessThanEqual(pointerSizeLength))
		{
			Unsafe.Add(ref ip, num) = default(IntPtr);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private unsafe static bool LessThanEqual(this IntPtr index, UIntPtr length)
	{
		if (sizeof(UIntPtr) != 4)
		{
			return (long)index <= (long)(ulong)length;
		}
		return (int)index <= (int)(uint)length;
	}

	public static int IndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		T value2 = value;
		ref T second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = IndexOf(ref Unsafe.Add(ref searchSpace, num2), value2, num3);
			if (num4 == -1)
			{
				break;
			}
			num2 += num4;
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num2 + 1), ref second, num))
			{
				return num2;
			}
			num2++;
		}
		return -1;
	}

	public static int IndexOf<T>(ref T searchSpace, T value, int length) where T : IEquatable<T>
	{
		nuint num = 0u;
		while (true)
		{
			T val;
			if (length >= 8)
			{
				length -= 8;
				ref T reference = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference;
					reference = ref val;
				}
				if (!reference.Equals(Unsafe.Add(ref searchSpace, num)))
				{
					ref T reference2 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference2;
						reference2 = ref val;
					}
					if (reference2.Equals(Unsafe.Add(ref searchSpace, num + 1)))
					{
						goto IL_0315;
					}
					ref T reference3 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference3;
						reference3 = ref val;
					}
					if (reference3.Equals(Unsafe.Add(ref searchSpace, num + 2)))
					{
						goto IL_031b;
					}
					ref T reference4 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference4;
						reference4 = ref val;
					}
					if (!reference4.Equals(Unsafe.Add(ref searchSpace, num + 3)))
					{
						ref T reference5 = ref value;
						val = default(T);
						if (val == null)
						{
							val = reference5;
							reference5 = ref val;
						}
						if (!reference5.Equals(Unsafe.Add(ref searchSpace, num + 4)))
						{
							ref T reference6 = ref value;
							val = default(T);
							if (val == null)
							{
								val = reference6;
								reference6 = ref val;
							}
							if (!reference6.Equals(Unsafe.Add(ref searchSpace, num + 5)))
							{
								ref T reference7 = ref value;
								val = default(T);
								if (val == null)
								{
									val = reference7;
									reference7 = ref val;
								}
								if (!reference7.Equals(Unsafe.Add(ref searchSpace, num + 6)))
								{
									ref T reference8 = ref value;
									val = default(T);
									if (val == null)
									{
										val = reference8;
										reference8 = ref val;
									}
									if (reference8.Equals(Unsafe.Add(ref searchSpace, num + 7)))
									{
										break;
									}
									num += 8;
									continue;
								}
								return (int)(num + 6);
							}
							return (int)(num + 5);
						}
						return (int)(num + 4);
					}
					goto IL_0321;
				}
			}
			else
			{
				if (length >= 4)
				{
					length -= 4;
					ref T reference9 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference9;
						reference9 = ref val;
					}
					if (reference9.Equals(Unsafe.Add(ref searchSpace, num)))
					{
						goto IL_0312;
					}
					ref T reference10 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference10;
						reference10 = ref val;
					}
					if (reference10.Equals(Unsafe.Add(ref searchSpace, num + 1)))
					{
						goto IL_0315;
					}
					ref T reference11 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference11;
						reference11 = ref val;
					}
					if (reference11.Equals(Unsafe.Add(ref searchSpace, num + 2)))
					{
						goto IL_031b;
					}
					ref T reference12 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference12;
						reference12 = ref val;
					}
					if (reference12.Equals(Unsafe.Add(ref searchSpace, num + 3)))
					{
						goto IL_0321;
					}
					num += 4;
				}
				while (true)
				{
					if (length > 0)
					{
						ref T reference13 = ref value;
						val = default(T);
						if (val == null)
						{
							val = reference13;
							reference13 = ref val;
						}
						if (reference13.Equals(Unsafe.Add(ref searchSpace, num)))
						{
							break;
						}
						num++;
						length--;
						continue;
					}
					return -1;
				}
			}
			goto IL_0312;
			IL_0312:
			return (int)num;
			IL_031b:
			return (int)(num + 2);
			IL_0315:
			return (int)(num + 1);
			IL_0321:
			return (int)(num + 3);
		}
		return (int)(num + 7);
	}

	public static int IndexOfAny<T>(ref T searchSpace, T value0, T value1, int length) where T : IEquatable<T>
	{
		int num = 0;
		while (true)
		{
			if (length - num >= 8)
			{
				T other = Unsafe.Add(ref searchSpace, num);
				if (!value0.Equals(other) && !value1.Equals(other))
				{
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cb;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cf;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (!value0.Equals(other) && !value1.Equals(other))
					{
						other = Unsafe.Add(ref searchSpace, num + 4);
						if (!value0.Equals(other) && !value1.Equals(other))
						{
							other = Unsafe.Add(ref searchSpace, num + 5);
							if (!value0.Equals(other) && !value1.Equals(other))
							{
								other = Unsafe.Add(ref searchSpace, num + 6);
								if (!value0.Equals(other) && !value1.Equals(other))
								{
									other = Unsafe.Add(ref searchSpace, num + 7);
									if (value0.Equals(other) || value1.Equals(other))
									{
										break;
									}
									num += 8;
									continue;
								}
								return num + 6;
							}
							return num + 5;
						}
						return num + 4;
					}
					goto IL_02d3;
				}
			}
			else
			{
				if (length - num >= 4)
				{
					T other = Unsafe.Add(ref searchSpace, num);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c9;
					}
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cb;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cf;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02d3;
					}
					num += 4;
				}
				while (true)
				{
					if (num < length)
					{
						T other = Unsafe.Add(ref searchSpace, num);
						if (value0.Equals(other) || value1.Equals(other))
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_02c9;
			IL_02cf:
			return num + 2;
			IL_02cb:
			return num + 1;
			IL_02d3:
			return num + 3;
			IL_02c9:
			return num;
		}
		return num + 7;
	}

	public static int IndexOfAny<T>(ref T searchSpace, T value0, T value1, T value2, int length) where T : IEquatable<T>
	{
		int num = 0;
		while (true)
		{
			if (length - num >= 8)
			{
				T other = Unsafe.Add(ref searchSpace, num);
				if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
				{
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c2;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c6;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
					{
						other = Unsafe.Add(ref searchSpace, num + 4);
						if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
						{
							other = Unsafe.Add(ref searchSpace, num + 5);
							if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
							{
								other = Unsafe.Add(ref searchSpace, num + 6);
								if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
								{
									other = Unsafe.Add(ref searchSpace, num + 7);
									if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
									{
										break;
									}
									num += 8;
									continue;
								}
								return num + 6;
							}
							return num + 5;
						}
						return num + 4;
					}
					goto IL_03ca;
				}
			}
			else
			{
				if (length - num >= 4)
				{
					T other = Unsafe.Add(ref searchSpace, num);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c0;
					}
					other = Unsafe.Add(ref searchSpace, num + 1);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c2;
					}
					other = Unsafe.Add(ref searchSpace, num + 2);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03c6;
					}
					other = Unsafe.Add(ref searchSpace, num + 3);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03ca;
					}
					num += 4;
				}
				while (true)
				{
					if (num < length)
					{
						T other = Unsafe.Add(ref searchSpace, num);
						if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
						{
							break;
						}
						num++;
						continue;
					}
					return -1;
				}
			}
			goto IL_03c0;
			IL_03c0:
			return num;
			IL_03c6:
			return num + 2;
			IL_03c2:
			return num + 1;
			IL_03ca:
			return num + 3;
		}
		return num + 7;
	}

	public static int IndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = IndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if ((uint)num2 < (uint)num)
			{
				num = num2;
				searchSpaceLength = num2;
				if (num == 0)
				{
					break;
				}
			}
		}
		return num;
	}

	public static int LastIndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		T value2 = value;
		ref T second = ref Unsafe.Add(ref value, 1);
		int num = valueLength - 1;
		int num2 = 0;
		while (true)
		{
			int num3 = searchSpaceLength - num2 - num;
			if (num3 <= 0)
			{
				break;
			}
			int num4 = LastIndexOf(ref searchSpace, value2, num3);
			if (num4 == -1)
			{
				break;
			}
			if (SequenceEqual(ref Unsafe.Add(ref searchSpace, num4 + 1), ref second, num))
			{
				return num4;
			}
			num2 += num3 - num4;
		}
		return -1;
	}

	public static int LastIndexOf<T>(ref T searchSpace, T value, int length) where T : IEquatable<T>
	{
		while (true)
		{
			T val;
			if (length >= 8)
			{
				length -= 8;
				ref T reference = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference;
					reference = ref val;
				}
				if (reference.Equals(Unsafe.Add(ref searchSpace, length + 7)))
				{
					break;
				}
				ref T reference2 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference2;
					reference2 = ref val;
				}
				if (reference2.Equals(Unsafe.Add(ref searchSpace, length + 6)))
				{
					return length + 6;
				}
				ref T reference3 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference3;
					reference3 = ref val;
				}
				if (reference3.Equals(Unsafe.Add(ref searchSpace, length + 5)))
				{
					return length + 5;
				}
				ref T reference4 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference4;
					reference4 = ref val;
				}
				if (reference4.Equals(Unsafe.Add(ref searchSpace, length + 4)))
				{
					return length + 4;
				}
				ref T reference5 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference5;
					reference5 = ref val;
				}
				if (reference5.Equals(Unsafe.Add(ref searchSpace, length + 3)))
				{
					goto IL_02fd;
				}
				ref T reference6 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference6;
					reference6 = ref val;
				}
				if (reference6.Equals(Unsafe.Add(ref searchSpace, length + 2)))
				{
					goto IL_02f9;
				}
				ref T reference7 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference7;
					reference7 = ref val;
				}
				if (reference7.Equals(Unsafe.Add(ref searchSpace, length + 1)))
				{
					goto IL_02f5;
				}
				ref T reference8 = ref value;
				val = default(T);
				if (val == null)
				{
					val = reference8;
					reference8 = ref val;
				}
				if (!reference8.Equals(Unsafe.Add(ref searchSpace, length)))
				{
					continue;
				}
			}
			else
			{
				if (length >= 4)
				{
					length -= 4;
					ref T reference9 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference9;
						reference9 = ref val;
					}
					if (reference9.Equals(Unsafe.Add(ref searchSpace, length + 3)))
					{
						goto IL_02fd;
					}
					ref T reference10 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference10;
						reference10 = ref val;
					}
					if (reference10.Equals(Unsafe.Add(ref searchSpace, length + 2)))
					{
						goto IL_02f9;
					}
					ref T reference11 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference11;
						reference11 = ref val;
					}
					if (reference11.Equals(Unsafe.Add(ref searchSpace, length + 1)))
					{
						goto IL_02f5;
					}
					ref T reference12 = ref value;
					val = default(T);
					if (val == null)
					{
						val = reference12;
						reference12 = ref val;
					}
					if (reference12.Equals(Unsafe.Add(ref searchSpace, length)))
					{
						goto IL_02f3;
					}
				}
				ref T reference13;
				do
				{
					if (length > 0)
					{
						length--;
						reference13 = ref value;
						val = default(T);
						if (val == null)
						{
							val = reference13;
							reference13 = ref val;
						}
						continue;
					}
					return -1;
				}
				while (!reference13.Equals(Unsafe.Add(ref searchSpace, length)));
			}
			goto IL_02f3;
			IL_02f5:
			return length + 1;
			IL_02f9:
			return length + 2;
			IL_02fd:
			return length + 3;
			IL_02f3:
			return length;
		}
		return length + 7;
	}

	public static int LastIndexOfAny<T>(ref T searchSpace, T value0, T value1, int length) where T : IEquatable<T>
	{
		while (true)
		{
			if (length >= 8)
			{
				length -= 8;
				T other = Unsafe.Add(ref searchSpace, length + 7);
				if (value0.Equals(other) || value1.Equals(other))
				{
					break;
				}
				other = Unsafe.Add(ref searchSpace, length + 6);
				if (value0.Equals(other) || value1.Equals(other))
				{
					return length + 6;
				}
				other = Unsafe.Add(ref searchSpace, length + 5);
				if (value0.Equals(other) || value1.Equals(other))
				{
					return length + 5;
				}
				other = Unsafe.Add(ref searchSpace, length + 4);
				if (value0.Equals(other) || value1.Equals(other))
				{
					return length + 4;
				}
				other = Unsafe.Add(ref searchSpace, length + 3);
				if (value0.Equals(other) || value1.Equals(other))
				{
					goto IL_02cd;
				}
				other = Unsafe.Add(ref searchSpace, length + 2);
				if (value0.Equals(other) || value1.Equals(other))
				{
					goto IL_02c9;
				}
				other = Unsafe.Add(ref searchSpace, length + 1);
				if (value0.Equals(other) || value1.Equals(other))
				{
					goto IL_02c5;
				}
				other = Unsafe.Add(ref searchSpace, length);
				if (!value0.Equals(other) && !value1.Equals(other))
				{
					continue;
				}
			}
			else
			{
				T other;
				if (length >= 4)
				{
					length -= 4;
					other = Unsafe.Add(ref searchSpace, length + 3);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02cd;
					}
					other = Unsafe.Add(ref searchSpace, length + 2);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c9;
					}
					other = Unsafe.Add(ref searchSpace, length + 1);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c5;
					}
					other = Unsafe.Add(ref searchSpace, length);
					if (value0.Equals(other) || value1.Equals(other))
					{
						goto IL_02c3;
					}
				}
				do
				{
					if (length > 0)
					{
						length--;
						other = Unsafe.Add(ref searchSpace, length);
						continue;
					}
					return -1;
				}
				while (!value0.Equals(other) && !value1.Equals(other));
			}
			goto IL_02c3;
			IL_02c9:
			return length + 2;
			IL_02c5:
			return length + 1;
			IL_02c3:
			return length;
			IL_02cd:
			return length + 3;
		}
		return length + 7;
	}

	public static int LastIndexOfAny<T>(ref T searchSpace, T value0, T value1, T value2, int length) where T : IEquatable<T>
	{
		while (true)
		{
			if (length >= 8)
			{
				length -= 8;
				T other = Unsafe.Add(ref searchSpace, length + 7);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					break;
				}
				other = Unsafe.Add(ref searchSpace, length + 6);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					return length + 6;
				}
				other = Unsafe.Add(ref searchSpace, length + 5);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					return length + 5;
				}
				other = Unsafe.Add(ref searchSpace, length + 4);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					return length + 4;
				}
				other = Unsafe.Add(ref searchSpace, length + 3);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					goto IL_03da;
				}
				other = Unsafe.Add(ref searchSpace, length + 2);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					goto IL_03d5;
				}
				other = Unsafe.Add(ref searchSpace, length + 1);
				if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
				{
					goto IL_03d0;
				}
				other = Unsafe.Add(ref searchSpace, length);
				if (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other))
				{
					continue;
				}
			}
			else
			{
				T other;
				if (length >= 4)
				{
					length -= 4;
					other = Unsafe.Add(ref searchSpace, length + 3);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03da;
					}
					other = Unsafe.Add(ref searchSpace, length + 2);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03d5;
					}
					other = Unsafe.Add(ref searchSpace, length + 1);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03d0;
					}
					other = Unsafe.Add(ref searchSpace, length);
					if (value0.Equals(other) || value1.Equals(other) || value2.Equals(other))
					{
						goto IL_03cd;
					}
				}
				do
				{
					if (length > 0)
					{
						length--;
						other = Unsafe.Add(ref searchSpace, length);
						continue;
					}
					return -1;
				}
				while (!value0.Equals(other) && !value1.Equals(other) && !value2.Equals(other));
			}
			goto IL_03cd;
			IL_03d0:
			return length + 1;
			IL_03d5:
			return length + 2;
			IL_03da:
			return length + 3;
			IL_03cd:
			return length;
		}
		return length + 7;
	}

	public static int LastIndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength) where T : IEquatable<T>
	{
		if (valueLength == 0)
		{
			return 0;
		}
		int num = -1;
		for (int i = 0; i < valueLength; i++)
		{
			int num2 = LastIndexOf(ref searchSpace, Unsafe.Add(ref value, i), searchSpaceLength);
			if (num2 > num)
			{
				num = num2;
			}
		}
		return num;
	}

	public static bool SequenceEqual<T>(ref T first, ref T second, int length) where T : IEquatable<T>
	{
		if (!Unsafe.AreSame(ref first, ref second))
		{
			nuint num = 0u;
			while (true)
			{
				T val;
				if (length >= 8)
				{
					length -= 8;
					ref T reference = ref Unsafe.Add(ref first, num);
					val = default(T);
					if (val == null)
					{
						val = reference;
						reference = ref val;
					}
					if (reference.Equals(Unsafe.Add(ref second, num)))
					{
						ref T reference2 = ref Unsafe.Add(ref first, num + 1);
						val = default(T);
						if (val == null)
						{
							val = reference2;
							reference2 = ref val;
						}
						if (reference2.Equals(Unsafe.Add(ref second, num + 1)))
						{
							ref T reference3 = ref Unsafe.Add(ref first, num + 2);
							val = default(T);
							if (val == null)
							{
								val = reference3;
								reference3 = ref val;
							}
							if (reference3.Equals(Unsafe.Add(ref second, num + 2)))
							{
								ref T reference4 = ref Unsafe.Add(ref first, num + 3);
								val = default(T);
								if (val == null)
								{
									val = reference4;
									reference4 = ref val;
								}
								if (reference4.Equals(Unsafe.Add(ref second, num + 3)))
								{
									ref T reference5 = ref Unsafe.Add(ref first, num + 4);
									val = default(T);
									if (val == null)
									{
										val = reference5;
										reference5 = ref val;
									}
									if (reference5.Equals(Unsafe.Add(ref second, num + 4)))
									{
										ref T reference6 = ref Unsafe.Add(ref first, num + 5);
										val = default(T);
										if (val == null)
										{
											val = reference6;
											reference6 = ref val;
										}
										if (reference6.Equals(Unsafe.Add(ref second, num + 5)))
										{
											ref T reference7 = ref Unsafe.Add(ref first, num + 6);
											val = default(T);
											if (val == null)
											{
												val = reference7;
												reference7 = ref val;
											}
											if (reference7.Equals(Unsafe.Add(ref second, num + 6)))
											{
												ref T reference8 = ref Unsafe.Add(ref first, num + 7);
												val = default(T);
												if (val == null)
												{
													val = reference8;
													reference8 = ref val;
												}
												if (reference8.Equals(Unsafe.Add(ref second, num + 7)))
												{
													num += 8;
													continue;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					if (length < 4)
					{
						goto IL_0377;
					}
					length -= 4;
					ref T reference9 = ref Unsafe.Add(ref first, num);
					val = default(T);
					if (val == null)
					{
						val = reference9;
						reference9 = ref val;
					}
					if (reference9.Equals(Unsafe.Add(ref second, num)))
					{
						ref T reference10 = ref Unsafe.Add(ref first, num + 1);
						val = default(T);
						if (val == null)
						{
							val = reference10;
							reference10 = ref val;
						}
						if (reference10.Equals(Unsafe.Add(ref second, num + 1)))
						{
							ref T reference11 = ref Unsafe.Add(ref first, num + 2);
							val = default(T);
							if (val == null)
							{
								val = reference11;
								reference11 = ref val;
							}
							if (reference11.Equals(Unsafe.Add(ref second, num + 2)))
							{
								ref T reference12 = ref Unsafe.Add(ref first, num + 3);
								val = default(T);
								if (val == null)
								{
									val = reference12;
									reference12 = ref val;
								}
								if (reference12.Equals(Unsafe.Add(ref second, num + 3)))
								{
									num += 4;
									goto IL_0377;
								}
							}
						}
					}
				}
				goto IL_037d;
				IL_0377:
				while (length > 0)
				{
					ref T reference13 = ref Unsafe.Add(ref first, num);
					val = default(T);
					if (val == null)
					{
						val = reference13;
						reference13 = ref val;
					}
					if (reference13.Equals(Unsafe.Add(ref second, num)))
					{
						num++;
						length--;
						continue;
					}
					goto IL_037d;
				}
				break;
				IL_037d:
				return false;
			}
		}
		return true;
	}

	public static int SequenceCompareTo<T>(ref T first, int firstLength, ref T second, int secondLength) where T : IComparable<T>
	{
		int num = firstLength;
		if (num > secondLength)
		{
			num = secondLength;
		}
		for (int i = 0; i < num; i++)
		{
			ref T reference = ref Unsafe.Add(ref first, i);
			T val = default(T);
			if (val == null)
			{
				val = reference;
				reference = ref val;
			}
			int num2 = reference.CompareTo(Unsafe.Add(ref second, i));
			if (num2 != 0)
			{
				return num2;
			}
		}
		return firstLength.CompareTo(secondLength);
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal struct ComparerComparable<T, TComparer> : IComparable<T> where TComparer : IComparer<T>
{
	private readonly T _value;

	private readonly TComparer _comparer;

	public ComparerComparable(T value, TComparer comparer)
	{
		_value = value;
		_comparer = comparer;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int CompareTo(T? other)
	{
		return _comparer.Compare(_value, other);
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 64)]
private struct Reg64
{
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 32)]
private struct Reg32
{
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 16)]
private struct Reg16
{
}


using System.Runtime.CompilerServices;

public static class PerTypeValues<T>
{
	public static readonly bool IsReferenceOrContainsReferences = IsReferenceOrContainsReferencesCore(typeof(T));

	public static readonly T[] EmptyArray = ArrayEx.Empty<T>();

	public static readonly IntPtr ArrayAdjustment = MeasureArrayAdjustment();

	private static IntPtr MeasureArrayAdjustment()
	{
		T[] array = new T[1];
		return Unsafe.ByteOffset(ref Unsafe.As<Pinnable<T>>(array).Data, ref array[0]);
	}
}


using System;

internal static class StringComparerEx
{
	public static StringComparer FromComparison(StringComparison comparisonType)
	{
		return comparisonType switch
		{
			StringComparison.CurrentCulture => StringComparer.CurrentCulture, 
			StringComparison.CurrentCultureIgnoreCase => StringComparer.CurrentCultureIgnoreCase, 
			StringComparison.InvariantCulture => StringComparer.InvariantCulture, 
			StringComparison.InvariantCultureIgnoreCase => StringComparer.InvariantCultureIgnoreCase, 
			StringComparison.Ordinal => StringComparer.Ordinal, 
			StringComparison.OrdinalIgnoreCase => StringComparer.OrdinalIgnoreCase, 
			_ => throw new ArgumentException("Invalid StringComparison value", "comparisonType"), 
		};
	}
}


using System;
using System.Runtime.CompilerServices;

internal static class StringExtensions
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static string Replace(this string self, string oldValue, string newValue, StringComparison comparison)
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, System.ExceptionArgument.self);
		System.ThrowHelper.ThrowIfArgumentNull(oldValue, System.ExceptionArgument.oldValue);
		System.ThrowHelper.ThrowIfArgumentNull(newValue, System.ExceptionArgument.newValue);
		DefaultInterpolatedStringHandler defaultInterpolatedStringHandler = new DefaultInterpolatedStringHandler(oldValue.Length, 0);
		ReadOnlySpan<char> readOnlySpan = MemoryExtensions.AsSpan(self);
		ReadOnlySpan<char> value = MemoryExtensions.AsSpan(oldValue);
		while (true)
		{
			int num = readOnlySpan.IndexOf(value, comparison);
			if (num < 0)
			{
				break;
			}
			defaultInterpolatedStringHandler.AppendFormatted(readOnlySpan.Slice(0, num));
			defaultInterpolatedStringHandler.AppendLiteral(newValue);
			readOnlySpan = readOnlySpan.Slice(num + value.Length);
		}
		defaultInterpolatedStringHandler.AppendFormatted(readOnlySpan);
		return defaultInterpolatedStringHandler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Contains(this string self, string value, StringComparison comparison)
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, System.ExceptionArgument.self);
		System.ThrowHelper.ThrowIfArgumentNull(value, System.ExceptionArgument.value);
		return self.IndexOf(value, comparison) >= 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Contains(this string self, char value, StringComparison comparison)
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, System.ExceptionArgument.self);
		return IndexOf(self, value, comparison) >= 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetHashCode(this string self, StringComparison comparison)
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, System.ExceptionArgument.self);
		return StringComparerEx.FromComparison(comparison).GetHashCode(self);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int IndexOf(this string self, char value, StringComparison comparison)
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, System.ExceptionArgument.self);
		return self.IndexOf(new string(value, 1), comparison);
	}
}


using System;
using System.Buffers;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

internal static class ThrowHelper
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static void ThrowIfArgumentNull([<22576685-8ec8-4022-94e7-b5a630de7c65>NotNull] object? obj, System.ExceptionArgument argument)
	{
		if (obj == null)
		{
			ThrowArgumentNullException(argument);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static void ThrowIfArgumentNull([<22576685-8ec8-4022-94e7-b5a630de7c65>NotNull] object? obj, string argument, string? message = null)
	{
		if (obj == null)
		{
			ThrowArgumentNullException(argument, message);
		}
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentNullException(System.ExceptionArgument argument)
	{
		throw CreateArgumentNullException(argument);
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentNullException(string argument, string? message = null)
	{
		throw CreateArgumentNullException(argument, message);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentNullException(System.ExceptionArgument argument)
	{
		return CreateArgumentNullException(argument.ToString());
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentNullException(string argument, string? message = null)
	{
		return new ArgumentNullException(argument, message);
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArrayTypeMismatchException()
	{
		throw CreateArrayTypeMismatchException();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArrayTypeMismatchException()
	{
		return new ArrayTypeMismatchException();
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type)
	{
		throw CreateArgumentException_InvalidTypeWithPointersNotSupported(type);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type)
	{
		return new ArgumentException($"Type {type} with managed pointers cannot be used in a Span");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentException_DestinationTooShort()
	{
		throw CreateArgumentException_DestinationTooShort();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentException_DestinationTooShort()
	{
		return new ArgumentException("Destination too short");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentException(string message, string? argument = null)
	{
		throw CreateArgumentException(message, argument);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentException(string message, string? argument)
	{
		return new ArgumentException(message, argument ?? "");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowIndexOutOfRangeException()
	{
		throw CreateIndexOutOfRangeException();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateIndexOutOfRangeException()
	{
		return new IndexOutOfRangeException();
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException()
	{
		throw CreateArgumentOutOfRangeException();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentOutOfRangeException()
	{
		return new ArgumentOutOfRangeException();
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException(System.ExceptionArgument argument)
	{
		throw CreateArgumentOutOfRangeException(argument);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentOutOfRangeException(System.ExceptionArgument argument)
	{
		return new ArgumentOutOfRangeException(argument.ToString());
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge()
	{
		throw CreateArgumentOutOfRangeException_PrecisionTooLarge();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentOutOfRangeException_PrecisionTooLarge()
	{
		return new ArgumentOutOfRangeException("precision", $"Precision too large (max: {99})");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit()
	{
		throw CreateArgumentOutOfRangeException_SymbolDoesNotFit();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit()
	{
		return new ArgumentOutOfRangeException("symbol", "Bad format specifier");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowInvalidOperationException()
	{
		throw CreateInvalidOperationException();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateInvalidOperationException()
	{
		return new InvalidOperationException();
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowInvalidOperationException_OutstandingReferences()
	{
		throw CreateInvalidOperationException_OutstandingReferences();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateInvalidOperationException_OutstandingReferences()
	{
		return new InvalidOperationException("Outstanding references");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowInvalidOperationException_UnexpectedSegmentType()
	{
		throw CreateInvalidOperationException_UnexpectedSegmentType();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateInvalidOperationException_UnexpectedSegmentType()
	{
		return new InvalidOperationException("Unexpected segment type");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowInvalidOperationException_EndPositionNotReached()
	{
		throw CreateInvalidOperationException_EndPositionNotReached();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateInvalidOperationException_EndPositionNotReached()
	{
		return new InvalidOperationException("End position not reached");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_PositionOutOfRange()
	{
		throw CreateArgumentOutOfRangeException_PositionOutOfRange();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentOutOfRangeException_PositionOutOfRange()
	{
		return new ArgumentOutOfRangeException("position");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_OffsetOutOfRange()
	{
		throw CreateArgumentOutOfRangeException_OffsetOutOfRange();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentOutOfRangeException_OffsetOutOfRange()
	{
		return new ArgumentOutOfRangeException("offset");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowObjectDisposedException_ArrayMemoryPoolBuffer()
	{
		throw CreateObjectDisposedException_ArrayMemoryPoolBuffer();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer()
	{
		return new ObjectDisposedException("ArrayMemoryPoolBuffer");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowFormatException_BadFormatSpecifier()
	{
		throw CreateFormatException_BadFormatSpecifier();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateFormatException_BadFormatSpecifier()
	{
		return new FormatException("Bad format specifier");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentException_OverlapAlignmentMismatch()
	{
		throw CreateArgumentException_OverlapAlignmentMismatch();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateArgumentException_OverlapAlignmentMismatch()
	{
		return new ArgumentException("Overlap alignment mismatch");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowNotSupportedException(string? msg = null)
	{
		throw CreateThrowNotSupportedException(msg);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateThrowNotSupportedException(string? msg)
	{
		return new NotSupportedException();
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowKeyNullException()
	{
		ThrowArgumentNullException(System.ExceptionArgument.key);
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowValueNullException()
	{
		throw CreateThrowValueNullException();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateThrowValueNullException()
	{
		return new ArgumentException("Value is null");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowOutOfMemoryException()
	{
		throw CreateOutOfMemoryException();
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static Exception CreateOutOfMemoryException()
	{
		return new OutOfMemoryException();
	}

	public static bool TryFormatThrowFormatException(out int bytesWritten)
	{
		bytesWritten = 0;
		ThrowFormatException_BadFormatSpecifier();
		return false;
	}

	public static bool TryParseThrowFormatException<T>(out T value, out int bytesConsumed)
	{
		value = default(T);
		bytesConsumed = 0;
		ThrowFormatException_BadFormatSpecifier();
		return false;
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	public static void ThrowArgumentValidationException<T>(ReadOnlySequenceSegment<T>? startSegment, int startIndex, ReadOnlySequenceSegment<T>? endSegment)
	{
		throw CreateArgumentValidationException(startSegment, startIndex, endSegment);
	}

	private static Exception CreateArgumentValidationException<T>(ReadOnlySequenceSegment<T>? startSegment, int startIndex, ReadOnlySequenceSegment<T>? endSegment)
	{
		if (startSegment == null)
		{
			return CreateArgumentNullException(System.ExceptionArgument.startSegment);
		}
		if (endSegment == null)
		{
			return CreateArgumentNullException(System.ExceptionArgument.endSegment);
		}
		if (startSegment != endSegment && startSegment.RunningIndex > endSegment.RunningIndex)
		{
			return CreateArgumentOutOfRangeException(System.ExceptionArgument.endSegment);
		}
		if ((uint)startSegment.Memory.Length < (uint)startIndex)
		{
			return CreateArgumentOutOfRangeException(System.ExceptionArgument.startIndex);
		}
		return CreateArgumentOutOfRangeException(System.ExceptionArgument.endIndex);
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	public static void ThrowArgumentValidationException(Array? array, int start)
	{
		throw CreateArgumentValidationException(array, start);
	}

	private static Exception CreateArgumentValidationException(Array? array, int start)
	{
		if (array == null)
		{
			return CreateArgumentNullException(System.ExceptionArgument.array);
		}
		if ((uint)start > (uint)array.Length)
		{
			return CreateArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return CreateArgumentOutOfRangeException(System.ExceptionArgument.length);
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	internal static void ThrowArgumentException_TupleIncorrectType(object other)
	{
		throw new ArgumentException($"Value tuple of incorrect type (found {other.GetType()})", "other");
	}

	[<22576685-8ec8-4022-94e7-b5a630de7c65>DoesNotReturn]
	public static void ThrowStartOrEndArgumentValidationException(long start)
	{
		throw CreateStartOrEndArgumentValidationException(start);
	}

	private static Exception CreateStartOrEndArgumentValidationException(long start)
	{
		if (start < 0)
		{
			return CreateArgumentOutOfRangeException(System.ExceptionArgument.start);
		}
		return CreateArgumentOutOfRangeException(System.ExceptionArgument.length);
	}
}


internal enum ExceptionArgument
{
	length,
	start,
	bufferSize,
	minimumBufferSize,
	elementIndex,
	comparable,
	comparer,
	destination,
	offset,
	startSegment,
	endSegment,
	startIndex,
	endIndex,
	array,
	culture,
	manager,
	key,
	collection,
	index,
	type,
	self,
	value,
	oldValue,
	newValue
}


using System;

internal static class TypeExtensions
{
	public static bool IsByRefLike(this Type type)
	{
		System.ThrowHelper.ThrowIfArgumentNull(type, System.ExceptionArgument.type);
		if ((object)type == null)
		{
			System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.type);
		}
		object[] customAttributes = type.GetCustomAttributes(inherit: false);
		for (int i = 0; i < customAttributes.Length; i++)
		{
			if (customAttributes[i].GetType().FullName == "System.Runtime.CompilerServices.IsByRefLikeAttribute")
			{
				return true;
			}
		}
		return false;
	}
}


using System.Runtime.CompilerServices;
using System.Threading;

internal static class MonitorEx
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Enter(object obj, ref bool lockTaken)
	{
		Monitor.Enter(obj, ref lockTaken);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Text;

internal static class StringBuilderExtensions
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static StringBuilder Clear(this StringBuilder builder)
	{
		System.ThrowHelper.ThrowIfArgumentNull(builder, "builder");
		return builder.Clear();
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class BitOperations
{
	private static ReadOnlySpan<byte> TrailingZeroCountDeBruijn => new byte[32]
	{
		0, 1, 28, 2, 29, 14, 24, 3, 30, 22,
		20, 15, 25, 17, 4, 8, 31, 27, 13, 23,
		21, 19, 16, 7, 26, 12, 18, 6, 11, 5,
		10, 9
	};

	private static ReadOnlySpan<byte> Log2DeBruijn => new byte[32]
	{
		0, 9, 1, 10, 13, 21, 2, 29, 11, 14,
		16, 18, 22, 25, 3, 30, 8, 12, 20, 28,
		15, 17, 24, 7, 19, 27, 23, 6, 26, 5,
		4, 31
	};

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int LeadingZeroCount(uint value)
	{
		if (value == 0)
		{
			return 32;
		}
		return 0x1F ^ Log2SoftwareFallback(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int LeadingZeroCount(ulong value)
	{
		uint num = (uint)(value >> 32);
		if (num == 0)
		{
			return 32 + LeadingZeroCount((uint)value);
		}
		return LeadingZeroCount(num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int Log2(uint value)
	{
		value |= 1;
		return Log2SoftwareFallback(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int Log2(ulong value)
	{
		value |= 1;
		uint num = (uint)(value >> 32);
		if (num == 0)
		{
			return Log2((uint)value);
		}
		return 32 + Log2(num);
	}

	private static int Log2SoftwareFallback(uint value)
	{
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return Unsafe.AddByteOffset(ref MemoryMarshal.GetReference(Log2DeBruijn), (IntPtr)(int)(value * 130329821 >> 27));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int Log2Ceiling(uint value)
	{
		int num = Log2(value);
		if (PopCount(value) != 1)
		{
			num++;
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int Log2Ceiling(ulong value)
	{
		int num = Log2(value);
		if (PopCount(value) != 1)
		{
			num++;
		}
		return num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int PopCount(uint value)
	{
		return SoftwareFallback(value);
		static int SoftwareFallback(uint value)
		{
			value -= (value >> 1) & 0x55555555;
			value = (value & 0x33333333) + ((value >> 2) & 0x33333333);
			value = ((value + (value >> 4)) & 0xF0F0F0F) * 16843009 >> 24;
			return (int)value;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int PopCount(ulong value)
	{
		if (IntPtr.Size == 8)
		{
			return PopCount((uint)value) + PopCount((uint)(value >> 32));
		}
		return SoftwareFallback(value);
		static int SoftwareFallback(ulong value)
		{
			value -= (value >> 1) & 0x5555555555555555L;
			value = (value & 0x3333333333333333L) + ((value >> 2) & 0x3333333333333333L);
			value = ((value + (value >> 4)) & 0xF0F0F0F0F0F0F0FL) * 72340172838076673L >> 56;
			return (int)value;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int TrailingZeroCount(int value)
	{
		return TrailingZeroCount((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int TrailingZeroCount(uint value)
	{
		if (value == 0)
		{
			return 32;
		}
		return Unsafe.AddByteOffset(ref MemoryMarshal.GetReference(TrailingZeroCountDeBruijn), (IntPtr)(int)((value & (0 - value)) * 125613361 >> 27));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int TrailingZeroCount(long value)
	{
		return TrailingZeroCount((ulong)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int TrailingZeroCount(ulong value)
	{
		uint num = (uint)value;
		if (num == 0)
		{
			return 32 + TrailingZeroCount((uint)(value >> 32));
		}
		return TrailingZeroCount(num);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint RotateLeft(uint value, int offset)
	{
		return (value << offset) | (value >> 32 - offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong RotateLeft(ulong value, int offset)
	{
		return (value << offset) | (value >> 64 - offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint RotateRight(uint value, int offset)
	{
		return (value >> offset) | (value << 32 - offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong RotateRight(ulong value, int offset)
	{
		return (value >> offset) | (value << 64 - offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static uint ResetLowestSetBit(uint value)
	{
		return value & (value - 1);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static uint ResetBit(uint value, int bitPos)
	{
		return value & (uint)(~(1 << bitPos));
	}
}


using System;
using System.Numerics;
using System.Runtime.CompilerServices;

internal static class BitOperationsEx
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsPow2(int value)
	{
		if ((value & (value - 1)) == 0)
		{
			return value > 0;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool IsPow2(uint value)
	{
		if ((value & (value - 1)) == 0)
		{
			return value != 0;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsPow2(long value)
	{
		if ((value & (value - 1)) == 0L)
		{
			return value > 0;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool IsPow2(ulong value)
	{
		if ((value & (value - 1)) == 0L)
		{
			return value != 0;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsPow2(nint value)
	{
		if ((value & (value - 1)) == 0)
		{
			return value > 0;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static bool IsPow2(nuint value)
	{
		if ((value & (value - 1)) == 0)
		{
			return value != 0;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint RoundUpToPowerOf2(uint value)
	{
		value--;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return value + 1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong RoundUpToPowerOf2(ulong value)
	{
		value--;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value |= value >> 32;
		return value + 1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static nuint RoundUpToPowerOf2(nuint value)
	{
		if (IntPtr.Size == 8)
		{
			return (nuint)RoundUpToPowerOf2((ulong)value);
		}
		return RoundUpToPowerOf2((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int LeadingZeroCount(uint value)
	{
		return BitOperations.LeadingZeroCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int LeadingZeroCount(ulong value)
	{
		return BitOperations.LeadingZeroCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int LeadingZeroCount(nuint value)
	{
		if (IntPtr.Size == 8)
		{
			return LeadingZeroCount((ulong)value);
		}
		return LeadingZeroCount((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int Log2(uint value)
	{
		return BitOperations.Log2(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int Log2(ulong value)
	{
		return BitOperations.Log2(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int Log2(nuint value)
	{
		if (IntPtr.Size == 8)
		{
			return Log2((ulong)value);
		}
		return Log2((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int PopCount(uint value)
	{
		return BitOperations.PopCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int PopCount(ulong value)
	{
		return BitOperations.PopCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int PopCount(nuint value)
	{
		if (IntPtr.Size == 8)
		{
			return PopCount((ulong)value);
		}
		return PopCount((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int TrailingZeroCount(int value)
	{
		return BitOperations.TrailingZeroCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int TrailingZeroCount(uint value)
	{
		return BitOperations.TrailingZeroCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int TrailingZeroCount(long value)
	{
		return BitOperations.TrailingZeroCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int TrailingZeroCount(ulong value)
	{
		return BitOperations.TrailingZeroCount(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int TrailingZeroCount(nint value)
	{
		if (IntPtr.Size == 8)
		{
			return TrailingZeroCount((long)value);
		}
		return TrailingZeroCount((int)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static int TrailingZeroCount(nuint value)
	{
		if (IntPtr.Size == 8)
		{
			return TrailingZeroCount((ulong)value);
		}
		return TrailingZeroCount((uint)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint RotateLeft(uint value, int offset)
	{
		return BitOperations.RotateLeft(value, offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong RotateLeft(ulong value, int offset)
	{
		return BitOperations.RotateLeft(value, offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static nuint RotateLeft(nuint value, int offset)
	{
		if (IntPtr.Size == 8)
		{
			return (nuint)RotateLeft((ulong)value, offset);
		}
		return RotateLeft((uint)value, offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static uint RotateRight(uint value, int offset)
	{
		return BitOperations.RotateRight(value, offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static ulong RotateRight(ulong value, int offset)
	{
		return BitOperations.RotateRight(value, offset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[CLSCompliant(false)]
	public static nuint RotateRight(nuint value, int offset)
	{
		if (IntPtr.Size == 8)
		{
			return (nuint)RotateRight((ulong)value, offset);
		}
		return RotateRight((uint)value, offset);
	}
}


using System;
using System.IO;

internal static class StreamExtensions
{
	public static void CopyTo(this Stream src, Stream destination)
	{
		System.ThrowHelper.ThrowIfArgumentNull(src, "src");
		src.CopyTo(destination);
	}

	public static void CopyTo(this Stream src, Stream destination, int bufferSize)
	{
		System.ThrowHelper.ThrowIfArgumentNull(src, "src");
		src.CopyTo(destination, bufferSize);
	}
}


using System;
using System.Runtime.CompilerServices;

internal static class HashHelpers
{
	public const uint HashCollisionThreshold = 100u;

	public const int MaxPrimeArrayLength = 2147483587;

	public const int HashPrime = 101;

	private static readonly int[] s_primes = new int[72]
	{
		3, 7, 11, 17, 23, 29, 37, 47, 59, 71,
		89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
		631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371,
		4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591, 17519, 21023,
		25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363,
		156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403,
		968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559,
		5999471, 7199369
	};

	public static bool IsPrime(int candidate)
	{
		if ((candidate & 1) != 0)
		{
			int num = (int)Math.Sqrt(candidate);
			for (int i = 3; i <= num; i += 2)
			{
				if (candidate % i == 0)
				{
					return false;
				}
			}
			return true;
		}
		return candidate == 2;
	}

	public static int GetPrime(int min)
	{
		if (min < 0)
		{
			throw new ArgumentException("Prime minimum cannot be less than zero");
		}
		int[] array = s_primes;
		foreach (int num in array)
		{
			if (num >= min)
			{
				return num;
			}
		}
		for (int j = min | 1; j < int.MaxValue; j += 2)
		{
			if (IsPrime(j) && (j - 1) % 101 != 0)
			{
				return j;
			}
		}
		return min;
	}

	public static int ExpandPrime(int oldSize)
	{
		int num = 2 * oldSize;
		if ((uint)num > 2147483587u && 2147483587 > oldSize)
		{
			return 2147483587;
		}
		return GetPrime(num);
	}

	public static ulong GetFastModMultiplier(uint divisor)
	{
		return ulong.MaxValue / (ulong)divisor + 1;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static uint FastMod(uint value, uint divisor, ulong multiplier)
	{
		return (uint)(((multiplier * value >> 32) + 1) * divisor >> 32);
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

internal static class ConcurrentExtensions
{
	public static void Clear<T>(this ConcurrentBag<T> bag)
	{
		System.ThrowHelper.ThrowIfArgumentNull(bag, "bag");
		T result;
		while (bag.TryTake(out result))
		{
		}
	}

	public static void Clear<T>(this ConcurrentQueue<T> queue)
	{
		System.ThrowHelper.ThrowIfArgumentNull(queue, "queue");
		T result;
		while (queue.TryDequeue(out result))
		{
		}
	}

	public static TValue AddOrUpdate<TKey, TValue, TArg>(this ConcurrentDictionary<TKey, TValue> dict, TKey key, Func<TKey, TArg, TValue> addValueFactory, Func<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument) where TKey : notnull
	{
		System.ThrowHelper.ThrowIfArgumentNull(dict, "dict");
		return dict.AddOrUpdate(key, (TKey k) => addValueFactory(k, factoryArgument), (TKey k, TValue v) => updateValueFactory(k, v, factoryArgument));
	}

	public static TValue GetOrAdd<TKey, TValue, TArg>(this ConcurrentDictionary<TKey, TValue> dict, TKey key, Func<TKey, TArg, TValue> valueFactory, TArg factoryArgument) where TKey : notnull
	{
		System.ThrowHelper.ThrowIfArgumentNull(dict, "dict");
		return dict.GetOrAdd(key, (TKey k) => valueFactory(k, factoryArgument));
	}

	public static bool TryRemove<TKey, TValue>(this ConcurrentDictionary<TKey, TValue> dict, KeyValuePair<TKey, TValue> item) where TKey : notnull
	{
		System.ThrowHelper.ThrowIfArgumentNull(dict, "dict");
		if (dict.TryRemove(item.Key, out TValue value))
		{
			if (EqualityComparer<TValue>.Default.Equals(item.Value, value))
			{
				return true;
			}
			dict.AddOrUpdate(item.Key, (TKey _) => value, (TKey _, TValue _) => value);
			return false;
		}
		return false;
	}
}


using System.Buffers;

internal abstract class ArrayPool<T>
{
	private static readonly TlsOverPerCoreLockedStacksArrayPool<T> s_shared = new TlsOverPerCoreLockedStacksArrayPool<T>();

	public static ArrayPool<T> Shared => s_shared;

	public static ArrayPool<T> Create()
	{
		return new System.Buffers.ConfigurableArrayPool<T>();
	}

	public static ArrayPool<T> Create(int maxArrayLength, int maxArraysPerBucket)
	{
		return new System.Buffers.ConfigurableArrayPool<T>(maxArrayLength, maxArraysPerBucket);
	}

	public abstract T[] Rent(int minimumLength);

	public abstract void Return(T[] array, bool clearArray = false);
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;

internal static class BuffersExtensions
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static SequencePosition? PositionOf<T>(this in ReadOnlySequence<T> source, T value) where T : IEquatable<T>
	{
		if (source.IsSingleSegment)
		{
			int num = source.First.Span.IndexOf(value);
			if (num != -1)
			{
				return source.GetPosition(num);
			}
			return null;
		}
		return PositionOfMultiSegment(in source, value);
	}

	private static SequencePosition? PositionOfMultiSegment<T>(in ReadOnlySequence<T> source, T value) where T : IEquatable<T>
	{
		SequencePosition position = source.Start;
		SequencePosition origin = position;
		ReadOnlyMemory<T> memory;
		while (source.TryGet(ref position, out memory))
		{
			int num = memory.Span.IndexOf(value);
			if (num != -1)
			{
				return source.GetPosition(num, origin);
			}
			if (position.GetObject() == null)
			{
				break;
			}
			origin = position;
		}
		return null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void CopyTo<T>(this in ReadOnlySequence<T> source, Span<T> destination)
	{
		if (source.Length > destination.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.destination);
		}
		if (source.IsSingleSegment)
		{
			source.First.Span.CopyTo(destination);
		}
		else
		{
			CopyToMultiSegment(in source, destination);
		}
	}

	private static void CopyToMultiSegment<T>(in ReadOnlySequence<T> sequence, Span<T> destination)
	{
		SequencePosition position = sequence.Start;
		ReadOnlyMemory<T> memory;
		while (sequence.TryGet(ref position, out memory))
		{
			ReadOnlySpan<T> span = memory.Span;
			span.CopyTo(destination);
			if (position.GetObject() != null)
			{
				destination = destination.Slice(span.Length);
				continue;
			}
			break;
		}
	}

	public static T[] ToArray<T>(this in ReadOnlySequence<T> sequence)
	{
		T[] array = new T[sequence.Length];
		CopyTo(in sequence, array);
		return array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Write<T>(this IBufferWriter<T> writer, ReadOnlySpan<T> value)
	{
		System.ThrowHelper.ThrowIfArgumentNull(writer, "writer");
		Span<T> span = writer.GetSpan();
		if (value.Length <= span.Length)
		{
			value.CopyTo(span);
			writer.Advance(value.Length);
		}
		else
		{
			WriteMultiSegment(writer, in value, span);
		}
	}

	private static void WriteMultiSegment<T>(IBufferWriter<T> writer, in ReadOnlySpan<T> source, Span<T> destination)
	{
		ReadOnlySpan<T> readOnlySpan = source;
		while (true)
		{
			int num = Math.Min(destination.Length, readOnlySpan.Length);
			readOnlySpan.Slice(0, num).CopyTo(destination);
			writer.Advance(num);
			readOnlySpan = readOnlySpan.Slice(num);
			if (readOnlySpan.Length > 0)
			{
				destination = writer.GetSpan(readOnlySpan.Length);
				continue;
			}
			break;
		}
	}
}


using System;
using System.Buffers;
using System.Diagnostics;
using System.Threading;

internal sealed class ConfigurableArrayPool<T> : ArrayPool<T>
{
	private sealed class Bucket
	{
		internal readonly int _bufferLength;

		private readonly T[]?[] _buffers;

		private readonly int _poolId;

		private SpinLock _lock;

		private int _index;

		internal int Id => GetHashCode();

		internal Bucket(int bufferLength, int numberOfBuffers, int poolId)
		{
			_lock = new SpinLock(Debugger.IsAttached);
			_buffers = new T[numberOfBuffers][];
			_bufferLength = bufferLength;
			_poolId = poolId;
		}

		internal T[]? Rent()
		{
			T[][] buffers = _buffers;
			T[] array = null;
			bool lockTaken = false;
			bool flag = false;
			try
			{
				_lock.Enter(ref lockTaken);
				if (_index < buffers.Length)
				{
					array = buffers[_index];
					buffers[_index++] = null;
					flag = array == null;
				}
			}
			finally
			{
				if (lockTaken)
				{
					_lock.Exit(useMemoryBarrier: false);
				}
			}
			if (flag)
			{
				array = new T[_bufferLength];
			}
			return array;
		}

		internal void Return(T[] array)
		{
			if (array.Length != _bufferLength)
			{
				throw new ArgumentException("Buffer not from this pool", "array");
			}
			bool lockTaken = false;
			try
			{
				_lock.Enter(ref lockTaken);
				if (_index != 0)
				{
					_buffers[--_index] = array;
				}
			}
			finally
			{
				if (lockTaken)
				{
					_lock.Exit(useMemoryBarrier: false);
				}
			}
		}
	}

	private const int DefaultMaxArrayLength = 1048576;

	private const int DefaultMaxNumberOfArraysPerBucket = 50;

	private readonly Bucket[] _buckets;

	private int Id => GetHashCode();

	internal ConfigurableArrayPool()
		: this(1048576, 50)
	{
	}

	internal ConfigurableArrayPool(int maxArrayLength, int maxArraysPerBucket)
	{
		if (maxArrayLength <= 0)
		{
			throw new ArgumentOutOfRangeException("maxArrayLength");
		}
		if (maxArraysPerBucket <= 0)
		{
			throw new ArgumentOutOfRangeException("maxArraysPerBucket");
		}
		if (maxArrayLength > 1073741824)
		{
			maxArrayLength = 1073741824;
		}
		else if (maxArrayLength < 16)
		{
			maxArrayLength = 16;
		}
		int id = Id;
		Bucket[] array = new Bucket[System.Buffers.Utilities.SelectBucketIndex(maxArrayLength) + 1];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = new Bucket(System.Buffers.Utilities.GetMaxSizeForBucket(i), maxArraysPerBucket, id);
		}
		_buckets = array;
	}

	public override T[] Rent(int minimumLength)
	{
		if (minimumLength < 0)
		{
			throw new ArgumentOutOfRangeException("minimumLength");
		}
		if (minimumLength == 0)
		{
			return ArrayEx.Empty<T>();
		}
		int num = System.Buffers.Utilities.SelectBucketIndex(minimumLength);
		if (num < _buckets.Length)
		{
			int num2 = num;
			do
			{
				T[] array = _buckets[num2].Rent();
				if (array != null)
				{
					return array;
				}
			}
			while (++num2 < _buckets.Length && num2 != num + 2);
			return new T[_buckets[num]._bufferLength];
		}
		return new T[minimumLength];
	}

	public override void Return(T[] array, bool clearArray = false)
	{
		if (array == null)
		{
			throw new ArgumentNullException("array");
		}
		if (array.Length == 0)
		{
			return;
		}
		int num = System.Buffers.Utilities.SelectBucketIndex(array.Length);
		if (num < _buckets.Length)
		{
			if (clearArray)
			{
				Array.Clear(array, 0, array.Length);
			}
			_buckets[num].Return(array);
		}
	}
}


using System.Diagnostics;
using System.Threading;

private sealed class Bucket
{
	internal readonly int _bufferLength;

	private readonly T[]?[] _buffers;

	private readonly int _poolId;

	private SpinLock _lock;

	private int _index;

	internal int Id => GetHashCode();

	internal Bucket(int bufferLength, int numberOfBuffers, int poolId)
	{
		_lock = new SpinLock(Debugger.IsAttached);
		_buffers = new T[numberOfBuffers][];
		_bufferLength = bufferLength;
		_poolId = poolId;
	}

	internal T[]? Rent()
	{
		T[][] buffers = _buffers;
		T[] array = null;
		bool lockTaken = false;
		bool flag = false;
		try
		{
			_lock.Enter(ref lockTaken);
			if (_index < buffers.Length)
			{
				array = buffers[_index];
				buffers[_index++] = null;
				flag = array == null;
			}
		}
		finally
		{
			if (lockTaken)
			{
				_lock.Exit(useMemoryBarrier: false);
			}
		}
		if (flag)
		{
			array = new T[_bufferLength];
		}
		return array;
	}

	internal void Return(T[] array)
	{
		if (array.Length != _bufferLength)
		{
			throw new ArgumentException("Buffer not from this pool", "array");
		}
		bool lockTaken = false;
		try
		{
			_lock.Enter(ref lockTaken);
			if (_index != 0)
			{
				_buffers[--_index] = array;
			}
		}
		finally
		{
			if (lockTaken)
			{
				_lock.Exit(useMemoryBarrier: false);
			}
		}
	}
}


using System;

internal interface IBufferWriter<T>
{
	void Advance(int count);

	Memory<T> GetMemory(int sizeHint = 0);

	Span<T> GetSpan(int sizeHint = 0);
}


using System;

internal interface IMemoryOwner<T> : IDisposable
{
	Memory<T> Memory { get; }
}


using System.Buffers;

internal interface IPinnable
{
	MemoryHandle Pin(int elementIndex);

	void Unpin();
}


using System;
using System.Buffers;
using System.Runtime.InteropServices;

internal struct MemoryHandle : IDisposable
{
	private unsafe void* _pointer;

	private GCHandle _handle;

	private IPinnable? _pinnable;

	[CLSCompliant(false)]
	public unsafe void* Pointer => _pointer;

	[CLSCompliant(false)]
	public unsafe MemoryHandle(void* pointer, GCHandle handle = default(GCHandle), IPinnable? pinnable = null)
	{
		_pointer = pointer;
		_handle = handle;
		_pinnable = pinnable;
	}

	public unsafe void Dispose()
	{
		if (_handle.IsAllocated)
		{
			_handle.Free();
		}
		if (_pinnable != null)
		{
			_pinnable.Unpin();
			_pinnable = null;
		}
		_pointer = null;
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;

internal abstract class MemoryManager<T> : IMemoryOwner<T>, IDisposable, IPinnable
{
	public virtual Memory<T> Memory => new Memory<T>(this, GetSpan().Length);

	public abstract Span<T> GetSpan();

	public abstract MemoryHandle Pin(int elementIndex = 0);

	public abstract void Unpin();

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected Memory<T> CreateMemory(int length)
	{
		return new Memory<T>(this, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	protected Memory<T> CreateMemory(int start, int length)
	{
		return new Memory<T>(this, start, length);
	}

	protected internal virtual bool TryGetArray(out ArraySegment<T> segment)
	{
		segment = default(ArraySegment<T>);
		return false;
	}

	void IDisposable.Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	protected abstract void Dispose(bool disposing);
}


using System;
using System.Buffers;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[DebuggerTypeProxy(typeof(System.Buffers.ReadOnlySequenceDebugView<>))]
[DebuggerDisplay("{ToString(),raw}")]
internal readonly struct ReadOnlySequence<T>
{
	public struct Enumerator
	{
		private readonly ReadOnlySequence<T> _sequence;

		private SequencePosition _next;

		private ReadOnlyMemory<T> _currentMemory;

		public ReadOnlyMemory<T> Current => _currentMemory;

		public Enumerator(in ReadOnlySequence<T> sequence)
		{
			_currentMemory = default(ReadOnlyMemory<T>);
			_next = sequence.Start;
			_sequence = sequence;
		}

		public bool MoveNext()
		{
			if (_next.GetObject() == null)
			{
				return false;
			}
			return _sequence.TryGet(ref _next, out _currentMemory);
		}
	}

	private enum SequenceType
	{
		MultiSegment,
		Array,
		MemoryManager,
		String,
		Empty
	}

	private readonly SequencePosition _sequenceStart;

	private readonly SequencePosition _sequenceEnd;

	public static readonly ReadOnlySequence<T> Empty = new ReadOnlySequence<T>(System.SpanHelpers.PerTypeValues<T>.EmptyArray);

	public long Length => GetLength();

	public bool IsEmpty => Length == 0;

	public bool IsSingleSegment
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return _sequenceStart.GetObject() == _sequenceEnd.GetObject();
		}
	}

	public ReadOnlyMemory<T> First => GetFirstBuffer();

	public SequencePosition Start => _sequenceStart;

	public SequencePosition End => _sequenceEnd;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ReadOnlySequence(object? startSegment, int startIndexAndFlags, object? endSegment, int endIndexAndFlags)
	{
		_sequenceStart = new SequencePosition(startSegment, startIndexAndFlags);
		_sequenceEnd = new SequencePosition(endSegment, endIndexAndFlags);
	}

	public ReadOnlySequence(ReadOnlySequenceSegment<T> startSegment, int startIndex, ReadOnlySequenceSegment<T> endSegment, int endIndex)
	{
		if (startSegment == null || endSegment == null || (startSegment != endSegment && startSegment.RunningIndex > endSegment.RunningIndex) || (uint)startSegment.Memory.Length < (uint)startIndex || (uint)endSegment.Memory.Length < (uint)endIndex || (startSegment == endSegment && endIndex < startIndex))
		{
			System.ThrowHelper.ThrowArgumentValidationException(startSegment, startIndex, endSegment);
		}
		_sequenceStart = new SequencePosition(startSegment, System.Buffers.ReadOnlySequence.SegmentToSequenceStart(startIndex));
		_sequenceEnd = new SequencePosition(endSegment, System.Buffers.ReadOnlySequence.SegmentToSequenceEnd(endIndex));
	}

	public ReadOnlySequence(T[] array)
	{
		System.ThrowHelper.ThrowIfArgumentNull(array, System.ExceptionArgument.array);
		_sequenceStart = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceStart(0));
		_sequenceEnd = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceEnd(array.Length));
	}

	public ReadOnlySequence(T[] array, int start, int length)
	{
		if (array == null || (uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			System.ThrowHelper.ThrowArgumentValidationException(array, start);
		}
		_sequenceStart = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceStart(start));
		_sequenceEnd = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceEnd(start + length));
	}

	public ReadOnlySequence(ReadOnlyMemory<T> memory)
	{
		ArraySegment<T> segment;
		if (MemoryMarshal.TryGetMemoryManager<T, MemoryManager<T>>(memory, out MemoryManager<T> manager, out int start, out int length))
		{
			_sequenceStart = new SequencePosition(manager, System.Buffers.ReadOnlySequence.MemoryManagerToSequenceStart(start));
			_sequenceEnd = new SequencePosition(manager, System.Buffers.ReadOnlySequence.MemoryManagerToSequenceEnd(length));
		}
		else if (MemoryMarshal.TryGetArray(memory, out segment))
		{
			T[] array = segment.Array;
			int offset = segment.Offset;
			_sequenceStart = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceStart(offset));
			_sequenceEnd = new SequencePosition(array, System.Buffers.ReadOnlySequence.ArrayToSequenceEnd(offset + segment.Count));
		}
		else if (typeof(T) == typeof(char))
		{
			if (!MemoryMarshal.TryGetString(Unsafe.As<ReadOnlyMemory<T>, ReadOnlyMemory<char>>(ref memory), out string text, out int start2, out length))
			{
				System.ThrowHelper.ThrowInvalidOperationException();
			}
			_sequenceStart = new SequencePosition(text, System.Buffers.ReadOnlySequence.StringToSequenceStart(start2));
			_sequenceEnd = new SequencePosition(text, System.Buffers.ReadOnlySequence.StringToSequenceEnd(start2 + length));
		}
		else
		{
			System.ThrowHelper.ThrowInvalidOperationException();
			_sequenceStart = default(SequencePosition);
			_sequenceEnd = default(SequencePosition);
		}
	}

	public ReadOnlySequence<T> Slice(long start, long length)
	{
		if (start < 0 || length < 0)
		{
			System.ThrowHelper.ThrowStartOrEndArgumentValidationException(start);
		}
		int index = GetIndex(in _sequenceStart);
		int index2 = GetIndex(in _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		SequencePosition position;
		SequencePosition end;
		if (@object != object2)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			int num = readOnlySequenceSegment.Memory.Length - index;
			if (num > start)
			{
				index += (int)start;
				position = new SequencePosition(@object, index);
				end = GetEndPosition(readOnlySequenceSegment, @object, index, object2, index2, length);
			}
			else
			{
				if (num < 0)
				{
					System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				position = SeekMultiSegment(readOnlySequenceSegment.Next, object2, index2, start - num, System.ExceptionArgument.start);
				int index3 = GetIndex(in position);
				object object3 = position.GetObject();
				if (object3 != object2)
				{
					end = GetEndPosition((ReadOnlySequenceSegment<T>)object3, object3, index3, object2, index2, length);
				}
				else
				{
					if (index2 - index3 < length)
					{
						System.ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
					}
					end = new SequencePosition(object3, index3 + (int)length);
				}
			}
		}
		else
		{
			if (index2 - index < start)
			{
				System.ThrowHelper.ThrowStartOrEndArgumentValidationException(-1L);
			}
			index += (int)start;
			position = new SequencePosition(@object, index);
			if (index2 - index < length)
			{
				System.ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
			end = new SequencePosition(@object, index + (int)length);
		}
		return SliceImpl(in position, in end);
	}

	public ReadOnlySequence<T> Slice(long start, SequencePosition end)
	{
		if (start < 0)
		{
			System.ThrowHelper.ThrowStartOrEndArgumentValidationException(start);
		}
		uint index = (uint)GetIndex(in end);
		object @object = end.GetObject();
		uint index2 = (uint)GetIndex(in _sequenceStart);
		object object2 = _sequenceStart.GetObject();
		uint index3 = (uint)GetIndex(in _sequenceEnd);
		object object3 = _sequenceEnd.GetObject();
		if (object2 == object3)
		{
			if (!InRange(index, index2, index3))
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if (index - index2 < start)
			{
				System.ThrowHelper.ThrowStartOrEndArgumentValidationException(-1L);
			}
		}
		else
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)object2;
			ulong num = (ulong)(readOnlySequenceSegment.RunningIndex + index2);
			ulong num2 = (ulong)(((ReadOnlySequenceSegment<T>)@object).RunningIndex + index);
			if (!InRange(num2, num, (ulong)(((ReadOnlySequenceSegment<T>)object3).RunningIndex + index3)))
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if ((ulong)((long)num + start) > num2)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.start);
			}
			int num3 = readOnlySequenceSegment.Memory.Length - (int)index2;
			if (num3 <= start)
			{
				if (num3 < 0)
				{
					System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				return SliceImpl(SeekMultiSegment(readOnlySequenceSegment.Next, @object, (int)index, start - num3, System.ExceptionArgument.start), in end);
			}
		}
		return SliceImpl(new SequencePosition(object2, (int)index2 + (int)start), in end);
	}

	public ReadOnlySequence<T> Slice(SequencePosition start, long length)
	{
		uint index = (uint)GetIndex(in start);
		object @object = start.GetObject();
		uint index2 = (uint)GetIndex(in _sequenceStart);
		object object2 = _sequenceStart.GetObject();
		uint index3 = (uint)GetIndex(in _sequenceEnd);
		object object3 = _sequenceEnd.GetObject();
		if (object2 == object3)
		{
			if (!InRange(index, index2, index3))
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if (length < 0)
			{
				System.ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
			if (index3 - index < length)
			{
				System.ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
		}
		else
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			long num = readOnlySequenceSegment.RunningIndex + index;
			ulong start2 = (ulong)(((ReadOnlySequenceSegment<T>)object2).RunningIndex + index2);
			ulong num2 = (ulong)(((ReadOnlySequenceSegment<T>)object3).RunningIndex + index3);
			if (!InRange((ulong)num, start2, num2))
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			if (length < 0)
			{
				System.ThrowHelper.ThrowStartOrEndArgumentValidationException(0L);
			}
			if ((ulong)(num + length) > num2)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.length);
			}
			int num3 = readOnlySequenceSegment.Memory.Length - (int)index;
			if (num3 < length)
			{
				if (num3 < 0)
				{
					System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				return SliceImpl(in start, SeekMultiSegment(readOnlySequenceSegment.Next, object3, (int)index3, length - num3, System.ExceptionArgument.length));
			}
		}
		return SliceImpl(in start, new SequencePosition(@object, (int)index + (int)length));
	}

	public ReadOnlySequence<T> Slice(int start, int length)
	{
		return Slice((long)start, (long)length);
	}

	public ReadOnlySequence<T> Slice(int start, SequencePosition end)
	{
		return Slice((long)start, end);
	}

	public ReadOnlySequence<T> Slice(SequencePosition start, int length)
	{
		return Slice(start, (long)length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySequence<T> Slice(SequencePosition start, SequencePosition end)
	{
		BoundsCheck((uint)GetIndex(in start), start.GetObject(), (uint)GetIndex(in end), end.GetObject());
		return SliceImpl(in start, in end);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ReadOnlySequence<T> Slice(SequencePosition start)
	{
		BoundsCheck(in start);
		return SliceImpl(in start, in _sequenceEnd);
	}

	public ReadOnlySequence<T> Slice(long start)
	{
		if (start < 0)
		{
			System.ThrowHelper.ThrowStartOrEndArgumentValidationException(start);
		}
		if (start == 0L)
		{
			return this;
		}
		return SliceImpl(Seek(in _sequenceStart, in _sequenceEnd, start, System.ExceptionArgument.start), in _sequenceEnd);
	}

	public override string ToString()
	{
		if (typeof(T) == typeof(char))
		{
			ReadOnlySequence<T> source = this;
			ReadOnlySequence<char> sequence = Unsafe.As<ReadOnlySequence<T>, ReadOnlySequence<char>>(ref source);
			if (SequenceMarshal.TryGetString(sequence, out string text, out int start, out int length))
			{
				return text.Substring(start, length);
			}
			if (Length < int.MaxValue)
			{
				return new string(BuffersExtensions.ToArray(in sequence));
			}
		}
		return $"System.Buffers.ReadOnlySequence<{typeof(T).Name}>[{Length}]";
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(in this);
	}

	public SequencePosition GetPosition(long offset)
	{
		return GetPosition(offset, _sequenceStart);
	}

	public SequencePosition GetPosition(long offset, SequencePosition origin)
	{
		if (offset < 0)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_OffsetOutOfRange();
		}
		return Seek(in origin, in _sequenceEnd, offset, System.ExceptionArgument.offset);
	}

	public bool TryGet(ref SequencePosition position, out ReadOnlyMemory<T> memory, bool advance = true)
	{
		SequencePosition next;
		bool result = TryGetBuffer(in position, out memory, out next);
		if (advance)
		{
			position = next;
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool TryGetBuffer(in SequencePosition position, out ReadOnlyMemory<T> memory, out SequencePosition next)
	{
		object @object = position.GetObject();
		next = default(SequencePosition);
		if (@object == null)
		{
			memory = default(ReadOnlyMemory<T>);
			return false;
		}
		SequenceType sequenceType = GetSequenceType();
		object object2 = _sequenceEnd.GetObject();
		int index = GetIndex(in position);
		int index2 = GetIndex(in _sequenceEnd);
		if (sequenceType == SequenceType.MultiSegment)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			if (readOnlySequenceSegment != object2)
			{
				ReadOnlySequenceSegment<T> next2 = readOnlySequenceSegment.Next;
				if (next2 == null)
				{
					System.ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
				}
				next = new SequencePosition(next2, 0);
				memory = readOnlySequenceSegment.Memory.Slice(index);
			}
			else
			{
				memory = readOnlySequenceSegment.Memory.Slice(index, index2 - index);
			}
		}
		else
		{
			if (@object != object2)
			{
				System.ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
			}
			if (sequenceType == SequenceType.Array)
			{
				memory = new ReadOnlyMemory<T>((T[])@object, index, index2 - index);
			}
			else if (typeof(T) == typeof(char) && sequenceType == SequenceType.String)
			{
				memory = (ReadOnlyMemory<T>)(object)MemoryExtensions.AsMemory((string)@object, index, index2 - index);
			}
			else
			{
				memory = ((MemoryManager<T>)@object).Memory.Slice(index, index2 - index);
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ReadOnlyMemory<T> GetFirstBuffer()
	{
		object @object = _sequenceStart.GetObject();
		if (@object == null)
		{
			return default(ReadOnlyMemory<T>);
		}
		int integer = _sequenceStart.GetInteger();
		int integer2 = _sequenceEnd.GetInteger();
		bool flag = @object != _sequenceEnd.GetObject();
		if (integer >= 0)
		{
			if (integer2 >= 0)
			{
				ReadOnlyMemory<T> memory = ((ReadOnlySequenceSegment<T>)@object).Memory;
				if (flag)
				{
					return memory.Slice(integer);
				}
				return memory.Slice(integer, integer2 - integer);
			}
			if (flag)
			{
				System.ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
			}
			return new ReadOnlyMemory<T>((T[])@object, integer, (integer2 & 0x7FFFFFFF) - integer);
		}
		if (flag)
		{
			System.ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached();
		}
		if (typeof(T) == typeof(char) && integer2 < 0)
		{
			return (ReadOnlyMemory<T>)(object)MemoryExtensions.AsMemory((string)@object, integer & 0x7FFFFFFF, integer2 - integer);
		}
		integer &= 0x7FFFFFFF;
		return ((MemoryManager<T>)@object).Memory.Slice(integer, integer2 - integer);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static SequencePosition Seek(in SequencePosition start, in SequencePosition end, long offset, System.ExceptionArgument argument)
	{
		int index = GetIndex(in start);
		int index2 = GetIndex(in end);
		object @object = start.GetObject();
		object object2 = end.GetObject();
		if (@object != object2)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			int num = readOnlySequenceSegment.Memory.Length - index;
			if (num <= offset)
			{
				if (num < 0)
				{
					System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
				}
				return SeekMultiSegment(readOnlySequenceSegment.Next, object2, index2, offset - num, argument);
			}
		}
		else if (index2 - index < offset)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(argument);
		}
		return new SequencePosition(@object, index + (int)offset);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static SequencePosition SeekMultiSegment(ReadOnlySequenceSegment<T>? currentSegment, object? endObject, int endIndex, long offset, System.ExceptionArgument argument)
	{
		while (true)
		{
			if (currentSegment != null && currentSegment != endObject)
			{
				int length = currentSegment.Memory.Length;
				if (length > offset)
				{
					break;
				}
				offset -= length;
				currentSegment = currentSegment.Next;
				continue;
			}
			if (currentSegment == null || endIndex < offset)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException(argument);
			}
			break;
		}
		return new SequencePosition(currentSegment, (int)offset);
	}

	private void BoundsCheck(in SequencePosition position)
	{
		uint index = (uint)GetIndex(in position);
		uint index2 = (uint)GetIndex(in _sequenceStart);
		uint index3 = (uint)GetIndex(in _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		if (@object == object2)
		{
			if (!InRange(index, index2, index3))
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			return;
		}
		ulong start = (ulong)(((ReadOnlySequenceSegment<T>)@object).RunningIndex + index2);
		if (!InRange((ulong)(((ReadOnlySequenceSegment<T>)position.GetObject()).RunningIndex + index), start, (ulong)(((ReadOnlySequenceSegment<T>)object2).RunningIndex + index3)))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
	}

	private void BoundsCheck(uint sliceStartIndex, object? sliceStartObject, uint sliceEndIndex, object? sliceEndObject)
	{
		uint index = (uint)GetIndex(in _sequenceStart);
		uint index2 = (uint)GetIndex(in _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		if (@object == object2)
		{
			if (sliceStartObject != sliceEndObject || sliceStartObject != @object || sliceStartIndex > sliceEndIndex || sliceStartIndex < index || sliceEndIndex > index2)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
			}
			return;
		}
		long num = ((ReadOnlySequenceSegment<T>)sliceStartObject).RunningIndex + sliceStartIndex;
		ulong num2 = (ulong)(((ReadOnlySequenceSegment<T>)sliceEndObject).RunningIndex + sliceEndIndex);
		if ((ulong)num > num2)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
		if ((ulong)num < (ulong)(((ReadOnlySequenceSegment<T>)@object).RunningIndex + index) || num2 > (ulong)(((ReadOnlySequenceSegment<T>)object2).RunningIndex + index2))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
	}

	private static SequencePosition GetEndPosition(ReadOnlySequenceSegment<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length)
	{
		int num = startSegment.Memory.Length - startIndex;
		if (num > length)
		{
			return new SequencePosition(startObject, startIndex + (int)length);
		}
		if (num < 0)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_PositionOutOfRange();
		}
		return SeekMultiSegment(startSegment.Next, endObject, endIndex, length - num, System.ExceptionArgument.length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private SequenceType GetSequenceType()
	{
		return (SequenceType)(-(2 * (_sequenceStart.GetInteger() >> 31) + (_sequenceEnd.GetInteger() >> 31)));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int GetIndex(in SequencePosition position)
	{
		return position.GetInteger() & 0x7FFFFFFF;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private ReadOnlySequence<T> SliceImpl(in SequencePosition start, in SequencePosition end)
	{
		return new ReadOnlySequence<T>(start.GetObject(), GetIndex(in start) | (_sequenceStart.GetInteger() & int.MinValue), end.GetObject(), GetIndex(in end) | (_sequenceEnd.GetInteger() & int.MinValue));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private long GetLength()
	{
		int index = GetIndex(in _sequenceStart);
		int index2 = GetIndex(in _sequenceEnd);
		object @object = _sequenceStart.GetObject();
		object object2 = _sequenceEnd.GetObject();
		if (@object != object2)
		{
			ReadOnlySequenceSegment<T> readOnlySequenceSegment = (ReadOnlySequenceSegment<T>)@object;
			return ((ReadOnlySequenceSegment<T>)object2).RunningIndex + index2 - (readOnlySequenceSegment.RunningIndex + index);
		}
		return index2 - index;
	}

	internal bool TryGetReadOnlySequenceSegment(out ReadOnlySequenceSegment<T>? startSegment, out int startIndex, out ReadOnlySequenceSegment<T>? endSegment, out int endIndex)
	{
		object @object = _sequenceStart.GetObject();
		if (@object == null || GetSequenceType() != 0)
		{
			startSegment = null;
			startIndex = 0;
			endSegment = null;
			endIndex = 0;
			return false;
		}
		startSegment = (ReadOnlySequenceSegment<T>)@object;
		startIndex = GetIndex(in _sequenceStart);
		endSegment = (ReadOnlySequenceSegment<T>)_sequenceEnd.GetObject();
		endIndex = GetIndex(in _sequenceEnd);
		return true;
	}

	internal bool TryGetArray(out ArraySegment<T> segment)
	{
		if (GetSequenceType() != SequenceType.Array)
		{
			segment = default(ArraySegment<T>);
			return false;
		}
		int index = GetIndex(in _sequenceStart);
		segment = new ArraySegment<T>((T[])_sequenceStart.GetObject(), index, GetIndex(in _sequenceEnd) - index);
		return true;
	}

	internal bool TryGetString([<22576685-8ec8-4022-94e7-b5a630de7c65>MaybeNullWhen(false)] out string text, out int start, out int length)
	{
		if (typeof(T) != typeof(char) || GetSequenceType() != SequenceType.String)
		{
			start = 0;
			length = 0;
			text = null;
			return false;
		}
		start = GetIndex(in _sequenceStart);
		length = GetIndex(in _sequenceEnd) - start;
		text = (string)_sequenceStart.GetObject();
		return true;
	}

	private static bool InRange(uint value, uint start, uint end)
	{
		return value - start <= end - start;
	}

	private static bool InRange(ulong value, ulong start, ulong end)
	{
		return value - start <= end - start;
	}
}


public struct Enumerator
{
	private readonly ReadOnlySequence<T> _sequence;

	private SequencePosition _next;

	private ReadOnlyMemory<T> _currentMemory;

	public ReadOnlyMemory<T> Current => _currentMemory;

	public Enumerator(in ReadOnlySequence<T> sequence)
	{
		_currentMemory = default(ReadOnlyMemory<T>);
		_next = sequence.Start;
		_sequence = sequence;
	}

	public bool MoveNext()
	{
		if (_next.GetObject() == null)
		{
			return false;
		}
		return _sequence.TryGet(ref _next, out _currentMemory);
	}
}


private enum SequenceType
{
	MultiSegment,
	Array,
	MemoryManager,
	String,
	Empty
}


using System.Runtime.CompilerServices;

internal static class ReadOnlySequence
{
	public const int FlagBitMask = int.MinValue;

	public const int IndexBitMask = int.MaxValue;

	public const int SegmentStartMask = 0;

	public const int SegmentEndMask = 0;

	public const int ArrayStartMask = 0;

	public const int ArrayEndMask = int.MinValue;

	public const int MemoryManagerStartMask = int.MinValue;

	public const int MemoryManagerEndMask = 0;

	public const int StringStartMask = int.MinValue;

	public const int StringEndMask = int.MinValue;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int SegmentToSequenceStart(int startIndex)
	{
		return startIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int SegmentToSequenceEnd(int endIndex)
	{
		return endIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ArrayToSequenceStart(int startIndex)
	{
		return startIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int ArrayToSequenceEnd(int endIndex)
	{
		return endIndex | int.MinValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int MemoryManagerToSequenceStart(int startIndex)
	{
		return startIndex | int.MinValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int MemoryManagerToSequenceEnd(int endIndex)
	{
		return endIndex | 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int StringToSequenceStart(int startIndex)
	{
		return startIndex | int.MinValue;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int StringToSequenceEnd(int endIndex)
	{
		return endIndex | int.MinValue;
	}
}


using System;
using System.Buffers;
using System.Diagnostics;

internal sealed class ReadOnlySequenceDebugView<T>
{
	[DebuggerDisplay("Count: {Segments.Length}", Name = "Segments")]
	public struct ReadOnlySequenceDebugViewSegments
	{
		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public ReadOnlyMemory<T>[] Segments { get; set; }
	}

	private readonly T[] _array;

	private readonly ReadOnlySequenceDebugViewSegments _segments;

	public ReadOnlySequenceDebugViewSegments BufferSegments => _segments;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public T[] Items => _array;

	public ReadOnlySequenceDebugView(ReadOnlySequence<T> sequence)
	{
		_array = BuffersExtensions.ToArray(in sequence);
		int num = 0;
		ReadOnlySequence<T>.Enumerator enumerator = sequence.GetEnumerator();
		while (enumerator.MoveNext())
		{
			_ = enumerator.Current;
			num++;
		}
		ReadOnlyMemory<T>[] array = new ReadOnlyMemory<T>[num];
		int num2 = 0;
		enumerator = sequence.GetEnumerator();
		while (enumerator.MoveNext())
		{
			ReadOnlyMemory<T> current = enumerator.Current;
			array[num2] = current;
			num2++;
		}
		_segments = new ReadOnlySequenceDebugViewSegments
		{
			Segments = array
		};
	}
}


using System.Diagnostics;

[DebuggerDisplay("Count: {Segments.Length}", Name = "Segments")]
public struct ReadOnlySequenceDebugViewSegments
{
	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public ReadOnlyMemory<T>[] Segments { get; set; }
}


using System;
using System.Buffers;

internal abstract class ReadOnlySequenceSegment<T>
{
	public ReadOnlyMemory<T> Memory { get; protected set; }

	public ReadOnlySequenceSegment<T>? Next { get; protected set; }

	public long RunningIndex { get; protected set; }
}


using System;
using System.Buffers;

internal readonly struct StandardFormat : IEquatable<StandardFormat>
{
	public const byte NoPrecision = byte.MaxValue;

	public const byte MaxPrecision = 99;

	private readonly byte _format;

	private readonly byte _precision;

	public char Symbol => (char)_format;

	public byte Precision => _precision;

	public bool HasPrecision => _precision != byte.MaxValue;

	public bool IsDefault
	{
		get
		{
			if (_format == 0)
			{
				return _precision == 0;
			}
			return false;
		}
	}

	public StandardFormat(char symbol, byte precision = byte.MaxValue)
	{
		if (precision != byte.MaxValue && precision > 99)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_PrecisionTooLarge();
		}
		if (symbol != (byte)symbol)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
		}
		_format = (byte)symbol;
		_precision = precision;
	}

	public static implicit operator StandardFormat(char symbol)
	{
		return new StandardFormat(symbol);
	}

	public static StandardFormat Parse(ReadOnlySpan<char> format)
	{
		if (format.Length == 0)
		{
			return default(StandardFormat);
		}
		char symbol = format[0];
		byte precision;
		if (format.Length == 1)
		{
			precision = byte.MaxValue;
		}
		else
		{
			uint num = 0u;
			for (int i = 1; i < format.Length; i++)
			{
				uint num2 = (uint)(format[i] - 48);
				if (num2 > 9)
				{
					throw new FormatException($"Cannot parse precision (max is {99})");
				}
				num = num * 10 + num2;
				if (num > 99)
				{
					throw new FormatException($"Precision is larger than the maximum {99}");
				}
			}
			precision = (byte)num;
		}
		return new StandardFormat(symbol, precision);
	}

	public static StandardFormat Parse(string? format)
	{
		if (format != null)
		{
			return Parse(MemoryExtensions.AsSpan(format));
		}
		return default(StandardFormat);
	}

	public override bool Equals(object? obj)
	{
		if (obj is StandardFormat other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		byte format = _format;
		int hashCode = format.GetHashCode();
		format = _precision;
		return hashCode ^ format.GetHashCode();
	}

	public bool Equals(StandardFormat other)
	{
		if (_format == other._format)
		{
			return _precision == other._precision;
		}
		return false;
	}

	public unsafe override string ToString()
	{
		char* ptr = stackalloc char[4];
		int length = 0;
		char symbol = Symbol;
		if (symbol != 0)
		{
			ptr[length++] = symbol;
			byte b = Precision;
			if (b != byte.MaxValue)
			{
				if (b >= 100)
				{
					ptr[length++] = (char)(48 + b / 100 % 10);
					b %= 100;
				}
				if (b >= 10)
				{
					ptr[length++] = (char)(48 + b / 10 % 10);
					b %= 10;
				}
				ptr[length++] = (char)(48 + b);
			}
		}
		return new string(ptr, 0, length);
	}

	public static bool operator ==(StandardFormat left, StandardFormat right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(StandardFormat left, StandardFormat right)
	{
		return !left.Equals(right);
	}
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;

internal sealed class TlsOverPerCoreLockedStacksArrayPool<T> : ArrayPool<T>
{
	private sealed class PerCoreLockedStacks
	{
		private static readonly int s_lockedStackCount = Math.Min(Environment.ProcessorCount, 64);

		private readonly LockedStack[] _perCoreStacks;

		public PerCoreLockedStacks()
		{
			LockedStack[] array = new LockedStack[s_lockedStackCount];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new LockedStack();
			}
			_perCoreStacks = array;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool TryPush(T[] array)
		{
			LockedStack[] perCoreStacks = _perCoreStacks;
			int num = (int)((uint)EnvironmentEx.CurrentManagedThreadId % (uint)s_lockedStackCount);
			for (int i = 0; i < perCoreStacks.Length; i++)
			{
				if (perCoreStacks[num].TryPush(array))
				{
					return true;
				}
				if (++num == perCoreStacks.Length)
				{
					num = 0;
				}
			}
			return false;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public T[]? TryPop()
		{
			LockedStack[] perCoreStacks = _perCoreStacks;
			int num = (int)((uint)EnvironmentEx.CurrentManagedThreadId % (uint)s_lockedStackCount);
			for (int i = 0; i < perCoreStacks.Length; i++)
			{
				T[] result;
				if ((result = perCoreStacks[num].TryPop()) != null)
				{
					return result;
				}
				if (++num == perCoreStacks.Length)
				{
					num = 0;
				}
			}
			return null;
		}

		public void Trim(int currentMilliseconds, int id, System.Buffers.Utilities.MemoryPressure pressure, int bucketSize)
		{
			LockedStack[] perCoreStacks = _perCoreStacks;
			for (int i = 0; i < perCoreStacks.Length; i++)
			{
				perCoreStacks[i].Trim(currentMilliseconds, id, pressure, bucketSize);
			}
		}
	}

	private sealed class LockedStack
	{
		private readonly T[]?[] _arrays = new T[8][];

		private int _count;

		private int _millisecondsTimestamp;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool TryPush(T[] array)
		{
			bool result = false;
			Monitor.Enter(this);
			T[][] arrays = _arrays;
			int count = _count;
			if ((uint)count < (uint)arrays.Length)
			{
				if (count == 0)
				{
					_millisecondsTimestamp = 0;
				}
				arrays[count] = array;
				_count = count + 1;
				result = true;
			}
			Monitor.Exit(this);
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public T[]? TryPop()
		{
			T[] result = null;
			Monitor.Enter(this);
			T[][] arrays = _arrays;
			int num = _count - 1;
			if ((uint)num < (uint)arrays.Length)
			{
				result = arrays[num];
				arrays[num] = null;
				_count = num;
			}
			Monitor.Exit(this);
			return result;
		}

		public void Trim(int currentMilliseconds, int id, System.Buffers.Utilities.MemoryPressure pressure, int bucketSize)
		{
			if (_count == 0)
			{
				return;
			}
			int num = ((pressure == System.Buffers.Utilities.MemoryPressure.High) ? 10000 : 60000);
			lock (this)
			{
				if (_count == 0)
				{
					return;
				}
				if (_millisecondsTimestamp == 0)
				{
					_millisecondsTimestamp = currentMilliseconds;
				}
				else
				{
					if (currentMilliseconds - _millisecondsTimestamp <= num)
					{
						return;
					}
					int num2 = 1;
					switch (pressure)
					{
					case System.Buffers.Utilities.MemoryPressure.High:
						num2 = 8;
						if (bucketSize > 16384)
						{
							num2++;
						}
						if (Unsafe.SizeOf<T>() > 16)
						{
							num2++;
						}
						if (Unsafe.SizeOf<T>() > 32)
						{
							num2++;
						}
						break;
					case System.Buffers.Utilities.MemoryPressure.Medium:
						num2 = 2;
						break;
					}
					while (_count > 0 && num2-- > 0)
					{
						_ = _arrays[--_count];
						_arrays[_count] = null;
					}
					_millisecondsTimestamp = ((_count > 0) ? (_millisecondsTimestamp + num / 4) : 0);
				}
			}
		}
	}

	private struct ThreadLocalArray
	{
		public T[]? Array;

		public int MillisecondsTimeStamp;

		public ThreadLocalArray(T[] array)
		{
			Array = array;
			MillisecondsTimeStamp = 0;
		}
	}

	private const int NumBuckets = 27;

	private const int MaxPerCorePerArraySizeStacks = 64;

	private const int MaxBuffersPerArraySizePerCore = 8;

	[ThreadStatic]
	private static ThreadLocalArray[]? t_tlsBuckets;

	private readonly ConditionalWeakTable<ThreadLocalArray[], object?> _allTlsBuckets = new ConditionalWeakTable<ThreadLocalArray[], object>();

	private readonly PerCoreLockedStacks?[] _buckets = new PerCoreLockedStacks[27];

	private int _trimCallbackCreated;

	private int Id => GetHashCode();

	private PerCoreLockedStacks CreatePerCoreLockedStacks(int bucketIndex)
	{
		PerCoreLockedStacks perCoreLockedStacks = new PerCoreLockedStacks();
		return Interlocked.CompareExchange(ref _buckets[bucketIndex], perCoreLockedStacks, null) ?? perCoreLockedStacks;
	}

	public override T[] Rent(int minimumLength)
	{
		int num = System.Buffers.Utilities.SelectBucketIndex(minimumLength);
		ThreadLocalArray[] array = t_tlsBuckets;
		if (array != null && (uint)num < (uint)array.Length)
		{
			T[] array2 = array[num].Array;
			if (array2 != null)
			{
				array[num].Array = null;
				return array2;
			}
		}
		PerCoreLockedStacks[] buckets = _buckets;
		if ((uint)num < (uint)buckets.Length)
		{
			PerCoreLockedStacks perCoreLockedStacks = buckets[num];
			if (perCoreLockedStacks != null)
			{
				T[] array2 = perCoreLockedStacks.TryPop();
				if (array2 != null)
				{
					return array2;
				}
			}
			minimumLength = System.Buffers.Utilities.GetMaxSizeForBucket(num);
		}
		else
		{
			if (minimumLength == 0)
			{
				return ArrayEx.Empty<T>();
			}
			if (minimumLength < 0)
			{
				throw new ArgumentOutOfRangeException("minimumLength");
			}
		}
		return new T[minimumLength];
	}

	public override void Return(T[] array, bool clearArray = false)
	{
		if (array == null)
		{
			System.ThrowHelper.ThrowArgumentNullException(System.ExceptionArgument.array);
		}
		int num = System.Buffers.Utilities.SelectBucketIndex(array.Length);
		ThreadLocalArray[] array2 = t_tlsBuckets ?? InitializeTlsBucketsAndTrimming();
		if ((uint)num < (uint)array2.Length)
		{
			if (clearArray)
			{
				Array.Clear(array, 0, array.Length);
			}
			if (array.Length != System.Buffers.Utilities.GetMaxSizeForBucket(num))
			{
				throw new ArgumentException("Buffer not from this pool", "array");
			}
			ref ThreadLocalArray reference = ref array2[num];
			T[] array3 = reference.Array;
			reference = new ThreadLocalArray(array);
			if (array3 != null)
			{
				(_buckets[num] ?? CreatePerCoreLockedStacks(num)).TryPush(array3);
			}
		}
	}

	public bool Trim()
	{
		int tickCount = Environment.TickCount;
		System.Buffers.Utilities.MemoryPressure memoryPressure = System.Buffers.Utilities.GetMemoryPressure();
		PerCoreLockedStacks[] buckets = _buckets;
		for (int i = 0; i < buckets.Length; i++)
		{
			buckets[i]?.Trim(tickCount, Id, memoryPressure, System.Buffers.Utilities.GetMaxSizeForBucket(i));
		}
		if (memoryPressure == System.Buffers.Utilities.MemoryPressure.High)
		{
			foreach (KeyValuePair<ThreadLocalArray[], object> allTlsBucket in _allTlsBuckets)
			{
				Array.Clear(allTlsBucket.Key, 0, allTlsBucket.Key.Length);
			}
		}
		else
		{
			uint num = ((memoryPressure != System.Buffers.Utilities.MemoryPressure.Medium) ? 30000u : 15000u);
			uint num2 = num;
			foreach (KeyValuePair<ThreadLocalArray[], object> allTlsBucket2 in _allTlsBuckets)
			{
				ThreadLocalArray[] key = allTlsBucket2.Key;
				for (int j = 0; j < key.Length; j++)
				{
					if (key[j].Array != null)
					{
						int millisecondsTimeStamp = key[j].MillisecondsTimeStamp;
						if (millisecondsTimeStamp == 0)
						{
							key[j].MillisecondsTimeStamp = tickCount;
						}
						else if (tickCount - millisecondsTimeStamp >= num2)
						{
							Interlocked.Exchange(ref key[j].Array, null);
						}
					}
				}
			}
		}
		if (!Environment.HasShutdownStarted)
		{
			return !AppDomain.CurrentDomain.IsFinalizingForUnload();
		}
		return false;
	}

	private ThreadLocalArray[] InitializeTlsBucketsAndTrimming()
	{
		ThreadLocalArray[] array = (t_tlsBuckets = new ThreadLocalArray[27]);
		_allTlsBuckets.Add(array, null);
		if (Interlocked.Exchange(ref _trimCallbackCreated, 1) == 0)
		{
			System.Gen2GcCallback.Register((object s) => ((TlsOverPerCoreLockedStacksArrayPool<T>)s).Trim(), this);
		}
		return array;
	}
}


using System.Runtime.CompilerServices;

private sealed class PerCoreLockedStacks
{
	private static readonly int s_lockedStackCount = Math.Min(Environment.ProcessorCount, 64);

	private readonly LockedStack[] _perCoreStacks;

	public PerCoreLockedStacks()
	{
		LockedStack[] array = new LockedStack[s_lockedStackCount];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = new LockedStack();
		}
		_perCoreStacks = array;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool TryPush(T[] array)
	{
		LockedStack[] perCoreStacks = _perCoreStacks;
		int num = (int)((uint)EnvironmentEx.CurrentManagedThreadId % (uint)s_lockedStackCount);
		for (int i = 0; i < perCoreStacks.Length; i++)
		{
			if (perCoreStacks[num].TryPush(array))
			{
				return true;
			}
			if (++num == perCoreStacks.Length)
			{
				num = 0;
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T[]? TryPop()
	{
		LockedStack[] perCoreStacks = _perCoreStacks;
		int num = (int)((uint)EnvironmentEx.CurrentManagedThreadId % (uint)s_lockedStackCount);
		for (int i = 0; i < perCoreStacks.Length; i++)
		{
			T[] result;
			if ((result = perCoreStacks[num].TryPop()) != null)
			{
				return result;
			}
			if (++num == perCoreStacks.Length)
			{
				num = 0;
			}
		}
		return null;
	}

	public void Trim(int currentMilliseconds, int id, System.Buffers.Utilities.MemoryPressure pressure, int bucketSize)
	{
		LockedStack[] perCoreStacks = _perCoreStacks;
		for (int i = 0; i < perCoreStacks.Length; i++)
		{
			perCoreStacks[i].Trim(currentMilliseconds, id, pressure, bucketSize);
		}
	}
}


using System.Runtime.CompilerServices;
using System.Threading;

private sealed class LockedStack
{
	private readonly T[]?[] _arrays = new T[8][];

	private int _count;

	private int _millisecondsTimestamp;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool TryPush(T[] array)
	{
		bool result = false;
		Monitor.Enter(this);
		T[][] arrays = _arrays;
		int count = _count;
		if ((uint)count < (uint)arrays.Length)
		{
			if (count == 0)
			{
				_millisecondsTimestamp = 0;
			}
			arrays[count] = array;
			_count = count + 1;
			result = true;
		}
		Monitor.Exit(this);
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public T[]? TryPop()
	{
		T[] result = null;
		Monitor.Enter(this);
		T[][] arrays = _arrays;
		int num = _count - 1;
		if ((uint)num < (uint)arrays.Length)
		{
			result = arrays[num];
			arrays[num] = null;
			_count = num;
		}
		Monitor.Exit(this);
		return result;
	}

	public void Trim(int currentMilliseconds, int id, System.Buffers.Utilities.MemoryPressure pressure, int bucketSize)
	{
		if (_count == 0)
		{
			return;
		}
		int num = ((pressure == System.Buffers.Utilities.MemoryPressure.High) ? 10000 : 60000);
		lock (this)
		{
			if (_count == 0)
			{
				return;
			}
			if (_millisecondsTimestamp == 0)
			{
				_millisecondsTimestamp = currentMilliseconds;
			}
			else
			{
				if (currentMilliseconds - _millisecondsTimestamp <= num)
				{
					return;
				}
				int num2 = 1;
				switch (pressure)
				{
				case System.Buffers.Utilities.MemoryPressure.High:
					num2 = 8;
					if (bucketSize > 16384)
					{
						num2++;
					}
					if (Unsafe.SizeOf<T>() > 16)
					{
						num2++;
					}
					if (Unsafe.SizeOf<T>() > 32)
					{
						num2++;
					}
					break;
				case System.Buffers.Utilities.MemoryPressure.Medium:
					num2 = 2;
					break;
				}
				while (_count > 0 && num2-- > 0)
				{
					_ = _arrays[--_count];
					_arrays[_count] = null;
				}
				_millisecondsTimestamp = ((_count > 0) ? (_millisecondsTimestamp + num / 4) : 0);
			}
		}
	}
}


private struct ThreadLocalArray
{
	public T[]? Array;

	public int MillisecondsTimeStamp;

	public ThreadLocalArray(T[] array)
	{
		Array = array;
		MillisecondsTimeStamp = 0;
	}
}


using System.Buffers;
using System.Numerics;
using System.Runtime.CompilerServices;

internal static class Utilities
{
	internal enum MemoryPressure
	{
		Low,
		Medium,
		High
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int SelectBucketIndex(int bufferSize)
	{
		return BitOperations.Log2((uint)((bufferSize - 1) | 0xF)) - 3;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int GetMaxSizeForBucket(int binIndex)
	{
		return 16 << binIndex;
	}

	internal static MemoryPressure GetMemoryPressure()
	{
		return MemoryPressure.Low;
	}
}


internal enum MemoryPressure
{
	Low,
	Medium,
	High
}


using System;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Threading;

internal struct DependentHandle : IDisposable
{
	private sealed class DependentHolder : CriticalFinalizerObject
	{
		public GCHandle TargetHandle;

		private IntPtr dependent;

		public object? Dependent
		{
			get
			{
				return GCHandle.FromIntPtr(dependent).Target;
			}
			set
			{
				IntPtr value2 = GCHandle.ToIntPtr(GCHandle.Alloc(value, GCHandleType.Normal));
				IntPtr intPtr;
				do
				{
					intPtr = dependent;
				}
				while (Interlocked.CompareExchange(ref dependent, value2, intPtr) == intPtr);
				GCHandle.FromIntPtr(intPtr).Free();
			}
		}

		public DependentHolder(GCHandle targetHandle, object dependent)
		{
			TargetHandle = targetHandle;
			this.dependent = GCHandle.ToIntPtr(GCHandle.Alloc(dependent, GCHandleType.Normal));
		}

		~DependentHolder()
		{
			if (!AppDomain.CurrentDomain.IsFinalizingForUnload() && (!Environment.HasShutdownStarted && (TargetHandle.IsAllocated && TargetHandle.Target != null)))
			{
				GC.ReRegisterForFinalize(this);
			}
			else
			{
				GCHandle.FromIntPtr(dependent).Free();
			}
		}
	}

	private GCHandle dependentHandle;

	private volatile bool allocated;

	public bool IsAllocated => allocated;

	public object? Target
	{
		get
		{
			if (!allocated)
			{
				throw new InvalidOperationException();
			}
			return UnsafeGetTarget();
		}
		set
		{
			if (!allocated || value != null)
			{
				throw new InvalidOperationException();
			}
			UnsafeSetTargetToNull();
		}
	}

	public object? Dependent
	{
		get
		{
			if (!allocated)
			{
				throw new InvalidOperationException();
			}
			return UnsafeGetHolder()?.Dependent;
		}
		set
		{
			if (!allocated)
			{
				throw new InvalidOperationException();
			}
			UnsafeSetDependent(value);
		}
	}

	public (object? Target, object? Dependent) TargetAndDependent
	{
		get
		{
			if (!allocated)
			{
				throw new InvalidOperationException();
			}
			return (Target: UnsafeGetTarget(), Dependent: Dependent);
		}
	}

	public DependentHandle(object? target, object? dependent)
	{
		GCHandle targetHandle = GCHandle.Alloc(target, GCHandleType.WeakTrackResurrection);
		dependentHandle = AllocDepHolder(targetHandle, dependent);
		GC.KeepAlive(target);
		allocated = true;
	}

	private static GCHandle AllocDepHolder(GCHandle targetHandle, object? dependent)
	{
		return GCHandle.Alloc((dependent != null) ? new DependentHolder(targetHandle, dependent) : null, GCHandleType.WeakTrackResurrection);
	}

	private DependentHolder? UnsafeGetHolder()
	{
		return Unsafe.As<DependentHolder>(dependentHandle.Target);
	}

	internal object? UnsafeGetTarget()
	{
		return UnsafeGetHolder()?.TargetHandle.Target;
	}

	internal object? UnsafeGetTargetAndDependent(out object? dependent)
	{
		dependent = null;
		DependentHolder dependentHolder = UnsafeGetHolder();
		if (dependentHolder == null)
		{
			return null;
		}
		object target = dependentHolder.TargetHandle.Target;
		if (target == null)
		{
			return null;
		}
		dependent = dependentHolder.Dependent;
		return target;
	}

	internal void UnsafeSetTargetToNull()
	{
		Free();
	}

	internal void UnsafeSetDependent(object? value)
	{
		DependentHolder dependentHolder = UnsafeGetHolder();
		if (dependentHolder != null)
		{
			if (!dependentHolder.TargetHandle.IsAllocated)
			{
				Free();
			}
			else
			{
				dependentHolder.Dependent = value;
			}
		}
	}

	private void FreeDependentHandle()
	{
		if (allocated)
		{
			UnsafeGetHolder()?.TargetHandle.Free();
			dependentHandle.Free();
		}
		allocated = false;
	}

	private void Free()
	{
		FreeDependentHandle();
	}

	public void Dispose()
	{
		Free();
		allocated = false;
	}
}


using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Threading;

private sealed class DependentHolder : CriticalFinalizerObject
{
	public GCHandle TargetHandle;

	private IntPtr dependent;

	public object? Dependent
	{
		get
		{
			return GCHandle.FromIntPtr(dependent).Target;
		}
		set
		{
			IntPtr value2 = GCHandle.ToIntPtr(GCHandle.Alloc(value, GCHandleType.Normal));
			IntPtr intPtr;
			do
			{
				intPtr = dependent;
			}
			while (Interlocked.CompareExchange(ref dependent, value2, intPtr) == intPtr);
			GCHandle.FromIntPtr(intPtr).Free();
		}
	}

	public DependentHolder(GCHandle targetHandle, object dependent)
	{
		TargetHandle = targetHandle;
		this.dependent = GCHandle.ToIntPtr(GCHandle.Alloc(dependent, GCHandleType.Normal));
	}

	~DependentHolder()
	{
		if (!AppDomain.CurrentDomain.IsFinalizingForUnload() && (!Environment.HasShutdownStarted && (TargetHandle.IsAllocated && TargetHandle.Target != null)))
		{
			GC.ReRegisterForFinalize(this);
		}
		else
		{
			GCHandle.FromIntPtr(dependent).Free();
		}
	}
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal static class MemoryMarshal
{
	public static bool TryGetArray<T>(ReadOnlyMemory<T> memory, out ArraySegment<T> segment)
	{
		int start;
		int length;
		object objectStartLength = memory.GetObjectStartLength(out start, out length);
		if (start < 0)
		{
			if (((MemoryManager<T>)objectStartLength).TryGetArray(out var segment2))
			{
				segment = new ArraySegment<T>(segment2.Array, segment2.Offset + (start & 0x7FFFFFFF), length);
				return true;
			}
		}
		else if (objectStartLength is T[] array)
		{
			segment = new ArraySegment<T>(array, start, length & 0x7FFFFFFF);
			return true;
		}
		if ((length & 0x7FFFFFFF) == 0)
		{
			segment = new ArraySegment<T>(System.SpanHelpers.PerTypeValues<T>.EmptyArray);
			return true;
		}
		segment = default(ArraySegment<T>);
		return false;
	}

	public static bool TryGetMemoryManager<T, TManager>(ReadOnlyMemory<T> memory, out TManager? manager) where TManager : MemoryManager<T>
	{
		int start;
		int length;
		return (manager = memory.GetObjectStartLength(out start, out length) as TManager) != null;
	}

	public static bool TryGetMemoryManager<T, TManager>(ReadOnlyMemory<T> memory, out TManager? manager, out int start, out int length) where TManager : MemoryManager<T>
	{
		TManager val = (manager = memory.GetObjectStartLength(out start, out length) as TManager);
		start &= int.MaxValue;
		if (val == null)
		{
			start = 0;
			length = 0;
			return false;
		}
		return true;
	}

	public static IEnumerable<T> ToEnumerable<T>(ReadOnlyMemory<T> memory)
	{
		for (int i = 0; i < memory.Length; i++)
		{
			yield return memory.Span[i];
		}
	}

	public static bool TryGetString(ReadOnlyMemory<char> memory, out string? text, out int start, out int length)
	{
		if (memory.GetObjectStartLength(out var start2, out var length2) is string text2)
		{
			text = text2;
			start = start2;
			length = length2;
			return true;
		}
		text = null;
		start = 0;
		length = 0;
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static T Read<T>(ReadOnlySpan<byte> source) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (Unsafe.SizeOf<T>() > source.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.length);
		}
		return Unsafe.ReadUnaligned<T>(ref GetReference(source));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryRead<T>(ReadOnlySpan<byte> source, out T value) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (Unsafe.SizeOf<T>() > (uint)source.Length)
		{
			value = default(T);
			return false;
		}
		value = Unsafe.ReadUnaligned<T>(ref GetReference(source));
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Write<T>(Span<byte> destination, ref T value) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if ((uint)Unsafe.SizeOf<T>() > (uint)destination.Length)
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException(System.ExceptionArgument.length);
		}
		Unsafe.WriteUnaligned(ref GetReference(destination), value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryWrite<T>(Span<byte> destination, ref T value) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		if (Unsafe.SizeOf<T>() > (uint)destination.Length)
		{
			return false;
		}
		Unsafe.WriteUnaligned(ref GetReference(destination), value);
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Memory<T> CreateFromPinnedArray<T>(T[] array, int start, int length)
	{
		if (array == null)
		{
			if (start != 0 || length != 0)
			{
				System.ThrowHelper.ThrowArgumentOutOfRangeException();
			}
			return default(Memory<T>);
		}
		if (default(T) == null && array.GetType() != typeof(T[]))
		{
			System.ThrowHelper.ThrowArrayTypeMismatchException();
		}
		if ((uint)start > (uint)array.Length || (uint)length > (uint)(array.Length - start))
		{
			System.ThrowHelper.ThrowArgumentOutOfRangeException();
		}
		return new Memory<T>((object?)array, start, length | int.MinValue);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Span<byte> AsBytes<T>(Span<T> span) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		int length = checked(span.Length * Unsafe.SizeOf<T>());
		return new Span<byte>(Unsafe.As<Pinnable<byte>>(span.Pinnable), span.ByteOffset, length);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ReadOnlySpan<byte> AsBytes<T>(ReadOnlySpan<T> span) where T : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<T>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(T));
		}
		int length = checked(span.Length * Unsafe.SizeOf<T>());
		return new ReadOnlySpan<byte>(Unsafe.As<Pinnable<byte>>(span.Pinnable), span.ByteOffset, length);
	}

	public static Memory<T> AsMemory<T>(ReadOnlyMemory<T> memory)
	{
		return Unsafe.As<ReadOnlyMemory<T>, Memory<T>>(ref memory);
	}

	public unsafe static ref T GetReference<T>(Span<T> span)
	{
		if (span.Pinnable == null)
		{
			return ref Unsafe.AsRef<T>(span.ByteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref span.Pinnable.Data, span.ByteOffset);
	}

	public unsafe static ref T GetReference<T>(ReadOnlySpan<T> span)
	{
		if (span.Pinnable == null)
		{
			return ref Unsafe.AsRef<T>(span.ByteOffset.ToPointer());
		}
		return ref Unsafe.AddByteOffset(ref span.Pinnable.Data, span.ByteOffset);
	}

	public static Span<TTo> Cast<TFrom, TTo>(Span<TFrom> span) where TFrom : struct where TTo : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TFrom>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TFrom));
		}
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TTo>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TTo));
		}
		checked
		{
			int length = (int)unchecked(checked(unchecked((long)span.Length) * unchecked((long)Unsafe.SizeOf<TFrom>())) / Unsafe.SizeOf<TTo>());
			return new Span<TTo>(Unsafe.As<Pinnable<TTo>>(span.Pinnable), span.ByteOffset, length);
		}
	}

	public static ReadOnlySpan<TTo> Cast<TFrom, TTo>(ReadOnlySpan<TFrom> span) where TFrom : struct where TTo : struct
	{
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TFrom>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TFrom));
		}
		if (System.SpanHelpers.IsReferenceOrContainsReferences<TTo>())
		{
			System.ThrowHelper.ThrowArgumentException_InvalidTypeWithPointersNotSupported(typeof(TTo));
		}
		checked
		{
			int length = (int)unchecked(checked(unchecked((long)span.Length) * unchecked((long)Unsafe.SizeOf<TFrom>())) / Unsafe.SizeOf<TTo>());
			return new ReadOnlySpan<TTo>(Unsafe.As<Pinnable<TTo>>(span.Pinnable), span.ByteOffset, length);
		}
	}
}


using System;
using System.Buffers;
using System.Diagnostics.CodeAnalysis;

internal static class SequenceMarshal
{
	public static bool TryGetReadOnlySequenceSegment<T>(ReadOnlySequence<T> sequence, out ReadOnlySequenceSegment<T>? startSegment, out int startIndex, out ReadOnlySequenceSegment<T>? endSegment, out int endIndex)
	{
		return sequence.TryGetReadOnlySequenceSegment(out startSegment, out startIndex, out endSegment, out endIndex);
	}

	public static bool TryGetArray<T>(ReadOnlySequence<T> sequence, out ArraySegment<T> segment)
	{
		return sequence.TryGetArray(out segment);
	}

	public static bool TryGetReadOnlyMemory<T>(ReadOnlySequence<T> sequence, out ReadOnlyMemory<T> memory)
	{
		if (!sequence.IsSingleSegment)
		{
			memory = default(ReadOnlyMemory<T>);
			return false;
		}
		memory = sequence.First;
		return true;
	}

	internal static bool TryGetString(ReadOnlySequence<char> sequence, [<22576685-8ec8-4022-94e7-b5a630de7c65>MaybeNullWhen(false)] out string text, out int start, out int length)
	{
		return sequence.TryGetString(out text, out start, out length);
	}
}


using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

internal static class MarshalEx
{
	private static readonly MethodInfo? Marshal_SetLastWin32Error_Meth = typeof(Marshal).GetMethod("SetLastPInvokeError", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic) ?? typeof(Marshal).GetMethod("SetLastWin32Error", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly Action<int>? Marshal_SetLastWin32Error = (((object)Marshal_SetLastWin32Error_Meth == null) ? null : ((Action<int>)Delegate.CreateDelegate(typeof(Action<int>), Marshal_SetLastWin32Error_Meth)));

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetLastPInvokeError()
	{
		return Marshal.GetLastWin32Error();
	}

	public static void SetLastPInvokeError(int error)
	{
		(Marshal_SetLastWin32Error ?? throw new PlatformNotSupportedException("Cannot set last P/Invoke error (no method Marshal.SetLastWin32Error or Marshal.SetLastPInvokeError)"))(error);
	}
}


using System;

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class CallerArgumentExpressionAttribute : Attribute
{
	public string ParameterName { get; }

	public CallerArgumentExpressionAttribute(string parameterName)
	{
		ParameterName = parameterName;
	}
}


using System.Collections.Generic;

internal interface ICWTEnumerable<T>
{
	IEnumerable<T> SelfEnumerable { get; }

	IEnumerator<T> GetEnumerator();
}


using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal sealed class CWTEnumerable<TKey, TValue> : IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable where TKey : class where TValue : class?
{
	private readonly ConditionalWeakTable<TKey, TValue> cwt;

	public CWTEnumerable(ConditionalWeakTable<TKey, TValue> table)
	{
		cwt = table;
	}

	public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
	{
		return cwt.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;

internal static class ConditionalWeakTableExtensions
{
	private static class CWTInfoHolder<TKey, TValue> where TKey : class where TValue : class?
	{
		public delegate IEnumerable<TKey> GetKeys(ConditionalWeakTable<TKey, TValue> cwt);

		private static readonly MethodInfo? get_KeysMethod;

		public static readonly GetKeys? get_Keys;

		static CWTInfoHolder()
		{
			get_KeysMethod = typeof(ConditionalWeakTable<TKey, TValue>).GetProperty("Keys", BindingFlags.Instance | BindingFlags.NonPublic)?.GetGetMethod(nonPublic: true);
			if ((object)get_KeysMethod != null)
			{
				get_Keys = (GetKeys)Delegate.CreateDelegate(typeof(GetKeys), get_KeysMethod);
			}
		}
	}

	public static IEnumerable<KeyValuePair<TKey, TValue>> AsEnumerable<TKey, TValue>(this ConditionalWeakTable<TKey, TValue> self) where TKey : class where TValue : class?
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, "self");
		if (self is IEnumerable<KeyValuePair<TKey, TValue>> result)
		{
			return result;
		}
		if (self is ICWTEnumerable<KeyValuePair<TKey, TValue>> iCWTEnumerable)
		{
			return iCWTEnumerable.SelfEnumerable;
		}
		return new CWTEnumerable<TKey, TValue>(self);
	}

	public static IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator<TKey, TValue>(this ConditionalWeakTable<TKey, TValue> self) where TKey : class where TValue : class?
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, "self");
		if (self is IEnumerable<KeyValuePair<TKey, TValue>> enumerable)
		{
			return enumerable.GetEnumerator();
		}
		if (self is ICWTEnumerable<KeyValuePair<TKey, TValue>> iCWTEnumerable)
		{
			return iCWTEnumerable.GetEnumerator();
		}
		CWTInfoHolder<TKey, TValue>.GetKeys get_Keys = CWTInfoHolder<TKey, TValue>.get_Keys;
		if (get_Keys != null)
		{
			return Enumerate(self, get_Keys(self));
		}
		throw new PlatformNotSupportedException("Could not get Keys property of ConditionalWeakTable to enumerate it");
		static IEnumerator<KeyValuePair<TKey, TValue>> Enumerate(ConditionalWeakTable<TKey, TValue> cwt, IEnumerable<TKey> keys)
		{
			foreach (TKey key in keys)
			{
				if (cwt.TryGetValue(key, out var value))
				{
					yield return new KeyValuePair<TKey, TValue>(key, value);
				}
			}
		}
	}

	public static void Clear<TKey, TValue>(this ConditionalWeakTable<TKey, TValue> self) where TKey : class where TValue : class?
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, "self");
		using IEnumerator<KeyValuePair<TKey, TValue>> enumerator = self.GetEnumerator();
		while (enumerator.MoveNext())
		{
			self.Remove(enumerator.Current.Key);
		}
	}

	public static bool TryAdd<TKey, TValue>(this ConditionalWeakTable<TKey, TValue> self, TKey key, TValue value) where TKey : class where TValue : class?
	{
		System.ThrowHelper.ThrowIfArgumentNull(self, "self");
		bool didAdd = false;
		self.GetValue(key, delegate
		{
			didAdd = true;
			return value;
		});
		return didAdd;
	}
}


using System.Collections.Generic;
using System.Reflection;

private static class CWTInfoHolder<TKey, TValue> where TKey : class where TValue : class?
{
	public delegate IEnumerable<TKey> GetKeys(ConditionalWeakTable<TKey, TValue> cwt);

	private static readonly MethodInfo? get_KeysMethod;

	public static readonly GetKeys? get_Keys;

	static CWTInfoHolder()
	{
		get_KeysMethod = typeof(ConditionalWeakTable<TKey, TValue>).GetProperty("Keys", BindingFlags.Instance | BindingFlags.NonPublic)?.GetGetMethod(nonPublic: true);
		if ((object)get_KeysMethod != null)
		{
			get_Keys = (GetKeys)Delegate.CreateDelegate(typeof(GetKeys), get_KeysMethod);
		}
	}
}


using System.Collections.Generic;

public delegate IEnumerable<TKey> GetKeys(ConditionalWeakTable<TKey, TValue> cwt);


using System;
using System.Buffers;
using System.Globalization;
using System.Runtime.CompilerServices;

[InterpolatedStringHandler]
internal ref struct DefaultInterpolatedStringHandler
{
	private const int GuessedLengthPerHole = 11;

	private const int MinimumArrayPoolLength = 256;

	private readonly IFormatProvider? _provider;

	private char[]? _arrayToReturnToPool;

	private Span<char> _chars;

	private int _pos;

	private readonly bool _hasCustomFormatter;

	internal ReadOnlySpan<char> Text => _chars.Slice(0, _pos);

	public DefaultInterpolatedStringHandler(int literalLength, int formattedCount)
	{
		_provider = null;
		_chars = (_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(GetDefaultLength(literalLength, formattedCount)));
		_pos = 0;
		_hasCustomFormatter = false;
	}

	public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider? provider)
	{
		_provider = provider;
		_chars = (_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(GetDefaultLength(literalLength, formattedCount)));
		_pos = 0;
		_hasCustomFormatter = provider != null && HasCustomFormatter(provider);
	}

	public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider? provider, Span<char> initialBuffer)
	{
		_provider = provider;
		_chars = initialBuffer;
		_arrayToReturnToPool = null;
		_pos = 0;
		_hasCustomFormatter = provider != null && HasCustomFormatter(provider);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int GetDefaultLength(int literalLength, int formattedCount)
	{
		return Math.Max(256, literalLength + formattedCount * 11);
	}

	public override string ToString()
	{
		return Text.ToString();
	}

	public string ToStringAndClear()
	{
		string result = Text.ToString();
		Clear();
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void Clear()
	{
		char[] arrayToReturnToPool = _arrayToReturnToPool;
		this = default(DefaultInterpolatedStringHandler);
		if (arrayToReturnToPool != null)
		{
			ArrayPool<char>.Shared.Return(arrayToReturnToPool);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string value)
	{
		if (value.Length == 1)
		{
			Span<char> chars = _chars;
			int pos = _pos;
			if ((uint)pos < (uint)chars.Length)
			{
				chars[pos] = value[0];
				_pos = pos + 1;
			}
			else
			{
				GrowThenCopyString(value);
			}
		}
		else if (value.Length == 2)
		{
			Span<char> chars2 = _chars;
			int pos2 = _pos;
			if ((uint)pos2 < chars2.Length - 1)
			{
				MemoryExtensions.AsSpan(value).CopyTo(chars2.Slice(pos2));
				_pos = pos2 + 2;
			}
			else
			{
				GrowThenCopyString(value);
			}
		}
		else
		{
			AppendStringDirect(value);
		}
	}

	private void AppendStringDirect(string value)
	{
		if (MemoryExtensions.AsSpan(value).TryCopyTo(_chars.Slice(_pos)))
		{
			_pos += value.Length;
		}
		else
		{
			GrowThenCopyString(value);
		}
	}

	public void AppendFormatted<T>(T value)
	{
		if (_hasCustomFormatter)
		{
			AppendCustomFormatter(value, null);
			return;
		}
		if (typeof(T) == typeof(IntPtr))
		{
			AppendFormatted(Unsafe.As<T, IntPtr>(ref value));
			return;
		}
		if (typeof(T) == typeof(UIntPtr))
		{
			AppendFormatted(Unsafe.As<T, UIntPtr>(ref value));
			return;
		}
		string text = ((!(value is IFormattable)) ? value?.ToString() : ((IFormattable)(object)value).ToString(null, _provider));
		if (text != null)
		{
			AppendStringDirect(text);
		}
	}

	public void AppendFormatted<T>(T value, string? format)
	{
		if (_hasCustomFormatter)
		{
			AppendCustomFormatter(value, format);
			return;
		}
		if (typeof(T) == typeof(IntPtr))
		{
			AppendFormatted(Unsafe.As<T, IntPtr>(ref value), format);
			return;
		}
		if (typeof(T) == typeof(UIntPtr))
		{
			AppendFormatted(Unsafe.As<T, UIntPtr>(ref value), format);
			return;
		}
		string text = ((!(value is IFormattable)) ? value?.ToString() : ((IFormattable)(object)value).ToString(format, _provider));
		if (text != null)
		{
			AppendStringDirect(text);
		}
	}

	public void AppendFormatted<T>(T value, int alignment)
	{
		int pos = _pos;
		AppendFormatted(value);
		if (alignment != 0)
		{
			AppendOrInsertAlignmentIfNeeded(pos, alignment);
		}
	}

	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		int pos = _pos;
		AppendFormatted(value, format);
		if (alignment != 0)
		{
			AppendOrInsertAlignmentIfNeeded(pos, alignment);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(IntPtr value)
	{
		if (IntPtr.Size == 4)
		{
			AppendFormatted((int)value);
		}
		else
		{
			AppendFormatted((long)value);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(IntPtr value, string? format)
	{
		if (IntPtr.Size == 4)
		{
			AppendFormatted((int)value, format);
		}
		else
		{
			AppendFormatted((long)value, format);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(UIntPtr value)
	{
		if (UIntPtr.Size == 4)
		{
			AppendFormatted((uint)value);
		}
		else
		{
			AppendFormatted((ulong)value);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(UIntPtr value, string? format)
	{
		if (UIntPtr.Size == 4)
		{
			AppendFormatted((uint)value, format);
		}
		else
		{
			AppendFormatted((ulong)value, format);
		}
	}

	public void AppendFormatted(ReadOnlySpan<char> value)
	{
		if (value.TryCopyTo(_chars.Slice(_pos)))
		{
			_pos += value.Length;
		}
		else
		{
			GrowThenCopySpan(value);
		}
	}

	public void AppendFormatted(ReadOnlySpan<char> value, int alignment = 0, string? format = null)
	{
		bool flag = false;
		if (alignment < 0)
		{
			flag = true;
			alignment = -alignment;
		}
		int num = alignment - value.Length;
		if (num <= 0)
		{
			AppendFormatted(value);
			return;
		}
		EnsureCapacityForAdditionalChars(value.Length + num);
		if (flag)
		{
			value.CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
			_chars.Slice(_pos, num).Fill(' ');
			_pos += num;
		}
		else
		{
			_chars.Slice(_pos, num).Fill(' ');
			_pos += num;
			value.CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
		}
	}

	public void AppendFormatted(string? value)
	{
		if (!_hasCustomFormatter && value != null && MemoryExtensions.AsSpan(value).TryCopyTo(_chars.Slice(_pos)))
		{
			_pos += value.Length;
		}
		else
		{
			AppendFormattedSlow(value);
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void AppendFormattedSlow(string? value)
	{
		if (_hasCustomFormatter)
		{
			AppendCustomFormatter(value, null);
		}
		else if (value != null)
		{
			EnsureCapacityForAdditionalChars(value.Length);
			MemoryExtensions.AsSpan(value).CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
		}
	}

	public void AppendFormatted(string? value, int alignment = 0, string? format = null)
	{
		this.AppendFormatted<string>(value, alignment, format);
	}

	public void AppendFormatted(object? value, int alignment = 0, string? format = null)
	{
		this.AppendFormatted<object>(value, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static bool HasCustomFormatter(IFormatProvider provider)
	{
		if (provider.GetType() != typeof(CultureInfo))
		{
			return provider.GetFormat(typeof(ICustomFormatter)) != null;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void AppendCustomFormatter<T>(T value, string? format)
	{
		ICustomFormatter customFormatter = (ICustomFormatter)_provider.GetFormat(typeof(ICustomFormatter));
		if (customFormatter != null)
		{
			string text = customFormatter.Format(format, value, _provider);
			if (text != null)
			{
				AppendStringDirect(text);
			}
		}
	}

	private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)
	{
		int num = _pos - startingPos;
		bool flag = false;
		if (alignment < 0)
		{
			flag = true;
			alignment = -alignment;
		}
		int num2 = alignment - num;
		if (num2 > 0)
		{
			EnsureCapacityForAdditionalChars(num2);
			if (flag)
			{
				_chars.Slice(_pos, num2).Fill(' ');
			}
			else
			{
				_chars.Slice(startingPos, num).CopyTo(_chars.Slice(startingPos + num2));
				_chars.Slice(startingPos, num2).Fill(' ');
			}
			_pos += num2;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void EnsureCapacityForAdditionalChars(int additionalChars)
	{
		if (_chars.Length - _pos < additionalChars)
		{
			Grow(additionalChars);
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void GrowThenCopyString(string value)
	{
		Grow(value.Length);
		MemoryExtensions.AsSpan(value).CopyTo(_chars.Slice(_pos));
		_pos += value.Length;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void GrowThenCopySpan(ReadOnlySpan<char> value)
	{
		Grow(value.Length);
		value.CopyTo(_chars.Slice(_pos));
		_pos += value.Length;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void Grow(int additionalChars)
	{
		GrowCore((uint)(_pos + additionalChars));
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void Grow()
	{
		GrowCore((uint)(_chars.Length + 1));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void GrowCore(uint requiredMinCapacity)
	{
		int minimumLength = (int)MathEx.Clamp(Math.Max(requiredMinCapacity, Math.Min((uint)(_chars.Length * 2), uint.MaxValue)), 256u, 2147483647u);
		char[] array = ArrayPool<char>.Shared.Rent(minimumLength);
		_chars.Slice(0, _pos).CopyTo(array);
		char[] arrayToReturnToPool = _arrayToReturnToPool;
		_chars = (_arrayToReturnToPool = array);
		if (arrayToReturnToPool != null)
		{
			ArrayPool<char>.Shared.Return(arrayToReturnToPool);
		}
	}
}


using System;

[AttributeUsage(AttributeTargets.Assembly, Inherited = false, AllowMultiple = false)]
internal sealed class DisableRuntimeMarshallingAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
internal sealed class InterpolatedStringHandlerAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class InterpolatedStringHandlerArgumentAttribute : Attribute
{
	public string[] Arguments { get; }

	public InterpolatedStringHandlerArgumentAttribute(string argument)
	{
		Arguments = new string[1] { argument };
	}

	public InterpolatedStringHandlerArgumentAttribute(params string[] arguments)
	{
		Arguments = arguments;
	}
}


internal interface ITuple
{
	int Length { get; }

	object? this[int index] { get; }
}


using System;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
internal sealed class ModuleInitializerAttribute : Attribute
{
}


using System.Diagnostics.CodeAnalysis;

internal static class ExtraDynamicallyAccessedMemberTypes
{
	public const DynamicallyAccessedMemberTypes Interfaces = (DynamicallyAccessedMemberTypes)8192;
}


using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, Inherited = false)]
internal sealed class DynamicallyAccessedMembersAttribute : Attribute
{
	public DynamicallyAccessedMemberTypes MemberTypes { get; }

	public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes)
	{
		MemberTypes = memberTypes;
	}
}


using System;

[Flags]
internal enum DynamicallyAccessedMemberTypes
{
	None = 0,
	PublicParameterlessConstructor = 1,
	PublicConstructors = 3,
	NonPublicConstructors = 4,
	PublicMethods = 8,
	NonPublicMethods = 0x10,
	PublicFields = 0x20,
	NonPublicFields = 0x40,
	PublicNestedTypes = 0x80,
	NonPublicNestedTypes = 0x100,
	PublicProperties = 0x200,
	NonPublicProperties = 0x400,
	PublicEvents = 0x800,
	NonPublicEvents = 0x1000,
	All = -1
}


using System;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class UnscopedRefAttribute : Attribute
{
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogSpamStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogSpamStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Spam, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogTraceStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogTraceStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Trace, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogInfoStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogInfoStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Info, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogWarningStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogWarningStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Warning, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogErrorStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogErrorStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Error, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Reflection;
using MonoMod.Core;

[CLSCompliant(true)]
internal interface ICoreDetour : ICoreDetourBase, IDisposable
{
	MethodBase Source { get; }

	MethodBase Target { get; }
}


using System;

internal interface ICoreDetourBase : IDisposable
{
	bool IsApplied { get; }

	void Apply();

	void Undo();
}


using System;
using MonoMod.Core;

internal interface ICoreNativeDetour : ICoreDetourBase, IDisposable
{
	IntPtr Source { get; }

	IntPtr Target { get; }

	bool HasOrigEntrypoint { get; }

	IntPtr OrigEntrypoint { get; }
}


using System;
using MonoMod.Core;

[CLSCompliant(true)]
internal interface IDetourFactory
{
	ICoreDetour CreateDetour(CreateDetourRequest request);

	ICoreNativeDetour CreateNativeDetour(CreateNativeDetourRequest request);
}


using System;
using System.Reflection;

[CLSCompliant(true)]
internal readonly record struct CreateDetourRequest(MethodBase Source, MethodBase Target)
{
	public bool ApplyByDefault { get; set; } = true;
}


using System;

[CLSCompliant(true)]
internal readonly record struct CreateNativeDetourRequest(IntPtr Source, IntPtr Target)
{
	public bool ApplyByDefault { get; set; } = true;
}


using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using MonoMod.Core;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

[CLSCompliant(true)]
internal static class DetourFactory
{
	private static PlatformTripleDetourFactory? lazyCurrent;

	public unsafe static IDetourFactory Current
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return Helpers.GetOrInit(ref lazyCurrent, (delegate*<PlatformTripleDetourFactory>)(&CreateDefaultFactory));
		}
	}

	private static PlatformTripleDetourFactory CreateDefaultFactory()
	{
		return new PlatformTripleDetourFactory(PlatformTriple.Current);
	}

	public static ICoreDetour CreateDetour(this IDetourFactory factory, MethodBase source, MethodBase target, bool applyByDefault = true)
	{
		Helpers.ThrowIfArgumentNull(factory, "factory");
		return factory.CreateDetour(new CreateDetourRequest(source, target)
		{
			ApplyByDefault = applyByDefault
		});
	}

	public static ICoreNativeDetour CreateNativeDetour(this IDetourFactory factory, IntPtr source, IntPtr target, bool applyByDefault = true)
	{
		Helpers.ThrowIfArgumentNull(factory, "factory");
		return factory.CreateNativeDetour(new CreateNativeDetourRequest(source, target)
		{
			ApplyByDefault = applyByDefault
		});
	}
}


internal static class AssemblyInfo
{
	public const string AssemblyName = "MonoMod.Core";

	public const string AssemblyVersion = "1.1.0";
}


using System;

[Flags]
internal enum AddressKind
{
	Rel32 = 0,
	Rel64 = 2,
	Abs32 = 1,
	Abs64 = 3,
	PrecodeFixupThunkRel32 = 4,
	PrecodeFixupThunkRel64 = 6,
	PrecodeFixupThunkAbs32 = 5,
	PrecodeFixupThunkAbs64 = 7,
	Indirect = 8
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Utils;
using MonoMod.Logs;

internal static class AddressKindExtensions
{
	public const AddressKind IsAbsoluteField = AddressKind.Abs32;

	public const AddressKind Is64BitField = AddressKind.Rel64;

	public const AddressKind IsPrecodeFixupField = AddressKind.PrecodeFixupThunkRel32;

	public const AddressKind IsIndirectField = AddressKind.Indirect;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsRelative(this AddressKind value)
	{
		return (value & AddressKind.Abs32) == 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsAbsolute(this AddressKind value)
	{
		return !value.IsRelative();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Is32Bit(this AddressKind value)
	{
		return (value & AddressKind.Rel64) == 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Is64Bit(this AddressKind value)
	{
		return !value.Is32Bit();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsPrecodeFixup(this AddressKind value)
	{
		return (value & AddressKind.PrecodeFixupThunkRel32) != 0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsIndirect(this AddressKind value)
	{
		return (value & AddressKind.Indirect) != 0;
	}

	public static void Validate(this AddressKind value, [CallerArgumentExpression("value")] string argName = "")
	{
		if ((value & ~(AddressKind.PrecodeFixupThunkAbs64 | AddressKind.Indirect)) != 0)
		{
			throw new ArgumentOutOfRangeException(argName);
		}
	}

	public static string FastToString(this AddressKind value)
	{
		FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(0, 4);
		handler.AppendFormatted(value.IsPrecodeFixup() ? "PrecodeFixupThunk" : "");
		handler.AppendFormatted(value.IsRelative() ? "Rel" : "Abs");
		handler.AppendFormatted(value.Is32Bit() ? "32" : "64");
		handler.AppendFormatted(value.IsIndirect() ? "Indirect" : "");
		return DebugFormatter.Format(ref handler);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Utils;
using MonoMod.Logs;

internal readonly struct AddressMeaning : IEquatable<AddressMeaning>
{
	public AddressKind Kind { get; }

	public int RelativeToOffset { get; }

	public AddressMeaning(AddressKind kind)
	{
		kind.Validate("kind");
		if (!kind.IsAbsolute())
		{
			throw new ArgumentOutOfRangeException("kind");
		}
		Kind = kind;
		RelativeToOffset = 0;
	}

	public AddressMeaning(AddressKind kind, int relativeOffset)
	{
		kind.Validate("kind");
		if (!kind.IsRelative())
		{
			throw new ArgumentOutOfRangeException("kind");
		}
		if (relativeOffset < 0)
		{
			throw new ArgumentOutOfRangeException("relativeOffset");
		}
		Kind = kind;
		RelativeToOffset = relativeOffset;
	}

	private unsafe static nint DoProcessAddress(AddressKind kind, nint basePtr, int offset, ulong address)
	{
		nint num;
		if (kind.IsAbsolute())
		{
			num = (nint)address;
		}
		else
		{
			long num2 = (kind.Is32Bit() ? Unsafe.As<ulong, int>(ref address) : Unsafe.As<ulong, long>(ref address));
			num = (nint)(basePtr + offset + num2);
		}
		if (kind.IsIndirect())
		{
			num = *(nint*)num;
		}
		return num;
	}

	public nint ProcessAddress(nint basePtr, int offset, ulong address)
	{
		return DoProcessAddress(Kind, basePtr, offset + RelativeToOffset, address);
	}

	public override bool Equals(object? obj)
	{
		if (obj is AddressMeaning other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(AddressMeaning other)
	{
		if (Kind == other.Kind)
		{
			return RelativeToOffset == other.RelativeToOffset;
		}
		return false;
	}

	public override string ToString()
	{
		FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(26, 2);
		handler.AppendLiteral("AddressMeaning(");
		handler.AppendFormatted(Kind.FastToString());
		handler.AppendLiteral(", offset: ");
		handler.AppendFormatted(RelativeToOffset);
		handler.AppendLiteral(")");
		return DebugFormatter.Format(ref handler);
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(Kind, RelativeToOffset);
	}

	public static bool operator ==(AddressMeaning left, AddressMeaning right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(AddressMeaning left, AddressMeaning right)
	{
		return !(left == right);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal sealed class BytePattern
{
	private enum SegmentKind
	{
		Literal,
		MaskedLiteral,
		Any,
		AnyRepeating,
		Address
	}

	private record struct PatternSegment(int Start, int Length, SegmentKind Kind)
	{
		public ReadOnlySpan<T> SliceOf<T>(ReadOnlySpan<T> span)
		{
			return span.Slice(Start, Length);
		}

		public ReadOnlyMemory<T> SliceOf<T>(ReadOnlyMemory<T> mem)
		{
			return mem.Slice(Start, Length);
		}
	}

	private readonly record struct ComputeSegmentsResult(PatternSegment[] Segments, int MinLen, int AddrBytes);

	private const ushort MaskMask = 65280;

	public const byte BAnyValue = 0;

	public const ushort SAnyValue = 65280;

	public const byte BAnyRepeatingValue = 1;

	public const ushort SAnyRepeatingValue = 65281;

	public const byte BAddressValue = 2;

	public const ushort SAddressValue = 65282;

	private readonly ReadOnlyMemory<byte> pattern;

	private readonly ReadOnlyMemory<byte> bitmask;

	private readonly PatternSegment[] segments;

	private (ReadOnlyMemory<byte> Bytes, int Offset)? lazyFirstLiteralSegment;

	public int AddressBytes { get; }

	public int MinLength { get; }

	public AddressMeaning AddressMeaning { get; }

	public bool MustMatchAtStart { get; }

	public (ReadOnlyMemory<byte> Bytes, int Offset) FirstLiteralSegment
	{
		get
		{
			(ReadOnlyMemory<byte>, int) valueOrDefault = lazyFirstLiteralSegment.GetValueOrDefault();
			if (!lazyFirstLiteralSegment.HasValue)
			{
				valueOrDefault = GetFirstLiteralSegment();
				lazyFirstLiteralSegment = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
	}

	public BytePattern(AddressMeaning meaning, params ushort[] pattern)
		: this(meaning, mustMatchAtStart: false, MemoryExtensions.AsMemory(pattern))
	{
	}

	public BytePattern(AddressMeaning meaning, bool mustMatchAtStart, params ushort[] pattern)
		: this(meaning, mustMatchAtStart, MemoryExtensions.AsMemory(pattern))
	{
	}

	public BytePattern(AddressMeaning meaning, ReadOnlyMemory<ushort> pattern)
		: this(meaning, mustMatchAtStart: false, pattern)
	{
	}

	public BytePattern(AddressMeaning meaning, bool mustMatchAtStart, ReadOnlyMemory<ushort> pattern)
	{
		AddressMeaning = meaning;
		MustMatchAtStart = mustMatchAtStart;
		ComputeSegmentsFromShort(pattern).Deconstruct(out PatternSegment[] Segments, out int MinLen, out int AddrBytes);
		segments = Segments;
		MinLength = MinLen;
		AddressBytes = AddrBytes;
		Memory<byte> memory = MemoryExtensions.AsMemory(new byte[pattern.Length * 2]);
		Memory<byte> memory2 = memory.Slice(0, pattern.Length);
		Memory<byte> memory3 = memory.Slice(pattern.Length);
		for (int i = 0; i < pattern.Length; i++)
		{
			ushort num = pattern.Span[i];
			byte b = (byte)((num & 0xFF00) >> 8);
			byte b2 = (byte)(num & -65281);
			if ((b == 0 || b == byte.MaxValue) ? true : false)
			{
				b = (byte)(~b);
			}
			memory2.Span[i] = (byte)(b2 & b);
			memory3.Span[i] = b;
		}
		this.pattern = memory2;
		bitmask = memory3;
	}

	public BytePattern(AddressMeaning meaning, ReadOnlyMemory<byte> mask, ReadOnlyMemory<byte> pattern)
		: this(meaning, mustMatchAtStart: false, mask, pattern)
	{
	}

	public BytePattern(AddressMeaning meaning, bool mustMatchAtStart, ReadOnlyMemory<byte> mask, ReadOnlyMemory<byte> pattern)
	{
		AddressMeaning = meaning;
		MustMatchAtStart = mustMatchAtStart;
		ComputeSegmentsFromMaskPattern(mask, pattern).Deconstruct(out PatternSegment[] Segments, out int MinLen, out int AddrBytes);
		segments = Segments;
		MinLength = MinLen;
		AddressBytes = AddrBytes;
		this.pattern = pattern;
		bitmask = mask;
	}

	private unsafe static ComputeSegmentsResult ComputeSegmentsFromShort(ReadOnlyMemory<ushort> pattern)
	{
		return ComputeSegmentsCore((delegate*<ReadOnlyMemory<ushort>, int, SegmentKind>)(&KindForShort), pattern.Length, pattern);
		static SegmentKind KindForShort(ReadOnlyMemory<ushort> pattern, int idx)
		{
			ushort num = pattern.Span[idx];
			switch (num & 0xFF00)
			{
			case 0:
				return SegmentKind.Literal;
			case 65280:
			{
				int num2 = num & 0xFF;
				return num2 switch
				{
					0 => SegmentKind.Any, 
					1 => SegmentKind.AnyRepeating, 
					2 => SegmentKind.Address, 
					_ => throw new ArgumentException($"Pattern contained unknown special value {num2:x2}", "pattern"), 
				};
			}
			default:
				return SegmentKind.MaskedLiteral;
			}
		}
	}

	private unsafe static ComputeSegmentsResult ComputeSegmentsFromMaskPattern(ReadOnlyMemory<byte> mask, ReadOnlyMemory<byte> pattern)
	{
		if (mask.Length < pattern.Length)
		{
			throw new ArgumentException("Mask buffer shorter than pattern", "mask");
		}
		return ComputeSegmentsCore((delegate*<(ReadOnlyMemory<byte>, ReadOnlyMemory<byte>), int, SegmentKind>)(&KindForIdx), pattern.Length, (mask, pattern));
		static SegmentKind KindForIdx((ReadOnlyMemory<byte> mask, ReadOnlyMemory<byte> pattern) t, int idx)
		{
			switch (t.mask.Span[idx])
			{
			case 0:
			{
				byte b = t.pattern.Span[idx];
				return b switch
				{
					0 => SegmentKind.Any, 
					1 => SegmentKind.AnyRepeating, 
					2 => SegmentKind.Address, 
					_ => throw new ArgumentException($"Pattern contained unknown special value {b:x2}", "pattern"), 
				};
			}
			case byte.MaxValue:
				return SegmentKind.Literal;
			default:
				return SegmentKind.MaskedLiteral;
			}
		}
	}

	private unsafe static ComputeSegmentsResult ComputeSegmentsCore<TPattern>(delegate*<TPattern, int, SegmentKind> kindForIdx, int patternLength, TPattern pattern)
	{
		if (patternLength == 0)
		{
			throw new ArgumentException("Pattern cannot be empty", "pattern");
		}
		int num = 0;
		SegmentKind segmentKind = SegmentKind.AnyRepeating;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = -1;
		for (int i = 0; i < patternLength; i++)
		{
			SegmentKind segmentKind2 = kindForIdx(pattern, i);
			int num6 = num4;
			num4 = num6 + segmentKind2 switch
			{
				SegmentKind.Literal => 1, 
				SegmentKind.MaskedLiteral => 1, 
				SegmentKind.Any => 1, 
				SegmentKind.AnyRepeating => 0, 
				SegmentKind.Address => 1, 
				_ => 0, 
			};
			if (segmentKind2 != segmentKind)
			{
				if (num5 < 0)
				{
					num5 = i;
				}
				num++;
				num2 = 1;
			}
			else
			{
				num2++;
			}
			if (segmentKind2 == SegmentKind.Address)
			{
				num3++;
			}
			segmentKind = segmentKind2;
		}
		if (num > 0 && segmentKind == SegmentKind.AnyRepeating)
		{
			num--;
		}
		if (num == 0 || num4 <= 0)
		{
			throw new ArgumentException("Pattern has no meaningful segments", "pattern");
		}
		PatternSegment[] array = new PatternSegment[num];
		num = 0;
		segmentKind = SegmentKind.AnyRepeating;
		num2 = 0;
		for (int j = num5; j < patternLength; j++)
		{
			if (num > array.Length)
			{
				break;
			}
			SegmentKind num7 = kindForIdx(pattern, j);
			if (num7 != segmentKind)
			{
				if (num > 0)
				{
					array[num - 1] = new PatternSegment(j - num2, num2, segmentKind);
					if (num > 1 && segmentKind == SegmentKind.Any && array[num - 2].Kind == SegmentKind.AnyRepeating)
					{
						Helpers.Swap(ref array[num - 2], ref array[num - 1]);
					}
				}
				num++;
				num2 = 1;
			}
			else
			{
				num2++;
			}
			segmentKind = num7;
		}
		if (segmentKind != SegmentKind.AnyRepeating && num > 0)
		{
			array[num - 1] = new PatternSegment(patternLength - num2, num2, segmentKind);
		}
		return new ComputeSegmentsResult(array, num4, num3);
	}

	public bool TryMatchAt(ReadOnlySpan<byte> data, out ulong address, out int length)
	{
		if (data.Length < MinLength)
		{
			length = 0;
			address = 0uL;
			return false;
		}
		ReadOnlySpan<byte> span = pattern.Span;
		Span<byte> addrBuf = stackalloc byte[8];
		bool result = TryMatchAtImpl(span, data, addrBuf, out length, 0);
		address = Unsafe.ReadUnaligned<ulong>(ref addrBuf[0]);
		return result;
	}

	public bool TryMatchAt(ReadOnlySpan<byte> data, Span<byte> addrBuf, out int length)
	{
		if (data.Length < MinLength)
		{
			length = 0;
			return false;
		}
		ReadOnlySpan<byte> span = pattern.Span;
		return TryMatchAtImpl(span, data, addrBuf, out length, 0);
	}

	private bool TryMatchAtImpl(ReadOnlySpan<byte> patternSpan, ReadOnlySpan<byte> data, Span<byte> addrBuf, out int length, int startAtSegment)
	{
		int num = 0;
		int num2 = startAtSegment;
		while (true)
		{
			if (num2 < segments.Length)
			{
				PatternSegment patternSegment = segments[num2];
				switch (patternSegment.Kind)
				{
				case SegmentKind.Literal:
					if (data.Length - num >= patternSegment.Length)
					{
						ReadOnlySpan<byte> span = patternSegment.SliceOf(patternSpan);
						if (span.SequenceEqual(data.Slice(num, span.Length)))
						{
							num += patternSegment.Length;
							goto IL_0192;
						}
					}
					break;
				case SegmentKind.MaskedLiteral:
					if (data.Length - num >= patternSegment.Length)
					{
						ReadOnlySpan<byte> first = patternSegment.SliceOf(patternSpan);
						ReadOnlySpan<byte> mask = patternSegment.SliceOf(bitmask.Span);
						if (Helpers.MaskedSequenceEqual(first, data.Slice(num, first.Length), mask))
						{
							num += patternSegment.Length;
							goto IL_0192;
						}
					}
					break;
				case SegmentKind.Any:
					if (data.Length - num >= patternSegment.Length)
					{
						num += patternSegment.Length;
						goto IL_0192;
					}
					break;
				case SegmentKind.Address:
					if (data.Length - num >= patternSegment.Length)
					{
						ReadOnlySpan<byte> readOnlySpan = data.Slice(num, Math.Min(patternSegment.Length, addrBuf.Length));
						readOnlySpan.CopyTo(addrBuf);
						addrBuf = addrBuf.Slice(Math.Min(addrBuf.Length, readOnlySpan.Length));
						num += patternSegment.Length;
						goto IL_0192;
					}
					break;
				case SegmentKind.AnyRepeating:
				{
					int offset;
					int length2;
					bool result = ScanForNextLiteral(patternSpan, data.Slice(num), addrBuf, out offset, out length2, num2);
					length = num + offset + length2;
					return result;
				}
				default:
					throw new InvalidOperationException();
				}
				break;
			}
			length = num;
			return true;
			IL_0192:
			num2++;
		}
		length = 0;
		return false;
	}

	public bool TryFindMatch(ReadOnlySpan<byte> data, out ulong address, out int offset, out int length)
	{
		if (data.Length < MinLength)
		{
			length = (offset = 0);
			address = 0uL;
			return false;
		}
		ReadOnlySpan<byte> span = pattern.Span;
		Span<byte> addrBuf = stackalloc byte[8];
		bool result;
		if (MustMatchAtStart)
		{
			offset = 0;
			result = TryMatchAtImpl(span, data, addrBuf, out length, 0);
		}
		else
		{
			result = ScanForNextLiteral(span, data, addrBuf, out offset, out length, 0);
		}
		address = Unsafe.ReadUnaligned<ulong>(ref addrBuf[0]);
		return result;
	}

	public bool TryFindMatch(ReadOnlySpan<byte> data, Span<byte> addrBuf, out int offset, out int length)
	{
		if (data.Length < MinLength)
		{
			length = (offset = 0);
			return false;
		}
		ReadOnlySpan<byte> span = pattern.Span;
		if (MustMatchAtStart)
		{
			offset = 0;
			return TryMatchAtImpl(span, data, addrBuf, out length, 0);
		}
		return ScanForNextLiteral(span, data, addrBuf, out offset, out length, 0);
	}

	private bool ScanForNextLiteral(ReadOnlySpan<byte> patternSpan, ReadOnlySpan<byte> data, Span<byte> addrBuf, out int offset, out int length, int segmentIndex)
	{
		var (patternSegment, num) = GetNextLiteralSegment(segmentIndex);
		if (num + patternSegment.Length > data.Length)
		{
			offset = (length = 0);
			return false;
		}
		int num2 = 0;
		while (true)
		{
			int num3 = data.Slice(num + num2).IndexOf(patternSegment.SliceOf(patternSpan));
			if (num3 < 0)
			{
				offset = (length = 0);
				return false;
			}
			if (TryMatchAtImpl(patternSpan, data.Slice(offset = num2 + num3), addrBuf, out length, segmentIndex))
			{
				break;
			}
			num2 += num3 + 1;
		}
		return true;
	}

	private (ReadOnlyMemory<byte> Bytes, int Offset) GetFirstLiteralSegment()
	{
		var (patternSegment, item) = GetNextLiteralSegment(0);
		return (Bytes: patternSegment.SliceOf(pattern), Offset: item);
	}

	private (PatternSegment Segment, int LiteralOffset) GetNextLiteralSegment(int segmentIndexId)
	{
		if (segmentIndexId < 0 || segmentIndexId >= segments.Length)
		{
			throw new ArgumentOutOfRangeException("segmentIndexId");
		}
		int num = 0;
		while (segmentIndexId < segments.Length)
		{
			PatternSegment item = segments[segmentIndexId];
			if (item.Kind == SegmentKind.Literal)
			{
				return (Segment: item, LiteralOffset: num);
			}
			SegmentKind kind = item.Kind;
			if (((uint)(kind - 1) <= 1u || kind == SegmentKind.Address) ? true : false)
			{
				num += item.Length;
			}
			else if (item.Kind != SegmentKind.AnyRepeating)
			{
				throw new InvalidOperationException("Unknown segment kind");
			}
			segmentIndexId++;
		}
		return (Segment: default(PatternSegment), LiteralOffset: num);
	}
}


private enum SegmentKind
{
	Literal,
	MaskedLiteral,
	Any,
	AnyRepeating,
	Address
}


using System;

private record struct PatternSegment(int Start, int Length, SegmentKind Kind)
{
	public ReadOnlySpan<T> SliceOf<T>(ReadOnlySpan<T> span)
	{
		return span.Slice(Start, Length);
	}

	public ReadOnlyMemory<T> SliceOf<T>(ReadOnlyMemory<T> mem)
	{
		return mem.Slice(Start, Length);
	}
}


private readonly record struct ComputeSegmentsResult(PatternSegment[] Segments, int MinLen, int AddrBytes);


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal sealed class BytePatternCollection : IEnumerable<BytePattern>, IEnumerable
{
	private struct HomogenousPatternCollection
	{
		public BytePattern[]?[] Lut;

		public readonly int Offset;

		public int MinLength;

		public HomogenousPatternCollection(int offs)
		{
			Offset = offs;
			Lut = null;
			MinLength = int.MaxValue;
		}

		public void AddFirstBytes(ref FirstByteCollection bytes)
		{
			for (int i = 0; i < Lut.Length; i++)
			{
				if (Lut[i] != null)
				{
					bytes.Add((byte)i);
				}
			}
		}
	}

	private ref struct FirstByteCollection
	{
		private Span<byte> firstByteStore;

		private Span<byte> byteIndicies;

		private int firstBytesRecorded;

		public const int SingleAllocationSize = 512;

		public ReadOnlySpan<byte> FirstBytes => firstByteStore.Slice(0, firstBytesRecorded);

		public FirstByteCollection(Span<byte> store)
			: this(store.Slice(0, 256), store.Slice(256, 256))
		{
		}

		public FirstByteCollection(Span<byte> store, Span<byte> indicies)
		{
			firstByteStore = store;
			byteIndicies = indicies;
			firstBytesRecorded = 0;
			byteIndicies.Fill(byte.MaxValue);
		}

		public void Add(byte value)
		{
			ref byte reference = ref byteIndicies[value];
			if (reference == byte.MaxValue)
			{
				reference = (byte)firstBytesRecorded;
				firstByteStore[reference] = value;
				firstBytesRecorded = Math.Min(firstBytesRecorded + 1, 256);
			}
		}
	}

	private readonly HomogenousPatternCollection[] patternCollections;

	private readonly BytePattern[]? emptyPatterns;

	private ReadOnlyMemory<byte>? lazyPossibleFirstBytes;

	public int MinLength { get; }

	public int MaxMinLength { get; }

	public int MaxAddressLength { get; }

	private ReadOnlyMemory<byte> PossibleFirstBytes
	{
		get
		{
			ReadOnlyMemory<byte> valueOrDefault = lazyPossibleFirstBytes.GetValueOrDefault();
			if (!lazyPossibleFirstBytes.HasValue)
			{
				valueOrDefault = GetPossibleFirstBytes();
				lazyPossibleFirstBytes = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
	}

	public BytePatternCollection(ReadOnlyMemory<BytePattern?> patterns)
	{
		int minLength;
		int maxMinLength;
		int maxAddrLength;
		(HomogenousPatternCollection[], BytePattern[]) tuple = ComputeLut(patterns, out minLength, out maxMinLength, out maxAddrLength);
		patternCollections = tuple.Item1;
		emptyPatterns = tuple.Item2;
		MinLength = minLength;
		MaxMinLength = maxMinLength;
		MaxAddressLength = maxAddrLength;
		Helpers.Assert(MinLength > 0, null, "MinLength > 0");
	}

	public BytePatternCollection(params BytePattern?[] patterns)
		: this(MemoryExtensions.AsMemory(patterns))
	{
	}

	public IEnumerator<BytePattern> GetEnumerator()
	{
		for (int i = 0; i < patternCollections.Length; i++)
		{
			BytePattern[]?[] coll = patternCollections[i].Lut;
			for (int j = 0; j < coll.Length; j++)
			{
				if (coll[j] != null)
				{
					BytePattern[] array = coll[j];
					for (int k = 0; k < array.Length; k++)
					{
						yield return array[k];
					}
				}
			}
		}
		if (emptyPatterns != null)
		{
			BytePattern[] array = emptyPatterns;
			for (int i = 0; i < array.Length; i++)
			{
				yield return array[i];
			}
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	private static (HomogenousPatternCollection[], BytePattern[]?) ComputeLut(ReadOnlyMemory<BytePattern?> patterns, out int minLength, out int maxMinLength, out int maxAddrLength)
	{
		if (patterns.Length == 0)
		{
			minLength = 0;
			maxMinLength = 0;
			maxAddrLength = 0;
			return (ArrayEx.Empty<HomogenousPatternCollection>(), null);
		}
		Span<int> span = stackalloc int[256];
		minLength = int.MaxValue;
		maxMinLength = int.MinValue;
		maxAddrLength = 0;
		int[][] array = null;
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < patterns.Length; i++)
		{
			BytePattern bytePattern = patterns.Span[i];
			if (bytePattern == null)
			{
				continue;
			}
			if (bytePattern.MinLength < minLength)
			{
				minLength = bytePattern.MinLength;
			}
			if (bytePattern.MinLength > maxMinLength)
			{
				maxMinLength = bytePattern.MinLength;
			}
			if (bytePattern.AddressBytes > maxAddrLength)
			{
				maxAddrLength = bytePattern.AddressBytes;
			}
			var (readOnlyMemory, num3) = bytePattern.FirstLiteralSegment;
			if (readOnlyMemory.Length == 0)
			{
				num++;
				continue;
			}
			num2 = 1;
			if (num3 == 0)
			{
				span[readOnlyMemory.Span[0]]++;
				continue;
			}
			if (array == null || array.Length < num3)
			{
				Array.Resize(ref array, num3);
			}
			ref int[] reference = ref array[num3 - 1];
			if (reference == null)
			{
				reference = new int[256];
			}
			reference[readOnlyMemory.Span[0]]++;
		}
		if (array != null)
		{
			int[][] array2 = array;
			for (int j = 0; j < array2.Length; j++)
			{
				if (array2[j] != null)
				{
					num2++;
				}
			}
		}
		BytePattern[] array3 = ((num > 0) ? new BytePattern[num] : null);
		int num4 = 0;
		HomogenousPatternCollection[] array4 = new HomogenousPatternCollection[num2];
		int num5 = 1;
		array4[0] = new HomogenousPatternCollection(0);
		for (int k = 0; k < patterns.Length; k++)
		{
			BytePattern bytePattern2 = patterns.Span[k];
			if (bytePattern2 == null)
			{
				continue;
			}
			var (readOnlyMemory2, num6) = bytePattern2.FirstLiteralSegment;
			if (readOnlyMemory2.Length == 0)
			{
				array3[num4++] = bytePattern2;
				continue;
			}
			int num7 = -1;
			for (int l = 0; l < array4.Length; l++)
			{
				if (array4[l].Offset == num6)
				{
					num7 = l;
					break;
				}
			}
			if (num7 == -1)
			{
				num7 = num5++;
				array4[num7] = new HomogenousPatternCollection(num6);
			}
			ReadOnlySpan<int> arrayCounts2 = ((num6 == 0) ? span : MemoryExtensions.AsSpan(array[num6 - 1]));
			AddToPatternCollection(ref array4[num7], arrayCounts2, bytePattern2);
			if (num7 > 0 && array4[num7 - 1].Offset > array4[num7].Offset)
			{
				Helpers.Swap(ref array4[num7 - 1], ref array4[num7]);
			}
		}
		return (array4, array3);
		static void AddToPatternCollection(ref HomogenousPatternCollection collection, ReadOnlySpan<int> arrayCounts, BytePattern pattern)
		{
			ReadOnlyMemory<byte> item = pattern.FirstLiteralSegment.Bytes;
			if (collection.Lut == null)
			{
				BytePattern[][] array5 = new BytePattern[256][];
				for (int m = 0; m < arrayCounts.Length; m++)
				{
					if (arrayCounts[m] > 0)
					{
						array5[m] = new BytePattern[arrayCounts[m]];
					}
				}
				collection.Lut = array5;
			}
			BytePattern[]? obj = collection.Lut[item.Span[0]];
			int num8 = Array.IndexOf(obj, null);
			obj[num8] = pattern;
			if (pattern.MinLength < collection.MinLength)
			{
				collection.MinLength = pattern.MinLength;
			}
		}
	}

	public bool TryMatchAt(ReadOnlySpan<byte> data, out ulong address, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out BytePattern matchingPattern, out int length)
	{
		if (data.Length < MinLength)
		{
			length = 0;
			address = 0uL;
			matchingPattern = null;
			return false;
		}
		Span<byte> addrBuf = stackalloc byte[8];
		bool result = TryMatchAt(data, addrBuf, out matchingPattern, out length);
		address = Unsafe.ReadUnaligned<ulong>(ref addrBuf[0]);
		return result;
	}

	public bool TryMatchAt(ReadOnlySpan<byte> data, Span<byte> addrBuf, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out BytePattern matchingPattern, out int length)
	{
		if (data.Length < MinLength)
		{
			length = 0;
			matchingPattern = null;
			return false;
		}
		for (int i = 0; i < patternCollections.Length; i++)
		{
			ref HomogenousPatternCollection reference = ref patternCollections[i];
			if (data.Length < reference.Offset + reference.MinLength)
			{
				continue;
			}
			byte b = data[reference.Offset];
			BytePattern[] array = reference.Lut[b];
			if (array == null)
			{
				continue;
			}
			BytePattern[] array2 = array;
			foreach (BytePattern bytePattern in array2)
			{
				if (bytePattern.TryMatchAt(data, addrBuf, out length))
				{
					matchingPattern = bytePattern;
					return true;
				}
			}
		}
		if (emptyPatterns != null)
		{
			BytePattern[] array2 = emptyPatterns;
			foreach (BytePattern bytePattern2 in array2)
			{
				if (bytePattern2.TryMatchAt(data, addrBuf, out length))
				{
					matchingPattern = bytePattern2;
					return true;
				}
			}
		}
		matchingPattern = null;
		length = 0;
		return false;
	}

	public bool TryFindMatch(ReadOnlySpan<byte> data, out ulong address, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out BytePattern matchingPattern, out int offset, out int length)
	{
		if (data.Length < MinLength)
		{
			length = (offset = 0);
			address = 0uL;
			matchingPattern = null;
			return false;
		}
		Span<byte> addrBuf = stackalloc byte[8];
		bool result = TryFindMatch(data, addrBuf, out matchingPattern, out offset, out length);
		address = Unsafe.ReadUnaligned<ulong>(ref addrBuf[0]);
		return result;
	}

	public bool TryFindMatch(ReadOnlySpan<byte> data, Span<byte> addrBuf, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out BytePattern matchingPattern, out int offset, out int length)
	{
		if (data.Length < MinLength)
		{
			length = (offset = 0);
			matchingPattern = null;
			return false;
		}
		ReadOnlySpan<byte> span = PossibleFirstBytes.Span;
		int num = 0;
		while (true)
		{
			int num2 = data.Slice(num).IndexOfAny(span);
			if (num2 < 0)
			{
				break;
			}
			offset = num + num2;
			byte b = data[offset];
			for (int i = 0; i < patternCollections.Length; i++)
			{
				ref HomogenousPatternCollection reference = ref patternCollections[i];
				if (offset < reference.Offset || data.Length < offset + reference.MinLength)
				{
					continue;
				}
				BytePattern[] array = reference.Lut[b];
				if (array == null)
				{
					continue;
				}
				BytePattern[] array2 = array;
				foreach (BytePattern bytePattern in array2)
				{
					if ((offset == 0 || !bytePattern.MustMatchAtStart) && bytePattern.TryMatchAt(data.Slice(offset - reference.Offset), addrBuf, out length))
					{
						offset -= reference.Offset;
						matchingPattern = bytePattern;
						return true;
					}
				}
			}
			num = offset + 1;
		}
		if (emptyPatterns != null)
		{
			BytePattern[] array2 = emptyPatterns;
			foreach (BytePattern bytePattern2 in array2)
			{
				if (bytePattern2.TryFindMatch(data, addrBuf, out offset, out length))
				{
					matchingPattern = bytePattern2;
					return true;
				}
			}
		}
		matchingPattern = null;
		offset = 0;
		length = 0;
		return false;
	}

	private ReadOnlyMemory<byte> GetPossibleFirstBytes()
	{
		Memory<byte> memory = MemoryExtensions.AsMemory(new byte[512]);
		FirstByteCollection bytes = new FirstByteCollection(memory.Span);
		for (int i = 0; i < patternCollections.Length; i++)
		{
			patternCollections[i].AddFirstBytes(ref bytes);
		}
		return memory.Slice(0, bytes.FirstBytes.Length);
	}
}


private struct HomogenousPatternCollection
{
	public BytePattern[]?[] Lut;

	public readonly int Offset;

	public int MinLength;

	public HomogenousPatternCollection(int offs)
	{
		Offset = offs;
		Lut = null;
		MinLength = int.MaxValue;
	}

	public void AddFirstBytes(ref FirstByteCollection bytes)
	{
		for (int i = 0; i < Lut.Length; i++)
		{
			if (Lut[i] != null)
			{
				bytes.Add((byte)i);
			}
		}
	}
}


using System;

private ref struct FirstByteCollection
{
	private Span<byte> firstByteStore;

	private Span<byte> byteIndicies;

	private int firstBytesRecorded;

	public const int SingleAllocationSize = 512;

	public ReadOnlySpan<byte> FirstBytes => firstByteStore.Slice(0, firstBytesRecorded);

	public FirstByteCollection(Span<byte> store)
		: this(store.Slice(0, 256), store.Slice(256, 256))
	{
	}

	public FirstByteCollection(Span<byte> store, Span<byte> indicies)
	{
		firstByteStore = store;
		byteIndicies = indicies;
		firstBytesRecorded = 0;
		byteIndicies.Fill(byte.MaxValue);
	}

	public void Add(byte value)
	{
		ref byte reference = ref byteIndicies[value];
		if (reference == byte.MaxValue)
		{
			reference = (byte)firstBytesRecorded;
			firstByteStore[reference] = value;
			firstBytesRecorded = Math.Min(firstBytesRecorded + 1, 256);
		}
	}
}


using System;
using System.Collections.Generic;
using Iced.Intel;

internal static class IcedExtensions
{
	[Obsolete("This method is not supported.", true)]
	public static string FormatInsns(this IList<Instruction> insns)
	{
		throw new NotSupportedException();
	}

	[Obsolete("This method is not supported.", true)]
	public static string FormatInsns(this InstructionList insns)
	{
		throw new NotSupportedException();
	}
}


internal interface IInitialize
{
	void Initialize();
}


internal interface IInitialize<T>
{
	void Initialize(T value);
}


internal enum TypeClassification
{
	InRegister,
	ByReference,
	OnStack
}


using System;
using MonoMod.Core.Platforms;

internal delegate TypeClassification Classifier(Type type, bool isReturn);


internal enum SpecialArgumentKind
{
	ThisPointer,
	ReturnBuffer,
	GenericContext,
	UserArguments
}


using System;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal readonly record struct Abi(ReadOnlyMemory<SpecialArgumentKind> ArgumentOrder, Classifier Classifier, bool ReturnsReturnBuffer)
{
	public TypeClassification Classify(Type type, bool isReturn)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		if (type == typeof(void))
		{
			return TypeClassification.InRegister;
		}
		if (!type.IsValueType)
		{
			return TypeClassification.InRegister;
		}
		if (type.IsPointer)
		{
			return TypeClassification.InRegister;
		}
		if (type.IsByRef)
		{
			return TypeClassification.InRegister;
		}
		return Classifier(type, isReturn);
	}
}


using System;

[Flags]
internal enum ArchitectureFeature
{
	None = 0,
	FixedInstructionSize = 1,
	Immediate64 = 2,
	CreateAltEntryPoint = 4
}


using System;
using MonoMod.Core.Platforms;

internal readonly struct FeatureFlags : IEquatable<FeatureFlags>
{
	public ArchitectureFeature Architecture { get; }

	public SystemFeature System { get; }

	public RuntimeFeature Runtime { get; }

	public FeatureFlags(ArchitectureFeature archFlags, SystemFeature sysFlags, RuntimeFeature runtimeFlags)
	{
		Runtime = runtimeFlags;
		Architecture = archFlags;
		System = sysFlags;
	}

	public bool Has(RuntimeFeature feature)
	{
		return (Runtime & feature) == feature;
	}

	public bool Has(ArchitectureFeature feature)
	{
		return (Architecture & feature) == feature;
	}

	public bool Has(SystemFeature feature)
	{
		return (System & feature) == feature;
	}

	public override bool Equals(object? obj)
	{
		if (obj is FeatureFlags other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(FeatureFlags other)
	{
		if (Runtime == other.Runtime && Architecture == other.Architecture)
		{
			return System == other.System;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(Runtime, Architecture, System);
	}

	public override string ToString()
	{
		return $"({Architecture})({System})({Runtime})";
	}

	public static bool operator ==(FeatureFlags left, FeatureFlags right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(FeatureFlags left, FeatureFlags right)
	{
		return !(left == right);
	}
}


using System;

internal interface IAltEntryFactory
{
	IntPtr CreateAlternateEntrypoint(IntPtr entrypoint, int minLength, out IDisposable? handle);
}


using System;
using MonoMod.Core.Platforms;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal interface IArchitecture
{
	ArchitectureKind Target { get; }

	ArchitectureFeature Features { get; }

	BytePatternCollection KnownMethodThunks { get; }

	IAltEntryFactory AltEntryFactory { get; }

	NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr target, int maxSizeHint = -1);

	int GetDetourBytes(NativeDetourInfo info, Span<byte> buffer, out IDisposable? allocationHandle);

	NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr target, int maxSizeHint = -1);

	int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span<byte> buffer, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc);

	ReadOnlyMemory<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize);

	IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument);
}


internal interface INativeDetourKind
{
	int Size { get; }
}


using System;
using MonoMod.Core.Platforms;

internal readonly record struct NativeDetourInfo(IntPtr From, IntPtr To, INativeDetourKind InternalKind, IDisposable? InternalData)
{
	public int Size => InternalKind.Size;
}


using System.Diagnostics.CodeAnalysis;
using MonoMod.Core.Platforms;

internal interface IMemoryAllocator
{
	int MaxSize { get; }

	bool TryAllocate(AllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated);

	bool TryAllocateInRange(PositionedAllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated);
}


using System.Runtime.CompilerServices;

internal readonly record struct AllocationRequest
{
	public int Size { get; set; }

	public int Alignment { get; set; }

	public bool Executable { get; set; }

	public AllocationRequest(int Size)
	{
		Executable = false;
		this.Size = Size;
		Alignment = 8;
	}

	[CompilerGenerated]
	public void Deconstruct(out int Size)
	{
		Size = this.Size;
	}
}


using System;
using MonoMod.Core.Platforms;

internal readonly record struct PositionedAllocationRequest(IntPtr Target, IntPtr LowBound, IntPtr HighBound, AllocationRequest Base);


using System;

internal interface IAllocatedMemory : IDisposable
{
	bool IsExecutable { get; }

	IntPtr BaseAddress { get; }

	int Size { get; }

	Span<byte> Memory { get; }
}


using System;
using MonoMod.Core.Platforms;

internal interface INativeExceptionHelper
{
	GetExceptionSlot GetExceptionSlot { get; }

	IntPtr CreateNativeToManagedHelper(IntPtr target, out IDisposable? handle);

	IntPtr CreateManagedToNativeHelper(IntPtr target, out IDisposable? handle);
}


using System;

internal unsafe delegate IntPtr* GetExceptionSlot();


using System;
using System.Reflection;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal interface IRuntime
{
	RuntimeKind Target { get; }

	RuntimeFeature Features { get; }

	Abi Abi { get; }

	event OnMethodCompiledCallback? OnMethodCompiled;

	MethodBase GetIdentifiable(MethodBase method);

	RuntimeMethodHandle GetMethodHandle(MethodBase method);

	void DisableInlining(MethodBase method);

	IDisposable? PinMethodIfNeeded(MethodBase method);

	IntPtr GetMethodEntryPoint(MethodBase method);

	void Compile(MethodBase method);
}


using System;
using System.Reflection;

internal delegate void OnMethodCompiledCallback(RuntimeMethodHandle methodHandle, MethodBase? method, IntPtr codeStart, IntPtr codeRw, ulong codeSize);


using System;
using System.Collections.Generic;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal interface ISystem
{
	OSKind Target { get; }

	SystemFeature Features { get; }

	Abi? DefaultAbi { get; }

	IMemoryAllocator MemoryAllocator { get; }

	INativeExceptionHelper? NativeExceptionHelper { get; }

	IEnumerable<string?> EnumerateLoadedModuleFiles();

	nint GetSizeOfReadableMemory(IntPtr start, nint guess);

	void PatchData(PatchTargetKind targetKind, IntPtr patchTarget, ReadOnlySpan<byte> data, Span<byte> backup);
}


internal enum PatchTargetKind
{
	Executable,
	ReadOnly
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Architectures;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Core.Platforms.Systems;
using MonoMod.Core.Utils;
using MonoMod.Logs;
using MonoMod.Utils;

internal sealed class PlatformTriple
{
	public record struct NativeDetour(SimpleNativeDetour Simple, IntPtr AltEntry, IDisposable? AltHandle)
	{
		public bool HasAltEntry => AltEntry != IntPtr.Zero;
	}

	private static object lazyCurrentLock = new object();

	private static PlatformTriple? lazyCurrent;

	private IntPtr ThePreStub = IntPtr.Zero;

	public IArchitecture Architecture { get; }

	public ISystem System { get; }

	public IRuntime Runtime { get; }

	public unsafe static PlatformTriple Current => Helpers.GetOrInitWithLock(ref lazyCurrent, lazyCurrentLock, (delegate*<PlatformTriple>)(&CreateCurrent));

	public (ArchitectureKind Arch, OSKind OS, RuntimeKind Runtime) HostTriple => (Arch: Architecture.Target, OS: System.Target, Runtime: Runtime.Target);

	public FeatureFlags SupportedFeatures { get; }

	public Abi Abi { get; }

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public static IRuntime CreateCurrentRuntime(ISystem system, IArchitecture arch)
	{
		Helpers.ThrowIfArgumentNull(system, "system");
		Helpers.ThrowIfArgumentNull(arch, "arch");
		RuntimeKind runtime = PlatformDetection.Runtime;
		return runtime switch
		{
			RuntimeKind.Framework => FxBaseRuntime.CreateForVersion(PlatformDetection.RuntimeVersion, system), 
			RuntimeKind.CoreCLR => CoreBaseRuntime.CreateForVersion(PlatformDetection.RuntimeVersion, system, arch), 
			RuntimeKind.Mono => new MonoRuntime(system), 
			_ => throw new PlatformNotSupportedException($"Runtime kind {runtime} not supported"), 
		};
	}

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public static IArchitecture CreateCurrentArchitecture(ISystem system)
	{
		Helpers.ThrowIfArgumentNull(system, "system");
		ArchitectureKind architecture = PlatformDetection.Architecture;
		return architecture switch
		{
			ArchitectureKind.x86 => new x86Arch(system), 
			ArchitectureKind.x86_64 => new x86_64Arch(system), 
			ArchitectureKind.Arm => throw new NotImplementedException(), 
			ArchitectureKind.Arm64 => throw new NotImplementedException(), 
			_ => throw new PlatformNotSupportedException($"Architecture kind {architecture} not supported"), 
		};
	}

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public static ISystem CreateCurrentSystem()
	{
		OSKind oS = PlatformDetection.OS;
		switch (oS)
		{
		case OSKind.Posix:
			throw new NotImplementedException();
		case OSKind.Linux:
			return new LinuxSystem();
		case OSKind.Android:
			throw new NotImplementedException();
		case OSKind.OSX:
			return new MacOSSystem();
		case OSKind.IOS:
			throw new NotImplementedException();
		case OSKind.BSD:
			throw new NotImplementedException();
		case OSKind.Windows:
		case OSKind.Wine:
			return new WindowsSystem();
		default:
			throw new PlatformNotSupportedException($"OS kind {oS} not supported");
		}
	}

	private static PlatformTriple CreateCurrent()
	{
		ISystem system = CreateCurrentSystem();
		IArchitecture architecture = CreateCurrentArchitecture(system);
		IRuntime runtime = CreateCurrentRuntime(system, architecture);
		return new PlatformTriple(architecture, system, runtime);
	}

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public static void SetPlatformTriple(PlatformTriple triple)
	{
		Helpers.ThrowIfArgumentNull(triple, "triple");
		if (lazyCurrent == null)
		{
			ThrowTripleAlreadyExists();
		}
		lock (lazyCurrentLock)
		{
			if (lazyCurrent == null)
			{
				ThrowTripleAlreadyExists();
			}
			lazyCurrent = triple;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static void ThrowTripleAlreadyExists()
	{
		throw new InvalidOperationException("The platform triple has already been initialized; cannot set a new one");
	}

	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public PlatformTriple(IArchitecture architecture, ISystem system, IRuntime runtime)
	{
		Helpers.ThrowIfArgumentNull(architecture, "architecture");
		Helpers.ThrowIfArgumentNull(system, "system");
		Helpers.ThrowIfArgumentNull(runtime, "runtime");
		Architecture = architecture;
		System = system;
		Runtime = runtime;
		SupportedFeatures = new FeatureFlags(Architecture.Features, System.Features, Runtime.Features);
		InitIfNeeded(Architecture);
		InitIfNeeded(System);
		InitIfNeeded(Runtime);
		Abi = Runtime.Abi;
	}

	private void InitIfNeeded(object obj)
	{
		(obj as IInitialize<ISystem>)?.Initialize(System);
		(obj as IInitialize<IArchitecture>)?.Initialize(Architecture);
		(obj as IInitialize<IRuntime>)?.Initialize(Runtime);
		(obj as IInitialize<PlatformTriple>)?.Initialize(this);
		(obj as IInitialize)?.Initialize();
	}

	public void Compile(MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (method.IsGenericMethodDefinition)
		{
			throw new ArgumentException("Cannot prepare generic method definition", "method");
		}
		method = GetIdentifiable(method);
		if (SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.RequiresCustomMethodCompile))
		{
			Runtime.Compile(method);
			return;
		}
		RuntimeMethodHandle methodHandle = Runtime.GetMethodHandle(method);
		if (method.IsGenericMethod)
		{
			Type[] genericArguments = method.GetGenericArguments();
			RuntimeTypeHandle[] array = new RuntimeTypeHandle[genericArguments.Length];
			for (int i = 0; i < genericArguments.Length; i++)
			{
				array[i] = genericArguments[i].TypeHandle;
			}
			RuntimeHelpers.PrepareMethod(methodHandle, array);
		}
		else
		{
			RuntimeHelpers.PrepareMethod(methodHandle);
		}
	}

	public MethodBase GetIdentifiable(MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.RequiresMethodIdentification))
		{
			method = Runtime.GetIdentifiable(method);
		}
		if (method.ReflectedType != method.DeclaringType)
		{
			ParameterInfo[] parameters = method.GetParameters();
			Type[] array = new Type[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				array[i] = parameters[i].ParameterType;
			}
			bool isEnabled;
			AssertionInterpolatedStringHandler message;
			bool isEnabled2;
			if ((object)method.DeclaringType == null)
			{
				MethodInfo? method2 = method.Module.GetMethod(method.Name, (BindingFlags)(-1), null, method.CallingConvention, array, null);
				isEnabled = (object)method2 != null;
				bool value = isEnabled;
				message = new AssertionInterpolatedStringHandler(16, 2, isEnabled, out isEnabled2);
				if (isEnabled2)
				{
					message.AppendLiteral("orig: ");
					message.AppendFormatted(method);
					message.AppendLiteral(", module: ");
					message.AppendFormatted(method.Module);
				}
				Helpers.Assert(value, ref message, "got is not null");
				method = method2;
			}
			else if (method.IsConstructor)
			{
				ConstructorInfo? constructor = method.DeclaringType.GetConstructor((BindingFlags)(-1), null, method.CallingConvention, array, null);
				isEnabled2 = (object)constructor != null;
				bool value2 = isEnabled2;
				message = new AssertionInterpolatedStringHandler(6, 1, isEnabled2, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("orig: ");
					message.AppendFormatted(method);
				}
				Helpers.Assert(value2, ref message, "got is not null");
				method = constructor;
			}
			else
			{
				MethodInfo? method3 = method.DeclaringType.GetMethod(method.Name, (BindingFlags)(-1), null, method.CallingConvention, array, null);
				isEnabled = (object)method3 != null;
				bool value3 = isEnabled;
				message = new AssertionInterpolatedStringHandler(6, 1, isEnabled, out isEnabled2);
				if (isEnabled2)
				{
					message.AppendLiteral("orig: ");
					message.AppendFormatted(method);
				}
				Helpers.Assert(value3, ref message, "got is not null");
				method = method3;
			}
		}
		return method;
	}

	public IDisposable? PinMethodIfNeeded(MethodBase method)
	{
		if (SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.RequiresMethodPinning))
		{
			return Runtime.PinMethodIfNeeded(method);
		}
		return null;
	}

	public bool TryDisableInlining(MethodBase method)
	{
		if (SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.DisableInlining))
		{
			Runtime.DisableInlining(method);
			return true;
		}
		return false;
	}

	public SimpleNativeDetour CreateSimpleDetour(IntPtr from, IntPtr to, int detourMaxSize = -1, IntPtr fromRw = default(IntPtr))
	{
		if (fromRw == (IntPtr)0)
		{
			fromRw = from;
		}
		bool flag = from != to;
		bool isEnabled;
		AssertionInterpolatedStringHandler message = new AssertionInterpolatedStringHandler(48, 2, flag, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Cannot detour a method to itself! (from: ");
			message.AppendFormatted(from);
			message.AppendLiteral(", to: ");
			message.AppendFormatted(to);
			message.AppendLiteral(")");
		}
		Helpers.Assert(flag, ref message, "from != to");
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(31, 2, out isEnabled);
		if (isEnabled)
		{
			message2.AppendLiteral("Creating simple detour 0x");
			message2.AppendFormatted(from, "x16");
			message2.AppendLiteral(" => 0x");
			message2.AppendFormatted(to, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
		NativeDetourInfo nativeDetourInfo = Architecture.ComputeDetourInfo(from, to, detourMaxSize);
		Span<byte> span = stackalloc byte[nativeDetourInfo.Size];
		Architecture.GetDetourBytes(nativeDetourInfo, span, out IDisposable allocationHandle);
		byte[] array = new byte[nativeDetourInfo.Size];
		System.PatchData(PatchTargetKind.Executable, fromRw, span, array);
		return new SimpleNativeDetour(this, nativeDetourInfo, array, allocationHandle);
	}

	public NativeDetour CreateNativeDetour(IntPtr from, IntPtr to, int detourMaxSize = -1, IntPtr fromRw = default(IntPtr))
	{
		if (fromRw == (IntPtr)0)
		{
			fromRw = from;
		}
		bool flag = from != to;
		bool isEnabled;
		AssertionInterpolatedStringHandler message = new AssertionInterpolatedStringHandler(48, 2, flag, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Cannot detour a method to itself! (from: ");
			message.AppendFormatted(from);
			message.AppendLiteral(", to: ");
			message.AppendFormatted(to);
			message.AppendLiteral(")");
		}
		Helpers.Assert(flag, ref message, "from != to");
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(31, 2, out isEnabled);
		if (isEnabled)
		{
			message2.AppendLiteral("Creating simple detour 0x");
			message2.AppendFormatted(from, "x16");
			message2.AppendLiteral(" => 0x");
			message2.AppendFormatted(to, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
		NativeDetourInfo nativeDetourInfo = Architecture.ComputeDetourInfo(from, to, detourMaxSize);
		Span<byte> span = stackalloc byte[nativeDetourInfo.Size];
		IDisposable allocationHandle;
		int detourBytes = Architecture.GetDetourBytes(nativeDetourInfo, span, out allocationHandle);
		IntPtr altEntry = IntPtr.Zero;
		IDisposable handle = null;
		if (SupportedFeatures.Has(ArchitectureFeature.CreateAltEntryPoint))
		{
			altEntry = Architecture.AltEntryFactory.CreateAlternateEntrypoint(from, detourBytes, out handle);
		}
		else
		{
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message3 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(67, 2, out isEnabled);
			if (isEnabled)
			{
				message3.AppendLiteral("Cannot create alternate entry point for native detour (from: ");
				message3.AppendFormatted(from, "x16");
				message3.AppendLiteral(", to: ");
				message3.AppendFormatted(to, "x16");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message3);
		}
		byte[] array = new byte[nativeDetourInfo.Size];
		System.PatchData(PatchTargetKind.Executable, fromRw, span, array);
		return new NativeDetour(new SimpleNativeDetour(this, nativeDetourInfo, array, allocationHandle), altEntry, handle);
	}

	public IntPtr GetNativeMethodBody(MethodBase method)
	{
		if (SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.RequiresBodyThunkWalking))
		{
			return GetNativeMethodBodyWalk(method, reloadPtr: true);
		}
		return GetNativeMethodBodyDirect(method);
	}

	private unsafe IntPtr GetNativeMethodBodyWalk(MethodBase method, bool reloadPtr)
	{
		bool flag = false;
		bool flag2 = false;
		int value = 0;
		BytePatternCollection knownMethodThunks = Architecture.KnownMethodThunks;
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(32, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Performing method body walk for ");
			message.AppendFormatted(method);
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		nint num = -1;
		while (true)
		{
			nint num2 = Runtime.GetMethodEntryPoint(method);
			message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(25, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Starting entry point = 0x");
				message.AppendFormatted(num2, "x16");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
			while (true)
			{
				if (value++ > 20)
				{
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(70, 4, out isEnabled);
					if (isEnabled)
					{
						message2.AppendLiteral("Could not get entry point for ");
						message2.AppendFormatted(method);
						message2.AppendLiteral("! (tried ");
						message2.AppendFormatted(value);
						message2.AppendLiteral(" times) entry: 0x");
						message2.AppendFormatted(num2, "x16");
						message2.AppendLiteral(" prevEntry: 0x");
						message2.AppendFormatted(num, "x16");
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message2);
					FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(47, 1);
					handler.AppendLiteral("Could not get entrypoint for ");
					handler.AppendFormatted(method);
					handler.AppendLiteral(" (stuck in a loop)");
					throw new NotSupportedException(DebugFormatter.Format(ref handler));
				}
				if (flag2 || num != num2)
				{
					num = num2;
					nint sizeOfReadableMemory = System.GetSizeOfReadableMemory(num2, knownMethodThunks.MaxMinLength);
					if (sizeOfReadableMemory <= 0)
					{
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message3 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(43, 2, out isEnabled);
						if (isEnabled)
						{
							message3.AppendLiteral("Got zero or negative readable length ");
							message3.AppendFormatted(sizeOfReadableMemory);
							message3.AppendLiteral(" at 0x");
							message3.AppendFormatted(num2, "x16");
						}
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message3);
					}
					ReadOnlySpan<byte> data = new ReadOnlySpan<byte>((void*)num2, Math.Min((int)sizeOfReadableMemory, knownMethodThunks.MaxMinLength));
					if (knownMethodThunks.TryFindMatch(data, out ulong address, out BytePattern matchingPattern, out int offset, out int _))
					{
						IntPtr ptrGot = num2;
						flag2 = false;
						AddressMeaning addressMeaning = matchingPattern.AddressMeaning;
						message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(46, 4, out isEnabled);
						if (isEnabled)
						{
							message.AppendLiteral("Matched thunk with ");
							message.AppendFormatted(addressMeaning);
							message.AppendLiteral(" at 0x");
							message.AppendFormatted(num2, "x16");
							message.AppendLiteral(" (addr: 0x");
							message.AppendFormatted(address, "x8");
							message.AppendLiteral(", offset: ");
							message.AppendFormatted(offset);
							message.AppendLiteral(")");
						}
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
						if (addressMeaning.Kind.IsPrecodeFixup() && !flag)
						{
							nint num3 = addressMeaning.ProcessAddress(num2, offset, address);
							if (reloadPtr)
							{
								message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(56, 1, out isEnabled);
								if (isEnabled)
								{
									message.AppendLiteral("Method thunk reset; regenerating (PrecodeFixupThunk: 0x");
									message.AppendFormatted(num3, "X16");
									message.AppendLiteral(")");
								}
								<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
								Compile(method);
								flag2 = true;
								break;
							}
							num2 = num3;
						}
						else
						{
							num2 = addressMeaning.ProcessAddress(num2, offset, address);
						}
						message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(23, 1, out isEnabled);
						if (isEnabled)
						{
							message.AppendLiteral("Got next entry point 0x");
							message.AppendFormatted(num2, "x16");
						}
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
						num2 = NotThePreStub(ptrGot, num2, out var wasPreStub);
						if (wasPreStub && reloadPtr)
						{
							<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace("Matched ThePreStub");
							Compile(method);
							break;
						}
						continue;
					}
				}
				return num2;
			}
		}
	}

	private IntPtr GetNativeMethodBodyDirect(MethodBase method)
	{
		return Runtime.GetMethodEntryPoint(method);
	}

	private IntPtr NotThePreStub(IntPtr ptrGot, IntPtr ptrParsed, out bool wasPreStub)
	{
		if (ThePreStub == IntPtr.Zero)
		{
			ThePreStub = (IntPtr)(-2);
			IntPtr thePreStub = (from m in typeof(HttpWebRequest).Assembly.GetType("System.Net.Connection")?.GetMethods()
				group m by GetNativeMethodBodyWalk(m, reloadPtr: false)).First((IGrouping<IntPtr, MethodInfo> g) => g.Count() > 1).Key ?? ((IntPtr)(-1));
			ThePreStub = thePreStub;
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(14, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("ThePreStub: 0x");
				message.AppendFormatted(ThePreStub, "X16");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		}
		wasPreStub = ptrParsed == ThePreStub;
		if (!wasPreStub)
		{
			return ptrParsed;
		}
		return ptrGot;
	}

	public MethodBase GetRealDetourTarget(MethodBase from, MethodBase to)
	{
		Helpers.ThrowIfArgumentNull(from, "from");
		Helpers.ThrowIfArgumentNull(to, "to");
		to = GetIdentifiable(to);
		if (from is MethodInfo methodInfo && to is MethodInfo && !methodInfo.IsStatic && to.IsStatic)
		{
			Type returnType = methodInfo.ReturnType;
			if (Abi.Classify(returnType, isReturn: true) == TypeClassification.ByReference)
			{
				Type thisParamType = from.GetThisParamType();
				Type type = returnType.MakeByRefType();
				Type returnType2 = (Abi.ReturnsReturnBuffer ? type : typeof(void));
				int value = -1;
				int value2 = -1;
				int num = -1;
				ParameterInfo[] parameters = from.GetParameters();
				List<Type> list = new List<Type>();
				ReadOnlySpan<SpecialArgumentKind> span = Abi.ArgumentOrder.Span;
				for (int i = 0; i < span.Length; i++)
				{
					switch (span[i])
					{
					case SpecialArgumentKind.ThisPointer:
						value = list.Count;
						list.Add(thisParamType);
						break;
					case SpecialArgumentKind.ReturnBuffer:
						value2 = list.Count;
						list.Add(type);
						break;
					case SpecialArgumentKind.UserArguments:
						num = list.Count;
						list.AddRange(parameters.Select((ParameterInfo p) => p.ParameterType));
						break;
					}
				}
				FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(16, 2);
				handler.AppendLiteral("Glue:AbiFixup<");
				handler.AppendFormatted(from);
				handler.AppendLiteral(",");
				handler.AppendFormatted(to);
				handler.AppendLiteral(">");
				using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(DebugFormatter.Format(ref handler), returnType2, list.ToArray());
				dynamicMethodDefinition.Definition.ImplAttributes |= Mono.Cecil.MethodImplAttributes.NoInlining | Mono.Cecil.MethodImplAttributes.AggressiveOptimization;
				ILProcessor iLProcessor = dynamicMethodDefinition.GetILProcessor();
				iLProcessor.Emit(OpCodes.Ldarg, value2);
				iLProcessor.Emit(OpCodes.Ldarg, value);
				for (int j = 0; j < parameters.Length; j++)
				{
					iLProcessor.Emit(OpCodes.Ldarg, j + num);
				}
				iLProcessor.Emit(OpCodes.Call, iLProcessor.Body.Method.Module.ImportReference(to));
				iLProcessor.Emit(OpCodes.Stobj, iLProcessor.Body.Method.Module.ImportReference(returnType));
				if (Abi.ReturnsReturnBuffer)
				{
					iLProcessor.Emit(OpCodes.Ldarg, value2);
				}
				iLProcessor.Emit(OpCodes.Ret);
				return dynamicMethodDefinition.Generate();
			}
		}
		return to;
	}
}


using System;

public record struct NativeDetour(SimpleNativeDetour Simple, IntPtr AltEntry, IDisposable? AltHandle)
{
	public bool HasAltEntry => AltEntry != IntPtr.Zero;
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using MonoMod;
using MonoMod.Core;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal sealed class PlatformTripleDetourFactory : IDetourFactory
{
	private abstract class DetourBase : ICoreDetourBase, IDisposable
	{
		protected abstract class DetourBoxBase
		{
			public SimpleNativeDetour? Detour;

			protected readonly PlatformTriple Triple;

			protected readonly object Sync = new object();

			private bool applyDetours;

			private bool isApplying;

			public bool IsApplied
			{
				get
				{
					return Volatile.Read(in applyDetours);
				}
				set
				{
					Volatile.Write(ref applyDetours, value);
					Thread.MemoryBarrier();
				}
			}

			public bool IsApplying
			{
				get
				{
					return Volatile.Read(in isApplying);
				}
				set
				{
					Volatile.Write(ref isApplying, value);
					Thread.MemoryBarrier();
				}
			}

			protected DetourBoxBase(PlatformTriple triple)
			{
				Triple = triple;
				applyDetours = false;
				isApplying = false;
			}
		}

		protected readonly PlatformTriple Triple;

		protected DetourBoxBase DetourBox;

		private bool disposedValue;

		public bool IsApplied => DetourBox.IsApplied;

		protected DetourBase(PlatformTriple triple)
		{
			Triple = triple;
			DetourBox = null;
		}

		protected TBox GetDetourBox<TBox>() where TBox : DetourBoxBase
		{
			return Unsafe.As<TBox>(DetourBox);
		}

		protected static void ReplaceDetourInLock(DetourBoxBase nativeDetour, SimpleNativeDetour? newDetour, out SimpleNativeDetour? oldDetour)
		{
			Thread.MemoryBarrier();
			oldDetour = Interlocked.Exchange(ref nativeDetour.Detour, newDetour);
		}

		protected abstract SimpleNativeDetour CreateDetour();

		public void Apply()
		{
			lock (DetourBox)
			{
				if (IsApplied)
				{
					throw new InvalidOperationException("Cannot apply a detour which is already applied");
				}
				try
				{
					DetourBox.IsApplying = true;
					DetourBox.IsApplied = true;
					ReplaceDetourInLock(DetourBox, CreateDetour(), out SimpleNativeDetour _);
				}
				catch
				{
					DetourBox.IsApplied = false;
					throw;
				}
				finally
				{
					DetourBox.IsApplying = false;
				}
			}
		}

		protected abstract void BeforeUndo();

		protected abstract void AfterUndo();

		public void Undo()
		{
			lock (DetourBox)
			{
				if (!IsApplied)
				{
					throw new InvalidOperationException("Cannot undo a detour which is not applied");
				}
				try
				{
					DetourBox.IsApplying = true;
					UndoCore(out SimpleNativeDetour oldDetour);
					oldDetour?.Dispose();
				}
				finally
				{
					DetourBox.IsApplying = false;
				}
			}
		}

		private void UndoCore(out SimpleNativeDetour? oldDetour)
		{
			BeforeUndo();
			DetourBox.IsApplied = false;
			ReplaceDetourInLock(DetourBox, null, out oldDetour);
			AfterUndo();
		}

		protected abstract void BeforeDispose();

		private void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				BeforeDispose();
				lock (DetourBox)
				{
					UndoCore(out SimpleNativeDetour oldDetour);
					oldDetour?.Dispose();
				}
				disposedValue = true;
			}
		}

		~DetourBase()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}

	private sealed class Detour : DetourBase, ICoreDetour, ICoreDetourBase, IDisposable
	{
		private sealed class ManagedDetourBox : DetourBoxBase
		{
			private readonly MethodBase src;

			private readonly MethodBase target;

			public ManagedDetourBox(PlatformTriple triple, MethodBase src, MethodBase target)
				: base(triple)
			{
				this.src = src;
				this.target = target;
				Detour = null;
			}

			public void SubscribeCompileMethod()
			{
				AddRelatedDetour(src, this);
			}

			public void UnsubscribeCompileMethod()
			{
				RemoveRelatedDetour(src, this);
			}

			public void OnMethodCompiled(MethodBase method, IntPtr codeStart, IntPtr codeStartRw, ulong codeSize)
			{
				if (!base.IsApplied)
				{
					return;
				}
				method = Triple.GetIdentifiable(method);
				lock (Sync)
				{
					if (!base.IsApplied || base.IsApplying)
					{
						return;
					}
					bool isEnabled;
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(43, 4, out isEnabled);
					if (isEnabled)
					{
						message.AppendLiteral("Updating detour from ");
						message.AppendFormatted(src);
						message.AppendLiteral(" to ");
						message.AppendFormatted(target);
						message.AppendLiteral(" (recompiled ");
						message.AppendFormatted(method);
						message.AppendLiteral(" to ");
						message.AppendFormatted(codeStart, "x16");
						message.AppendLiteral(")");
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
					try
					{
						base.IsApplying = true;
						SimpleNativeDetour detour = Detour;
						IntPtr to;
						IntPtr from;
						IntPtr fromRw;
						if (detour != null)
						{
							_ = detour.Source;
							to = detour.Destination;
							from = codeStart;
							fromRw = codeStartRw;
						}
						else
						{
							from = codeStart;
							fromRw = codeStartRw;
							to = Triple.Runtime.GetMethodHandle(target).GetFunctionPointer();
						}
						SimpleNativeDetour newDetour = Triple.CreateSimpleDetour(from, to, (int)codeSize, fromRw);
						DetourBase.ReplaceDetourInLock(this, newDetour, out SimpleNativeDetour _);
					}
					finally
					{
						base.IsApplying = false;
					}
				}
			}
		}

		private sealed class RelatedDetourBag
		{
			public readonly MethodBase Method;

			public readonly List<ManagedDetourBox> RelatedDetours = new List<ManagedDetourBox>();

			public bool IsValid = true;

			public RelatedDetourBag(MethodBase method)
			{
				Method = method;
			}
		}

		private readonly MethodBase realTarget;

		private static readonly object subLock = new object();

		private static bool hasSubscribed;

		private static readonly ConcurrentDictionary<MethodBase, RelatedDetourBag> relatedDetours = new ConcurrentDictionary<MethodBase, RelatedDetourBag>();

		private IDisposable? srcPin;

		private IDisposable? dstPin;

		private new ManagedDetourBox DetourBox => GetDetourBox<ManagedDetourBox>();

		public MethodBase Source { get; }

		public MethodBase Target { get; }

		public Detour(PlatformTriple triple, MethodBase src, MethodBase dst)
			: base(triple)
		{
			Source = triple.GetIdentifiable(src);
			Target = dst;
			realTarget = triple.GetRealDetourTarget(src, dst);
			base.DetourBox = new ManagedDetourBox(triple, Source, realTarget);
			if (triple.SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.CompileMethodHook))
			{
				EnsureSubscribed(triple);
				DetourBox.SubscribeCompileMethod();
			}
		}

		private static void EnsureSubscribed(PlatformTriple triple)
		{
			if (Volatile.Read(in hasSubscribed))
			{
				return;
			}
			lock (subLock)
			{
				if (!Volatile.Read(in hasSubscribed))
				{
					Volatile.Write(ref hasSubscribed, value: true);
					triple.Runtime.OnMethodCompiled += OnMethodCompiled;
				}
			}
		}

		private static void AddRelatedDetour(MethodBase m, ManagedDetourBox cmh)
		{
			while (true)
			{
				RelatedDetourBag orAdd = relatedDetours.GetOrAdd(m, (MethodBase m) => new RelatedDetourBag(m));
				lock (orAdd)
				{
					if (!orAdd.IsValid)
					{
						continue;
					}
					orAdd.RelatedDetours.Add(cmh);
					if (orAdd.RelatedDetours.Count > 1)
					{
						bool isEnabled;
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(115, 1, out isEnabled);
						if (isEnabled)
						{
							message.AppendLiteral("Multiple related detours for method ");
							message.AppendFormatted(m);
							message.AppendLiteral("! This means that the method has been detoured twice. Detour cleanup will fail.");
						}
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
					}
					break;
				}
			}
		}

		private static void RemoveRelatedDetour(MethodBase m, ManagedDetourBox cmh)
		{
			if (relatedDetours.TryGetValue(m, out RelatedDetourBag value))
			{
				lock (value)
				{
					value.RelatedDetours.Remove(cmh);
					if (value.RelatedDetours.Count == 0)
					{
						value.IsValid = false;
						Helpers.Assert(relatedDetours.TryRemove(value.Method, out RelatedDetourBag _), null, "relatedDetours.TryRemove(related.Method, out _)");
					}
					return;
				}
			}
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(79, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Attempted to remove a related detour from method ");
				message.AppendFormatted(m);
				message.AppendLiteral(" which has no RelatedDetourBag");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
		}

		private static void OnMethodCompiled(RuntimeMethodHandle methodHandle, MethodBase? method, IntPtr codeStart, IntPtr codeStartRw, ulong codeSize)
		{
			if ((object)method == null)
			{
				return;
			}
			method = PlatformTriple.Current.GetIdentifiable(method);
			if (!relatedDetours.TryGetValue(method, out RelatedDetourBag value))
			{
				return;
			}
			lock (value)
			{
				foreach (ManagedDetourBox relatedDetour in value.RelatedDetours)
				{
					relatedDetour.OnMethodCompiled(method, codeStart, codeStartRw, codeSize);
				}
			}
		}

		protected override SimpleNativeDetour CreateDetour()
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(33, 2, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Applying managed detour from ");
				message.AppendFormatted(Source);
				message.AppendLiteral(" to ");
				message.AppendFormatted(realTarget);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
			srcPin = Triple.PinMethodIfNeeded(Source);
			dstPin = Triple.PinMethodIfNeeded(realTarget);
			Triple.Compile(Source);
			IntPtr nativeMethodBody = Triple.GetNativeMethodBody(Source);
			Triple.Compile(realTarget);
			IntPtr functionPointer = Triple.Runtime.GetMethodHandle(realTarget).GetFunctionPointer();
			return Triple.CreateSimpleDetour(nativeMethodBody, functionPointer, -1, (IntPtr)0);
		}

		protected override void BeforeUndo()
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(32, 2, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Undoing managed detour from ");
				message.AppendFormatted(Source);
				message.AppendLiteral(" to ");
				message.AppendFormatted(realTarget);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		}

		protected override void AfterUndo()
		{
			Interlocked.Exchange(ref srcPin, null)?.Dispose();
			Interlocked.Exchange(ref dstPin, null)?.Dispose();
		}

		protected override void BeforeDispose()
		{
			if (Triple.SupportedFeatures.Has(MonoMod.Core.Platforms.RuntimeFeature.CompileMethodHook))
			{
				DetourBox.UnsubscribeCompileMethod();
			}
		}
	}

	private sealed class NativeDetour : DetourBase, ICoreNativeDetour, ICoreDetourBase, IDisposable
	{
		private sealed class NativeDetourBox : DetourBoxBase
		{
			public readonly IntPtr From;

			public readonly IntPtr To;

			public NativeDetourBox(PlatformTriple triple, IntPtr from, IntPtr to)
				: base(triple)
			{
				From = from;
				To = to;
			}
		}

		private IDisposable? origHandle;

		public IntPtr Source => DetourBox.From;

		public IntPtr Target => DetourBox.To;

		public bool HasOrigEntrypoint => OrigEntrypoint != IntPtr.Zero;

		public IntPtr OrigEntrypoint { get; private set; }

		private new NativeDetourBox DetourBox => GetDetourBox<NativeDetourBox>();

		public NativeDetour(PlatformTriple triple, IntPtr from, IntPtr to)
			: base(triple)
		{
			base.DetourBox = new NativeDetourBox(triple, from, to);
		}

		protected override SimpleNativeDetour CreateDetour()
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(32, 2, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Applying native detour from ");
				message.AppendFormatted(Source, "x16");
				message.AppendLiteral(" to ");
				message.AppendFormatted(Target, "x16");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
			Triple.CreateNativeDetour(Source, Target, -1, (IntPtr)0).Deconstruct(out SimpleNativeDetour Simple, out IntPtr AltEntry, out IDisposable AltHandle);
			SimpleNativeDetour result = Simple;
			IntPtr origEntrypoint = AltEntry;
			IDisposable disposable = AltHandle;
			IDisposable? disposable2 = origHandle;
			AltHandle = disposable;
			disposable = disposable2;
			origHandle = AltHandle;
			OrigEntrypoint = origEntrypoint;
			return result;
		}

		protected override void BeforeUndo()
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(31, 2, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Undoing native detour from ");
				message.AppendFormatted(Source, "x16");
				message.AppendLiteral(" to ");
				message.AppendFormatted(Target, "x16");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		}

		protected override void AfterUndo()
		{
			OrigEntrypoint = IntPtr.Zero;
			origHandle?.Dispose();
			origHandle = null;
		}

		protected override void BeforeDispose()
		{
		}
	}

	private readonly PlatformTriple triple;

	public PlatformTripleDetourFactory(PlatformTriple triple)
	{
		this.triple = triple;
	}

	public ICoreDetour CreateDetour(CreateDetourRequest request)
	{
		Helpers.ThrowIfArgumentNull(request.Source, "request.Source");
		Helpers.ThrowIfArgumentNull(request.Target, "request.Target");
		if (!triple.TryDisableInlining(request.Source))
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(66, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Could not disable inlining of method ");
				message.AppendFormatted(request.Source);
				message.AppendLiteral("; detours may not be reliable");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
		}
		Detour detour = new Detour(triple, request.Source, request.Target);
		if (request.ApplyByDefault)
		{
			detour.Apply();
		}
		return detour;
	}

	public ICoreNativeDetour CreateNativeDetour(CreateNativeDetourRequest request)
	{
		NativeDetour nativeDetour = new NativeDetour(triple, request.Source, request.Target);
		if (request.ApplyByDefault)
		{
			nativeDetour.Apply();
		}
		return nativeDetour;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Threading;

private abstract class DetourBase : ICoreDetourBase, IDisposable
{
	protected abstract class DetourBoxBase
	{
		public SimpleNativeDetour? Detour;

		protected readonly PlatformTriple Triple;

		protected readonly object Sync = new object();

		private bool applyDetours;

		private bool isApplying;

		public bool IsApplied
		{
			get
			{
				return Volatile.Read(in applyDetours);
			}
			set
			{
				Volatile.Write(ref applyDetours, value);
				Thread.MemoryBarrier();
			}
		}

		public bool IsApplying
		{
			get
			{
				return Volatile.Read(in isApplying);
			}
			set
			{
				Volatile.Write(ref isApplying, value);
				Thread.MemoryBarrier();
			}
		}

		protected DetourBoxBase(PlatformTriple triple)
		{
			Triple = triple;
			applyDetours = false;
			isApplying = false;
		}
	}

	protected readonly PlatformTriple Triple;

	protected DetourBoxBase DetourBox;

	private bool disposedValue;

	public bool IsApplied => DetourBox.IsApplied;

	protected DetourBase(PlatformTriple triple)
	{
		Triple = triple;
		DetourBox = null;
	}

	protected TBox GetDetourBox<TBox>() where TBox : DetourBoxBase
	{
		return Unsafe.As<TBox>(DetourBox);
	}

	protected static void ReplaceDetourInLock(DetourBoxBase nativeDetour, SimpleNativeDetour? newDetour, out SimpleNativeDetour? oldDetour)
	{
		Thread.MemoryBarrier();
		oldDetour = Interlocked.Exchange(ref nativeDetour.Detour, newDetour);
	}

	protected abstract SimpleNativeDetour CreateDetour();

	public void Apply()
	{
		lock (DetourBox)
		{
			if (IsApplied)
			{
				throw new InvalidOperationException("Cannot apply a detour which is already applied");
			}
			try
			{
				DetourBox.IsApplying = true;
				DetourBox.IsApplied = true;
				ReplaceDetourInLock(DetourBox, CreateDetour(), out SimpleNativeDetour _);
			}
			catch
			{
				DetourBox.IsApplied = false;
				throw;
			}
			finally
			{
				DetourBox.IsApplying = false;
			}
		}
	}

	protected abstract void BeforeUndo();

	protected abstract void AfterUndo();

	public void Undo()
	{
		lock (DetourBox)
		{
			if (!IsApplied)
			{
				throw new InvalidOperationException("Cannot undo a detour which is not applied");
			}
			try
			{
				DetourBox.IsApplying = true;
				UndoCore(out SimpleNativeDetour oldDetour);
				oldDetour?.Dispose();
			}
			finally
			{
				DetourBox.IsApplying = false;
			}
		}
	}

	private void UndoCore(out SimpleNativeDetour? oldDetour)
	{
		BeforeUndo();
		DetourBox.IsApplied = false;
		ReplaceDetourInLock(DetourBox, null, out oldDetour);
		AfterUndo();
	}

	protected abstract void BeforeDispose();

	private void Dispose(bool disposing)
	{
		if (!disposedValue)
		{
			BeforeDispose();
			lock (DetourBox)
			{
				UndoCore(out SimpleNativeDetour oldDetour);
				oldDetour?.Dispose();
			}
			disposedValue = true;
		}
	}

	~DetourBase()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}


using System.Threading;

protected abstract class DetourBoxBase
{
	public SimpleNativeDetour? Detour;

	protected readonly PlatformTriple Triple;

	protected readonly object Sync = new object();

	private bool applyDetours;

	private bool isApplying;

	public bool IsApplied
	{
		get
		{
			return Volatile.Read(in applyDetours);
		}
		set
		{
			Volatile.Write(ref applyDetours, value);
			Thread.MemoryBarrier();
		}
	}

	public bool IsApplying
	{
		get
		{
			return Volatile.Read(in isApplying);
		}
		set
		{
			Volatile.Write(ref isApplying, value);
			Thread.MemoryBarrier();
		}
	}

	protected DetourBoxBase(PlatformTriple triple)
	{
		Triple = triple;
		applyDetours = false;
		isApplying = false;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using MonoMod.Utils;

private sealed class Detour : DetourBase, ICoreDetour, ICoreDetourBase, IDisposable
{
	private sealed class ManagedDetourBox : DetourBoxBase
	{
		private readonly MethodBase src;

		private readonly MethodBase target;

		public ManagedDetourBox(PlatformTriple triple, MethodBase src, MethodBase target)
			: base(triple)
		{
			this.src = src;
			this.target = target;
			Detour = null;
		}

		public void SubscribeCompileMethod()
		{
			AddRelatedDetour(src, this);
		}

		public void UnsubscribeCompileMethod()
		{
			RemoveRelatedDetour(src, this);
		}

		public void OnMethodCompiled(MethodBase method, IntPtr codeStart, IntPtr codeStartRw, ulong codeSize)
		{
			if (!base.IsApplied)
			{
				return;
			}
			method = Triple.GetIdentifiable(method);
			lock (Sync)
			{
				if (!base.IsApplied || base.IsApplying)
				{
					return;
				}
				bool isEnabled;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(43, 4, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Updating detour from ");
					message.AppendFormatted(src);
					message.AppendLiteral(" to ");
					message.AppendFormatted(target);
					message.AppendLiteral(" (recompiled ");
					message.AppendFormatted(method);
					message.AppendLiteral(" to ");
					message.AppendFormatted(codeStart, "x16");
					message.AppendLiteral(")");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
				try
				{
					base.IsApplying = true;
					SimpleNativeDetour detour = Detour;
					IntPtr to;
					IntPtr from;
					IntPtr fromRw;
					if (detour != null)
					{
						_ = detour.Source;
						to = detour.Destination;
						from = codeStart;
						fromRw = codeStartRw;
					}
					else
					{
						from = codeStart;
						fromRw = codeStartRw;
						to = Triple.Runtime.GetMethodHandle(target).GetFunctionPointer();
					}
					SimpleNativeDetour newDetour = Triple.CreateSimpleDetour(from, to, (int)codeSize, fromRw);
					DetourBase.ReplaceDetourInLock(this, newDetour, out SimpleNativeDetour _);
				}
				finally
				{
					base.IsApplying = false;
				}
			}
		}
	}

	private sealed class RelatedDetourBag
	{
		public readonly MethodBase Method;

		public readonly List<ManagedDetourBox> RelatedDetours = new List<ManagedDetourBox>();

		public bool IsValid = true;

		public RelatedDetourBag(MethodBase method)
		{
			Method = method;
		}
	}

	private readonly MethodBase realTarget;

	private static readonly object subLock = new object();

	private static bool hasSubscribed;

	private static readonly ConcurrentDictionary<MethodBase, RelatedDetourBag> relatedDetours = new ConcurrentDictionary<MethodBase, RelatedDetourBag>();

	private IDisposable? srcPin;

	private IDisposable? dstPin;

	private new ManagedDetourBox DetourBox => GetDetourBox<ManagedDetourBox>();

	public MethodBase Source { get; }

	public MethodBase Target { get; }

	public Detour(PlatformTriple triple, MethodBase src, MethodBase dst)
		: base(triple)
	{
		Source = triple.GetIdentifiable(src);
		Target = dst;
		realTarget = triple.GetRealDetourTarget(src, dst);
		base.DetourBox = new ManagedDetourBox(triple, Source, realTarget);
		if (triple.SupportedFeatures.Has(RuntimeFeature.CompileMethodHook))
		{
			EnsureSubscribed(triple);
			DetourBox.SubscribeCompileMethod();
		}
	}

	private static void EnsureSubscribed(PlatformTriple triple)
	{
		if (Volatile.Read(in hasSubscribed))
		{
			return;
		}
		lock (subLock)
		{
			if (!Volatile.Read(in hasSubscribed))
			{
				Volatile.Write(ref hasSubscribed, value: true);
				triple.Runtime.OnMethodCompiled += OnMethodCompiled;
			}
		}
	}

	private static void AddRelatedDetour(MethodBase m, ManagedDetourBox cmh)
	{
		while (true)
		{
			RelatedDetourBag orAdd = relatedDetours.GetOrAdd(m, (MethodBase m) => new RelatedDetourBag(m));
			lock (orAdd)
			{
				if (!orAdd.IsValid)
				{
					continue;
				}
				orAdd.RelatedDetours.Add(cmh);
				if (orAdd.RelatedDetours.Count > 1)
				{
					bool isEnabled;
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(115, 1, out isEnabled);
					if (isEnabled)
					{
						message.AppendLiteral("Multiple related detours for method ");
						message.AppendFormatted(m);
						message.AppendLiteral("! This means that the method has been detoured twice. Detour cleanup will fail.");
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
				}
				break;
			}
		}
	}

	private static void RemoveRelatedDetour(MethodBase m, ManagedDetourBox cmh)
	{
		if (relatedDetours.TryGetValue(m, out RelatedDetourBag value))
		{
			lock (value)
			{
				value.RelatedDetours.Remove(cmh);
				if (value.RelatedDetours.Count == 0)
				{
					value.IsValid = false;
					Helpers.Assert(relatedDetours.TryRemove(value.Method, out RelatedDetourBag _), null, "relatedDetours.TryRemove(related.Method, out _)");
				}
				return;
			}
		}
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(79, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Attempted to remove a related detour from method ");
			message.AppendFormatted(m);
			message.AppendLiteral(" which has no RelatedDetourBag");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
	}

	private static void OnMethodCompiled(RuntimeMethodHandle methodHandle, MethodBase? method, IntPtr codeStart, IntPtr codeStartRw, ulong codeSize)
	{
		if ((object)method == null)
		{
			return;
		}
		method = PlatformTriple.Current.GetIdentifiable(method);
		if (!relatedDetours.TryGetValue(method, out RelatedDetourBag value))
		{
			return;
		}
		lock (value)
		{
			foreach (ManagedDetourBox relatedDetour in value.RelatedDetours)
			{
				relatedDetour.OnMethodCompiled(method, codeStart, codeStartRw, codeSize);
			}
		}
	}

	protected override SimpleNativeDetour CreateDetour()
	{
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(33, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Applying managed detour from ");
			message.AppendFormatted(Source);
			message.AppendLiteral(" to ");
			message.AppendFormatted(realTarget);
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		srcPin = Triple.PinMethodIfNeeded(Source);
		dstPin = Triple.PinMethodIfNeeded(realTarget);
		Triple.Compile(Source);
		IntPtr nativeMethodBody = Triple.GetNativeMethodBody(Source);
		Triple.Compile(realTarget);
		IntPtr functionPointer = Triple.Runtime.GetMethodHandle(realTarget).GetFunctionPointer();
		return Triple.CreateSimpleDetour(nativeMethodBody, functionPointer, -1, (IntPtr)0);
	}

	protected override void BeforeUndo()
	{
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(32, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Undoing managed detour from ");
			message.AppendFormatted(Source);
			message.AppendLiteral(" to ");
			message.AppendFormatted(realTarget);
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
	}

	protected override void AfterUndo()
	{
		Interlocked.Exchange(ref srcPin, null)?.Dispose();
		Interlocked.Exchange(ref dstPin, null)?.Dispose();
	}

	protected override void BeforeDispose()
	{
		if (Triple.SupportedFeatures.Has(RuntimeFeature.CompileMethodHook))
		{
			DetourBox.UnsubscribeCompileMethod();
		}
	}
}


using System;
using System.Reflection;

private sealed class ManagedDetourBox : DetourBoxBase
{
	private readonly MethodBase src;

	private readonly MethodBase target;

	public ManagedDetourBox(PlatformTriple triple, MethodBase src, MethodBase target)
		: base(triple)
	{
		this.src = src;
		this.target = target;
		Detour = null;
	}

	public void SubscribeCompileMethod()
	{
		AddRelatedDetour(src, this);
	}

	public void UnsubscribeCompileMethod()
	{
		RemoveRelatedDetour(src, this);
	}

	public void OnMethodCompiled(MethodBase method, IntPtr codeStart, IntPtr codeStartRw, ulong codeSize)
	{
		if (!base.IsApplied)
		{
			return;
		}
		method = Triple.GetIdentifiable(method);
		lock (Sync)
		{
			if (!base.IsApplied || base.IsApplying)
			{
				return;
			}
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(43, 4, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Updating detour from ");
				message.AppendFormatted(src);
				message.AppendLiteral(" to ");
				message.AppendFormatted(target);
				message.AppendLiteral(" (recompiled ");
				message.AppendFormatted(method);
				message.AppendLiteral(" to ");
				message.AppendFormatted(codeStart, "x16");
				message.AppendLiteral(")");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
			try
			{
				base.IsApplying = true;
				SimpleNativeDetour detour = Detour;
				IntPtr to;
				IntPtr from;
				IntPtr fromRw;
				if (detour != null)
				{
					_ = detour.Source;
					to = detour.Destination;
					from = codeStart;
					fromRw = codeStartRw;
				}
				else
				{
					from = codeStart;
					fromRw = codeStartRw;
					to = Triple.Runtime.GetMethodHandle(target).GetFunctionPointer();
				}
				SimpleNativeDetour newDetour = Triple.CreateSimpleDetour(from, to, (int)codeSize, fromRw);
				DetourBase.ReplaceDetourInLock(this, newDetour, out SimpleNativeDetour _);
			}
			finally
			{
				base.IsApplying = false;
			}
		}
	}
}


using System.Collections.Generic;
using System.Reflection;

private sealed class RelatedDetourBag
{
	public readonly MethodBase Method;

	public readonly List<ManagedDetourBox> RelatedDetours = new List<ManagedDetourBox>();

	public bool IsValid = true;

	public RelatedDetourBag(MethodBase method)
	{
		Method = method;
	}
}


using System;

private sealed class NativeDetour : DetourBase, ICoreNativeDetour, ICoreDetourBase, IDisposable
{
	private sealed class NativeDetourBox : DetourBoxBase
	{
		public readonly IntPtr From;

		public readonly IntPtr To;

		public NativeDetourBox(PlatformTriple triple, IntPtr from, IntPtr to)
			: base(triple)
		{
			From = from;
			To = to;
		}
	}

	private IDisposable? origHandle;

	public IntPtr Source => DetourBox.From;

	public IntPtr Target => DetourBox.To;

	public bool HasOrigEntrypoint => OrigEntrypoint != IntPtr.Zero;

	public IntPtr OrigEntrypoint { get; private set; }

	private new NativeDetourBox DetourBox => GetDetourBox<NativeDetourBox>();

	public NativeDetour(PlatformTriple triple, IntPtr from, IntPtr to)
		: base(triple)
	{
		base.DetourBox = new NativeDetourBox(triple, from, to);
	}

	protected override SimpleNativeDetour CreateDetour()
	{
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(32, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Applying native detour from ");
			message.AppendFormatted(Source, "x16");
			message.AppendLiteral(" to ");
			message.AppendFormatted(Target, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		Triple.CreateNativeDetour(Source, Target, -1, (IntPtr)0).Deconstruct(out SimpleNativeDetour Simple, out IntPtr AltEntry, out IDisposable AltHandle);
		SimpleNativeDetour result = Simple;
		IntPtr origEntrypoint = AltEntry;
		IDisposable disposable = AltHandle;
		IDisposable? disposable2 = origHandle;
		AltHandle = disposable;
		disposable = disposable2;
		origHandle = AltHandle;
		OrigEntrypoint = origEntrypoint;
		return result;
	}

	protected override void BeforeUndo()
	{
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(31, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Undoing native detour from ");
			message.AppendFormatted(Source, "x16");
			message.AppendLiteral(" to ");
			message.AppendFormatted(Target, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
	}

	protected override void AfterUndo()
	{
		OrigEntrypoint = IntPtr.Zero;
		origHandle?.Dispose();
		origHandle = null;
	}

	protected override void BeforeDispose()
	{
	}
}


using System;

private sealed class NativeDetourBox : DetourBoxBase
{
	public readonly IntPtr From;

	public readonly IntPtr To;

	public NativeDetourBox(PlatformTriple triple, IntPtr from, IntPtr to)
		: base(triple)
	{
		From = from;
		To = to;
	}
}


using System;

[Flags]
internal enum RuntimeFeature
{
	None = 0,
	PreciseGC = 1,
	CompileMethodHook = 2,
	ILDetour = 4,
	GenericSharing = 8,
	ListGenericInstantiations = 0x40,
	DisableInlining = 0x10,
	Uninlining = 0x20,
	RequiresMethodPinning = 0x80,
	RequiresMethodIdentification = 0x100,
	RequiresBodyThunkWalking = 0x200,
	HasKnownABI = 0x400,
	RequiresCustomMethodCompile = 0x800
}


using System;
using MonoMod;
using MonoMod.Core.Platforms;

internal sealed class SimpleNativeDetour : IDisposable
{
	private bool disposedValue;

	private readonly PlatformTriple triple;

	private NativeDetourInfo detourInfo;

	private Memory<byte> backup;

	private IDisposable? AllocHandle;

	public ReadOnlyMemory<byte> DetourBackup => backup;

	public IntPtr Source => detourInfo.From;

	public IntPtr Destination => detourInfo.To;

	internal SimpleNativeDetour(PlatformTriple triple, NativeDetourInfo detourInfo, Memory<byte> backup, IDisposable? allocHandle)
	{
		this.triple = triple;
		this.detourInfo = detourInfo;
		this.backup = backup;
		AllocHandle = allocHandle;
	}

	public void ChangeTarget(IntPtr newTarget)
	{
		CheckDisposed();
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(47, 3, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Retargeting simple detour 0x");
			message.AppendFormatted(Source, "x16");
			message.AppendLiteral(" => 0x");
			message.AppendFormatted(Destination, "x16");
			message.AppendLiteral(" to target 0x");
			message.AppendFormatted(newTarget, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		NativeDetourInfo retarget = triple.Architecture.ComputeRetargetInfo(detourInfo, newTarget, detourInfo.Size);
		Span<byte> span = stackalloc byte[retarget.Size];
		triple.Architecture.GetRetargetBytes(detourInfo, retarget, span, out IDisposable allocationHandle, out bool needsRepatch, out bool disposeOldAlloc);
		if (needsRepatch)
		{
			byte[] array = null;
			if (retarget.Size > backup.Length)
			{
				array = new byte[retarget.Size];
			}
			triple.System.PatchData(PatchTargetKind.Executable, Source, span, array);
			if (array != null)
			{
				backup.Span.CopyTo(array);
				backup = array;
			}
		}
		detourInfo = retarget;
		IDisposable? allocHandle = AllocHandle;
		IDisposable allocHandle2 = allocationHandle;
		allocationHandle = allocHandle;
		AllocHandle = allocHandle2;
		if (disposeOldAlloc)
		{
			allocationHandle?.Dispose();
		}
	}

	public void Undo()
	{
		CheckDisposed();
		UndoCore(disposing: true);
	}

	private void CheckDisposed()
	{
		if (disposedValue)
		{
			throw new ObjectDisposedException("SimpleNativeDetour");
		}
	}

	private void UndoCore(bool disposing)
	{
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(30, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Undoing simple detour 0x");
			message.AppendFormatted(Source, "x16");
			message.AppendLiteral(" => 0x");
			message.AppendFormatted(Destination, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		triple.System.PatchData(PatchTargetKind.Executable, Source, DetourBackup.Span, default(Span<byte>));
		if (disposing)
		{
			Cleanup();
		}
		disposedValue = true;
	}

	private void Cleanup()
	{
		AllocHandle?.Dispose();
	}

	private void Dispose(bool disposing)
	{
		if (!disposedValue)
		{
			UndoCore(disposing);
			disposedValue = true;
		}
	}

	~SimpleNativeDetour()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}


using System;

[Flags]
internal enum SystemFeature
{
	None = 0,
	RWXPages = 1,
	RXPages = 2
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.Win32.SafeHandles;
using MonoMod;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Memory;
using MonoMod.Core.Platforms.Systems;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal sealed class LinuxSystem : ISystem, IInitialize<IArchitecture>
{
	private sealed class MmapPagedMemoryAllocator : PagedMemoryAllocator
	{
		private sealed class SyscallNotImplementedException : Exception
		{
		}

		private static int PageProbePipeReadFD;

		private static int PageProbePipeWriteFD;

		private bool canTestPageAllocation = true;

		public MmapPagedMemoryAllocator(nint pageSize)
			: base(pageSize)
		{
		}

		unsafe static MmapPagedMemoryAllocator()
		{
			byte* num = stackalloc byte[8];
			if (Unix.Pipe2((int*)num, Unix.PipeFlags.CloseOnExec) == -1)
			{
				throw new Win32Exception(Unix.Errno, "Failed to create pipe for page probes");
			}
			PageProbePipeReadFD = *(int*)num;
			PageProbePipeWriteFD = *(int*)(num + 4);
		}

		public unsafe static bool PageAllocated(nint page)
		{
			byte b = default(byte);
			if (Unix.Mincore(page, 1u, &b) == -1)
			{
				int errno = Unix.Errno;
				return errno switch
				{
					12 => false, 
					38 => throw new SyscallNotImplementedException(), 
					_ => throw new NotImplementedException($"Got unimplemented errno for mincore(2); errno = {errno}"), 
				};
			}
			return true;
		}

		public unsafe static bool PageReadable(nint page)
		{
			if (Unix.Write(PageProbePipeWriteFD, page, 1) == -1)
			{
				int errno = Unix.Errno;
				if (errno == 14)
				{
					return false;
				}
				throw new NotImplementedException($"Got unimplemented errno for write(2); errno = {errno}");
			}
			byte b = default(byte);
			if (Unix.Read(PageProbePipeReadFD, new IntPtr(&b), 1) == -1)
			{
				throw new Win32Exception("Failed to clean up page probe pipe after successful page probe");
			}
			return true;
		}

		protected override bool TryAllocateNewPage(AllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
		{
			Unix.Protection protection = (request.Executable ? Unix.Protection.Execute : Unix.Protection.None);
			protection |= Unix.Protection.Read | Unix.Protection.Write;
			nint num = Unix.Mmap(IntPtr.Zero, (nuint)base.PageSize, protection, Unix.MmapFlags.Private | Unix.MmapFlags.Anonymous, -1, 0);
			long num2 = num;
			bool isEnabled = (((ulong)(num2 - -1) <= 1uL) ? true : false);
			if (isEnabled)
			{
				int errno = Unix.Errno;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(28, 2, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Error creating allocation: ");
					message.AppendFormatted(errno);
					message.AppendLiteral(" ");
					message.AppendFormatted(new Win32Exception(errno).Message);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				allocated = null;
				return false;
			}
			Page page = new Page(this, num, (uint)base.PageSize, request.Executable);
			InsertAllocatedPage(page);
			if (!page.TryAllocate((uint)request.Size, (uint)request.Alignment, out PageAllocation alloc))
			{
				RegisterForCleanup(page);
				allocated = null;
				return false;
			}
			allocated = alloc;
			return true;
		}

		protected override bool TryAllocateNewPage(PositionedAllocationRequest request, nint targetPage, nint lowPageBound, nint highPageBound, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
		{
			if (!canTestPageAllocation)
			{
				allocated = null;
				return false;
			}
			Unix.Protection protection = (request.Base.Executable ? Unix.Protection.Execute : Unix.Protection.None);
			protection |= Unix.Protection.Read | Unix.Protection.Write;
			nint num = request.Base.Size / base.PageSize + 1;
			nint num2 = targetPage - base.PageSize;
			nint num3 = targetPage;
			nint num4 = -1;
			try
			{
				while (num2 >= lowPageBound || num3 <= highPageBound)
				{
					if (num3 <= highPageBound)
					{
						nint num5 = 0;
						while (true)
						{
							if (num5 < num)
							{
								if (PageAllocated(num3 + base.PageSize * num5))
								{
									num3 += base.PageSize;
									goto IL_008e;
								}
								num5++;
								continue;
							}
							num4 = num3;
							break;
						}
						break;
					}
					goto IL_008e;
					IL_008e:
					if (num2 < lowPageBound)
					{
						continue;
					}
					nint num6 = 0;
					while (true)
					{
						if (num6 < num)
						{
							if (PageAllocated(num2 + base.PageSize * num6))
							{
								num2 -= base.PageSize;
								goto IL_00c5;
							}
							num6++;
							continue;
						}
						num4 = num2;
						break;
					}
					break;
					IL_00c5:;
				}
			}
			catch (SyscallNotImplementedException)
			{
				canTestPageAllocation = false;
				allocated = null;
				return false;
			}
			if (num4 == -1)
			{
				allocated = null;
				return false;
			}
			nint num7 = Unix.Mmap(num4, (nuint)base.PageSize, protection, Unix.MmapFlags.Private | Unix.MmapFlags.Anonymous | Unix.MmapFlags.FixedNoReplace, -1, 0);
			long num8 = num7;
			if (((ulong)(num8 - -1) <= 1uL) ? true : false)
			{
				allocated = null;
				return false;
			}
			Page page = new Page(this, num7, (uint)base.PageSize, request.Base.Executable);
			InsertAllocatedPage(page);
			if (!page.TryAllocate((uint)request.Base.Size, (uint)request.Base.Alignment, out PageAllocation alloc))
			{
				RegisterForCleanup(page);
				allocated = null;
				return false;
			}
			if ((nint)alloc.BaseAddress < (nint)request.LowBound || (nint)alloc.BaseAddress + alloc.Size >= (nint)request.HighBound)
			{
				alloc.Dispose();
				allocated = null;
				return false;
			}
			allocated = alloc;
			return true;
		}

		protected override bool TryFreePage(Page page, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
		{
			if (Unix.Munmap(page.BaseAddr, page.Size) != 0)
			{
				errorMsg = new Win32Exception(Unix.Errno).Message;
				return false;
			}
			errorMsg = null;
			return true;
		}
	}

	private readonly Abi defaultAbi;

	private readonly nint PageSize;

	private readonly MmapPagedMemoryAllocator allocator;

	private IArchitecture? arch;

	private PosixExceptionHelper? lazyNativeExceptionHelper;

	public OSKind Target => OSKind.Linux;

	public SystemFeature Features => SystemFeature.RWXPages | SystemFeature.RXPages;

	public Abi? DefaultAbi => defaultAbi;

	public IMemoryAllocator MemoryAllocator => allocator;

	public INativeExceptionHelper? NativeExceptionHelper => lazyNativeExceptionHelper ?? (lazyNativeExceptionHelper = CreateNativeExceptionHelper());

	private static ReadOnlySpan<byte> NEHTempl => "/tmp/mm-exhelper.so.XXXXXX"u8;

	public IEnumerable<string?> EnumerateLoadedModuleFiles()
	{
		return from ProcessModule m in Process.GetCurrentProcess().Modules
			select m.FileName;
	}

	public LinuxSystem()
	{
		PageSize = (nint)Unix.Sysconf(Unix.SysconfName.PageSize);
		allocator = new MmapPagedMemoryAllocator(PageSize);
		if (PlatformDetection.Architecture == ArchitectureKind.x86_64)
		{
			defaultAbi = new Abi(new SpecialArgumentKind[3]
			{
				SpecialArgumentKind.ReturnBuffer,
				SpecialArgumentKind.ThisPointer,
				SpecialArgumentKind.UserArguments
			}, SystemVABI.ClassifyAMD64, ReturnsReturnBuffer: true);
			return;
		}
		throw new NotImplementedException();
	}

	public nint GetSizeOfReadableMemory(IntPtr start, nint guess)
	{
		nint num = allocator.RoundDownToPageBoundary(start);
		if (!MmapPagedMemoryAllocator.PageReadable(num))
		{
			return 0;
		}
		num += PageSize;
		nint num2 = num - (nint)start;
		while (num2 < guess)
		{
			if (!MmapPagedMemoryAllocator.PageReadable(num))
			{
				return num2;
			}
			num2 += PageSize;
			num += PageSize;
		}
		return num2;
	}

	public unsafe void PatchData(PatchTargetKind patchKind, IntPtr patchTarget, ReadOnlySpan<byte> data, Span<byte> backup)
	{
		if (patchKind == PatchTargetKind.Executable)
		{
			ProtectRWX(patchTarget, data.Length);
		}
		else
		{
			ProtectRW(patchTarget, data.Length);
		}
		Span<byte> destination = new Span<byte>((void*)patchTarget, data.Length);
		destination.TryCopyTo(backup);
		data.CopyTo(destination);
	}

	private void RoundToPageBoundary(ref nint addr, ref nint size)
	{
		nint num = allocator.RoundDownToPageBoundary(addr);
		size += addr - num;
		addr = num;
	}

	private void ProtectRW(IntPtr addr, nint size)
	{
		RoundToPageBoundary(ref addr, ref size);
		if (Unix.Mprotect(addr, (nuint)size, Unix.Protection.Read | Unix.Protection.Write) != 0)
		{
			throw new Win32Exception(Unix.Errno);
		}
	}

	private void ProtectRWX(IntPtr addr, nint size)
	{
		RoundToPageBoundary(ref addr, ref size);
		if (Unix.Mprotect(addr, (nuint)size, Unix.Protection.Read | Unix.Protection.Write | Unix.Protection.Execute) != 0)
		{
			throw new Win32Exception(Unix.Errno);
		}
	}

	void IInitialize<IArchitecture>.Initialize(IArchitecture value)
	{
		arch = value;
	}

	private unsafe PosixExceptionHelper CreateNativeExceptionHelper()
	{
		Helpers.Assert(arch != null, null, "arch is not null");
		if (arch.Target == ArchitectureKind.x86_64)
		{
			string text = "exhelper_linux_x86_64.so";
			string name = text;
			byte[] array = ArrayPool<byte>.Shared.Rent(NEHTempl.Length + 1);
			int num;
			string @string;
			try
			{
				MemoryExtensions.AsSpan(array).Clear();
				NEHTempl.CopyTo(array);
				fixed (byte* template = array)
				{
					num = Unix.MkSTemp(template);
				}
				if (num == -1)
				{
					int errno = Unix.Errno;
					Win32Exception ex = new Win32Exception(errno);
					bool isEnabled;
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(55, 2, out isEnabled);
					if (isEnabled)
					{
						message.AppendLiteral("Could not create temp file for NativeExceptionHelper: ");
						message.AppendFormatted(errno);
						message.AppendLiteral(" ");
						message.AppendFormatted(ex);
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
					throw ex;
				}
				@string = Encoding.UTF8.GetString(array, 0, NEHTempl.Length);
			}
			finally
			{
				ArrayPool<byte>.Shared.Return(array);
			}
			using (SafeFileHandle handle = new SafeFileHandle((IntPtr)num, ownsHandle: true))
			{
				using FileStream destination = new FileStream(handle, FileAccess.Write);
				using Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(name);
				Helpers.Assert(stream != null, null, "embedded is not null");
				stream.CopyTo(destination);
			}
			return PosixExceptionHelper.CreateHelper(arch, @string);
		}
		throw new NotImplementedException("No exception helper for current arch");
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms.Memory;

private sealed class MmapPagedMemoryAllocator : PagedMemoryAllocator
{
	private sealed class SyscallNotImplementedException : Exception
	{
	}

	private static int PageProbePipeReadFD;

	private static int PageProbePipeWriteFD;

	private bool canTestPageAllocation = true;

	public MmapPagedMemoryAllocator(nint pageSize)
		: base(pageSize)
	{
	}

	unsafe static MmapPagedMemoryAllocator()
	{
		byte* num = stackalloc byte[8];
		if (Unix.Pipe2((int*)num, Unix.PipeFlags.CloseOnExec) == -1)
		{
			throw new Win32Exception(Unix.Errno, "Failed to create pipe for page probes");
		}
		PageProbePipeReadFD = *(int*)num;
		PageProbePipeWriteFD = *(int*)(num + 4);
	}

	public unsafe static bool PageAllocated(nint page)
	{
		byte b = default(byte);
		if (Unix.Mincore(page, 1u, &b) == -1)
		{
			int errno = Unix.Errno;
			return errno switch
			{
				12 => false, 
				38 => throw new SyscallNotImplementedException(), 
				_ => throw new NotImplementedException($"Got unimplemented errno for mincore(2); errno = {errno}"), 
			};
		}
		return true;
	}

	public unsafe static bool PageReadable(nint page)
	{
		if (Unix.Write(PageProbePipeWriteFD, page, 1) == -1)
		{
			int errno = Unix.Errno;
			if (errno == 14)
			{
				return false;
			}
			throw new NotImplementedException($"Got unimplemented errno for write(2); errno = {errno}");
		}
		byte b = default(byte);
		if (Unix.Read(PageProbePipeReadFD, new IntPtr(&b), 1) == -1)
		{
			throw new Win32Exception("Failed to clean up page probe pipe after successful page probe");
		}
		return true;
	}

	protected override bool TryAllocateNewPage(AllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		Unix.Protection protection = (request.Executable ? Unix.Protection.Execute : Unix.Protection.None);
		protection |= Unix.Protection.Read | Unix.Protection.Write;
		nint num = Unix.Mmap(IntPtr.Zero, (nuint)base.PageSize, protection, Unix.MmapFlags.Private | Unix.MmapFlags.Anonymous, -1, 0);
		long num2 = num;
		bool isEnabled = (((ulong)(num2 - -1) <= 1uL) ? true : false);
		if (isEnabled)
		{
			int errno = Unix.Errno;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(28, 2, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Error creating allocation: ");
				message.AppendFormatted(errno);
				message.AppendLiteral(" ");
				message.AppendFormatted(new Win32Exception(errno).Message);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
			allocated = null;
			return false;
		}
		Page page = new Page(this, num, (uint)base.PageSize, request.Executable);
		InsertAllocatedPage(page);
		if (!page.TryAllocate((uint)request.Size, (uint)request.Alignment, out PageAllocation alloc))
		{
			RegisterForCleanup(page);
			allocated = null;
			return false;
		}
		allocated = alloc;
		return true;
	}

	protected override bool TryAllocateNewPage(PositionedAllocationRequest request, nint targetPage, nint lowPageBound, nint highPageBound, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		if (!canTestPageAllocation)
		{
			allocated = null;
			return false;
		}
		Unix.Protection protection = (request.Base.Executable ? Unix.Protection.Execute : Unix.Protection.None);
		protection |= Unix.Protection.Read | Unix.Protection.Write;
		nint num = request.Base.Size / base.PageSize + 1;
		nint num2 = targetPage - base.PageSize;
		nint num3 = targetPage;
		nint num4 = -1;
		try
		{
			while (num2 >= lowPageBound || num3 <= highPageBound)
			{
				if (num3 <= highPageBound)
				{
					nint num5 = 0;
					while (true)
					{
						if (num5 < num)
						{
							if (PageAllocated(num3 + base.PageSize * num5))
							{
								num3 += base.PageSize;
								goto IL_008e;
							}
							num5++;
							continue;
						}
						num4 = num3;
						break;
					}
					break;
				}
				goto IL_008e;
				IL_008e:
				if (num2 < lowPageBound)
				{
					continue;
				}
				nint num6 = 0;
				while (true)
				{
					if (num6 < num)
					{
						if (PageAllocated(num2 + base.PageSize * num6))
						{
							num2 -= base.PageSize;
							goto IL_00c5;
						}
						num6++;
						continue;
					}
					num4 = num2;
					break;
				}
				break;
				IL_00c5:;
			}
		}
		catch (SyscallNotImplementedException)
		{
			canTestPageAllocation = false;
			allocated = null;
			return false;
		}
		if (num4 == -1)
		{
			allocated = null;
			return false;
		}
		nint num7 = Unix.Mmap(num4, (nuint)base.PageSize, protection, Unix.MmapFlags.Private | Unix.MmapFlags.Anonymous | Unix.MmapFlags.FixedNoReplace, -1, 0);
		long num8 = num7;
		if (((ulong)(num8 - -1) <= 1uL) ? true : false)
		{
			allocated = null;
			return false;
		}
		Page page = new Page(this, num7, (uint)base.PageSize, request.Base.Executable);
		InsertAllocatedPage(page);
		if (!page.TryAllocate((uint)request.Base.Size, (uint)request.Base.Alignment, out PageAllocation alloc))
		{
			RegisterForCleanup(page);
			allocated = null;
			return false;
		}
		if ((nint)alloc.BaseAddress < (nint)request.LowBound || (nint)alloc.BaseAddress + alloc.Size >= (nint)request.HighBound)
		{
			alloc.Dispose();
			allocated = null;
			return false;
		}
		allocated = alloc;
		return true;
	}

	protected override bool TryFreePage(Page page, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
	{
		if (Unix.Munmap(page.BaseAddr, page.Size) != 0)
		{
			errorMsg = new Win32Exception(Unix.Errno).Message;
			return false;
		}
		errorMsg = null;
		return true;
	}
}


using System;

private sealed class SyscallNotImplementedException : Exception
{
}


using System;
using System.Buffers;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Reflection;
using System.Text;
using Microsoft.Win32.SafeHandles;
using MonoMod;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Memory;
using MonoMod.Core.Platforms.Systems;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal sealed class MacOSSystem : ISystem, IInitialize<IArchitecture>
{
	private sealed class MacOsQueryingAllocator : QueryingMemoryPageAllocatorBase
	{
		public override uint PageSize { get; }

		public MacOsQueryingAllocator()
		{
			PageSize = (uint)OSX.GetPageSize();
		}

		public unsafe override bool TryAllocatePage(nint size, bool executable, out IntPtr allocated)
		{
			Helpers.Assert(size == PageSize, null, "size == PageSize");
			OSX.vm_prot_t vm_prot_t = (executable ? OSX.vm_prot_t.Execute : OSX.vm_prot_t.None);
			vm_prot_t |= OSX.vm_prot_t.Default;
			ulong num = 0uL;
			OSX.kern_return_t kern_return_t = OSX.mach_vm_map(OSX.mach_task_self(), &num, (ulong)size, 0uL, OSX.vm_flags.Anywhere, 0, 0uL, true, vm_prot_t, vm_prot_t, OSX.vm_inherit_t.Copy);
			if (!kern_return_t)
			{
				bool isEnabled;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(41, 1, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Error creating allocation anywhere! kr = ");
					message.AppendFormatted(kern_return_t.Value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				allocated = default(IntPtr);
				return false;
			}
			allocated = (IntPtr)(long)num;
			return true;
		}

		public unsafe override bool TryAllocatePage(IntPtr pageAddr, nint size, bool executable, out IntPtr allocated)
		{
			Helpers.Assert(size == PageSize, null, "size == PageSize");
			OSX.vm_prot_t vm_prot_t = (executable ? OSX.vm_prot_t.Execute : OSX.vm_prot_t.None);
			vm_prot_t |= OSX.vm_prot_t.Default;
			ulong num = (ulong)(long)pageAddr;
			OSX.kern_return_t kern_return_t = OSX.mach_vm_map(OSX.mach_task_self(), &num, (ulong)size, 0uL, OSX.vm_flags.Fixed, 0, 0uL, true, vm_prot_t, vm_prot_t, OSX.vm_inherit_t.Copy);
			if (!kern_return_t)
			{
				bool isEnabled;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler(38, 2, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Error creating allocation at 0x");
					message.AppendFormatted(num, "x16");
					message.AppendLiteral(": kr = ");
					message.AppendFormatted(kern_return_t.Value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Spam(ref message);
				allocated = default(IntPtr);
				return false;
			}
			allocated = (IntPtr)(long)num;
			return true;
		}

		public override bool TryFreePage(IntPtr pageAddr, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
		{
			OSX.kern_return_t kern_return_t = OSX.mach_vm_deallocate(OSX.mach_task_self(), (ulong)(long)pageAddr, PageSize);
			if (!kern_return_t)
			{
				errorMsg = $"Could not deallocate page: kr = {kern_return_t.Value}";
				return false;
			}
			errorMsg = null;
			return true;
		}

		public override bool TryQueryPage(IntPtr pageAddr, out bool isFree, out IntPtr allocBase, out nint allocSize)
		{
			OSX.vm_prot_t prot;
			OSX.vm_prot_t maxProt;
			OSX.kern_return_t localRegionInfo = GetLocalRegionInfo(pageAddr, out allocBase, out allocSize, out prot, out maxProt);
			if ((bool)localRegionInfo)
			{
				if ((nint)allocBase > (nint)pageAddr)
				{
					allocSize = (nint)allocBase - (nint)pageAddr;
					allocBase = pageAddr;
					isFree = true;
					return true;
				}
				isFree = false;
				return true;
			}
			if (localRegionInfo == OSX.kern_return_t.InvalidAddress)
			{
				isFree = true;
				return true;
			}
			isFree = false;
			return false;
		}
	}

	private IArchitecture? arch;

	private PosixExceptionHelper? lazyNativeExceptionHelper;

	public OSKind Target => OSKind.OSX;

	public SystemFeature Features => SystemFeature.RWXPages | SystemFeature.RXPages;

	public Abi? DefaultAbi { get; }

	public IMemoryAllocator MemoryAllocator { get; } = new QueryingPagedMemoryAllocator(new MacOsQueryingAllocator());

	public INativeExceptionHelper? NativeExceptionHelper => lazyNativeExceptionHelper ?? (lazyNativeExceptionHelper = CreateNativeExceptionHelper());

	private static ReadOnlySpan<byte> NEHTempl => "/tmp/mm-exhelper.dylib.XXXXXX"u8;

	public MacOSSystem()
	{
		if (PlatformDetection.Architecture == ArchitectureKind.x86_64)
		{
			DefaultAbi = new Abi(new SpecialArgumentKind[3]
			{
				SpecialArgumentKind.ReturnBuffer,
				SpecialArgumentKind.ThisPointer,
				SpecialArgumentKind.UserArguments
			}, SystemVABI.ClassifyAMD64, ReturnsReturnBuffer: true);
			return;
		}
		throw new NotImplementedException();
	}

	public unsafe IEnumerable<string?> EnumerateLoadedModuleFiles()
	{
		int count = OSX.task_dyld_info.Count;
		OSX.task_dyld_info task_dyld_info = default(OSX.task_dyld_info);
		if (!OSX.task_info(OSX.mach_task_self(), OSX.task_flavor_t.DyldInfo, &task_dyld_info, &count))
		{
			return ArrayEx.Empty<string>();
		}
		ReadOnlySpan<OSX.dyld_image_info> infoArray = task_dyld_info.all_image_infos->InfoArray;
		string[] array = new string[infoArray.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = infoArray[i].imageFilePath.ToString();
		}
		return array;
	}

	public nint GetSizeOfReadableMemory(IntPtr start, nint guess)
	{
		nint num = 0;
		do
		{
			if (!GetLocalRegionInfo(start, out var startAddr, out var outSize, out var prot, out var _))
			{
				return num;
			}
			if (startAddr > (nint)start)
			{
				return num;
			}
			if ((prot & OSX.vm_prot_t.Read) == 0)
			{
				return num;
			}
			num += startAddr + outSize - (nint)start;
			start = startAddr + outSize;
		}
		while (num < guess);
		return num;
	}

	public unsafe void PatchData(PatchTargetKind targetKind, IntPtr patchTarget, ReadOnlySpan<byte> data, Span<byte> backup)
	{
		int length = data.Length;
		bool isEnabled;
		bool flag;
		bool flag2;
		if (TryGetProtForMem(patchTarget, length, out var _, out var prot, out var crossesAllocBoundary, out var notAllocated))
		{
			if (crossesAllocBoundary)
			{
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(101, 2, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Patch requested for memory which spans multiple memory allocations. Failures may result. (0x");
					message.AppendFormatted(patchTarget, "x16");
					message.AppendLiteral(" length ");
					message.AppendFormatted(length);
					message.AppendLiteral(")");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
			}
			flag = prot.Has(OSX.vm_prot_t.Write);
			flag2 = prot.Has(OSX.vm_prot_t.Execute);
		}
		else
		{
			if (notAllocated)
			{
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(68, 2, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("Requested patch of region which was not fully allocated (0x");
					message2.AppendFormatted(patchTarget, "x16");
					message2.AppendLiteral(" length ");
					message2.AppendFormatted(length);
					message2.AppendLiteral(")");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message2);
				throw new InvalidOperationException("Cannot patch unallocated region");
			}
			flag = false;
			flag2 = targetKind == PatchTargetKind.Executable;
		}
		if (!flag)
		{
			Helpers.Assert(!crossesAllocBoundary, null, "!crossesBoundary");
			MakePageWritable(patchTarget);
		}
		Span<byte> destination = new Span<byte>((void*)patchTarget, data.Length);
		destination.TryCopyTo(backup);
		data.CopyTo(destination);
		if (flag2)
		{
			OSX.sys_icache_invalidate((void*)patchTarget, (nuint)data.Length);
		}
	}

	private unsafe static void MakePageWritable(nint addrInPage)
	{
		Helpers.Assert(GetLocalRegionInfo(addrInPage, out IntPtr startAddr, out IntPtr outSize, out OSX.vm_prot_t prot, out OSX.vm_prot_t maxProt), null, "GetLocalRegionInfo(addrInPage, out var allocStart, out var allocSize, out var allocProt, out var allocMaxProt)");
		Helpers.Assert((nint)startAddr <= addrInPage, null, "allocStart <= addrInPage");
		if (prot.Has(OSX.vm_prot_t.Write))
		{
			return;
		}
		int targetTask = OSX.mach_task_self();
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message;
		bool isEnabled;
		OSX.kern_return_t kern_return_t;
		if (maxProt.Has(OSX.vm_prot_t.Write))
		{
			kern_return_t = OSX.mach_vm_protect(targetTask, (ulong)(nint)startAddr, (ulong)(nint)outSize, false, prot | OSX.vm_prot_t.Write);
			if ((bool)kern_return_t)
			{
				return;
			}
			message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(60, 6, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Could not vm_protect page 0x");
				message.AppendFormatted(startAddr, "x16");
				message.AppendLiteral("+0x");
				message.AppendFormatted(outSize, "x");
				message.AppendLiteral(" ");
				message.AppendLiteral("from ");
				message.AppendFormatted(OSX.P(prot));
				message.AppendLiteral(" to ");
				message.AppendFormatted(OSX.P(prot | OSX.vm_prot_t.Write));
				message.AppendLiteral(" (max prot ");
				message.AppendFormatted(OSX.P(maxProt));
				message.AppendLiteral("): kr = ");
				message.AppendFormatted(kern_return_t.Value);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error("Trying copy/remap instead...");
		}
		if (!prot.Has(OSX.vm_prot_t.Read))
		{
			if (!maxProt.Has(OSX.vm_prot_t.Read))
			{
				message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(66, 3, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Requested 0x");
					message.AppendFormatted(startAddr, "x16");
					message.AppendLiteral("+0x");
					message.AppendFormatted(outSize, "x");
					message.AppendLiteral(" (max: ");
					message.AppendFormatted(OSX.P(maxProt));
					message.AppendLiteral(") to be made writable, but its not readable!");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				throw new NotSupportedException("Cannot make page writable because its not readable");
			}
			kern_return_t = OSX.mach_vm_protect(targetTask, (ulong)(nint)startAddr, (ulong)(nint)outSize, false, prot | OSX.vm_prot_t.Read);
			if (!kern_return_t)
			{
				message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(60, 4, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("vm_protect of 0x");
					message.AppendFormatted(startAddr, "x16");
					message.AppendLiteral("+0x");
					message.AppendFormatted(outSize, "x");
					message.AppendLiteral(" (max: ");
					message.AppendFormatted(OSX.P(maxProt));
					message.AppendLiteral(") to become readable failed: kr = ");
					message.AppendFormatted(kern_return_t.Value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				throw new NotSupportedException("Could not make page readable for remap");
			}
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(41, 5, out isEnabled);
		if (isEnabled)
		{
			message2.AppendLiteral("Performing page remap on 0x");
			message2.AppendFormatted(startAddr, "x16");
			message2.AppendLiteral("+0x");
			message2.AppendFormatted(outSize, "x");
			message2.AppendLiteral(" from ");
			message2.AppendFormatted(OSX.P(prot));
			message2.AppendLiteral("/");
			message2.AppendFormatted(OSX.P(maxProt));
			message2.AppendLiteral(" to ");
			message2.AppendFormatted(OSX.P(prot | OSX.vm_prot_t.Write));
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
		OSX.vm_prot_t vm_prot_t = prot | OSX.vm_prot_t.Write;
		OSX.vm_prot_t vm_prot_t2 = maxProt | OSX.vm_prot_t.Write;
		ulong num = default(ulong);
		kern_return_t = OSX.mach_vm_map(targetTask, &num, (ulong)(nint)outSize, 0uL, OSX.vm_flags.Anywhere, 0, 0uL, true, vm_prot_t, vm_prot_t2, OSX.vm_inherit_t.Copy);
		if (!kern_return_t)
		{
			message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(36, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Could not allocate new memory! kr = ");
				message.AppendFormatted(kern_return_t.Value);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
			throw new OutOfMemoryException();
		}
		try
		{
			new Span<byte>((void*)startAddr, (int)(nint)outSize).CopyTo(new Span<byte>((void*)num, (int)(nint)outSize));
			ulong value = (ulong)(nint)outSize;
			int num2 = default(int);
			kern_return_t = OSX.mach_make_memory_entry_64(targetTask, &value, num, vm_prot_t2, &num2, 0);
			if (!kern_return_t)
			{
				message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(79, 4, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("make_memory_entry(task_self(), size: 0x");
					message.AppendFormatted(value, "x");
					message.AppendLiteral(", addr: ");
					message.AppendFormatted(num, "x16");
					message.AppendLiteral(", prot: ");
					message.AppendFormatted(OSX.P(vm_prot_t2));
					message.AppendLiteral(", &obj, 0) failed: kr = ");
					message.AppendFormatted(kern_return_t.Value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				throw new NotSupportedException("make_memory_entry() failed");
			}
			ulong value2 = (ulong)(nint)startAddr;
			kern_return_t = OSX.mach_vm_map(targetTask, &value2, (ulong)(nint)outSize, 0uL, OSX.vm_flags.Overwrite, num2, 0uL, true, vm_prot_t, vm_prot_t2, OSX.vm_inherit_t.Copy);
			if (!kern_return_t)
			{
				message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(78, 10, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("vm_map() failed to map over target range: 0x");
					message.AppendFormatted(value2, "x16");
					message.AppendLiteral("+0x");
					message.AppendFormatted(outSize, "x");
					message.AppendLiteral(" (");
					message.AppendFormatted(OSX.P(prot));
					message.AppendLiteral("/");
					message.AppendFormatted(OSX.P(maxProt));
					message.AppendLiteral(")");
					message.AppendLiteral(" <- (obj ");
					message.AppendFormatted(num2);
					message.AppendLiteral(") 0x");
					message.AppendFormatted(num, "x16");
					message.AppendLiteral("+0x");
					message.AppendFormatted(outSize, "x");
					message.AppendLiteral(" (");
					message.AppendFormatted(OSX.P(vm_prot_t));
					message.AppendLiteral("/");
					message.AppendFormatted(OSX.P(vm_prot_t2));
					message.AppendLiteral("), kr = ");
					message.AppendFormatted(kern_return_t.Value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				throw new NotSupportedException("vm_map() failed");
			}
		}
		finally
		{
			kern_return_t = OSX.mach_vm_deallocate(targetTask, num, (ulong)(nint)outSize);
			if (!kern_return_t)
			{
				message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(53, 3, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Could not deallocate created memory page 0x");
					message.AppendFormatted(num, "x16");
					message.AppendLiteral("+0x");
					message.AppendFormatted(outSize, "x");
					message.AppendLiteral("! kr = ");
					message.AppendFormatted(kern_return_t.Value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
			}
		}
	}

	private static bool TryGetProtForMem(nint addr, int length, out OSX.vm_prot_t maxProt, out OSX.vm_prot_t prot, out bool crossesAllocBoundary, out bool notAllocated)
	{
		maxProt = (OSX.vm_prot_t)(-1);
		prot = (OSX.vm_prot_t)(-1);
		crossesAllocBoundary = false;
		notAllocated = false;
		nint num = addr;
		while (addr < num + length)
		{
			nint startAddr;
			nint outSize;
			OSX.vm_prot_t prot2;
			OSX.vm_prot_t maxProt2;
			OSX.kern_return_t localRegionInfo = GetLocalRegionInfo(addr, out startAddr, out outSize, out prot2, out maxProt2);
			if ((bool)localRegionInfo)
			{
				if (startAddr > addr)
				{
					notAllocated = true;
					return false;
				}
				prot &= prot2;
				maxProt &= maxProt2;
				addr = startAddr + outSize;
				if (addr >= num + length)
				{
					break;
				}
				crossesAllocBoundary = true;
				continue;
			}
			if (localRegionInfo == OSX.kern_return_t.NoSpace)
			{
				notAllocated = true;
				return false;
			}
			return false;
		}
		return true;
	}

	private unsafe static OSX.kern_return_t GetLocalRegionInfo(nint origAddr, out nint startAddr, out nint outSize, out OSX.vm_prot_t prot, out OSX.vm_prot_t maxProt)
	{
		int num = int.MaxValue;
		int count = OSX.vm_region_submap_short_info_64.Count;
		ulong num2 = (ulong)origAddr;
		ulong num3 = default(ulong);
		OSX.vm_region_submap_short_info_64 vm_region_submap_short_info_ = default(OSX.vm_region_submap_short_info_64);
		OSX.kern_return_t kern_return_t = OSX.mach_vm_region_recurse(OSX.mach_task_self(), &num2, &num3, &num, &vm_region_submap_short_info_, &count);
		if (!kern_return_t)
		{
			startAddr = 0;
			outSize = 0;
			prot = OSX.vm_prot_t.None;
			maxProt = OSX.vm_prot_t.None;
			return kern_return_t;
		}
		Helpers.Assert(!vm_region_submap_short_info_.is_submap, null, "!info.is_submap");
		startAddr = (nint)num2;
		outSize = (nint)num3;
		prot = vm_region_submap_short_info_.protection;
		maxProt = vm_region_submap_short_info_.max_protection;
		return kern_return_t;
	}

	void IInitialize<IArchitecture>.Initialize(IArchitecture value)
	{
		arch = value;
	}

	private unsafe PosixExceptionHelper CreateNativeExceptionHelper()
	{
		Helpers.Assert(arch != null, null, "arch is not null");
		if (arch.Target == ArchitectureKind.x86_64)
		{
			string text = "exhelper_macos_x86_64.dylib";
			string name = text;
			byte[] array = ArrayPool<byte>.Shared.Rent(NEHTempl.Length + 1);
			int num;
			string @string;
			try
			{
				MemoryExtensions.AsSpan(array).Clear();
				NEHTempl.CopyTo(array);
				fixed (byte* template = array)
				{
					num = OSX.MkSTemp(template);
				}
				if (num == -1)
				{
					int errno = OSX.Errno;
					Win32Exception ex = new Win32Exception(errno);
					bool isEnabled;
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(55, 2, out isEnabled);
					if (isEnabled)
					{
						message.AppendLiteral("Could not create temp file for NativeExceptionHelper: ");
						message.AppendFormatted(errno);
						message.AppendLiteral(" ");
						message.AppendFormatted(ex);
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
					throw ex;
				}
				@string = Encoding.UTF8.GetString(array, 0, NEHTempl.Length);
			}
			finally
			{
				ArrayPool<byte>.Shared.Return(array);
			}
			using (SafeFileHandle handle = new SafeFileHandle((IntPtr)num, ownsHandle: true))
			{
				using FileStream destination = new FileStream(handle, FileAccess.Write);
				using Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(name);
				Helpers.Assert(stream != null, null, "embedded is not null");
				stream.CopyTo(destination);
			}
			return PosixExceptionHelper.CreateHelper(arch, @string);
		}
		throw new NotImplementedException("No exception helper for current arch");
	}
}


using System;
using System.Diagnostics.CodeAnalysis;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms.Memory;
using MonoMod.Utils;

private sealed class MacOsQueryingAllocator : QueryingMemoryPageAllocatorBase
{
	public override uint PageSize { get; }

	public MacOsQueryingAllocator()
	{
		PageSize = (uint)OSX.GetPageSize();
	}

	public unsafe override bool TryAllocatePage(nint size, bool executable, out IntPtr allocated)
	{
		Helpers.Assert(size == PageSize, null, "size == PageSize");
		OSX.vm_prot_t vm_prot_t = (executable ? OSX.vm_prot_t.Execute : OSX.vm_prot_t.None);
		vm_prot_t |= OSX.vm_prot_t.Default;
		ulong num = 0uL;
		OSX.kern_return_t kern_return_t = OSX.mach_vm_map(OSX.mach_task_self(), &num, (ulong)size, 0uL, OSX.vm_flags.Anywhere, 0, 0uL, true, vm_prot_t, vm_prot_t, OSX.vm_inherit_t.Copy);
		if (!kern_return_t)
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(41, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Error creating allocation anywhere! kr = ");
				message.AppendFormatted(kern_return_t.Value);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
			allocated = default(IntPtr);
			return false;
		}
		allocated = (IntPtr)(long)num;
		return true;
	}

	public unsafe override bool TryAllocatePage(IntPtr pageAddr, nint size, bool executable, out IntPtr allocated)
	{
		Helpers.Assert(size == PageSize, null, "size == PageSize");
		OSX.vm_prot_t vm_prot_t = (executable ? OSX.vm_prot_t.Execute : OSX.vm_prot_t.None);
		vm_prot_t |= OSX.vm_prot_t.Default;
		ulong num = (ulong)(long)pageAddr;
		OSX.kern_return_t kern_return_t = OSX.mach_vm_map(OSX.mach_task_self(), &num, (ulong)size, 0uL, OSX.vm_flags.Fixed, 0, 0uL, true, vm_prot_t, vm_prot_t, OSX.vm_inherit_t.Copy);
		if (!kern_return_t)
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler(38, 2, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Error creating allocation at 0x");
				message.AppendFormatted(num, "x16");
				message.AppendLiteral(": kr = ");
				message.AppendFormatted(kern_return_t.Value);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Spam(ref message);
			allocated = default(IntPtr);
			return false;
		}
		allocated = (IntPtr)(long)num;
		return true;
	}

	public override bool TryFreePage(IntPtr pageAddr, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
	{
		OSX.kern_return_t kern_return_t = OSX.mach_vm_deallocate(OSX.mach_task_self(), (ulong)(long)pageAddr, PageSize);
		if (!kern_return_t)
		{
			errorMsg = $"Could not deallocate page: kr = {kern_return_t.Value}";
			return false;
		}
		errorMsg = null;
		return true;
	}

	public override bool TryQueryPage(IntPtr pageAddr, out bool isFree, out IntPtr allocBase, out nint allocSize)
	{
		OSX.vm_prot_t prot;
		OSX.vm_prot_t maxProt;
		OSX.kern_return_t localRegionInfo = GetLocalRegionInfo(pageAddr, out allocBase, out allocSize, out prot, out maxProt);
		if ((bool)localRegionInfo)
		{
			if ((nint)allocBase > (nint)pageAddr)
			{
				allocSize = (nint)allocBase - (nint)pageAddr;
				allocBase = pageAddr;
				isFree = true;
				return true;
			}
			isFree = false;
			return true;
		}
		if (localRegionInfo == OSX.kern_return_t.InvalidAddress)
		{
			isFree = true;
			return true;
		}
		isFree = false;
		return false;
	}
}


using System;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Systems;
using MonoMod.Utils;

internal sealed class PosixExceptionHelper : INativeExceptionHelper
{
	private readonly IArchitecture arch;

	private readonly IntPtr eh_get_exception_ptr;

	private readonly IntPtr eh_managed_to_native;

	private readonly IntPtr eh_native_to_managed;

	public unsafe IntPtr NativeException
	{
		get
		{
			return *((delegate* unmanaged[Cdecl]<IntPtr*>)(void*)eh_get_exception_ptr)();
		}
		set
		{
			*((delegate* unmanaged[Cdecl]<IntPtr*>)(void*)eh_get_exception_ptr)() = value;
		}
	}

	public unsafe GetExceptionSlot GetExceptionSlot => () => ((delegate* unmanaged[Cdecl]<IntPtr*>)(void*)eh_get_exception_ptr)();

	private PosixExceptionHelper(IArchitecture arch, IntPtr getExPtr, IntPtr m2n, IntPtr n2m)
	{
		this.arch = arch;
		eh_get_exception_ptr = getExPtr;
		eh_managed_to_native = m2n;
		eh_native_to_managed = n2m;
	}

	public static PosixExceptionHelper CreateHelper(IArchitecture arch, string filename)
	{
		IntPtr intPtr = DynDll.OpenLibrary(filename);
		IntPtr export;
		IntPtr export2;
		IntPtr export3;
		try
		{
			export = intPtr.GetExport("eh_get_exception_ptr");
			export2 = intPtr.GetExport("eh_managed_to_native");
			export3 = intPtr.GetExport("eh_native_to_managed");
			Helpers.Assert(export != IntPtr.Zero, null, "eh_get_exception_ptr != IntPtr.Zero");
			Helpers.Assert(export2 != IntPtr.Zero, null, "eh_managed_to_native != IntPtr.Zero");
			Helpers.Assert(export3 != IntPtr.Zero, null, "eh_native_to_managed != IntPtr.Zero");
		}
		catch
		{
			DynDll.CloseLibrary(intPtr);
			throw;
		}
		return new PosixExceptionHelper(arch, export, export2, export3);
	}

	public IntPtr CreateManagedToNativeHelper(IntPtr target, out IDisposable? handle)
	{
		return ((IAllocatedMemory)(handle = arch.CreateSpecialEntryStub(eh_managed_to_native, target))).BaseAddress;
	}

	public IntPtr CreateNativeToManagedHelper(IntPtr target, out IDisposable? handle)
	{
		return ((IAllocatedMemory)(handle = arch.CreateSpecialEntryStub(eh_native_to_managed, target))).BaseAddress;
	}
}


using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal static class SystemVABI
{
	private static readonly ConditionalWeakTable<Type, StrongBox<bool>> SysVIsMemoryCache = new ConditionalWeakTable<Type, StrongBox<bool>>();

	public static TypeClassification ClassifyAMD64(Type type, bool isReturn)
	{
		int managedSize = type.GetManagedSize();
		if (managedSize > 16)
		{
			if (managedSize > 32)
			{
				if (!isReturn)
				{
					return TypeClassification.OnStack;
				}
				return TypeClassification.ByReference;
			}
			if (SysVIsMemoryCache.GetValue(type, (Type t) => new StrongBox<bool>(AnyFieldsNotFloat(t))).Value)
			{
				if (!isReturn)
				{
					return TypeClassification.OnStack;
				}
				return TypeClassification.ByReference;
			}
		}
		return TypeClassification.InRegister;
	}

	private static bool AnyFieldsNotFloat(Type type)
	{
		FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		for (int i = 0; i < fields.Length; i++)
		{
			Type fieldType = fields[i].FieldType;
			if ((object)fieldType != null && !fieldType.IsPrimitive && fieldType.IsValueType && AnyFieldsNotFloat(fieldType))
			{
				return true;
			}
			TypeCode typeCode = Type.GetTypeCode(fieldType);
			if (typeCode != TypeCode.Single && typeCode != TypeCode.Double)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using MonoMod;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Memory;
using MonoMod.Core.Platforms.Systems;
using MonoMod.Utils;

internal sealed class WindowsSystem : ISystem
{
	private sealed class PageAllocator : QueryingMemoryPageAllocatorBase
	{
		public override uint PageSize { get; }

		public unsafe PageAllocator()
		{
			Windows.SYSTEM_INFO sYSTEM_INFO = default(Windows.SYSTEM_INFO);
			Windows.GetSystemInfo(&sYSTEM_INFO);
			PageSize = sYSTEM_INFO.dwPageSize;
		}

		public unsafe override bool TryAllocatePage(nint size, bool executable, out IntPtr allocated)
		{
			int flProtect = (executable ? 64 : 4);
			allocated = (IntPtr)Windows.VirtualAlloc(null, (nuint)size, 12288u, (uint)flProtect);
			return allocated != IntPtr.Zero;
		}

		public unsafe override bool TryAllocatePage(IntPtr pageAddr, nint size, bool executable, out IntPtr allocated)
		{
			int flProtect = (executable ? 64 : 4);
			allocated = (IntPtr)Windows.VirtualAlloc((void*)pageAddr, (nuint)size, 12288u, (uint)flProtect);
			return allocated != IntPtr.Zero;
		}

		public unsafe override bool TryFreePage(IntPtr pageAddr, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
		{
			if (!Windows.VirtualFree((void*)pageAddr, 0u, 32768u))
			{
				errorMsg = new Win32Exception((int)Windows.GetLastError()).Message;
				return false;
			}
			errorMsg = null;
			return true;
		}

		public unsafe override bool TryQueryPage(IntPtr pageAddr, out bool isFree, out IntPtr allocBase, out nint allocSize)
		{
			Windows.MEMORY_BASIC_INFORMATION mEMORY_BASIC_INFORMATION = default(Windows.MEMORY_BASIC_INFORMATION);
			if (Windows.VirtualQuery((void*)pageAddr, &mEMORY_BASIC_INFORMATION, (nuint)sizeof(Windows.MEMORY_BASIC_INFORMATION)) != 0)
			{
				isFree = mEMORY_BASIC_INFORMATION.State == 65536;
				allocBase = (nint)(isFree ? mEMORY_BASIC_INFORMATION.BaseAddress : mEMORY_BASIC_INFORMATION.AllocationBase);
				allocSize = (nint)pageAddr + (nint)mEMORY_BASIC_INFORMATION.RegionSize - (nint)allocBase;
				return true;
			}
			isFree = false;
			allocBase = IntPtr.Zero;
			allocSize = 0;
			return false;
		}
	}

	public OSKind Target => OSKind.Windows;

	public SystemFeature Features => SystemFeature.RWXPages;

	public INativeExceptionHelper? NativeExceptionHelper => null;

	public Abi? DefaultAbi { get; }

	public IMemoryAllocator MemoryAllocator { get; } = new QueryingPagedMemoryAllocator(new PageAllocator());

	private static TypeClassification ClassifyX64(Type type, bool isReturn)
	{
		int managedSize = type.GetManagedSize();
		if (((uint)(managedSize - 1) <= 1u || managedSize == 4 || managedSize == 8) ? true : false)
		{
			return TypeClassification.InRegister;
		}
		return TypeClassification.ByReference;
	}

	private static TypeClassification ClassifyX86(Type type, bool isReturn)
	{
		if (!isReturn)
		{
			return TypeClassification.OnStack;
		}
		int managedSize = type.GetManagedSize();
		if (((uint)(managedSize - 1) <= 1u || managedSize == 4) ? true : false)
		{
			return TypeClassification.InRegister;
		}
		return TypeClassification.ByReference;
	}

	public WindowsSystem()
	{
		if (PlatformDetection.Architecture == ArchitectureKind.x86_64)
		{
			DefaultAbi = new Abi(new SpecialArgumentKind[3]
			{
				SpecialArgumentKind.ReturnBuffer,
				SpecialArgumentKind.ThisPointer,
				SpecialArgumentKind.UserArguments
			}, ClassifyX64, ReturnsReturnBuffer: true);
		}
		else if (PlatformDetection.Architecture == ArchitectureKind.x86)
		{
			DefaultAbi = new Abi(new SpecialArgumentKind[3]
			{
				SpecialArgumentKind.ThisPointer,
				SpecialArgumentKind.ReturnBuffer,
				SpecialArgumentKind.UserArguments
			}, ClassifyX86, ReturnsReturnBuffer: true);
		}
	}

	public unsafe void PatchData(PatchTargetKind patchKind, IntPtr patchTarget, ReadOnlySpan<byte> data, Span<byte> backup)
	{
		if (patchKind == PatchTargetKind.Executable)
		{
			ProtectRWX(patchTarget, (nuint)data.Length);
		}
		else
		{
			ProtectRW(patchTarget, (nuint)data.Length);
		}
		Span<byte> destination = new Span<byte>((void*)patchTarget, data.Length);
		destination.TryCopyTo(backup);
		data.CopyTo(destination);
		if (patchKind == PatchTargetKind.Executable)
		{
			FlushInstructionCache(patchTarget, (nuint)data.Length);
		}
	}

	private unsafe static void ProtectRW(IntPtr addr, nuint size)
	{
		uint num = default(uint);
		if (!Windows.VirtualProtect((void*)addr, size, 4u, &num))
		{
			throw LogAllSections(Windows.GetLastError(), addr, size, "ProtectRW");
		}
	}

	private unsafe static void ProtectRWX(IntPtr addr, nuint size)
	{
		uint num = default(uint);
		if (!Windows.VirtualProtect((void*)addr, size, 64u, &num))
		{
			throw LogAllSections(Windows.GetLastError(), addr, size, "ProtectRWX");
		}
	}

	private unsafe static void FlushInstructionCache(IntPtr addr, nuint size)
	{
		if (!Windows.FlushInstructionCache(Windows.GetCurrentProcess(), (void*)addr, size))
		{
			throw LogAllSections(Windows.GetLastError(), addr, size, "FlushInstructionCache");
		}
	}

	public IEnumerable<string?> EnumerateLoadedModuleFiles()
	{
		return from ProcessModule m in Process.GetCurrentProcess().Modules
			select m.FileName;
	}

	public unsafe nint GetSizeOfReadableMemory(nint start, nint guess)
	{
		nint num = 0;
		Windows.MEMORY_BASIC_INFORMATION mEMORY_BASIC_INFORMATION = default(Windows.MEMORY_BASIC_INFORMATION);
		do
		{
			bool isEnabled;
			if (Windows.VirtualQuery((void*)start, &mEMORY_BASIC_INFORMATION, (nuint)sizeof(Windows.MEMORY_BASIC_INFORMATION)) == 0)
			{
				uint lastError = Windows.GetLastError();
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(22, 2, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("VirtualQuery failed: ");
					message.AppendFormatted(lastError);
					message.AppendLiteral(" ");
					message.AppendFormatted(new Win32Exception((int)lastError).Message);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
				return 0;
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler(56, 4, out isEnabled);
			if (isEnabled)
			{
				message2.AppendLiteral("VirtualQuery(0x");
				message2.AppendFormatted(start, "x16");
				message2.AppendLiteral(") == { Protect = ");
				message2.AppendFormatted(mEMORY_BASIC_INFORMATION.Protect, "x");
				message2.AppendLiteral(", BaseAddr = ");
				message2.AppendFormatted((UIntPtr)mEMORY_BASIC_INFORMATION.BaseAddress, "x16");
				message2.AppendLiteral(", Size = ");
				message2.AppendFormatted(mEMORY_BASIC_INFORMATION.RegionSize, "x4");
				message2.AppendLiteral(" }");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Spam(ref message2);
			if ((mEMORY_BASIC_INFORMATION.Protect & 0x66) == 0)
			{
				return num;
			}
			nint num2 = (nint)((byte*)mEMORY_BASIC_INFORMATION.BaseAddress + mEMORY_BASIC_INFORMATION.RegionSize);
			num += num2 - start;
			start = num2;
		}
		while (num < guess);
		return num;
	}

	private unsafe static Exception LogAllSections(uint error, IntPtr src, nuint size, [CallerMemberName] string from = "")
	{
		Exception ex = new Win32Exception((int)error);
		if (!<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.IsWritingLog)
		{
			return ex;
		}
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(47, 3, out isEnabled);
		if (isEnabled)
		{
			message.AppendFormatted(from);
			message.AppendLiteral(" failed for 0x");
			message.AppendFormatted(src, "X16");
			message.AppendLiteral(" + ");
			message.AppendFormatted(size);
			message.AppendLiteral(" - logging all memory sections");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
		message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(8, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("reason: ");
			message.AppendFormatted(ex.Message);
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
		try
		{
			IntPtr intPtr = (IntPtr)65536;
			int num = 0;
			Windows.MEMORY_BASIC_INFORMATION mEMORY_BASIC_INFORMATION = default(Windows.MEMORY_BASIC_INFORMATION);
			while (Windows.VirtualQuery((void*)intPtr, &mEMORY_BASIC_INFORMATION, (nuint)sizeof(Windows.MEMORY_BASIC_INFORMATION)) != 0)
			{
				nuint num2 = (nuint)(nint)src + size;
				void* baseAddress = mEMORY_BASIC_INFORMATION.BaseAddress;
				nuint num3 = (nuint)((byte*)baseAddress + mEMORY_BASIC_INFORMATION.RegionSize);
				bool flag = (nuint)baseAddress <= num2 && (nuint)(nint)src <= num3;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(2, 2, out isEnabled);
				if (isEnabled)
				{
					message2.AppendFormatted(flag ? "*" : "-");
					message2.AppendLiteral(" #");
					message2.AppendFormatted(num++);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(8, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("addr: 0x");
					message2.AppendFormatted((UIntPtr)mEMORY_BASIC_INFORMATION.BaseAddress, "X16");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(8, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("size: 0x");
					message2.AppendFormatted(mEMORY_BASIC_INFORMATION.RegionSize, "X16");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(9, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("aaddr: 0x");
					message2.AppendFormatted((UIntPtr)mEMORY_BASIC_INFORMATION.AllocationBase, "X16");
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(7, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("state: ");
					message2.AppendFormatted(mEMORY_BASIC_INFORMATION.State);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(6, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("type: ");
					message2.AppendFormatted(mEMORY_BASIC_INFORMATION.Type);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(9, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("protect: ");
					message2.AppendFormatted(mEMORY_BASIC_INFORMATION.Protect);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(10, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("aprotect: ");
					message2.AppendFormatted(mEMORY_BASIC_INFORMATION.AllocationProtect);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
				try
				{
					IntPtr intPtr2 = intPtr;
					intPtr = (IntPtr)((long)mEMORY_BASIC_INFORMATION.BaseAddress + (long)mEMORY_BASIC_INFORMATION.RegionSize);
					if ((ulong)(long)intPtr <= (ulong)(long)intPtr2)
					{
						break;
					}
				}
				catch (OverflowException value)
				{
					message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(9, 1, out isEnabled);
					if (isEnabled)
					{
						message.AppendLiteral("overflow ");
						message.AppendFormatted(value);
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
					break;
				}
			}
		}
		catch
		{
			throw ex;
		}
		return ex;
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms.Memory;

private sealed class PageAllocator : QueryingMemoryPageAllocatorBase
{
	public override uint PageSize { get; }

	public unsafe PageAllocator()
	{
		Windows.SYSTEM_INFO sYSTEM_INFO = default(Windows.SYSTEM_INFO);
		Windows.GetSystemInfo(&sYSTEM_INFO);
		PageSize = sYSTEM_INFO.dwPageSize;
	}

	public unsafe override bool TryAllocatePage(nint size, bool executable, out IntPtr allocated)
	{
		int flProtect = (executable ? 64 : 4);
		allocated = (IntPtr)Windows.VirtualAlloc(null, (nuint)size, 12288u, (uint)flProtect);
		return allocated != IntPtr.Zero;
	}

	public unsafe override bool TryAllocatePage(IntPtr pageAddr, nint size, bool executable, out IntPtr allocated)
	{
		int flProtect = (executable ? 64 : 4);
		allocated = (IntPtr)Windows.VirtualAlloc((void*)pageAddr, (nuint)size, 12288u, (uint)flProtect);
		return allocated != IntPtr.Zero;
	}

	public unsafe override bool TryFreePage(IntPtr pageAddr, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
	{
		if (!Windows.VirtualFree((void*)pageAddr, 0u, 32768u))
		{
			errorMsg = new Win32Exception((int)Windows.GetLastError()).Message;
			return false;
		}
		errorMsg = null;
		return true;
	}

	public unsafe override bool TryQueryPage(IntPtr pageAddr, out bool isFree, out IntPtr allocBase, out nint allocSize)
	{
		Windows.MEMORY_BASIC_INFORMATION mEMORY_BASIC_INFORMATION = default(Windows.MEMORY_BASIC_INFORMATION);
		if (Windows.VirtualQuery((void*)pageAddr, &mEMORY_BASIC_INFORMATION, (nuint)sizeof(Windows.MEMORY_BASIC_INFORMATION)) != 0)
		{
			isFree = mEMORY_BASIC_INFORMATION.State == 65536;
			allocBase = (nint)(isFree ? mEMORY_BASIC_INFORMATION.BaseAddress : mEMORY_BASIC_INFORMATION.AllocationBase);
			allocSize = (nint)pageAddr + (nint)mEMORY_BASIC_INFORMATION.RegionSize - (nint)allocBase;
			return true;
		}
		isFree = false;
		allocBase = IntPtr.Zero;
		allocSize = 0;
		return false;
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using Mono.Cecil;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal class Core21Runtime : CoreBaseRuntime
{
	private sealed class JitHookDelegateHolder
	{
		public readonly Core21Runtime Runtime;

		public readonly INativeExceptionHelper? NativeExceptionHelper;

		public readonly GetExceptionSlot? GetNativeExceptionSlot;

		public readonly JitHookHelpersHolder JitHookHelpers;

		public readonly CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr;

		public readonly IntPtr CompileMethodPtr;

		[ThreadStatic]
		private static int hookEntrancy;

		public unsafe JitHookDelegateHolder(Core21Runtime runtime, CoreCLR.InvokeCompileMethodPtr icmp, IntPtr compileMethod)
		{
			Runtime = runtime;
			NativeExceptionHelper = runtime.NativeExceptionHelper;
			JitHookHelpers = runtime.JitHookHelpers;
			InvokeCompileMethodPtr = icmp;
			CompileMethodPtr = compileMethod;
			delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = icmp.InvokeCompileMethod;
			_ = IntPtr.Zero;
			_ = IntPtr.Zero;
			_ = IntPtr.Zero;
			CoreCLR.V21.CORINFO_METHOD_INFO cORINFO_METHOD_INFO = default(CoreCLR.V21.CORINFO_METHOD_INFO);
			_ = &cORINFO_METHOD_INFO;
			_ = 0;
			byte* ptr = default(byte*);
			_ = &ptr;
			uint num = default(uint);
			_ = &num;
			/*Error near IL_0057: Handle with invalid row number.*/;
		}

		public unsafe CoreCLR.CorJitResult CompileMethodHook(IntPtr jit, IntPtr corJitInfo, CoreCLR.V21.CORINFO_METHOD_INFO* methodInfo, uint flags, byte** pNativeEntry, uint* pNativeSizeOfCode)
		{
			//Discarded unreachable code: IL_00c2, IL_0228, IL_0249
			*pNativeEntry = null;
			*pNativeSizeOfCode = 0u;
			if (jit == IntPtr.Zero)
			{
				return CoreCLR.CorJitResult.CORJIT_OK;
			}
			int lastPInvokeError = MarshalEx.GetLastPInvokeError();
			nint num = 0;
			GetExceptionSlot getNativeExceptionSlot = GetNativeExceptionSlot;
			IntPtr* ptr = ((getNativeExceptionSlot != null) ? getNativeExceptionSlot() : null);
			hookEntrancy++;
			try
			{
				delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = InvokeCompileMethodPtr.InvokeCompileMethod;
				_ = CompileMethodPtr;
				/*Error near IL_0060: Handle with invalid row number.*/;
			}
			finally
			{
				hookEntrancy--;
				if (ptr != null)
				{
					*ptr = num;
				}
				MarshalEx.SetLastPInvokeError(lastPInvokeError);
			}
		}
	}

	protected sealed class JitHookHelpersHolder
	{
		public delegate object MethodHandle_GetLoaderAllocatorD(IntPtr methodHandle);

		public delegate object CreateRuntimeMethodInfoStubD(IntPtr methodHandle, object loaderAllocator);

		public delegate RuntimeMethodHandle CreateRuntimeMethodHandleD(object runtimeMethodInfo);

		public delegate Type GetDeclaringTypeOfMethodHandleD(IntPtr methodHandle);

		public delegate Type GetTypeFromNativeHandleD(IntPtr handle);

		public readonly MethodHandle_GetLoaderAllocatorD MethodHandle_GetLoaderAllocator;

		public readonly CreateRuntimeMethodInfoStubD CreateRuntimeMethodInfoStub;

		public readonly CreateRuntimeMethodHandleD CreateRuntimeMethodHandle;

		public readonly GetDeclaringTypeOfMethodHandleD GetDeclaringTypeOfMethodHandle;

		public readonly GetTypeFromNativeHandleD GetTypeFromNativeHandle;

		public RuntimeMethodHandle CreateHandleForHandlePointer(IntPtr handle)
		{
			return CreateRuntimeMethodHandle(CreateRuntimeMethodInfoStub(handle, MethodHandle_GetLoaderAllocator(handle)));
		}

		public JitHookHelpersHolder(Core21Runtime runtime)
		{
			MethodInfo method = typeof(RuntimeMethodHandle).GetMethod("GetLoaderAllocator", BindingFlags.Static | BindingFlags.NonPublic);
			MethodInfo method2;
			using (DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("MethodHandle_GetLoaderAllocator", typeof(object), new Type[1] { typeof(IntPtr) }))
			{
				ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
				Type parameterType = method.GetParameters().First().ParameterType;
				iLGenerator.Emit(OpCodes.Ldarga_S, 0);
				iLGenerator.Emit(OpCodes.Ldobj, parameterType);
				iLGenerator.Emit(OpCodes.Call, method);
				iLGenerator.Emit(OpCodes.Ret);
				method2 = dynamicMethodDefinition.Generate();
			}
			MethodHandle_GetLoaderAllocator = Extensions.CreateDelegate<MethodHandle_GetLoaderAllocatorD>(method2);
			MethodInfo orCreateGetTypeFromHandleUnsafe = GetOrCreateGetTypeFromHandleUnsafe(runtime);
			GetTypeFromNativeHandle = Extensions.CreateDelegate<GetTypeFromNativeHandleD>(orCreateGetTypeFromHandleUnsafe);
			Type type = typeof(RuntimeMethodHandle).Assembly.GetType("System.RuntimeMethodHandleInternal");
			MethodInfo method3 = typeof(RuntimeMethodHandle).GetMethod("GetDeclaringType", BindingFlags.Static | BindingFlags.NonPublic, null, new Type[1] { type }, null);
			MethodInfo method4;
			using (DynamicMethodDefinition dynamicMethodDefinition2 = new DynamicMethodDefinition("GetDeclaringTypeOfMethodHandle", typeof(Type), new Type[1] { typeof(IntPtr) }))
			{
				ILGenerator iLGenerator2 = dynamicMethodDefinition2.GetILGenerator();
				iLGenerator2.Emit(OpCodes.Ldarga_S, 0);
				iLGenerator2.Emit(OpCodes.Ldobj, type);
				iLGenerator2.Emit(OpCodes.Call, method3);
				iLGenerator2.Emit(OpCodes.Ret);
				method4 = dynamicMethodDefinition2.Generate();
			}
			GetDeclaringTypeOfMethodHandle = Extensions.CreateDelegate<GetDeclaringTypeOfMethodHandleD>(method4);
			Type[] array = new Type[2]
			{
				typeof(IntPtr),
				typeof(object)
			};
			Type type2 = typeof(RuntimeMethodHandle).Assembly.GetType("System.RuntimeMethodInfoStub");
			ConstructorInfo constructor = type2.GetConstructor(array);
			MethodInfo method5;
			using (DynamicMethodDefinition dynamicMethodDefinition3 = new DynamicMethodDefinition("new RuntimeMethodInfoStub", type2, array))
			{
				ILGenerator iLGenerator3 = dynamicMethodDefinition3.GetILGenerator();
				iLGenerator3.Emit(OpCodes.Ldarg_0);
				iLGenerator3.Emit(OpCodes.Ldarg_1);
				iLGenerator3.Emit(OpCodes.Newobj, constructor);
				iLGenerator3.Emit(OpCodes.Ret);
				method5 = dynamicMethodDefinition3.Generate();
			}
			CreateRuntimeMethodInfoStub = Extensions.CreateDelegate<CreateRuntimeMethodInfoStubD>(method5);
			ConstructorInfo con = typeof(RuntimeMethodHandle).GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).First();
			MethodInfo method6;
			using (DynamicMethodDefinition dynamicMethodDefinition4 = new DynamicMethodDefinition("new RuntimeMethodHandle", typeof(RuntimeMethodHandle), new Type[1] { typeof(object) }))
			{
				ILGenerator iLGenerator4 = dynamicMethodDefinition4.GetILGenerator();
				iLGenerator4.Emit(OpCodes.Ldarg_0);
				iLGenerator4.Emit(OpCodes.Newobj, con);
				iLGenerator4.Emit(OpCodes.Ret);
				method6 = dynamicMethodDefinition4.Generate();
			}
			CreateRuntimeMethodHandle = Extensions.CreateDelegate<CreateRuntimeMethodHandleD>(method6);
		}

		private static MethodInfo GetOrCreateGetTypeFromHandleUnsafe(Core21Runtime runtime)
		{
			MethodInfo method = typeof(Type).GetMethod("GetTypeFromHandleUnsafe", (BindingFlags)(-1));
			if ((object)method != null)
			{
				return method;
			}
			Assembly assembly;
			using (ModuleDefinition moduleDefinition = ModuleDefinition.CreateModule("MonoMod.Core.Platforms.Runtimes.Core30Runtime+Helpers", new ModuleParameters
			{
				Kind = ModuleKind.Dll
			}))
			{
				TypeDefinition typeDefinition = new TypeDefinition("System", "Type", Mono.Cecil.TypeAttributes.Public | Mono.Cecil.TypeAttributes.Abstract)
				{
					BaseType = moduleDefinition.TypeSystem.Object
				};
				moduleDefinition.Types.Add(typeDefinition);
				MethodDefinition methodDefinition = new MethodDefinition("GetTypeFromHandleUnsafe", Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Static, moduleDefinition.ImportReference(typeof(Type)))
				{
					IsInternalCall = true
				};
				methodDefinition.Parameters.Add(new ParameterDefinition(moduleDefinition.ImportReference(typeof(IntPtr))));
				typeDefinition.Methods.Add(methodDefinition);
				assembly = ReflectionHelper.Load(moduleDefinition);
			}
			runtime.MakeAssemblySystemAssembly(assembly);
			return assembly.GetType("System.Type").GetMethod("GetTypeFromHandleUnsafe", (BindingFlags)(-1));
		}
	}

	private readonly object sync = new object();

	private JitHookHelpersHolder? lazyJitHookHelpers;

	private static readonly Guid JitVersionGuid = new Guid(195102408u, 33184, 16511, 153, 161, 146, 132, 72, 193, 235, 98);

	private Delegate? ourCompileMethod;

	private IDisposable? n2mHookHelper;

	private IDisposable? m2nHookHelper;

	private static readonly FieldInfo RuntimeAssemblyPtrField = Type.GetType("System.Reflection.RuntimeAssembly").GetField("m_assembly", BindingFlags.Instance | BindingFlags.NonPublic);

	public override RuntimeFeature Features => base.Features | RuntimeFeature.CompileMethodHook;

	protected unsafe JitHookHelpersHolder JitHookHelpers => Helpers.GetOrInitWithLock(ref lazyJitHookHelpers, sync, (delegate*<Core21Runtime, JitHookHelpersHolder>)(&CreateJitHookHelpers), this);

	protected virtual Guid ExpectedJitVersion => JitVersionGuid;

	protected virtual int VtableIndexICorJitCompilerGetVersionGuid => 4;

	protected virtual int VtableIndexICorJitCompilerCompileMethod => 0;

	protected virtual CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr => CoreCLR.V21.InvokeCompileMethodPtr;

	public Core21Runtime(ISystem system)
		: base(system)
	{
	}

	private static JitHookHelpersHolder CreateJitHookHelpers(Core21Runtime self)
	{
		return new JitHookHelpersHolder(self);
	}

	protected virtual Delegate CastCompileHookToRealType(Delegate del)
	{
		return del.CastDelegate<CoreCLR.V21.CompileMethodDelegate>();
	}

	protected unsafe static IntPtr* GetVTableEntry(IntPtr @object, int index)
	{
		return (IntPtr*)((nint)(*(IntPtr*)(void*)@object) + (nint)index * (nint)sizeof(IntPtr));
	}

	protected unsafe static IntPtr ReadObjectVTable(IntPtr @object, int index)
	{
		return *GetVTableEntry(@object, index);
	}

	private unsafe void CheckVersionGuid(IntPtr jit)
	{
		Guid guid = default(Guid);
		((delegate* unmanaged[Thiscall]<IntPtr, Guid*, void>)(void*)ReadObjectVTable(jit, VtableIndexICorJitCompilerGetVersionGuid))(jit, &guid);
		bool flag = guid == ExpectedJitVersion;
		bool isEnabled;
		AssertionInterpolatedStringHandler message = new AssertionInterpolatedStringHandler(66, 2, flag, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("JIT version does not match expected JIT version! ");
			message.AppendLiteral("expected: ");
			message.AppendFormatted(ExpectedJitVersion);
			message.AppendLiteral(", got: ");
			message.AppendFormatted(guid);
		}
		Helpers.Assert(flag, ref message, "guid == ExpectedJitVersion");
	}

	protected unsafe override void InstallJitHook(IntPtr jit)
	{
		CheckVersionGuid(jit);
		IntPtr* vTableEntry = GetVTableEntry(jit, VtableIndexICorJitCompilerCompileMethod);
		IntPtr compileMethod = EHManagedToNative(*vTableEntry, out m2nHookHelper);
		IntPtr value = EHNativeToManaged(Marshal.GetFunctionPointerForDelegate(ourCompileMethod = CastCompileHookToRealType(CreateCompileMethodDelegate(compileMethod))), out n2mHookHelper);
		InvokeCompileMethodToPrepare(value);
		Span<byte> span = stackalloc byte[sizeof(IntPtr)];
		MemoryMarshal.Write(span, ref value);
		base.System.PatchData(PatchTargetKind.ReadOnly, (IntPtr)vTableEntry, span, default(Span<byte>));
	}

	protected unsafe virtual void InvokeCompileMethodToPrepare(IntPtr method)
	{
		delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = InvokeCompileMethodPtr.InvokeCompileMethod;
		_ = IntPtr.Zero;
		_ = IntPtr.Zero;
		CoreCLR.V21.CORINFO_METHOD_INFO cORINFO_METHOD_INFO = default(CoreCLR.V21.CORINFO_METHOD_INFO);
		_ = &cORINFO_METHOD_INFO;
		_ = 0;
		byte* ptr = default(byte*);
		_ = &ptr;
		uint num = default(uint);
		_ = &num;
		/*Error near IL_0027: Handle with invalid row number.*/;
	}

	protected virtual Delegate CreateCompileMethodDelegate(IntPtr compileMethod)
	{
		return new <>f__AnonymousDelegate0(new JitHookDelegateHolder(this, InvokeCompileMethodPtr, compileMethod).CompileMethodHook);
	}

	protected unsafe virtual void MakeAssemblySystemAssembly(Assembly assembly)
	{
		IntPtr intPtr = (IntPtr)RuntimeAssemblyPtrField.GetValue(assembly);
		int num = IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + 4 + IntPtr.Size + IntPtr.Size + 4 + 4 + IntPtr.Size + IntPtr.Size + 4 + 4 + IntPtr.Size;
		if (IntPtr.Size == 8)
		{
			num += 4;
		}
		IntPtr intPtr2 = *(IntPtr*)((byte*)(void*)intPtr + num);
		int num2 = IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size;
		IntPtr intPtr3 = *(IntPtr*)((byte*)(void*)intPtr2 + num2);
		int num3 = IntPtr.Size + (FxCoreBaseRuntime.IsDebugClr ? (IntPtr.Size + 4 + 4 + 4 + IntPtr.Size + 4) : 0) + IntPtr.Size + IntPtr.Size + 4 + 4 + IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + 4;
		if (FxCoreBaseRuntime.IsDebugClr && IntPtr.Size == 8)
		{
			num3 += 8;
		}
		int* ptr = (int*)((byte*)(void*)intPtr3 + num3);
		*ptr |= 1;
	}
}


using System;
using System.Runtime.InteropServices;
using MonoMod.Core.Interop;

private sealed class JitHookDelegateHolder
{
	public readonly Core21Runtime Runtime;

	public readonly INativeExceptionHelper? NativeExceptionHelper;

	public readonly GetExceptionSlot? GetNativeExceptionSlot;

	public readonly JitHookHelpersHolder JitHookHelpers;

	public readonly CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr;

	public readonly IntPtr CompileMethodPtr;

	[ThreadStatic]
	private static int hookEntrancy;

	public unsafe JitHookDelegateHolder(Core21Runtime runtime, CoreCLR.InvokeCompileMethodPtr icmp, IntPtr compileMethod)
	{
		Runtime = runtime;
		NativeExceptionHelper = runtime.NativeExceptionHelper;
		JitHookHelpers = runtime.JitHookHelpers;
		InvokeCompileMethodPtr = icmp;
		CompileMethodPtr = compileMethod;
		delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = icmp.InvokeCompileMethod;
		_ = IntPtr.Zero;
		_ = IntPtr.Zero;
		_ = IntPtr.Zero;
		CoreCLR.V21.CORINFO_METHOD_INFO cORINFO_METHOD_INFO = default(CoreCLR.V21.CORINFO_METHOD_INFO);
		_ = &cORINFO_METHOD_INFO;
		_ = 0;
		byte* ptr = default(byte*);
		_ = &ptr;
		uint num = default(uint);
		_ = &num;
		/*Error near IL_0057: Handle with invalid row number.*/;
	}

	public unsafe CoreCLR.CorJitResult CompileMethodHook(IntPtr jit, IntPtr corJitInfo, CoreCLR.V21.CORINFO_METHOD_INFO* methodInfo, uint flags, byte** pNativeEntry, uint* pNativeSizeOfCode)
	{
		//Discarded unreachable code: IL_00c2, IL_0228, IL_0249
		*pNativeEntry = null;
		*pNativeSizeOfCode = 0u;
		if (jit == IntPtr.Zero)
		{
			return CoreCLR.CorJitResult.CORJIT_OK;
		}
		int lastPInvokeError = MarshalEx.GetLastPInvokeError();
		nint num = 0;
		GetExceptionSlot getNativeExceptionSlot = GetNativeExceptionSlot;
		IntPtr* ptr = ((getNativeExceptionSlot != null) ? getNativeExceptionSlot() : null);
		hookEntrancy++;
		try
		{
			delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = InvokeCompileMethodPtr.InvokeCompileMethod;
			_ = CompileMethodPtr;
			/*Error near IL_0060: Handle with invalid row number.*/;
		}
		finally
		{
			hookEntrancy--;
			if (ptr != null)
			{
				*ptr = num;
			}
			MarshalEx.SetLastPInvokeError(lastPInvokeError);
		}
	}
}


