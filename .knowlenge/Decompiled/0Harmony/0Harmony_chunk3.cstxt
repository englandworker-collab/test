using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Mono.Cecil;
using MonoMod.Utils;

protected sealed class JitHookHelpersHolder
{
	public delegate object MethodHandle_GetLoaderAllocatorD(IntPtr methodHandle);

	public delegate object CreateRuntimeMethodInfoStubD(IntPtr methodHandle, object loaderAllocator);

	public delegate RuntimeMethodHandle CreateRuntimeMethodHandleD(object runtimeMethodInfo);

	public delegate Type GetDeclaringTypeOfMethodHandleD(IntPtr methodHandle);

	public delegate Type GetTypeFromNativeHandleD(IntPtr handle);

	public readonly MethodHandle_GetLoaderAllocatorD MethodHandle_GetLoaderAllocator;

	public readonly CreateRuntimeMethodInfoStubD CreateRuntimeMethodInfoStub;

	public readonly CreateRuntimeMethodHandleD CreateRuntimeMethodHandle;

	public readonly GetDeclaringTypeOfMethodHandleD GetDeclaringTypeOfMethodHandle;

	public readonly GetTypeFromNativeHandleD GetTypeFromNativeHandle;

	public RuntimeMethodHandle CreateHandleForHandlePointer(IntPtr handle)
	{
		return CreateRuntimeMethodHandle(CreateRuntimeMethodInfoStub(handle, MethodHandle_GetLoaderAllocator(handle)));
	}

	public JitHookHelpersHolder(Core21Runtime runtime)
	{
		MethodInfo method = typeof(RuntimeMethodHandle).GetMethod("GetLoaderAllocator", BindingFlags.Static | BindingFlags.NonPublic);
		MethodInfo method2;
		using (DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("MethodHandle_GetLoaderAllocator", typeof(object), new Type[1] { typeof(IntPtr) }))
		{
			ILGenerator iLGenerator = dynamicMethodDefinition.GetILGenerator();
			Type parameterType = method.GetParameters().First().ParameterType;
			iLGenerator.Emit(OpCodes.Ldarga_S, 0);
			iLGenerator.Emit(OpCodes.Ldobj, parameterType);
			iLGenerator.Emit(OpCodes.Call, method);
			iLGenerator.Emit(OpCodes.Ret);
			method2 = dynamicMethodDefinition.Generate();
		}
		MethodHandle_GetLoaderAllocator = Extensions.CreateDelegate<MethodHandle_GetLoaderAllocatorD>(method2);
		MethodInfo orCreateGetTypeFromHandleUnsafe = GetOrCreateGetTypeFromHandleUnsafe(runtime);
		GetTypeFromNativeHandle = Extensions.CreateDelegate<GetTypeFromNativeHandleD>(orCreateGetTypeFromHandleUnsafe);
		Type type = typeof(RuntimeMethodHandle).Assembly.GetType("System.RuntimeMethodHandleInternal");
		MethodInfo method3 = typeof(RuntimeMethodHandle).GetMethod("GetDeclaringType", BindingFlags.Static | BindingFlags.NonPublic, null, new Type[1] { type }, null);
		MethodInfo method4;
		using (DynamicMethodDefinition dynamicMethodDefinition2 = new DynamicMethodDefinition("GetDeclaringTypeOfMethodHandle", typeof(Type), new Type[1] { typeof(IntPtr) }))
		{
			ILGenerator iLGenerator2 = dynamicMethodDefinition2.GetILGenerator();
			iLGenerator2.Emit(OpCodes.Ldarga_S, 0);
			iLGenerator2.Emit(OpCodes.Ldobj, type);
			iLGenerator2.Emit(OpCodes.Call, method3);
			iLGenerator2.Emit(OpCodes.Ret);
			method4 = dynamicMethodDefinition2.Generate();
		}
		GetDeclaringTypeOfMethodHandle = Extensions.CreateDelegate<GetDeclaringTypeOfMethodHandleD>(method4);
		Type[] array = new Type[2]
		{
			typeof(IntPtr),
			typeof(object)
		};
		Type type2 = typeof(RuntimeMethodHandle).Assembly.GetType("System.RuntimeMethodInfoStub");
		ConstructorInfo constructor = type2.GetConstructor(array);
		MethodInfo method5;
		using (DynamicMethodDefinition dynamicMethodDefinition3 = new DynamicMethodDefinition("new RuntimeMethodInfoStub", type2, array))
		{
			ILGenerator iLGenerator3 = dynamicMethodDefinition3.GetILGenerator();
			iLGenerator3.Emit(OpCodes.Ldarg_0);
			iLGenerator3.Emit(OpCodes.Ldarg_1);
			iLGenerator3.Emit(OpCodes.Newobj, constructor);
			iLGenerator3.Emit(OpCodes.Ret);
			method5 = dynamicMethodDefinition3.Generate();
		}
		CreateRuntimeMethodInfoStub = Extensions.CreateDelegate<CreateRuntimeMethodInfoStubD>(method5);
		ConstructorInfo con = typeof(RuntimeMethodHandle).GetConstructors(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).First();
		MethodInfo method6;
		using (DynamicMethodDefinition dynamicMethodDefinition4 = new DynamicMethodDefinition("new RuntimeMethodHandle", typeof(RuntimeMethodHandle), new Type[1] { typeof(object) }))
		{
			ILGenerator iLGenerator4 = dynamicMethodDefinition4.GetILGenerator();
			iLGenerator4.Emit(OpCodes.Ldarg_0);
			iLGenerator4.Emit(OpCodes.Newobj, con);
			iLGenerator4.Emit(OpCodes.Ret);
			method6 = dynamicMethodDefinition4.Generate();
		}
		CreateRuntimeMethodHandle = Extensions.CreateDelegate<CreateRuntimeMethodHandleD>(method6);
	}

	private static MethodInfo GetOrCreateGetTypeFromHandleUnsafe(Core21Runtime runtime)
	{
		MethodInfo method = typeof(Type).GetMethod("GetTypeFromHandleUnsafe", (BindingFlags)(-1));
		if ((object)method != null)
		{
			return method;
		}
		Assembly assembly;
		using (ModuleDefinition moduleDefinition = ModuleDefinition.CreateModule("MonoMod.Core.Platforms.Runtimes.Core30Runtime+Helpers", new ModuleParameters
		{
			Kind = ModuleKind.Dll
		}))
		{
			TypeDefinition typeDefinition = new TypeDefinition("System", "Type", Mono.Cecil.TypeAttributes.Public | Mono.Cecil.TypeAttributes.Abstract)
			{
				BaseType = moduleDefinition.TypeSystem.Object
			};
			moduleDefinition.Types.Add(typeDefinition);
			MethodDefinition methodDefinition = new MethodDefinition("GetTypeFromHandleUnsafe", Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Static, moduleDefinition.ImportReference(typeof(Type)))
			{
				IsInternalCall = true
			};
			methodDefinition.Parameters.Add(new ParameterDefinition(moduleDefinition.ImportReference(typeof(IntPtr))));
			typeDefinition.Methods.Add(methodDefinition);
			assembly = ReflectionHelper.Load(moduleDefinition);
		}
		runtime.MakeAssemblySystemAssembly(assembly);
		return assembly.GetType("System.Type").GetMethod("GetTypeFromHandleUnsafe", (BindingFlags)(-1));
	}
}


using System;

public delegate object MethodHandle_GetLoaderAllocatorD(IntPtr methodHandle);


using System;

public delegate object CreateRuntimeMethodInfoStubD(IntPtr methodHandle, object loaderAllocator);


using System;

public delegate RuntimeMethodHandle CreateRuntimeMethodHandleD(object runtimeMethodInfo);


using System;

public delegate Type GetDeclaringTypeOfMethodHandleD(IntPtr methodHandle);


using System;

public delegate Type GetTypeFromNativeHandleD(IntPtr handle);


using System;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal class Core30Runtime : Core21Runtime
{
	private static readonly Guid JitVersionGuid = new Guid(3590962897u, 30769, 18940, 189, 73, 182, 240, 84, 221, 77, 70);

	protected override Guid ExpectedJitVersion => JitVersionGuid;

	protected override CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr => CoreCLR.V21.InvokeCompileMethodPtr;

	public Core30Runtime(ISystem system)
		: base(system)
	{
	}

	protected override Delegate CastCompileHookToRealType(Delegate del)
	{
		return del.CastDelegate<CoreCLR.V21.CompileMethodDelegate>();
	}
}


using System;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal class Core31Runtime : Core30Runtime
{
	protected override CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr => CoreCLR.V21.InvokeCompileMethodPtr;

	public Core31Runtime(ISystem system)
		: base(system)
	{
	}

	protected override Delegate CastCompileHookToRealType(Delegate del)
	{
		return del.CastDelegate<CoreCLR.V21.CompileMethodDelegate>();
	}
}


using System;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal class Core50Runtime : Core31Runtime
{
	private static readonly Guid JitVersionGuid = new Guid(2783888292u, 16758, 17319, 140, 43, 160, 91, 85, 29, 79, 73);

	protected override Guid ExpectedJitVersion => JitVersionGuid;

	protected override int VtableIndexICorJitCompilerGetVersionGuid => 2;

	protected override CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr => CoreCLR.V21.InvokeCompileMethodPtr;

	public Core50Runtime(ISystem system)
		: base(system)
	{
	}

	protected override Delegate CastCompileHookToRealType(Delegate del)
	{
		return del.CastDelegate<CoreCLR.V21.CompileMethodDelegate>();
	}
}


using System;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal class Core60Runtime : Core50Runtime
{
	private static readonly Guid JitVersionGuid = new Guid(1590910040u, 34171, 18653, 168, 24, 124, 1, 54, 220, 159, 115);

	protected override Guid ExpectedJitVersion => JitVersionGuid;

	protected override CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr => CoreCLR.V60.InvokeCompileMethodPtr;

	public Core60Runtime(ISystem system)
		: base(system)
	{
	}

	protected override Delegate CastCompileHookToRealType(Delegate del)
	{
		return del.CastDelegate<CoreCLR.V60.CompileMethodDelegate>();
	}
}


using System;
using System.Collections.Concurrent;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;
using MonoMod;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal class Core70Runtime : Core60Runtime
{
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	protected struct ICorJitInfoWrapper
	{
		public IntPtr Vtbl;

		public unsafe IntPtr** Wrapped;

		public const int HotCodeRW = 0;

		public const int ColdCodeRW = 1;

		private const int DataQWords = 4;

		private unsafe fixed ulong data[4];

		public unsafe ref IntPtr this[int index] => ref Unsafe.Add(ref Unsafe.As<ulong, IntPtr>(ref data[0]), index);
	}

	private sealed class JitHookDelegateHolder
	{
		public readonly Core70Runtime Runtime;

		public readonly INativeExceptionHelper? NativeExceptionHelper;

		public readonly GetExceptionSlot? GetNativeExceptionSlot;

		public readonly JitHookHelpersHolder JitHookHelpers;

		public readonly CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr;

		public readonly IntPtr CompileMethodPtr;

		public readonly ThreadLocal<IAllocatedMemory> iCorJitInfoWrapper = new ThreadLocal<IAllocatedMemory>();

		public readonly ReadOnlyMemory<IAllocatedMemory> iCorJitInfoWrapperAllocs;

		public readonly IntPtr iCorJitInfoWrapperVtbl;

		[ThreadStatic]
		private static int hookEntrancy;

		public unsafe JitHookDelegateHolder(Core70Runtime runtime, CoreCLR.InvokeCompileMethodPtr icmp, IntPtr compileMethod)
		{
			Runtime = runtime;
			NativeExceptionHelper = runtime.NativeExceptionHelper;
			JitHookHelpers = runtime.JitHookHelpers;
			InvokeCompileMethodPtr = icmp;
			CompileMethodPtr = compileMethod;
			iCorJitInfoWrapperVtbl = Marshal.AllocHGlobal(IntPtr.Size * runtime.ICorJitInfoFullVtableCount);
			iCorJitInfoWrapperAllocs = Runtime.arch.CreateNativeVtableProxyStubs(iCorJitInfoWrapperVtbl, runtime.ICorJitInfoFullVtableCount);
			Runtime.PatchWrapperVtable((IntPtr*)(void*)iCorJitInfoWrapperVtbl);
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(42, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Allocated ICorJitInfo wrapper vtable at 0x");
				message.AppendFormatted(iCorJitInfoWrapperVtbl, "x16");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
			delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = icmp.InvokeCompileMethod;
			_ = IntPtr.Zero;
			_ = IntPtr.Zero;
			_ = IntPtr.Zero;
			CoreCLR.V21.CORINFO_METHOD_INFO cORINFO_METHOD_INFO = default(CoreCLR.V21.CORINFO_METHOD_INFO);
			_ = &cORINFO_METHOD_INFO;
			_ = 0;
			byte* ptr = default(byte*);
			_ = &ptr;
			uint num = default(uint);
			_ = &num;
			/*Error near IL_00e4: Handle with invalid row number.*/;
		}

		public unsafe CoreCLR.CorJitResult CompileMethodHook(IntPtr jit, IntPtr corJitInfo, CoreCLR.V21.CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode)
		{
			//Discarded unreachable code: IL_01b6, IL_0345, IL_0366
			*nativeEntry = null;
			*nativeSizeOfCode = 0u;
			if (jit == IntPtr.Zero)
			{
				return CoreCLR.CorJitResult.CORJIT_OK;
			}
			int lastPInvokeError = MarshalEx.GetLastPInvokeError();
			nint num = 0;
			GetExceptionSlot getNativeExceptionSlot = GetNativeExceptionSlot;
			IntPtr* ptr = ((getNativeExceptionSlot != null) ? getNativeExceptionSlot() : null);
			hookEntrancy++;
			try
			{
				if (hookEntrancy == 1)
				{
					try
					{
						IAllocatedMemory allocatedMemory = iCorJitInfoWrapper.Value;
						if (allocatedMemory == null)
						{
							AllocationRequest allocationRequest = new AllocationRequest(sizeof(ICorJitInfoWrapper));
							allocationRequest.Alignment = IntPtr.Size;
							allocationRequest.Executable = false;
							AllocationRequest request = allocationRequest;
							if (Runtime.System.MemoryAllocator.TryAllocate(request, out IAllocatedMemory allocated))
							{
								allocatedMemory = (iCorJitInfoWrapper.Value = allocated);
							}
						}
						if (allocatedMemory != null)
						{
							ICorJitInfoWrapper* ptr2 = (ICorJitInfoWrapper*)(void*)allocatedMemory.BaseAddress;
							ptr2->Vtbl = iCorJitInfoWrapperVtbl;
							ptr2->Wrapped = (IntPtr**)(void*)corJitInfo;
							(*ptr2)[0] = IntPtr.Zero;
							(*ptr2)[1] = IntPtr.Zero;
							corJitInfo = (IntPtr)ptr2;
						}
					}
					catch (Exception value)
					{
						try
						{
							bool isEnabled;
							<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(48, 1, out isEnabled);
							if (isEnabled)
							{
								message.AppendLiteral("Error while setting up the ICorJitInfo wrapper: ");
								message.AppendFormatted(value);
							}
							<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
						}
						catch
						{
						}
					}
				}
				delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = InvokeCompileMethodPtr.InvokeCompileMethod;
				_ = CompileMethodPtr;
				/*Error near IL_0154: Handle with invalid row number.*/;
			}
			finally
			{
				hookEntrancy--;
				if (ptr != null)
				{
					*ptr = num;
				}
				MarshalEx.SetLastPInvokeError(lastPInvokeError);
			}
		}
	}

	private sealed class AllocMemDelegateHolder
	{
		public readonly Core70Runtime Runtime;

		public readonly INativeExceptionHelper? NativeExceptionHelper;

		public readonly GetExceptionSlot? GetNativeExceptionSlot;

		public readonly CoreCLR.InvokeAllocMemPtr InvokeAllocMemPtr;

		public readonly int ICorJitInfoAllocMemIdx;

		public readonly ConcurrentDictionary<IntPtr, (IntPtr M2N, IDisposable?)> AllocMemExceptionHelperCache = new ConcurrentDictionary<IntPtr, (IntPtr, IDisposable)>();

		public unsafe AllocMemDelegateHolder(Core70Runtime runtime, CoreCLR.InvokeAllocMemPtr iamp)
		{
			Runtime = runtime;
			NativeExceptionHelper = runtime.NativeExceptionHelper;
			GetNativeExceptionSlot = NativeExceptionHelper?.GetExceptionSlot;
			InvokeAllocMemPtr = iamp;
			ICorJitInfoAllocMemIdx = Runtime.VtableIndexICorJitInfoAllocMem;
			delegate*<IntPtr, IntPtr, CoreCLR.V70.AllocMemArgs*, void> invokeAllocMem = iamp.InvokeAllocMem;
			_ = IntPtr.Zero;
			_ = IntPtr.Zero;
			_ = 0u;
			/*Error near IL_0069: Handle with invalid row number.*/;
		}

		private IntPtr GetRealInvokePtr(IntPtr ptr)
		{
			if (NativeExceptionHelper == null)
			{
				return ptr;
			}
			IDisposable handle;
			return AllocMemExceptionHelperCache.GetOrAdd(ptr, (IntPtr p) => (M2N: Runtime.EHManagedToNative(p, out handle), handle)).M2N;
		}

		public unsafe void AllocMemHook(IntPtr thisPtr, CoreCLR.V70.AllocMemArgs* args)
		{
			ICorJitInfoWrapper* ptr = (ICorJitInfoWrapper*)(void*)thisPtr;
			IntPtr** wrapped = ptr->Wrapped;
			delegate*<IntPtr, IntPtr, CoreCLR.V70.AllocMemArgs*, void> invokeAllocMem = InvokeAllocMemPtr.InvokeAllocMem;
			GetRealInvokePtr((*wrapped)[ICorJitInfoAllocMemIdx]);
			_ = (IntPtr)wrapped;
			/*Error near IL_003a: Handle with invalid row number.*/;
		}
	}

	private readonly IArchitecture arch;

	private static readonly Guid JitVersionGuid = new Guid(1810136669u, 43307, 19734, 146, 128, 246, 61, 246, 70, 173, 164);

	private Delegate? allocMemDelegate;

	private IDisposable? n2mAllocMemHelper;

	protected override Guid ExpectedJitVersion => JitVersionGuid;

	protected virtual int VtableIndexICorJitInfoAllocMem => 159;

	protected virtual int ICorJitInfoFullVtableCount => 175;

	protected virtual CoreCLR.InvokeAllocMemPtr InvokeAllocMemPtr => CoreCLR.V70.InvokeAllocMemPtr;

	public Core70Runtime(ISystem system, IArchitecture arch)
		: base(system)
	{
		this.arch = arch;
	}

	protected override Delegate CreateCompileMethodDelegate(IntPtr compileMethod)
	{
		return new <>f__AnonymousDelegate0(new JitHookDelegateHolder(this, InvokeCompileMethodPtr, compileMethod).CompileMethodHook);
	}

	protected unsafe virtual void PatchWrapperVtable(IntPtr* vtbl)
	{
		allocMemDelegate = CastAllocMemToRealType(CreateAllocMemDelegate());
		vtbl[VtableIndexICorJitInfoAllocMem] = EHNativeToManaged(Marshal.GetFunctionPointerForDelegate(allocMemDelegate), out n2mAllocMemHelper);
	}

	protected virtual Delegate CastAllocMemToRealType(Delegate del)
	{
		return del.CastDelegate<CoreCLR.V70.AllocMemDelegate>();
	}

	protected virtual Delegate CreateAllocMemDelegate()
	{
		return new <>f__AnonymousDelegate1(new AllocMemDelegateHolder(this, InvokeAllocMemPtr).AllocMemHook);
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 1)]
protected struct ICorJitInfoWrapper
{
	public IntPtr Vtbl;

	public unsafe IntPtr** Wrapped;

	public const int HotCodeRW = 0;

	public const int ColdCodeRW = 1;

	private const int DataQWords = 4;

	private unsafe fixed ulong data[4];

	public unsafe ref IntPtr this[int index] => ref Unsafe.Add(ref Unsafe.As<ulong, IntPtr>(ref data[0]), index);
}


using System;
using System.Runtime.InteropServices;
using System.Threading;
using MonoMod.Core.Interop;

private sealed class JitHookDelegateHolder
{
	public readonly Core70Runtime Runtime;

	public readonly INativeExceptionHelper? NativeExceptionHelper;

	public readonly GetExceptionSlot? GetNativeExceptionSlot;

	public readonly JitHookHelpersHolder JitHookHelpers;

	public readonly CoreCLR.InvokeCompileMethodPtr InvokeCompileMethodPtr;

	public readonly IntPtr CompileMethodPtr;

	public readonly ThreadLocal<IAllocatedMemory> iCorJitInfoWrapper = new ThreadLocal<IAllocatedMemory>();

	public readonly ReadOnlyMemory<IAllocatedMemory> iCorJitInfoWrapperAllocs;

	public readonly IntPtr iCorJitInfoWrapperVtbl;

	[ThreadStatic]
	private static int hookEntrancy;

	public unsafe JitHookDelegateHolder(Core70Runtime runtime, CoreCLR.InvokeCompileMethodPtr icmp, IntPtr compileMethod)
	{
		Runtime = runtime;
		NativeExceptionHelper = runtime.NativeExceptionHelper;
		JitHookHelpers = runtime.JitHookHelpers;
		InvokeCompileMethodPtr = icmp;
		CompileMethodPtr = compileMethod;
		iCorJitInfoWrapperVtbl = Marshal.AllocHGlobal(IntPtr.Size * runtime.ICorJitInfoFullVtableCount);
		iCorJitInfoWrapperAllocs = Runtime.arch.CreateNativeVtableProxyStubs(iCorJitInfoWrapperVtbl, runtime.ICorJitInfoFullVtableCount);
		Runtime.PatchWrapperVtable((IntPtr*)(void*)iCorJitInfoWrapperVtbl);
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(42, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Allocated ICorJitInfo wrapper vtable at 0x");
			message.AppendFormatted(iCorJitInfoWrapperVtbl, "x16");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message);
		delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = icmp.InvokeCompileMethod;
		_ = IntPtr.Zero;
		_ = IntPtr.Zero;
		_ = IntPtr.Zero;
		CoreCLR.V21.CORINFO_METHOD_INFO cORINFO_METHOD_INFO = default(CoreCLR.V21.CORINFO_METHOD_INFO);
		_ = &cORINFO_METHOD_INFO;
		_ = 0;
		byte* ptr = default(byte*);
		_ = &ptr;
		uint num = default(uint);
		_ = &num;
		/*Error near IL_00e4: Handle with invalid row number.*/;
	}

	public unsafe CoreCLR.CorJitResult CompileMethodHook(IntPtr jit, IntPtr corJitInfo, CoreCLR.V21.CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode)
	{
		//Discarded unreachable code: IL_01b6, IL_0345, IL_0366
		*nativeEntry = null;
		*nativeSizeOfCode = 0u;
		if (jit == IntPtr.Zero)
		{
			return CoreCLR.CorJitResult.CORJIT_OK;
		}
		int lastPInvokeError = MarshalEx.GetLastPInvokeError();
		nint num = 0;
		GetExceptionSlot getNativeExceptionSlot = GetNativeExceptionSlot;
		IntPtr* ptr = ((getNativeExceptionSlot != null) ? getNativeExceptionSlot() : null);
		hookEntrancy++;
		try
		{
			if (hookEntrancy == 1)
			{
				try
				{
					IAllocatedMemory allocatedMemory = iCorJitInfoWrapper.Value;
					if (allocatedMemory == null)
					{
						AllocationRequest allocationRequest = new AllocationRequest(sizeof(ICorJitInfoWrapper));
						allocationRequest.Alignment = IntPtr.Size;
						allocationRequest.Executable = false;
						AllocationRequest request = allocationRequest;
						if (Runtime.System.MemoryAllocator.TryAllocate(request, out IAllocatedMemory allocated))
						{
							allocatedMemory = (iCorJitInfoWrapper.Value = allocated);
						}
					}
					if (allocatedMemory != null)
					{
						ICorJitInfoWrapper* ptr2 = (ICorJitInfoWrapper*)(void*)allocatedMemory.BaseAddress;
						ptr2->Vtbl = iCorJitInfoWrapperVtbl;
						ptr2->Wrapped = (IntPtr**)(void*)corJitInfo;
						(*ptr2)[0] = IntPtr.Zero;
						(*ptr2)[1] = IntPtr.Zero;
						corJitInfo = (IntPtr)ptr2;
					}
				}
				catch (Exception value)
				{
					try
					{
						bool isEnabled;
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(48, 1, out isEnabled);
						if (isEnabled)
						{
							message.AppendLiteral("Error while setting up the ICorJitInfo wrapper: ");
							message.AppendFormatted(value);
						}
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
					}
					catch
					{
					}
				}
			}
			delegate*<IntPtr, IntPtr, IntPtr, CoreCLR.V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CoreCLR.CorJitResult> invokeCompileMethod = InvokeCompileMethodPtr.InvokeCompileMethod;
			_ = CompileMethodPtr;
			/*Error near IL_0154: Handle with invalid row number.*/;
		}
		finally
		{
			hookEntrancy--;
			if (ptr != null)
			{
				*ptr = num;
			}
			MarshalEx.SetLastPInvokeError(lastPInvokeError);
		}
	}
}


using System;
using System.Collections.Concurrent;
using MonoMod.Core.Interop;

private sealed class AllocMemDelegateHolder
{
	public readonly Core70Runtime Runtime;

	public readonly INativeExceptionHelper? NativeExceptionHelper;

	public readonly GetExceptionSlot? GetNativeExceptionSlot;

	public readonly CoreCLR.InvokeAllocMemPtr InvokeAllocMemPtr;

	public readonly int ICorJitInfoAllocMemIdx;

	public readonly ConcurrentDictionary<IntPtr, (IntPtr M2N, IDisposable?)> AllocMemExceptionHelperCache = new ConcurrentDictionary<IntPtr, (IntPtr, IDisposable)>();

	public unsafe AllocMemDelegateHolder(Core70Runtime runtime, CoreCLR.InvokeAllocMemPtr iamp)
	{
		Runtime = runtime;
		NativeExceptionHelper = runtime.NativeExceptionHelper;
		GetNativeExceptionSlot = NativeExceptionHelper?.GetExceptionSlot;
		InvokeAllocMemPtr = iamp;
		ICorJitInfoAllocMemIdx = Runtime.VtableIndexICorJitInfoAllocMem;
		delegate*<IntPtr, IntPtr, CoreCLR.V70.AllocMemArgs*, void> invokeAllocMem = iamp.InvokeAllocMem;
		_ = IntPtr.Zero;
		_ = IntPtr.Zero;
		_ = 0u;
		/*Error near IL_0069: Handle with invalid row number.*/;
	}

	private IntPtr GetRealInvokePtr(IntPtr ptr)
	{
		if (NativeExceptionHelper == null)
		{
			return ptr;
		}
		IDisposable handle;
		return AllocMemExceptionHelperCache.GetOrAdd(ptr, (IntPtr p) => (M2N: Runtime.EHManagedToNative(p, out handle), handle)).M2N;
	}

	public unsafe void AllocMemHook(IntPtr thisPtr, CoreCLR.V70.AllocMemArgs* args)
	{
		ICorJitInfoWrapper* ptr = (ICorJitInfoWrapper*)(void*)thisPtr;
		IntPtr** wrapped = ptr->Wrapped;
		delegate*<IntPtr, IntPtr, CoreCLR.V70.AllocMemArgs*, void> invokeAllocMem = InvokeAllocMemPtr.InvokeAllocMem;
		GetRealInvokePtr((*wrapped)[ICorJitInfoAllocMemIdx]);
		_ = (IntPtr)wrapped;
		/*Error near IL_003a: Handle with invalid row number.*/;
	}
}


using System;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;

internal class Core80Runtime : Core70Runtime
{
	private static readonly Guid JitVersionGuid = new Guid(1271838981u, 54608, 19037, 177, 235, 39, 111, byte.MaxValue, 104, 209, 131);

	protected override Guid ExpectedJitVersion => JitVersionGuid;

	protected override int VtableIndexICorJitInfoAllocMem => 154;

	protected override int ICorJitInfoFullVtableCount => 170;

	public Core80Runtime(ISystem system, IArchitecture arch)
		: base(system, arch)
	{
	}
}


using System;
using System.IO;
using System.Linq;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal abstract class CoreBaseRuntime : FxCoreBaseRuntime, IInitialize
{
	private IntPtr? lazyJitObject;

	private INativeExceptionHelper? lazyNativeExceptionHelper;

	public override RuntimeKind Target => RuntimeKind.CoreCLR;

	protected ISystem System { get; }

	protected IntPtr JitObject
	{
		get
		{
			IntPtr valueOrDefault = lazyJitObject.GetValueOrDefault();
			if (!lazyJitObject.HasValue)
			{
				valueOrDefault = GetJitObject();
				lazyJitObject = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
	}

	protected INativeExceptionHelper? NativeExceptionHelper => lazyNativeExceptionHelper ?? (lazyNativeExceptionHelper = System.NativeExceptionHelper);

	public static CoreBaseRuntime CreateForVersion(Version version, ISystem system, IArchitecture arch)
	{
		switch (version.Major)
		{
		case 2:
		case 4:
			return new Core21Runtime(system);
		case 3:
			return version.Minor switch
			{
				0 => new Core30Runtime(system), 
				1 => new Core31Runtime(system), 
				_ => throw new PlatformNotSupportedException($"Unknown .NET Core 3.x minor version {version.Minor}"), 
			};
		case 5:
			return new Core50Runtime(system);
		case 6:
			return new Core60Runtime(system);
		case 7:
			return new Core70Runtime(system, arch);
		case 8:
			return new Core80Runtime(system, arch);
		default:
			throw new PlatformNotSupportedException($"CoreCLR version {version} is not supported");
		}
	}

	protected CoreBaseRuntime(ISystem system)
	{
		System = system;
		if (PlatformDetection.Architecture == ArchitectureKind.x86_64)
		{
			Abi? defaultAbi = system.DefaultAbi;
			if (defaultAbi.HasValue)
			{
				Abi valueOrDefault = defaultAbi.GetValueOrDefault();
				AbiCore = FxCoreBaseRuntime.AbiForCoreFx45X64(valueOrDefault);
			}
		}
	}

	void IInitialize.Initialize()
	{
		InstallJitHook(JitObject);
	}

	private static bool IsMaybeClrJitPath(string path)
	{
		return Path.GetFileNameWithoutExtension(path).EndsWith("clrjit", StringComparison.Ordinal);
	}

	protected virtual string GetClrJitPath()
	{
		string text = null;
		bool isEnabled;
		if (Switches.TryGetSwitchValue("JitPath", out object value))
		{
			string jitPath = value as string;
			if (jitPath != null)
			{
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message;
				if (!IsMaybeClrJitPath(jitPath))
				{
					message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(77, 1, out isEnabled);
					if (isEnabled)
					{
						message.AppendLiteral("Provided value for MonoMod.JitPath switch '");
						message.AppendFormatted(jitPath);
						message.AppendLiteral("' does not look like a ClrJIT path");
					}
					<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
				}
				else
				{
					text = System.EnumerateLoadedModuleFiles().FirstOrDefault((string f) => f != null && f == jitPath);
					if (text == null)
					{
						message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(82, 1, out isEnabled);
						if (isEnabled)
						{
							message.AppendLiteral("Provided path for MonoMod.JitPath switch was not loaded in this process. jitPath: ");
							message.AppendFormatted(jitPath);
						}
						<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
					}
				}
			}
		}
		if (text == null)
		{
			text = System.EnumerateLoadedModuleFiles().FirstOrDefault((string f) => f != null && IsMaybeClrJitPath(f));
		}
		if (text == null)
		{
			throw new PlatformNotSupportedException("Could not locate clrjit library");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogTraceStringHandler(14, 1, out isEnabled);
		if (isEnabled)
		{
			message2.AppendLiteral("Got jit path: ");
			message2.AppendFormatted(text);
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Trace(ref message2);
		return text;
	}

	private unsafe IntPtr GetJitObject()
	{
		if (!DynDll.TryOpenLibrary(GetClrJitPath(), out var libraryPtr))
		{
			throw new PlatformNotSupportedException("Could not open clrjit library");
		}
		try
		{
			return ((delegate* unmanaged[Stdcall]<IntPtr>)(void*)libraryPtr.GetExport("getJit"))();
		}
		catch
		{
			DynDll.CloseLibrary(libraryPtr);
			throw;
		}
	}

	protected abstract void InstallJitHook(IntPtr jit);

	protected IntPtr EHNativeToManaged(IntPtr target, out IDisposable? handle)
	{
		if (NativeExceptionHelper != null)
		{
			return NativeExceptionHelper.CreateNativeToManagedHelper(target, out handle);
		}
		handle = null;
		return target;
	}

	protected IntPtr EHManagedToNative(IntPtr target, out IDisposable? handle)
	{
		if (NativeExceptionHelper != null)
		{
			return NativeExceptionHelper.CreateManagedToNativeHelper(target, out handle);
		}
		handle = null;
		return target;
	}
}


using System;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal abstract class FxBaseRuntime : FxCoreBaseRuntime
{
	public override RuntimeKind Target => RuntimeKind.Framework;

	public static FxBaseRuntime CreateForVersion(Version version, ISystem system)
	{
		if (version.Major == 4)
		{
			return new FxCLR4Runtime(system);
		}
		if (version.Major == 2)
		{
			return new FxCLR2Runtime(system);
		}
		throw new PlatformNotSupportedException($"CLR version {version} is not suppoted.");
	}
}


using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;

internal sealed class FxCLR2Runtime : FxBaseRuntime
{
	private readonly ISystem system;

	public FxCLR2Runtime(ISystem system)
	{
		this.system = system;
		Abi? abiCore = AbiCore;
		if (!abiCore.HasValue)
		{
			AbiCore = system.DefaultAbi;
		}
	}
}


using System;
using System.Reflection;
using MonoMod.Core.Interop;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal sealed class FxCLR4Runtime : FxBaseRuntime
{
	private ISystem system;

	public override RuntimeFeature Features => base.Features & ~RuntimeFeature.RequiresBodyThunkWalking;

	public FxCLR4Runtime(ISystem system)
	{
		this.system = system;
		if (PlatformDetection.Architecture == ArchitectureKind.x86_64 && (PlatformDetection.RuntimeVersion.Revision >= 17379 || PlatformDetection.RuntimeVersion.Minor >= 5))
		{
			Abi? defaultAbi = system.DefaultAbi;
			if (defaultAbi.HasValue)
			{
				Abi valueOrDefault = defaultAbi.GetValueOrDefault();
				AbiCore = FxCoreBaseRuntime.AbiForCoreFx45X64(valueOrDefault);
			}
		}
	}

	private unsafe IntPtr GetMethodBodyPtr(MethodBase method, RuntimeMethodHandle handle)
	{
		Fx.V48.MethodDesc* pMD = (Fx.V48.MethodDesc*)(void*)handle.Value;
		pMD = Fx.V48.MethodDesc.FindTightlyBoundWrappedMethodDesc(pMD);
		return (IntPtr)pMD->GetNativeCode();
	}

	public override IntPtr GetMethodEntryPoint(MethodBase method)
	{
		method = GetIdentifiable(method);
		RuntimeMethodHandle methodHandle = GetMethodHandle(method);
		bool flag = false;
		IntPtr methodBodyPtr;
		while (true)
		{
			Helpers.Assert(TryInvokeBclCompileMethod(methodHandle), null, "TryInvokeBclCompileMethod(handle)");
			methodHandle.GetFunctionPointer();
			methodBodyPtr = GetMethodBodyPtr(method, methodHandle);
			if (!(methodBodyPtr == IntPtr.Zero))
			{
				break;
			}
			if (!flag)
			{
				Helpers.Assert(TryInvokeBclCompileMethod(methodHandle), null, "TryInvokeBclCompileMethod(handle)");
				flag = true;
				continue;
			}
			methodBodyPtr = methodHandle.GetFunctionPointer();
			throw new InvalidOperationException($"Could not get entry point normally, GetFunctionPointer() = {methodBodyPtr:x16}");
		}
		return methodBodyPtr;
	}
}


using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal abstract class FxCoreBaseRuntime : IRuntime
{
	protected Abi? AbiCore;

	private static readonly Type? RTDynamicMethod = typeof(DynamicMethod).GetNestedType("RTDynamicMethod", BindingFlags.NonPublic);

	private static readonly FieldInfo? RTDynamicMethod_m_owner = RTDynamicMethod?.GetField("m_owner", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly FieldInfo? _DynamicMethod_m_method = typeof(DynamicMethod).GetField("m_method", BindingFlags.Instance | BindingFlags.NonPublic);

	private static readonly MethodInfo? _DynamicMethod_GetMethodDescriptor = typeof(DynamicMethod).GetMethod("GetMethodDescriptor", BindingFlags.Instance | BindingFlags.NonPublic);

	private static readonly MethodInfo? _RuntimeMethodHandle_get_Value = typeof(RuntimeMethodHandle).GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public);

	private static readonly FieldInfo? _RuntimeMethodHandle_m_value = typeof(RuntimeMethodHandle).GetField("m_value", BindingFlags.Instance | BindingFlags.NonPublic);

	private static readonly MethodInfo? _IRuntimeMethodInfo_get_Value = typeof(RuntimeMethodHandle).Assembly.GetType("System.IRuntimeMethodInfo")?.GetMethod("get_Value");

	private static readonly MethodInfo? _RuntimeHelpers__CompileMethod = typeof(RuntimeHelpers).GetMethod("_CompileMethod", BindingFlags.Static | BindingFlags.NonPublic) ?? typeof(RuntimeHelpers).GetMethod("CompileMethod", BindingFlags.Static | BindingFlags.NonPublic);

	private static readonly Type? RtH_CM_FirstArg;

	private static readonly bool _RuntimeHelpers__CompileMethod_TakesIntPtr;

	private static readonly bool _RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo;

	private static readonly bool _RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal;

	private Func<DynamicMethod, RuntimeMethodHandle>? lazyGetDmHandleHelper;

	private Action<RuntimeMethodHandle>? lazyBclCompileMethod;

	protected static readonly bool IsDebugClr;

	public abstract RuntimeKind Target { get; }

	public virtual MonoMod.Core.Platforms.RuntimeFeature Features => MonoMod.Core.Platforms.RuntimeFeature.PreciseGC | MonoMod.Core.Platforms.RuntimeFeature.GenericSharing | MonoMod.Core.Platforms.RuntimeFeature.DisableInlining | MonoMod.Core.Platforms.RuntimeFeature.RequiresMethodIdentification | MonoMod.Core.Platforms.RuntimeFeature.RequiresBodyThunkWalking | MonoMod.Core.Platforms.RuntimeFeature.HasKnownABI | MonoMod.Core.Platforms.RuntimeFeature.RequiresCustomMethodCompile;

	public Abi Abi => AbiCore ?? throw new PlatformNotSupportedException($"The runtime's Abi field is not set, and is unusable ({GetType()})");

	private Func<DynamicMethod, RuntimeMethodHandle> GetDMHandleHelper => lazyGetDmHandleHelper ?? (lazyGetDmHandleHelper = CreateGetDMHandleHelper());

	private static bool CanCreateGetDMHandleHelper => (object)_DynamicMethod_GetMethodDescriptor != null;

	private Action<RuntimeMethodHandle> BclCompileMethodHelper => lazyBclCompileMethod ?? (lazyBclCompileMethod = CreateBclCompileMethodHelper());

	private static bool CanCreateBclCompileMethodHelper
	{
		get
		{
			if ((object)_RuntimeHelpers__CompileMethod != null)
			{
				if (!_RuntimeHelpers__CompileMethod_TakesIntPtr)
				{
					if ((object)_RuntimeMethodHandle_m_value != null)
					{
						if (!_RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo)
						{
							if ((object)_IRuntimeMethodInfo_get_Value != null)
							{
								return _RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal;
							}
							return false;
						}
						return true;
					}
					return false;
				}
				return true;
			}
			return false;
		}
	}

	public event OnMethodCompiledCallback? OnMethodCompiled;

	private static TypeClassification ClassifyRyuJitX86(Type type, bool isReturn)
	{
		while (!type.IsPrimitive || type.IsEnum)
		{
			FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (fields == null || fields.Length != 1)
			{
				break;
			}
			type = fields[0].FieldType;
		}
		TypeCode typeCode = Type.GetTypeCode(type);
		bool flag = ((typeCode == TypeCode.Boolean || (uint)(typeCode - 5) <= 5u) ? true : false);
		if (flag || type == typeof(IntPtr) || type == typeof(UIntPtr))
		{
			return TypeClassification.InRegister;
		}
		flag = isReturn;
		if (flag)
		{
			bool flag2 = (uint)(typeCode - 11) <= 1u;
			flag = flag2;
		}
		if (flag)
		{
			return TypeClassification.InRegister;
		}
		if (isReturn)
		{
			return TypeClassification.ByReference;
		}
		return TypeClassification.OnStack;
	}

	protected FxCoreBaseRuntime()
	{
		if (PlatformDetection.Architecture == ArchitectureKind.x86)
		{
			AbiCore = new Abi(new SpecialArgumentKind[4]
			{
				SpecialArgumentKind.ThisPointer,
				SpecialArgumentKind.ReturnBuffer,
				SpecialArgumentKind.UserArguments,
				SpecialArgumentKind.GenericContext
			}, ClassifyRyuJitX86, ReturnsReturnBuffer: true);
		}
	}

	protected static Abi AbiForCoreFx45X64(Abi baseAbi)
	{
		return baseAbi with
		{
			ArgumentOrder = new SpecialArgumentKind[4]
			{
				SpecialArgumentKind.ThisPointer,
				SpecialArgumentKind.ReturnBuffer,
				SpecialArgumentKind.GenericContext,
				SpecialArgumentKind.UserArguments
			}
		};
	}

	public virtual MethodBase GetIdentifiable(MethodBase method)
	{
		if (RTDynamicMethod_m_owner != null && method.GetType() == RTDynamicMethod)
		{
			return (MethodBase)RTDynamicMethod_m_owner.GetValue(method);
		}
		return method;
	}

	public virtual RuntimeMethodHandle GetMethodHandle(MethodBase method)
	{
		if (method is DynamicMethod dynamicMethod)
		{
			if (TryGetDMHandle(dynamicMethod, out var handle) && TryInvokeBclCompileMethod(handle))
			{
				return handle;
			}
			try
			{
				dynamicMethod.CreateDelegate(typeof(MulticastDelegate));
			}
			catch
			{
			}
			if (TryGetDMHandle(dynamicMethod, out handle))
			{
				return handle;
			}
			if (_DynamicMethod_m_method != null)
			{
				return (RuntimeMethodHandle)_DynamicMethod_m_method.GetValue(method);
			}
		}
		return method.MethodHandle;
	}

	private static Func<DynamicMethod, RuntimeMethodHandle> CreateGetDMHandleHelper()
	{
		Helpers.Assert(CanCreateGetDMHandleHelper, null, "CanCreateGetDMHandleHelper");
		using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("get DynamicMethod RuntimeMethodHandle", typeof(RuntimeMethodHandle), new Type[1] { typeof(DynamicMethod) });
		_ = dynamicMethodDefinition.Module;
		ILProcessor iLProcessor = dynamicMethodDefinition.GetILProcessor();
		Helpers.Assert((object)_DynamicMethod_GetMethodDescriptor != null, null, "_DynamicMethod_GetMethodDescriptor is not null");
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_0);
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, _DynamicMethod_GetMethodDescriptor);
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
		return Extensions.CreateDelegate<Func<DynamicMethod, RuntimeMethodHandle>>(dynamicMethodDefinition.Generate());
	}

	private static Action<RuntimeMethodHandle> CreateBclCompileMethodHelper()
	{
		Helpers.Assert(CanCreateBclCompileMethodHelper, null, "CanCreateBclCompileMethodHelper");
		using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("invoke RuntimeHelpers.CompileMethod", null, new Type[1] { typeof(RuntimeMethodHandle) });
		ModuleDefinition module = dynamicMethodDefinition.Module;
		ILProcessor iLProcessor = dynamicMethodDefinition.GetILProcessor();
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarga_S, (byte)0);
		if (_RuntimeHelpers__CompileMethod_TakesIntPtr)
		{
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, module.ImportReference(_RuntimeMethodHandle_get_Value));
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, module.ImportReference(_RuntimeHelpers__CompileMethod));
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
			return Extensions.CreateDelegate<Action<RuntimeMethodHandle>>(dynamicMethodDefinition.Generate());
		}
		Helpers.Assert((object)_RuntimeMethodHandle_m_value != null, null, "_RuntimeMethodHandle_m_value is not null");
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldfld, module.ImportReference(_RuntimeMethodHandle_m_value));
		if (_RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo)
		{
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, module.ImportReference(_RuntimeHelpers__CompileMethod));
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
			return Extensions.CreateDelegate<Action<RuntimeMethodHandle>>(dynamicMethodDefinition.Generate());
		}
		Helpers.Assert((object)_IRuntimeMethodInfo_get_Value != null, null, "_IRuntimeMethodInfo_get_Value is not null");
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Callvirt, module.ImportReference(_IRuntimeMethodInfo_get_Value));
		if (_RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal)
		{
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, module.ImportReference(_RuntimeHelpers__CompileMethod));
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
			return Extensions.CreateDelegate<Action<RuntimeMethodHandle>>(dynamicMethodDefinition.Generate());
		}
		Helpers.Assert(value: false, "Tried to generate BCL CompileMethod helper when it's not possible? (This should never happen if CanCreateBclCompileMethodHelper is correct)", "false");
		throw new InvalidOperationException("UNREACHABLE");
	}

	private bool TryGetDMHandle(DynamicMethod dm, out RuntimeMethodHandle handle)
	{
		if (CanCreateGetDMHandleHelper)
		{
			handle = GetDMHandleHelper(dm);
			return true;
		}
		return TryGetDMHandleRefl(dm, out handle);
	}

	protected bool TryInvokeBclCompileMethod(RuntimeMethodHandle handle)
	{
		if (CanCreateBclCompileMethodHelper)
		{
			BclCompileMethodHelper(handle);
			return true;
		}
		return TryInvokeBclCompileMethodRefl(handle);
	}

	private static bool TryGetDMHandleRefl(DynamicMethod dm, out RuntimeMethodHandle handle)
	{
		handle = default(RuntimeMethodHandle);
		if ((object)_DynamicMethod_GetMethodDescriptor == null)
		{
			return false;
		}
		handle = (RuntimeMethodHandle)_DynamicMethod_GetMethodDescriptor.Invoke(dm, null);
		return true;
	}

	private static bool TryInvokeBclCompileMethodRefl(RuntimeMethodHandle handle)
	{
		if ((object)_RuntimeHelpers__CompileMethod == null)
		{
			return false;
		}
		if (_RuntimeHelpers__CompileMethod_TakesIntPtr)
		{
			_RuntimeHelpers__CompileMethod.Invoke(null, new object[1] { handle.Value });
			return true;
		}
		if ((object)_RuntimeMethodHandle_m_value == null)
		{
			return false;
		}
		object value = _RuntimeMethodHandle_m_value.GetValue(handle);
		if (_RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo)
		{
			_RuntimeHelpers__CompileMethod.Invoke(null, new object[1] { value });
			return true;
		}
		if ((object)_IRuntimeMethodInfo_get_Value == null)
		{
			return false;
		}
		object obj = _IRuntimeMethodInfo_get_Value.Invoke(value, null);
		if (_RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal)
		{
			_RuntimeHelpers__CompileMethod.Invoke(null, new object[1] { obj });
			return true;
		}
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(81, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Could not compile DynamicMethod using BCL reflection (_CompileMethod first arg: ");
			message.AppendFormatted(RtH_CM_FirstArg);
			message.AppendLiteral(")");
		}
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
		return false;
	}

	public virtual void Compile(MethodBase method)
	{
		RuntimeMethodHandle handle = GetMethodHandle(method);
		RuntimeHelpers.PrepareMethod(handle);
		Helpers.Assert(TryInvokeBclCompileMethod(handle), null, "TryInvokeBclCompileMethod(handle)");
		if (!method.IsVirtual)
		{
			return;
		}
		Type? declaringType = method.DeclaringType;
		if ((object)declaringType == null || !declaringType.IsValueType)
		{
			return;
		}
		if (TryGetCanonicalMethodHandle(ref handle))
		{
			Helpers.Assert(TryInvokeBclCompileMethod(handle), null, "TryInvokeBclCompileMethod(handle)");
			return;
		}
		try
		{
			method.CreateDelegate<Action>();
		}
		catch (Exception value)
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler(91, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Caught exception while attempting to compile real entry point of virtual method on struct: ");
				message.AppendFormatted(value);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Spam(ref message);
		}
	}

	protected virtual bool TryGetCanonicalMethodHandle(ref RuntimeMethodHandle handle)
	{
		return false;
	}

	public virtual IDisposable? PinMethodIfNeeded(MethodBase method)
	{
		return null;
	}

	public unsafe virtual void DisableInlining(MethodBase method)
	{
		RuntimeMethodHandle methodHandle = GetMethodHandle(method);
		int num = (IsDebugClr ? (IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size) : 0) + 2 + 1 + 1 + 2;
		ushort* ptr = (ushort*)((byte*)(void*)methodHandle.Value + num);
		*ptr |= 0x2000;
	}

	public virtual IntPtr GetMethodEntryPoint(MethodBase method)
	{
		method = GetIdentifiable(method);
		if (method.IsVirtual)
		{
			Type? declaringType = method.DeclaringType;
			if ((object)declaringType != null && declaringType.IsValueType)
			{
				return method.GetLdftnPointer();
			}
		}
		return GetMethodHandle(method).GetFunctionPointer();
	}

	protected virtual void OnMethodCompiledCore(RuntimeTypeHandle declaringType, RuntimeMethodHandle methodHandle, ReadOnlyMemory<RuntimeTypeHandle>? genericTypeArguments, ReadOnlyMemory<RuntimeTypeHandle>? genericMethodArguments, IntPtr methodBodyStart, IntPtr methodBodyRw, ulong methodBodySize)
	{
		bool isEnabled;
		<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message2;
		try
		{
			Type type = Type.GetTypeFromHandle(declaringType);
			if (genericTypeArguments.HasValue)
			{
				ReadOnlyMemory<RuntimeTypeHandle> valueOrDefault = genericTypeArguments.GetValueOrDefault();
				if (type.IsGenericTypeDefinition)
				{
					Type[] array = new Type[valueOrDefault.Length];
					for (int i = 0; i < valueOrDefault.Length; i++)
					{
						array[i] = Type.GetTypeFromHandle(valueOrDefault.Span[i]);
					}
					type = type.MakeGenericType(array);
				}
			}
			MethodBase methodBase = MethodBase.GetMethodFromHandle(methodHandle, type.TypeHandle);
			if ((object)methodBase == null)
			{
				MethodInfo[] methods = type.GetMethods((BindingFlags)(-1));
				foreach (MethodInfo methodInfo in methods)
				{
					if (methodInfo.MethodHandle.Value == methodHandle.Value)
					{
						methodBase = methodInfo;
						break;
					}
				}
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogSpamStringHandler(28, 3, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("JIT compiled ");
				message.AppendFormatted(methodBase);
				message.AppendLiteral(" to 0x");
				message.AppendFormatted(methodBodyStart, "x16");
				message.AppendLiteral(" (rw: 0x");
				message.AppendFormatted(methodBodyRw, "x16");
				message.AppendLiteral(")");
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Spam(ref message);
			try
			{
				this.OnMethodCompiled?.Invoke(methodHandle, methodBase, methodBodyStart, methodBodyRw, methodBodySize);
			}
			catch (Exception value)
			{
				message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(40, 1, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("Error executing OnMethodCompiled event: ");
					message2.AppendFormatted(value);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message2);
			}
		}
		catch (Exception value2)
		{
			message2 = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(31, 1, out isEnabled);
			if (isEnabled)
			{
				message2.AppendLiteral("Error in OnMethodCompiledCore: ");
				message2.AppendFormatted(value2);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message2);
		}
	}

	static FxCoreBaseRuntime()
	{
		MethodInfo? runtimeHelpers__CompileMethod = _RuntimeHelpers__CompileMethod;
		RtH_CM_FirstArg = (((object)runtimeHelpers__CompileMethod != null) ? runtimeHelpers__CompileMethod.GetParameters()[0].ParameterType : null);
		_RuntimeHelpers__CompileMethod_TakesIntPtr = RtH_CM_FirstArg?.FullName == "System.IntPtr";
		_RuntimeHelpers__CompileMethod_TakesIRuntimeMethodInfo = RtH_CM_FirstArg?.FullName == "System.IRuntimeMethodInfo";
		_RuntimeHelpers__CompileMethod_TakesRuntimeMethodHandleInternal = RtH_CM_FirstArg?.FullName == "System.RuntimeMethodHandleInternal";
		IsDebugClr = Switches.TryGetSwitchEnabled("DebugClr", out var isEnabled) && isEnabled;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Runtimes;
using MonoMod.Utils;

internal sealed class MonoRuntime : IRuntime
{
	private sealed class PrivateMethodPin
	{
		private readonly MonoRuntime runtime;

		public MethodPinInfo Pin;

		public PrivateMethodPin(MonoRuntime runtime)
		{
			this.runtime = runtime;
		}

		public void UnpinOnce()
		{
			runtime.UnpinOnce(this);
		}
	}

	private sealed class PinHandle : IDisposable
	{
		private readonly PrivateMethodPin pin;

		private bool disposedValue;

		public PinHandle(PrivateMethodPin pin)
		{
			this.pin = pin;
		}

		private void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				pin.UnpinOnce();
				disposedValue = true;
			}
		}

		~PinHandle()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}

	private struct MethodPinInfo
	{
		public int Count;

		public MethodBase Method;

		public RuntimeMethodHandle Handle;

		public override string ToString()
		{
			return $"(MethodPinInfo: {Count}, {Method}, 0x{(long)Handle.Value:X})";
		}
	}

	private readonly ISystem system;

	private static readonly MethodInfo _DynamicMethod_CreateDynMethod = typeof(DynamicMethod).GetMethod("CreateDynMethod", BindingFlags.Instance | BindingFlags.NonPublic);

	private static readonly FieldInfo _DynamicMethod_mhandle = typeof(DynamicMethod).GetField("mhandle", BindingFlags.Instance | BindingFlags.NonPublic);

	private readonly ConcurrentDictionary<MethodBase, PrivateMethodPin> pinnedMethods = new ConcurrentDictionary<MethodBase, PrivateMethodPin>();

	private readonly ConcurrentDictionary<RuntimeMethodHandle, PrivateMethodPin> pinnedHandles = new ConcurrentDictionary<RuntimeMethodHandle, PrivateMethodPin>();

	public RuntimeKind Target => RuntimeKind.Mono;

	public RuntimeFeature Features => RuntimeFeature.PreciseGC | RuntimeFeature.GenericSharing | RuntimeFeature.DisableInlining | RuntimeFeature.RequiresMethodPinning | RuntimeFeature.RequiresMethodIdentification | RuntimeFeature.RequiresCustomMethodCompile;

	public Abi Abi { get; }

	public event OnMethodCompiledCallback? OnMethodCompiled;

	private static TypeClassification LinuxAmd64Classifier(Type type, bool isReturn)
	{
		if (type.IsEnum)
		{
			type = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).First().FieldType;
		}
		switch (Type.GetTypeCode(type))
		{
		case TypeCode.Empty:
			return TypeClassification.InRegister;
		case TypeCode.Object:
		case TypeCode.DBNull:
		case TypeCode.String:
			return TypeClassification.InRegister;
		case TypeCode.Boolean:
		case TypeCode.Char:
		case TypeCode.SByte:
		case TypeCode.Byte:
		case TypeCode.Int16:
		case TypeCode.UInt16:
		case TypeCode.Int32:
		case TypeCode.UInt32:
		case TypeCode.Int64:
		case TypeCode.UInt64:
			return TypeClassification.InRegister;
		case TypeCode.Single:
		case TypeCode.Double:
			return TypeClassification.InRegister;
		default:
			if (type.IsPointer)
			{
				return TypeClassification.InRegister;
			}
			if (type.IsByRef)
			{
				return TypeClassification.InRegister;
			}
			if (type == typeof(IntPtr) || type == typeof(UIntPtr))
			{
				return TypeClassification.InRegister;
			}
			if (type == typeof(void))
			{
				return TypeClassification.InRegister;
			}
			Helpers.Assert(type.IsValueType, null, "type.IsValueType");
			return ClassifyValueType(type, isReturn: true);
		}
	}

	private static TypeClassification ClassifyValueType(Type type, bool isReturn)
	{
		int managedSize = type.GetManagedSize();
		bool flag = (!isReturn || managedSize != 8) && (isReturn || managedSize > 16);
		if (managedSize == 0)
		{
			return TypeClassification.InRegister;
		}
		if (flag)
		{
			if (!isReturn)
			{
				return TypeClassification.OnStack;
			}
			return TypeClassification.ByReference;
		}
		int num = ((managedSize <= 8) ? 1 : 2);
		int num2 = 1;
		int num3 = 1;
		if (isReturn && num != 1)
		{
			num2 = (num3 = 2);
		}
		if (num2 == 2 || num3 == 2)
		{
			num2 = 2;
		}
		return num2 switch
		{
			1 => TypeClassification.InRegister, 
			2 => TypeClassification.OnStack, 
			_ => throw new InvalidOperationException(), 
		};
	}

	private static IEnumerable<FieldInfo> NestedValutypeFields(Type type)
	{
		FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		FieldInfo[] array = fields;
		foreach (FieldInfo fieldInfo in array)
		{
			if (fieldInfo.FieldType.IsValueType)
			{
				foreach (FieldInfo item in NestedValutypeFields(fieldInfo.FieldType))
				{
					yield return item;
				}
			}
			else
			{
				yield return fieldInfo;
			}
		}
	}

	public MonoRuntime(ISystem system)
	{
		this.system = system;
		Abi? defaultAbi = system.DefaultAbi;
		if (defaultAbi.HasValue)
		{
			Abi abi = defaultAbi.GetValueOrDefault();
			OSKind kernel = PlatformDetection.OS.GetKernel();
			if (((kernel == OSKind.OSX || kernel == OSKind.Linux) ? true : false) && PlatformDetection.Architecture == ArchitectureKind.x86_64)
			{
				abi = abi with
				{
					Classifier = LinuxAmd64Classifier
				};
			}
			kernel = PlatformDetection.OS;
			bool flag = ((kernel == OSKind.Windows || kernel == OSKind.Wine) ? true : false);
			if (flag)
			{
				ArchitectureKind architecture = PlatformDetection.Architecture;
				flag = (uint)(architecture - 2) <= 1u;
			}
			if (flag)
			{
				abi = abi with
				{
					ArgumentOrder = new SpecialArgumentKind[3]
					{
						SpecialArgumentKind.ThisPointer,
						SpecialArgumentKind.ReturnBuffer,
						SpecialArgumentKind.UserArguments
					}
				};
			}
			Abi = abi;
			return;
		}
		throw new InvalidOperationException("Cannot use Mono system, because the underlying system doesn't provide a default ABI!");
	}

	public unsafe void DisableInlining(MethodBase method)
	{
		ushort* ptr = (ushort*)((long)GetMethodHandle(method).Value + 2);
		*ptr |= 8;
	}

	public RuntimeMethodHandle GetMethodHandle(MethodBase method)
	{
		if (method is DynamicMethod)
		{
			_DynamicMethod_CreateDynMethod?.Invoke(method, ArrayEx.Empty<object>());
			if (_DynamicMethod_mhandle != null)
			{
				return (RuntimeMethodHandle)_DynamicMethod_mhandle.GetValue(method);
			}
		}
		return method.MethodHandle;
	}

	public IDisposable? PinMethodIfNeeded(MethodBase method)
	{
		method = GetIdentifiable(method);
		PrivateMethodPin orAdd = pinnedMethods.GetOrAdd(method, delegate(MethodBase m)
		{
			PrivateMethodPin privateMethodPin = new PrivateMethodPin(this)
			{
				Pin = 
				{
					Method = m
				}
			};
			RuntimeMethodHandle key = (privateMethodPin.Pin.Handle = GetMethodHandle(m));
			pinnedHandles[key] = privateMethodPin;
			DisableInlining(method);
			_ = method.DeclaringType?.IsGenericType ?? false;
			return privateMethodPin;
		});
		Interlocked.Increment(ref orAdd.Pin.Count);
		return new PinHandle(orAdd);
	}

	private void UnpinOnce(PrivateMethodPin pin)
	{
		if (Interlocked.Decrement(ref pin.Pin.Count) <= 0)
		{
			pinnedMethods.TryRemove(pin.Pin.Method, out PrivateMethodPin value);
			pinnedHandles.TryRemove(pin.Pin.Handle, out value);
		}
	}

	public MethodBase GetIdentifiable(MethodBase method)
	{
		if (!pinnedHandles.TryGetValue(GetMethodHandle(method), out PrivateMethodPin value))
		{
			return method;
		}
		return value.Pin.Method;
	}

	public IntPtr GetMethodEntryPoint(MethodBase method)
	{
		if (pinnedMethods.TryGetValue(method, out PrivateMethodPin value))
		{
			return value.Pin.Handle.GetFunctionPointer();
		}
		return GetMethodHandle(method).GetFunctionPointer();
	}

	public void Compile(MethodBase method)
	{
		GetMethodHandle(method).GetFunctionPointer();
	}
}


private sealed class PrivateMethodPin
{
	private readonly MonoRuntime runtime;

	public MethodPinInfo Pin;

	public PrivateMethodPin(MonoRuntime runtime)
	{
		this.runtime = runtime;
	}

	public void UnpinOnce()
	{
		runtime.UnpinOnce(this);
	}
}


using System;

private sealed class PinHandle : IDisposable
{
	private readonly PrivateMethodPin pin;

	private bool disposedValue;

	public PinHandle(PrivateMethodPin pin)
	{
		this.pin = pin;
	}

	private void Dispose(bool disposing)
	{
		if (!disposedValue)
		{
			pin.UnpinOnce();
			disposedValue = true;
		}
	}

	~PinHandle()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}


using System;
using System.Reflection;

private struct MethodPinInfo
{
	public int Count;

	public MethodBase Method;

	public RuntimeMethodHandle Handle;

	public override string ToString()
	{
		return $"(MethodPinInfo: {Count}, {Method}, 0x{(long)Handle.Value:X})";
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Threading;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Memory;

internal abstract class PagedMemoryAllocator : IMemoryAllocator
{
	private sealed class FreeMem
	{
		public uint BaseOffset;

		public uint Size;

		public FreeMem? NextFree;
	}

	protected sealed class PageAllocation : IAllocatedMemory, IDisposable
	{
		private readonly Page owner;

		private readonly uint offset;

		private bool disposedValue;

		public bool IsExecutable => owner.IsExecutable;

		public IntPtr BaseAddress => (nint)owner.BaseAddr + (nint)offset;

		public int Size { get; }

		public unsafe Span<byte> Memory => new Span<byte>((void*)BaseAddress, Size);

		public PageAllocation(Page page, uint offset, int size)
		{
			owner = page;
			this.offset = offset;
			Size = size;
		}

		private void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				owner.FreeMem(offset, (uint)Size);
				disposedValue = true;
			}
		}

		~PageAllocation()
		{
			Dispose(disposing: false);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}

	protected sealed class Page
	{
		private readonly PagedMemoryAllocator owner;

		private readonly object sync = new object();

		private FreeMem? freeList;

		public bool IsEmpty
		{
			get
			{
				FreeMem freeMem = freeList;
				if (freeMem != null && freeMem.BaseOffset == 0)
				{
					return freeMem.Size == Size;
				}
				return false;
			}
		}

		public IntPtr BaseAddr { get; }

		public uint Size { get; }

		public bool IsExecutable { get; }

		public Page(PagedMemoryAllocator owner, IntPtr baseAddr, uint size, bool isExecutable)
		{
			this.owner = owner;
			BaseAddr = baseAddr;
			Size = size;
			IsExecutable = isExecutable;
			freeList = new FreeMem
			{
				BaseOffset = 0u,
				Size = size,
				NextFree = null
			};
		}

		public bool TryAllocate(uint size, uint align, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out PageAllocation alloc)
		{
			lock (sync)
			{
				ref FreeMem nextFree = ref freeList;
				uint num = 0u;
				while (nextFree != null)
				{
					uint num2 = nextFree.BaseOffset % align;
					num2 = ((num2 != 0) ? (align - num2) : num2);
					if (nextFree.Size >= num2 + size)
					{
						num = num2;
						break;
					}
					nextFree = ref nextFree.NextFree;
				}
				if (nextFree == null)
				{
					alloc = null;
					return false;
				}
				uint offset = nextFree.BaseOffset + num;
				if (num == 0)
				{
					nextFree.BaseOffset += size;
					nextFree.Size -= size;
				}
				else
				{
					FreeMem freeMem = new FreeMem
					{
						BaseOffset = nextFree.BaseOffset,
						Size = num,
						NextFree = nextFree
					};
					nextFree.BaseOffset += num + size;
					nextFree.Size -= num + size;
					nextFree = freeMem;
				}
				NormalizeFreeList();
				alloc = new PageAllocation(this, offset, (int)size);
				return true;
			}
		}

		private void NormalizeFreeList()
		{
			ref FreeMem nextFree = ref freeList;
			while (nextFree != null)
			{
				if (nextFree.Size == 0)
				{
					nextFree = nextFree.NextFree;
					continue;
				}
				FreeMem nextFree2 = nextFree.NextFree;
				if (nextFree2 != null && nextFree2.BaseOffset == nextFree.BaseOffset + nextFree.Size)
				{
					nextFree.Size += nextFree2.Size;
					nextFree.NextFree = nextFree2.NextFree;
				}
				else
				{
					nextFree = ref nextFree.NextFree;
				}
			}
		}

		internal void FreeMem(uint offset, uint size)
		{
			lock (sync)
			{
				ref FreeMem nextFree = ref freeList;
				while (nextFree != null && nextFree.BaseOffset <= offset)
				{
					nextFree = ref nextFree.NextFree;
				}
				nextFree = new FreeMem
				{
					BaseOffset = offset,
					Size = size,
					NextFree = nextFree
				};
				NormalizeFreeList();
				if (IsEmpty)
				{
					owner.RegisterForCleanup(this);
				}
			}
		}
	}

	[StructLayout(LayoutKind.Sequential, Size = 1)]
	private readonly struct PageComparer : IComparer<Page?>
	{
		public int Compare(Page? x, Page? y)
		{
			if (x == y)
			{
				return 0;
			}
			if (x == null)
			{
				return 1;
			}
			if (y == null)
			{
				return -1;
			}
			return ((long)x.BaseAddr).CompareTo((long)y.BaseAddr);
		}
	}

	private readonly struct PageAddrComparable : IComparable<Page>
	{
		private readonly IntPtr addr;

		public PageAddrComparable(IntPtr addr)
		{
			this.addr = addr;
		}

		public int CompareTo(Page? other)
		{
			if (other == null)
			{
				return 1;
			}
			return ((long)addr).CompareTo((long)other.BaseAddr);
		}
	}

	private readonly nint pageBaseMask;

	private readonly nint pageSize;

	private readonly bool pageSizeIsPow2;

	private Page?[] allocationList = new Page[16];

	private int pageCount;

	private readonly ConcurrentBag<Page> pagesToClean = new ConcurrentBag<Page>();

	private int registeredForCleanup;

	private readonly object sync = new object();

	protected nint PageSize => pageSize;

	private ReadOnlySpan<Page> AllocList => MemoryExtensions.AsSpan(allocationList).Slice(0, pageCount);

	public int MaxSize => (int)pageSize;

	protected PagedMemoryAllocator(nint pageSize)
	{
		this.pageSize = pageSize;
		pageSizeIsPow2 = BitOperationsEx.IsPow2(pageSize);
		pageBaseMask = ~(nint)0 << BitOperationsEx.TrailingZeroCount(pageSize);
	}

	public nint RoundDownToPageBoundary(nint addr)
	{
		if (pageSizeIsPow2)
		{
			return addr & pageBaseMask;
		}
		return addr - addr % pageSize;
	}

	protected void InsertAllocatedPage(Page page)
	{
		if (pageCount == allocationList.Length)
		{
			int newSize = (int)BitOperationsEx.RoundUpToPowerOf2((uint)(allocationList.Length + 1));
			Array.Resize(ref allocationList, newSize);
		}
		Span<Page> span = MemoryExtensions.AsSpan(allocationList);
		int num = span.Slice(0, pageCount).BinarySearch(page, default(PageComparer));
		if (num < 0)
		{
			num = ~num;
			if (num + 1 < span.Length)
			{
				span.Slice(num, pageCount - num).CopyTo(span.Slice(num + 1));
			}
			span[num] = page;
			pageCount++;
		}
	}

	private void RemoveAllocatedPage(Page page)
	{
		Span<Page> span = MemoryExtensions.AsSpan(allocationList);
		int num = span.Slice(0, pageCount).BinarySearch(page, default(PageComparer));
		if (num >= 0)
		{
			span.Slice(num + 1).CopyTo(span.Slice(num));
			pageCount--;
		}
	}

	private int GetBoundIndex(IntPtr ptr)
	{
		int num = MemoryExtensions.BinarySearch(AllocList, new PageAddrComparable(ptr));
		if (num < 0)
		{
			return ~num;
		}
		return num;
	}

	protected void RegisterForCleanup(Page page)
	{
		if (!Environment.HasShutdownStarted && !AppDomain.CurrentDomain.IsFinalizingForUnload())
		{
			pagesToClean.Add(page);
			if (Interlocked.CompareExchange(ref registeredForCleanup, 1, 0) == 0)
			{
				System.Gen2GcCallback.Register(DoCleanup);
			}
		}
	}

	private bool DoCleanup()
	{
		if (Environment.HasShutdownStarted || AppDomain.CurrentDomain.IsFinalizingForUnload())
		{
			return false;
		}
		Volatile.Write(ref registeredForCleanup, 0);
		Page result;
		while (pagesToClean.TryTake(out result))
		{
			lock (sync)
			{
				if (!result.IsEmpty)
				{
					continue;
				}
				RemoveAllocatedPage(result);
				goto IL_005e;
			}
			IL_005e:
			if (!TryFreePage(result, out string errorMsg))
			{
				bool isEnabled;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(27, 1, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("Could not deallocate page! ");
					message.AppendFormatted(errorMsg);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
			}
		}
		return false;
	}

	protected abstract bool TryFreePage(Page page, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg);

	public bool TryAllocateInRange(PositionedAllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		if ((nint)request.Target < (nint)request.LowBound || (nint)request.Target > (nint)request.HighBound)
		{
			throw new ArgumentException("Target not between low and high", "request");
		}
		if (request.Base.Size < 0)
		{
			throw new ArgumentException("Size is negative", "request");
		}
		if (request.Base.Alignment <= 0)
		{
			throw new ArgumentException("Alignment is zero or negative", "request");
		}
		if (request.Base.Size > pageSize)
		{
			throw new NotSupportedException("Single allocations cannot be larger than a page");
		}
		nint num = RoundDownToPageBoundary((nint)request.LowBound + pageSize - 1);
		nint num2 = RoundDownToPageBoundary(request.HighBound);
		nint num3 = RoundDownToPageBoundary(request.Target);
		nint target = request.Target;
		lock (sync)
		{
			int boundIndex = GetBoundIndex(num);
			int boundIndex2 = GetBoundIndex(num2);
			if (boundIndex != boundIndex2)
			{
				int boundIndex3 = GetBoundIndex(num3);
				int i = boundIndex3 - 1;
				int j = boundIndex3;
				while ((uint)j <= AllocList.Length && (uint)i < AllocList.Length && (i >= boundIndex || j < boundIndex2))
				{
					for (; (uint)j < AllocList.Length && j < boundIndex2 && (i < boundIndex || target - (nint)AllocList[i].BaseAddr > (nint)AllocList[j].BaseAddr - target); j++)
					{
						if (TryAllocWithPage(AllocList[j], request, out allocated))
						{
							return true;
						}
					}
					for (; (uint)i < AllocList.Length && i >= boundIndex && (j >= boundIndex2 || target - (nint)AllocList[i].BaseAddr < (nint)AllocList[j].BaseAddr - target); i++)
					{
						if (TryAllocWithPage(AllocList[i], request, out allocated))
						{
							return true;
						}
					}
				}
			}
			return TryAllocateNewPage(request, num3, num, num2, out allocated);
		}
	}

	private static bool TryAllocWithPage(Page page, PositionedAllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		if (page.IsExecutable == request.Base.Executable && (nint)page.BaseAddr >= (nint)request.LowBound && (nint)page.BaseAddr < (nint)request.HighBound && page.TryAllocate((uint)request.Base.Size, (uint)request.Base.Alignment, out PageAllocation alloc))
		{
			if ((nint)alloc.BaseAddress >= (nint)request.LowBound && (nint)alloc.BaseAddress < (nint)request.HighBound)
			{
				allocated = alloc;
				return true;
			}
			alloc.Dispose();
		}
		allocated = null;
		return false;
	}

	public bool TryAllocate(AllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		if (request.Size < 0)
		{
			throw new ArgumentException("Size is negative", "request");
		}
		if (request.Alignment <= 0)
		{
			throw new ArgumentException("Alignment is zero or negative", "request");
		}
		if (request.Size > pageSize)
		{
			throw new NotSupportedException("Single allocations cannot be larger than a page");
		}
		lock (sync)
		{
			ReadOnlySpan<Page> allocList = AllocList;
			for (int i = 0; i < allocList.Length; i++)
			{
				Page page = allocList[i];
				if (page.IsExecutable == request.Executable && page.TryAllocate((uint)request.Size, (uint)request.Alignment, out PageAllocation alloc))
				{
					allocated = alloc;
					return true;
				}
			}
			return TryAllocateNewPage(request, out allocated);
		}
	}

	protected abstract bool TryAllocateNewPage(AllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated);

	protected abstract bool TryAllocateNewPage(PositionedAllocationRequest request, nint targetPage, nint lowPageBound, nint highPageBound, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated);
}


private sealed class FreeMem
{
	public uint BaseOffset;

	public uint Size;

	public FreeMem? NextFree;
}


using System;

protected sealed class PageAllocation : IAllocatedMemory, IDisposable
{
	private readonly Page owner;

	private readonly uint offset;

	private bool disposedValue;

	public bool IsExecutable => owner.IsExecutable;

	public IntPtr BaseAddress => (nint)owner.BaseAddr + (nint)offset;

	public int Size { get; }

	public unsafe Span<byte> Memory => new Span<byte>((void*)BaseAddress, Size);

	public PageAllocation(Page page, uint offset, int size)
	{
		owner = page;
		this.offset = offset;
		Size = size;
	}

	private void Dispose(bool disposing)
	{
		if (!disposedValue)
		{
			owner.FreeMem(offset, (uint)Size);
			disposedValue = true;
		}
	}

	~PageAllocation()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

protected sealed class Page
{
	private readonly PagedMemoryAllocator owner;

	private readonly object sync = new object();

	private FreeMem? freeList;

	public bool IsEmpty
	{
		get
		{
			FreeMem freeMem = freeList;
			if (freeMem != null && freeMem.BaseOffset == 0)
			{
				return freeMem.Size == Size;
			}
			return false;
		}
	}

	public IntPtr BaseAddr { get; }

	public uint Size { get; }

	public bool IsExecutable { get; }

	public Page(PagedMemoryAllocator owner, IntPtr baseAddr, uint size, bool isExecutable)
	{
		this.owner = owner;
		BaseAddr = baseAddr;
		Size = size;
		IsExecutable = isExecutable;
		freeList = new FreeMem
		{
			BaseOffset = 0u,
			Size = size,
			NextFree = null
		};
	}

	public bool TryAllocate(uint size, uint align, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out PageAllocation alloc)
	{
		lock (sync)
		{
			ref FreeMem nextFree = ref freeList;
			uint num = 0u;
			while (nextFree != null)
			{
				uint num2 = nextFree.BaseOffset % align;
				num2 = ((num2 != 0) ? (align - num2) : num2);
				if (nextFree.Size >= num2 + size)
				{
					num = num2;
					break;
				}
				nextFree = ref nextFree.NextFree;
			}
			if (nextFree == null)
			{
				alloc = null;
				return false;
			}
			uint offset = nextFree.BaseOffset + num;
			if (num == 0)
			{
				nextFree.BaseOffset += size;
				nextFree.Size -= size;
			}
			else
			{
				FreeMem freeMem = new FreeMem
				{
					BaseOffset = nextFree.BaseOffset,
					Size = num,
					NextFree = nextFree
				};
				nextFree.BaseOffset += num + size;
				nextFree.Size -= num + size;
				nextFree = freeMem;
			}
			NormalizeFreeList();
			alloc = new PageAllocation(this, offset, (int)size);
			return true;
		}
	}

	private void NormalizeFreeList()
	{
		ref FreeMem nextFree = ref freeList;
		while (nextFree != null)
		{
			if (nextFree.Size == 0)
			{
				nextFree = nextFree.NextFree;
				continue;
			}
			FreeMem nextFree2 = nextFree.NextFree;
			if (nextFree2 != null && nextFree2.BaseOffset == nextFree.BaseOffset + nextFree.Size)
			{
				nextFree.Size += nextFree2.Size;
				nextFree.NextFree = nextFree2.NextFree;
			}
			else
			{
				nextFree = ref nextFree.NextFree;
			}
		}
	}

	internal void FreeMem(uint offset, uint size)
	{
		lock (sync)
		{
			ref FreeMem nextFree = ref freeList;
			while (nextFree != null && nextFree.BaseOffset <= offset)
			{
				nextFree = ref nextFree.NextFree;
			}
			nextFree = new FreeMem
			{
				BaseOffset = offset,
				Size = size,
				NextFree = nextFree
			};
			NormalizeFreeList();
			if (IsEmpty)
			{
				owner.RegisterForCleanup(this);
			}
		}
	}
}


using System.Collections.Generic;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
private readonly struct PageComparer : IComparer<Page?>
{
	public int Compare(Page? x, Page? y)
	{
		if (x == y)
		{
			return 0;
		}
		if (x == null)
		{
			return 1;
		}
		if (y == null)
		{
			return -1;
		}
		return ((long)x.BaseAddr).CompareTo((long)y.BaseAddr);
	}
}


using System;

private readonly struct PageAddrComparable : IComparable<Page>
{
	private readonly IntPtr addr;

	public PageAddrComparable(IntPtr addr)
	{
		this.addr = addr;
	}

	public int CompareTo(Page? other)
	{
		if (other == null)
		{
			return 1;
		}
		return ((long)addr).CompareTo((long)other.BaseAddr);
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

internal abstract class QueryingMemoryPageAllocatorBase
{
	public abstract uint PageSize { get; }

	public abstract bool TryQueryPage(IntPtr pageAddr, out bool isFree, out IntPtr allocBase, out nint allocSize);

	public abstract bool TryAllocatePage(nint size, bool executable, out IntPtr allocated);

	public abstract bool TryAllocatePage(IntPtr pageAddr, nint size, bool executable, out IntPtr allocated);

	public abstract bool TryFreePage(IntPtr pageAddr, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg);
}


using System.Diagnostics.CodeAnalysis;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Memory;
using MonoMod.Utils;

internal sealed class QueryingPagedMemoryAllocator : PagedMemoryAllocator
{
	private readonly QueryingMemoryPageAllocatorBase pageAlloc;

	public QueryingPagedMemoryAllocator(QueryingMemoryPageAllocatorBase alloc)
		: base((nint)Helpers.ThrowIfNull(alloc, "alloc").PageSize)
	{
		pageAlloc = alloc;
	}

	protected override bool TryAllocateNewPage(AllocationRequest request, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		if (!pageAlloc.TryAllocatePage(base.PageSize, request.Executable, out var allocated2))
		{
			allocated = null;
			return false;
		}
		Page page = new Page(this, allocated2, (uint)base.PageSize, request.Executable);
		InsertAllocatedPage(page);
		if (!page.TryAllocate((uint)request.Size, (uint)request.Alignment, out PageAllocation alloc))
		{
			RegisterForCleanup(page);
			allocated = null;
			return false;
		}
		allocated = alloc;
		return true;
	}

	protected override bool TryAllocateNewPage(PositionedAllocationRequest request, nint targetPage, nint lowPageBound, nint highPageBound, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		nint target = request.Target;
		nint page = targetPage;
		nint page2 = targetPage + base.PageSize;
		while (page >= lowPageBound || page2 < highPageBound)
		{
			while (page2 < highPageBound && (page < lowPageBound || target - page > page2 - target))
			{
				if (TryAllocNewPage(request, ref page2, goingUp: true, out allocated))
				{
					return true;
				}
			}
			while (page >= lowPageBound && (page2 >= highPageBound || target - page < page2 - target))
			{
				if (TryAllocNewPage(request, ref page, goingUp: false, out allocated))
				{
					return true;
				}
			}
		}
		allocated = null;
		return false;
	}

	private bool TryAllocNewPage(PositionedAllocationRequest request, ref nint page, bool goingUp, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MaybeNullWhen(false)] out IAllocatedMemory allocated)
	{
		if (pageAlloc.TryQueryPage(page, out bool isFree, out nint allocBase, out nint allocSize))
		{
			if (isFree && pageAlloc.TryAllocatePage(page, base.PageSize, request.Base.Executable, out var allocated2))
			{
				Page page2 = new Page(this, allocated2, (uint)base.PageSize, request.Base.Executable);
				InsertAllocatedPage(page2);
				if (page2.TryAllocate((uint)request.Base.Size, (uint)request.Base.Alignment, out PageAllocation alloc))
				{
					allocated = alloc;
					return true;
				}
				RegisterForCleanup(page2);
			}
			if (goingUp)
			{
				page = allocBase + allocSize;
			}
			else
			{
				page = allocBase - base.PageSize;
			}
			allocated = null;
			return false;
		}
		if (goingUp)
		{
			page += base.PageSize;
		}
		else
		{
			page -= base.PageSize;
		}
		allocated = null;
		return false;
	}

	protected override bool TryFreePage(Page page, [<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>NotNullWhen(false)] out string? errorMsg)
	{
		return pageAlloc.TryFreePage(page.BaseAddr, out errorMsg);
	}
}


using System;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Architectures;
using MonoMod.Utils;

internal abstract class DetourKindBase : INativeDetourKind
{
	public abstract int Size { get; }

	public abstract int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle);

	public static int GetDetourBytes(NativeDetourInfo info, Span<byte> buffer, out IDisposable? allocHandle)
	{
		Helpers.ThrowIfArgumentNull(info.InternalKind, "info.InternalKind");
		if (buffer.Length < info.Size)
		{
			throw new ArgumentException("Buffer too short", "buffer");
		}
		return ((DetourKindBase)info.InternalKind).GetBytes(info.From, info.To, buffer, info.InternalData, out allocHandle);
	}

	public abstract bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo);

	public static bool TryFindRetargetInfo(NativeDetourInfo info, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
	{
		Helpers.ThrowIfArgumentNull(info.InternalKind, "info.InternalKind");
		return ((DetourKindBase)info.InternalKind).TryGetRetargetInfo(info, to, maxSize, out retargetInfo);
	}

	public abstract int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc);

	public static int DoRetarget(NativeDetourInfo orig, NativeDetourInfo info, Span<byte> buffer, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		Helpers.ThrowIfArgumentNull(info.InternalKind, "info.InternalKind");
		if (buffer.Length < info.Size)
		{
			throw new ArgumentException("Buffer too short", "buffer");
		}
		return ((DetourKindBase)info.InternalKind).DoRetarget(orig, info.To, buffer, info.InternalData, out allocationHandle, out needsRepatch, out disposeOldAlloc);
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using MonoMod.Core.Platforms;
using MonoMod.Utils;

internal static class Shared
{
	public unsafe static ReadOnlyMemory<IAllocatedMemory> CreateVtableStubs(ISystem system, IntPtr vtableBase, int vtableSize, ReadOnlySpan<byte> stubData, int indexOffs, bool premulOffset)
	{
		int maxSize = system.MemoryAllocator.MaxSize;
		int num = stubData.Length * vtableSize;
		int num2 = num / maxSize;
		int num3 = maxSize / stubData.Length;
		int num4 = num3 * stubData.Length;
		int num5 = num % num4;
		IAllocatedMemory[] array = new IAllocatedMemory[num2 + ((num5 != 0) ? 1 : 0)];
		byte[] array2 = ArrayPool<byte>.Shared.Rent(num4);
		Span<byte> backup = MemoryExtensions.AsSpan(array2);
		Span<byte> span = backup.Slice(0, num4);
		for (int j = 0; j < num3; j++)
		{
			stubData.CopyTo(span.Slice(j * stubData.Length));
		}
		ref IntPtr vtblBase2 = ref Unsafe.AsRef<IntPtr>((void*)vtableBase);
		AllocationRequest allocationRequest = new AllocationRequest(num4);
		allocationRequest.Alignment = IntPtr.Size;
		allocationRequest.Executable = true;
		AllocationRequest allocationRequest2 = allocationRequest;
		for (int k = 0; k < num2; k++)
		{
			Helpers.Assert(system.MemoryAllocator.TryAllocate(allocationRequest2, out IAllocatedMemory allocated), null, "system.MemoryAllocator.TryAllocate(allocReq, out var alloc)");
			array[k] = allocated;
			FillBufferIndicies(stubData.Length, indexOffs, num3, k, span, premulOffset);
			FillVtbl(stubData.Length, num3 * k, ref vtblBase2, num3, allocated.BaseAddress);
			IntPtr baseAddress = allocated.BaseAddress;
			ReadOnlySpan<byte> data = span;
			backup = default(Span<byte>);
			system.PatchData(PatchTargetKind.Executable, baseAddress, data, backup);
		}
		if (num5 > 0)
		{
			allocationRequest2 = allocationRequest2 with
			{
				Size = num5
			};
			Helpers.Assert(system.MemoryAllocator.TryAllocate(allocationRequest2, out IAllocatedMemory allocated2), null, "system.MemoryAllocator.TryAllocate(allocReq, out var alloc)");
			array[^1] = allocated2;
			FillBufferIndicies(stubData.Length, indexOffs, num3, num2, span, premulOffset);
			FillVtbl(stubData.Length, num3 * num2, ref vtblBase2, num5 / stubData.Length, allocated2.BaseAddress);
			IntPtr baseAddress2 = allocated2.BaseAddress;
			ReadOnlySpan<byte> data2 = span.Slice(0, num5);
			backup = default(Span<byte>);
			system.PatchData(PatchTargetKind.Executable, baseAddress2, data2, backup);
		}
		ArrayPool<byte>.Shared.Return(array2);
		return array;
		static void FillBufferIndicies(int stubSize, int indexOffs, int numPerAlloc, int i, Span<byte> mainAllocBuf, bool premul)
		{
			for (int l = 0; l < numPerAlloc; l++)
			{
				ref byte destination = ref mainAllocBuf[l * stubSize + indexOffs];
				uint num6 = (uint)(numPerAlloc * i + l);
				if (premul)
				{
					num6 *= (uint)IntPtr.Size;
				}
				Unsafe.WriteUnaligned(ref destination, num6);
			}
		}
		static void FillVtbl(int stubSize, int baseIndex, ref IntPtr vtblBase, int numEntries, nint baseAddr)
		{
			for (int m = 0; m < numEntries; m++)
			{
				Unsafe.Add(ref vtblBase, baseIndex + m) = baseAddr + stubSize * m;
			}
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Architectures;
using MonoMod.Core.Platforms.Architectures.AltEntryFactories;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal sealed class x86Arch : IArchitecture
{
	private sealed class Abs32Kind : DetourKindBase
	{
		public static readonly Abs32Kind Instance = new Abs32Kind();

		public override int Size => 6;

		public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
		{
			buffer[0] = 104;
			Unsafe.WriteUnaligned(ref buffer[1], Unsafe.As<IntPtr, int>(ref to));
			buffer[5] = 195;
			allocHandle = null;
			return Size;
		}

		public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
		{
			retargetInfo = orig with
			{
				To = to
			};
			return true;
		}

		public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
		{
			needsRepatch = true;
			disposeOldAlloc = true;
			return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
		}
	}

	private BytePatternCollection? lazyKnownMethodThunks;

	private readonly ISystem system;

	private const int WinThisVtableThunkIndexOffs = 7;

	private const int SpecEntryStubArgOffs = 1;

	private const int SpecEntryStubTargetOffs = 6;

	public ArchitectureKind Target => ArchitectureKind.x86;

	public ArchitectureFeature Features => ArchitectureFeature.CreateAltEntryPoint;

	public unsafe BytePatternCollection KnownMethodThunks => Helpers.GetOrInit(ref lazyKnownMethodThunks, (delegate*<BytePatternCollection>)(&CreateKnownMethodThunks));

	public IAltEntryFactory AltEntryFactory { get; }

	private static ReadOnlySpan<byte> WinThisVtableProxyThunk => new byte[12]
	{
		139, 73, 4, 139, 1, 255, 160, 85, 85, 85,
		85, 204
	};

	private static ReadOnlySpan<byte> SpecEntryStub => new byte[12]
	{
		184, 0, 0, 0, 0, 185, 0, 0, 0, 0,
		255, 225
	};

	private static BytePatternCollection CreateKnownMethodThunks()
	{
		RuntimeKind runtime = PlatformDetection.Runtime;
		if ((uint)(runtime - 1) <= 1u)
		{
			return new BytePatternCollection(new BytePattern(new AddressMeaning(AddressKind.Rel32, 16), 184, 65280, 65280, 65280, 65280, 144, 232, 65280, 65280, 65280, 65280, 233, 65282, 65282, 65282, 65282), new BytePattern(new AddressMeaning(AddressKind.Rel32, 5), true, 233, 65282, 65282, 65282, 65282, 95), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkRel32, 5), true, 232, 65282, 65282, 65282, 65282, 94), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkRel32, 5), true, 232, 65282, 65282, 65282, 65282, 204), new BytePattern(new AddressMeaning(AddressKind.Abs32 | AddressKind.Indirect), true, 255, 37, 65282, 65282, 65282, 65282, 161, 65280, 65280, 65280, 65280, 255, 37, 65280, 65280, 65280, 65280), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkAbs32 | AddressKind.Indirect), true, 161, 65280, 65280, 65280, 65280, 255, 37, 65282, 65282, 65282, 65282), null);
		}
		return new BytePatternCollection();
	}

	public NativeDetourInfo ComputeDetourInfo(IntPtr from, IntPtr to, int maxSizeHint = -1)
	{
		x86Shared.FixSizeHint(ref maxSizeHint);
		if (x86Shared.TryRel32Detour(from, to, maxSizeHint, out var info))
		{
			return info;
		}
		if (maxSizeHint < Abs32Kind.Instance.Size)
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(79, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Size too small for all known detour kinds; defaulting to Abs32. provided size: ");
				message.AppendFormatted(maxSizeHint);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
		}
		return new NativeDetourInfo(from, to, Abs32Kind.Instance, null);
	}

	public int GetDetourBytes(NativeDetourInfo info, Span<byte> buffer, out IDisposable? allocationHandle)
	{
		return DetourKindBase.GetDetourBytes(info, buffer, out allocationHandle);
	}

	public NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr to, int maxSizeHint = -1)
	{
		x86Shared.FixSizeHint(ref maxSizeHint);
		if (DetourKindBase.TryFindRetargetInfo(detour, to, maxSizeHint, out var retargetInfo))
		{
			return retargetInfo;
		}
		return ComputeDetourInfo(detour.From, to, maxSizeHint);
	}

	public int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span<byte> buffer, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		return DetourKindBase.DoRetarget(original, retarget, buffer, out allocationHandle, out needsRepatch, out disposeOldAlloc);
	}

	public x86Arch(ISystem system)
	{
		this.system = system;
		AltEntryFactory = new IcedAltEntryFactory(system, 32);
	}

	public ReadOnlyMemory<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize)
	{
		OSKind kernel = PlatformDetection.OS.GetKernel();
		bool premulOffset = true;
		if (kernel.Is(OSKind.Windows))
		{
			ReadOnlySpan<byte> winThisVtableProxyThunk = WinThisVtableProxyThunk;
			int indexOffs = 7;
			return Shared.CreateVtableStubs(system, vtableBase, vtableSize, winThisVtableProxyThunk, indexOffs, premulOffset);
		}
		throw new PlatformNotSupportedException();
	}

	public IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument)
	{
		Span<byte> span = stackalloc byte[SpecEntryStub.Length];
		SpecEntryStub.CopyTo(span);
		Unsafe.WriteUnaligned(ref span[6], target);
		Unsafe.WriteUnaligned(ref span[1], argument);
		Helpers.Assert(system.MemoryAllocator.TryAllocate(new AllocationRequest(span.Length)
		{
			Executable = true,
			Alignment = 1
		}, out IAllocatedMemory allocated), null, "system.MemoryAllocator.TryAllocate(new(stub.Length) { Executable = true, Alignment = 1 }, out var alloc)");
		system.PatchData(PatchTargetKind.Executable, allocated.BaseAddress, span, default(Span<byte>));
		return allocated;
	}
}


using System;
using System.Runtime.CompilerServices;

private sealed class Abs32Kind : DetourKindBase
{
	public static readonly Abs32Kind Instance = new Abs32Kind();

	public override int Size => 6;

	public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
	{
		buffer[0] = 104;
		Unsafe.WriteUnaligned(ref buffer[1], Unsafe.As<IntPtr, int>(ref to));
		buffer[5] = 195;
		allocHandle = null;
		return Size;
	}

	public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
	{
		retargetInfo = orig with
		{
			To = to
		};
		return true;
	}

	public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		needsRepatch = true;
		disposeOldAlloc = true;
		return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Architectures;

internal static class x86Shared
{
	public sealed class Rel32Kind : DetourKindBase
	{
		public static readonly Rel32Kind Instance = new Rel32Kind();

		public override int Size => 5;

		public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
		{
			buffer[0] = 233;
			Unsafe.WriteUnaligned(ref buffer[1], (int)((nint)to - ((nint)from + 5)));
			allocHandle = null;
			return Size;
		}

		public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
		{
			nint num = (nint)to - ((nint)orig.From + 5);
			if (Is32Bit(num) || Is32Bit(-num))
			{
				retargetInfo = new NativeDetourInfo(orig.From, to, Instance, null);
				return true;
			}
			retargetInfo = default(NativeDetourInfo);
			return false;
		}

		public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
		{
			needsRepatch = true;
			disposeOldAlloc = true;
			return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
		}
	}

	public static void FixSizeHint(ref int sizeHint)
	{
		if (sizeHint < 0)
		{
			sizeHint = int.MaxValue;
		}
	}

	public unsafe static bool TryRel32Detour(nint from, nint to, int sizeHint, out NativeDetourInfo info)
	{
		nint num = to - (from + 5);
		if (sizeHint >= Rel32Kind.Instance.Size && (Is32Bit(num) || Is32Bit(-num)) && *(byte*)(from + 5) != 95)
		{
			info = new NativeDetourInfo(from, to, Rel32Kind.Instance, null);
			return true;
		}
		info = default(NativeDetourInfo);
		return false;
	}

	public static bool Is32Bit(long to)
	{
		return (to & 0x7FFFFFFF) == to;
	}
}


using System;
using System.Runtime.CompilerServices;

public sealed class Rel32Kind : DetourKindBase
{
	public static readonly Rel32Kind Instance = new Rel32Kind();

	public override int Size => 5;

	public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
	{
		buffer[0] = 233;
		Unsafe.WriteUnaligned(ref buffer[1], (int)((nint)to - ((nint)from + 5)));
		allocHandle = null;
		return Size;
	}

	public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
	{
		nint num = (nint)to - ((nint)orig.From + 5);
		if (Is32Bit(num) || Is32Bit(-num))
		{
			retargetInfo = new NativeDetourInfo(orig.From, to, Instance, null);
			return true;
		}
		retargetInfo = default(NativeDetourInfo);
		return false;
	}

	public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		needsRepatch = true;
		disposeOldAlloc = true;
		return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Architectures;
using MonoMod.Core.Platforms.Architectures.AltEntryFactories;
using MonoMod.Core.Utils;
using MonoMod.Utils;

internal sealed class x86_64Arch : IArchitecture
{
	private sealed class Abs64Kind : DetourKindBase
	{
		public static readonly Abs64Kind Instance = new Abs64Kind();

		public override int Size => 14;

		public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
		{
			buffer[0] = byte.MaxValue;
			buffer[1] = 37;
			Unsafe.WriteUnaligned(ref buffer[2], 0);
			Unsafe.WriteUnaligned(ref buffer[6], (long)to);
			allocHandle = null;
			return Size;
		}

		public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
		{
			retargetInfo = orig with
			{
				To = to
			};
			return true;
		}

		public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
		{
			needsRepatch = true;
			disposeOldAlloc = true;
			return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
		}
	}

	private sealed class Rel32Ind64Kind : DetourKindBase
	{
		public static readonly Rel32Ind64Kind Instance = new Rel32Ind64Kind();

		public override int Size => 6;

		public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
		{
			Helpers.ThrowIfArgumentNull(data, "data");
			IAllocatedMemory allocatedMemory = (IAllocatedMemory)data;
			buffer[0] = byte.MaxValue;
			buffer[1] = 37;
			Unsafe.WriteUnaligned(ref buffer[2], (int)((nint)allocatedMemory.BaseAddress - ((nint)from + 6)));
			Unsafe.WriteUnaligned(ref allocatedMemory.Memory[0], to);
			allocHandle = allocatedMemory;
			return Size;
		}

		public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
		{
			retargetInfo = orig with
			{
				To = to
			};
			return true;
		}

		public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
		{
			if (origInfo.InternalKind == this)
			{
				needsRepatch = false;
				disposeOldAlloc = false;
				Helpers.ThrowIfArgumentNull(data, "data");
				IAllocatedMemory allocatedMemory = (IAllocatedMemory)data;
				Unsafe.WriteUnaligned(ref allocatedMemory.Memory[0], to);
				allocationHandle = allocatedMemory;
				return 0;
			}
			needsRepatch = true;
			disposeOldAlloc = true;
			return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
		}
	}

	private BytePatternCollection? lazyKnownMethodThunks;

	private readonly ISystem system;

	private const int VtblProxyStubIdxOffs = 9;

	private const bool VtblProxyStubIdxPremul = true;

	private const int SpecEntryStubArgOffs = 2;

	private const int SpecEntryStubTargetOffs = 12;

	public ArchitectureKind Target => ArchitectureKind.x86_64;

	public ArchitectureFeature Features => ArchitectureFeature.Immediate64 | ArchitectureFeature.CreateAltEntryPoint;

	public unsafe BytePatternCollection KnownMethodThunks => Helpers.GetOrInit(ref lazyKnownMethodThunks, (delegate*<BytePatternCollection>)(&CreateKnownMethodThunks));

	public IAltEntryFactory AltEntryFactory { get; }

	private static ReadOnlySpan<byte> VtblProxyStubWin => new byte[16]
	{
		72, 139, 73, 8, 72, 139, 1, 255, 160, 85,
		85, 85, 85, 204, 204, 204
	};

	private static ReadOnlySpan<byte> VtblProxyStubSysV => new byte[16]
	{
		72, 139, 127, 8, 72, 139, 7, 255, 160, 85,
		85, 85, 85, 204, 204, 204
	};

	private static ReadOnlySpan<byte> SpecEntryStub => new byte[23]
	{
		72, 184, 0, 0, 0, 0, 0, 0, 0, 0,
		73, 186, 0, 0, 0, 0, 0, 0, 0, 0,
		65, 255, 226
	};

	private static BytePatternCollection CreateKnownMethodThunks()
	{
		RuntimeKind runtime = PlatformDetection.Runtime;
		if ((uint)(runtime - 1) <= 1u)
		{
			return new BytePatternCollection(new BytePattern(new AddressMeaning(AddressKind.Abs64), true, 72, 133, 201, 116, 65280, 72, 139, 1, 73, 65280, 65280, 65280, 65280, 65280, 65280, 65280, 65280, 65280, 73, 59, 194, 116, 65280, 72, 184, 65282, 65282, 65282, 65282, 65282, 65282, 65282, 65282), new BytePattern(new AddressMeaning(AddressKind.Rel32, 5), true, 233, 65282, 65282, 65282, 65282, 95), new BytePattern(new AddressMeaning(AddressKind.Abs64), false, 72, 184, 65282, 65282, 65282, 65282, 65282, 65282, 65282, 65282, 255, 224), new BytePattern(new AddressMeaning(AddressKind.Rel32, 19), mustMatchAtStart: false, new byte[19]
			{
				240, 255, 0, 0, 0, 0, 0, 0, 0, 0,
				255, 255, 240, 255, 255, 0, 0, 0, 0
			}, new byte[19]
			{
				64, 184, 0, 0, 0, 0, 0, 0, 0, 0,
				102, 255, 0, 15, 133, 2, 2, 2, 2
			}), new BytePattern(new AddressMeaning(AddressKind.Abs64), mustMatchAtStart: false, new byte[27]
			{
				240, 255, 0, 0, 0, 0, 0, 0, 0, 0,
				255, 255, 240, 255, 0, 255, 255, 0, 0, 0,
				0, 0, 0, 0, 0, 255, 255
			}, new byte[27]
			{
				64, 184, 0, 0, 0, 0, 0, 0, 0, 0,
				102, 255, 0, 116, 0, 72, 184, 2, 2, 2,
				2, 2, 2, 2, 2, 255, 224
			}), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkRel32, 5), true, 232, 65282, 65282, 65282, 65282, 94), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkRel32, 5), true, 232, 65282, 65282, 65282, 65282, 204), new BytePattern(new AddressMeaning(AddressKind.Indirect, 6), mustMatchAtStart: true, new byte[19]
			{
				255, 255, 0, 0, 0, 0, 255, 255, 255, 255,
				255, 255, 255, 255, 255, 255, 255, 255, 255
			}, new byte[19]
			{
				255, 37, 2, 2, 2, 2, 76, 139, 21, 251,
				15, 0, 0, 255, 37, 253, 15, 0, 0
			}), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkRel32 | AddressKind.Indirect, 13), mustMatchAtStart: true, new byte[13]
			{
				255, 255, 255, 255, 255, 255, 255, 255, 255, 0,
				0, 0, 0
			}, new byte[13]
			{
				76, 139, 21, 251, 15, 0, 0, 255, 37, 2,
				2, 2, 2
			}), new BytePattern(new AddressMeaning(AddressKind.Indirect, 18), mustMatchAtStart: true, new byte[24]
			{
				255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
				255, 255, 255, 255, 0, 0, 0, 0, 255, 255,
				255, 255, 255, 255
			}, new byte[24]
			{
				72, 139, 5, 249, 15, 0, 0, 102, 255, 8,
				116, 6, 255, 37, 2, 2, 2, 2, 255, 37,
				248, 15, 0, 0
			}), new BytePattern(new AddressMeaning(AddressKind.Indirect, 6), mustMatchAtStart: true, new byte[19]
			{
				255, 255, 0, 0, 0, 0, 255, 255, 255, 255,
				255, 255, 255, 255, 255, 255, 255, 255, 255
			}, new byte[19]
			{
				255, 37, 2, 2, 2, 2, 76, 139, 21, 251,
				63, 0, 0, 255, 37, 253, 63, 0, 0
			}), new BytePattern(new AddressMeaning(AddressKind.PrecodeFixupThunkRel32 | AddressKind.Indirect, 13), mustMatchAtStart: true, new byte[13]
			{
				255, 255, 255, 255, 255, 255, 255, 255, 255, 0,
				0, 0, 0
			}, new byte[13]
			{
				76, 139, 21, 251, 63, 0, 0, 255, 37, 2,
				2, 2, 2
			}), new BytePattern(new AddressMeaning(AddressKind.Indirect, 18), mustMatchAtStart: true, new byte[24]
			{
				255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
				255, 255, 255, 255, 0, 0, 0, 0, 255, 255,
				255, 255, 255, 255
			}, new byte[24]
			{
				72, 139, 5, 249, 63, 0, 0, 102, 255, 8,
				116, 6, 255, 37, 2, 2, 2, 2, 255, 37,
				248, 63, 0, 0
			}), null);
		}
		return new BytePatternCollection();
	}

	public x86_64Arch(ISystem system)
	{
		this.system = system;
		AltEntryFactory = new IcedAltEntryFactory(system, 64);
	}

	public NativeDetourInfo ComputeDetourInfo(nint from, nint to, int sizeHint)
	{
		x86Shared.FixSizeHint(ref sizeHint);
		if (x86Shared.TryRel32Detour(from, to, sizeHint, out var info))
		{
			return info;
		}
		nint num = from + 6;
		nint num2 = num + int.MinValue;
		if ((nuint)num2 > (nuint)num)
		{
			num2 = 0;
		}
		nint num3 = num + int.MaxValue;
		if ((nuint)num3 < (nuint)num)
		{
			num3 = -1;
		}
		PositionedAllocationRequest request = new PositionedAllocationRequest(num, num2, num3, new AllocationRequest(IntPtr.Size));
		if (sizeHint >= Rel32Ind64Kind.Instance.Size && system.MemoryAllocator.TryAllocateInRange(request, out IAllocatedMemory allocated))
		{
			return new NativeDetourInfo(from, to, Rel32Ind64Kind.Instance, allocated);
		}
		if (sizeHint < Abs64Kind.Instance.Size)
		{
			bool isEnabled;
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogWarningStringHandler(79, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Size too small for all known detour kinds; defaulting to Abs64. provided size: ");
				message.AppendFormatted(sizeHint);
			}
			<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Warning(ref message);
		}
		return new NativeDetourInfo(from, to, Abs64Kind.Instance, null);
	}

	public int GetDetourBytes(NativeDetourInfo info, Span<byte> buffer, out IDisposable? allocHandle)
	{
		return DetourKindBase.GetDetourBytes(info, buffer, out allocHandle);
	}

	public NativeDetourInfo ComputeRetargetInfo(NativeDetourInfo detour, IntPtr to, int maxSizeHint = -1)
	{
		x86Shared.FixSizeHint(ref maxSizeHint);
		if (DetourKindBase.TryFindRetargetInfo(detour, to, maxSizeHint, out var retargetInfo))
		{
			return retargetInfo;
		}
		return ComputeDetourInfo(detour.From, to, maxSizeHint);
	}

	public int GetRetargetBytes(NativeDetourInfo original, NativeDetourInfo retarget, Span<byte> buffer, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		return DetourKindBase.DoRetarget(original, retarget, buffer, out allocationHandle, out needsRepatch, out disposeOldAlloc);
	}

	public ReadOnlyMemory<IAllocatedMemory> CreateNativeVtableProxyStubs(IntPtr vtableBase, int vtableSize)
	{
		ReadOnlySpan<byte> stubData;
		int indexOffs;
		bool premulOffset;
		if (PlatformDetection.OS.Is(OSKind.Windows))
		{
			stubData = VtblProxyStubWin;
			indexOffs = 9;
			premulOffset = true;
		}
		else
		{
			stubData = VtblProxyStubSysV;
			indexOffs = 9;
			premulOffset = true;
		}
		return Shared.CreateVtableStubs(system, vtableBase, vtableSize, stubData, indexOffs, premulOffset);
	}

	public IAllocatedMemory CreateSpecialEntryStub(IntPtr target, IntPtr argument)
	{
		Span<byte> span = stackalloc byte[SpecEntryStub.Length];
		SpecEntryStub.CopyTo(span);
		Unsafe.WriteUnaligned(ref span[12], target);
		Unsafe.WriteUnaligned(ref span[2], argument);
		Helpers.Assert(system.MemoryAllocator.TryAllocate(new AllocationRequest(span.Length)
		{
			Executable = true,
			Alignment = 1
		}, out IAllocatedMemory allocated), null, "system.MemoryAllocator.TryAllocate(new(stub.Length) { Executable = true, Alignment = 1 }, out var alloc)");
		system.PatchData(PatchTargetKind.Executable, allocated.BaseAddress, span, default(Span<byte>));
		return allocated;
	}
}


using System;
using System.Runtime.CompilerServices;

private sealed class Abs64Kind : DetourKindBase
{
	public static readonly Abs64Kind Instance = new Abs64Kind();

	public override int Size => 14;

	public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
	{
		buffer[0] = byte.MaxValue;
		buffer[1] = 37;
		Unsafe.WriteUnaligned(ref buffer[2], 0);
		Unsafe.WriteUnaligned(ref buffer[6], (long)to);
		allocHandle = null;
		return Size;
	}

	public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
	{
		retargetInfo = orig with
		{
			To = to
		};
		return true;
	}

	public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		needsRepatch = true;
		disposeOldAlloc = true;
		return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Utils;

private sealed class Rel32Ind64Kind : DetourKindBase
{
	public static readonly Rel32Ind64Kind Instance = new Rel32Ind64Kind();

	public override int Size => 6;

	public override int GetBytes(IntPtr from, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocHandle)
	{
		Helpers.ThrowIfArgumentNull(data, "data");
		IAllocatedMemory allocatedMemory = (IAllocatedMemory)data;
		buffer[0] = byte.MaxValue;
		buffer[1] = 37;
		Unsafe.WriteUnaligned(ref buffer[2], (int)((nint)allocatedMemory.BaseAddress - ((nint)from + 6)));
		Unsafe.WriteUnaligned(ref allocatedMemory.Memory[0], to);
		allocHandle = allocatedMemory;
		return Size;
	}

	public override bool TryGetRetargetInfo(NativeDetourInfo orig, IntPtr to, int maxSize, out NativeDetourInfo retargetInfo)
	{
		retargetInfo = orig with
		{
			To = to
		};
		return true;
	}

	public override int DoRetarget(NativeDetourInfo origInfo, IntPtr to, Span<byte> buffer, object? data, out IDisposable? allocationHandle, out bool needsRepatch, out bool disposeOldAlloc)
	{
		if (origInfo.InternalKind == this)
		{
			needsRepatch = false;
			disposeOldAlloc = false;
			Helpers.ThrowIfArgumentNull(data, "data");
			IAllocatedMemory allocatedMemory = (IAllocatedMemory)data;
			Unsafe.WriteUnaligned(ref allocatedMemory.Memory[0], to);
			allocationHandle = allocatedMemory;
			return 0;
		}
		needsRepatch = true;
		disposeOldAlloc = true;
		return GetBytes(origInfo.From, to, buffer, data, out allocationHandle);
	}
}


using System;
using System.Buffers;
using Iced.Intel;
using MonoMod;
using MonoMod.Core.Platforms;
using MonoMod.Core.Platforms.Architectures.AltEntryFactories;
using MonoMod.Utils;

internal sealed class IcedAltEntryFactory : IAltEntryFactory
{
	private sealed class PtrCodeReader : CodeReader
	{
		public IntPtr Base { get; }

		public int Position { get; private set; }

		public PtrCodeReader(IntPtr basePtr)
		{
			Base = basePtr;
			Position = 0;
		}

		public unsafe override int ReadByte()
		{
			return *(byte*)((nint)Base + Position++);
		}
	}

	private sealed class NullCodeWriter : CodeWriter
	{
		public override void WriteByte(byte value)
		{
		}
	}

	private sealed class BufferCodeWriter : CodeWriter, IDisposable
	{
		private readonly ArrayPool<byte> pool;

		private byte[]? buffer;

		private int pos;

		public ReadOnlyMemory<byte> Data => MemoryExtensions.AsMemory(buffer).Slice(0, pos);

		public BufferCodeWriter()
		{
			pool = ArrayPool<byte>.Shared;
		}

		public override void WriteByte(byte value)
		{
			if (buffer == null)
			{
				buffer = pool.Rent(8);
			}
			if (buffer.Length <= pos)
			{
				byte[] destinationArray = pool.Rent(buffer.Length * 2);
				Array.Copy(buffer, destinationArray, buffer.Length);
				pool.Return(buffer);
				buffer = destinationArray;
			}
			buffer[pos++] = value;
		}

		public void Reset()
		{
			pos = 0;
		}

		public void Dispose()
		{
			if (buffer != null)
			{
				byte[] array = buffer;
				buffer = null;
				pool.Return(array);
			}
		}
	}

	private readonly ISystem system;

	private readonly IMemoryAllocator alloc;

	private readonly int bitness;

	public IcedAltEntryFactory(ISystem system, int bitness)
	{
		this.system = system;
		this.bitness = bitness;
		alloc = system.MemoryAllocator;
	}

	public IntPtr CreateAlternateEntrypoint(IntPtr entrypoint, int minLength, out IDisposable? handle)
	{
		PtrCodeReader ptrCodeReader = new PtrCodeReader(entrypoint);
		Decoder decoder = Decoder.Create(bitness, ptrCodeReader, (ulong)(long)entrypoint, DecoderOptions.NoInvalidCheck | DecoderOptions.AMD);
		InstructionList instructionList = new InstructionList();
		while (ptrCodeReader.Position < minLength)
		{
			decoder.Decode(out instructionList.AllocUninitializedElement());
		}
		bool flag = false;
		foreach (ref Instruction item in instructionList)
		{
			if (item.IsIPRelativeMemoryOperand)
			{
				flag = true;
				break;
			}
		}
		Instruction instruction = instructionList[instructionList.Count - 1];
		if (instruction.Mnemonic == Mnemonic.Call)
		{
			Encoder encoder = Encoder.Create(bitness, new NullCodeWriter());
			Instruction instruction2 = instruction;
			instruction2.Code = instruction.Code switch
			{
				Code.Call_rel16 => Code.Jmp_rel16, 
				Code.Call_rel32_32 => Code.Jmp_rel32_32, 
				Code.Call_rel32_64 => Code.Jmp_rel32_64, 
				Code.Jmp_rm16 => Code.Jmp_rm16, 
				Code.Jmp_rm32 => Code.Jmp_rm32, 
				Code.Jmp_rm64 => Code.Jmp_rm64, 
				Code.Call_m1616 => Code.Jmp_m1616, 
				Code.Call_m1632 => Code.Jmp_m1632, 
				Code.Call_m1664 => Code.Jmp_m1664, 
				Code.Call_ptr1616 => Code.Jmp_ptr1616, 
				Code.Call_ptr1632 => Code.Jmp_ptr1632, 
				_ => throw new InvalidOperationException($"Unrecognized call opcode {instruction.Code}"), 
			};
			instruction2.Length = (int)encoder.Encode(in instruction2, instruction2.IP);
			ulong nextIP = instruction.NextIP;
			Instruction instruction3;
			bool flag2;
			Instruction instruction4;
			if (bitness == 32)
			{
				instruction3 = Instruction.Create(Code.Pushd_imm32, (uint)nextIP);
				instruction3.Length = (int)encoder.Encode(in instruction3, instruction2.IP);
				instruction3.IP = instruction2.IP;
				instruction2.IP += (ulong)instruction3.Length;
				flag2 = false;
				instruction4 = default(Instruction);
			}
			else
			{
				flag2 = true;
				instruction4 = Instruction.CreateDeclareQword(nextIP);
				instruction3 = Instruction.Create(Code.Push_rm64, new MemoryOperand(Register.RIP, (long)instruction2.NextIP));
				instruction3.Length = (int)encoder.Encode(in instruction3, instruction2.IP);
				instruction3.IP = instruction2.IP;
				instruction2.IP += (ulong)instruction3.Length;
				instruction4.IP = instruction2.NextIP;
				instruction3.MemoryDisplacement64 = instruction4.IP;
			}
			instructionList.RemoveAt(instructionList.Count - 1);
			instructionList.Add(in instruction3);
			instructionList.Add(in instruction2);
			if (flag2)
			{
				instructionList.Add(in instruction4);
			}
		}
		else
		{
			instructionList.Add(Instruction.CreateBranch((bitness == 64) ? Code.Jmp_rel32_64 : Code.Jmp_rel32_32, decoder.IP));
		}
		int size = ptrCodeReader.Position + 5;
		using BufferCodeWriter bufferCodeWriter = new BufferCodeWriter();
		IAllocatedMemory allocated;
		ReadOnlyMemory<byte> data;
		while (true)
		{
			bufferCodeWriter.Reset();
			if (flag)
			{
				Helpers.Assert(alloc.TryAllocateInRange(new PositionedAllocationRequest(entrypoint, (nint)entrypoint + int.MinValue, (nint)entrypoint + int.MaxValue, new AllocationRequest(size)
				{
					Executable = true
				}), out allocated), null, "alloc.TryAllocateInRange(\n                        new(entrypoint, (nint)entrypoint + int.MinValue, (nint)entrypoint + int.MaxValue,\n                        new(estTotalSize) { Executable = true }), out allocated)");
			}
			else
			{
				Helpers.Assert(alloc.TryAllocate(new AllocationRequest(size)
				{
					Executable = true
				}, out allocated), null, "alloc.TryAllocate(new(estTotalSize) { Executable = true }, out allocated)");
			}
			IntPtr baseAddress = allocated.BaseAddress;
			if (!BlockEncoder.TryEncode(bitness, new InstructionBlock(bufferCodeWriter, instructionList, (ulong)(long)baseAddress), out string errorMessage, out BlockEncoderResult _))
			{
				allocated.Dispose();
				bool isEnabled;
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler message = new <027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.DebugLogErrorStringHandler(44, 1, out isEnabled);
				if (isEnabled)
				{
					message.AppendLiteral("BlockEncoder failed to encode instructions: ");
					message.AppendFormatted(errorMessage);
				}
				<027f1d0e-6e0b-4adc-bc2b-a5d0603c6ea8>MMDbgLog.Error(ref message);
				throw new InvalidOperationException("BlockEncoder failed to encode instructions: " + errorMessage);
			}
			data = bufferCodeWriter.Data;
			if (data.Length == allocated.Size)
			{
				break;
			}
			data = bufferCodeWriter.Data;
			size = data.Length;
			allocated.Dispose();
		}
		ISystem obj = system;
		IntPtr baseAddress2 = allocated.BaseAddress;
		data = bufferCodeWriter.Data;
		obj.PatchData(PatchTargetKind.Executable, baseAddress2, data.Span, default(Span<byte>));
		handle = allocated;
		return allocated.BaseAddress;
	}
}


using System;
using Iced.Intel;

private sealed class PtrCodeReader : CodeReader
{
	public IntPtr Base { get; }

	public int Position { get; private set; }

	public PtrCodeReader(IntPtr basePtr)
	{
		Base = basePtr;
		Position = 0;
	}

	public unsafe override int ReadByte()
	{
		return *(byte*)((nint)Base + Position++);
	}
}


using Iced.Intel;

private sealed class NullCodeWriter : CodeWriter
{
	public override void WriteByte(byte value)
	{
	}
}


using System;
using System.Buffers;
using Iced.Intel;

private sealed class BufferCodeWriter : CodeWriter, IDisposable
{
	private readonly ArrayPool<byte> pool;

	private byte[]? buffer;

	private int pos;

	public ReadOnlyMemory<byte> Data => MemoryExtensions.AsMemory(buffer).Slice(0, pos);

	public BufferCodeWriter()
	{
		pool = ArrayPool<byte>.Shared;
	}

	public override void WriteByte(byte value)
	{
		if (buffer == null)
		{
			buffer = pool.Rent(8);
		}
		if (buffer.Length <= pos)
		{
			byte[] destinationArray = pool.Rent(buffer.Length * 2);
			Array.Copy(buffer, destinationArray, buffer.Length);
			pool.Return(buffer);
			buffer = destinationArray;
		}
		buffer[pos++] = value;
	}

	public void Reset()
	{
		pos = 0;
	}

	public void Dispose()
	{
		if (buffer != null)
		{
			byte[] array = buffer;
			buffer = null;
			pool.Return(array);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MonoMod.Core.Interop;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

internal static class CoreCLR
{
	public enum CorJitResult
	{
		CORJIT_OK
	}

	public readonly struct InvokeCompileMethodPtr
	{
		private readonly IntPtr methodPtr;

		public unsafe delegate*<IntPtr, IntPtr, IntPtr, V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> InvokeCompileMethod => (delegate*<IntPtr, IntPtr, IntPtr, V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(void*)methodPtr;

		public unsafe InvokeCompileMethodPtr(delegate*<IntPtr, IntPtr, IntPtr, V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> ptr)
		{
			methodPtr = (IntPtr)ptr;
		}
	}

	public class V21
	{
		public struct CORINFO_SIG_INST
		{
			public uint classInstCount;

			public unsafe IntPtr* classInst;

			public uint methInstCount;

			public unsafe IntPtr* methInst;
		}

		public struct CORINFO_SIG_INFO
		{
			public int callConv;

			public IntPtr retTypeClass;

			public IntPtr retTypeSigClass;

			public byte retType;

			public byte flags;

			public ushort numArgs;

			public CORINFO_SIG_INST sigInst;

			public IntPtr args;

			public IntPtr pSig;

			public uint sbSig;

			public IntPtr scope;

			public uint token;
		}

		public struct CORINFO_METHOD_INFO
		{
			public IntPtr ftn;

			public IntPtr scope;

			public unsafe byte* ILCode;

			public uint ILCodeSize;

			public uint maxStack;

			public uint EHcount;

			public int options;

			public int regionKind;

			public CORINFO_SIG_INFO args;

			public CORINFO_SIG_INFO locals;
		}

		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public unsafe delegate CorJitResult CompileMethodDelegate(IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

		public unsafe static InvokeCompileMethodPtr InvokeCompileMethodPtr => new InvokeCompileMethodPtr((delegate*<IntPtr, IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(&InvokeCompileMethod));

		public unsafe static CorJitResult InvokeCompileMethod(IntPtr functionPtr, IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** pNativeEntry, uint* pNativeSizeOfCode)
		{
			if (functionPtr == IntPtr.Zero)
			{
				*pNativeEntry = null;
				*pNativeSizeOfCode = 0u;
				return CorJitResult.CORJIT_OK;
			}
			delegate* unmanaged[Stdcall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate* = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(void*)functionPtr;
			delegate* unmanaged[Stdcall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate*2 = delegate*;
			/*Error near IL_002b: Handle with invalid row number.*/;
		}
	}

	public class V30 : V21
	{
	}

	public class V31 : V30
	{
	}

	public class V50 : V31
	{
	}

	public class V60 : V50
	{
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public new unsafe delegate CorJitResult CompileMethodDelegate(IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

		public enum MethodClassification
		{
			IL,
			FCall,
			NDirect,
			EEImpl,
			Array,
			Instantiated,
			ComInterop,
			Dynamic
		}

		[Flags]
		public enum MethodDescClassification : ushort
		{
			ClassificationMask = 7,
			HasNonVtableSlot = 8,
			MethodImpl = 0x10,
			HasNativeCodeSlot = 0x20,
			HasComPlusCallInfo = 0x40,
			Static = 0x80,
			Duplicate = 0x400,
			VerifiedState = 0x800,
			Verifiable = 0x1000,
			NotInline = 0x2000,
			Synchronized = 0x4000,
			RequiresFullSlotNumber = 0x8000
		}

		public struct RelativePointer
		{
			private nint m_delta;

			public unsafe void* Value
			{
				get
				{
					nint delta = m_delta;
					if (delta != 0)
					{
						return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
					}
					return null;
				}
			}

			public RelativePointer(nint delta)
			{
				m_delta = delta;
			}
		}

		public struct RelativeFixupPointer
		{
			private nint m_delta;

			public const nint FIXUP_POINTER_INDIRECTION = 1;

			public unsafe void* Value
			{
				get
				{
					nint delta = m_delta;
					if (delta == 0)
					{
						return null;
					}
					nint num = (nint)Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
					if ((num & 1) != 0)
					{
						num = *(nint*)(num - 1);
					}
					return (void*)num;
				}
			}
		}

		public struct MethodDesc
		{
			[Flags]
			public enum Flags3 : ushort
			{
				TokenRemainderMask = 0x3FFF,
				HasForwardedValuetypeParameter = 0x4000,
				ValueTypeParametersWalked = 0x4000,
				DoesNotHaveEquivalentValuetypeParameters = 0x8000
			}

			[Flags]
			public enum Flags2 : byte
			{
				HasStableEntryPoint = 1,
				HasPrecode = 2,
				IsUnboxingStub = 4,
				IsJitIntrinsic = 0x10,
				IsEligibleForTieredCompilation = 0x20,
				RequiresCovariantReturnTypeChecking = 0x40
			}

			public static readonly nuint Alignment = (nuint)((IntPtr.Size == 8) ? 8 : 4);

			public Flags3 m_wFlags3AndTokenRemainder;

			public byte m_chunkIndex;

			public Flags2 m_bFlags2;

			public const ushort PackedSlot_SlotMask = 1023;

			public const ushort PackedSlot_NameHashMask = 64512;

			public ushort m_wSlotNumber;

			public MethodDescClassification m_wFlags;

			private unsafe static readonly nuint[] s_ClassificationSizeTable = new UIntPtr[8]
			{
				(nuint)sizeof(MethodDesc),
				(nuint)FCallMethodDescPtr.CurrentSize,
				(nuint)NDirectMethodDescPtr.CurrentSize,
				(nuint)EEImplMethodDescPtr.CurrentSize,
				(nuint)ArrayMethodDescPtr.CurrentSize,
				(nuint)sizeof(InstantiatedMethodDesc),
				(nuint)sizeof(ComPlusCallMethodDesc),
				(nuint)DynamicMethodDescPtr.CurrentSize
			};

			public ushort SlotNumber
			{
				get
				{
					if (!m_wFlags.Has(MethodDescClassification.RequiresFullSlotNumber))
					{
						return (ushort)(m_wSlotNumber & 0x3FF);
					}
					return m_wSlotNumber;
				}
			}

			public MethodClassification Classification => (MethodClassification)(m_wFlags & MethodDescClassification.ClassificationMask);

			public unsafe MethodDescChunk* MethodDescChunk => (MethodDescChunk*)((byte*)Unsafe.AsPointer(ref this) - (nuint)((nint)sizeof(MethodDescChunk) + (nint)(m_chunkIndex * Alignment)));

			public unsafe MethodTable* MethodTable => MethodDescChunk->m_methodTable;

			public bool HasNonVtableSlot => m_wFlags.Has(MethodDescClassification.HasNonVtableSlot);

			public bool HasStableEntryPoint => m_bFlags2.Has(Flags2.HasStableEntryPoint);

			public bool HasPrecode => m_bFlags2.Has(Flags2.HasPrecode);

			public bool HasNativeCodeSlot => m_wFlags.Has(MethodDescClassification.HasNativeCodeSlot);

			public bool IsUnboxingStub => m_bFlags2.Has(Flags2.IsUnboxingStub);

			public unsafe bool HasMethodInstantiation
			{
				get
				{
					if (TryAsInstantiated(out var md))
					{
						return md->IMD_HasMethodInstantiation;
					}
					return false;
				}
			}

			public unsafe bool IsGenericMethodDefinition
			{
				get
				{
					if (TryAsInstantiated(out var md))
					{
						return md->IMD_IsGenericMethodDefinition;
					}
					return false;
				}
			}

			public unsafe bool IsInstantiatingStub
			{
				get
				{
					if (!IsUnboxingStub && TryAsInstantiated(out var md))
					{
						return md->IMD_IsWrapperStubWithInstantiations;
					}
					return false;
				}
			}

			public bool IsWrapperStub
			{
				get
				{
					if (!IsUnboxingStub)
					{
						return IsInstantiatingStub;
					}
					return true;
				}
			}

			public bool IsTightlyBoundToMethodTable
			{
				get
				{
					if (!HasNonVtableSlot)
					{
						return true;
					}
					if (HasMethodInstantiation)
					{
						return IsGenericMethodDefinition;
					}
					if (IsWrapperStub)
					{
						return false;
					}
					return true;
				}
			}

			public unsafe void* GetMethodEntryPoint()
			{
				if (HasNonVtableSlot)
				{
					nuint baseSize = GetBaseSize();
					byte* ptr = (byte*)Unsafe.AsPointer(ref this) + baseSize;
					if (!MethodDescChunk->m_flagsAndTokenRange.Has(V60.MethodDescChunk.Flags.IsZapped))
					{
						return *(void**)ptr;
					}
					return new RelativePointer((nint)ptr).Value;
				}
				return MethodTable->GetSlot(SlotNumber);
			}

			public unsafe bool TryAsFCall(out FCallMethodDescPtr md)
			{
				if (Classification == MethodClassification.FCall)
				{
					md = new FCallMethodDescPtr(Unsafe.AsPointer(ref this), FCallMethodDescPtr.CurrentVtable);
					return true;
				}
				md = default(FCallMethodDescPtr);
				return false;
			}

			public unsafe bool TryAsNDirect(out NDirectMethodDescPtr md)
			{
				if (Classification == MethodClassification.NDirect)
				{
					md = new NDirectMethodDescPtr(Unsafe.AsPointer(ref this), NDirectMethodDescPtr.CurrentVtable);
					return true;
				}
				md = default(NDirectMethodDescPtr);
				return false;
			}

			public unsafe bool TryAsEEImpl(out EEImplMethodDescPtr md)
			{
				if (Classification == MethodClassification.EEImpl)
				{
					md = new EEImplMethodDescPtr(Unsafe.AsPointer(ref this), EEImplMethodDescPtr.CurrentVtable);
					return true;
				}
				md = default(EEImplMethodDescPtr);
				return false;
			}

			public unsafe bool TryAsArray(out ArrayMethodDescPtr md)
			{
				if (Classification == MethodClassification.Array)
				{
					md = new ArrayMethodDescPtr(Unsafe.AsPointer(ref this), ArrayMethodDescPtr.CurrentVtable);
					return true;
				}
				md = default(ArrayMethodDescPtr);
				return false;
			}

			public unsafe bool TryAsInstantiated(out InstantiatedMethodDesc* md)
			{
				if (Classification == MethodClassification.Instantiated)
				{
					md = (InstantiatedMethodDesc*)Unsafe.AsPointer(ref this);
					return true;
				}
				md = default(InstantiatedMethodDesc*);
				return false;
			}

			public unsafe bool TryAsComPlusCall(out ComPlusCallMethodDesc* md)
			{
				if (Classification == MethodClassification.ComInterop)
				{
					md = (ComPlusCallMethodDesc*)Unsafe.AsPointer(ref this);
					return true;
				}
				md = default(ComPlusCallMethodDesc*);
				return false;
			}

			public unsafe bool TryAsDynamic(out DynamicMethodDescPtr md)
			{
				if (Classification == MethodClassification.Dynamic)
				{
					md = new DynamicMethodDescPtr(Unsafe.AsPointer(ref this), DynamicMethodDescPtr.CurrentVtable);
					return true;
				}
				md = default(DynamicMethodDescPtr);
				return false;
			}

			public unsafe nuint SizeOf(bool includeNonVtable = true, bool includeMethodImpl = true, bool includeComPlus = true, bool includeNativeCode = true)
			{
				nuint num = (nuint)((nint)GetBaseSize() + (nint)((includeNonVtable && m_wFlags.Has(MethodDescClassification.HasNonVtableSlot)) ? sizeof(void*) : 0) + ((includeMethodImpl && m_wFlags.Has(MethodDescClassification.MethodImpl)) ? ((nint)sizeof(void*) * (nint)2) : 0) + ((includeComPlus && m_wFlags.Has(MethodDescClassification.HasComPlusCallInfo)) ? sizeof(void*) : 0) + ((includeNativeCode && m_wFlags.Has(MethodDescClassification.HasNativeCodeSlot)) ? sizeof(void*) : 0));
				if (includeNativeCode && HasNativeCodeSlot)
				{
					num += (nuint)((((nuint)GetAddrOfNativeCodeSlot() & (nuint)1u) != 0) ? sizeof(void*) : 0);
				}
				return num;
			}

			public unsafe void* GetNativeCode()
			{
				if (HasNativeCodeSlot)
				{
					void* ptr = *(void**)((nuint)GetAddrOfNativeCodeSlot() & (nuint)(~(nint)1));
					if (ptr != null)
					{
						return ptr;
					}
				}
				if (!HasStableEntryPoint || HasPrecode)
				{
					return null;
				}
				return GetStableEntryPoint();
			}

			public unsafe void* GetStableEntryPoint()
			{
				return GetMethodEntryPoint();
			}

			public unsafe static MethodDesc* FindTightlyBoundWrappedMethodDesc(MethodDesc* pMD)
			{
				if (pMD->IsUnboxingStub && pMD->TryAsInstantiated(out var md))
				{
					pMD = md->IMD_GetWrappedMethodDesc();
				}
				if (!pMD->IsTightlyBoundToMethodTable)
				{
					pMD = pMD->GetCanonicalMethodTable()->GetParallelMethodDesc(pMD);
				}
				if (pMD->IsUnboxingStub)
				{
					pMD = GetNextIntroducedMethod(pMD);
				}
				return pMD;
			}

			public unsafe static MethodDesc* GetNextIntroducedMethod(MethodDesc* pMD)
			{
				MethodDescChunk* methodDescChunk = pMD->MethodDescChunk;
				nuint num = (nuint)((byte*)pMD + pMD->SizeOf());
				nuint num2 = (nuint)((byte*)methodDescChunk + methodDescChunk->SizeOf);
				if (num < num2)
				{
					return (MethodDesc*)num;
				}
				methodDescChunk = methodDescChunk->m_next;
				if (methodDescChunk != null)
				{
					return methodDescChunk->FirstMethodDesc;
				}
				return null;
			}

			public unsafe MethodTable* GetCanonicalMethodTable()
			{
				return MethodTable->GetCanonicalMethodTable();
			}

			public unsafe void* GetAddrOfNativeCodeSlot()
			{
				nuint byteOffset = SizeOf(includeNonVtable: true, includeMethodImpl: true, includeComPlus: false, includeNativeCode: false);
				return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, byteOffset));
			}

			public nuint GetBaseSize()
			{
				return GetBaseSize(Classification);
			}

			public static nuint GetBaseSize(MethodClassification classification)
			{
				return s_ClassificationSizeTable[(int)classification];
			}
		}

		public struct MethodDescChunk
		{
			[Flags]
			public enum Flags : ushort
			{
				TokenRangeMask = 0x3FF,
				HasCompactEntrypoints = 0x4000,
				IsZapped = 0x8000
			}

			public unsafe MethodTable* m_methodTable;

			public unsafe MethodDescChunk* m_next;

			public byte m_size;

			public byte m_count;

			public Flags m_flagsAndTokenRange;

			public unsafe MethodDesc* FirstMethodDesc => (MethodDesc*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodDescChunk));

			public uint Size => (uint)(m_size + 1);

			public uint Count => (uint)(m_count + 1);

			public unsafe nuint SizeOf => (nuint)sizeof(MethodDescChunk) + Size * MethodDesc.Alignment;
		}

		[FatInterface]
		public struct StoredSigMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? StoredSigMethodDesc_64.FatVtable_ : StoredSigMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(StoredSigMethodDesc_64) : sizeof(StoredSigMethodDesc_32);

			public unsafe void* m_pSig
			{
				[FatInterfaceIgnore]
				get
				{
					return GetPSig();
				}
			}

			public uint m_cSig
			{
				[FatInterfaceIgnore]
				get
				{
					return GetCSig();
				}
			}

			private unsafe void* GetPSig()
			{
				return ((delegate*<void*, void*>)(void*)vtbl_[0])(ptr_);
			}

			private unsafe uint GetCSig()
			{
				return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
			}

			public unsafe StoredSigMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
		public struct StoredSigMethodDesc_64
		{
			public MethodDesc @base;

			public unsafe void* m_pSig;

			public uint m_cSig;

			public uint m_dwExtendedFlags;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[2]
						{
							(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
							(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
						};
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetCSig_1(void* ptr__)
					{
						return ((StoredSigMethodDesc_64*)ptr__)->GetCSig();
					}
					unsafe static void* S_GetPSig_0(void* ptr__)
					{
						return ((StoredSigMethodDesc_64*)ptr__)->GetPSig();
					}
				}
			}

			private unsafe void* GetPSig()
			{
				return m_pSig;
			}

			private uint GetCSig()
			{
				return m_cSig;
			}
		}

		[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
		public struct StoredSigMethodDesc_32
		{
			public MethodDesc @base;

			public unsafe void* m_pSig;

			public uint m_cSig;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[2]
						{
							(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
							(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
						};
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetCSig_1(void* ptr__)
					{
						return ((StoredSigMethodDesc_32*)ptr__)->GetCSig();
					}
					unsafe static void* S_GetPSig_0(void* ptr__)
					{
						return ((StoredSigMethodDesc_32*)ptr__)->GetPSig();
					}
				}
			}

			private unsafe void* GetPSig()
			{
				return m_pSig;
			}

			private uint GetCSig()
			{
				return m_cSig;
			}
		}

		[FatInterface]
		public struct FCallMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? FCallMethodDesc_64.FatVtable_ : FCallMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(FCallMethodDesc_64) : sizeof(FCallMethodDesc_32);

			public uint m_dwECallID
			{
				[FatInterfaceIgnore]
				get
				{
					return GetECallID();
				}
			}

			private unsafe uint GetECallID()
			{
				return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
			}

			public unsafe FCallMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
		public struct FCallMethodDesc_64
		{
			public MethodDesc @base;

			public uint m_dwECallID;

			public uint m_padding;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetECallID_0(void* ptr__)
					{
						return ((FCallMethodDesc_64*)ptr__)->GetECallID();
					}
				}
			}

			private uint GetECallID()
			{
				return m_dwECallID;
			}
		}

		[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
		public struct FCallMethodDesc_32
		{
			public MethodDesc @base;

			public uint m_dwECallID;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetECallID_0(void* ptr__)
					{
						return ((FCallMethodDesc_32*)ptr__)->GetECallID();
					}
				}
			}

			private uint GetECallID()
			{
				return m_dwECallID;
			}
		}

		public struct DynamicResolver
		{
		}

		[Flags]
		public enum DynamicMethodDesc_ExtendedFlags
		{
			Attrs = 0xFFFF,
			ILStubAttrs = 0x17,
			MemberAccessMask = 7,
			ReverseStub = 8,
			Static = 0x10,
			CALLIStub = 0x20,
			DelegateStub = 0x40,
			StructMarshalStub = 0x80,
			Unbreakable = 0x100,
			SignatureNeedsResture = 0x400,
			StubNeedsCOMStarted = 0x800,
			MulticastStub = 0x1000,
			UnboxingILStub = 0x2000,
			WrapperDelegateStub = 0x4000,
			UnmanagedCallersOnlyStub = 0x8000,
			ILStub = 0x10000,
			LCGMethod = 0x20000,
			StackArgSize = 0xFFC0000
		}

		[FatInterface]
		public struct DynamicMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? DynamicMethodDesc_64.FatVtable_ : DynamicMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(DynamicMethodDesc_64) : sizeof(DynamicMethodDesc_32);

			public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

			private unsafe DynamicMethodDesc_ExtendedFlags GetFlags()
			{
				return ((delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(void*)vtbl_[0])(ptr_);
			}

			public unsafe DynamicMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
		public struct DynamicMethodDesc_64
		{
			public StoredSigMethodDesc_64 @base;

			public unsafe byte* m_pszMethodName;

			public unsafe DynamicResolver* m_pResolver;

			private static IntPtr[]? fatVtable_;

			public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
					{
						return ((DynamicMethodDesc_64*)ptr__)->GetFlags();
					}
				}
			}

			private DynamicMethodDesc_ExtendedFlags GetFlags()
			{
				return (DynamicMethodDesc_ExtendedFlags)@base.m_dwExtendedFlags;
			}
		}

		[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
		public struct DynamicMethodDesc_32
		{
			public StoredSigMethodDesc_32 @base;

			public unsafe byte* m_pszMethodName;

			public unsafe DynamicResolver* m_pResolver;

			public uint m_dwExtendedFlags;

			private static IntPtr[]? fatVtable_;

			public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
					{
						return ((DynamicMethodDesc_32*)ptr__)->GetFlags();
					}
				}
			}

			private DynamicMethodDesc_ExtendedFlags GetFlags()
			{
				return (DynamicMethodDesc_ExtendedFlags)m_dwExtendedFlags;
			}
		}

		[FatInterface]
		public struct ArrayMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? ArrayMethodDesc_64.FatVtable_ : ArrayMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(ArrayMethodDesc_64) : sizeof(ArrayMethodDesc_32);

			public unsafe ArrayMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		public enum ArrayFunc
		{
			Get,
			Set,
			Address,
			Ctor
		}

		[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
		public struct ArrayMethodDesc_64
		{
			public StoredSigMethodDesc_64 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
		public struct ArrayMethodDesc_32
		{
			public StoredSigMethodDesc_32 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		public struct NDirectWriteableData
		{
		}

		[Flags]
		public enum NDirectMethodDesc_Flags : ushort
		{
			EarlyBound = 1,
			HasSuppressUnmanagedCodeAccess = 2,
			DefaultDllImportSearchPathIsCached = 4,
			IsMarshalingRequiredCached = 0x10,
			CachedMarshalingRequired = 0x20,
			NativeAnsi = 0x40,
			LastError = 0x80,
			NativeNoMangle = 0x100,
			VarArgs = 0x200,
			StdCall = 0x400,
			ThisCall = 0x800,
			IsQCall = 0x1000,
			DefaultDllImportSearchPathsStatus = 0x2000,
			NDirectPopulated = 0x8000
		}

		[FatInterface]
		public struct NDirectMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? NDirectMethodDesc_x86.FatVtable_ : NDirectMethodDesc_other.FatVtable_;

			public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(NDirectMethodDesc_x86) : sizeof(NDirectMethodDesc_other);

			public unsafe NDirectMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
		public struct NDirectMethodDesc_other
		{
			public struct NDirect
			{
				public unsafe void* m_pNativeNDirectTarget;

				public unsafe byte* m_pszEntrypointName;

				public nuint union_pszLibName_dwECallID;

				public unsafe NDirectWriteableData* m_pWriteableData;

				public unsafe void* m_pImportThunkGlue;

				public uint m_DefaultDllImportSearchPathsAttributeValue;

				public NDirectMethodDesc_Flags m_wFlags;

				public unsafe MethodDesc* m_pStubMD;
			}

			public MethodDesc @base;

			private NDirect ndirect;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
		public struct NDirectMethodDesc_x86
		{
			public struct NDirect
			{
				public unsafe void* m_pNativeNDirectTarget;

				public unsafe byte* m_pszEntrypointName;

				public nuint union_pszLibName_dwECallID;

				public unsafe NDirectWriteableData* m_pWriteableData;

				public unsafe void* m_pImportThunkGlue;

				public uint m_DefaultDllImportSearchPathsAttributeValue;

				public NDirectMethodDesc_Flags m_wFlags;

				public ushort m_cbStackArgumentSize;

				public unsafe MethodDesc* m_pStubMD;
			}

			public MethodDesc @base;

			private NDirect ndirect;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterface]
		public struct EEImplMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? EEImplMethodDesc_64.FatVtable_ : EEImplMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(EEImplMethodDesc_64) : sizeof(EEImplMethodDesc_32);

			public unsafe EEImplMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
		public struct EEImplMethodDesc_64
		{
			public StoredSigMethodDesc_64 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
		public struct EEImplMethodDesc_32
		{
			public StoredSigMethodDesc_32 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		public struct ComPlusCallMethodDesc
		{
			public MethodDesc @base;

			public unsafe void* m_pComPlusCallInfo;
		}

		public struct InstantiatedMethodDesc
		{
			[Flags]
			public enum Flags : ushort
			{
				KindMask = 7,
				GenericMethodDefinition = 0,
				UnsharedMethodInstantiation = 1,
				SharedMethodInstantiation = 2,
				WrapperStubWithInstantiations = 3,
				EnCAddedMethod = 7,
				Unrestored = 8,
				HasComPlusCallInfo = 0x10
			}

			public MethodDesc @base;

			public unsafe void* union_pDictLayout_pWrappedMethodDesc;

			public unsafe Dictionary* m_pPerInstInfo;

			public Flags m_wFlags2;

			public ushort m_wNumGenericArgs;

			public unsafe bool IMD_HasMethodInstantiation
			{
				get
				{
					if (!IMD_IsGenericMethodDefinition)
					{
						return m_pPerInstInfo != null;
					}
					return true;
				}
			}

			public bool IMD_IsGenericMethodDefinition => (m_wFlags2 & Flags.KindMask) == 0;

			public bool IMD_IsWrapperStubWithInstantiations => (m_wFlags2 & Flags.KindMask) == Flags.WrapperStubWithInstantiations;

			public unsafe MethodDesc* IMD_GetWrappedMethodDesc()
			{
				Helpers.Assert(IMD_IsWrapperStubWithInstantiations, null, "IMD_IsWrapperStubWithInstantiations");
				return (MethodDesc*)union_pDictLayout_pWrappedMethodDesc;
			}
		}

		public struct Dictionary
		{
		}

		public struct Module
		{
		}

		public struct MethodTableWriteableData
		{
		}

		public struct VTableIndir2_t
		{
			public unsafe void* pCode;

			public unsafe void* Value => pCode;
		}

		public struct VTableIndir_t
		{
			public unsafe VTableIndir2_t* Value;
		}

		private static class MultipurposeSlotHelpers
		{
			public unsafe static byte OffsetOfMp1()
			{
				MethodTable methodTable = default(MethodTable);
				return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
			}

			public unsafe static byte OffsetOfMp2()
			{
				MethodTable methodTable = default(MethodTable);
				return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
			}

			public unsafe static byte RegularOffset(int index)
			{
				return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
			}
		}

		public struct MethodTable
		{
			[Flags]
			public enum Flags2 : ushort
			{
				MultipurposeSlotsMask = 0x1F,
				HasPerInstInfo = 1,
				HasInterfaceMap = 2,
				HasDispatchMapSlot = 4,
				HasNonVirtualSlots = 8,
				HasModuleOverride = 0x10,
				IsZapped = 0x20,
				IsPreRestored = 0x40,
				HasModuleDependencies = 0x80,
				IsIntrinsicType = 0x100,
				RequiresDispatchTokenFat = 0x200,
				HasCctor = 0x400,
				HasVirtualStaticMethods = 0x800,
				REquiresAlign8 = 0x1000,
				HasBoxedRegularStatics = 0x2000,
				HasSingleNonVirtualSlot = 0x4000,
				DependsOnEquivalentOrForwardedStructs = 0x8000
			}

			public enum UnionLowBits
			{
				EEClass,
				Invalid,
				MethodTable,
				Indirection
			}

			public uint m_dwFlags;

			public uint m_BaseSize;

			public Flags2 m_wFlags2;

			public ushort m_wToken;

			public ushort m_wNumVirtuals;

			public ushort m_wNumInterfaces;

			private unsafe void* m_pParentMethodTable;

			public unsafe Module* m_pLoaderModule;

			public unsafe MethodTableWriteableData* m_pWriteableData;

			public unsafe void* union_pEEClass_pCanonMT;

			public unsafe void* union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1;

			public unsafe void* union_p_InterfaceMap_pMultipurposeSlot2;

			public const int VTABLE_SLOTS_PER_CHUNK = 8;

			public const int VTABLE_SLOTS_PER_CHUNK_LOG2 = 3;

			private static readonly byte[] c_NonVirtualSlotsOffsets = GetNonVirtualSlotsOffsets();

			public bool IsInterface => (m_dwFlags & 0xF0000) == 786432;

			public bool HasIndirectParent => (m_dwFlags & 0x800000) != 0;

			public bool HasSingleNonVirtualSlot => m_wFlags2.Has(Flags2.HasSingleNonVirtualSlot);

			public unsafe MethodTable* GetCanonicalMethodTable()
			{
				nuint num = (nuint)union_pEEClass_pCanonMT;
				if ((num & 2) == 0)
				{
					return (MethodTable*)num;
				}
				if ((num & 1) != 0)
				{
					return *(MethodTable**)(num - 3);
				}
				return (MethodTable*)(num - 2);
			}

			public unsafe MethodDesc* GetParallelMethodDesc(MethodDesc* pDefMD)
			{
				return GetMethodDescForSlot(pDefMD->SlotNumber);
			}

			public unsafe MethodDesc* GetMethodDescForSlot(uint slotNumber)
			{
				if (IsInterface)
				{
					GetNumVirtuals();
				}
				throw new NotImplementedException();
			}

			public unsafe void* GetRestoredSlot(uint slotNumber)
			{
				MethodTable* ptr = (MethodTable*)Unsafe.AsPointer(ref this);
				void* slot;
				while (true)
				{
					ptr = ptr->GetCanonicalMethodTable();
					slot = ptr->GetSlot(slotNumber);
					if (slot != null)
					{
						break;
					}
					ptr = ptr->GetParentMethodTable();
				}
				return slot;
			}

			public unsafe MethodTable* GetParentMethodTable()
			{
				void* pParentMethodTable = m_pParentMethodTable;
				if (HasIndirectParent)
				{
					return *(MethodTable**)pParentMethodTable;
				}
				return (MethodTable*)pParentMethodTable;
			}

			public unsafe void* GetSlot(uint slotNumber)
			{
				nint slotPtrRaw = GetSlotPtrRaw(slotNumber);
				if (slotNumber < GetNumVirtuals())
				{
					return ((VTableIndir2_t*)slotPtrRaw)->Value;
				}
				if ((m_wFlags2 & Flags2.IsZapped) != 0 && slotNumber >= GetNumVirtuals())
				{
					return ((RelativePointer*)slotPtrRaw)->Value;
				}
				return *(void**)slotPtrRaw;
			}

			public unsafe nint GetSlotPtrRaw(uint slotNum)
			{
				if (slotNum < GetNumVirtuals())
				{
					uint indexOfVtableIndirection = GetIndexOfVtableIndirection(slotNum);
					return (nint)(VTableIndir_t__GetValueMaybeNullAtPtr((nint)(GetVtableIndirections() + indexOfVtableIndirection)) + GetIndexAfterVtableIndirection(slotNum));
				}
				if (HasSingleNonVirtualSlot)
				{
					return GetNonVirtualSlotsPtr();
				}
				return (nint)(GetNonVirtualSlotsArray() + (slotNum - GetNumVirtuals()));
			}

			public ushort GetNumVirtuals()
			{
				return m_wNumVirtuals;
			}

			public static uint GetIndexOfVtableIndirection(uint slotNum)
			{
				return slotNum >> 3;
			}

			public unsafe VTableIndir_t* GetVtableIndirections()
			{
				return (VTableIndir_t*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodTable));
			}

			public unsafe static VTableIndir2_t* VTableIndir_t__GetValueMaybeNullAtPtr(nint @base)
			{
				return (VTableIndir2_t*)@base;
			}

			public static uint GetIndexAfterVtableIndirection(uint slotNum)
			{
				return slotNum & 7;
			}

			[MultipurposeSlotOffsetTable(3, typeof(MultipurposeSlotHelpers))]
			private static byte[] GetNonVirtualSlotsOffsets()
			{
				return new byte[8]
				{
					MultipurposeSlotHelpers.OffsetOfMp1(),
					MultipurposeSlotHelpers.OffsetOfMp2(),
					MultipurposeSlotHelpers.OffsetOfMp1(),
					MultipurposeSlotHelpers.RegularOffset(2),
					MultipurposeSlotHelpers.OffsetOfMp2(),
					MultipurposeSlotHelpers.RegularOffset(2),
					MultipurposeSlotHelpers.RegularOffset(2),
					MultipurposeSlotHelpers.RegularOffset(3)
				};
			}

			public nint GetNonVirtualSlotsPtr()
			{
				return GetMultipurposeSlotPtr(Flags2.HasNonVirtualSlots, c_NonVirtualSlotsOffsets);
			}

			public unsafe nint GetMultipurposeSlotPtr(Flags2 flag, byte[] offsets)
			{
				nint num = offsets[(uint)(m_wFlags2 & (flag - 1))];
				if (num >= sizeof(MethodTable))
				{
					num += (nint)GetNumVTableIndirections() * (nint)sizeof(VTableIndir_t);
				}
				return (nint)((byte*)Unsafe.AsPointer(ref this) + num);
			}

			public unsafe void*** GetNonVirtualSlotsArray()
			{
				return (void***)GetNonVirtualSlotsPtr();
			}

			public uint GetNumVTableIndirections()
			{
				return GetNumVtableIndirections(GetNumVirtuals());
			}

			public static uint GetNumVtableIndirections(uint numVirtuals)
			{
				return numVirtuals + 7 >> 3;
			}
		}

		public new unsafe static InvokeCompileMethodPtr InvokeCompileMethodPtr => new InvokeCompileMethodPtr((delegate*<IntPtr, IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(&InvokeCompileMethod));

		public new unsafe static CorJitResult InvokeCompileMethod(IntPtr functionPtr, IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode)
		{
			if (functionPtr == IntPtr.Zero)
			{
				*nativeEntry = null;
				*nativeSizeOfCode = 0u;
				return CorJitResult.CORJIT_OK;
			}
			delegate* unmanaged[Thiscall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate* = (delegate* unmanaged[Thiscall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(void*)functionPtr;
			delegate* unmanaged[Thiscall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate*2 = delegate*;
			/*Error near IL_002b: Handle with invalid row number.*/;
		}
	}

	public readonly struct InvokeAllocMemPtr
	{
		private readonly IntPtr methodPtr;

		public unsafe delegate*<IntPtr, IntPtr, V70.AllocMemArgs*, void> InvokeAllocMem => (delegate*<IntPtr, IntPtr, V70.AllocMemArgs*, void>)(void*)methodPtr;

		public unsafe InvokeAllocMemPtr(delegate*<IntPtr, IntPtr, V70.AllocMemArgs*, void> ptr)
		{
			methodPtr = (IntPtr)ptr;
		}
	}

	public class V70 : V60
	{
		public static class ICorJitInfoVtable
		{
			public const int AllocMemIndex = 159;

			public const int TotalVtableCount = 175;
		}

		public struct AllocMemArgs
		{
			public uint hotCodeSize;

			public uint coldCodeSize;

			public uint roDataSize;

			public uint xcptnsCount;

			public int flag;

			public IntPtr hotCodeBlock;

			public IntPtr hotCodeBlockRW;

			public IntPtr coldCodeBlock;

			public IntPtr coldCodeBlockRW;

			public IntPtr roDataBlock;

			public IntPtr roDataBlockRW;
		}

		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public unsafe delegate void AllocMemDelegate(IntPtr thisPtr, AllocMemArgs* args);

		public unsafe static InvokeAllocMemPtr InvokeAllocMemPtr => new InvokeAllocMemPtr((delegate*<IntPtr, IntPtr, AllocMemArgs*, void>)(&InvokeAllocMem));

		public unsafe static void InvokeAllocMem(IntPtr functionPtr, IntPtr thisPtr, AllocMemArgs* args)
		{
			if (functionPtr == IntPtr.Zero)
			{
				return;
			}
			delegate* unmanaged[Thiscall]<IntPtr, AllocMemArgs*, void> delegate* = (delegate* unmanaged[Thiscall]<IntPtr, AllocMemArgs*, void>)(void*)functionPtr;
			delegate* unmanaged[Thiscall]<IntPtr, AllocMemArgs*, void> delegate*2 = delegate*;
			/*Error near IL_001a: Handle with invalid row number.*/;
		}
	}

	public class V80 : V70
	{
		public static class ICorJitInfoVtableV80
		{
			public const int AllocMemIndex = 154;

			public const int TotalVtableCount = 170;
		}
	}
}


public enum CorJitResult
{
	CORJIT_OK
}


using System;

public readonly struct InvokeCompileMethodPtr
{
	private readonly IntPtr methodPtr;

	public unsafe delegate*<IntPtr, IntPtr, IntPtr, V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> InvokeCompileMethod => (delegate*<IntPtr, IntPtr, IntPtr, V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(void*)methodPtr;

	public unsafe InvokeCompileMethodPtr(delegate*<IntPtr, IntPtr, IntPtr, V21.CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> ptr)
	{
		methodPtr = (IntPtr)ptr;
	}
}


using System;
using System.Runtime.InteropServices;

public class V21
{
	public struct CORINFO_SIG_INST
	{
		public uint classInstCount;

		public unsafe IntPtr* classInst;

		public uint methInstCount;

		public unsafe IntPtr* methInst;
	}

	public struct CORINFO_SIG_INFO
	{
		public int callConv;

		public IntPtr retTypeClass;

		public IntPtr retTypeSigClass;

		public byte retType;

		public byte flags;

		public ushort numArgs;

		public CORINFO_SIG_INST sigInst;

		public IntPtr args;

		public IntPtr pSig;

		public uint sbSig;

		public IntPtr scope;

		public uint token;
	}

	public struct CORINFO_METHOD_INFO
	{
		public IntPtr ftn;

		public IntPtr scope;

		public unsafe byte* ILCode;

		public uint ILCodeSize;

		public uint maxStack;

		public uint EHcount;

		public int options;

		public int regionKind;

		public CORINFO_SIG_INFO args;

		public CORINFO_SIG_INFO locals;
	}

	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public unsafe delegate CorJitResult CompileMethodDelegate(IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

	public unsafe static InvokeCompileMethodPtr InvokeCompileMethodPtr => new InvokeCompileMethodPtr((delegate*<IntPtr, IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(&InvokeCompileMethod));

	public unsafe static CorJitResult InvokeCompileMethod(IntPtr functionPtr, IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** pNativeEntry, uint* pNativeSizeOfCode)
	{
		if (functionPtr == IntPtr.Zero)
		{
			*pNativeEntry = null;
			*pNativeSizeOfCode = 0u;
			return CorJitResult.CORJIT_OK;
		}
		delegate* unmanaged[Stdcall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate* = (delegate* unmanaged[Stdcall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(void*)functionPtr;
		delegate* unmanaged[Stdcall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate*2 = delegate*;
		/*Error near IL_002b: Handle with invalid row number.*/;
	}
}


using System;

public struct CORINFO_SIG_INST
{
	public uint classInstCount;

	public unsafe IntPtr* classInst;

	public uint methInstCount;

	public unsafe IntPtr* methInst;
}


using System;

public struct CORINFO_SIG_INFO
{
	public int callConv;

	public IntPtr retTypeClass;

	public IntPtr retTypeSigClass;

	public byte retType;

	public byte flags;

	public ushort numArgs;

	public CORINFO_SIG_INST sigInst;

	public IntPtr args;

	public IntPtr pSig;

	public uint sbSig;

	public IntPtr scope;

	public uint token;
}


using System;

public struct CORINFO_METHOD_INFO
{
	public IntPtr ftn;

	public IntPtr scope;

	public unsafe byte* ILCode;

	public uint ILCodeSize;

	public uint maxStack;

	public uint EHcount;

	public int options;

	public int regionKind;

	public CORINFO_SIG_INFO args;

	public CORINFO_SIG_INFO locals;
}


using System;
using System.Runtime.InteropServices;

[UnmanagedFunctionPointer(CallingConvention.StdCall)]
public unsafe delegate CorJitResult CompileMethodDelegate(IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);


public class V30 : V21
{
}


public class V31 : V30
{
}


public class V50 : V31
{
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

public class V60 : V50
{
	[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
	public new unsafe delegate CorJitResult CompileMethodDelegate(IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);

	public enum MethodClassification
	{
		IL,
		FCall,
		NDirect,
		EEImpl,
		Array,
		Instantiated,
		ComInterop,
		Dynamic
	}

	[Flags]
	public enum MethodDescClassification : ushort
	{
		ClassificationMask = 7,
		HasNonVtableSlot = 8,
		MethodImpl = 0x10,
		HasNativeCodeSlot = 0x20,
		HasComPlusCallInfo = 0x40,
		Static = 0x80,
		Duplicate = 0x400,
		VerifiedState = 0x800,
		Verifiable = 0x1000,
		NotInline = 0x2000,
		Synchronized = 0x4000,
		RequiresFullSlotNumber = 0x8000
	}

	public struct RelativePointer
	{
		private nint m_delta;

		public unsafe void* Value
		{
			get
			{
				nint delta = m_delta;
				if (delta != 0)
				{
					return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
				}
				return null;
			}
		}

		public RelativePointer(nint delta)
		{
			m_delta = delta;
		}
	}

	public struct RelativeFixupPointer
	{
		private nint m_delta;

		public const nint FIXUP_POINTER_INDIRECTION = 1;

		public unsafe void* Value
		{
			get
			{
				nint delta = m_delta;
				if (delta == 0)
				{
					return null;
				}
				nint num = (nint)Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
				if ((num & 1) != 0)
				{
					num = *(nint*)(num - 1);
				}
				return (void*)num;
			}
		}
	}

	public struct MethodDesc
	{
		[Flags]
		public enum Flags3 : ushort
		{
			TokenRemainderMask = 0x3FFF,
			HasForwardedValuetypeParameter = 0x4000,
			ValueTypeParametersWalked = 0x4000,
			DoesNotHaveEquivalentValuetypeParameters = 0x8000
		}

		[Flags]
		public enum Flags2 : byte
		{
			HasStableEntryPoint = 1,
			HasPrecode = 2,
			IsUnboxingStub = 4,
			IsJitIntrinsic = 0x10,
			IsEligibleForTieredCompilation = 0x20,
			RequiresCovariantReturnTypeChecking = 0x40
		}

		public static readonly nuint Alignment = (nuint)((IntPtr.Size == 8) ? 8 : 4);

		public Flags3 m_wFlags3AndTokenRemainder;

		public byte m_chunkIndex;

		public Flags2 m_bFlags2;

		public const ushort PackedSlot_SlotMask = 1023;

		public const ushort PackedSlot_NameHashMask = 64512;

		public ushort m_wSlotNumber;

		public MethodDescClassification m_wFlags;

		private unsafe static readonly nuint[] s_ClassificationSizeTable = new UIntPtr[8]
		{
			(nuint)sizeof(MethodDesc),
			(nuint)FCallMethodDescPtr.CurrentSize,
			(nuint)NDirectMethodDescPtr.CurrentSize,
			(nuint)EEImplMethodDescPtr.CurrentSize,
			(nuint)ArrayMethodDescPtr.CurrentSize,
			(nuint)sizeof(InstantiatedMethodDesc),
			(nuint)sizeof(ComPlusCallMethodDesc),
			(nuint)DynamicMethodDescPtr.CurrentSize
		};

		public ushort SlotNumber
		{
			get
			{
				if (!m_wFlags.Has(MethodDescClassification.RequiresFullSlotNumber))
				{
					return (ushort)(m_wSlotNumber & 0x3FF);
				}
				return m_wSlotNumber;
			}
		}

		public MethodClassification Classification => (MethodClassification)(m_wFlags & MethodDescClassification.ClassificationMask);

		public unsafe MethodDescChunk* MethodDescChunk => (MethodDescChunk*)((byte*)Unsafe.AsPointer(ref this) - (nuint)((nint)sizeof(MethodDescChunk) + (nint)(m_chunkIndex * Alignment)));

		public unsafe MethodTable* MethodTable => MethodDescChunk->m_methodTable;

		public bool HasNonVtableSlot => m_wFlags.Has(MethodDescClassification.HasNonVtableSlot);

		public bool HasStableEntryPoint => m_bFlags2.Has(Flags2.HasStableEntryPoint);

		public bool HasPrecode => m_bFlags2.Has(Flags2.HasPrecode);

		public bool HasNativeCodeSlot => m_wFlags.Has(MethodDescClassification.HasNativeCodeSlot);

		public bool IsUnboxingStub => m_bFlags2.Has(Flags2.IsUnboxingStub);

		public unsafe bool HasMethodInstantiation
		{
			get
			{
				if (TryAsInstantiated(out var md))
				{
					return md->IMD_HasMethodInstantiation;
				}
				return false;
			}
		}

		public unsafe bool IsGenericMethodDefinition
		{
			get
			{
				if (TryAsInstantiated(out var md))
				{
					return md->IMD_IsGenericMethodDefinition;
				}
				return false;
			}
		}

		public unsafe bool IsInstantiatingStub
		{
			get
			{
				if (!IsUnboxingStub && TryAsInstantiated(out var md))
				{
					return md->IMD_IsWrapperStubWithInstantiations;
				}
				return false;
			}
		}

		public bool IsWrapperStub
		{
			get
			{
				if (!IsUnboxingStub)
				{
					return IsInstantiatingStub;
				}
				return true;
			}
		}

		public bool IsTightlyBoundToMethodTable
		{
			get
			{
				if (!HasNonVtableSlot)
				{
					return true;
				}
				if (HasMethodInstantiation)
				{
					return IsGenericMethodDefinition;
				}
				if (IsWrapperStub)
				{
					return false;
				}
				return true;
			}
		}

		public unsafe void* GetMethodEntryPoint()
		{
			if (HasNonVtableSlot)
			{
				nuint baseSize = GetBaseSize();
				byte* ptr = (byte*)Unsafe.AsPointer(ref this) + baseSize;
				if (!MethodDescChunk->m_flagsAndTokenRange.Has(V60.MethodDescChunk.Flags.IsZapped))
				{
					return *(void**)ptr;
				}
				return new RelativePointer((nint)ptr).Value;
			}
			return MethodTable->GetSlot(SlotNumber);
		}

		public unsafe bool TryAsFCall(out FCallMethodDescPtr md)
		{
			if (Classification == MethodClassification.FCall)
			{
				md = new FCallMethodDescPtr(Unsafe.AsPointer(ref this), FCallMethodDescPtr.CurrentVtable);
				return true;
			}
			md = default(FCallMethodDescPtr);
			return false;
		}

		public unsafe bool TryAsNDirect(out NDirectMethodDescPtr md)
		{
			if (Classification == MethodClassification.NDirect)
			{
				md = new NDirectMethodDescPtr(Unsafe.AsPointer(ref this), NDirectMethodDescPtr.CurrentVtable);
				return true;
			}
			md = default(NDirectMethodDescPtr);
			return false;
		}

		public unsafe bool TryAsEEImpl(out EEImplMethodDescPtr md)
		{
			if (Classification == MethodClassification.EEImpl)
			{
				md = new EEImplMethodDescPtr(Unsafe.AsPointer(ref this), EEImplMethodDescPtr.CurrentVtable);
				return true;
			}
			md = default(EEImplMethodDescPtr);
			return false;
		}

		public unsafe bool TryAsArray(out ArrayMethodDescPtr md)
		{
			if (Classification == MethodClassification.Array)
			{
				md = new ArrayMethodDescPtr(Unsafe.AsPointer(ref this), ArrayMethodDescPtr.CurrentVtable);
				return true;
			}
			md = default(ArrayMethodDescPtr);
			return false;
		}

		public unsafe bool TryAsInstantiated(out InstantiatedMethodDesc* md)
		{
			if (Classification == MethodClassification.Instantiated)
			{
				md = (InstantiatedMethodDesc*)Unsafe.AsPointer(ref this);
				return true;
			}
			md = default(InstantiatedMethodDesc*);
			return false;
		}

		public unsafe bool TryAsComPlusCall(out ComPlusCallMethodDesc* md)
		{
			if (Classification == MethodClassification.ComInterop)
			{
				md = (ComPlusCallMethodDesc*)Unsafe.AsPointer(ref this);
				return true;
			}
			md = default(ComPlusCallMethodDesc*);
			return false;
		}

		public unsafe bool TryAsDynamic(out DynamicMethodDescPtr md)
		{
			if (Classification == MethodClassification.Dynamic)
			{
				md = new DynamicMethodDescPtr(Unsafe.AsPointer(ref this), DynamicMethodDescPtr.CurrentVtable);
				return true;
			}
			md = default(DynamicMethodDescPtr);
			return false;
		}

		public unsafe nuint SizeOf(bool includeNonVtable = true, bool includeMethodImpl = true, bool includeComPlus = true, bool includeNativeCode = true)
		{
			nuint num = (nuint)((nint)GetBaseSize() + (nint)((includeNonVtable && m_wFlags.Has(MethodDescClassification.HasNonVtableSlot)) ? sizeof(void*) : 0) + ((includeMethodImpl && m_wFlags.Has(MethodDescClassification.MethodImpl)) ? ((nint)sizeof(void*) * (nint)2) : 0) + ((includeComPlus && m_wFlags.Has(MethodDescClassification.HasComPlusCallInfo)) ? sizeof(void*) : 0) + ((includeNativeCode && m_wFlags.Has(MethodDescClassification.HasNativeCodeSlot)) ? sizeof(void*) : 0));
			if (includeNativeCode && HasNativeCodeSlot)
			{
				num += (nuint)((((nuint)GetAddrOfNativeCodeSlot() & (nuint)1u) != 0) ? sizeof(void*) : 0);
			}
			return num;
		}

		public unsafe void* GetNativeCode()
		{
			if (HasNativeCodeSlot)
			{
				void* ptr = *(void**)((nuint)GetAddrOfNativeCodeSlot() & (nuint)(~(nint)1));
				if (ptr != null)
				{
					return ptr;
				}
			}
			if (!HasStableEntryPoint || HasPrecode)
			{
				return null;
			}
			return GetStableEntryPoint();
		}

		public unsafe void* GetStableEntryPoint()
		{
			return GetMethodEntryPoint();
		}

		public unsafe static MethodDesc* FindTightlyBoundWrappedMethodDesc(MethodDesc* pMD)
		{
			if (pMD->IsUnboxingStub && pMD->TryAsInstantiated(out var md))
			{
				pMD = md->IMD_GetWrappedMethodDesc();
			}
			if (!pMD->IsTightlyBoundToMethodTable)
			{
				pMD = pMD->GetCanonicalMethodTable()->GetParallelMethodDesc(pMD);
			}
			if (pMD->IsUnboxingStub)
			{
				pMD = GetNextIntroducedMethod(pMD);
			}
			return pMD;
		}

		public unsafe static MethodDesc* GetNextIntroducedMethod(MethodDesc* pMD)
		{
			MethodDescChunk* methodDescChunk = pMD->MethodDescChunk;
			nuint num = (nuint)((byte*)pMD + pMD->SizeOf());
			nuint num2 = (nuint)((byte*)methodDescChunk + methodDescChunk->SizeOf);
			if (num < num2)
			{
				return (MethodDesc*)num;
			}
			methodDescChunk = methodDescChunk->m_next;
			if (methodDescChunk != null)
			{
				return methodDescChunk->FirstMethodDesc;
			}
			return null;
		}

		public unsafe MethodTable* GetCanonicalMethodTable()
		{
			return MethodTable->GetCanonicalMethodTable();
		}

		public unsafe void* GetAddrOfNativeCodeSlot()
		{
			nuint byteOffset = SizeOf(includeNonVtable: true, includeMethodImpl: true, includeComPlus: false, includeNativeCode: false);
			return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, byteOffset));
		}

		public nuint GetBaseSize()
		{
			return GetBaseSize(Classification);
		}

		public static nuint GetBaseSize(MethodClassification classification)
		{
			return s_ClassificationSizeTable[(int)classification];
		}
	}

	public struct MethodDescChunk
	{
		[Flags]
		public enum Flags : ushort
		{
			TokenRangeMask = 0x3FF,
			HasCompactEntrypoints = 0x4000,
			IsZapped = 0x8000
		}

		public unsafe MethodTable* m_methodTable;

		public unsafe MethodDescChunk* m_next;

		public byte m_size;

		public byte m_count;

		public Flags m_flagsAndTokenRange;

		public unsafe MethodDesc* FirstMethodDesc => (MethodDesc*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodDescChunk));

		public uint Size => (uint)(m_size + 1);

		public uint Count => (uint)(m_count + 1);

		public unsafe nuint SizeOf => (nuint)sizeof(MethodDescChunk) + Size * MethodDesc.Alignment;
	}

	[FatInterface]
	public struct StoredSigMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? StoredSigMethodDesc_64.FatVtable_ : StoredSigMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(StoredSigMethodDesc_64) : sizeof(StoredSigMethodDesc_32);

		public unsafe void* m_pSig
		{
			[FatInterfaceIgnore]
			get
			{
				return GetPSig();
			}
		}

		public uint m_cSig
		{
			[FatInterfaceIgnore]
			get
			{
				return GetCSig();
			}
		}

		private unsafe void* GetPSig()
		{
			return ((delegate*<void*, void*>)(void*)vtbl_[0])(ptr_);
		}

		private unsafe uint GetCSig()
		{
			return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
		}

		public unsafe StoredSigMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
	public struct StoredSigMethodDesc_64
	{
		public MethodDesc @base;

		public unsafe void* m_pSig;

		public uint m_cSig;

		public uint m_dwExtendedFlags;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[2]
					{
						(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
						(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
					};
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetCSig_1(void* ptr__)
				{
					return ((StoredSigMethodDesc_64*)ptr__)->GetCSig();
				}
				unsafe static void* S_GetPSig_0(void* ptr__)
				{
					return ((StoredSigMethodDesc_64*)ptr__)->GetPSig();
				}
			}
		}

		private unsafe void* GetPSig()
		{
			return m_pSig;
		}

		private uint GetCSig()
		{
			return m_cSig;
		}
	}

	[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
	public struct StoredSigMethodDesc_32
	{
		public MethodDesc @base;

		public unsafe void* m_pSig;

		public uint m_cSig;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[2]
					{
						(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
						(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
					};
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetCSig_1(void* ptr__)
				{
					return ((StoredSigMethodDesc_32*)ptr__)->GetCSig();
				}
				unsafe static void* S_GetPSig_0(void* ptr__)
				{
					return ((StoredSigMethodDesc_32*)ptr__)->GetPSig();
				}
			}
		}

		private unsafe void* GetPSig()
		{
			return m_pSig;
		}

		private uint GetCSig()
		{
			return m_cSig;
		}
	}

	[FatInterface]
	public struct FCallMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? FCallMethodDesc_64.FatVtable_ : FCallMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(FCallMethodDesc_64) : sizeof(FCallMethodDesc_32);

		public uint m_dwECallID
		{
			[FatInterfaceIgnore]
			get
			{
				return GetECallID();
			}
		}

		private unsafe uint GetECallID()
		{
			return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
		}

		public unsafe FCallMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
	public struct FCallMethodDesc_64
	{
		public MethodDesc @base;

		public uint m_dwECallID;

		public uint m_padding;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetECallID_0(void* ptr__)
				{
					return ((FCallMethodDesc_64*)ptr__)->GetECallID();
				}
			}
		}

		private uint GetECallID()
		{
			return m_dwECallID;
		}
	}

	[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
	public struct FCallMethodDesc_32
	{
		public MethodDesc @base;

		public uint m_dwECallID;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetECallID_0(void* ptr__)
				{
					return ((FCallMethodDesc_32*)ptr__)->GetECallID();
				}
			}
		}

		private uint GetECallID()
		{
			return m_dwECallID;
		}
	}

	public struct DynamicResolver
	{
	}

	[Flags]
	public enum DynamicMethodDesc_ExtendedFlags
	{
		Attrs = 0xFFFF,
		ILStubAttrs = 0x17,
		MemberAccessMask = 7,
		ReverseStub = 8,
		Static = 0x10,
		CALLIStub = 0x20,
		DelegateStub = 0x40,
		StructMarshalStub = 0x80,
		Unbreakable = 0x100,
		SignatureNeedsResture = 0x400,
		StubNeedsCOMStarted = 0x800,
		MulticastStub = 0x1000,
		UnboxingILStub = 0x2000,
		WrapperDelegateStub = 0x4000,
		UnmanagedCallersOnlyStub = 0x8000,
		ILStub = 0x10000,
		LCGMethod = 0x20000,
		StackArgSize = 0xFFC0000
	}

	[FatInterface]
	public struct DynamicMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? DynamicMethodDesc_64.FatVtable_ : DynamicMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(DynamicMethodDesc_64) : sizeof(DynamicMethodDesc_32);

		public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

		private unsafe DynamicMethodDesc_ExtendedFlags GetFlags()
		{
			return ((delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(void*)vtbl_[0])(ptr_);
		}

		public unsafe DynamicMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
	public struct DynamicMethodDesc_64
	{
		public StoredSigMethodDesc_64 @base;

		public unsafe byte* m_pszMethodName;

		public unsafe DynamicResolver* m_pResolver;

		private static IntPtr[]? fatVtable_;

		public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
				{
					return ((DynamicMethodDesc_64*)ptr__)->GetFlags();
				}
			}
		}

		private DynamicMethodDesc_ExtendedFlags GetFlags()
		{
			return (DynamicMethodDesc_ExtendedFlags)@base.m_dwExtendedFlags;
		}
	}

	[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
	public struct DynamicMethodDesc_32
	{
		public StoredSigMethodDesc_32 @base;

		public unsafe byte* m_pszMethodName;

		public unsafe DynamicResolver* m_pResolver;

		public uint m_dwExtendedFlags;

		private static IntPtr[]? fatVtable_;

		public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
				{
					return ((DynamicMethodDesc_32*)ptr__)->GetFlags();
				}
			}
		}

		private DynamicMethodDesc_ExtendedFlags GetFlags()
		{
			return (DynamicMethodDesc_ExtendedFlags)m_dwExtendedFlags;
		}
	}

	[FatInterface]
	public struct ArrayMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? ArrayMethodDesc_64.FatVtable_ : ArrayMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(ArrayMethodDesc_64) : sizeof(ArrayMethodDesc_32);

		public unsafe ArrayMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	public enum ArrayFunc
	{
		Get,
		Set,
		Address,
		Ctor
	}

	[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
	public struct ArrayMethodDesc_64
	{
		public StoredSigMethodDesc_64 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
	public struct ArrayMethodDesc_32
	{
		public StoredSigMethodDesc_32 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	public struct NDirectWriteableData
	{
	}

	[Flags]
	public enum NDirectMethodDesc_Flags : ushort
	{
		EarlyBound = 1,
		HasSuppressUnmanagedCodeAccess = 2,
		DefaultDllImportSearchPathIsCached = 4,
		IsMarshalingRequiredCached = 0x10,
		CachedMarshalingRequired = 0x20,
		NativeAnsi = 0x40,
		LastError = 0x80,
		NativeNoMangle = 0x100,
		VarArgs = 0x200,
		StdCall = 0x400,
		ThisCall = 0x800,
		IsQCall = 0x1000,
		DefaultDllImportSearchPathsStatus = 0x2000,
		NDirectPopulated = 0x8000
	}

	[FatInterface]
	public struct NDirectMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? NDirectMethodDesc_x86.FatVtable_ : NDirectMethodDesc_other.FatVtable_;

		public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(NDirectMethodDesc_x86) : sizeof(NDirectMethodDesc_other);

		public unsafe NDirectMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
	public struct NDirectMethodDesc_other
	{
		public struct NDirect
		{
			public unsafe void* m_pNativeNDirectTarget;

			public unsafe byte* m_pszEntrypointName;

			public nuint union_pszLibName_dwECallID;

			public unsafe NDirectWriteableData* m_pWriteableData;

			public unsafe void* m_pImportThunkGlue;

			public uint m_DefaultDllImportSearchPathsAttributeValue;

			public NDirectMethodDesc_Flags m_wFlags;

			public unsafe MethodDesc* m_pStubMD;
		}

		public MethodDesc @base;

		private NDirect ndirect;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
	public struct NDirectMethodDesc_x86
	{
		public struct NDirect
		{
			public unsafe void* m_pNativeNDirectTarget;

			public unsafe byte* m_pszEntrypointName;

			public nuint union_pszLibName_dwECallID;

			public unsafe NDirectWriteableData* m_pWriteableData;

			public unsafe void* m_pImportThunkGlue;

			public uint m_DefaultDllImportSearchPathsAttributeValue;

			public NDirectMethodDesc_Flags m_wFlags;

			public ushort m_cbStackArgumentSize;

			public unsafe MethodDesc* m_pStubMD;
		}

		public MethodDesc @base;

		private NDirect ndirect;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterface]
	public struct EEImplMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? EEImplMethodDesc_64.FatVtable_ : EEImplMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(EEImplMethodDesc_64) : sizeof(EEImplMethodDesc_32);

		public unsafe EEImplMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
	public struct EEImplMethodDesc_64
	{
		public StoredSigMethodDesc_64 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
	public struct EEImplMethodDesc_32
	{
		public StoredSigMethodDesc_32 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	public struct ComPlusCallMethodDesc
	{
		public MethodDesc @base;

		public unsafe void* m_pComPlusCallInfo;
	}

	public struct InstantiatedMethodDesc
	{
		[Flags]
		public enum Flags : ushort
		{
			KindMask = 7,
			GenericMethodDefinition = 0,
			UnsharedMethodInstantiation = 1,
			SharedMethodInstantiation = 2,
			WrapperStubWithInstantiations = 3,
			EnCAddedMethod = 7,
			Unrestored = 8,
			HasComPlusCallInfo = 0x10
		}

		public MethodDesc @base;

		public unsafe void* union_pDictLayout_pWrappedMethodDesc;

		public unsafe Dictionary* m_pPerInstInfo;

		public Flags m_wFlags2;

		public ushort m_wNumGenericArgs;

		public unsafe bool IMD_HasMethodInstantiation
		{
			get
			{
				if (!IMD_IsGenericMethodDefinition)
				{
					return m_pPerInstInfo != null;
				}
				return true;
			}
		}

		public bool IMD_IsGenericMethodDefinition => (m_wFlags2 & Flags.KindMask) == 0;

		public bool IMD_IsWrapperStubWithInstantiations => (m_wFlags2 & Flags.KindMask) == Flags.WrapperStubWithInstantiations;

		public unsafe MethodDesc* IMD_GetWrappedMethodDesc()
		{
			Helpers.Assert(IMD_IsWrapperStubWithInstantiations, null, "IMD_IsWrapperStubWithInstantiations");
			return (MethodDesc*)union_pDictLayout_pWrappedMethodDesc;
		}
	}

	public struct Dictionary
	{
	}

	public struct Module
	{
	}

	public struct MethodTableWriteableData
	{
	}

	public struct VTableIndir2_t
	{
		public unsafe void* pCode;

		public unsafe void* Value => pCode;
	}

	public struct VTableIndir_t
	{
		public unsafe VTableIndir2_t* Value;
	}

	private static class MultipurposeSlotHelpers
	{
		public unsafe static byte OffsetOfMp1()
		{
			MethodTable methodTable = default(MethodTable);
			return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
		}

		public unsafe static byte OffsetOfMp2()
		{
			MethodTable methodTable = default(MethodTable);
			return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
		}

		public unsafe static byte RegularOffset(int index)
		{
			return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
		}
	}

	public struct MethodTable
	{
		[Flags]
		public enum Flags2 : ushort
		{
			MultipurposeSlotsMask = 0x1F,
			HasPerInstInfo = 1,
			HasInterfaceMap = 2,
			HasDispatchMapSlot = 4,
			HasNonVirtualSlots = 8,
			HasModuleOverride = 0x10,
			IsZapped = 0x20,
			IsPreRestored = 0x40,
			HasModuleDependencies = 0x80,
			IsIntrinsicType = 0x100,
			RequiresDispatchTokenFat = 0x200,
			HasCctor = 0x400,
			HasVirtualStaticMethods = 0x800,
			REquiresAlign8 = 0x1000,
			HasBoxedRegularStatics = 0x2000,
			HasSingleNonVirtualSlot = 0x4000,
			DependsOnEquivalentOrForwardedStructs = 0x8000
		}

		public enum UnionLowBits
		{
			EEClass,
			Invalid,
			MethodTable,
			Indirection
		}

		public uint m_dwFlags;

		public uint m_BaseSize;

		public Flags2 m_wFlags2;

		public ushort m_wToken;

		public ushort m_wNumVirtuals;

		public ushort m_wNumInterfaces;

		private unsafe void* m_pParentMethodTable;

		public unsafe Module* m_pLoaderModule;

		public unsafe MethodTableWriteableData* m_pWriteableData;

		public unsafe void* union_pEEClass_pCanonMT;

		public unsafe void* union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1;

		public unsafe void* union_p_InterfaceMap_pMultipurposeSlot2;

		public const int VTABLE_SLOTS_PER_CHUNK = 8;

		public const int VTABLE_SLOTS_PER_CHUNK_LOG2 = 3;

		private static readonly byte[] c_NonVirtualSlotsOffsets = GetNonVirtualSlotsOffsets();

		public bool IsInterface => (m_dwFlags & 0xF0000) == 786432;

		public bool HasIndirectParent => (m_dwFlags & 0x800000) != 0;

		public bool HasSingleNonVirtualSlot => m_wFlags2.Has(Flags2.HasSingleNonVirtualSlot);

		public unsafe MethodTable* GetCanonicalMethodTable()
		{
			nuint num = (nuint)union_pEEClass_pCanonMT;
			if ((num & 2) == 0)
			{
				return (MethodTable*)num;
			}
			if ((num & 1) != 0)
			{
				return *(MethodTable**)(num - 3);
			}
			return (MethodTable*)(num - 2);
		}

		public unsafe MethodDesc* GetParallelMethodDesc(MethodDesc* pDefMD)
		{
			return GetMethodDescForSlot(pDefMD->SlotNumber);
		}

		public unsafe MethodDesc* GetMethodDescForSlot(uint slotNumber)
		{
			if (IsInterface)
			{
				GetNumVirtuals();
			}
			throw new NotImplementedException();
		}

		public unsafe void* GetRestoredSlot(uint slotNumber)
		{
			MethodTable* ptr = (MethodTable*)Unsafe.AsPointer(ref this);
			void* slot;
			while (true)
			{
				ptr = ptr->GetCanonicalMethodTable();
				slot = ptr->GetSlot(slotNumber);
				if (slot != null)
				{
					break;
				}
				ptr = ptr->GetParentMethodTable();
			}
			return slot;
		}

		public unsafe MethodTable* GetParentMethodTable()
		{
			void* pParentMethodTable = m_pParentMethodTable;
			if (HasIndirectParent)
			{
				return *(MethodTable**)pParentMethodTable;
			}
			return (MethodTable*)pParentMethodTable;
		}

		public unsafe void* GetSlot(uint slotNumber)
		{
			nint slotPtrRaw = GetSlotPtrRaw(slotNumber);
			if (slotNumber < GetNumVirtuals())
			{
				return ((VTableIndir2_t*)slotPtrRaw)->Value;
			}
			if ((m_wFlags2 & Flags2.IsZapped) != 0 && slotNumber >= GetNumVirtuals())
			{
				return ((RelativePointer*)slotPtrRaw)->Value;
			}
			return *(void**)slotPtrRaw;
		}

		public unsafe nint GetSlotPtrRaw(uint slotNum)
		{
			if (slotNum < GetNumVirtuals())
			{
				uint indexOfVtableIndirection = GetIndexOfVtableIndirection(slotNum);
				return (nint)(VTableIndir_t__GetValueMaybeNullAtPtr((nint)(GetVtableIndirections() + indexOfVtableIndirection)) + GetIndexAfterVtableIndirection(slotNum));
			}
			if (HasSingleNonVirtualSlot)
			{
				return GetNonVirtualSlotsPtr();
			}
			return (nint)(GetNonVirtualSlotsArray() + (slotNum - GetNumVirtuals()));
		}

		public ushort GetNumVirtuals()
		{
			return m_wNumVirtuals;
		}

		public static uint GetIndexOfVtableIndirection(uint slotNum)
		{
			return slotNum >> 3;
		}

		public unsafe VTableIndir_t* GetVtableIndirections()
		{
			return (VTableIndir_t*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodTable));
		}

		public unsafe static VTableIndir2_t* VTableIndir_t__GetValueMaybeNullAtPtr(nint @base)
		{
			return (VTableIndir2_t*)@base;
		}

		public static uint GetIndexAfterVtableIndirection(uint slotNum)
		{
			return slotNum & 7;
		}

		[MultipurposeSlotOffsetTable(3, typeof(MultipurposeSlotHelpers))]
		private static byte[] GetNonVirtualSlotsOffsets()
		{
			return new byte[8]
			{
				MultipurposeSlotHelpers.OffsetOfMp1(),
				MultipurposeSlotHelpers.OffsetOfMp2(),
				MultipurposeSlotHelpers.OffsetOfMp1(),
				MultipurposeSlotHelpers.RegularOffset(2),
				MultipurposeSlotHelpers.OffsetOfMp2(),
				MultipurposeSlotHelpers.RegularOffset(2),
				MultipurposeSlotHelpers.RegularOffset(2),
				MultipurposeSlotHelpers.RegularOffset(3)
			};
		}

		public nint GetNonVirtualSlotsPtr()
		{
			return GetMultipurposeSlotPtr(Flags2.HasNonVirtualSlots, c_NonVirtualSlotsOffsets);
		}

		public unsafe nint GetMultipurposeSlotPtr(Flags2 flag, byte[] offsets)
		{
			nint num = offsets[(uint)(m_wFlags2 & (flag - 1))];
			if (num >= sizeof(MethodTable))
			{
				num += (nint)GetNumVTableIndirections() * (nint)sizeof(VTableIndir_t);
			}
			return (nint)((byte*)Unsafe.AsPointer(ref this) + num);
		}

		public unsafe void*** GetNonVirtualSlotsArray()
		{
			return (void***)GetNonVirtualSlotsPtr();
		}

		public uint GetNumVTableIndirections()
		{
			return GetNumVtableIndirections(GetNumVirtuals());
		}

		public static uint GetNumVtableIndirections(uint numVirtuals)
		{
			return numVirtuals + 7 >> 3;
		}
	}

	public new unsafe static InvokeCompileMethodPtr InvokeCompileMethodPtr => new InvokeCompileMethodPtr((delegate*<IntPtr, IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(&InvokeCompileMethod));

	public new unsafe static CorJitResult InvokeCompileMethod(IntPtr functionPtr, IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode)
	{
		if (functionPtr == IntPtr.Zero)
		{
			*nativeEntry = null;
			*nativeSizeOfCode = 0u;
			return CorJitResult.CORJIT_OK;
		}
		delegate* unmanaged[Thiscall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate* = (delegate* unmanaged[Thiscall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult>)(void*)functionPtr;
		delegate* unmanaged[Thiscall]<IntPtr, IntPtr, CORINFO_METHOD_INFO*, uint, byte**, uint*, CorJitResult> delegate*2 = delegate*;
		/*Error near IL_002b: Handle with invalid row number.*/;
	}
}


using System;
using System.Runtime.InteropServices;

[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
public unsafe delegate CorJitResult CompileMethodDelegate(IntPtr thisPtr, IntPtr corJitInfo, CORINFO_METHOD_INFO* methodInfo, uint flags, byte** nativeEntry, uint* nativeSizeOfCode);


public enum MethodClassification
{
	IL,
	FCall,
	NDirect,
	EEImpl,
	Array,
	Instantiated,
	ComInterop,
	Dynamic
}


using System;

[Flags]
public enum MethodDescClassification : ushort
{
	ClassificationMask = 7,
	HasNonVtableSlot = 8,
	MethodImpl = 0x10,
	HasNativeCodeSlot = 0x20,
	HasComPlusCallInfo = 0x40,
	Static = 0x80,
	Duplicate = 0x400,
	VerifiedState = 0x800,
	Verifiable = 0x1000,
	NotInline = 0x2000,
	Synchronized = 0x4000,
	RequiresFullSlotNumber = 0x8000
}


using System.Runtime.CompilerServices;

public struct RelativePointer
{
	private nint m_delta;

	public unsafe void* Value
	{
		get
		{
			nint delta = m_delta;
			if (delta != 0)
			{
				return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
			}
			return null;
		}
	}

	public RelativePointer(nint delta)
	{
		m_delta = delta;
	}
}


using System.Runtime.CompilerServices;

public struct RelativeFixupPointer
{
	private nint m_delta;

	public const nint FIXUP_POINTER_INDIRECTION = 1;

	public unsafe void* Value
	{
		get
		{
			nint delta = m_delta;
			if (delta == 0)
			{
				return null;
			}
			nint num = (nint)Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
			if ((num & 1) != 0)
			{
				num = *(nint*)(num - 1);
			}
			return (void*)num;
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Utils;

public struct MethodDesc
{
	[Flags]
	public enum Flags3 : ushort
	{
		TokenRemainderMask = 0x3FFF,
		HasForwardedValuetypeParameter = 0x4000,
		ValueTypeParametersWalked = 0x4000,
		DoesNotHaveEquivalentValuetypeParameters = 0x8000
	}

	[Flags]
	public enum Flags2 : byte
	{
		HasStableEntryPoint = 1,
		HasPrecode = 2,
		IsUnboxingStub = 4,
		IsJitIntrinsic = 0x10,
		IsEligibleForTieredCompilation = 0x20,
		RequiresCovariantReturnTypeChecking = 0x40
	}

	public static readonly nuint Alignment = (nuint)((IntPtr.Size == 8) ? 8 : 4);

	public Flags3 m_wFlags3AndTokenRemainder;

	public byte m_chunkIndex;

	public Flags2 m_bFlags2;

	public const ushort PackedSlot_SlotMask = 1023;

	public const ushort PackedSlot_NameHashMask = 64512;

	public ushort m_wSlotNumber;

	public MethodDescClassification m_wFlags;

	private unsafe static readonly nuint[] s_ClassificationSizeTable = new UIntPtr[8]
	{
		(nuint)sizeof(MethodDesc),
		(nuint)FCallMethodDescPtr.CurrentSize,
		(nuint)NDirectMethodDescPtr.CurrentSize,
		(nuint)EEImplMethodDescPtr.CurrentSize,
		(nuint)ArrayMethodDescPtr.CurrentSize,
		(nuint)sizeof(InstantiatedMethodDesc),
		(nuint)sizeof(ComPlusCallMethodDesc),
		(nuint)DynamicMethodDescPtr.CurrentSize
	};

	public ushort SlotNumber
	{
		get
		{
			if (!m_wFlags.Has(MethodDescClassification.RequiresFullSlotNumber))
			{
				return (ushort)(m_wSlotNumber & 0x3FF);
			}
			return m_wSlotNumber;
		}
	}

	public MethodClassification Classification => (MethodClassification)(m_wFlags & MethodDescClassification.ClassificationMask);

	public unsafe MethodDescChunk* MethodDescChunk => (MethodDescChunk*)((byte*)Unsafe.AsPointer(ref this) - (nuint)((nint)sizeof(MethodDescChunk) + (nint)(m_chunkIndex * Alignment)));

	public unsafe MethodTable* MethodTable => MethodDescChunk->m_methodTable;

	public bool HasNonVtableSlot => m_wFlags.Has(MethodDescClassification.HasNonVtableSlot);

	public bool HasStableEntryPoint => m_bFlags2.Has(Flags2.HasStableEntryPoint);

	public bool HasPrecode => m_bFlags2.Has(Flags2.HasPrecode);

	public bool HasNativeCodeSlot => m_wFlags.Has(MethodDescClassification.HasNativeCodeSlot);

	public bool IsUnboxingStub => m_bFlags2.Has(Flags2.IsUnboxingStub);

	public unsafe bool HasMethodInstantiation
	{
		get
		{
			if (TryAsInstantiated(out var md))
			{
				return md->IMD_HasMethodInstantiation;
			}
			return false;
		}
	}

	public unsafe bool IsGenericMethodDefinition
	{
		get
		{
			if (TryAsInstantiated(out var md))
			{
				return md->IMD_IsGenericMethodDefinition;
			}
			return false;
		}
	}

	public unsafe bool IsInstantiatingStub
	{
		get
		{
			if (!IsUnboxingStub && TryAsInstantiated(out var md))
			{
				return md->IMD_IsWrapperStubWithInstantiations;
			}
			return false;
		}
	}

	public bool IsWrapperStub
	{
		get
		{
			if (!IsUnboxingStub)
			{
				return IsInstantiatingStub;
			}
			return true;
		}
	}

	public bool IsTightlyBoundToMethodTable
	{
		get
		{
			if (!HasNonVtableSlot)
			{
				return true;
			}
			if (HasMethodInstantiation)
			{
				return IsGenericMethodDefinition;
			}
			if (IsWrapperStub)
			{
				return false;
			}
			return true;
		}
	}

	public unsafe void* GetMethodEntryPoint()
	{
		if (HasNonVtableSlot)
		{
			nuint baseSize = GetBaseSize();
			byte* ptr = (byte*)Unsafe.AsPointer(ref this) + baseSize;
			if (!MethodDescChunk->m_flagsAndTokenRange.Has(V60.MethodDescChunk.Flags.IsZapped))
			{
				return *(void**)ptr;
			}
			return new RelativePointer((nint)ptr).Value;
		}
		return MethodTable->GetSlot(SlotNumber);
	}

	public unsafe bool TryAsFCall(out FCallMethodDescPtr md)
	{
		if (Classification == MethodClassification.FCall)
		{
			md = new FCallMethodDescPtr(Unsafe.AsPointer(ref this), FCallMethodDescPtr.CurrentVtable);
			return true;
		}
		md = default(FCallMethodDescPtr);
		return false;
	}

	public unsafe bool TryAsNDirect(out NDirectMethodDescPtr md)
	{
		if (Classification == MethodClassification.NDirect)
		{
			md = new NDirectMethodDescPtr(Unsafe.AsPointer(ref this), NDirectMethodDescPtr.CurrentVtable);
			return true;
		}
		md = default(NDirectMethodDescPtr);
		return false;
	}

	public unsafe bool TryAsEEImpl(out EEImplMethodDescPtr md)
	{
		if (Classification == MethodClassification.EEImpl)
		{
			md = new EEImplMethodDescPtr(Unsafe.AsPointer(ref this), EEImplMethodDescPtr.CurrentVtable);
			return true;
		}
		md = default(EEImplMethodDescPtr);
		return false;
	}

	public unsafe bool TryAsArray(out ArrayMethodDescPtr md)
	{
		if (Classification == MethodClassification.Array)
		{
			md = new ArrayMethodDescPtr(Unsafe.AsPointer(ref this), ArrayMethodDescPtr.CurrentVtable);
			return true;
		}
		md = default(ArrayMethodDescPtr);
		return false;
	}

	public unsafe bool TryAsInstantiated(out InstantiatedMethodDesc* md)
	{
		if (Classification == MethodClassification.Instantiated)
		{
			md = (InstantiatedMethodDesc*)Unsafe.AsPointer(ref this);
			return true;
		}
		md = default(InstantiatedMethodDesc*);
		return false;
	}

	public unsafe bool TryAsComPlusCall(out ComPlusCallMethodDesc* md)
	{
		if (Classification == MethodClassification.ComInterop)
		{
			md = (ComPlusCallMethodDesc*)Unsafe.AsPointer(ref this);
			return true;
		}
		md = default(ComPlusCallMethodDesc*);
		return false;
	}

	public unsafe bool TryAsDynamic(out DynamicMethodDescPtr md)
	{
		if (Classification == MethodClassification.Dynamic)
		{
			md = new DynamicMethodDescPtr(Unsafe.AsPointer(ref this), DynamicMethodDescPtr.CurrentVtable);
			return true;
		}
		md = default(DynamicMethodDescPtr);
		return false;
	}

	public unsafe nuint SizeOf(bool includeNonVtable = true, bool includeMethodImpl = true, bool includeComPlus = true, bool includeNativeCode = true)
	{
		nuint num = (nuint)((nint)GetBaseSize() + (nint)((includeNonVtable && m_wFlags.Has(MethodDescClassification.HasNonVtableSlot)) ? sizeof(void*) : 0) + ((includeMethodImpl && m_wFlags.Has(MethodDescClassification.MethodImpl)) ? ((nint)sizeof(void*) * (nint)2) : 0) + ((includeComPlus && m_wFlags.Has(MethodDescClassification.HasComPlusCallInfo)) ? sizeof(void*) : 0) + ((includeNativeCode && m_wFlags.Has(MethodDescClassification.HasNativeCodeSlot)) ? sizeof(void*) : 0));
		if (includeNativeCode && HasNativeCodeSlot)
		{
			num += (nuint)((((nuint)GetAddrOfNativeCodeSlot() & (nuint)1u) != 0) ? sizeof(void*) : 0);
		}
		return num;
	}

	public unsafe void* GetNativeCode()
	{
		if (HasNativeCodeSlot)
		{
			void* ptr = *(void**)((nuint)GetAddrOfNativeCodeSlot() & (nuint)(~(nint)1));
			if (ptr != null)
			{
				return ptr;
			}
		}
		if (!HasStableEntryPoint || HasPrecode)
		{
			return null;
		}
		return GetStableEntryPoint();
	}

	public unsafe void* GetStableEntryPoint()
	{
		return GetMethodEntryPoint();
	}

	public unsafe static MethodDesc* FindTightlyBoundWrappedMethodDesc(MethodDesc* pMD)
	{
		if (pMD->IsUnboxingStub && pMD->TryAsInstantiated(out var md))
		{
			pMD = md->IMD_GetWrappedMethodDesc();
		}
		if (!pMD->IsTightlyBoundToMethodTable)
		{
			pMD = pMD->GetCanonicalMethodTable()->GetParallelMethodDesc(pMD);
		}
		if (pMD->IsUnboxingStub)
		{
			pMD = GetNextIntroducedMethod(pMD);
		}
		return pMD;
	}

	public unsafe static MethodDesc* GetNextIntroducedMethod(MethodDesc* pMD)
	{
		MethodDescChunk* methodDescChunk = pMD->MethodDescChunk;
		nuint num = (nuint)((byte*)pMD + pMD->SizeOf());
		nuint num2 = (nuint)((byte*)methodDescChunk + methodDescChunk->SizeOf);
		if (num < num2)
		{
			return (MethodDesc*)num;
		}
		methodDescChunk = methodDescChunk->m_next;
		if (methodDescChunk != null)
		{
			return methodDescChunk->FirstMethodDesc;
		}
		return null;
	}

	public unsafe MethodTable* GetCanonicalMethodTable()
	{
		return MethodTable->GetCanonicalMethodTable();
	}

	public unsafe void* GetAddrOfNativeCodeSlot()
	{
		nuint byteOffset = SizeOf(includeNonVtable: true, includeMethodImpl: true, includeComPlus: false, includeNativeCode: false);
		return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, byteOffset));
	}

	public nuint GetBaseSize()
	{
		return GetBaseSize(Classification);
	}

	public static nuint GetBaseSize(MethodClassification classification)
	{
		return s_ClassificationSizeTable[(int)classification];
	}
}


using System;

[Flags]
public enum Flags3 : ushort
{
	TokenRemainderMask = 0x3FFF,
	HasForwardedValuetypeParameter = 0x4000,
	ValueTypeParametersWalked = 0x4000,
	DoesNotHaveEquivalentValuetypeParameters = 0x8000
}


using System;

[Flags]
public enum Flags2 : byte
{
	HasStableEntryPoint = 1,
	HasPrecode = 2,
	IsUnboxingStub = 4,
	IsJitIntrinsic = 0x10,
	IsEligibleForTieredCompilation = 0x20,
	RequiresCovariantReturnTypeChecking = 0x40
}


using System;
using System.Runtime.CompilerServices;

public struct MethodDescChunk
{
	[Flags]
	public enum Flags : ushort
	{
		TokenRangeMask = 0x3FF,
		HasCompactEntrypoints = 0x4000,
		IsZapped = 0x8000
	}

	public unsafe MethodTable* m_methodTable;

	public unsafe MethodDescChunk* m_next;

	public byte m_size;

	public byte m_count;

	public Flags m_flagsAndTokenRange;

	public unsafe MethodDesc* FirstMethodDesc => (MethodDesc*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodDescChunk));

	public uint Size => (uint)(m_size + 1);

	public uint Count => (uint)(m_count + 1);

	public unsafe nuint SizeOf => (nuint)sizeof(MethodDescChunk) + Size * MethodDesc.Alignment;
}


using System;

[Flags]
public enum Flags : ushort
{
	TokenRangeMask = 0x3FF,
	HasCompactEntrypoints = 0x4000,
	IsZapped = 0x8000
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct StoredSigMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? StoredSigMethodDesc_64.FatVtable_ : StoredSigMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(StoredSigMethodDesc_64) : sizeof(StoredSigMethodDesc_32);

	public unsafe void* m_pSig
	{
		[FatInterfaceIgnore]
		get
		{
			return GetPSig();
		}
	}

	public uint m_cSig
	{
		[FatInterfaceIgnore]
		get
		{
			return GetCSig();
		}
	}

	private unsafe void* GetPSig()
	{
		return ((delegate*<void*, void*>)(void*)vtbl_[0])(ptr_);
	}

	private unsafe uint GetCSig()
	{
		return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
	}

	public unsafe StoredSigMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
public struct StoredSigMethodDesc_64
{
	public MethodDesc @base;

	public unsafe void* m_pSig;

	public uint m_cSig;

	public uint m_dwExtendedFlags;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[2]
				{
					(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
					(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
				};
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetCSig_1(void* ptr__)
			{
				return ((StoredSigMethodDesc_64*)ptr__)->GetCSig();
			}
			unsafe static void* S_GetPSig_0(void* ptr__)
			{
				return ((StoredSigMethodDesc_64*)ptr__)->GetPSig();
			}
		}
	}

	private unsafe void* GetPSig()
	{
		return m_pSig;
	}

	private uint GetCSig()
	{
		return m_cSig;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
public struct StoredSigMethodDesc_32
{
	public MethodDesc @base;

	public unsafe void* m_pSig;

	public uint m_cSig;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[2]
				{
					(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
					(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
				};
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetCSig_1(void* ptr__)
			{
				return ((StoredSigMethodDesc_32*)ptr__)->GetCSig();
			}
			unsafe static void* S_GetPSig_0(void* ptr__)
			{
				return ((StoredSigMethodDesc_32*)ptr__)->GetPSig();
			}
		}
	}

	private unsafe void* GetPSig()
	{
		return m_pSig;
	}

	private uint GetCSig()
	{
		return m_cSig;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct FCallMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? FCallMethodDesc_64.FatVtable_ : FCallMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(FCallMethodDesc_64) : sizeof(FCallMethodDesc_32);

	public uint m_dwECallID
	{
		[FatInterfaceIgnore]
		get
		{
			return GetECallID();
		}
	}

	private unsafe uint GetECallID()
	{
		return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
	}

	public unsafe FCallMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
public struct FCallMethodDesc_64
{
	public MethodDesc @base;

	public uint m_dwECallID;

	public uint m_padding;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetECallID_0(void* ptr__)
			{
				return ((FCallMethodDesc_64*)ptr__)->GetECallID();
			}
		}
	}

	private uint GetECallID()
	{
		return m_dwECallID;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
public struct FCallMethodDesc_32
{
	public MethodDesc @base;

	public uint m_dwECallID;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetECallID_0(void* ptr__)
			{
				return ((FCallMethodDesc_32*)ptr__)->GetECallID();
			}
		}
	}

	private uint GetECallID()
	{
		return m_dwECallID;
	}
}


public struct DynamicResolver
{
}


using System;

[Flags]
public enum DynamicMethodDesc_ExtendedFlags
{
	Attrs = 0xFFFF,
	ILStubAttrs = 0x17,
	MemberAccessMask = 7,
	ReverseStub = 8,
	Static = 0x10,
	CALLIStub = 0x20,
	DelegateStub = 0x40,
	StructMarshalStub = 0x80,
	Unbreakable = 0x100,
	SignatureNeedsResture = 0x400,
	StubNeedsCOMStarted = 0x800,
	MulticastStub = 0x1000,
	UnboxingILStub = 0x2000,
	WrapperDelegateStub = 0x4000,
	UnmanagedCallersOnlyStub = 0x8000,
	ILStub = 0x10000,
	LCGMethod = 0x20000,
	StackArgSize = 0xFFC0000
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct DynamicMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? DynamicMethodDesc_64.FatVtable_ : DynamicMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(DynamicMethodDesc_64) : sizeof(DynamicMethodDesc_32);

	public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

	private unsafe DynamicMethodDesc_ExtendedFlags GetFlags()
	{
		return ((delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(void*)vtbl_[0])(ptr_);
	}

	public unsafe DynamicMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
public struct DynamicMethodDesc_64
{
	public StoredSigMethodDesc_64 @base;

	public unsafe byte* m_pszMethodName;

	public unsafe DynamicResolver* m_pResolver;

	private static IntPtr[]? fatVtable_;

	public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
			{
				return ((DynamicMethodDesc_64*)ptr__)->GetFlags();
			}
		}
	}

	private DynamicMethodDesc_ExtendedFlags GetFlags()
	{
		return (DynamicMethodDesc_ExtendedFlags)@base.m_dwExtendedFlags;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
public struct DynamicMethodDesc_32
{
	public StoredSigMethodDesc_32 @base;

	public unsafe byte* m_pszMethodName;

	public unsafe DynamicResolver* m_pResolver;

	public uint m_dwExtendedFlags;

	private static IntPtr[]? fatVtable_;

	public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
			{
				return ((DynamicMethodDesc_32*)ptr__)->GetFlags();
			}
		}
	}

	private DynamicMethodDesc_ExtendedFlags GetFlags()
	{
		return (DynamicMethodDesc_ExtendedFlags)m_dwExtendedFlags;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct ArrayMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? ArrayMethodDesc_64.FatVtable_ : ArrayMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(ArrayMethodDesc_64) : sizeof(ArrayMethodDesc_32);

	public unsafe ArrayMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


public enum ArrayFunc
{
	Get,
	Set,
	Address,
	Ctor
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
public struct ArrayMethodDesc_64
{
	public StoredSigMethodDesc_64 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
public struct ArrayMethodDesc_32
{
	public StoredSigMethodDesc_32 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct NDirectWriteableData
{
}


using System;

[Flags]
public enum NDirectMethodDesc_Flags : ushort
{
	EarlyBound = 1,
	HasSuppressUnmanagedCodeAccess = 2,
	DefaultDllImportSearchPathIsCached = 4,
	IsMarshalingRequiredCached = 0x10,
	CachedMarshalingRequired = 0x20,
	NativeAnsi = 0x40,
	LastError = 0x80,
	NativeNoMangle = 0x100,
	VarArgs = 0x200,
	StdCall = 0x400,
	ThisCall = 0x800,
	IsQCall = 0x1000,
	DefaultDllImportSearchPathsStatus = 0x2000,
	NDirectPopulated = 0x8000
}


using System;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

[FatInterface]
public struct NDirectMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? NDirectMethodDesc_x86.FatVtable_ : NDirectMethodDesc_other.FatVtable_;

	public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(NDirectMethodDesc_x86) : sizeof(NDirectMethodDesc_other);

	public unsafe NDirectMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
public struct NDirectMethodDesc_other
{
	public struct NDirect
	{
		public unsafe void* m_pNativeNDirectTarget;

		public unsafe byte* m_pszEntrypointName;

		public nuint union_pszLibName_dwECallID;

		public unsafe NDirectWriteableData* m_pWriteableData;

		public unsafe void* m_pImportThunkGlue;

		public uint m_DefaultDllImportSearchPathsAttributeValue;

		public NDirectMethodDesc_Flags m_wFlags;

		public unsafe MethodDesc* m_pStubMD;
	}

	public MethodDesc @base;

	private NDirect ndirect;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct NDirect
{
	public unsafe void* m_pNativeNDirectTarget;

	public unsafe byte* m_pszEntrypointName;

	public nuint union_pszLibName_dwECallID;

	public unsafe NDirectWriteableData* m_pWriteableData;

	public unsafe void* m_pImportThunkGlue;

	public uint m_DefaultDllImportSearchPathsAttributeValue;

	public NDirectMethodDesc_Flags m_wFlags;

	public unsafe MethodDesc* m_pStubMD;
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
public struct NDirectMethodDesc_x86
{
	public struct NDirect
	{
		public unsafe void* m_pNativeNDirectTarget;

		public unsafe byte* m_pszEntrypointName;

		public nuint union_pszLibName_dwECallID;

		public unsafe NDirectWriteableData* m_pWriteableData;

		public unsafe void* m_pImportThunkGlue;

		public uint m_DefaultDllImportSearchPathsAttributeValue;

		public NDirectMethodDesc_Flags m_wFlags;

		public ushort m_cbStackArgumentSize;

		public unsafe MethodDesc* m_pStubMD;
	}

	public MethodDesc @base;

	private NDirect ndirect;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct NDirect
{
	public unsafe void* m_pNativeNDirectTarget;

	public unsafe byte* m_pszEntrypointName;

	public nuint union_pszLibName_dwECallID;

	public unsafe NDirectWriteableData* m_pWriteableData;

	public unsafe void* m_pImportThunkGlue;

	public uint m_DefaultDllImportSearchPathsAttributeValue;

	public NDirectMethodDesc_Flags m_wFlags;

	public ushort m_cbStackArgumentSize;

	public unsafe MethodDesc* m_pStubMD;
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct EEImplMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? EEImplMethodDesc_64.FatVtable_ : EEImplMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(EEImplMethodDesc_64) : sizeof(EEImplMethodDesc_32);

	public unsafe EEImplMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
public struct EEImplMethodDesc_64
{
	public StoredSigMethodDesc_64 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
public struct EEImplMethodDesc_32
{
	public StoredSigMethodDesc_32 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct ComPlusCallMethodDesc
{
	public MethodDesc @base;

	public unsafe void* m_pComPlusCallInfo;
}


using System;
using MonoMod.Utils;

public struct InstantiatedMethodDesc
{
	[Flags]
	public enum Flags : ushort
	{
		KindMask = 7,
		GenericMethodDefinition = 0,
		UnsharedMethodInstantiation = 1,
		SharedMethodInstantiation = 2,
		WrapperStubWithInstantiations = 3,
		EnCAddedMethod = 7,
		Unrestored = 8,
		HasComPlusCallInfo = 0x10
	}

	public MethodDesc @base;

	public unsafe void* union_pDictLayout_pWrappedMethodDesc;

	public unsafe Dictionary* m_pPerInstInfo;

	public Flags m_wFlags2;

	public ushort m_wNumGenericArgs;

	public unsafe bool IMD_HasMethodInstantiation
	{
		get
		{
			if (!IMD_IsGenericMethodDefinition)
			{
				return m_pPerInstInfo != null;
			}
			return true;
		}
	}

	public bool IMD_IsGenericMethodDefinition => (m_wFlags2 & Flags.KindMask) == 0;

	public bool IMD_IsWrapperStubWithInstantiations => (m_wFlags2 & Flags.KindMask) == Flags.WrapperStubWithInstantiations;

	public unsafe MethodDesc* IMD_GetWrappedMethodDesc()
	{
		Helpers.Assert(IMD_IsWrapperStubWithInstantiations, null, "IMD_IsWrapperStubWithInstantiations");
		return (MethodDesc*)union_pDictLayout_pWrappedMethodDesc;
	}
}


using System;

[Flags]
public enum Flags : ushort
{
	KindMask = 7,
	GenericMethodDefinition = 0,
	UnsharedMethodInstantiation = 1,
	SharedMethodInstantiation = 2,
	WrapperStubWithInstantiations = 3,
	EnCAddedMethod = 7,
	Unrestored = 8,
	HasComPlusCallInfo = 0x10
}


public struct Dictionary
{
}


public struct Module
{
}


public struct MethodTableWriteableData
{
}


public struct VTableIndir2_t
{
	public unsafe void* pCode;

	public unsafe void* Value => pCode;
}


public struct VTableIndir_t
{
	public unsafe VTableIndir2_t* Value;
}


using System;

private static class MultipurposeSlotHelpers
{
	public unsafe static byte OffsetOfMp1()
	{
		MethodTable methodTable = default(MethodTable);
		return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
	}

	public unsafe static byte OffsetOfMp2()
	{
		MethodTable methodTable = default(MethodTable);
		return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
	}

	public unsafe static byte RegularOffset(int index)
	{
		return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

public struct MethodTable
{
	[Flags]
	public enum Flags2 : ushort
	{
		MultipurposeSlotsMask = 0x1F,
		HasPerInstInfo = 1,
		HasInterfaceMap = 2,
		HasDispatchMapSlot = 4,
		HasNonVirtualSlots = 8,
		HasModuleOverride = 0x10,
		IsZapped = 0x20,
		IsPreRestored = 0x40,
		HasModuleDependencies = 0x80,
		IsIntrinsicType = 0x100,
		RequiresDispatchTokenFat = 0x200,
		HasCctor = 0x400,
		HasVirtualStaticMethods = 0x800,
		REquiresAlign8 = 0x1000,
		HasBoxedRegularStatics = 0x2000,
		HasSingleNonVirtualSlot = 0x4000,
		DependsOnEquivalentOrForwardedStructs = 0x8000
	}

	public enum UnionLowBits
	{
		EEClass,
		Invalid,
		MethodTable,
		Indirection
	}

	public uint m_dwFlags;

	public uint m_BaseSize;

	public Flags2 m_wFlags2;

	public ushort m_wToken;

	public ushort m_wNumVirtuals;

	public ushort m_wNumInterfaces;

	private unsafe void* m_pParentMethodTable;

	public unsafe Module* m_pLoaderModule;

	public unsafe MethodTableWriteableData* m_pWriteableData;

	public unsafe void* union_pEEClass_pCanonMT;

	public unsafe void* union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1;

	public unsafe void* union_p_InterfaceMap_pMultipurposeSlot2;

	public const int VTABLE_SLOTS_PER_CHUNK = 8;

	public const int VTABLE_SLOTS_PER_CHUNK_LOG2 = 3;

	private static readonly byte[] c_NonVirtualSlotsOffsets = GetNonVirtualSlotsOffsets();

	public bool IsInterface => (m_dwFlags & 0xF0000) == 786432;

	public bool HasIndirectParent => (m_dwFlags & 0x800000) != 0;

	public bool HasSingleNonVirtualSlot => m_wFlags2.Has(Flags2.HasSingleNonVirtualSlot);

	public unsafe MethodTable* GetCanonicalMethodTable()
	{
		nuint num = (nuint)union_pEEClass_pCanonMT;
		if ((num & 2) == 0)
		{
			return (MethodTable*)num;
		}
		if ((num & 1) != 0)
		{
			return *(MethodTable**)(num - 3);
		}
		return (MethodTable*)(num - 2);
	}

	public unsafe MethodDesc* GetParallelMethodDesc(MethodDesc* pDefMD)
	{
		return GetMethodDescForSlot(pDefMD->SlotNumber);
	}

	public unsafe MethodDesc* GetMethodDescForSlot(uint slotNumber)
	{
		if (IsInterface)
		{
			GetNumVirtuals();
		}
		throw new NotImplementedException();
	}

	public unsafe void* GetRestoredSlot(uint slotNumber)
	{
		MethodTable* ptr = (MethodTable*)Unsafe.AsPointer(ref this);
		void* slot;
		while (true)
		{
			ptr = ptr->GetCanonicalMethodTable();
			slot = ptr->GetSlot(slotNumber);
			if (slot != null)
			{
				break;
			}
			ptr = ptr->GetParentMethodTable();
		}
		return slot;
	}

	public unsafe MethodTable* GetParentMethodTable()
	{
		void* pParentMethodTable = m_pParentMethodTable;
		if (HasIndirectParent)
		{
			return *(MethodTable**)pParentMethodTable;
		}
		return (MethodTable*)pParentMethodTable;
	}

	public unsafe void* GetSlot(uint slotNumber)
	{
		nint slotPtrRaw = GetSlotPtrRaw(slotNumber);
		if (slotNumber < GetNumVirtuals())
		{
			return ((VTableIndir2_t*)slotPtrRaw)->Value;
		}
		if ((m_wFlags2 & Flags2.IsZapped) != 0 && slotNumber >= GetNumVirtuals())
		{
			return ((RelativePointer*)slotPtrRaw)->Value;
		}
		return *(void**)slotPtrRaw;
	}

	public unsafe nint GetSlotPtrRaw(uint slotNum)
	{
		if (slotNum < GetNumVirtuals())
		{
			uint indexOfVtableIndirection = GetIndexOfVtableIndirection(slotNum);
			return (nint)(VTableIndir_t__GetValueMaybeNullAtPtr((nint)(GetVtableIndirections() + indexOfVtableIndirection)) + GetIndexAfterVtableIndirection(slotNum));
		}
		if (HasSingleNonVirtualSlot)
		{
			return GetNonVirtualSlotsPtr();
		}
		return (nint)(GetNonVirtualSlotsArray() + (slotNum - GetNumVirtuals()));
	}

	public ushort GetNumVirtuals()
	{
		return m_wNumVirtuals;
	}

	public static uint GetIndexOfVtableIndirection(uint slotNum)
	{
		return slotNum >> 3;
	}

	public unsafe VTableIndir_t* GetVtableIndirections()
	{
		return (VTableIndir_t*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodTable));
	}

	public unsafe static VTableIndir2_t* VTableIndir_t__GetValueMaybeNullAtPtr(nint @base)
	{
		return (VTableIndir2_t*)@base;
	}

	public static uint GetIndexAfterVtableIndirection(uint slotNum)
	{
		return slotNum & 7;
	}

	[MultipurposeSlotOffsetTable(3, typeof(MultipurposeSlotHelpers))]
	private static byte[] GetNonVirtualSlotsOffsets()
	{
		return new byte[8]
		{
			MultipurposeSlotHelpers.OffsetOfMp1(),
			MultipurposeSlotHelpers.OffsetOfMp2(),
			MultipurposeSlotHelpers.OffsetOfMp1(),
			MultipurposeSlotHelpers.RegularOffset(2),
			MultipurposeSlotHelpers.OffsetOfMp2(),
			MultipurposeSlotHelpers.RegularOffset(2),
			MultipurposeSlotHelpers.RegularOffset(2),
			MultipurposeSlotHelpers.RegularOffset(3)
		};
	}

	public nint GetNonVirtualSlotsPtr()
	{
		return GetMultipurposeSlotPtr(Flags2.HasNonVirtualSlots, c_NonVirtualSlotsOffsets);
	}

	public unsafe nint GetMultipurposeSlotPtr(Flags2 flag, byte[] offsets)
	{
		nint num = offsets[(uint)(m_wFlags2 & (flag - 1))];
		if (num >= sizeof(MethodTable))
		{
			num += (nint)GetNumVTableIndirections() * (nint)sizeof(VTableIndir_t);
		}
		return (nint)((byte*)Unsafe.AsPointer(ref this) + num);
	}

	public unsafe void*** GetNonVirtualSlotsArray()
	{
		return (void***)GetNonVirtualSlotsPtr();
	}

	public uint GetNumVTableIndirections()
	{
		return GetNumVtableIndirections(GetNumVirtuals());
	}

	public static uint GetNumVtableIndirections(uint numVirtuals)
	{
		return numVirtuals + 7 >> 3;
	}
}


using System;

[Flags]
public enum Flags2 : ushort
{
	MultipurposeSlotsMask = 0x1F,
	HasPerInstInfo = 1,
	HasInterfaceMap = 2,
	HasDispatchMapSlot = 4,
	HasNonVirtualSlots = 8,
	HasModuleOverride = 0x10,
	IsZapped = 0x20,
	IsPreRestored = 0x40,
	HasModuleDependencies = 0x80,
	IsIntrinsicType = 0x100,
	RequiresDispatchTokenFat = 0x200,
	HasCctor = 0x400,
	HasVirtualStaticMethods = 0x800,
	REquiresAlign8 = 0x1000,
	HasBoxedRegularStatics = 0x2000,
	HasSingleNonVirtualSlot = 0x4000,
	DependsOnEquivalentOrForwardedStructs = 0x8000
}


public enum UnionLowBits
{
	EEClass,
	Invalid,
	MethodTable,
	Indirection
}


using System;

public readonly struct InvokeAllocMemPtr
{
	private readonly IntPtr methodPtr;

	public unsafe delegate*<IntPtr, IntPtr, V70.AllocMemArgs*, void> InvokeAllocMem => (delegate*<IntPtr, IntPtr, V70.AllocMemArgs*, void>)(void*)methodPtr;

	public unsafe InvokeAllocMemPtr(delegate*<IntPtr, IntPtr, V70.AllocMemArgs*, void> ptr)
	{
		methodPtr = (IntPtr)ptr;
	}
}


using System;
using System.Runtime.InteropServices;

public class V70 : V60
{
	public static class ICorJitInfoVtable
	{
		public const int AllocMemIndex = 159;

		public const int TotalVtableCount = 175;
	}

	public struct AllocMemArgs
	{
		public uint hotCodeSize;

		public uint coldCodeSize;

		public uint roDataSize;

		public uint xcptnsCount;

		public int flag;

		public IntPtr hotCodeBlock;

		public IntPtr hotCodeBlockRW;

		public IntPtr coldCodeBlock;

		public IntPtr coldCodeBlockRW;

		public IntPtr roDataBlock;

		public IntPtr roDataBlockRW;
	}

	[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
	public unsafe delegate void AllocMemDelegate(IntPtr thisPtr, AllocMemArgs* args);

	public unsafe static InvokeAllocMemPtr InvokeAllocMemPtr => new InvokeAllocMemPtr((delegate*<IntPtr, IntPtr, AllocMemArgs*, void>)(&InvokeAllocMem));

	public unsafe static void InvokeAllocMem(IntPtr functionPtr, IntPtr thisPtr, AllocMemArgs* args)
	{
		if (functionPtr == IntPtr.Zero)
		{
			return;
		}
		delegate* unmanaged[Thiscall]<IntPtr, AllocMemArgs*, void> delegate* = (delegate* unmanaged[Thiscall]<IntPtr, AllocMemArgs*, void>)(void*)functionPtr;
		delegate* unmanaged[Thiscall]<IntPtr, AllocMemArgs*, void> delegate*2 = delegate*;
		/*Error near IL_001a: Handle with invalid row number.*/;
	}
}


public static class ICorJitInfoVtable
{
	public const int AllocMemIndex = 159;

	public const int TotalVtableCount = 175;
}


using System;

public struct AllocMemArgs
{
	public uint hotCodeSize;

	public uint coldCodeSize;

	public uint roDataSize;

	public uint xcptnsCount;

	public int flag;

	public IntPtr hotCodeBlock;

	public IntPtr hotCodeBlockRW;

	public IntPtr coldCodeBlock;

	public IntPtr coldCodeBlockRW;

	public IntPtr roDataBlock;

	public IntPtr roDataBlockRW;
}


using System;
using System.Runtime.InteropServices;

[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
public unsafe delegate void AllocMemDelegate(IntPtr thisPtr, AllocMemArgs* args);


public class V80 : V70
{
	public static class ICorJitInfoVtableV80
	{
		public const int AllocMemIndex = 154;

		public const int TotalVtableCount = 170;
	}
}


public static class ICorJitInfoVtableV80
{
	public const int AllocMemIndex = 154;

	public const int TotalVtableCount = 170;
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Interop;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

internal static class Fx
{
	public static class V48
	{
		public enum MethodClassification
		{
			IL,
			FCall,
			NDirect,
			EEImpl,
			Array,
			Instantiated,
			ComInterop,
			Dynamic
		}

		public enum MethodDescClassification : ushort
		{
			ClassificationMask = 7,
			HasNonVtableSlot = 8,
			MethodImpl = 16,
			Static = 32,
			Intercepted = 64,
			RequiresLinktimeCheck = 128,
			RequiresInheritanceCheck = 256,
			ParentRequiresInheritanceCheck = 512,
			Duplicate = 1024,
			VerifiedState = 2048,
			Verifiable = 4096,
			NotInline = 8192,
			Synchronized = 16384,
			RequiresFullSlotNumber = 32768
		}

		public struct MethodImpl
		{
			public unsafe uint* pdwSlots;

			public unsafe MethodDesc* pImplementedMD;
		}

		public struct MethodDesc
		{
			[Flags]
			public enum Flags3 : ushort
			{
				TokenRemainderMask = 0x3FFF,
				HasForwardedValuetypeParameter = 0x4000,
				ValueTypeParametersWalked = 0x4000,
				DoesNotHaveEquivalentValuetypeParameters = 0x8000
			}

			[Flags]
			public enum Flags2 : byte
			{
				HasStableEntryPoint = 1,
				HasPrecode = 2,
				IsUnboxingStub = 4,
				HasNativeCodeSlot = 8,
				TransparencyMask = 0x30,
				TransparencyUnknown = 0,
				TransparencyTransparent = 0x10,
				TransparencyCritical = 0x20,
				TransparencyTreatAsSafe = 0x30,
				CASDemandsOnly = 0x40,
				HostProtectionLinkChecksOnly = 0x80
			}

			public static readonly nuint Alignment = (nuint)((IntPtr.Size == 8) ? 8 : 4);

			public Flags3 m_wFlags3AndTokenRemainder;

			public byte m_chunkIndex;

			public Flags2 m_bFlags2;

			public const ushort PackedSlot_SlotMask = 1023;

			public const ushort PackedSlot_NameHashMask = 64512;

			public ushort m_wSlotNumber;

			public MethodDescClassification m_wFlags;

			private unsafe static readonly nuint[] s_ClassificationSizeTable = new UIntPtr[8]
			{
				(nuint)sizeof(MethodDesc),
				(nuint)FCallMethodDescPtr.CurrentSize,
				(nuint)NDirectMethodDescPtr.CurrentSize,
				(nuint)EEImplMethodDescPtr.CurrentSize,
				(nuint)ArrayMethodDescPtr.CurrentSize,
				(nuint)sizeof(InstantiatedMethodDesc),
				(nuint)sizeof(ComPlusCallMethodDesc),
				(nuint)DynamicMethodDescPtr.CurrentSize
			};

			public ushort SlotNumber
			{
				get
				{
					if (!m_wFlags.Has(MethodDescClassification.RequiresFullSlotNumber))
					{
						return (ushort)(m_wSlotNumber & 0x3FF);
					}
					return m_wSlotNumber;
				}
			}

			public MethodClassification Classification => (MethodClassification)(m_wFlags & MethodDescClassification.ClassificationMask);

			public unsafe MethodDescChunk* MethodDescChunk => (MethodDescChunk*)Unsafe.AsPointer(ref Unsafe.SubtractByteOffset(ref this, (nuint)sizeof(MethodDescChunk) + m_chunkIndex * Alignment));

			public unsafe MethodTable* MethodTable => MethodDescChunk->MethodTable;

			public bool HasNonVtableSlot => m_wFlags.Has(MethodDescClassification.HasNonVtableSlot);

			public bool HasStableEntryPoint => m_bFlags2.Has(Flags2.HasStableEntryPoint);

			public bool HasPrecode => m_bFlags2.Has(Flags2.HasPrecode);

			public bool HasNativeCodeSlot => m_bFlags2.Has(Flags2.HasNativeCodeSlot);

			public bool IsUnboxingStub => m_bFlags2.Has(Flags2.IsUnboxingStub);

			public unsafe bool HasMethodInstantiation
			{
				get
				{
					if (TryAsInstantiated(out var md))
					{
						return md->IMD_HasMethodInstantiation;
					}
					return false;
				}
			}

			public unsafe bool IsGenericMethodDefinition
			{
				get
				{
					if (TryAsInstantiated(out var md))
					{
						return md->IMD_IsGenericMethodDefinition;
					}
					return false;
				}
			}

			public unsafe bool IsInstantiatingStub
			{
				get
				{
					if (!IsUnboxingStub && TryAsInstantiated(out var md))
					{
						return md->IMD_IsWrapperStubWithInstantiations;
					}
					return false;
				}
			}

			public unsafe bool IsGenericComPlusCall
			{
				get
				{
					if (TryAsInstantiated(out var md))
					{
						return md->IMD_HasComPlusCallInfo;
					}
					return false;
				}
			}

			public bool IsWrapperStub
			{
				get
				{
					if (!IsUnboxingStub)
					{
						return IsInstantiatingStub;
					}
					return true;
				}
			}

			public bool IsTightlyBoundToMethodTable
			{
				get
				{
					if (!HasNonVtableSlot)
					{
						return true;
					}
					if (HasMethodInstantiation)
					{
						return IsGenericMethodDefinition;
					}
					if (IsWrapperStub)
					{
						return false;
					}
					return true;
				}
			}

			public unsafe void* GetMethodEntryPoint()
			{
				if (HasNonVtableSlot)
				{
					nuint baseSize = GetBaseSize();
					return *(void**)((byte*)Unsafe.AsPointer(ref this) + baseSize);
				}
				return MethodTable->GetSlot(SlotNumber);
			}

			public unsafe bool TryAsInstantiated(out InstantiatedMethodDesc* md)
			{
				if (Classification == MethodClassification.Instantiated)
				{
					md = (InstantiatedMethodDesc*)Unsafe.AsPointer(ref this);
					return true;
				}
				md = default(InstantiatedMethodDesc*);
				return false;
			}

			public unsafe nuint SizeOf(bool includeNonVtable = true, bool includeMethodImpl = true, bool includeComPlus = true, bool includeNativeCode = true)
			{
				nuint num = (nuint)((nint)GetBaseSize() + (nint)((includeNonVtable && m_wFlags.Has(MethodDescClassification.HasNonVtableSlot)) ? sizeof(void*) : 0) + ((includeMethodImpl && m_wFlags.Has(MethodDescClassification.MethodImpl)) ? sizeof(MethodImpl) : 0));
				if (includeNativeCode && HasNativeCodeSlot)
				{
					num += (uint)((((nint)(nuint)Unsafe.As<MethodDesc, UIntPtr>(ref Unsafe.AddByteOffset(ref this, num)) & 1) != 0) ? (sizeof(void*) + sizeof(void*)) : sizeof(void*));
				}
				if (includeComPlus && IsGenericComPlusCall)
				{
					num += (uint)ComPlusCallInfoPtr.CurrentSize;
				}
				return num;
			}

			public unsafe void* GetNativeCode()
			{
				if (HasNativeCodeSlot)
				{
					nuint num = (nuint)((RelativePointer*)GetAddrOfNativeCodeSlot())->Value & (nuint)(~(nint)1);
					if (num != 0)
					{
						return (void*)num;
					}
				}
				if (!HasStableEntryPoint || HasPrecode)
				{
					return null;
				}
				return GetStableEntryPoint();
			}

			public unsafe void* GetStableEntryPoint()
			{
				return GetMethodEntryPoint();
			}

			public unsafe static MethodDesc* FindTightlyBoundWrappedMethodDesc(MethodDesc* pMD)
			{
				if (pMD->IsUnboxingStub && pMD->TryAsInstantiated(out var md))
				{
					pMD = md->IMD_GetWrappedMethodDesc();
				}
				if (!pMD->IsTightlyBoundToMethodTable)
				{
					pMD = pMD->GetCanonicalMethodTable()->GetParallelMethodDesc(pMD);
				}
				if (pMD->IsUnboxingStub)
				{
					pMD = GetNextIntroducedMethod(pMD);
				}
				return pMD;
			}

			public unsafe static MethodDesc* GetNextIntroducedMethod(MethodDesc* pMD)
			{
				MethodDescChunk* methodDescChunk = pMD->MethodDescChunk;
				nuint num = (nuint)((byte*)pMD + pMD->SizeOf());
				nuint num2 = (nuint)((byte*)methodDescChunk + methodDescChunk->SizeOf);
				if (num < num2)
				{
					return (MethodDesc*)num;
				}
				methodDescChunk = methodDescChunk->m_next;
				if (methodDescChunk != null)
				{
					return methodDescChunk->FirstMethodDesc;
				}
				return null;
			}

			public unsafe MethodTable* GetCanonicalMethodTable()
			{
				return MethodTable->GetCanonicalMethodTable();
			}

			public unsafe void* GetAddrOfNativeCodeSlot()
			{
				nuint byteOffset = SizeOf(includeNonVtable: true, includeMethodImpl: true, includeComPlus: false, includeNativeCode: false);
				return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, byteOffset));
			}

			public nuint GetBaseSize()
			{
				return GetBaseSize(Classification);
			}

			public static nuint GetBaseSize(MethodClassification classification)
			{
				return s_ClassificationSizeTable[(int)classification];
			}
		}

		[FatInterface]
		public struct StoredSigMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? StoredSigMethodDesc_64.FatVtable_ : StoredSigMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(StoredSigMethodDesc_64) : sizeof(StoredSigMethodDesc_32);

			public unsafe void* m_pSig
			{
				[FatInterfaceIgnore]
				get
				{
					return GetPSig();
				}
			}

			public uint m_cSig
			{
				[FatInterfaceIgnore]
				get
				{
					return GetCSig();
				}
			}

			private unsafe void* GetPSig()
			{
				return ((delegate*<void*, void*>)(void*)vtbl_[0])(ptr_);
			}

			private unsafe uint GetCSig()
			{
				return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
			}

			public unsafe StoredSigMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
		public struct StoredSigMethodDesc_64
		{
			public MethodDesc @base;

			public unsafe void* m_pSig;

			public uint m_cSig;

			public uint m_dwExtendedFlags;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[2]
						{
							(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
							(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
						};
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetCSig_1(void* ptr__)
					{
						return ((StoredSigMethodDesc_64*)ptr__)->GetCSig();
					}
					unsafe static void* S_GetPSig_0(void* ptr__)
					{
						return ((StoredSigMethodDesc_64*)ptr__)->GetPSig();
					}
				}
			}

			private unsafe void* GetPSig()
			{
				return m_pSig;
			}

			private uint GetCSig()
			{
				return m_cSig;
			}
		}

		[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
		public struct StoredSigMethodDesc_32
		{
			public MethodDesc @base;

			public unsafe void* m_pSig;

			public uint m_cSig;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[2]
						{
							(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
							(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
						};
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetCSig_1(void* ptr__)
					{
						return ((StoredSigMethodDesc_32*)ptr__)->GetCSig();
					}
					unsafe static void* S_GetPSig_0(void* ptr__)
					{
						return ((StoredSigMethodDesc_32*)ptr__)->GetPSig();
					}
				}
			}

			private unsafe void* GetPSig()
			{
				return m_pSig;
			}

			private uint GetCSig()
			{
				return m_cSig;
			}
		}

		[FatInterface]
		public struct FCallMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? FCallMethodDesc_64.FatVtable_ : FCallMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(FCallMethodDesc_64) : sizeof(FCallMethodDesc_32);

			public uint m_dwECallID
			{
				[FatInterfaceIgnore]
				get
				{
					return GetECallID();
				}
			}

			private unsafe uint GetECallID()
			{
				return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
			}

			public unsafe FCallMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
		public struct FCallMethodDesc_64
		{
			public MethodDesc @base;

			public uint m_dwECallID;

			public uint m_padding;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetECallID_0(void* ptr__)
					{
						return ((FCallMethodDesc_64*)ptr__)->GetECallID();
					}
				}
			}

			private uint GetECallID()
			{
				return m_dwECallID;
			}
		}

		[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
		public struct FCallMethodDesc_32
		{
			public MethodDesc @base;

			public uint m_dwECallID;

			private static IntPtr[]? fatVtable_;

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static uint S_GetECallID_0(void* ptr__)
					{
						return ((FCallMethodDesc_32*)ptr__)->GetECallID();
					}
				}
			}

			private uint GetECallID()
			{
				return m_dwECallID;
			}
		}

		public struct DynamicResolver
		{
		}

		[Flags]
		public enum DynamicMethodDesc_ExtendedFlags : uint
		{
			Attrs = 0xFFFFu,
			ILStubAttrs = 0x17u,
			MemberAccessMask = 7u,
			ReverseStub = 8u,
			Static = 0x10u,
			CALLIStub = 0x20u,
			DelegateStub = 0x40u,
			CopyCtorArgs = 0x80u,
			Unbreakable = 0x100u,
			DelegateCOMStub = 0x200u,
			SignatureNeedsResture = 0x400u,
			StubNeedsCOMStarted = 0x800u,
			MulticastStub = 0x1000u,
			UnboxingILStub = 0x2000u,
			ILStub = 0x10000u,
			LCGMethod = 0x20000u,
			StackArgSize = 0xFFFC0000u
		}

		[FatInterface]
		public struct DynamicMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? DynamicMethodDesc_64.FatVtable_ : DynamicMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(DynamicMethodDesc_64) : sizeof(DynamicMethodDesc_32);

			public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

			private unsafe DynamicMethodDesc_ExtendedFlags GetFlags()
			{
				return ((delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(void*)vtbl_[0])(ptr_);
			}

			public unsafe DynamicMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
		public struct DynamicMethodDesc_64
		{
			public StoredSigMethodDesc_64 @base;

			public unsafe byte* m_pszMethodName;

			public unsafe DynamicResolver* m_pResolver;

			private static IntPtr[]? fatVtable_;

			public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
					{
						return ((DynamicMethodDesc_64*)ptr__)->GetFlags();
					}
				}
			}

			private DynamicMethodDesc_ExtendedFlags GetFlags()
			{
				return (DynamicMethodDesc_ExtendedFlags)@base.m_dwExtendedFlags;
			}
		}

		[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
		public struct DynamicMethodDesc_32
		{
			public StoredSigMethodDesc_32 @base;

			public unsafe byte* m_pszMethodName;

			public unsafe DynamicResolver* m_pResolver;

			public uint m_dwExtendedFlags;

			private static IntPtr[]? fatVtable_;

			public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

			public unsafe static IntPtr[] FatVtable_
			{
				get
				{
					object obj = fatVtable_;
					if (obj == null)
					{
						obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
						fatVtable_ = (IntPtr[]?)obj;
					}
					return (IntPtr[])obj;
					unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
					{
						return ((DynamicMethodDesc_32*)ptr__)->GetFlags();
					}
				}
			}

			private DynamicMethodDesc_ExtendedFlags GetFlags()
			{
				return (DynamicMethodDesc_ExtendedFlags)m_dwExtendedFlags;
			}
		}

		[FatInterface]
		public struct ArrayMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? ArrayMethodDesc_64.FatVtable_ : ArrayMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(ArrayMethodDesc_64) : sizeof(ArrayMethodDesc_32);

			public unsafe ArrayMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		public enum ArrayFunc
		{
			Get,
			Set,
			Address,
			Ctor
		}

		[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
		public struct ArrayMethodDesc_64
		{
			public StoredSigMethodDesc_64 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
		public struct ArrayMethodDesc_32
		{
			public StoredSigMethodDesc_32 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		public struct NDirectWriteableData
		{
		}

		[Flags]
		public enum NDirectMethodDesc_Flags : ushort
		{
			EarlyBound = 1,
			HasSuppressUnmanagedCodeAccess = 2,
			DefaultDllImportSearchPathIsCached = 4,
			IsMarshalingRequiredCached = 0x10,
			CachedMarshalingRequired = 0x20,
			NativeAnsi = 0x40,
			LastError = 0x80,
			NativeNoMangle = 0x100,
			VarArgs = 0x200,
			StdCall = 0x400,
			ThisCall = 0x800,
			IsQCall = 0x1000,
			DefaultDllImportSearchPathsStatus = 0x2000,
			NDirectPopulated = 0x8000
		}

		[FatInterface]
		public struct NDirectMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? NDirectMethodDesc_x86.FatVtable_ : NDirectMethodDesc_other.FatVtable_;

			public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(NDirectMethodDesc_x86) : sizeof(NDirectMethodDesc_other);

			public unsafe NDirectMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
		public struct NDirectMethodDesc_other
		{
			public struct NDirect
			{
				public unsafe void* m_pNativeNDirectTarget;

				public unsafe byte* m_pszEntrypointName;

				public nuint union_pszLibName_dwECallID;

				public unsafe NDirectWriteableData* m_pWriteableData;

				public unsafe void* m_pImportThunkGlue;

				public uint m_DefaultDllImportSearchPathsAttributeValue;

				public NDirectMethodDesc_Flags m_wFlags;

				public unsafe MethodDesc* m_pStubMD;
			}

			public MethodDesc @base;

			private NDirect ndirect;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
		public struct NDirectMethodDesc_x86
		{
			public struct NDirect
			{
				public unsafe void* m_pNativeNDirectTarget;

				public unsafe byte* m_pszEntrypointName;

				public nuint union_pszLibName_dwECallID;

				public unsafe NDirectWriteableData* m_pWriteableData;

				public unsafe void* m_pImportThunkGlue;

				public uint m_DefaultDllImportSearchPathsAttributeValue;

				public NDirectMethodDesc_Flags m_wFlags;

				public ushort m_cbStackArgumentSize;

				public unsafe MethodDesc* m_pStubMD;
			}

			public MethodDesc @base;

			private NDirect ndirect;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterface]
		public struct EEImplMethodDescPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? EEImplMethodDesc_64.FatVtable_ : EEImplMethodDesc_32.FatVtable_;

			public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(EEImplMethodDesc_64) : sizeof(EEImplMethodDesc_32);

			public unsafe EEImplMethodDescPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
		public struct EEImplMethodDesc_64
		{
			public StoredSigMethodDesc_64 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
		public struct EEImplMethodDesc_32
		{
			public StoredSigMethodDesc_32 @base;

			private static IntPtr[]? fatVtable_;

			public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
		}

		[FatInterface]
		public struct ComPlusCallInfoPtr
		{
			private unsafe readonly void* ptr_;

			private readonly IntPtr[] vtbl_;

			public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(ComPlusCallInfo_x86) : sizeof(ComPlusCallInfo_other);

			public unsafe ComPlusCallInfoPtr(void* ptr, IntPtr[] vtbl)
			{
				ptr_ = ptr;
				vtbl_ = vtbl;
			}
		}

		public struct ComPlusCallInfo_x86
		{
			public unsafe void* union_m_pILStub_pEventProviderMD;

			public unsafe MethodTable* m_pInterfaceMT;

			public byte m_flags;

			public ushort m_cachedComSlot;

			public ushort m_cbStackArgumentSize;

			public unsafe void* union_m_pRetThunk_pInterceptStub;

			private RelativePointer m_pStubMD;
		}

		public struct ComPlusCallInfo_other
		{
			public unsafe void* union_m_pILStub_pEventProviderMD;

			public unsafe MethodTable* m_pInterfaceMT;

			public byte m_flags;

			public ushort m_cachedComSlot;

			private RelativePointer m_pStubMD;
		}

		public struct ComPlusCallMethodDesc
		{
			public MethodDesc @base;

			public unsafe void* m_pComPlusCallInfo;
		}

		public struct InstantiatedMethodDesc
		{
			[Flags]
			public enum Flags : ushort
			{
				KindMask = 7,
				GenericMethodDefinition = 0,
				UnsharedMethodInstantiation = 1,
				SharedMethodInstantiation = 2,
				WrapperStubWithInstantiations = 3,
				EnCAddedMethod = 7,
				Unrestored = 8,
				HasComPlusCallInfo = 0x10
			}

			public MethodDesc @base;

			public unsafe void* union_pDictLayout_pWrappedMethodDesc;

			public unsafe Dictionary* m_pPerInstInfo;

			public Flags m_wFlags2;

			public ushort m_wNumGenericArgs;

			public unsafe bool IMD_HasMethodInstantiation
			{
				get
				{
					if (!IMD_IsGenericMethodDefinition)
					{
						return m_pPerInstInfo != null;
					}
					return true;
				}
			}

			public bool IMD_IsGenericMethodDefinition => (m_wFlags2 & Flags.KindMask) == 0;

			public bool IMD_IsWrapperStubWithInstantiations => (m_wFlags2 & Flags.KindMask) == Flags.WrapperStubWithInstantiations;

			public bool IMD_HasComPlusCallInfo => m_wFlags2.Has(Flags.HasComPlusCallInfo);

			public unsafe MethodDesc* IMD_GetWrappedMethodDesc()
			{
				Helpers.Assert(IMD_IsWrapperStubWithInstantiations, null, "IMD_IsWrapperStubWithInstantiations");
				return (MethodDesc*)union_pDictLayout_pWrappedMethodDesc;
			}
		}

		public struct RelativeFixupPointer
		{
			private readonly nint value;

			public unsafe void* Value
			{
				get
				{
					nint num = value;
					if (num == 0)
					{
						return null;
					}
					nint num2 = (nint)((byte*)Unsafe.AsPointer(ref this) + num);
					if ((num2 & 1) != 0)
					{
						num2 = *(nint*)(num2 - 1);
					}
					return (void*)num2;
				}
			}
		}

		public struct MethodDescChunk
		{
			[Flags]
			public enum Flags : ushort
			{
				TokenRangeMask = 0x3FF,
				HasCompactEntrypoints = 0x4000,
				IsZapped = 0x8000
			}

			public RelativeFixupPointer m_methodTable;

			public unsafe MethodDescChunk* m_next;

			public byte m_size;

			public byte m_count;

			public Flags m_flagsAndTokenRange;

			public unsafe MethodTable* MethodTable => (MethodTable*)m_methodTable.Value;

			public unsafe MethodDesc* FirstMethodDesc => (MethodDesc*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodDescChunk));

			public uint Size => (uint)(m_size + 1);

			public uint Count => (uint)(m_count + 1);

			public unsafe nuint SizeOf => (nuint)sizeof(MethodDescChunk) + Size * MethodDesc.Alignment;
		}

		public struct Dictionary
		{
		}

		public struct Module
		{
		}

		public struct MethodTableWriteableData
		{
		}

		public struct RelativePointer
		{
			private nint m_delta;

			public unsafe void* Value
			{
				get
				{
					nint delta = m_delta;
					if (delta != 0)
					{
						return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
					}
					return null;
				}
			}

			public RelativePointer(nint delta)
			{
				m_delta = delta;
			}
		}

		public struct MethodTable
		{
			[Flags]
			public enum WFlagsLow : uint
			{
				UNUSED_ComponentSize_1 = 1u,
				StaticsMask = 6u,
				StaticsMask_NonDynamic = 0u,
				StaticsMask_Dynamic = 2u,
				StaticsMask_Generics = 4u,
				StaticsMask_CrossModuleGenerics = 6u,
				StaticsMask_IfGenericsThenCrossModule = 2u,
				NotInPZM = 8u,
				GenericsMask = 0x30u,
				GenericsMask_NonGeneric = 0u,
				GenericsMask_GenericInst = 0x10u,
				GenericsMask_SharedInst = 0x20u,
				GenericsMask_TypicalInst = 0x30u,
				ContextStatic = 0x40u,
				HasRemotingVtsInfo = 0x80u,
				HasVariance = 0x100u,
				HasDefaultCtor = 0x200u,
				HasPreciseInitCctors = 0x400u,
				IsHFA_IsRegStructPassed = 0x800u,
				IsByRefLike = 0x1000u,
				UNUSED_ComponentSize_5 = 0x2000u,
				UNUSED_ComponentSize_6 = 0x4000u,
				UNUSED_ComponentSize_7 = 0x8000u,
				StringArrayValues = 0u
			}

			[Flags]
			public enum WFlagsHigh : uint
			{
				Category_Mask = 0xF0000u,
				Category_Class = 0u,
				Category_Unused_1 = 0x10000u,
				Category_MarshalByRef_Mask = 0xE0000u,
				Category_MarshalByRef = 0x20000u,
				Category_Contextful = 0x30000u,
				Category_ValueType = 0x40000u,
				Category_ValueType_Mask = 0xC0000u,
				Category_Nullable = 0x50000u,
				Category_PrimitiveValueType = 0x60000u,
				Category_TruePrimitive = 0x70000u,
				Category_Array = 0x80000u,
				Category_Array_Mask = 0xC0000u,
				Category_IfArrayThenSzArray = 0x20000u,
				Category_Interface = 0xC0000u,
				Category_Unused_2 = 0xD0000u,
				Category_TransparentProxy = 0xE0000u,
				Category_AsyncPin = 0xF0000u,
				Category_ElementTypeMask = 0xE0000u,
				HasFinalizer = 0x100000u,
				IfNotInterfaceThenMarshalable = 0x200000u,
				IfInterfaceThenHasGuidInfo = 0x200000u,
				ICastable = 0x400000u,
				HasIndirectParent = 0x800000u,
				ContainsPointers = 0x1000000u,
				HasTypeEquivalence = 0x2000000u,
				HasRCWPerTypeData = 0x4000000u,
				HasCriticalFinalizer = 0x8000000u,
				Collectible = 0x10000000u,
				ContainsGenericVariables = 0x20000000u,
				ComObject = 0x40000000u,
				HasComponentSize = 0x80000000u,
				NonTrivialInterfaceCast = 0x40480000u
			}

			[Flags]
			public enum Flags2 : ushort
			{
				MultipurposeSlotsMask = 0x1F,
				HasPerInstInfo = 1,
				HasInterfaceMap = 2,
				HasDispatchMapSlot = 4,
				HasNonVirtualSlots = 8,
				HasModuleOverride = 0x10,
				IsZapped = 0x20,
				IsPreRestored = 0x40,
				HasModuleDependencies = 0x80,
				NoSecurityProperties = 0x100,
				RequiresDispatchTokenFat = 0x200,
				HasCctor = 0x400,
				HasCCWTemplate = 0x800,
				RequiresAlign8 = 0x1000,
				HasBoxedRegularStatics = 0x2000,
				HasSingleNonVirtualSlot = 0x4000,
				DependsOnEquivalentOrForwardedStructs = 0x8000
			}

			public enum UnionLowBits
			{
				EEClass,
				Invalid,
				MethodTable,
				Indirection
			}

			private static class MultipurposeSlotHelpers
			{
				public unsafe static byte OffsetOfMp1()
				{
					MethodTable methodTable = default(MethodTable);
					return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
				}

				public unsafe static byte OffsetOfMp2()
				{
					MethodTable methodTable = default(MethodTable);
					return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
				}

				public unsafe static byte RegularOffset(int index)
				{
					return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
				}
			}

			private uint m_dwFlags;

			public uint m_BaseSize;

			public Flags2 m_wFlags2;

			public ushort m_wToken;

			public ushort m_wNumVirtuals;

			public ushort m_wNumInterfaces;

			private unsafe void* m_pParentMethodTable;

			public unsafe Module* m_pLoaderModule;

			public unsafe MethodTableWriteableData* m_pWriteableData;

			public unsafe void* union_pEEClass_pCanonMT;

			public unsafe void* union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1;

			public unsafe void* union_p_InterfaceMap_pMultipurposeSlot2;

			public const int VTABLE_SLOTS_PER_CHUNK = 8;

			public const int VTABLE_SLOTS_PER_CHUNK_LOG2 = 3;

			private static readonly byte[] c_NonVirtualSlotsOffsets = GetNonVirtualSlotsOffsets();

			public WFlagsHigh FlagsHigh => (WFlagsHigh)(m_dwFlags & 0xFFFF0000u);

			public WFlagsLow FlagsLow
			{
				get
				{
					if (!FlagsHigh.Has(WFlagsHigh.HasComponentSize))
					{
						return (WFlagsLow)(m_dwFlags & 0xFFFF);
					}
					return WFlagsLow.StaticsMask_NonDynamic;
				}
			}

			public int ComponentSize
			{
				get
				{
					if (!FlagsHigh.Has(WFlagsHigh.HasComponentSize))
					{
						return 0;
					}
					return (int)(m_dwFlags & 0xFFFF);
				}
			}

			public bool IsInterface => (m_dwFlags & 0xF0000) == 786432;

			public bool HasIndirectParent => FlagsHigh.Has(WFlagsHigh.HasIndirectParent);

			public unsafe MethodTable* ParentMethodTable
			{
				get
				{
					void* pParentMethodTable = m_pParentMethodTable;
					if (HasIndirectParent)
					{
						return (MethodTable*)((MethodTable*)pParentMethodTable)->m_pParentMethodTable;
					}
					return (MethodTable*)pParentMethodTable;
				}
			}

			public bool HasSingleNonVirtualSlot => m_wFlags2.Has(Flags2.HasSingleNonVirtualSlot);

			public unsafe MethodTable* GetCanonicalMethodTable()
			{
				nuint num = (nuint)union_pEEClass_pCanonMT;
				if ((num & 2) == 0)
				{
					return (MethodTable*)num;
				}
				if ((num & 1) != 0)
				{
					return *(MethodTable**)(num - 3);
				}
				return (MethodTable*)(num - 2);
			}

			public unsafe MethodDesc* GetParallelMethodDesc(MethodDesc* pDefMD)
			{
				return GetMethodDescForSlot(pDefMD->SlotNumber);
			}

			public unsafe MethodDesc* GetMethodDescForSlot(uint slotNumber)
			{
				if (IsInterface)
				{
					GetNumVirtuals();
				}
				throw new NotImplementedException();
			}

			public unsafe void* GetRestoredSlot(uint slotNumber)
			{
				MethodTable* ptr = (MethodTable*)Unsafe.AsPointer(ref this);
				void* slot;
				while (true)
				{
					ptr = ptr->GetCanonicalMethodTable();
					slot = ptr->GetSlot(slotNumber);
					if (slot != null)
					{
						break;
					}
					ptr = ptr->ParentMethodTable;
				}
				return slot;
			}

			public unsafe void* GetSlot(uint slotNumber)
			{
				return *(void**)GetSlotPtrRaw(slotNumber);
			}

			public unsafe nint GetSlotPtrRaw(uint slotNum)
			{
				if (slotNum < GetNumVirtuals())
				{
					uint indexOfVtableIndirection = GetIndexOfVtableIndirection(slotNum);
					void** ptr = (void**)GetVtableIndirections()[indexOfVtableIndirection];
					return (nint)(ptr + GetIndexAfterVtableIndirection(slotNum));
				}
				if (HasSingleNonVirtualSlot)
				{
					return GetNonVirtualSlotsPtr();
				}
				return (nint)(GetNonVirtualSlotsArray() + (slotNum - GetNumVirtuals()));
			}

			public ushort GetNumVirtuals()
			{
				return m_wNumVirtuals;
			}

			public static uint GetIndexOfVtableIndirection(uint slotNum)
			{
				return slotNum >> 3;
			}

			public unsafe void** GetVtableIndirections()
			{
				return (void**)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodTable));
			}

			public static uint GetIndexAfterVtableIndirection(uint slotNum)
			{
				return slotNum & 7;
			}

			[MultipurposeSlotOffsetTable(3, typeof(MultipurposeSlotHelpers))]
			private static byte[] GetNonVirtualSlotsOffsets()
			{
				return new byte[8]
				{
					MultipurposeSlotHelpers.OffsetOfMp1(),
					MultipurposeSlotHelpers.OffsetOfMp2(),
					MultipurposeSlotHelpers.OffsetOfMp1(),
					MultipurposeSlotHelpers.RegularOffset(2),
					MultipurposeSlotHelpers.OffsetOfMp2(),
					MultipurposeSlotHelpers.RegularOffset(2),
					MultipurposeSlotHelpers.RegularOffset(2),
					MultipurposeSlotHelpers.RegularOffset(3)
				};
			}

			public nint GetNonVirtualSlotsPtr()
			{
				return GetMultipurposeSlotPtr(Flags2.HasNonVirtualSlots, c_NonVirtualSlotsOffsets);
			}

			public unsafe nint GetMultipurposeSlotPtr(Flags2 flag, byte[] offsets)
			{
				nint num = offsets[(uint)(m_wFlags2 & (flag - 1))];
				if (num >= sizeof(MethodTable))
				{
					num += (nint)GetNumVTableIndirections() * (nint)sizeof(void**);
				}
				return (nint)((byte*)Unsafe.AsPointer(ref this) + num);
			}

			public unsafe void** GetNonVirtualSlotsArray()
			{
				return (void**)((RelativePointer*)GetNonVirtualSlotsPtr())->Value;
			}

			public uint GetNumVTableIndirections()
			{
				return GetNumVtableIndirections(GetNumVirtuals());
			}

			public static uint GetNumVtableIndirections(uint numVirtuals)
			{
				return numVirtuals + 7 >> 3;
			}
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

public static class V48
{
	public enum MethodClassification
	{
		IL,
		FCall,
		NDirect,
		EEImpl,
		Array,
		Instantiated,
		ComInterop,
		Dynamic
	}

	public enum MethodDescClassification : ushort
	{
		ClassificationMask = 7,
		HasNonVtableSlot = 8,
		MethodImpl = 16,
		Static = 32,
		Intercepted = 64,
		RequiresLinktimeCheck = 128,
		RequiresInheritanceCheck = 256,
		ParentRequiresInheritanceCheck = 512,
		Duplicate = 1024,
		VerifiedState = 2048,
		Verifiable = 4096,
		NotInline = 8192,
		Synchronized = 16384,
		RequiresFullSlotNumber = 32768
	}

	public struct MethodImpl
	{
		public unsafe uint* pdwSlots;

		public unsafe MethodDesc* pImplementedMD;
	}

	public struct MethodDesc
	{
		[Flags]
		public enum Flags3 : ushort
		{
			TokenRemainderMask = 0x3FFF,
			HasForwardedValuetypeParameter = 0x4000,
			ValueTypeParametersWalked = 0x4000,
			DoesNotHaveEquivalentValuetypeParameters = 0x8000
		}

		[Flags]
		public enum Flags2 : byte
		{
			HasStableEntryPoint = 1,
			HasPrecode = 2,
			IsUnboxingStub = 4,
			HasNativeCodeSlot = 8,
			TransparencyMask = 0x30,
			TransparencyUnknown = 0,
			TransparencyTransparent = 0x10,
			TransparencyCritical = 0x20,
			TransparencyTreatAsSafe = 0x30,
			CASDemandsOnly = 0x40,
			HostProtectionLinkChecksOnly = 0x80
		}

		public static readonly nuint Alignment = (nuint)((IntPtr.Size == 8) ? 8 : 4);

		public Flags3 m_wFlags3AndTokenRemainder;

		public byte m_chunkIndex;

		public Flags2 m_bFlags2;

		public const ushort PackedSlot_SlotMask = 1023;

		public const ushort PackedSlot_NameHashMask = 64512;

		public ushort m_wSlotNumber;

		public MethodDescClassification m_wFlags;

		private unsafe static readonly nuint[] s_ClassificationSizeTable = new UIntPtr[8]
		{
			(nuint)sizeof(MethodDesc),
			(nuint)FCallMethodDescPtr.CurrentSize,
			(nuint)NDirectMethodDescPtr.CurrentSize,
			(nuint)EEImplMethodDescPtr.CurrentSize,
			(nuint)ArrayMethodDescPtr.CurrentSize,
			(nuint)sizeof(InstantiatedMethodDesc),
			(nuint)sizeof(ComPlusCallMethodDesc),
			(nuint)DynamicMethodDescPtr.CurrentSize
		};

		public ushort SlotNumber
		{
			get
			{
				if (!m_wFlags.Has(MethodDescClassification.RequiresFullSlotNumber))
				{
					return (ushort)(m_wSlotNumber & 0x3FF);
				}
				return m_wSlotNumber;
			}
		}

		public MethodClassification Classification => (MethodClassification)(m_wFlags & MethodDescClassification.ClassificationMask);

		public unsafe MethodDescChunk* MethodDescChunk => (MethodDescChunk*)Unsafe.AsPointer(ref Unsafe.SubtractByteOffset(ref this, (nuint)sizeof(MethodDescChunk) + m_chunkIndex * Alignment));

		public unsafe MethodTable* MethodTable => MethodDescChunk->MethodTable;

		public bool HasNonVtableSlot => m_wFlags.Has(MethodDescClassification.HasNonVtableSlot);

		public bool HasStableEntryPoint => m_bFlags2.Has(Flags2.HasStableEntryPoint);

		public bool HasPrecode => m_bFlags2.Has(Flags2.HasPrecode);

		public bool HasNativeCodeSlot => m_bFlags2.Has(Flags2.HasNativeCodeSlot);

		public bool IsUnboxingStub => m_bFlags2.Has(Flags2.IsUnboxingStub);

		public unsafe bool HasMethodInstantiation
		{
			get
			{
				if (TryAsInstantiated(out var md))
				{
					return md->IMD_HasMethodInstantiation;
				}
				return false;
			}
		}

		public unsafe bool IsGenericMethodDefinition
		{
			get
			{
				if (TryAsInstantiated(out var md))
				{
					return md->IMD_IsGenericMethodDefinition;
				}
				return false;
			}
		}

		public unsafe bool IsInstantiatingStub
		{
			get
			{
				if (!IsUnboxingStub && TryAsInstantiated(out var md))
				{
					return md->IMD_IsWrapperStubWithInstantiations;
				}
				return false;
			}
		}

		public unsafe bool IsGenericComPlusCall
		{
			get
			{
				if (TryAsInstantiated(out var md))
				{
					return md->IMD_HasComPlusCallInfo;
				}
				return false;
			}
		}

		public bool IsWrapperStub
		{
			get
			{
				if (!IsUnboxingStub)
				{
					return IsInstantiatingStub;
				}
				return true;
			}
		}

		public bool IsTightlyBoundToMethodTable
		{
			get
			{
				if (!HasNonVtableSlot)
				{
					return true;
				}
				if (HasMethodInstantiation)
				{
					return IsGenericMethodDefinition;
				}
				if (IsWrapperStub)
				{
					return false;
				}
				return true;
			}
		}

		public unsafe void* GetMethodEntryPoint()
		{
			if (HasNonVtableSlot)
			{
				nuint baseSize = GetBaseSize();
				return *(void**)((byte*)Unsafe.AsPointer(ref this) + baseSize);
			}
			return MethodTable->GetSlot(SlotNumber);
		}

		public unsafe bool TryAsInstantiated(out InstantiatedMethodDesc* md)
		{
			if (Classification == MethodClassification.Instantiated)
			{
				md = (InstantiatedMethodDesc*)Unsafe.AsPointer(ref this);
				return true;
			}
			md = default(InstantiatedMethodDesc*);
			return false;
		}

		public unsafe nuint SizeOf(bool includeNonVtable = true, bool includeMethodImpl = true, bool includeComPlus = true, bool includeNativeCode = true)
		{
			nuint num = (nuint)((nint)GetBaseSize() + (nint)((includeNonVtable && m_wFlags.Has(MethodDescClassification.HasNonVtableSlot)) ? sizeof(void*) : 0) + ((includeMethodImpl && m_wFlags.Has(MethodDescClassification.MethodImpl)) ? sizeof(MethodImpl) : 0));
			if (includeNativeCode && HasNativeCodeSlot)
			{
				num += (uint)((((nint)(nuint)Unsafe.As<MethodDesc, UIntPtr>(ref Unsafe.AddByteOffset(ref this, num)) & 1) != 0) ? (sizeof(void*) + sizeof(void*)) : sizeof(void*));
			}
			if (includeComPlus && IsGenericComPlusCall)
			{
				num += (uint)ComPlusCallInfoPtr.CurrentSize;
			}
			return num;
		}

		public unsafe void* GetNativeCode()
		{
			if (HasNativeCodeSlot)
			{
				nuint num = (nuint)((RelativePointer*)GetAddrOfNativeCodeSlot())->Value & (nuint)(~(nint)1);
				if (num != 0)
				{
					return (void*)num;
				}
			}
			if (!HasStableEntryPoint || HasPrecode)
			{
				return null;
			}
			return GetStableEntryPoint();
		}

		public unsafe void* GetStableEntryPoint()
		{
			return GetMethodEntryPoint();
		}

		public unsafe static MethodDesc* FindTightlyBoundWrappedMethodDesc(MethodDesc* pMD)
		{
			if (pMD->IsUnboxingStub && pMD->TryAsInstantiated(out var md))
			{
				pMD = md->IMD_GetWrappedMethodDesc();
			}
			if (!pMD->IsTightlyBoundToMethodTable)
			{
				pMD = pMD->GetCanonicalMethodTable()->GetParallelMethodDesc(pMD);
			}
			if (pMD->IsUnboxingStub)
			{
				pMD = GetNextIntroducedMethod(pMD);
			}
			return pMD;
		}

		public unsafe static MethodDesc* GetNextIntroducedMethod(MethodDesc* pMD)
		{
			MethodDescChunk* methodDescChunk = pMD->MethodDescChunk;
			nuint num = (nuint)((byte*)pMD + pMD->SizeOf());
			nuint num2 = (nuint)((byte*)methodDescChunk + methodDescChunk->SizeOf);
			if (num < num2)
			{
				return (MethodDesc*)num;
			}
			methodDescChunk = methodDescChunk->m_next;
			if (methodDescChunk != null)
			{
				return methodDescChunk->FirstMethodDesc;
			}
			return null;
		}

		public unsafe MethodTable* GetCanonicalMethodTable()
		{
			return MethodTable->GetCanonicalMethodTable();
		}

		public unsafe void* GetAddrOfNativeCodeSlot()
		{
			nuint byteOffset = SizeOf(includeNonVtable: true, includeMethodImpl: true, includeComPlus: false, includeNativeCode: false);
			return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, byteOffset));
		}

		public nuint GetBaseSize()
		{
			return GetBaseSize(Classification);
		}

		public static nuint GetBaseSize(MethodClassification classification)
		{
			return s_ClassificationSizeTable[(int)classification];
		}
	}

	[FatInterface]
	public struct StoredSigMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? StoredSigMethodDesc_64.FatVtable_ : StoredSigMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(StoredSigMethodDesc_64) : sizeof(StoredSigMethodDesc_32);

		public unsafe void* m_pSig
		{
			[FatInterfaceIgnore]
			get
			{
				return GetPSig();
			}
		}

		public uint m_cSig
		{
			[FatInterfaceIgnore]
			get
			{
				return GetCSig();
			}
		}

		private unsafe void* GetPSig()
		{
			return ((delegate*<void*, void*>)(void*)vtbl_[0])(ptr_);
		}

		private unsafe uint GetCSig()
		{
			return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
		}

		public unsafe StoredSigMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
	public struct StoredSigMethodDesc_64
	{
		public MethodDesc @base;

		public unsafe void* m_pSig;

		public uint m_cSig;

		public uint m_dwExtendedFlags;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[2]
					{
						(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
						(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
					};
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetCSig_1(void* ptr__)
				{
					return ((StoredSigMethodDesc_64*)ptr__)->GetCSig();
				}
				unsafe static void* S_GetPSig_0(void* ptr__)
				{
					return ((StoredSigMethodDesc_64*)ptr__)->GetPSig();
				}
			}
		}

		private unsafe void* GetPSig()
		{
			return m_pSig;
		}

		private uint GetCSig()
		{
			return m_cSig;
		}
	}

	[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
	public struct StoredSigMethodDesc_32
	{
		public MethodDesc @base;

		public unsafe void* m_pSig;

		public uint m_cSig;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[2]
					{
						(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
						(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
					};
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetCSig_1(void* ptr__)
				{
					return ((StoredSigMethodDesc_32*)ptr__)->GetCSig();
				}
				unsafe static void* S_GetPSig_0(void* ptr__)
				{
					return ((StoredSigMethodDesc_32*)ptr__)->GetPSig();
				}
			}
		}

		private unsafe void* GetPSig()
		{
			return m_pSig;
		}

		private uint GetCSig()
		{
			return m_cSig;
		}
	}

	[FatInterface]
	public struct FCallMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? FCallMethodDesc_64.FatVtable_ : FCallMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(FCallMethodDesc_64) : sizeof(FCallMethodDesc_32);

		public uint m_dwECallID
		{
			[FatInterfaceIgnore]
			get
			{
				return GetECallID();
			}
		}

		private unsafe uint GetECallID()
		{
			return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
		}

		public unsafe FCallMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
	public struct FCallMethodDesc_64
	{
		public MethodDesc @base;

		public uint m_dwECallID;

		public uint m_padding;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetECallID_0(void* ptr__)
				{
					return ((FCallMethodDesc_64*)ptr__)->GetECallID();
				}
			}
		}

		private uint GetECallID()
		{
			return m_dwECallID;
		}
	}

	[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
	public struct FCallMethodDesc_32
	{
		public MethodDesc @base;

		public uint m_dwECallID;

		private static IntPtr[]? fatVtable_;

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static uint S_GetECallID_0(void* ptr__)
				{
					return ((FCallMethodDesc_32*)ptr__)->GetECallID();
				}
			}
		}

		private uint GetECallID()
		{
			return m_dwECallID;
		}
	}

	public struct DynamicResolver
	{
	}

	[Flags]
	public enum DynamicMethodDesc_ExtendedFlags : uint
	{
		Attrs = 0xFFFFu,
		ILStubAttrs = 0x17u,
		MemberAccessMask = 7u,
		ReverseStub = 8u,
		Static = 0x10u,
		CALLIStub = 0x20u,
		DelegateStub = 0x40u,
		CopyCtorArgs = 0x80u,
		Unbreakable = 0x100u,
		DelegateCOMStub = 0x200u,
		SignatureNeedsResture = 0x400u,
		StubNeedsCOMStarted = 0x800u,
		MulticastStub = 0x1000u,
		UnboxingILStub = 0x2000u,
		ILStub = 0x10000u,
		LCGMethod = 0x20000u,
		StackArgSize = 0xFFFC0000u
	}

	[FatInterface]
	public struct DynamicMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? DynamicMethodDesc_64.FatVtable_ : DynamicMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(DynamicMethodDesc_64) : sizeof(DynamicMethodDesc_32);

		public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

		private unsafe DynamicMethodDesc_ExtendedFlags GetFlags()
		{
			return ((delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(void*)vtbl_[0])(ptr_);
		}

		public unsafe DynamicMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
	public struct DynamicMethodDesc_64
	{
		public StoredSigMethodDesc_64 @base;

		public unsafe byte* m_pszMethodName;

		public unsafe DynamicResolver* m_pResolver;

		private static IntPtr[]? fatVtable_;

		public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
				{
					return ((DynamicMethodDesc_64*)ptr__)->GetFlags();
				}
			}
		}

		private DynamicMethodDesc_ExtendedFlags GetFlags()
		{
			return (DynamicMethodDesc_ExtendedFlags)@base.m_dwExtendedFlags;
		}
	}

	[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
	public struct DynamicMethodDesc_32
	{
		public StoredSigMethodDesc_32 @base;

		public unsafe byte* m_pszMethodName;

		public unsafe DynamicResolver* m_pResolver;

		public uint m_dwExtendedFlags;

		private static IntPtr[]? fatVtable_;

		public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

		public unsafe static IntPtr[] FatVtable_
		{
			get
			{
				object obj = fatVtable_;
				if (obj == null)
				{
					obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
					fatVtable_ = (IntPtr[]?)obj;
				}
				return (IntPtr[])obj;
				unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
				{
					return ((DynamicMethodDesc_32*)ptr__)->GetFlags();
				}
			}
		}

		private DynamicMethodDesc_ExtendedFlags GetFlags()
		{
			return (DynamicMethodDesc_ExtendedFlags)m_dwExtendedFlags;
		}
	}

	[FatInterface]
	public struct ArrayMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? ArrayMethodDesc_64.FatVtable_ : ArrayMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(ArrayMethodDesc_64) : sizeof(ArrayMethodDesc_32);

		public unsafe ArrayMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	public enum ArrayFunc
	{
		Get,
		Set,
		Address,
		Ctor
	}

	[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
	public struct ArrayMethodDesc_64
	{
		public StoredSigMethodDesc_64 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
	public struct ArrayMethodDesc_32
	{
		public StoredSigMethodDesc_32 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	public struct NDirectWriteableData
	{
	}

	[Flags]
	public enum NDirectMethodDesc_Flags : ushort
	{
		EarlyBound = 1,
		HasSuppressUnmanagedCodeAccess = 2,
		DefaultDllImportSearchPathIsCached = 4,
		IsMarshalingRequiredCached = 0x10,
		CachedMarshalingRequired = 0x20,
		NativeAnsi = 0x40,
		LastError = 0x80,
		NativeNoMangle = 0x100,
		VarArgs = 0x200,
		StdCall = 0x400,
		ThisCall = 0x800,
		IsQCall = 0x1000,
		DefaultDllImportSearchPathsStatus = 0x2000,
		NDirectPopulated = 0x8000
	}

	[FatInterface]
	public struct NDirectMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? NDirectMethodDesc_x86.FatVtable_ : NDirectMethodDesc_other.FatVtable_;

		public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(NDirectMethodDesc_x86) : sizeof(NDirectMethodDesc_other);

		public unsafe NDirectMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
	public struct NDirectMethodDesc_other
	{
		public struct NDirect
		{
			public unsafe void* m_pNativeNDirectTarget;

			public unsafe byte* m_pszEntrypointName;

			public nuint union_pszLibName_dwECallID;

			public unsafe NDirectWriteableData* m_pWriteableData;

			public unsafe void* m_pImportThunkGlue;

			public uint m_DefaultDllImportSearchPathsAttributeValue;

			public NDirectMethodDesc_Flags m_wFlags;

			public unsafe MethodDesc* m_pStubMD;
		}

		public MethodDesc @base;

		private NDirect ndirect;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
	public struct NDirectMethodDesc_x86
	{
		public struct NDirect
		{
			public unsafe void* m_pNativeNDirectTarget;

			public unsafe byte* m_pszEntrypointName;

			public nuint union_pszLibName_dwECallID;

			public unsafe NDirectWriteableData* m_pWriteableData;

			public unsafe void* m_pImportThunkGlue;

			public uint m_DefaultDllImportSearchPathsAttributeValue;

			public NDirectMethodDesc_Flags m_wFlags;

			public ushort m_cbStackArgumentSize;

			public unsafe MethodDesc* m_pStubMD;
		}

		public MethodDesc @base;

		private NDirect ndirect;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterface]
	public struct EEImplMethodDescPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? EEImplMethodDesc_64.FatVtable_ : EEImplMethodDesc_32.FatVtable_;

		public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(EEImplMethodDesc_64) : sizeof(EEImplMethodDesc_32);

		public unsafe EEImplMethodDescPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
	public struct EEImplMethodDesc_64
	{
		public StoredSigMethodDesc_64 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
	public struct EEImplMethodDesc_32
	{
		public StoredSigMethodDesc_32 @base;

		private static IntPtr[]? fatVtable_;

		public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
	}

	[FatInterface]
	public struct ComPlusCallInfoPtr
	{
		private unsafe readonly void* ptr_;

		private readonly IntPtr[] vtbl_;

		public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(ComPlusCallInfo_x86) : sizeof(ComPlusCallInfo_other);

		public unsafe ComPlusCallInfoPtr(void* ptr, IntPtr[] vtbl)
		{
			ptr_ = ptr;
			vtbl_ = vtbl;
		}
	}

	public struct ComPlusCallInfo_x86
	{
		public unsafe void* union_m_pILStub_pEventProviderMD;

		public unsafe MethodTable* m_pInterfaceMT;

		public byte m_flags;

		public ushort m_cachedComSlot;

		public ushort m_cbStackArgumentSize;

		public unsafe void* union_m_pRetThunk_pInterceptStub;

		private RelativePointer m_pStubMD;
	}

	public struct ComPlusCallInfo_other
	{
		public unsafe void* union_m_pILStub_pEventProviderMD;

		public unsafe MethodTable* m_pInterfaceMT;

		public byte m_flags;

		public ushort m_cachedComSlot;

		private RelativePointer m_pStubMD;
	}

	public struct ComPlusCallMethodDesc
	{
		public MethodDesc @base;

		public unsafe void* m_pComPlusCallInfo;
	}

	public struct InstantiatedMethodDesc
	{
		[Flags]
		public enum Flags : ushort
		{
			KindMask = 7,
			GenericMethodDefinition = 0,
			UnsharedMethodInstantiation = 1,
			SharedMethodInstantiation = 2,
			WrapperStubWithInstantiations = 3,
			EnCAddedMethod = 7,
			Unrestored = 8,
			HasComPlusCallInfo = 0x10
		}

		public MethodDesc @base;

		public unsafe void* union_pDictLayout_pWrappedMethodDesc;

		public unsafe Dictionary* m_pPerInstInfo;

		public Flags m_wFlags2;

		public ushort m_wNumGenericArgs;

		public unsafe bool IMD_HasMethodInstantiation
		{
			get
			{
				if (!IMD_IsGenericMethodDefinition)
				{
					return m_pPerInstInfo != null;
				}
				return true;
			}
		}

		public bool IMD_IsGenericMethodDefinition => (m_wFlags2 & Flags.KindMask) == 0;

		public bool IMD_IsWrapperStubWithInstantiations => (m_wFlags2 & Flags.KindMask) == Flags.WrapperStubWithInstantiations;

		public bool IMD_HasComPlusCallInfo => m_wFlags2.Has(Flags.HasComPlusCallInfo);

		public unsafe MethodDesc* IMD_GetWrappedMethodDesc()
		{
			Helpers.Assert(IMD_IsWrapperStubWithInstantiations, null, "IMD_IsWrapperStubWithInstantiations");
			return (MethodDesc*)union_pDictLayout_pWrappedMethodDesc;
		}
	}

	public struct RelativeFixupPointer
	{
		private readonly nint value;

		public unsafe void* Value
		{
			get
			{
				nint num = value;
				if (num == 0)
				{
					return null;
				}
				nint num2 = (nint)((byte*)Unsafe.AsPointer(ref this) + num);
				if ((num2 & 1) != 0)
				{
					num2 = *(nint*)(num2 - 1);
				}
				return (void*)num2;
			}
		}
	}

	public struct MethodDescChunk
	{
		[Flags]
		public enum Flags : ushort
		{
			TokenRangeMask = 0x3FF,
			HasCompactEntrypoints = 0x4000,
			IsZapped = 0x8000
		}

		public RelativeFixupPointer m_methodTable;

		public unsafe MethodDescChunk* m_next;

		public byte m_size;

		public byte m_count;

		public Flags m_flagsAndTokenRange;

		public unsafe MethodTable* MethodTable => (MethodTable*)m_methodTable.Value;

		public unsafe MethodDesc* FirstMethodDesc => (MethodDesc*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodDescChunk));

		public uint Size => (uint)(m_size + 1);

		public uint Count => (uint)(m_count + 1);

		public unsafe nuint SizeOf => (nuint)sizeof(MethodDescChunk) + Size * MethodDesc.Alignment;
	}

	public struct Dictionary
	{
	}

	public struct Module
	{
	}

	public struct MethodTableWriteableData
	{
	}

	public struct RelativePointer
	{
		private nint m_delta;

		public unsafe void* Value
		{
			get
			{
				nint delta = m_delta;
				if (delta != 0)
				{
					return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
				}
				return null;
			}
		}

		public RelativePointer(nint delta)
		{
			m_delta = delta;
		}
	}

	public struct MethodTable
	{
		[Flags]
		public enum WFlagsLow : uint
		{
			UNUSED_ComponentSize_1 = 1u,
			StaticsMask = 6u,
			StaticsMask_NonDynamic = 0u,
			StaticsMask_Dynamic = 2u,
			StaticsMask_Generics = 4u,
			StaticsMask_CrossModuleGenerics = 6u,
			StaticsMask_IfGenericsThenCrossModule = 2u,
			NotInPZM = 8u,
			GenericsMask = 0x30u,
			GenericsMask_NonGeneric = 0u,
			GenericsMask_GenericInst = 0x10u,
			GenericsMask_SharedInst = 0x20u,
			GenericsMask_TypicalInst = 0x30u,
			ContextStatic = 0x40u,
			HasRemotingVtsInfo = 0x80u,
			HasVariance = 0x100u,
			HasDefaultCtor = 0x200u,
			HasPreciseInitCctors = 0x400u,
			IsHFA_IsRegStructPassed = 0x800u,
			IsByRefLike = 0x1000u,
			UNUSED_ComponentSize_5 = 0x2000u,
			UNUSED_ComponentSize_6 = 0x4000u,
			UNUSED_ComponentSize_7 = 0x8000u,
			StringArrayValues = 0u
		}

		[Flags]
		public enum WFlagsHigh : uint
		{
			Category_Mask = 0xF0000u,
			Category_Class = 0u,
			Category_Unused_1 = 0x10000u,
			Category_MarshalByRef_Mask = 0xE0000u,
			Category_MarshalByRef = 0x20000u,
			Category_Contextful = 0x30000u,
			Category_ValueType = 0x40000u,
			Category_ValueType_Mask = 0xC0000u,
			Category_Nullable = 0x50000u,
			Category_PrimitiveValueType = 0x60000u,
			Category_TruePrimitive = 0x70000u,
			Category_Array = 0x80000u,
			Category_Array_Mask = 0xC0000u,
			Category_IfArrayThenSzArray = 0x20000u,
			Category_Interface = 0xC0000u,
			Category_Unused_2 = 0xD0000u,
			Category_TransparentProxy = 0xE0000u,
			Category_AsyncPin = 0xF0000u,
			Category_ElementTypeMask = 0xE0000u,
			HasFinalizer = 0x100000u,
			IfNotInterfaceThenMarshalable = 0x200000u,
			IfInterfaceThenHasGuidInfo = 0x200000u,
			ICastable = 0x400000u,
			HasIndirectParent = 0x800000u,
			ContainsPointers = 0x1000000u,
			HasTypeEquivalence = 0x2000000u,
			HasRCWPerTypeData = 0x4000000u,
			HasCriticalFinalizer = 0x8000000u,
			Collectible = 0x10000000u,
			ContainsGenericVariables = 0x20000000u,
			ComObject = 0x40000000u,
			HasComponentSize = 0x80000000u,
			NonTrivialInterfaceCast = 0x40480000u
		}

		[Flags]
		public enum Flags2 : ushort
		{
			MultipurposeSlotsMask = 0x1F,
			HasPerInstInfo = 1,
			HasInterfaceMap = 2,
			HasDispatchMapSlot = 4,
			HasNonVirtualSlots = 8,
			HasModuleOverride = 0x10,
			IsZapped = 0x20,
			IsPreRestored = 0x40,
			HasModuleDependencies = 0x80,
			NoSecurityProperties = 0x100,
			RequiresDispatchTokenFat = 0x200,
			HasCctor = 0x400,
			HasCCWTemplate = 0x800,
			RequiresAlign8 = 0x1000,
			HasBoxedRegularStatics = 0x2000,
			HasSingleNonVirtualSlot = 0x4000,
			DependsOnEquivalentOrForwardedStructs = 0x8000
		}

		public enum UnionLowBits
		{
			EEClass,
			Invalid,
			MethodTable,
			Indirection
		}

		private static class MultipurposeSlotHelpers
		{
			public unsafe static byte OffsetOfMp1()
			{
				MethodTable methodTable = default(MethodTable);
				return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
			}

			public unsafe static byte OffsetOfMp2()
			{
				MethodTable methodTable = default(MethodTable);
				return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
			}

			public unsafe static byte RegularOffset(int index)
			{
				return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
			}
		}

		private uint m_dwFlags;

		public uint m_BaseSize;

		public Flags2 m_wFlags2;

		public ushort m_wToken;

		public ushort m_wNumVirtuals;

		public ushort m_wNumInterfaces;

		private unsafe void* m_pParentMethodTable;

		public unsafe Module* m_pLoaderModule;

		public unsafe MethodTableWriteableData* m_pWriteableData;

		public unsafe void* union_pEEClass_pCanonMT;

		public unsafe void* union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1;

		public unsafe void* union_p_InterfaceMap_pMultipurposeSlot2;

		public const int VTABLE_SLOTS_PER_CHUNK = 8;

		public const int VTABLE_SLOTS_PER_CHUNK_LOG2 = 3;

		private static readonly byte[] c_NonVirtualSlotsOffsets = GetNonVirtualSlotsOffsets();

		public WFlagsHigh FlagsHigh => (WFlagsHigh)(m_dwFlags & 0xFFFF0000u);

		public WFlagsLow FlagsLow
		{
			get
			{
				if (!FlagsHigh.Has(WFlagsHigh.HasComponentSize))
				{
					return (WFlagsLow)(m_dwFlags & 0xFFFF);
				}
				return WFlagsLow.StaticsMask_NonDynamic;
			}
		}

		public int ComponentSize
		{
			get
			{
				if (!FlagsHigh.Has(WFlagsHigh.HasComponentSize))
				{
					return 0;
				}
				return (int)(m_dwFlags & 0xFFFF);
			}
		}

		public bool IsInterface => (m_dwFlags & 0xF0000) == 786432;

		public bool HasIndirectParent => FlagsHigh.Has(WFlagsHigh.HasIndirectParent);

		public unsafe MethodTable* ParentMethodTable
		{
			get
			{
				void* pParentMethodTable = m_pParentMethodTable;
				if (HasIndirectParent)
				{
					return (MethodTable*)((MethodTable*)pParentMethodTable)->m_pParentMethodTable;
				}
				return (MethodTable*)pParentMethodTable;
			}
		}

		public bool HasSingleNonVirtualSlot => m_wFlags2.Has(Flags2.HasSingleNonVirtualSlot);

		public unsafe MethodTable* GetCanonicalMethodTable()
		{
			nuint num = (nuint)union_pEEClass_pCanonMT;
			if ((num & 2) == 0)
			{
				return (MethodTable*)num;
			}
			if ((num & 1) != 0)
			{
				return *(MethodTable**)(num - 3);
			}
			return (MethodTable*)(num - 2);
		}

		public unsafe MethodDesc* GetParallelMethodDesc(MethodDesc* pDefMD)
		{
			return GetMethodDescForSlot(pDefMD->SlotNumber);
		}

		public unsafe MethodDesc* GetMethodDescForSlot(uint slotNumber)
		{
			if (IsInterface)
			{
				GetNumVirtuals();
			}
			throw new NotImplementedException();
		}

		public unsafe void* GetRestoredSlot(uint slotNumber)
		{
			MethodTable* ptr = (MethodTable*)Unsafe.AsPointer(ref this);
			void* slot;
			while (true)
			{
				ptr = ptr->GetCanonicalMethodTable();
				slot = ptr->GetSlot(slotNumber);
				if (slot != null)
				{
					break;
				}
				ptr = ptr->ParentMethodTable;
			}
			return slot;
		}

		public unsafe void* GetSlot(uint slotNumber)
		{
			return *(void**)GetSlotPtrRaw(slotNumber);
		}

		public unsafe nint GetSlotPtrRaw(uint slotNum)
		{
			if (slotNum < GetNumVirtuals())
			{
				uint indexOfVtableIndirection = GetIndexOfVtableIndirection(slotNum);
				void** ptr = (void**)GetVtableIndirections()[indexOfVtableIndirection];
				return (nint)(ptr + GetIndexAfterVtableIndirection(slotNum));
			}
			if (HasSingleNonVirtualSlot)
			{
				return GetNonVirtualSlotsPtr();
			}
			return (nint)(GetNonVirtualSlotsArray() + (slotNum - GetNumVirtuals()));
		}

		public ushort GetNumVirtuals()
		{
			return m_wNumVirtuals;
		}

		public static uint GetIndexOfVtableIndirection(uint slotNum)
		{
			return slotNum >> 3;
		}

		public unsafe void** GetVtableIndirections()
		{
			return (void**)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodTable));
		}

		public static uint GetIndexAfterVtableIndirection(uint slotNum)
		{
			return slotNum & 7;
		}

		[MultipurposeSlotOffsetTable(3, typeof(MultipurposeSlotHelpers))]
		private static byte[] GetNonVirtualSlotsOffsets()
		{
			return new byte[8]
			{
				MultipurposeSlotHelpers.OffsetOfMp1(),
				MultipurposeSlotHelpers.OffsetOfMp2(),
				MultipurposeSlotHelpers.OffsetOfMp1(),
				MultipurposeSlotHelpers.RegularOffset(2),
				MultipurposeSlotHelpers.OffsetOfMp2(),
				MultipurposeSlotHelpers.RegularOffset(2),
				MultipurposeSlotHelpers.RegularOffset(2),
				MultipurposeSlotHelpers.RegularOffset(3)
			};
		}

		public nint GetNonVirtualSlotsPtr()
		{
			return GetMultipurposeSlotPtr(Flags2.HasNonVirtualSlots, c_NonVirtualSlotsOffsets);
		}

		public unsafe nint GetMultipurposeSlotPtr(Flags2 flag, byte[] offsets)
		{
			nint num = offsets[(uint)(m_wFlags2 & (flag - 1))];
			if (num >= sizeof(MethodTable))
			{
				num += (nint)GetNumVTableIndirections() * (nint)sizeof(void**);
			}
			return (nint)((byte*)Unsafe.AsPointer(ref this) + num);
		}

		public unsafe void** GetNonVirtualSlotsArray()
		{
			return (void**)((RelativePointer*)GetNonVirtualSlotsPtr())->Value;
		}

		public uint GetNumVTableIndirections()
		{
			return GetNumVtableIndirections(GetNumVirtuals());
		}

		public static uint GetNumVtableIndirections(uint numVirtuals)
		{
			return numVirtuals + 7 >> 3;
		}
	}
}


public enum MethodClassification
{
	IL,
	FCall,
	NDirect,
	EEImpl,
	Array,
	Instantiated,
	ComInterop,
	Dynamic
}


public enum MethodDescClassification : ushort
{
	ClassificationMask = 7,
	HasNonVtableSlot = 8,
	MethodImpl = 16,
	Static = 32,
	Intercepted = 64,
	RequiresLinktimeCheck = 128,
	RequiresInheritanceCheck = 256,
	ParentRequiresInheritanceCheck = 512,
	Duplicate = 1024,
	VerifiedState = 2048,
	Verifiable = 4096,
	NotInline = 8192,
	Synchronized = 16384,
	RequiresFullSlotNumber = 32768
}


public struct MethodImpl
{
	public unsafe uint* pdwSlots;

	public unsafe MethodDesc* pImplementedMD;
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Utils;

public struct MethodDesc
{
	[Flags]
	public enum Flags3 : ushort
	{
		TokenRemainderMask = 0x3FFF,
		HasForwardedValuetypeParameter = 0x4000,
		ValueTypeParametersWalked = 0x4000,
		DoesNotHaveEquivalentValuetypeParameters = 0x8000
	}

	[Flags]
	public enum Flags2 : byte
	{
		HasStableEntryPoint = 1,
		HasPrecode = 2,
		IsUnboxingStub = 4,
		HasNativeCodeSlot = 8,
		TransparencyMask = 0x30,
		TransparencyUnknown = 0,
		TransparencyTransparent = 0x10,
		TransparencyCritical = 0x20,
		TransparencyTreatAsSafe = 0x30,
		CASDemandsOnly = 0x40,
		HostProtectionLinkChecksOnly = 0x80
	}

	public static readonly nuint Alignment = (nuint)((IntPtr.Size == 8) ? 8 : 4);

	public Flags3 m_wFlags3AndTokenRemainder;

	public byte m_chunkIndex;

	public Flags2 m_bFlags2;

	public const ushort PackedSlot_SlotMask = 1023;

	public const ushort PackedSlot_NameHashMask = 64512;

	public ushort m_wSlotNumber;

	public MethodDescClassification m_wFlags;

	private unsafe static readonly nuint[] s_ClassificationSizeTable = new UIntPtr[8]
	{
		(nuint)sizeof(MethodDesc),
		(nuint)FCallMethodDescPtr.CurrentSize,
		(nuint)NDirectMethodDescPtr.CurrentSize,
		(nuint)EEImplMethodDescPtr.CurrentSize,
		(nuint)ArrayMethodDescPtr.CurrentSize,
		(nuint)sizeof(InstantiatedMethodDesc),
		(nuint)sizeof(ComPlusCallMethodDesc),
		(nuint)DynamicMethodDescPtr.CurrentSize
	};

	public ushort SlotNumber
	{
		get
		{
			if (!m_wFlags.Has(MethodDescClassification.RequiresFullSlotNumber))
			{
				return (ushort)(m_wSlotNumber & 0x3FF);
			}
			return m_wSlotNumber;
		}
	}

	public MethodClassification Classification => (MethodClassification)(m_wFlags & MethodDescClassification.ClassificationMask);

	public unsafe MethodDescChunk* MethodDescChunk => (MethodDescChunk*)Unsafe.AsPointer(ref Unsafe.SubtractByteOffset(ref this, (nuint)sizeof(MethodDescChunk) + m_chunkIndex * Alignment));

	public unsafe MethodTable* MethodTable => MethodDescChunk->MethodTable;

	public bool HasNonVtableSlot => m_wFlags.Has(MethodDescClassification.HasNonVtableSlot);

	public bool HasStableEntryPoint => m_bFlags2.Has(Flags2.HasStableEntryPoint);

	public bool HasPrecode => m_bFlags2.Has(Flags2.HasPrecode);

	public bool HasNativeCodeSlot => m_bFlags2.Has(Flags2.HasNativeCodeSlot);

	public bool IsUnboxingStub => m_bFlags2.Has(Flags2.IsUnboxingStub);

	public unsafe bool HasMethodInstantiation
	{
		get
		{
			if (TryAsInstantiated(out var md))
			{
				return md->IMD_HasMethodInstantiation;
			}
			return false;
		}
	}

	public unsafe bool IsGenericMethodDefinition
	{
		get
		{
			if (TryAsInstantiated(out var md))
			{
				return md->IMD_IsGenericMethodDefinition;
			}
			return false;
		}
	}

	public unsafe bool IsInstantiatingStub
	{
		get
		{
			if (!IsUnboxingStub && TryAsInstantiated(out var md))
			{
				return md->IMD_IsWrapperStubWithInstantiations;
			}
			return false;
		}
	}

	public unsafe bool IsGenericComPlusCall
	{
		get
		{
			if (TryAsInstantiated(out var md))
			{
				return md->IMD_HasComPlusCallInfo;
			}
			return false;
		}
	}

	public bool IsWrapperStub
	{
		get
		{
			if (!IsUnboxingStub)
			{
				return IsInstantiatingStub;
			}
			return true;
		}
	}

	public bool IsTightlyBoundToMethodTable
	{
		get
		{
			if (!HasNonVtableSlot)
			{
				return true;
			}
			if (HasMethodInstantiation)
			{
				return IsGenericMethodDefinition;
			}
			if (IsWrapperStub)
			{
				return false;
			}
			return true;
		}
	}

	public unsafe void* GetMethodEntryPoint()
	{
		if (HasNonVtableSlot)
		{
			nuint baseSize = GetBaseSize();
			return *(void**)((byte*)Unsafe.AsPointer(ref this) + baseSize);
		}
		return MethodTable->GetSlot(SlotNumber);
	}

	public unsafe bool TryAsInstantiated(out InstantiatedMethodDesc* md)
	{
		if (Classification == MethodClassification.Instantiated)
		{
			md = (InstantiatedMethodDesc*)Unsafe.AsPointer(ref this);
			return true;
		}
		md = default(InstantiatedMethodDesc*);
		return false;
	}

	public unsafe nuint SizeOf(bool includeNonVtable = true, bool includeMethodImpl = true, bool includeComPlus = true, bool includeNativeCode = true)
	{
		nuint num = (nuint)((nint)GetBaseSize() + (nint)((includeNonVtable && m_wFlags.Has(MethodDescClassification.HasNonVtableSlot)) ? sizeof(void*) : 0) + ((includeMethodImpl && m_wFlags.Has(MethodDescClassification.MethodImpl)) ? sizeof(MethodImpl) : 0));
		if (includeNativeCode && HasNativeCodeSlot)
		{
			num += (uint)((((nint)(nuint)Unsafe.As<MethodDesc, UIntPtr>(ref Unsafe.AddByteOffset(ref this, num)) & 1) != 0) ? (sizeof(void*) + sizeof(void*)) : sizeof(void*));
		}
		if (includeComPlus && IsGenericComPlusCall)
		{
			num += (uint)ComPlusCallInfoPtr.CurrentSize;
		}
		return num;
	}

	public unsafe void* GetNativeCode()
	{
		if (HasNativeCodeSlot)
		{
			nuint num = (nuint)((RelativePointer*)GetAddrOfNativeCodeSlot())->Value & (nuint)(~(nint)1);
			if (num != 0)
			{
				return (void*)num;
			}
		}
		if (!HasStableEntryPoint || HasPrecode)
		{
			return null;
		}
		return GetStableEntryPoint();
	}

	public unsafe void* GetStableEntryPoint()
	{
		return GetMethodEntryPoint();
	}

	public unsafe static MethodDesc* FindTightlyBoundWrappedMethodDesc(MethodDesc* pMD)
	{
		if (pMD->IsUnboxingStub && pMD->TryAsInstantiated(out var md))
		{
			pMD = md->IMD_GetWrappedMethodDesc();
		}
		if (!pMD->IsTightlyBoundToMethodTable)
		{
			pMD = pMD->GetCanonicalMethodTable()->GetParallelMethodDesc(pMD);
		}
		if (pMD->IsUnboxingStub)
		{
			pMD = GetNextIntroducedMethod(pMD);
		}
		return pMD;
	}

	public unsafe static MethodDesc* GetNextIntroducedMethod(MethodDesc* pMD)
	{
		MethodDescChunk* methodDescChunk = pMD->MethodDescChunk;
		nuint num = (nuint)((byte*)pMD + pMD->SizeOf());
		nuint num2 = (nuint)((byte*)methodDescChunk + methodDescChunk->SizeOf);
		if (num < num2)
		{
			return (MethodDesc*)num;
		}
		methodDescChunk = methodDescChunk->m_next;
		if (methodDescChunk != null)
		{
			return methodDescChunk->FirstMethodDesc;
		}
		return null;
	}

	public unsafe MethodTable* GetCanonicalMethodTable()
	{
		return MethodTable->GetCanonicalMethodTable();
	}

	public unsafe void* GetAddrOfNativeCodeSlot()
	{
		nuint byteOffset = SizeOf(includeNonVtable: true, includeMethodImpl: true, includeComPlus: false, includeNativeCode: false);
		return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, byteOffset));
	}

	public nuint GetBaseSize()
	{
		return GetBaseSize(Classification);
	}

	public static nuint GetBaseSize(MethodClassification classification)
	{
		return s_ClassificationSizeTable[(int)classification];
	}
}


using System;

[Flags]
public enum Flags3 : ushort
{
	TokenRemainderMask = 0x3FFF,
	HasForwardedValuetypeParameter = 0x4000,
	ValueTypeParametersWalked = 0x4000,
	DoesNotHaveEquivalentValuetypeParameters = 0x8000
}


using System;

[Flags]
public enum Flags2 : byte
{
	HasStableEntryPoint = 1,
	HasPrecode = 2,
	IsUnboxingStub = 4,
	HasNativeCodeSlot = 8,
	TransparencyMask = 0x30,
	TransparencyUnknown = 0,
	TransparencyTransparent = 0x10,
	TransparencyCritical = 0x20,
	TransparencyTreatAsSafe = 0x30,
	CASDemandsOnly = 0x40,
	HostProtectionLinkChecksOnly = 0x80
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct StoredSigMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? StoredSigMethodDesc_64.FatVtable_ : StoredSigMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(StoredSigMethodDesc_64) : sizeof(StoredSigMethodDesc_32);

	public unsafe void* m_pSig
	{
		[FatInterfaceIgnore]
		get
		{
			return GetPSig();
		}
	}

	public uint m_cSig
	{
		[FatInterfaceIgnore]
		get
		{
			return GetCSig();
		}
	}

	private unsafe void* GetPSig()
	{
		return ((delegate*<void*, void*>)(void*)vtbl_[0])(ptr_);
	}

	private unsafe uint GetCSig()
	{
		return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
	}

	public unsafe StoredSigMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
public struct StoredSigMethodDesc_64
{
	public MethodDesc @base;

	public unsafe void* m_pSig;

	public uint m_cSig;

	public uint m_dwExtendedFlags;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[2]
				{
					(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
					(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
				};
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetCSig_1(void* ptr__)
			{
				return ((StoredSigMethodDesc_64*)ptr__)->GetCSig();
			}
			unsafe static void* S_GetPSig_0(void* ptr__)
			{
				return ((StoredSigMethodDesc_64*)ptr__)->GetPSig();
			}
		}
	}

	private unsafe void* GetPSig()
	{
		return m_pSig;
	}

	private uint GetCSig()
	{
		return m_cSig;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(StoredSigMethodDescPtr))]
public struct StoredSigMethodDesc_32
{
	public MethodDesc @base;

	public unsafe void* m_pSig;

	public uint m_cSig;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[2]
				{
					(IntPtr)(delegate*<void*, void*>)(&S_GetPSig_0),
					(IntPtr)(delegate*<void*, uint>)(&S_GetCSig_1)
				};
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetCSig_1(void* ptr__)
			{
				return ((StoredSigMethodDesc_32*)ptr__)->GetCSig();
			}
			unsafe static void* S_GetPSig_0(void* ptr__)
			{
				return ((StoredSigMethodDesc_32*)ptr__)->GetPSig();
			}
		}
	}

	private unsafe void* GetPSig()
	{
		return m_pSig;
	}

	private uint GetCSig()
	{
		return m_cSig;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct FCallMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? FCallMethodDesc_64.FatVtable_ : FCallMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(FCallMethodDesc_64) : sizeof(FCallMethodDesc_32);

	public uint m_dwECallID
	{
		[FatInterfaceIgnore]
		get
		{
			return GetECallID();
		}
	}

	private unsafe uint GetECallID()
	{
		return ((delegate*<void*, uint>)(void*)vtbl_[0])(ptr_);
	}

	public unsafe FCallMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
public struct FCallMethodDesc_64
{
	public MethodDesc @base;

	public uint m_dwECallID;

	public uint m_padding;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetECallID_0(void* ptr__)
			{
				return ((FCallMethodDesc_64*)ptr__)->GetECallID();
			}
		}
	}

	private uint GetECallID()
	{
		return m_dwECallID;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(FCallMethodDescPtr))]
public struct FCallMethodDesc_32
{
	public MethodDesc @base;

	public uint m_dwECallID;

	private static IntPtr[]? fatVtable_;

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, uint>)(&S_GetECallID_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static uint S_GetECallID_0(void* ptr__)
			{
				return ((FCallMethodDesc_32*)ptr__)->GetECallID();
			}
		}
	}

	private uint GetECallID()
	{
		return m_dwECallID;
	}
}


public struct DynamicResolver
{
}


using System;

[Flags]
public enum DynamicMethodDesc_ExtendedFlags : uint
{
	Attrs = 0xFFFFu,
	ILStubAttrs = 0x17u,
	MemberAccessMask = 7u,
	ReverseStub = 8u,
	Static = 0x10u,
	CALLIStub = 0x20u,
	DelegateStub = 0x40u,
	CopyCtorArgs = 0x80u,
	Unbreakable = 0x100u,
	DelegateCOMStub = 0x200u,
	SignatureNeedsResture = 0x400u,
	StubNeedsCOMStarted = 0x800u,
	MulticastStub = 0x1000u,
	UnboxingILStub = 0x2000u,
	ILStub = 0x10000u,
	LCGMethod = 0x20000u,
	StackArgSize = 0xFFFC0000u
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct DynamicMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? DynamicMethodDesc_64.FatVtable_ : DynamicMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(DynamicMethodDesc_64) : sizeof(DynamicMethodDesc_32);

	public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

	private unsafe DynamicMethodDesc_ExtendedFlags GetFlags()
	{
		return ((delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(void*)vtbl_[0])(ptr_);
	}

	public unsafe DynamicMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
public struct DynamicMethodDesc_64
{
	public StoredSigMethodDesc_64 @base;

	public unsafe byte* m_pszMethodName;

	public unsafe DynamicResolver* m_pResolver;

	private static IntPtr[]? fatVtable_;

	public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
			{
				return ((DynamicMethodDesc_64*)ptr__)->GetFlags();
			}
		}
	}

	private DynamicMethodDesc_ExtendedFlags GetFlags()
	{
		return (DynamicMethodDesc_ExtendedFlags)@base.m_dwExtendedFlags;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(DynamicMethodDescPtr))]
public struct DynamicMethodDesc_32
{
	public StoredSigMethodDesc_32 @base;

	public unsafe byte* m_pszMethodName;

	public unsafe DynamicResolver* m_pResolver;

	public uint m_dwExtendedFlags;

	private static IntPtr[]? fatVtable_;

	public DynamicMethodDesc_ExtendedFlags Flags => GetFlags();

	public unsafe static IntPtr[] FatVtable_
	{
		get
		{
			object obj = fatVtable_;
			if (obj == null)
			{
				obj = new IntPtr[1] { (IntPtr)(delegate*<void*, DynamicMethodDesc_ExtendedFlags>)(&S_GetFlags_0) };
				fatVtable_ = (IntPtr[]?)obj;
			}
			return (IntPtr[])obj;
			unsafe static DynamicMethodDesc_ExtendedFlags S_GetFlags_0(void* ptr__)
			{
				return ((DynamicMethodDesc_32*)ptr__)->GetFlags();
			}
		}
	}

	private DynamicMethodDesc_ExtendedFlags GetFlags()
	{
		return (DynamicMethodDesc_ExtendedFlags)m_dwExtendedFlags;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct ArrayMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? ArrayMethodDesc_64.FatVtable_ : ArrayMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(ArrayMethodDesc_64) : sizeof(ArrayMethodDesc_32);

	public unsafe ArrayMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


public enum ArrayFunc
{
	Get,
	Set,
	Address,
	Ctor
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
public struct ArrayMethodDesc_64
{
	public StoredSigMethodDesc_64 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(ArrayMethodDescPtr))]
public struct ArrayMethodDesc_32
{
	public StoredSigMethodDesc_32 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct NDirectWriteableData
{
}


using System;

[Flags]
public enum NDirectMethodDesc_Flags : ushort
{
	EarlyBound = 1,
	HasSuppressUnmanagedCodeAccess = 2,
	DefaultDllImportSearchPathIsCached = 4,
	IsMarshalingRequiredCached = 0x10,
	CachedMarshalingRequired = 0x20,
	NativeAnsi = 0x40,
	LastError = 0x80,
	NativeNoMangle = 0x100,
	VarArgs = 0x200,
	StdCall = 0x400,
	ThisCall = 0x800,
	IsQCall = 0x1000,
	DefaultDllImportSearchPathsStatus = 0x2000,
	NDirectPopulated = 0x8000
}


using System;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

[FatInterface]
public struct NDirectMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? NDirectMethodDesc_x86.FatVtable_ : NDirectMethodDesc_other.FatVtable_;

	public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(NDirectMethodDesc_x86) : sizeof(NDirectMethodDesc_other);

	public unsafe NDirectMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
public struct NDirectMethodDesc_other
{
	public struct NDirect
	{
		public unsafe void* m_pNativeNDirectTarget;

		public unsafe byte* m_pszEntrypointName;

		public nuint union_pszLibName_dwECallID;

		public unsafe NDirectWriteableData* m_pWriteableData;

		public unsafe void* m_pImportThunkGlue;

		public uint m_DefaultDllImportSearchPathsAttributeValue;

		public NDirectMethodDesc_Flags m_wFlags;

		public unsafe MethodDesc* m_pStubMD;
	}

	public MethodDesc @base;

	private NDirect ndirect;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct NDirect
{
	public unsafe void* m_pNativeNDirectTarget;

	public unsafe byte* m_pszEntrypointName;

	public nuint union_pszLibName_dwECallID;

	public unsafe NDirectWriteableData* m_pWriteableData;

	public unsafe void* m_pImportThunkGlue;

	public uint m_DefaultDllImportSearchPathsAttributeValue;

	public NDirectMethodDesc_Flags m_wFlags;

	public unsafe MethodDesc* m_pStubMD;
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(NDirectMethodDescPtr))]
public struct NDirectMethodDesc_x86
{
	public struct NDirect
	{
		public unsafe void* m_pNativeNDirectTarget;

		public unsafe byte* m_pszEntrypointName;

		public nuint union_pszLibName_dwECallID;

		public unsafe NDirectWriteableData* m_pWriteableData;

		public unsafe void* m_pImportThunkGlue;

		public uint m_DefaultDllImportSearchPathsAttributeValue;

		public NDirectMethodDesc_Flags m_wFlags;

		public ushort m_cbStackArgumentSize;

		public unsafe MethodDesc* m_pStubMD;
	}

	public MethodDesc @base;

	private NDirect ndirect;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


public struct NDirect
{
	public unsafe void* m_pNativeNDirectTarget;

	public unsafe byte* m_pszEntrypointName;

	public nuint union_pszLibName_dwECallID;

	public unsafe NDirectWriteableData* m_pWriteableData;

	public unsafe void* m_pImportThunkGlue;

	public uint m_DefaultDllImportSearchPathsAttributeValue;

	public NDirectMethodDesc_Flags m_wFlags;

	public ushort m_cbStackArgumentSize;

	public unsafe MethodDesc* m_pStubMD;
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterface]
public struct EEImplMethodDescPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public static IntPtr[] CurrentVtable { get; } = (IntPtr.Size == 8) ? EEImplMethodDesc_64.FatVtable_ : EEImplMethodDesc_32.FatVtable_;

	public unsafe static int CurrentSize { get; } = (IntPtr.Size == 8) ? sizeof(EEImplMethodDesc_64) : sizeof(EEImplMethodDesc_32);

	public unsafe EEImplMethodDescPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
public struct EEImplMethodDesc_64
{
	public StoredSigMethodDesc_64 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


using System;
using MonoMod.Core.Interop.Attributes;

[FatInterfaceImpl(typeof(EEImplMethodDescPtr))]
public struct EEImplMethodDesc_32
{
	public StoredSigMethodDesc_32 @base;

	private static IntPtr[]? fatVtable_;

	public static IntPtr[] FatVtable_ => fatVtable_ ?? (fatVtable_ = new IntPtr[0]);
}


using System;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

[FatInterface]
public struct ComPlusCallInfoPtr
{
	private unsafe readonly void* ptr_;

	private readonly IntPtr[] vtbl_;

	public unsafe static int CurrentSize { get; } = (PlatformDetection.Architecture == ArchitectureKind.x86) ? sizeof(ComPlusCallInfo_x86) : sizeof(ComPlusCallInfo_other);

	public unsafe ComPlusCallInfoPtr(void* ptr, IntPtr[] vtbl)
	{
		ptr_ = ptr;
		vtbl_ = vtbl;
	}
}


public struct ComPlusCallInfo_x86
{
	public unsafe void* union_m_pILStub_pEventProviderMD;

	public unsafe MethodTable* m_pInterfaceMT;

	public byte m_flags;

	public ushort m_cachedComSlot;

	public ushort m_cbStackArgumentSize;

	public unsafe void* union_m_pRetThunk_pInterceptStub;

	private RelativePointer m_pStubMD;
}


public struct ComPlusCallInfo_other
{
	public unsafe void* union_m_pILStub_pEventProviderMD;

	public unsafe MethodTable* m_pInterfaceMT;

	public byte m_flags;

	public ushort m_cachedComSlot;

	private RelativePointer m_pStubMD;
}


public struct ComPlusCallMethodDesc
{
	public MethodDesc @base;

	public unsafe void* m_pComPlusCallInfo;
}


using System;
using MonoMod.Utils;

public struct InstantiatedMethodDesc
{
	[Flags]
	public enum Flags : ushort
	{
		KindMask = 7,
		GenericMethodDefinition = 0,
		UnsharedMethodInstantiation = 1,
		SharedMethodInstantiation = 2,
		WrapperStubWithInstantiations = 3,
		EnCAddedMethod = 7,
		Unrestored = 8,
		HasComPlusCallInfo = 0x10
	}

	public MethodDesc @base;

	public unsafe void* union_pDictLayout_pWrappedMethodDesc;

	public unsafe Dictionary* m_pPerInstInfo;

	public Flags m_wFlags2;

	public ushort m_wNumGenericArgs;

	public unsafe bool IMD_HasMethodInstantiation
	{
		get
		{
			if (!IMD_IsGenericMethodDefinition)
			{
				return m_pPerInstInfo != null;
			}
			return true;
		}
	}

	public bool IMD_IsGenericMethodDefinition => (m_wFlags2 & Flags.KindMask) == 0;

	public bool IMD_IsWrapperStubWithInstantiations => (m_wFlags2 & Flags.KindMask) == Flags.WrapperStubWithInstantiations;

	public bool IMD_HasComPlusCallInfo => m_wFlags2.Has(Flags.HasComPlusCallInfo);

	public unsafe MethodDesc* IMD_GetWrappedMethodDesc()
	{
		Helpers.Assert(IMD_IsWrapperStubWithInstantiations, null, "IMD_IsWrapperStubWithInstantiations");
		return (MethodDesc*)union_pDictLayout_pWrappedMethodDesc;
	}
}


using System;

[Flags]
public enum Flags : ushort
{
	KindMask = 7,
	GenericMethodDefinition = 0,
	UnsharedMethodInstantiation = 1,
	SharedMethodInstantiation = 2,
	WrapperStubWithInstantiations = 3,
	EnCAddedMethod = 7,
	Unrestored = 8,
	HasComPlusCallInfo = 0x10
}


using System.Runtime.CompilerServices;

public struct RelativeFixupPointer
{
	private readonly nint value;

	public unsafe void* Value
	{
		get
		{
			nint num = value;
			if (num == 0)
			{
				return null;
			}
			nint num2 = (nint)((byte*)Unsafe.AsPointer(ref this) + num);
			if ((num2 & 1) != 0)
			{
				num2 = *(nint*)(num2 - 1);
			}
			return (void*)num2;
		}
	}
}


using System;
using System.Runtime.CompilerServices;

public struct MethodDescChunk
{
	[Flags]
	public enum Flags : ushort
	{
		TokenRangeMask = 0x3FF,
		HasCompactEntrypoints = 0x4000,
		IsZapped = 0x8000
	}

	public RelativeFixupPointer m_methodTable;

	public unsafe MethodDescChunk* m_next;

	public byte m_size;

	public byte m_count;

	public Flags m_flagsAndTokenRange;

	public unsafe MethodTable* MethodTable => (MethodTable*)m_methodTable.Value;

	public unsafe MethodDesc* FirstMethodDesc => (MethodDesc*)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodDescChunk));

	public uint Size => (uint)(m_size + 1);

	public uint Count => (uint)(m_count + 1);

	public unsafe nuint SizeOf => (nuint)sizeof(MethodDescChunk) + Size * MethodDesc.Alignment;
}


using System;

[Flags]
public enum Flags : ushort
{
	TokenRangeMask = 0x3FF,
	HasCompactEntrypoints = 0x4000,
	IsZapped = 0x8000
}


public struct Dictionary
{
}


public struct Module
{
}


public struct MethodTableWriteableData
{
}


using System.Runtime.CompilerServices;

public struct RelativePointer
{
	private nint m_delta;

	public unsafe void* Value
	{
		get
		{
			nint delta = m_delta;
			if (delta != 0)
			{
				return Unsafe.AsPointer(ref Unsafe.AddByteOffset(ref this, delta));
			}
			return null;
		}
	}

	public RelativePointer(nint delta)
	{
		m_delta = delta;
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Core.Interop.Attributes;
using MonoMod.Utils;

public struct MethodTable
{
	[Flags]
	public enum WFlagsLow : uint
	{
		UNUSED_ComponentSize_1 = 1u,
		StaticsMask = 6u,
		StaticsMask_NonDynamic = 0u,
		StaticsMask_Dynamic = 2u,
		StaticsMask_Generics = 4u,
		StaticsMask_CrossModuleGenerics = 6u,
		StaticsMask_IfGenericsThenCrossModule = 2u,
		NotInPZM = 8u,
		GenericsMask = 0x30u,
		GenericsMask_NonGeneric = 0u,
		GenericsMask_GenericInst = 0x10u,
		GenericsMask_SharedInst = 0x20u,
		GenericsMask_TypicalInst = 0x30u,
		ContextStatic = 0x40u,
		HasRemotingVtsInfo = 0x80u,
		HasVariance = 0x100u,
		HasDefaultCtor = 0x200u,
		HasPreciseInitCctors = 0x400u,
		IsHFA_IsRegStructPassed = 0x800u,
		IsByRefLike = 0x1000u,
		UNUSED_ComponentSize_5 = 0x2000u,
		UNUSED_ComponentSize_6 = 0x4000u,
		UNUSED_ComponentSize_7 = 0x8000u,
		StringArrayValues = 0u
	}

	[Flags]
	public enum WFlagsHigh : uint
	{
		Category_Mask = 0xF0000u,
		Category_Class = 0u,
		Category_Unused_1 = 0x10000u,
		Category_MarshalByRef_Mask = 0xE0000u,
		Category_MarshalByRef = 0x20000u,
		Category_Contextful = 0x30000u,
		Category_ValueType = 0x40000u,
		Category_ValueType_Mask = 0xC0000u,
		Category_Nullable = 0x50000u,
		Category_PrimitiveValueType = 0x60000u,
		Category_TruePrimitive = 0x70000u,
		Category_Array = 0x80000u,
		Category_Array_Mask = 0xC0000u,
		Category_IfArrayThenSzArray = 0x20000u,
		Category_Interface = 0xC0000u,
		Category_Unused_2 = 0xD0000u,
		Category_TransparentProxy = 0xE0000u,
		Category_AsyncPin = 0xF0000u,
		Category_ElementTypeMask = 0xE0000u,
		HasFinalizer = 0x100000u,
		IfNotInterfaceThenMarshalable = 0x200000u,
		IfInterfaceThenHasGuidInfo = 0x200000u,
		ICastable = 0x400000u,
		HasIndirectParent = 0x800000u,
		ContainsPointers = 0x1000000u,
		HasTypeEquivalence = 0x2000000u,
		HasRCWPerTypeData = 0x4000000u,
		HasCriticalFinalizer = 0x8000000u,
		Collectible = 0x10000000u,
		ContainsGenericVariables = 0x20000000u,
		ComObject = 0x40000000u,
		HasComponentSize = 0x80000000u,
		NonTrivialInterfaceCast = 0x40480000u
	}

	[Flags]
	public enum Flags2 : ushort
	{
		MultipurposeSlotsMask = 0x1F,
		HasPerInstInfo = 1,
		HasInterfaceMap = 2,
		HasDispatchMapSlot = 4,
		HasNonVirtualSlots = 8,
		HasModuleOverride = 0x10,
		IsZapped = 0x20,
		IsPreRestored = 0x40,
		HasModuleDependencies = 0x80,
		NoSecurityProperties = 0x100,
		RequiresDispatchTokenFat = 0x200,
		HasCctor = 0x400,
		HasCCWTemplate = 0x800,
		RequiresAlign8 = 0x1000,
		HasBoxedRegularStatics = 0x2000,
		HasSingleNonVirtualSlot = 0x4000,
		DependsOnEquivalentOrForwardedStructs = 0x8000
	}

	public enum UnionLowBits
	{
		EEClass,
		Invalid,
		MethodTable,
		Indirection
	}

	private static class MultipurposeSlotHelpers
	{
		public unsafe static byte OffsetOfMp1()
		{
			MethodTable methodTable = default(MethodTable);
			return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
		}

		public unsafe static byte OffsetOfMp2()
		{
			MethodTable methodTable = default(MethodTable);
			return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
		}

		public unsafe static byte RegularOffset(int index)
		{
			return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
		}
	}

	private uint m_dwFlags;

	public uint m_BaseSize;

	public Flags2 m_wFlags2;

	public ushort m_wToken;

	public ushort m_wNumVirtuals;

	public ushort m_wNumInterfaces;

	private unsafe void* m_pParentMethodTable;

	public unsafe Module* m_pLoaderModule;

	public unsafe MethodTableWriteableData* m_pWriteableData;

	public unsafe void* union_pEEClass_pCanonMT;

	public unsafe void* union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1;

	public unsafe void* union_p_InterfaceMap_pMultipurposeSlot2;

	public const int VTABLE_SLOTS_PER_CHUNK = 8;

	public const int VTABLE_SLOTS_PER_CHUNK_LOG2 = 3;

	private static readonly byte[] c_NonVirtualSlotsOffsets = GetNonVirtualSlotsOffsets();

	public WFlagsHigh FlagsHigh => (WFlagsHigh)(m_dwFlags & 0xFFFF0000u);

	public WFlagsLow FlagsLow
	{
		get
		{
			if (!FlagsHigh.Has(WFlagsHigh.HasComponentSize))
			{
				return (WFlagsLow)(m_dwFlags & 0xFFFF);
			}
			return WFlagsLow.StaticsMask_NonDynamic;
		}
	}

	public int ComponentSize
	{
		get
		{
			if (!FlagsHigh.Has(WFlagsHigh.HasComponentSize))
			{
				return 0;
			}
			return (int)(m_dwFlags & 0xFFFF);
		}
	}

	public bool IsInterface => (m_dwFlags & 0xF0000) == 786432;

	public bool HasIndirectParent => FlagsHigh.Has(WFlagsHigh.HasIndirectParent);

	public unsafe MethodTable* ParentMethodTable
	{
		get
		{
			void* pParentMethodTable = m_pParentMethodTable;
			if (HasIndirectParent)
			{
				return (MethodTable*)((MethodTable*)pParentMethodTable)->m_pParentMethodTable;
			}
			return (MethodTable*)pParentMethodTable;
		}
	}

	public bool HasSingleNonVirtualSlot => m_wFlags2.Has(Flags2.HasSingleNonVirtualSlot);

	public unsafe MethodTable* GetCanonicalMethodTable()
	{
		nuint num = (nuint)union_pEEClass_pCanonMT;
		if ((num & 2) == 0)
		{
			return (MethodTable*)num;
		}
		if ((num & 1) != 0)
		{
			return *(MethodTable**)(num - 3);
		}
		return (MethodTable*)(num - 2);
	}

	public unsafe MethodDesc* GetParallelMethodDesc(MethodDesc* pDefMD)
	{
		return GetMethodDescForSlot(pDefMD->SlotNumber);
	}

	public unsafe MethodDesc* GetMethodDescForSlot(uint slotNumber)
	{
		if (IsInterface)
		{
			GetNumVirtuals();
		}
		throw new NotImplementedException();
	}

	public unsafe void* GetRestoredSlot(uint slotNumber)
	{
		MethodTable* ptr = (MethodTable*)Unsafe.AsPointer(ref this);
		void* slot;
		while (true)
		{
			ptr = ptr->GetCanonicalMethodTable();
			slot = ptr->GetSlot(slotNumber);
			if (slot != null)
			{
				break;
			}
			ptr = ptr->ParentMethodTable;
		}
		return slot;
	}

	public unsafe void* GetSlot(uint slotNumber)
	{
		return *(void**)GetSlotPtrRaw(slotNumber);
	}

	public unsafe nint GetSlotPtrRaw(uint slotNum)
	{
		if (slotNum < GetNumVirtuals())
		{
			uint indexOfVtableIndirection = GetIndexOfVtableIndirection(slotNum);
			void** ptr = (void**)GetVtableIndirections()[indexOfVtableIndirection];
			return (nint)(ptr + GetIndexAfterVtableIndirection(slotNum));
		}
		if (HasSingleNonVirtualSlot)
		{
			return GetNonVirtualSlotsPtr();
		}
		return (nint)(GetNonVirtualSlotsArray() + (slotNum - GetNumVirtuals()));
	}

	public ushort GetNumVirtuals()
	{
		return m_wNumVirtuals;
	}

	public static uint GetIndexOfVtableIndirection(uint slotNum)
	{
		return slotNum >> 3;
	}

	public unsafe void** GetVtableIndirections()
	{
		return (void**)((byte*)Unsafe.AsPointer(ref this) + sizeof(MethodTable));
	}

	public static uint GetIndexAfterVtableIndirection(uint slotNum)
	{
		return slotNum & 7;
	}

	[MultipurposeSlotOffsetTable(3, typeof(MultipurposeSlotHelpers))]
	private static byte[] GetNonVirtualSlotsOffsets()
	{
		return new byte[8]
		{
			MultipurposeSlotHelpers.OffsetOfMp1(),
			MultipurposeSlotHelpers.OffsetOfMp2(),
			MultipurposeSlotHelpers.OffsetOfMp1(),
			MultipurposeSlotHelpers.RegularOffset(2),
			MultipurposeSlotHelpers.OffsetOfMp2(),
			MultipurposeSlotHelpers.RegularOffset(2),
			MultipurposeSlotHelpers.RegularOffset(2),
			MultipurposeSlotHelpers.RegularOffset(3)
		};
	}

	public nint GetNonVirtualSlotsPtr()
	{
		return GetMultipurposeSlotPtr(Flags2.HasNonVirtualSlots, c_NonVirtualSlotsOffsets);
	}

	public unsafe nint GetMultipurposeSlotPtr(Flags2 flag, byte[] offsets)
	{
		nint num = offsets[(uint)(m_wFlags2 & (flag - 1))];
		if (num >= sizeof(MethodTable))
		{
			num += (nint)GetNumVTableIndirections() * (nint)sizeof(void**);
		}
		return (nint)((byte*)Unsafe.AsPointer(ref this) + num);
	}

	public unsafe void** GetNonVirtualSlotsArray()
	{
		return (void**)((RelativePointer*)GetNonVirtualSlotsPtr())->Value;
	}

	public uint GetNumVTableIndirections()
	{
		return GetNumVtableIndirections(GetNumVirtuals());
	}

	public static uint GetNumVtableIndirections(uint numVirtuals)
	{
		return numVirtuals + 7 >> 3;
	}
}


using System;

[Flags]
public enum WFlagsLow : uint
{
	UNUSED_ComponentSize_1 = 1u,
	StaticsMask = 6u,
	StaticsMask_NonDynamic = 0u,
	StaticsMask_Dynamic = 2u,
	StaticsMask_Generics = 4u,
	StaticsMask_CrossModuleGenerics = 6u,
	StaticsMask_IfGenericsThenCrossModule = 2u,
	NotInPZM = 8u,
	GenericsMask = 0x30u,
	GenericsMask_NonGeneric = 0u,
	GenericsMask_GenericInst = 0x10u,
	GenericsMask_SharedInst = 0x20u,
	GenericsMask_TypicalInst = 0x30u,
	ContextStatic = 0x40u,
	HasRemotingVtsInfo = 0x80u,
	HasVariance = 0x100u,
	HasDefaultCtor = 0x200u,
	HasPreciseInitCctors = 0x400u,
	IsHFA_IsRegStructPassed = 0x800u,
	IsByRefLike = 0x1000u,
	UNUSED_ComponentSize_5 = 0x2000u,
	UNUSED_ComponentSize_6 = 0x4000u,
	UNUSED_ComponentSize_7 = 0x8000u,
	StringArrayValues = 0u
}


using System;

[Flags]
public enum WFlagsHigh : uint
{
	Category_Mask = 0xF0000u,
	Category_Class = 0u,
	Category_Unused_1 = 0x10000u,
	Category_MarshalByRef_Mask = 0xE0000u,
	Category_MarshalByRef = 0x20000u,
	Category_Contextful = 0x30000u,
	Category_ValueType = 0x40000u,
	Category_ValueType_Mask = 0xC0000u,
	Category_Nullable = 0x50000u,
	Category_PrimitiveValueType = 0x60000u,
	Category_TruePrimitive = 0x70000u,
	Category_Array = 0x80000u,
	Category_Array_Mask = 0xC0000u,
	Category_IfArrayThenSzArray = 0x20000u,
	Category_Interface = 0xC0000u,
	Category_Unused_2 = 0xD0000u,
	Category_TransparentProxy = 0xE0000u,
	Category_AsyncPin = 0xF0000u,
	Category_ElementTypeMask = 0xE0000u,
	HasFinalizer = 0x100000u,
	IfNotInterfaceThenMarshalable = 0x200000u,
	IfInterfaceThenHasGuidInfo = 0x200000u,
	ICastable = 0x400000u,
	HasIndirectParent = 0x800000u,
	ContainsPointers = 0x1000000u,
	HasTypeEquivalence = 0x2000000u,
	HasRCWPerTypeData = 0x4000000u,
	HasCriticalFinalizer = 0x8000000u,
	Collectible = 0x10000000u,
	ContainsGenericVariables = 0x20000000u,
	ComObject = 0x40000000u,
	HasComponentSize = 0x80000000u,
	NonTrivialInterfaceCast = 0x40480000u
}


using System;

[Flags]
public enum Flags2 : ushort
{
	MultipurposeSlotsMask = 0x1F,
	HasPerInstInfo = 1,
	HasInterfaceMap = 2,
	HasDispatchMapSlot = 4,
	HasNonVirtualSlots = 8,
	HasModuleOverride = 0x10,
	IsZapped = 0x20,
	IsPreRestored = 0x40,
	HasModuleDependencies = 0x80,
	NoSecurityProperties = 0x100,
	RequiresDispatchTokenFat = 0x200,
	HasCctor = 0x400,
	HasCCWTemplate = 0x800,
	RequiresAlign8 = 0x1000,
	HasBoxedRegularStatics = 0x2000,
	HasSingleNonVirtualSlot = 0x4000,
	DependsOnEquivalentOrForwardedStructs = 0x8000
}


public enum UnionLowBits
{
	EEClass,
	Invalid,
	MethodTable,
	Indirection
}


using System;

private static class MultipurposeSlotHelpers
{
	public unsafe static byte OffsetOfMp1()
	{
		MethodTable methodTable = default(MethodTable);
		return (byte)((byte*)(&methodTable.union_pPerInstInfo_ElementTypeHnd_pMultipurposeSlot1) - (byte*)(&methodTable));
	}

	public unsafe static byte OffsetOfMp2()
	{
		MethodTable methodTable = default(MethodTable);
		return (byte)((byte*)(&methodTable.union_p_InterfaceMap_pMultipurposeSlot2) - (byte*)(&methodTable));
	}

	public unsafe static byte RegularOffset(int index)
	{
		return (byte)(sizeof(MethodTable) + index * IntPtr.Size - 2 * IntPtr.Size);
	}
}


using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using MonoMod.Core.Interop;
using MonoMod.Logs;
using MonoMod.Utils;

internal static class OSX
{
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct vm_region_submap_short_info_64
	{
		public vm_prot_t protection;

		public vm_prot_t max_protection;

		public vm_inherit_t inheritance;

		public ulong offset;

		public uint user_tag;

		public uint ref_count;

		public ushort shadow_depth;

		public byte external_pager;

		public ShareMode share_mode;

		public boolean_t is_submap;

		public vm_behavior_t behavior;

		public uint object_id;

		public ushort user_wired_count;

		public unsafe static int Count => sizeof(vm_region_submap_short_info_64) / 4;
	}

	public enum ShareMode : byte
	{
		COW = 1,
		Private,
		Empty,
		Shared,
		TrueShared,
		PrivateAliased,
		SharedAliased,
		LargePage
	}

	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	public struct task_dyld_info
	{
		public ulong all_image_info_addr;

		public ulong all_image_info_size;

		public task_dyld_all_image_info_format all_image_info_format;

		public unsafe dyld_all_image_infos* all_image_infos => (dyld_all_image_infos*)all_image_info_addr;

		public unsafe static int Count => sizeof(task_dyld_info) / 4;
	}

	public struct dyld_all_image_infos
	{
		public uint version;

		public uint infoArrayCount;

		public unsafe dyld_image_info* infoArray;

		public unsafe ReadOnlySpan<dyld_image_info> InfoArray => new ReadOnlySpan<dyld_image_info>(infoArray, (int)infoArrayCount);
	}

	public struct dyld_image_info
	{
		public unsafe void* imageLoadAddress;

		public PCSTR imageFilePath;

		public nuint imageFileModDate;
	}

	public enum task_dyld_all_image_info_format
	{
		Bits32,
		Bits64
	}

	public enum task_flavor_t : uint
	{
		DyldInfo = 17u
	}

	public enum vm_region_flavor_t
	{
		BasicInfo64 = 9
	}

	[Flags]
	public enum vm_prot_t
	{
		None = 0,
		Read = 1,
		Write = 2,
		Execute = 4,
		Default = 3,
		All = 7,
		[Obsolete("Only used for memory_object_lock_request. Invalid otherwise.")]
		NoChange = 8,
		Copy = 0x10,
		WantsCopy = 0x10,
		[Obsolete("Invalid value. Indicates that other bits are to be applied as mask to actual bits.")]
		IsMask = 0x40,
		[Obsolete("Invalid value. Tells mprotect to not set Read. Used for execute-only.")]
		StripRead = 0x80,
		[Obsolete("Invalid value. Use only for mprotect.")]
		ExecuteOnly = 0x84
	}

	public struct VmProtFmtProxy : IDebugFormattable
	{
		private readonly vm_prot_t value;

		public VmProtFmtProxy(vm_prot_t value)
		{
			this.value = value;
		}

		public bool TryFormatInto(Span<char> span, out int wrote)
		{
			int num = 0;
			if (value.Has(vm_prot_t.NoChange))
			{
				if (span.Slice(num).Length < 1)
				{
					wrote = num;
					return false;
				}
				span[num++] = '~';
			}
			if (span.Slice(num).Length < 3)
			{
				wrote = 0;
				return false;
			}
			span[num++] = (value.Has(vm_prot_t.Read) ? 'r' : '-');
			span[num++] = (value.Has(vm_prot_t.Write) ? 'w' : '-');
			span[num++] = (value.Has(vm_prot_t.Execute) ? 'x' : '-');
			if (value.Has(vm_prot_t.StripRead))
			{
				if (span.Slice(num).Length < 1)
				{
					wrote = num;
					return false;
				}
				span[num++] = '!';
			}
			if (value.Has(vm_prot_t.Copy))
			{
				if (span.Slice(num).Length < 1)
				{
					wrote = num;
					return false;
				}
				span[num++] = 'c';
			}
			if (value.Has(vm_prot_t.IsMask))
			{
				if (span.Slice(num).Length < " (mask)".Length)
				{
					wrote = num;
					return false;
				}
				MemoryExtensions.AsSpan(" (mask)").CopyTo(span.Slice(num));
				num += " (mask)".Length;
			}
			wrote = num;
			return true;
		}
	}

	[Flags]
	public enum vm_flags
	{
		Fixed = 0,
		Anywhere = 1,
		Purgable = 2,
		Chunk4GB = 4,
		RandomAddr = 8,
		NoCache = 0x10,
		Overwrite = 0x4000,
		SuperpageMask = 0x70000,
		SuperpageSizeAny = 0x10000,
		SuperpageWSize2MB = 0x20000,
		AliasMask = -16777216
	}

	public enum vm_inherit_t : uint
	{
		Share = 0u,
		Copy = 1u,
		None = 2u,
		DonateCopy = 3u,
		Default = 1u,
		LastValid = 2u
	}

	public enum vm_behavior_t
	{
		Default,
		Random,
		Sequential,
		ReverseSequential,
		WillNeed,
		DontNeed,
		Free,
		ZeroWiredPages,
		Reusable,
		Reuse,
		CanReuse,
		PageOut
	}

	[DebuggerDisplay("{ToString(),nq}")]
	public struct boolean_t
	{
		private int value;

		public boolean_t(bool value)
		{
			this.value = (value ? 1 : 0);
		}

		public static implicit operator bool(boolean_t v)
		{
			return v.value != 0;
		}

		public static implicit operator boolean_t(bool v)
		{
			return new boolean_t(v);
		}

		public static bool operator true(boolean_t v)
		{
			return v;
		}

		public static bool operator false(boolean_t v)
		{
			return !v;
		}

		public override string ToString()
		{
			if (!this)
			{
				return "false";
			}
			return "true";
		}
	}

	[DebuggerDisplay("{Value}")]
	public struct kern_return_t : IEquatable<kern_return_t>
	{
		private int value;

		public static kern_return_t Success = new kern_return_t(0);

		public static kern_return_t InvalidAddress = new kern_return_t(1);

		public static kern_return_t ProtectionFailure = new kern_return_t(2);

		public static kern_return_t NoSpace = new kern_return_t(3);

		public static kern_return_t InvalidArgument = new kern_return_t(4);

		public static kern_return_t Failure = new kern_return_t(5);

		public int Value => value;

		public kern_return_t(int value)
		{
			this.value = value;
		}

		public static implicit operator bool(kern_return_t v)
		{
			return v.value == 0;
		}

		public static bool operator ==(kern_return_t x, kern_return_t y)
		{
			return x.value == y.value;
		}

		public static bool operator !=(kern_return_t x, kern_return_t y)
		{
			return x.value != y.value;
		}

		public override bool Equals(object? obj)
		{
			if (obj is kern_return_t other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(kern_return_t other)
		{
			return value == other.value;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(value);
		}
	}

	public const string LibSystem = "libSystem";

	private unsafe static int* mach_task_self_;

	public unsafe static int Errno => *__error();

	[DllImport("libSystem", EntryPoint = "getpagesize")]
	public static extern int GetPageSize();

	[DllImport("libSystem")]
	public unsafe static extern void sys_icache_invalidate(void* start, nuint size);

	[DllImport("libSystem", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mkstemp")]
	public unsafe static extern int MkSTemp(byte* template);

	[DllImport("libSystem", CallingConvention = CallingConvention.Cdecl)]
	public unsafe static extern int* __error();

	[DllImport("libSystem")]
	public unsafe static extern kern_return_t mach_vm_region_recurse(int targetTask, [In][Out] ulong* address, [Out] ulong* size, [In][Out] int* nestingDepth, [Out] vm_region_submap_short_info_64* info, [In][Out] int* infoSize);

	[DllImport("libSystem")]
	public static extern kern_return_t mach_vm_protect(int targetTask, ulong address, ulong size, boolean_t setMax, vm_prot_t protection);

	[DllImport("libSystem")]
	public unsafe static extern kern_return_t mach_vm_allocate(int targetTask, [In][Out] ulong* address, ulong size, vm_flags flags);

	[DllImport("libSystem")]
	public unsafe static extern kern_return_t mach_vm_map(int targetTask, [In][Out] ulong* address, ulong size, ulong mask, vm_flags flags, int @object, ulong offset, boolean_t copy, vm_prot_t curProt, vm_prot_t maxProt, vm_inherit_t inheritance);

	[DllImport("libSystem")]
	public unsafe static extern kern_return_t mach_vm_remap(int targetTask, [In][Out] ulong* targetAddress, ulong size, ulong offset, vm_flags flags, int srcTask, ulong srcAddress, boolean_t copy, [Out] vm_prot_t* curProt, [Out] vm_prot_t* maxProt, vm_inherit_t inherit);

	[DllImport("libSystem")]
	public unsafe static extern kern_return_t mach_make_memory_entry_64(int targetTask, [In][Out] ulong* size, ulong offset, vm_prot_t permission, int* objectHandle, int parentHandle);

	[DllImport("libSystem")]
	public static extern kern_return_t mach_vm_deallocate(int targetTask, ulong address, ulong size);

	public unsafe static int mach_task_self()
	{
		int* ptr = mach_task_self_;
		if (ptr == null)
		{
			IntPtr intPtr = DynDll.OpenLibrary("libSystem");
			try
			{
				ptr = (mach_task_self_ = (int*)(void*)intPtr.GetExport("mach_task_self_"));
			}
			finally
			{
				DynDll.CloseLibrary(intPtr);
			}
		}
		return *ptr;
	}

	[DllImport("libSystem")]
	public unsafe static extern kern_return_t task_info(int targetTask, task_flavor_t flavor, [Out] task_dyld_info* taskInfoOut, int* taskInfoCnt);

	public static VmProtFmtProxy P(vm_prot_t prot)
	{
		return new VmProtFmtProxy(prot);
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct vm_region_submap_short_info_64
{
	public vm_prot_t protection;

	public vm_prot_t max_protection;

	public vm_inherit_t inheritance;

	public ulong offset;

	public uint user_tag;

	public uint ref_count;

	public ushort shadow_depth;

	public byte external_pager;

	public ShareMode share_mode;

	public boolean_t is_submap;

	public vm_behavior_t behavior;

	public uint object_id;

	public ushort user_wired_count;

	public unsafe static int Count => sizeof(vm_region_submap_short_info_64) / 4;
}


public enum ShareMode : byte
{
	COW = 1,
	Private,
	Empty,
	Shared,
	TrueShared,
	PrivateAliased,
	SharedAliased,
	LargePage
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Pack = 4)]
public struct task_dyld_info
{
	public ulong all_image_info_addr;

	public ulong all_image_info_size;

	public task_dyld_all_image_info_format all_image_info_format;

	public unsafe dyld_all_image_infos* all_image_infos => (dyld_all_image_infos*)all_image_info_addr;

	public unsafe static int Count => sizeof(task_dyld_info) / 4;
}


using System;

public struct dyld_all_image_infos
{
	public uint version;

	public uint infoArrayCount;

	public unsafe dyld_image_info* infoArray;

	public unsafe ReadOnlySpan<dyld_image_info> InfoArray => new ReadOnlySpan<dyld_image_info>(infoArray, (int)infoArrayCount);
}


public struct dyld_image_info
{
	public unsafe void* imageLoadAddress;

	public PCSTR imageFilePath;

	public nuint imageFileModDate;
}


public enum task_dyld_all_image_info_format
{
	Bits32,
	Bits64
}


public enum task_flavor_t : uint
{
	DyldInfo = 17u
}


public enum vm_region_flavor_t
{
	BasicInfo64 = 9
}


using System;

[Flags]
public enum vm_prot_t
{
	None = 0,
	Read = 1,
	Write = 2,
	Execute = 4,
	Default = 3,
	All = 7,
	[Obsolete("Only used for memory_object_lock_request. Invalid otherwise.")]
	NoChange = 8,
	Copy = 0x10,
	WantsCopy = 0x10,
	[Obsolete("Invalid value. Indicates that other bits are to be applied as mask to actual bits.")]
	IsMask = 0x40,
	[Obsolete("Invalid value. Tells mprotect to not set Read. Used for execute-only.")]
	StripRead = 0x80,
	[Obsolete("Invalid value. Use only for mprotect.")]
	ExecuteOnly = 0x84
}


using System;
using MonoMod.Logs;
using MonoMod.Utils;

public struct VmProtFmtProxy : IDebugFormattable
{
	private readonly vm_prot_t value;

	public VmProtFmtProxy(vm_prot_t value)
	{
		this.value = value;
	}

	public bool TryFormatInto(Span<char> span, out int wrote)
	{
		int num = 0;
		if (value.Has(vm_prot_t.NoChange))
		{
			if (span.Slice(num).Length < 1)
			{
				wrote = num;
				return false;
			}
			span[num++] = '~';
		}
		if (span.Slice(num).Length < 3)
		{
			wrote = 0;
			return false;
		}
		span[num++] = (value.Has(vm_prot_t.Read) ? 'r' : '-');
		span[num++] = (value.Has(vm_prot_t.Write) ? 'w' : '-');
		span[num++] = (value.Has(vm_prot_t.Execute) ? 'x' : '-');
		if (value.Has(vm_prot_t.StripRead))
		{
			if (span.Slice(num).Length < 1)
			{
				wrote = num;
				return false;
			}
			span[num++] = '!';
		}
		if (value.Has(vm_prot_t.Copy))
		{
			if (span.Slice(num).Length < 1)
			{
				wrote = num;
				return false;
			}
			span[num++] = 'c';
		}
		if (value.Has(vm_prot_t.IsMask))
		{
			if (span.Slice(num).Length < " (mask)".Length)
			{
				wrote = num;
				return false;
			}
			MemoryExtensions.AsSpan(" (mask)").CopyTo(span.Slice(num));
			num += " (mask)".Length;
		}
		wrote = num;
		return true;
	}
}


using System;

[Flags]
public enum vm_flags
{
	Fixed = 0,
	Anywhere = 1,
	Purgable = 2,
	Chunk4GB = 4,
	RandomAddr = 8,
	NoCache = 0x10,
	Overwrite = 0x4000,
	SuperpageMask = 0x70000,
	SuperpageSizeAny = 0x10000,
	SuperpageWSize2MB = 0x20000,
	AliasMask = -16777216
}


public enum vm_inherit_t : uint
{
	Share = 0u,
	Copy = 1u,
	None = 2u,
	DonateCopy = 3u,
	Default = 1u,
	LastValid = 2u
}


public enum vm_behavior_t
{
	Default,
	Random,
	Sequential,
	ReverseSequential,
	WillNeed,
	DontNeed,
	Free,
	ZeroWiredPages,
	Reusable,
	Reuse,
	CanReuse,
	PageOut
}


using System.Diagnostics;

[DebuggerDisplay("{ToString(),nq}")]
public struct boolean_t
{
	private int value;

	public boolean_t(bool value)
	{
		this.value = (value ? 1 : 0);
	}

	public static implicit operator bool(boolean_t v)
	{
		return v.value != 0;
	}

	public static implicit operator boolean_t(bool v)
	{
		return new boolean_t(v);
	}

	public static bool operator true(boolean_t v)
	{
		return v;
	}

	public static bool operator false(boolean_t v)
	{
		return !v;
	}

	public override string ToString()
	{
		if (!this)
		{
			return "false";
		}
		return "true";
	}
}


using System;
using System.Diagnostics;

[DebuggerDisplay("{Value}")]
public struct kern_return_t : IEquatable<kern_return_t>
{
	private int value;

	public static kern_return_t Success = new kern_return_t(0);

	public static kern_return_t InvalidAddress = new kern_return_t(1);

	public static kern_return_t ProtectionFailure = new kern_return_t(2);

	public static kern_return_t NoSpace = new kern_return_t(3);

	public static kern_return_t InvalidArgument = new kern_return_t(4);

	public static kern_return_t Failure = new kern_return_t(5);

	public int Value => value;

	public kern_return_t(int value)
	{
		this.value = value;
	}

	public static implicit operator bool(kern_return_t v)
	{
		return v.value == 0;
	}

	public static bool operator ==(kern_return_t x, kern_return_t y)
	{
		return x.value == y.value;
	}

	public static bool operator !=(kern_return_t x, kern_return_t y)
	{
		return x.value != y.value;
	}

	public override bool Equals(object? obj)
	{
		if (obj is kern_return_t other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(kern_return_t other)
	{
		return value == other.value;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(value);
	}
}


using System;
using System.Diagnostics;
using System.Text;
using MonoMod.Core.Interop;

[DebuggerDisplay("{DebuggerDisplay}")]
internal readonly struct PCSTR : IEquatable<PCSTR>
{
	internal unsafe readonly byte* Value;

	internal unsafe int Length
	{
		get
		{
			byte* ptr = Value;
			if (ptr == null)
			{
				return 0;
			}
			for (; *ptr != 0; ptr++)
			{
			}
			return checked((int)(ptr - Value));
		}
	}

	private string? DebuggerDisplay => ToString();

	internal unsafe PCSTR(byte* value)
	{
		Value = value;
	}

	public unsafe static implicit operator byte*(PCSTR value)
	{
		return value.Value;
	}

	public unsafe static explicit operator PCSTR(byte* value)
	{
		return new PCSTR(value);
	}

	public unsafe bool Equals(PCSTR other)
	{
		return Value == other.Value;
	}

	public override bool Equals(object? obj)
	{
		if (obj is PCSTR other)
		{
			return Equals(other);
		}
		return false;
	}

	public unsafe override int GetHashCode()
	{
		return (int)Value;
	}

	public unsafe override string? ToString()
	{
		if (Value != null)
		{
			return new string((sbyte*)Value, 0, Length, Encoding.UTF8);
		}
		return null;
	}

	internal unsafe ReadOnlySpan<byte> AsSpan()
	{
		if (Value != null)
		{
			return new ReadOnlySpan<byte>(Value, Length);
		}
		return default(ReadOnlySpan<byte>);
	}
}


using System;
using System.Runtime.InteropServices;
using MonoMod.Core.Interop;

internal static class Unix
{
	[Flags]
	public enum PipeFlags
	{
		CloseOnExec = 0x80000
	}

	[Flags]
	public enum Protection
	{
		None = 0,
		Read = 1,
		Write = 2,
		Execute = 4
	}

	[Flags]
	public enum MmapFlags
	{
		Shared = 1,
		Private = 2,
		SharedValidate = 3,
		Fixed = 0x10,
		Anonymous = 0x20,
		GrowsDown = 0x100,
		DenyWrite = 0x800,
		[Obsolete("Use Protection.Execute instead", true)]
		Executable = 0x1000,
		Locked = 0x2000,
		NoReserve = 0x4000,
		Populate = 0x8000,
		NonBlock = 0x10000,
		Stack = 0x20000,
		HugeTLB = 0x40000,
		Sync = 0x80000,
		FixedNoReplace = 0x100000
	}

	public enum SysconfName
	{
		ArgMax,
		ChildMax,
		ClockTick,
		NGroupsMax,
		OpenMax,
		StreamMax,
		TZNameMax,
		JobControl,
		SavedIds,
		RealtimeSignals,
		PriorityScheduling,
		Timers,
		AsyncIO,
		PrioritizedIO,
		SynchronizedIO,
		FSync,
		MappedFiles,
		MemLock,
		MemLockRange,
		MemoryProtection,
		MessagePassing,
		Semaphores,
		SharedMemoryObjects,
		AIOListIOMax,
		AIOMax,
		AIOPrioDeltaMax,
		DelayTimerMax,
		MQOpenMax,
		MQPrioMax,
		Version,
		PageSize,
		RTSigMax,
		SemNSemsMax,
		SemValueMax,
		SigQueueMax,
		TimerMax
	}

	public const string LibC = "libc";

	public unsafe static int Errno => *__errno_location();

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "read")]
	public static extern nint Read(int fd, IntPtr buf, nint count);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "write")]
	public static extern nint Write(int fd, IntPtr buf, nint count);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "pipe2")]
	public unsafe static extern int Pipe2(int* pipefd, PipeFlags flags);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mmap")]
	public static extern nint Mmap(IntPtr addr, nuint length, Protection prot, MmapFlags flags, int fd, int offset);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "munmap")]
	public static extern int Munmap(IntPtr addr, nuint length);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mprotect")]
	public static extern int Mprotect(IntPtr addr, nuint len, Protection prot);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "sysconf")]
	public static extern long Sysconf(SysconfName name);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mincore")]
	public unsafe static extern int Mincore(IntPtr addr, nuint len, byte* vec);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "mkstemp")]
	public unsafe static extern int MkSTemp(byte* template);

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl)]
	public unsafe static extern int* __errno_location();
}


using System;

[Flags]
public enum PipeFlags
{
	CloseOnExec = 0x80000
}


using System;

[Flags]
public enum Protection
{
	None = 0,
	Read = 1,
	Write = 2,
	Execute = 4
}


using System;

[Flags]
public enum MmapFlags
{
	Shared = 1,
	Private = 2,
	SharedValidate = 3,
	Fixed = 0x10,
	Anonymous = 0x20,
	GrowsDown = 0x100,
	DenyWrite = 0x800,
	[Obsolete("Use Protection.Execute instead", true)]
	Executable = 0x1000,
	Locked = 0x2000,
	NoReserve = 0x4000,
	Populate = 0x8000,
	NonBlock = 0x10000,
	Stack = 0x20000,
	HugeTLB = 0x40000,
	Sync = 0x80000,
	FixedNoReplace = 0x100000
}


public enum SysconfName
{
	ArgMax,
	ChildMax,
	ClockTick,
	NGroupsMax,
	OpenMax,
	StreamMax,
	TZNameMax,
	JobControl,
	SavedIds,
	RealtimeSignals,
	PriorityScheduling,
	Timers,
	AsyncIO,
	PrioritizedIO,
	SynchronizedIO,
	FSync,
	MappedFiles,
	MemLock,
	MemLockRange,
	MemoryProtection,
	MessagePassing,
	Semaphores,
	SharedMemoryObjects,
	AIOListIOMax,
	AIOMax,
	AIOPrioDeltaMax,
	DelayTimerMax,
	MQOpenMax,
	MQPrioMax,
	Version,
	PageSize,
	RTSigMax,
	SemNSemsMax,
	SemValueMax,
	SigQueueMax,
	TimerMax
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MonoMod.Core.Interop;

internal static class Windows
{
	[Conditional("NEVER")]
	[AttributeUsage(AttributeTargets.All)]
	private sealed class SetsLastSystemErrorAttribute : Attribute
	{
	}

	[Conditional("NEVER")]
	[AttributeUsage(AttributeTargets.All)]
	private sealed class NativeTypeNameAttribute : Attribute
	{
		public NativeTypeNameAttribute(string x)
		{
		}
	}

	public struct MEMORY_BASIC_INFORMATION
	{
		public unsafe void* BaseAddress;

		public unsafe void* AllocationBase;

		public uint AllocationProtect;

		public nuint RegionSize;

		public uint State;

		public uint Protect;

		public uint Type;
	}

	public struct SYSTEM_INFO
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct _Anonymous_e__Union
		{
			public struct _Anonymous_e__Struct
			{
				public ushort wProcessorArchitecture;

				public ushort wReserved;
			}

			[FieldOffset(0)]
			public uint dwOemId;

			[FieldOffset(0)]
			public _Anonymous_e__Struct Anonymous;
		}

		public _Anonymous_e__Union Anonymous;

		public uint dwPageSize;

		public unsafe void* lpMinimumApplicationAddress;

		public unsafe void* lpMaximumApplicationAddress;

		public nuint dwActiveProcessorMask;

		public uint dwNumberOfProcessors;

		public uint dwProcessorType;

		public uint dwAllocationGranularity;

		public ushort wProcessorLevel;

		public ushort wProcessorRevision;

		[UnscopedRef]
		public ref uint dwOemId
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref Anonymous.dwOemId;
			}
		}

		[UnscopedRef]
		public ref ushort wProcessorArchitecture
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref Anonymous.Anonymous.wProcessorArchitecture;
			}
		}

		[UnscopedRef]
		public ref ushort wReserved
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref Anonymous.Anonymous.wReserved;
			}
		}
	}

	public readonly struct BOOL : IComparable, IComparable<BOOL>, IEquatable<BOOL>, IFormattable
	{
		public readonly int Value;

		public static BOOL FALSE => new BOOL(0);

		public static BOOL TRUE => new BOOL(1);

		public BOOL(int value)
		{
			Value = value;
		}

		public static bool operator ==(BOOL left, BOOL right)
		{
			return left.Value == right.Value;
		}

		public static bool operator !=(BOOL left, BOOL right)
		{
			return left.Value != right.Value;
		}

		public static bool operator <(BOOL left, BOOL right)
		{
			return left.Value < right.Value;
		}

		public static bool operator <=(BOOL left, BOOL right)
		{
			return left.Value <= right.Value;
		}

		public static bool operator >(BOOL left, BOOL right)
		{
			return left.Value > right.Value;
		}

		public static bool operator >=(BOOL left, BOOL right)
		{
			return left.Value >= right.Value;
		}

		public static implicit operator bool(BOOL value)
		{
			return value.Value != 0;
		}

		public static implicit operator BOOL(bool value)
		{
			return new BOOL(value ? 1 : 0);
		}

		public static bool operator false(BOOL value)
		{
			return value.Value == 0;
		}

		public static bool operator true(BOOL value)
		{
			return value.Value != 0;
		}

		public static implicit operator BOOL(byte value)
		{
			return new BOOL(value);
		}

		public static explicit operator byte(BOOL value)
		{
			return (byte)value.Value;
		}

		public static implicit operator BOOL(short value)
		{
			return new BOOL(value);
		}

		public static explicit operator short(BOOL value)
		{
			return (short)value.Value;
		}

		public static implicit operator BOOL(int value)
		{
			return new BOOL(value);
		}

		public static implicit operator int(BOOL value)
		{
			return value.Value;
		}

		public static explicit operator BOOL(long value)
		{
			return new BOOL((int)value);
		}

		public static implicit operator long(BOOL value)
		{
			return value.Value;
		}

		public static explicit operator BOOL(nint value)
		{
			return new BOOL((int)value);
		}

		public static implicit operator nint(BOOL value)
		{
			return value.Value;
		}

		public static implicit operator BOOL(sbyte value)
		{
			return new BOOL(value);
		}

		public static explicit operator sbyte(BOOL value)
		{
			return (sbyte)value.Value;
		}

		public static implicit operator BOOL(ushort value)
		{
			return new BOOL(value);
		}

		public static explicit operator ushort(BOOL value)
		{
			return (ushort)value.Value;
		}

		public static explicit operator BOOL(uint value)
		{
			return new BOOL((int)value);
		}

		public static explicit operator uint(BOOL value)
		{
			return (uint)value.Value;
		}

		public static explicit operator BOOL(ulong value)
		{
			return new BOOL((int)value);
		}

		public static explicit operator ulong(BOOL value)
		{
			return (ulong)value.Value;
		}

		public static explicit operator BOOL(nuint value)
		{
			return new BOOL((int)value);
		}

		public static explicit operator nuint(BOOL value)
		{
			return (nuint)value.Value;
		}

		public int CompareTo(object? obj)
		{
			if (obj is BOOL other)
			{
				return CompareTo(other);
			}
			if (obj != null)
			{
				throw new ArgumentException("obj is not an instance of BOOL.");
			}
			return 1;
		}

		public int CompareTo(BOOL other)
		{
			int value = Value;
			return value.CompareTo(other.Value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is BOOL other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(BOOL other)
		{
			int value = Value;
			return value.Equals(other.Value);
		}

		public override int GetHashCode()
		{
			int value = Value;
			return value.GetHashCode();
		}

		public override string ToString()
		{
			int value = Value;
			return value.ToString((IFormatProvider?)null);
		}

		public string ToString(string? format, IFormatProvider? formatProvider)
		{
			int value = Value;
			return value.ToString(format, formatProvider);
		}
	}

	public readonly struct HANDLE : IComparable, IComparable<HANDLE>, IEquatable<HANDLE>, IFormattable
	{
		public unsafe readonly void* Value;

		public unsafe static HANDLE INVALID_VALUE => new HANDLE((void*)(-1));

		public static HANDLE NULL => new HANDLE(null);

		public unsafe HANDLE(void* value)
		{
			Value = value;
		}

		public unsafe static bool operator ==(HANDLE left, HANDLE right)
		{
			return left.Value == right.Value;
		}

		public unsafe static bool operator !=(HANDLE left, HANDLE right)
		{
			return left.Value != right.Value;
		}

		public unsafe static bool operator <(HANDLE left, HANDLE right)
		{
			return left.Value < right.Value;
		}

		public unsafe static bool operator <=(HANDLE left, HANDLE right)
		{
			return left.Value <= right.Value;
		}

		public unsafe static bool operator >(HANDLE left, HANDLE right)
		{
			return left.Value > right.Value;
		}

		public unsafe static bool operator >=(HANDLE left, HANDLE right)
		{
			return left.Value >= right.Value;
		}

		public unsafe static explicit operator HANDLE(void* value)
		{
			return new HANDLE(value);
		}

		public unsafe static implicit operator void*(HANDLE value)
		{
			return value.Value;
		}

		public unsafe static explicit operator HANDLE(byte value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator byte(HANDLE value)
		{
			return (byte)value.Value;
		}

		public unsafe static explicit operator HANDLE(short value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator short(HANDLE value)
		{
			return (short)value.Value;
		}

		public unsafe static explicit operator HANDLE(int value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator int(HANDLE value)
		{
			return (int)value.Value;
		}

		public unsafe static explicit operator HANDLE(long value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator long(HANDLE value)
		{
			return (long)value.Value;
		}

		public unsafe static explicit operator HANDLE(nint value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static implicit operator nint(HANDLE value)
		{
			return (nint)value.Value;
		}

		public unsafe static explicit operator HANDLE(sbyte value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator sbyte(HANDLE value)
		{
			return (sbyte)value.Value;
		}

		public unsafe static explicit operator HANDLE(ushort value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator ushort(HANDLE value)
		{
			return (ushort)value.Value;
		}

		public unsafe static explicit operator HANDLE(uint value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator uint(HANDLE value)
		{
			return (uint)value.Value;
		}

		public unsafe static explicit operator HANDLE(ulong value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator ulong(HANDLE value)
		{
			return (ulong)value.Value;
		}

		public unsafe static explicit operator HANDLE(nuint value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static implicit operator nuint(HANDLE value)
		{
			return (nuint)value.Value;
		}

		public int CompareTo(object? obj)
		{
			if (obj is HANDLE other)
			{
				return CompareTo(other);
			}
			if (obj != null)
			{
				throw new ArgumentException("obj is not an instance of HANDLE.");
			}
			return 1;
		}

		public unsafe int CompareTo(HANDLE other)
		{
			if (sizeof(IntPtr) != 4)
			{
				return ((ulong)Value).CompareTo((ulong)other.Value);
			}
			return ((uint)Value).CompareTo((uint)other.Value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is HANDLE other)
			{
				return Equals(other);
			}
			return false;
		}

		public unsafe bool Equals(HANDLE other)
		{
			UIntPtr value = (UIntPtr)Value;
			return value.Equals((object?)(nuint)other.Value);
		}

		public unsafe override int GetHashCode()
		{
			UIntPtr value = (UIntPtr)Value;
			return value.GetHashCode();
		}

		public unsafe override string ToString()
		{
			if (sizeof(UIntPtr) != 4)
			{
				return ((ulong)Value).ToString("X16", null);
			}
			return ((uint)Value).ToString("X8", null);
		}

		public unsafe string ToString(string? format, IFormatProvider? formatProvider)
		{
			if (sizeof(IntPtr) != 4)
			{
				return ((ulong)Value).ToString(format, formatProvider);
			}
			return ((uint)Value).ToString(format, formatProvider);
		}
	}

	public const int MEM_COMMIT = 4096;

	public const int MEM_RESERVE = 8192;

	public const int MEM_REPLACE_PLACEHOLDER = 16384;

	public const int MEM_RESERVE_PLACEHOLDER = 262144;

	public const int MEM_RESET = 524288;

	public const int MEM_TOP_DOWN = 1048576;

	public const int MEM_WRITE_WATCH = 2097152;

	public const int MEM_PHYSICAL = 4194304;

	public const int MEM_ROTATE = 8388608;

	public const int MEM_DIFFERENT_IMAGE_BASE_OK = 8388608;

	public const int MEM_RESET_UNDO = 16777216;

	public const int MEM_LARGE_PAGES = 536870912;

	public const uint MEM_4MB_PAGES = 2147483648u;

	public const int MEM_64K_PAGES = 541065216;

	public const int MEM_UNMAP_WITH_TRANSIENT_BOOST = 1;

	public const int MEM_COALESCE_PLACEHOLDERS = 1;

	public const int MEM_PRESERVE_PLACEHOLDER = 2;

	public const int MEM_DECOMMIT = 16384;

	public const int MEM_RELEASE = 32768;

	public const int MEM_FREE = 65536;

	public const int MEM_EXTENDED_PARAMETER_GRAPHICS = 1;

	public const int MEM_EXTENDED_PARAMETER_NONPAGED = 2;

	public const int MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL = 4;

	public const int MEM_EXTENDED_PARAMETER_NONPAGED_LARGE = 8;

	public const int MEM_EXTENDED_PARAMETER_NONPAGED_HUGE = 16;

	public const int MEM_EXTENDED_PARAMETER_SOFT_FAULT_PAGES = 32;

	public const int MEM_EXTENDED_PARAMETER_EC_CODE = 64;

	public const int MEM_EXTENDED_PARAMETER_IMAGE_NO_HPAT = 128;

	public const long MEM_EXTENDED_PARAMETER_NUMA_NODE_MANDATORY = long.MinValue;

	public const int MEM_EXTENDED_PARAMETER_TYPE_BITS = 8;

	public const ulong MEM_DEDICATED_ATTRIBUTE_NOT_SPECIFIED = ulong.MaxValue;

	public const int MEM_PRIVATE = 131072;

	public const int MEM_MAPPED = 262144;

	public const int MEM_IMAGE = 16777216;

	public const int PAGE_NOACCESS = 1;

	public const int PAGE_READONLY = 2;

	public const int PAGE_READWRITE = 4;

	public const int PAGE_WRITECOPY = 8;

	public const int PAGE_EXECUTE = 16;

	public const int PAGE_EXECUTE_READ = 32;

	public const int PAGE_EXECUTE_READWRITE = 64;

	public const int PAGE_EXECUTE_WRITECOPY = 128;

	public const int PAGE_GUARD = 256;

	public const int PAGE_NOCACHE = 512;

	public const int PAGE_WRITECOMBINE = 1024;

	public const int PAGE_GRAPHICS_NOACCESS = 2048;

	public const int PAGE_GRAPHICS_READONLY = 4096;

	public const int PAGE_GRAPHICS_READWRITE = 8192;

	public const int PAGE_GRAPHICS_EXECUTE = 16384;

	public const int PAGE_GRAPHICS_EXECUTE_READ = 32768;

	public const int PAGE_GRAPHICS_EXECUTE_READWRITE = 65536;

	public const int PAGE_GRAPHICS_COHERENT = 131072;

	public const int PAGE_GRAPHICS_NOCACHE = 262144;

	public const uint PAGE_ENCLAVE_THREAD_CONTROL = 2147483648u;

	public const uint PAGE_REVERT_TO_FILE_MAP = 2147483648u;

	public const int PAGE_TARGETS_NO_UPDATE = 1073741824;

	public const int PAGE_TARGETS_INVALID = 1073741824;

	public const int PAGE_ENCLAVE_UNVALIDATED = 536870912;

	public const int PAGE_ENCLAVE_MASK = 268435456;

	public const int PAGE_ENCLAVE_DECOMMIT = 268435456;

	public const int PAGE_ENCLAVE_SS_FIRST = 268435457;

	public const int PAGE_ENCLAVE_SS_REST = 268435458;

	public const int PROCESSOR_ARCHITECTURE_INTEL = 0;

	public const int PROCESSOR_ARCHITECTURE_MIPS = 1;

	public const int PROCESSOR_ARCHITECTURE_ALPHA = 2;

	public const int PROCESSOR_ARCHITECTURE_PPC = 3;

	public const int PROCESSOR_ARCHITECTURE_SHX = 4;

	public const int PROCESSOR_ARCHITECTURE_ARM = 5;

	public const int PROCESSOR_ARCHITECTURE_IA64 = 6;

	public const int PROCESSOR_ARCHITECTURE_ALPHA64 = 7;

	public const int PROCESSOR_ARCHITECTURE_MSIL = 8;

	public const int PROCESSOR_ARCHITECTURE_AMD64 = 9;

	public const int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 = 10;

	public const int PROCESSOR_ARCHITECTURE_NEUTRAL = 11;

	public const int PROCESSOR_ARCHITECTURE_ARM64 = 12;

	public const int PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 = 13;

	public const int PROCESSOR_ARCHITECTURE_IA32_ON_ARM64 = 14;

	public const int PROCESSOR_ARCHITECTURE_UNKNOWN = 65535;

	[DllImport("kernel32", ExactSpelling = true)]
	public unsafe static extern void* VirtualAlloc(void* lpAddress, nuint dwSize, uint flAllocationType, uint flProtect);

	[DllImport("kernel32", ExactSpelling = true)]
	public unsafe static extern BOOL VirtualProtect(void* lpAddress, nuint dwSize, uint flNewProtect, uint* lpflOldProtect);

	[DllImport("kernel32", ExactSpelling = true)]
	public unsafe static extern BOOL VirtualFree(void* lpAddress, nuint dwSize, uint dwFreeType);

	[DllImport("kernel32", ExactSpelling = true)]
	public unsafe static extern nuint VirtualQuery(void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, nuint dwLength);

	[DllImport("kernel32", ExactSpelling = true)]
	public unsafe static extern void GetSystemInfo(SYSTEM_INFO* lpSystemInfo);

	[DllImport("kernel32", ExactSpelling = true)]
	public static extern HANDLE GetCurrentProcess();

	[DllImport("kernel32", ExactSpelling = true)]
	public unsafe static extern BOOL FlushInstructionCache(HANDLE hProcess, void* lpBaseAddress, nuint dwSize);

	[DllImport("kernel32", ExactSpelling = true)]
	public static extern uint GetLastError();
}


using System;
using System.Diagnostics;

[Conditional("NEVER")]
[AttributeUsage(AttributeTargets.All)]
private sealed class SetsLastSystemErrorAttribute : Attribute
{
}


using System;
using System.Diagnostics;

[Conditional("NEVER")]
[AttributeUsage(AttributeTargets.All)]
private sealed class NativeTypeNameAttribute : Attribute
{
	public NativeTypeNameAttribute(string x)
	{
	}
}


public struct MEMORY_BASIC_INFORMATION
{
	public unsafe void* BaseAddress;

	public unsafe void* AllocationBase;

	public uint AllocationProtect;

	public nuint RegionSize;

	public uint State;

	public uint Protect;

	public uint Type;
}


using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

public struct SYSTEM_INFO
{
	[StructLayout(LayoutKind.Explicit)]
	public struct _Anonymous_e__Union
	{
		public struct _Anonymous_e__Struct
		{
			public ushort wProcessorArchitecture;

			public ushort wReserved;
		}

		[FieldOffset(0)]
		public uint dwOemId;

		[FieldOffset(0)]
		public _Anonymous_e__Struct Anonymous;
	}

	public _Anonymous_e__Union Anonymous;

	public uint dwPageSize;

	public unsafe void* lpMinimumApplicationAddress;

	public unsafe void* lpMaximumApplicationAddress;

	public nuint dwActiveProcessorMask;

	public uint dwNumberOfProcessors;

	public uint dwProcessorType;

	public uint dwAllocationGranularity;

	public ushort wProcessorLevel;

	public ushort wProcessorRevision;

	[UnscopedRef]
	public ref uint dwOemId
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref Anonymous.dwOemId;
		}
	}

	[UnscopedRef]
	public ref ushort wProcessorArchitecture
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref Anonymous.Anonymous.wProcessorArchitecture;
		}
	}

	[UnscopedRef]
	public ref ushort wReserved
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref Anonymous.Anonymous.wReserved;
		}
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct _Anonymous_e__Union
{
	public struct _Anonymous_e__Struct
	{
		public ushort wProcessorArchitecture;

		public ushort wReserved;
	}

	[FieldOffset(0)]
	public uint dwOemId;

	[FieldOffset(0)]
	public _Anonymous_e__Struct Anonymous;
}


public struct _Anonymous_e__Struct
{
	public ushort wProcessorArchitecture;

	public ushort wReserved;
}


using System;

public readonly struct BOOL : IComparable, IComparable<BOOL>, IEquatable<BOOL>, IFormattable
{
	public readonly int Value;

	public static BOOL FALSE => new BOOL(0);

	public static BOOL TRUE => new BOOL(1);

	public BOOL(int value)
	{
		Value = value;
	}

	public static bool operator ==(BOOL left, BOOL right)
	{
		return left.Value == right.Value;
	}

	public static bool operator !=(BOOL left, BOOL right)
	{
		return left.Value != right.Value;
	}

	public static bool operator <(BOOL left, BOOL right)
	{
		return left.Value < right.Value;
	}

	public static bool operator <=(BOOL left, BOOL right)
	{
		return left.Value <= right.Value;
	}

	public static bool operator >(BOOL left, BOOL right)
	{
		return left.Value > right.Value;
	}

	public static bool operator >=(BOOL left, BOOL right)
	{
		return left.Value >= right.Value;
	}

	public static implicit operator bool(BOOL value)
	{
		return value.Value != 0;
	}

	public static implicit operator BOOL(bool value)
	{
		return new BOOL(value ? 1 : 0);
	}

	public static bool operator false(BOOL value)
	{
		return value.Value == 0;
	}

	public static bool operator true(BOOL value)
	{
		return value.Value != 0;
	}

	public static implicit operator BOOL(byte value)
	{
		return new BOOL(value);
	}

	public static explicit operator byte(BOOL value)
	{
		return (byte)value.Value;
	}

	public static implicit operator BOOL(short value)
	{
		return new BOOL(value);
	}

	public static explicit operator short(BOOL value)
	{
		return (short)value.Value;
	}

	public static implicit operator BOOL(int value)
	{
		return new BOOL(value);
	}

	public static implicit operator int(BOOL value)
	{
		return value.Value;
	}

	public static explicit operator BOOL(long value)
	{
		return new BOOL((int)value);
	}

	public static implicit operator long(BOOL value)
	{
		return value.Value;
	}

	public static explicit operator BOOL(nint value)
	{
		return new BOOL((int)value);
	}

	public static implicit operator nint(BOOL value)
	{
		return value.Value;
	}

	public static implicit operator BOOL(sbyte value)
	{
		return new BOOL(value);
	}

	public static explicit operator sbyte(BOOL value)
	{
		return (sbyte)value.Value;
	}

	public static implicit operator BOOL(ushort value)
	{
		return new BOOL(value);
	}

	public static explicit operator ushort(BOOL value)
	{
		return (ushort)value.Value;
	}

	public static explicit operator BOOL(uint value)
	{
		return new BOOL((int)value);
	}

	public static explicit operator uint(BOOL value)
	{
		return (uint)value.Value;
	}

	public static explicit operator BOOL(ulong value)
	{
		return new BOOL((int)value);
	}

	public static explicit operator ulong(BOOL value)
	{
		return (ulong)value.Value;
	}

	public static explicit operator BOOL(nuint value)
	{
		return new BOOL((int)value);
	}

	public static explicit operator nuint(BOOL value)
	{
		return (nuint)value.Value;
	}

	public int CompareTo(object? obj)
	{
		if (obj is BOOL other)
		{
			return CompareTo(other);
		}
		if (obj != null)
		{
			throw new ArgumentException("obj is not an instance of BOOL.");
		}
		return 1;
	}

	public int CompareTo(BOOL other)
	{
		int value = Value;
		return value.CompareTo(other.Value);
	}

	public override bool Equals(object? obj)
	{
		if (obj is BOOL other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(BOOL other)
	{
		int value = Value;
		return value.Equals(other.Value);
	}

	public override int GetHashCode()
	{
		int value = Value;
		return value.GetHashCode();
	}

	public override string ToString()
	{
		int value = Value;
		return value.ToString((IFormatProvider?)null);
	}

	public string ToString(string? format, IFormatProvider? formatProvider)
	{
		int value = Value;
		return value.ToString(format, formatProvider);
	}
}


using System;

public readonly struct HANDLE : IComparable, IComparable<HANDLE>, IEquatable<HANDLE>, IFormattable
{
	public unsafe readonly void* Value;

	public unsafe static HANDLE INVALID_VALUE => new HANDLE((void*)(-1));

	public static HANDLE NULL => new HANDLE(null);

	public unsafe HANDLE(void* value)
	{
		Value = value;
	}

	public unsafe static bool operator ==(HANDLE left, HANDLE right)
	{
		return left.Value == right.Value;
	}

	public unsafe static bool operator !=(HANDLE left, HANDLE right)
	{
		return left.Value != right.Value;
	}

	public unsafe static bool operator <(HANDLE left, HANDLE right)
	{
		return left.Value < right.Value;
	}

	public unsafe static bool operator <=(HANDLE left, HANDLE right)
	{
		return left.Value <= right.Value;
	}

	public unsafe static bool operator >(HANDLE left, HANDLE right)
	{
		return left.Value > right.Value;
	}

	public unsafe static bool operator >=(HANDLE left, HANDLE right)
	{
		return left.Value >= right.Value;
	}

	public unsafe static explicit operator HANDLE(void* value)
	{
		return new HANDLE(value);
	}

	public unsafe static implicit operator void*(HANDLE value)
	{
		return value.Value;
	}

	public unsafe static explicit operator HANDLE(byte value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator byte(HANDLE value)
	{
		return (byte)value.Value;
	}

	public unsafe static explicit operator HANDLE(short value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator short(HANDLE value)
	{
		return (short)value.Value;
	}

	public unsafe static explicit operator HANDLE(int value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator int(HANDLE value)
	{
		return (int)value.Value;
	}

	public unsafe static explicit operator HANDLE(long value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator long(HANDLE value)
	{
		return (long)value.Value;
	}

	public unsafe static explicit operator HANDLE(nint value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static implicit operator nint(HANDLE value)
	{
		return (nint)value.Value;
	}

	public unsafe static explicit operator HANDLE(sbyte value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator sbyte(HANDLE value)
	{
		return (sbyte)value.Value;
	}

	public unsafe static explicit operator HANDLE(ushort value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator ushort(HANDLE value)
	{
		return (ushort)value.Value;
	}

	public unsafe static explicit operator HANDLE(uint value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator uint(HANDLE value)
	{
		return (uint)value.Value;
	}

	public unsafe static explicit operator HANDLE(ulong value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator ulong(HANDLE value)
	{
		return (ulong)value.Value;
	}

	public unsafe static explicit operator HANDLE(nuint value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static implicit operator nuint(HANDLE value)
	{
		return (nuint)value.Value;
	}

	public int CompareTo(object? obj)
	{
		if (obj is HANDLE other)
		{
			return CompareTo(other);
		}
		if (obj != null)
		{
			throw new ArgumentException("obj is not an instance of HANDLE.");
		}
		return 1;
	}

	public unsafe int CompareTo(HANDLE other)
	{
		if (sizeof(IntPtr) != 4)
		{
			return ((ulong)Value).CompareTo((ulong)other.Value);
		}
		return ((uint)Value).CompareTo((uint)other.Value);
	}

	public override bool Equals(object? obj)
	{
		if (obj is HANDLE other)
		{
			return Equals(other);
		}
		return false;
	}

	public unsafe bool Equals(HANDLE other)
	{
		UIntPtr value = (UIntPtr)Value;
		return value.Equals((object?)(nuint)other.Value);
	}

	public unsafe override int GetHashCode()
	{
		UIntPtr value = (UIntPtr)Value;
		return value.GetHashCode();
	}

	public unsafe override string ToString()
	{
		if (sizeof(UIntPtr) != 4)
		{
			return ((ulong)Value).ToString("X16", null);
		}
		return ((uint)Value).ToString("X8", null);
	}

	public unsafe string ToString(string? format, IFormatProvider? formatProvider)
	{
		if (sizeof(IntPtr) != 4)
		{
			return ((ulong)Value).ToString(format, formatProvider);
		}
		return ((uint)Value).ToString(format, formatProvider);
	}
}


using System;

[AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]
internal sealed class FatInterfaceAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]
internal sealed class FatInterfaceImplAttribute : Attribute
{
	public Type FatInterface { get; }

	public FatInterfaceImplAttribute(Type fatInterface)
	{
		FatInterface = fatInterface;
	}
}


using System;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
internal sealed class FatInterfaceIgnoreAttribute : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
internal sealed class MultipurposeSlotOffsetTableAttribute : Attribute
{
	public int Bits { get; }

	public Type HelperType { get; }

	public MultipurposeSlotOffsetTableAttribute(int bits, Type helperType)
	{
		Bits = bits;
		HelperType = helperType;
	}
}


internal enum RelocKind
{
	Offset64
}


using Iced.Intel;

internal readonly struct RelocInfo
{
	public readonly ulong Address;

	public readonly RelocKind Kind;

	public RelocInfo(RelocKind kind, ulong address)
	{
		Kind = kind;
		Address = address;
	}
}


using System;
using System.Collections.Generic;
using Iced.Intel;

internal readonly struct InstructionBlock
{
	public readonly CodeWriter CodeWriter;

	public readonly IList<Instruction> Instructions;

	public readonly ulong RIP;

	public InstructionBlock(CodeWriter codeWriter, IList<Instruction> instructions, ulong rip)
	{
		CodeWriter = codeWriter ?? throw new ArgumentNullException("codeWriter");
		Instructions = instructions ?? throw new ArgumentNullException("instructions");
		RIP = rip;
	}
}


using System;
using System.Collections.Generic;
using Iced.Intel;

internal readonly struct BlockEncoderResult
{
	public readonly ulong RIP;

	public readonly List<RelocInfo>? RelocInfos;

	public readonly uint[] NewInstructionOffsets;

	public readonly ConstantOffsets[] ConstantOffsets;

	internal BlockEncoderResult(ulong rip, List<RelocInfo>? relocInfos, uint[]? newInstructionOffsets, ConstantOffsets[]? constantOffsets)
	{
		RIP = rip;
		RelocInfos = relocInfos;
		NewInstructionOffsets = newInstructionOffsets ?? Array2.Empty<uint>();
		ConstantOffsets = constantOffsets ?? Array2.Empty<ConstantOffsets>();
	}
}


using System;

[Flags]
internal enum BlockEncoderOptions
{
	None = 0,
	DontFixBranches = 1,
	ReturnRelocInfos = 2,
	ReturnNewInstructionOffsets = 4,
	ReturnConstantOffsets = 8
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class BlockEncoder
{
	private sealed class NullCodeWriter : CodeWriter
	{
		public static readonly NullCodeWriter? Instance = new NullCodeWriter();

		private NullCodeWriter()
		{
		}

		public override void WriteByte(byte value)
		{
		}
	}

	private readonly int bitness;

	private readonly BlockEncoderOptions options;

	private readonly Block?[]? blocks;

	private readonly Encoder? nullEncoder;

	private readonly Dictionary<ulong, Instr?>? toInstr;

	internal int Bitness => bitness;

	internal bool FixBranches => (options & BlockEncoderOptions.DontFixBranches) == 0;

	private bool ReturnRelocInfos => (options & BlockEncoderOptions.ReturnRelocInfos) != 0;

	private bool ReturnNewInstructionOffsets => (options & BlockEncoderOptions.ReturnNewInstructionOffsets) != 0;

	private bool ReturnConstantOffsets => (options & BlockEncoderOptions.ReturnConstantOffsets) != 0;

	private BlockEncoder(int bitness, InstructionBlock[]? instrBlocks, BlockEncoderOptions options)
	{
		if (bitness != 16 && bitness != 32 && bitness != 64)
		{
			throw new ArgumentOutOfRangeException("bitness");
		}
		if (instrBlocks == null)
		{
			throw new ArgumentNullException("instrBlocks");
		}
		this.bitness = bitness;
		nullEncoder = Encoder.Create(bitness, NullCodeWriter.Instance);
		this.options = options;
		blocks = new Block[instrBlocks.Length];
		int num = 0;
		for (int i = 0; i < instrBlocks.Length; i++)
		{
			IList<Instruction> instructions = instrBlocks[i].Instructions;
			if (instructions == null)
			{
				throw new ArgumentException();
			}
			Block block = new Block(this, instrBlocks[i].CodeWriter, instrBlocks[i].RIP, ReturnRelocInfos ? new List<RelocInfo>() : null);
			blocks[i] = block;
			Instr[] array = new Instr[instructions.Count];
			ulong num2 = instrBlocks[i].RIP;
			for (int j = 0; j < array.Length; j++)
			{
				Instr instr = Instr.Create(this, block, instructions[j]);
				instr.IP = num2;
				array[j] = instr;
				num++;
				num2 += instr.Size;
			}
			block.SetInstructions(array);
		}
		Array.Sort(blocks, delegate(Block? a, Block? b)
		{
			ulong rIP = a.RIP;
			return rIP.CompareTo(b.RIP);
		});
		Dictionary<ulong, Instr> dictionary = (toInstr = new Dictionary<ulong, Instr>(num));
		bool flag = false;
		Block[] array2 = blocks;
		for (int k = 0; k < array2.Length; k++)
		{
			Instr[] instructions2 = array2[k].Instructions;
			foreach (Instr instr2 in instructions2)
			{
				ulong origIP = instr2.OrigIP;
				if (dictionary.TryGetValue(origIP, out var _))
				{
					if (origIP != 0L)
					{
						throw new ArgumentException($"Multiple instructions with the same IP: 0x{origIP:X}");
					}
					flag = true;
				}
				else
				{
					dictionary[origIP] = instr2;
				}
			}
		}
		if (flag)
		{
			dictionary.Remove(0uL);
		}
		array2 = blocks;
		foreach (Block obj in array2)
		{
			ulong num3 = obj.RIP;
			Instr[] instructions2 = obj.Instructions;
			foreach (Instr instr3 in instructions2)
			{
				instr3.IP = num3;
				if (!instr3.Done)
				{
					instr3.Initialize(this);
				}
				num3 += instr3.Size;
			}
		}
	}

	public static bool TryEncode(int bitness, InstructionBlock block, [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(false)] out string? errorMessage, out BlockEncoderResult result, BlockEncoderOptions options = BlockEncoderOptions.None)
	{
		if (TryEncode(bitness, new InstructionBlock[1] { block }, out errorMessage, out BlockEncoderResult[] result2, options))
		{
			result = result2[0];
			return true;
		}
		result = default(BlockEncoderResult);
		return false;
	}

	public static bool TryEncode(int bitness, InstructionBlock[] blocks, [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(false)] out string? errorMessage, [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(true)] out BlockEncoderResult[]? result, BlockEncoderOptions options = BlockEncoderOptions.None)
	{
		return new BlockEncoder(bitness, blocks, options).Encode(out errorMessage, out result);
	}

	private bool Encode([<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(false)] out string? errorMessage, [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(true)] out BlockEncoderResult[]? result)
	{
		Block[] array;
		for (int i = 0; i < 5; i++)
		{
			bool flag = false;
			array = blocks;
			foreach (Block obj in array)
			{
				ulong num = obj.RIP;
				ulong num2 = 0uL;
				Instr[] instructions = obj.Instructions;
				foreach (Instr instr in instructions)
				{
					instr.IP = num;
					if (!instr.Done)
					{
						uint size = instr.Size;
						if (instr.Optimize(num2))
						{
							if (instr.Size > size)
							{
								errorMessage = "Internal error: new size > old size";
								result = null;
								return false;
							}
							if (instr.Size < size)
							{
								num2 += size - instr.Size;
								flag = true;
							}
						}
						else if (instr.Size != size)
						{
							errorMessage = "Internal error: new size != old size";
							result = null;
							return false;
						}
					}
					num += instr.Size;
				}
			}
			if (!flag)
			{
				break;
			}
		}
		array = blocks;
		for (int j = 0; j < array.Length; j++)
		{
			array[j].InitializeData();
		}
		BlockEncoderResult[] array2 = new BlockEncoderResult[blocks.Length];
		for (int l = 0; l < blocks.Length; l++)
		{
			Block block = blocks[l];
			Encoder encoder = Encoder.Create(bitness, block.CodeWriter);
			ulong num3 = block.RIP;
			uint[] array3 = (ReturnNewInstructionOffsets ? new uint[block.Instructions.Length] : null);
			ConstantOffsets[] array4 = (ReturnConstantOffsets ? new ConstantOffsets[block.Instructions.Length] : null);
			Instr[] instructions2 = block.Instructions;
			for (int m = 0; m < instructions2.Length; m++)
			{
				Instr instr2 = instructions2[m];
				uint bytesWritten = block.CodeWriter.BytesWritten;
				bool isOriginalInstruction;
				if (array4 != null)
				{
					errorMessage = instr2.TryEncode(encoder, out array4[m], out isOriginalInstruction);
				}
				else
				{
					errorMessage = instr2.TryEncode(encoder, out var _, out isOriginalInstruction);
				}
				if (errorMessage != null)
				{
					result = null;
					return false;
				}
				uint num4 = block.CodeWriter.BytesWritten - bytesWritten;
				if (num4 != instr2.Size)
				{
					errorMessage = "Internal error: didn't write all bytes";
					result = null;
					return false;
				}
				if (array3 != null)
				{
					if (isOriginalInstruction)
					{
						array3[m] = (uint)(num3 - block.RIP);
					}
					else
					{
						array3[m] = uint.MaxValue;
					}
				}
				num3 += num4;
			}
			array2[l] = new BlockEncoderResult(block.RIP, block.relocInfos, array3, array4);
			block.WriteData();
		}
		errorMessage = null;
		result = array2;
		return true;
	}

	internal TargetInstr GetTarget(ulong address)
	{
		if (toInstr.TryGetValue(address, out Instr value))
		{
			return new TargetInstr(value);
		}
		return new TargetInstr(address);
	}

	internal uint GetInstructionSize(in Instruction instruction, ulong ip)
	{
		if (!nullEncoder.TryEncode(in instruction, ip, out uint encodedLength, out string _))
		{
			return 15u;
		}
		return encodedLength;
	}
}


private sealed class NullCodeWriter : CodeWriter
{
	public static readonly NullCodeWriter? Instance = new NullCodeWriter();

	private NullCodeWriter()
	{
	}

	public override void WriteByte(byte value)
	{
	}
}


using System;
using Iced.Intel;

internal sealed class ByteArrayCodeReader : CodeReader
{
	private readonly byte[] data;

	private int currentPosition;

	private readonly int startPosition;

	private readonly int endPosition;

	public int Position
	{
		get
		{
			return currentPosition - startPosition;
		}
		set
		{
			if ((uint)value > (uint)Count)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_value();
			}
			currentPosition = startPosition + value;
		}
	}

	public int Count => endPosition - startPosition;

	public bool CanReadByte => currentPosition < endPosition;

	public ByteArrayCodeReader(string hexData)
		: this(HexUtils.ToByteArray(hexData))
	{
	}

	public ByteArrayCodeReader(byte[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		this.data = data;
		currentPosition = 0;
		startPosition = 0;
		endPosition = data.Length;
	}

	public ByteArrayCodeReader(byte[] data, int index, int count)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		this.data = data;
		if (index < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		if (count < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		if ((uint)(index + count) > (uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		currentPosition = index;
		startPosition = index;
		endPosition = index + count;
	}

	public ByteArrayCodeReader(ArraySegment<byte> data)
	{
		if (data.Array == null)
		{
			ThrowHelper.ThrowArgumentException();
		}
		this.data = data.Array;
		endPosition = (startPosition = (currentPosition = data.Offset)) + data.Count;
	}

	public override int ReadByte()
	{
		if (currentPosition >= endPosition)
		{
			return -1;
		}
		return data[currentPosition++];
	}
}


internal enum Code
{
	INVALID,
	DeclareByte,
	DeclareWord,
	DeclareDword,
	DeclareQword,
	Add_rm8_r8,
	Add_rm16_r16,
	Add_rm32_r32,
	Add_rm64_r64,
	Add_r8_rm8,
	Add_r16_rm16,
	Add_r32_rm32,
	Add_r64_rm64,
	Add_AL_imm8,
	Add_AX_imm16,
	Add_EAX_imm32,
	Add_RAX_imm32,
	Pushw_ES,
	Pushd_ES,
	Popw_ES,
	Popd_ES,
	Or_rm8_r8,
	Or_rm16_r16,
	Or_rm32_r32,
	Or_rm64_r64,
	Or_r8_rm8,
	Or_r16_rm16,
	Or_r32_rm32,
	Or_r64_rm64,
	Or_AL_imm8,
	Or_AX_imm16,
	Or_EAX_imm32,
	Or_RAX_imm32,
	Pushw_CS,
	Pushd_CS,
	Popw_CS,
	Adc_rm8_r8,
	Adc_rm16_r16,
	Adc_rm32_r32,
	Adc_rm64_r64,
	Adc_r8_rm8,
	Adc_r16_rm16,
	Adc_r32_rm32,
	Adc_r64_rm64,
	Adc_AL_imm8,
	Adc_AX_imm16,
	Adc_EAX_imm32,
	Adc_RAX_imm32,
	Pushw_SS,
	Pushd_SS,
	Popw_SS,
	Popd_SS,
	Sbb_rm8_r8,
	Sbb_rm16_r16,
	Sbb_rm32_r32,
	Sbb_rm64_r64,
	Sbb_r8_rm8,
	Sbb_r16_rm16,
	Sbb_r32_rm32,
	Sbb_r64_rm64,
	Sbb_AL_imm8,
	Sbb_AX_imm16,
	Sbb_EAX_imm32,
	Sbb_RAX_imm32,
	Pushw_DS,
	Pushd_DS,
	Popw_DS,
	Popd_DS,
	And_rm8_r8,
	And_rm16_r16,
	And_rm32_r32,
	And_rm64_r64,
	And_r8_rm8,
	And_r16_rm16,
	And_r32_rm32,
	And_r64_rm64,
	And_AL_imm8,
	And_AX_imm16,
	And_EAX_imm32,
	And_RAX_imm32,
	Daa,
	Sub_rm8_r8,
	Sub_rm16_r16,
	Sub_rm32_r32,
	Sub_rm64_r64,
	Sub_r8_rm8,
	Sub_r16_rm16,
	Sub_r32_rm32,
	Sub_r64_rm64,
	Sub_AL_imm8,
	Sub_AX_imm16,
	Sub_EAX_imm32,
	Sub_RAX_imm32,
	Das,
	Xor_rm8_r8,
	Xor_rm16_r16,
	Xor_rm32_r32,
	Xor_rm64_r64,
	Xor_r8_rm8,
	Xor_r16_rm16,
	Xor_r32_rm32,
	Xor_r64_rm64,
	Xor_AL_imm8,
	Xor_AX_imm16,
	Xor_EAX_imm32,
	Xor_RAX_imm32,
	Aaa,
	Cmp_rm8_r8,
	Cmp_rm16_r16,
	Cmp_rm32_r32,
	Cmp_rm64_r64,
	Cmp_r8_rm8,
	Cmp_r16_rm16,
	Cmp_r32_rm32,
	Cmp_r64_rm64,
	Cmp_AL_imm8,
	Cmp_AX_imm16,
	Cmp_EAX_imm32,
	Cmp_RAX_imm32,
	Aas,
	Inc_r16,
	Inc_r32,
	Dec_r16,
	Dec_r32,
	Push_r16,
	Push_r32,
	Push_r64,
	Pop_r16,
	Pop_r32,
	Pop_r64,
	Pushaw,
	Pushad,
	Popaw,
	Popad,
	Bound_r16_m1616,
	Bound_r32_m3232,
	Arpl_rm16_r16,
	Arpl_r32m16_r32,
	Movsxd_r16_rm16,
	Movsxd_r32_rm32,
	Movsxd_r64_rm32,
	Push_imm16,
	Pushd_imm32,
	Pushq_imm32,
	Imul_r16_rm16_imm16,
	Imul_r32_rm32_imm32,
	Imul_r64_rm64_imm32,
	Pushw_imm8,
	Pushd_imm8,
	Pushq_imm8,
	Imul_r16_rm16_imm8,
	Imul_r32_rm32_imm8,
	Imul_r64_rm64_imm8,
	Insb_m8_DX,
	Insw_m16_DX,
	Insd_m32_DX,
	Outsb_DX_m8,
	Outsw_DX_m16,
	Outsd_DX_m32,
	Jo_rel8_16,
	Jo_rel8_32,
	Jo_rel8_64,
	Jno_rel8_16,
	Jno_rel8_32,
	Jno_rel8_64,
	Jb_rel8_16,
	Jb_rel8_32,
	Jb_rel8_64,
	Jae_rel8_16,
	Jae_rel8_32,
	Jae_rel8_64,
	Je_rel8_16,
	Je_rel8_32,
	Je_rel8_64,
	Jne_rel8_16,
	Jne_rel8_32,
	Jne_rel8_64,
	Jbe_rel8_16,
	Jbe_rel8_32,
	Jbe_rel8_64,
	Ja_rel8_16,
	Ja_rel8_32,
	Ja_rel8_64,
	Js_rel8_16,
	Js_rel8_32,
	Js_rel8_64,
	Jns_rel8_16,
	Jns_rel8_32,
	Jns_rel8_64,
	Jp_rel8_16,
	Jp_rel8_32,
	Jp_rel8_64,
	Jnp_rel8_16,
	Jnp_rel8_32,
	Jnp_rel8_64,
	Jl_rel8_16,
	Jl_rel8_32,
	Jl_rel8_64,
	Jge_rel8_16,
	Jge_rel8_32,
	Jge_rel8_64,
	Jle_rel8_16,
	Jle_rel8_32,
	Jle_rel8_64,
	Jg_rel8_16,
	Jg_rel8_32,
	Jg_rel8_64,
	Add_rm8_imm8,
	Or_rm8_imm8,
	Adc_rm8_imm8,
	Sbb_rm8_imm8,
	And_rm8_imm8,
	Sub_rm8_imm8,
	Xor_rm8_imm8,
	Cmp_rm8_imm8,
	Add_rm16_imm16,
	Add_rm32_imm32,
	Add_rm64_imm32,
	Or_rm16_imm16,
	Or_rm32_imm32,
	Or_rm64_imm32,
	Adc_rm16_imm16,
	Adc_rm32_imm32,
	Adc_rm64_imm32,
	Sbb_rm16_imm16,
	Sbb_rm32_imm32,
	Sbb_rm64_imm32,
	And_rm16_imm16,
	And_rm32_imm32,
	And_rm64_imm32,
	Sub_rm16_imm16,
	Sub_rm32_imm32,
	Sub_rm64_imm32,
	Xor_rm16_imm16,
	Xor_rm32_imm32,
	Xor_rm64_imm32,
	Cmp_rm16_imm16,
	Cmp_rm32_imm32,
	Cmp_rm64_imm32,
	Add_rm8_imm8_82,
	Or_rm8_imm8_82,
	Adc_rm8_imm8_82,
	Sbb_rm8_imm8_82,
	And_rm8_imm8_82,
	Sub_rm8_imm8_82,
	Xor_rm8_imm8_82,
	Cmp_rm8_imm8_82,
	Add_rm16_imm8,
	Add_rm32_imm8,
	Add_rm64_imm8,
	Or_rm16_imm8,
	Or_rm32_imm8,
	Or_rm64_imm8,
	Adc_rm16_imm8,
	Adc_rm32_imm8,
	Adc_rm64_imm8,
	Sbb_rm16_imm8,
	Sbb_rm32_imm8,
	Sbb_rm64_imm8,
	And_rm16_imm8,
	And_rm32_imm8,
	And_rm64_imm8,
	Sub_rm16_imm8,
	Sub_rm32_imm8,
	Sub_rm64_imm8,
	Xor_rm16_imm8,
	Xor_rm32_imm8,
	Xor_rm64_imm8,
	Cmp_rm16_imm8,
	Cmp_rm32_imm8,
	Cmp_rm64_imm8,
	Test_rm8_r8,
	Test_rm16_r16,
	Test_rm32_r32,
	Test_rm64_r64,
	Xchg_rm8_r8,
	Xchg_rm16_r16,
	Xchg_rm32_r32,
	Xchg_rm64_r64,
	Mov_rm8_r8,
	Mov_rm16_r16,
	Mov_rm32_r32,
	Mov_rm64_r64,
	Mov_r8_rm8,
	Mov_r16_rm16,
	Mov_r32_rm32,
	Mov_r64_rm64,
	Mov_rm16_Sreg,
	Mov_r32m16_Sreg,
	Mov_r64m16_Sreg,
	Lea_r16_m,
	Lea_r32_m,
	Lea_r64_m,
	Mov_Sreg_rm16,
	Mov_Sreg_r32m16,
	Mov_Sreg_r64m16,
	Pop_rm16,
	Pop_rm32,
	Pop_rm64,
	Nopw,
	Nopd,
	Nopq,
	Xchg_r16_AX,
	Xchg_r32_EAX,
	Xchg_r64_RAX,
	Pause,
	Cbw,
	Cwde,
	Cdqe,
	Cwd,
	Cdq,
	Cqo,
	Call_ptr1616,
	Call_ptr1632,
	Wait,
	Pushfw,
	Pushfd,
	Pushfq,
	Popfw,
	Popfd,
	Popfq,
	Sahf,
	Lahf,
	Mov_AL_moffs8,
	Mov_AX_moffs16,
	Mov_EAX_moffs32,
	Mov_RAX_moffs64,
	Mov_moffs8_AL,
	Mov_moffs16_AX,
	Mov_moffs32_EAX,
	Mov_moffs64_RAX,
	Movsb_m8_m8,
	Movsw_m16_m16,
	Movsd_m32_m32,
	Movsq_m64_m64,
	Cmpsb_m8_m8,
	Cmpsw_m16_m16,
	Cmpsd_m32_m32,
	Cmpsq_m64_m64,
	Test_AL_imm8,
	Test_AX_imm16,
	Test_EAX_imm32,
	Test_RAX_imm32,
	Stosb_m8_AL,
	Stosw_m16_AX,
	Stosd_m32_EAX,
	Stosq_m64_RAX,
	Lodsb_AL_m8,
	Lodsw_AX_m16,
	Lodsd_EAX_m32,
	Lodsq_RAX_m64,
	Scasb_AL_m8,
	Scasw_AX_m16,
	Scasd_EAX_m32,
	Scasq_RAX_m64,
	Mov_r8_imm8,
	Mov_r16_imm16,
	Mov_r32_imm32,
	Mov_r64_imm64,
	Rol_rm8_imm8,
	Ror_rm8_imm8,
	Rcl_rm8_imm8,
	Rcr_rm8_imm8,
	Shl_rm8_imm8,
	Shr_rm8_imm8,
	Sal_rm8_imm8,
	Sar_rm8_imm8,
	Rol_rm16_imm8,
	Rol_rm32_imm8,
	Rol_rm64_imm8,
	Ror_rm16_imm8,
	Ror_rm32_imm8,
	Ror_rm64_imm8,
	Rcl_rm16_imm8,
	Rcl_rm32_imm8,
	Rcl_rm64_imm8,
	Rcr_rm16_imm8,
	Rcr_rm32_imm8,
	Rcr_rm64_imm8,
	Shl_rm16_imm8,
	Shl_rm32_imm8,
	Shl_rm64_imm8,
	Shr_rm16_imm8,
	Shr_rm32_imm8,
	Shr_rm64_imm8,
	Sal_rm16_imm8,
	Sal_rm32_imm8,
	Sal_rm64_imm8,
	Sar_rm16_imm8,
	Sar_rm32_imm8,
	Sar_rm64_imm8,
	Retnw_imm16,
	Retnd_imm16,
	Retnq_imm16,
	Retnw,
	Retnd,
	Retnq,
	Les_r16_m1616,
	Les_r32_m1632,
	Lds_r16_m1616,
	Lds_r32_m1632,
	Mov_rm8_imm8,
	Xabort_imm8,
	Mov_rm16_imm16,
	Mov_rm32_imm32,
	Mov_rm64_imm32,
	Xbegin_rel16,
	Xbegin_rel32,
	Enterw_imm16_imm8,
	Enterd_imm16_imm8,
	Enterq_imm16_imm8,
	Leavew,
	Leaved,
	Leaveq,
	Retfw_imm16,
	Retfd_imm16,
	Retfq_imm16,
	Retfw,
	Retfd,
	Retfq,
	Int3,
	Int_imm8,
	Into,
	Iretw,
	Iretd,
	Iretq,
	Rol_rm8_1,
	Ror_rm8_1,
	Rcl_rm8_1,
	Rcr_rm8_1,
	Shl_rm8_1,
	Shr_rm8_1,
	Sal_rm8_1,
	Sar_rm8_1,
	Rol_rm16_1,
	Rol_rm32_1,
	Rol_rm64_1,
	Ror_rm16_1,
	Ror_rm32_1,
	Ror_rm64_1,
	Rcl_rm16_1,
	Rcl_rm32_1,
	Rcl_rm64_1,
	Rcr_rm16_1,
	Rcr_rm32_1,
	Rcr_rm64_1,
	Shl_rm16_1,
	Shl_rm32_1,
	Shl_rm64_1,
	Shr_rm16_1,
	Shr_rm32_1,
	Shr_rm64_1,
	Sal_rm16_1,
	Sal_rm32_1,
	Sal_rm64_1,
	Sar_rm16_1,
	Sar_rm32_1,
	Sar_rm64_1,
	Rol_rm8_CL,
	Ror_rm8_CL,
	Rcl_rm8_CL,
	Rcr_rm8_CL,
	Shl_rm8_CL,
	Shr_rm8_CL,
	Sal_rm8_CL,
	Sar_rm8_CL,
	Rol_rm16_CL,
	Rol_rm32_CL,
	Rol_rm64_CL,
	Ror_rm16_CL,
	Ror_rm32_CL,
	Ror_rm64_CL,
	Rcl_rm16_CL,
	Rcl_rm32_CL,
	Rcl_rm64_CL,
	Rcr_rm16_CL,
	Rcr_rm32_CL,
	Rcr_rm64_CL,
	Shl_rm16_CL,
	Shl_rm32_CL,
	Shl_rm64_CL,
	Shr_rm16_CL,
	Shr_rm32_CL,
	Shr_rm64_CL,
	Sal_rm16_CL,
	Sal_rm32_CL,
	Sal_rm64_CL,
	Sar_rm16_CL,
	Sar_rm32_CL,
	Sar_rm64_CL,
	Aam_imm8,
	Aad_imm8,
	Salc,
	Xlat_m8,
	Fadd_m32fp,
	Fmul_m32fp,
	Fcom_m32fp,
	Fcomp_m32fp,
	Fsub_m32fp,
	Fsubr_m32fp,
	Fdiv_m32fp,
	Fdivr_m32fp,
	Fadd_st0_sti,
	Fmul_st0_sti,
	Fcom_st0_sti,
	Fcomp_st0_sti,
	Fsub_st0_sti,
	Fsubr_st0_sti,
	Fdiv_st0_sti,
	Fdivr_st0_sti,
	Fld_m32fp,
	Fst_m32fp,
	Fstp_m32fp,
	Fldenv_m14byte,
	Fldenv_m28byte,
	Fldcw_m2byte,
	Fnstenv_m14byte,
	Fstenv_m14byte,
	Fnstenv_m28byte,
	Fstenv_m28byte,
	Fnstcw_m2byte,
	Fstcw_m2byte,
	Fld_sti,
	Fxch_st0_sti,
	Fnop,
	Fstpnce_sti,
	Fchs,
	Fabs,
	Ftst,
	Fxam,
	Fld1,
	Fldl2t,
	Fldl2e,
	Fldpi,
	Fldlg2,
	Fldln2,
	Fldz,
	F2xm1,
	Fyl2x,
	Fptan,
	Fpatan,
	Fxtract,
	Fprem1,
	Fdecstp,
	Fincstp,
	Fprem,
	Fyl2xp1,
	Fsqrt,
	Fsincos,
	Frndint,
	Fscale,
	Fsin,
	Fcos,
	Fiadd_m32int,
	Fimul_m32int,
	Ficom_m32int,
	Ficomp_m32int,
	Fisub_m32int,
	Fisubr_m32int,
	Fidiv_m32int,
	Fidivr_m32int,
	Fcmovb_st0_sti,
	Fcmove_st0_sti,
	Fcmovbe_st0_sti,
	Fcmovu_st0_sti,
	Fucompp,
	Fild_m32int,
	Fisttp_m32int,
	Fist_m32int,
	Fistp_m32int,
	Fld_m80fp,
	Fstp_m80fp,
	Fcmovnb_st0_sti,
	Fcmovne_st0_sti,
	Fcmovnbe_st0_sti,
	Fcmovnu_st0_sti,
	Fneni,
	Feni,
	Fndisi,
	Fdisi,
	Fnclex,
	Fclex,
	Fninit,
	Finit,
	Fnsetpm,
	Fsetpm,
	Frstpm,
	Fucomi_st0_sti,
	Fcomi_st0_sti,
	Fadd_m64fp,
	Fmul_m64fp,
	Fcom_m64fp,
	Fcomp_m64fp,
	Fsub_m64fp,
	Fsubr_m64fp,
	Fdiv_m64fp,
	Fdivr_m64fp,
	Fadd_sti_st0,
	Fmul_sti_st0,
	Fcom_st0_sti_DCD0,
	Fcomp_st0_sti_DCD8,
	Fsubr_sti_st0,
	Fsub_sti_st0,
	Fdivr_sti_st0,
	Fdiv_sti_st0,
	Fld_m64fp,
	Fisttp_m64int,
	Fst_m64fp,
	Fstp_m64fp,
	Frstor_m94byte,
	Frstor_m108byte,
	Fnsave_m94byte,
	Fsave_m94byte,
	Fnsave_m108byte,
	Fsave_m108byte,
	Fnstsw_m2byte,
	Fstsw_m2byte,
	Ffree_sti,
	Fxch_st0_sti_DDC8,
	Fst_sti,
	Fstp_sti,
	Fucom_st0_sti,
	Fucomp_st0_sti,
	Fiadd_m16int,
	Fimul_m16int,
	Ficom_m16int,
	Ficomp_m16int,
	Fisub_m16int,
	Fisubr_m16int,
	Fidiv_m16int,
	Fidivr_m16int,
	Faddp_sti_st0,
	Fmulp_sti_st0,
	Fcomp_st0_sti_DED0,
	Fcompp,
	Fsubrp_sti_st0,
	Fsubp_sti_st0,
	Fdivrp_sti_st0,
	Fdivp_sti_st0,
	Fild_m16int,
	Fisttp_m16int,
	Fist_m16int,
	Fistp_m16int,
	Fbld_m80bcd,
	Fild_m64int,
	Fbstp_m80bcd,
	Fistp_m64int,
	Ffreep_sti,
	Fxch_st0_sti_DFC8,
	Fstp_sti_DFD0,
	Fstp_sti_DFD8,
	Fnstsw_AX,
	Fstsw_AX,
	Fstdw_AX,
	Fstsg_AX,
	Fucomip_st0_sti,
	Fcomip_st0_sti,
	Loopne_rel8_16_CX,
	Loopne_rel8_32_CX,
	Loopne_rel8_16_ECX,
	Loopne_rel8_32_ECX,
	Loopne_rel8_64_ECX,
	Loopne_rel8_16_RCX,
	Loopne_rel8_64_RCX,
	Loope_rel8_16_CX,
	Loope_rel8_32_CX,
	Loope_rel8_16_ECX,
	Loope_rel8_32_ECX,
	Loope_rel8_64_ECX,
	Loope_rel8_16_RCX,
	Loope_rel8_64_RCX,
	Loop_rel8_16_CX,
	Loop_rel8_32_CX,
	Loop_rel8_16_ECX,
	Loop_rel8_32_ECX,
	Loop_rel8_64_ECX,
	Loop_rel8_16_RCX,
	Loop_rel8_64_RCX,
	Jcxz_rel8_16,
	Jcxz_rel8_32,
	Jecxz_rel8_16,
	Jecxz_rel8_32,
	Jecxz_rel8_64,
	Jrcxz_rel8_16,
	Jrcxz_rel8_64,
	In_AL_imm8,
	In_AX_imm8,
	In_EAX_imm8,
	Out_imm8_AL,
	Out_imm8_AX,
	Out_imm8_EAX,
	Call_rel16,
	Call_rel32_32,
	Call_rel32_64,
	Jmp_rel16,
	Jmp_rel32_32,
	Jmp_rel32_64,
	Jmp_ptr1616,
	Jmp_ptr1632,
	Jmp_rel8_16,
	Jmp_rel8_32,
	Jmp_rel8_64,
	In_AL_DX,
	In_AX_DX,
	In_EAX_DX,
	Out_DX_AL,
	Out_DX_AX,
	Out_DX_EAX,
	Int1,
	Hlt,
	Cmc,
	Test_rm8_imm8,
	Test_rm8_imm8_F6r1,
	Not_rm8,
	Neg_rm8,
	Mul_rm8,
	Imul_rm8,
	Div_rm8,
	Idiv_rm8,
	Test_rm16_imm16,
	Test_rm32_imm32,
	Test_rm64_imm32,
	Test_rm16_imm16_F7r1,
	Test_rm32_imm32_F7r1,
	Test_rm64_imm32_F7r1,
	Not_rm16,
	Not_rm32,
	Not_rm64,
	Neg_rm16,
	Neg_rm32,
	Neg_rm64,
	Mul_rm16,
	Mul_rm32,
	Mul_rm64,
	Imul_rm16,
	Imul_rm32,
	Imul_rm64,
	Div_rm16,
	Div_rm32,
	Div_rm64,
	Idiv_rm16,
	Idiv_rm32,
	Idiv_rm64,
	Clc,
	Stc,
	Cli,
	Sti,
	Cld,
	Std,
	Inc_rm8,
	Dec_rm8,
	Inc_rm16,
	Inc_rm32,
	Inc_rm64,
	Dec_rm16,
	Dec_rm32,
	Dec_rm64,
	Call_rm16,
	Call_rm32,
	Call_rm64,
	Call_m1616,
	Call_m1632,
	Call_m1664,
	Jmp_rm16,
	Jmp_rm32,
	Jmp_rm64,
	Jmp_m1616,
	Jmp_m1632,
	Jmp_m1664,
	Push_rm16,
	Push_rm32,
	Push_rm64,
	Sldt_rm16,
	Sldt_r32m16,
	Sldt_r64m16,
	Str_rm16,
	Str_r32m16,
	Str_r64m16,
	Lldt_rm16,
	Lldt_r32m16,
	Lldt_r64m16,
	Ltr_rm16,
	Ltr_r32m16,
	Ltr_r64m16,
	Verr_rm16,
	Verr_r32m16,
	Verr_r64m16,
	Verw_rm16,
	Verw_r32m16,
	Verw_r64m16,
	Jmpe_rm16,
	Jmpe_rm32,
	Sgdt_m1632_16,
	Sgdt_m1632,
	Sgdt_m1664,
	Sidt_m1632_16,
	Sidt_m1632,
	Sidt_m1664,
	Lgdt_m1632_16,
	Lgdt_m1632,
	Lgdt_m1664,
	Lidt_m1632_16,
	Lidt_m1632,
	Lidt_m1664,
	Smsw_rm16,
	Smsw_r32m16,
	Smsw_r64m16,
	Rstorssp_m64,
	Lmsw_rm16,
	Lmsw_r32m16,
	Lmsw_r64m16,
	Invlpg_m,
	Enclv,
	Vmcall,
	Vmlaunch,
	Vmresume,
	Vmxoff,
	Pconfig,
	Monitorw,
	Monitord,
	Monitorq,
	Mwait,
	Clac,
	Stac,
	Encls,
	Xgetbv,
	Xsetbv,
	Vmfunc,
	Xend,
	Xtest,
	Enclu,
	Vmrunw,
	Vmrund,
	Vmrunq,
	Vmmcall,
	Vmloadw,
	Vmloadd,
	Vmloadq,
	Vmsavew,
	Vmsaved,
	Vmsaveq,
	Stgi,
	Clgi,
	Skinit,
	Invlpgaw,
	Invlpgad,
	Invlpgaq,
	Setssbsy,
	Saveprevssp,
	Rdpkru,
	Wrpkru,
	Swapgs,
	Rdtscp,
	Monitorxw,
	Monitorxd,
	Monitorxq,
	Mcommit,
	Mwaitx,
	Clzerow,
	Clzerod,
	Clzeroq,
	Rdpru,
	Lar_r16_rm16,
	Lar_r32_r32m16,
	Lar_r64_r64m16,
	Lsl_r16_rm16,
	Lsl_r32_r32m16,
	Lsl_r64_r64m16,
	Storeall,
	Loadall286,
	Syscall,
	Clts,
	Loadall386,
	Sysretd,
	Sysretq,
	Invd,
	Wbinvd,
	Wbnoinvd,
	Cl1invmb,
	Ud2,
	Reservednop_rm16_r16_0F0D,
	Reservednop_rm32_r32_0F0D,
	Reservednop_rm64_r64_0F0D,
	Prefetch_m8,
	Prefetchw_m8,
	Prefetchwt1_m8,
	Femms,
	Umov_rm8_r8,
	Umov_rm16_r16,
	Umov_rm32_r32,
	Umov_r8_rm8,
	Umov_r16_rm16,
	Umov_r32_rm32,
	Movups_xmm_xmmm128,
	VEX_Vmovups_xmm_xmmm128,
	VEX_Vmovups_ymm_ymmm256,
	EVEX_Vmovups_xmm_k1z_xmmm128,
	EVEX_Vmovups_ymm_k1z_ymmm256,
	EVEX_Vmovups_zmm_k1z_zmmm512,
	Movupd_xmm_xmmm128,
	VEX_Vmovupd_xmm_xmmm128,
	VEX_Vmovupd_ymm_ymmm256,
	EVEX_Vmovupd_xmm_k1z_xmmm128,
	EVEX_Vmovupd_ymm_k1z_ymmm256,
	EVEX_Vmovupd_zmm_k1z_zmmm512,
	Movss_xmm_xmmm32,
	VEX_Vmovss_xmm_xmm_xmm,
	VEX_Vmovss_xmm_m32,
	EVEX_Vmovss_xmm_k1z_xmm_xmm,
	EVEX_Vmovss_xmm_k1z_m32,
	Movsd_xmm_xmmm64,
	VEX_Vmovsd_xmm_xmm_xmm,
	VEX_Vmovsd_xmm_m64,
	EVEX_Vmovsd_xmm_k1z_xmm_xmm,
	EVEX_Vmovsd_xmm_k1z_m64,
	Movups_xmmm128_xmm,
	VEX_Vmovups_xmmm128_xmm,
	VEX_Vmovups_ymmm256_ymm,
	EVEX_Vmovups_xmmm128_k1z_xmm,
	EVEX_Vmovups_ymmm256_k1z_ymm,
	EVEX_Vmovups_zmmm512_k1z_zmm,
	Movupd_xmmm128_xmm,
	VEX_Vmovupd_xmmm128_xmm,
	VEX_Vmovupd_ymmm256_ymm,
	EVEX_Vmovupd_xmmm128_k1z_xmm,
	EVEX_Vmovupd_ymmm256_k1z_ymm,
	EVEX_Vmovupd_zmmm512_k1z_zmm,
	Movss_xmmm32_xmm,
	VEX_Vmovss_xmm_xmm_xmm_0F11,
	VEX_Vmovss_m32_xmm,
	EVEX_Vmovss_xmm_k1z_xmm_xmm_0F11,
	EVEX_Vmovss_m32_k1_xmm,
	Movsd_xmmm64_xmm,
	VEX_Vmovsd_xmm_xmm_xmm_0F11,
	VEX_Vmovsd_m64_xmm,
	EVEX_Vmovsd_xmm_k1z_xmm_xmm_0F11,
	EVEX_Vmovsd_m64_k1_xmm,
	Movhlps_xmm_xmm,
	Movlps_xmm_m64,
	VEX_Vmovhlps_xmm_xmm_xmm,
	VEX_Vmovlps_xmm_xmm_m64,
	EVEX_Vmovhlps_xmm_xmm_xmm,
	EVEX_Vmovlps_xmm_xmm_m64,
	Movlpd_xmm_m64,
	VEX_Vmovlpd_xmm_xmm_m64,
	EVEX_Vmovlpd_xmm_xmm_m64,
	Movsldup_xmm_xmmm128,
	VEX_Vmovsldup_xmm_xmmm128,
	VEX_Vmovsldup_ymm_ymmm256,
	EVEX_Vmovsldup_xmm_k1z_xmmm128,
	EVEX_Vmovsldup_ymm_k1z_ymmm256,
	EVEX_Vmovsldup_zmm_k1z_zmmm512,
	Movddup_xmm_xmmm64,
	VEX_Vmovddup_xmm_xmmm64,
	VEX_Vmovddup_ymm_ymmm256,
	EVEX_Vmovddup_xmm_k1z_xmmm64,
	EVEX_Vmovddup_ymm_k1z_ymmm256,
	EVEX_Vmovddup_zmm_k1z_zmmm512,
	Movlps_m64_xmm,
	VEX_Vmovlps_m64_xmm,
	EVEX_Vmovlps_m64_xmm,
	Movlpd_m64_xmm,
	VEX_Vmovlpd_m64_xmm,
	EVEX_Vmovlpd_m64_xmm,
	Unpcklps_xmm_xmmm128,
	VEX_Vunpcklps_xmm_xmm_xmmm128,
	VEX_Vunpcklps_ymm_ymm_ymmm256,
	EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32,
	Unpcklpd_xmm_xmmm128,
	VEX_Vunpcklpd_xmm_xmm_xmmm128,
	VEX_Vunpcklpd_ymm_ymm_ymmm256,
	EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64,
	Unpckhps_xmm_xmmm128,
	VEX_Vunpckhps_xmm_xmm_xmmm128,
	VEX_Vunpckhps_ymm_ymm_ymmm256,
	EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32,
	Unpckhpd_xmm_xmmm128,
	VEX_Vunpckhpd_xmm_xmm_xmmm128,
	VEX_Vunpckhpd_ymm_ymm_ymmm256,
	EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64,
	Movlhps_xmm_xmm,
	VEX_Vmovlhps_xmm_xmm_xmm,
	EVEX_Vmovlhps_xmm_xmm_xmm,
	Movhps_xmm_m64,
	VEX_Vmovhps_xmm_xmm_m64,
	EVEX_Vmovhps_xmm_xmm_m64,
	Movhpd_xmm_m64,
	VEX_Vmovhpd_xmm_xmm_m64,
	EVEX_Vmovhpd_xmm_xmm_m64,
	Movshdup_xmm_xmmm128,
	VEX_Vmovshdup_xmm_xmmm128,
	VEX_Vmovshdup_ymm_ymmm256,
	EVEX_Vmovshdup_xmm_k1z_xmmm128,
	EVEX_Vmovshdup_ymm_k1z_ymmm256,
	EVEX_Vmovshdup_zmm_k1z_zmmm512,
	Movhps_m64_xmm,
	VEX_Vmovhps_m64_xmm,
	EVEX_Vmovhps_m64_xmm,
	Movhpd_m64_xmm,
	VEX_Vmovhpd_m64_xmm,
	EVEX_Vmovhpd_m64_xmm,
	Reservednop_rm16_r16_0F18,
	Reservednop_rm32_r32_0F18,
	Reservednop_rm64_r64_0F18,
	Reservednop_rm16_r16_0F19,
	Reservednop_rm32_r32_0F19,
	Reservednop_rm64_r64_0F19,
	Reservednop_rm16_r16_0F1A,
	Reservednop_rm32_r32_0F1A,
	Reservednop_rm64_r64_0F1A,
	Reservednop_rm16_r16_0F1B,
	Reservednop_rm32_r32_0F1B,
	Reservednop_rm64_r64_0F1B,
	Reservednop_rm16_r16_0F1C,
	Reservednop_rm32_r32_0F1C,
	Reservednop_rm64_r64_0F1C,
	Reservednop_rm16_r16_0F1D,
	Reservednop_rm32_r32_0F1D,
	Reservednop_rm64_r64_0F1D,
	Reservednop_rm16_r16_0F1E,
	Reservednop_rm32_r32_0F1E,
	Reservednop_rm64_r64_0F1E,
	Reservednop_rm16_r16_0F1F,
	Reservednop_rm32_r32_0F1F,
	Reservednop_rm64_r64_0F1F,
	Prefetchnta_m8,
	Prefetcht0_m8,
	Prefetcht1_m8,
	Prefetcht2_m8,
	Bndldx_bnd_mib,
	Bndmov_bnd_bndm64,
	Bndmov_bnd_bndm128,
	Bndcl_bnd_rm32,
	Bndcl_bnd_rm64,
	Bndcu_bnd_rm32,
	Bndcu_bnd_rm64,
	Bndstx_mib_bnd,
	Bndmov_bndm64_bnd,
	Bndmov_bndm128_bnd,
	Bndmk_bnd_m32,
	Bndmk_bnd_m64,
	Bndcn_bnd_rm32,
	Bndcn_bnd_rm64,
	Cldemote_m8,
	Rdsspd_r32,
	Rdsspq_r64,
	Endbr64,
	Endbr32,
	Nop_rm16,
	Nop_rm32,
	Nop_rm64,
	Mov_r32_cr,
	Mov_r64_cr,
	Mov_r32_dr,
	Mov_r64_dr,
	Mov_cr_r32,
	Mov_cr_r64,
	Mov_dr_r32,
	Mov_dr_r64,
	Mov_r32_tr,
	Mov_tr_r32,
	Movaps_xmm_xmmm128,
	VEX_Vmovaps_xmm_xmmm128,
	VEX_Vmovaps_ymm_ymmm256,
	EVEX_Vmovaps_xmm_k1z_xmmm128,
	EVEX_Vmovaps_ymm_k1z_ymmm256,
	EVEX_Vmovaps_zmm_k1z_zmmm512,
	Movapd_xmm_xmmm128,
	VEX_Vmovapd_xmm_xmmm128,
	VEX_Vmovapd_ymm_ymmm256,
	EVEX_Vmovapd_xmm_k1z_xmmm128,
	EVEX_Vmovapd_ymm_k1z_ymmm256,
	EVEX_Vmovapd_zmm_k1z_zmmm512,
	Movaps_xmmm128_xmm,
	VEX_Vmovaps_xmmm128_xmm,
	VEX_Vmovaps_ymmm256_ymm,
	EVEX_Vmovaps_xmmm128_k1z_xmm,
	EVEX_Vmovaps_ymmm256_k1z_ymm,
	EVEX_Vmovaps_zmmm512_k1z_zmm,
	Movapd_xmmm128_xmm,
	VEX_Vmovapd_xmmm128_xmm,
	VEX_Vmovapd_ymmm256_ymm,
	EVEX_Vmovapd_xmmm128_k1z_xmm,
	EVEX_Vmovapd_ymmm256_k1z_ymm,
	EVEX_Vmovapd_zmmm512_k1z_zmm,
	Cvtpi2ps_xmm_mmm64,
	Cvtpi2pd_xmm_mmm64,
	Cvtsi2ss_xmm_rm32,
	Cvtsi2ss_xmm_rm64,
	VEX_Vcvtsi2ss_xmm_xmm_rm32,
	VEX_Vcvtsi2ss_xmm_xmm_rm64,
	EVEX_Vcvtsi2ss_xmm_xmm_rm32_er,
	EVEX_Vcvtsi2ss_xmm_xmm_rm64_er,
	Cvtsi2sd_xmm_rm32,
	Cvtsi2sd_xmm_rm64,
	VEX_Vcvtsi2sd_xmm_xmm_rm32,
	VEX_Vcvtsi2sd_xmm_xmm_rm64,
	EVEX_Vcvtsi2sd_xmm_xmm_rm32_er,
	EVEX_Vcvtsi2sd_xmm_xmm_rm64_er,
	Movntps_m128_xmm,
	VEX_Vmovntps_m128_xmm,
	VEX_Vmovntps_m256_ymm,
	EVEX_Vmovntps_m128_xmm,
	EVEX_Vmovntps_m256_ymm,
	EVEX_Vmovntps_m512_zmm,
	Movntpd_m128_xmm,
	VEX_Vmovntpd_m128_xmm,
	VEX_Vmovntpd_m256_ymm,
	EVEX_Vmovntpd_m128_xmm,
	EVEX_Vmovntpd_m256_ymm,
	EVEX_Vmovntpd_m512_zmm,
	Movntss_m32_xmm,
	Movntsd_m64_xmm,
	Cvttps2pi_mm_xmmm64,
	Cvttpd2pi_mm_xmmm128,
	Cvttss2si_r32_xmmm32,
	Cvttss2si_r64_xmmm32,
	VEX_Vcvttss2si_r32_xmmm32,
	VEX_Vcvttss2si_r64_xmmm32,
	EVEX_Vcvttss2si_r32_xmmm32_sae,
	EVEX_Vcvttss2si_r64_xmmm32_sae,
	Cvttsd2si_r32_xmmm64,
	Cvttsd2si_r64_xmmm64,
	VEX_Vcvttsd2si_r32_xmmm64,
	VEX_Vcvttsd2si_r64_xmmm64,
	EVEX_Vcvttsd2si_r32_xmmm64_sae,
	EVEX_Vcvttsd2si_r64_xmmm64_sae,
	Cvtps2pi_mm_xmmm64,
	Cvtpd2pi_mm_xmmm128,
	Cvtss2si_r32_xmmm32,
	Cvtss2si_r64_xmmm32,
	VEX_Vcvtss2si_r32_xmmm32,
	VEX_Vcvtss2si_r64_xmmm32,
	EVEX_Vcvtss2si_r32_xmmm32_er,
	EVEX_Vcvtss2si_r64_xmmm32_er,
	Cvtsd2si_r32_xmmm64,
	Cvtsd2si_r64_xmmm64,
	VEX_Vcvtsd2si_r32_xmmm64,
	VEX_Vcvtsd2si_r64_xmmm64,
	EVEX_Vcvtsd2si_r32_xmmm64_er,
	EVEX_Vcvtsd2si_r64_xmmm64_er,
	Ucomiss_xmm_xmmm32,
	VEX_Vucomiss_xmm_xmmm32,
	EVEX_Vucomiss_xmm_xmmm32_sae,
	Ucomisd_xmm_xmmm64,
	VEX_Vucomisd_xmm_xmmm64,
	EVEX_Vucomisd_xmm_xmmm64_sae,
	Comiss_xmm_xmmm32,
	Comisd_xmm_xmmm64,
	VEX_Vcomiss_xmm_xmmm32,
	VEX_Vcomisd_xmm_xmmm64,
	EVEX_Vcomiss_xmm_xmmm32_sae,
	EVEX_Vcomisd_xmm_xmmm64_sae,
	Wrmsr,
	Rdtsc,
	Rdmsr,
	Rdpmc,
	Sysenter,
	Sysexitd,
	Sysexitq,
	Getsecd,
	Cmovo_r16_rm16,
	Cmovo_r32_rm32,
	Cmovo_r64_rm64,
	Cmovno_r16_rm16,
	Cmovno_r32_rm32,
	Cmovno_r64_rm64,
	Cmovb_r16_rm16,
	Cmovb_r32_rm32,
	Cmovb_r64_rm64,
	Cmovae_r16_rm16,
	Cmovae_r32_rm32,
	Cmovae_r64_rm64,
	Cmove_r16_rm16,
	Cmove_r32_rm32,
	Cmove_r64_rm64,
	Cmovne_r16_rm16,
	Cmovne_r32_rm32,
	Cmovne_r64_rm64,
	Cmovbe_r16_rm16,
	Cmovbe_r32_rm32,
	Cmovbe_r64_rm64,
	Cmova_r16_rm16,
	Cmova_r32_rm32,
	Cmova_r64_rm64,
	Cmovs_r16_rm16,
	Cmovs_r32_rm32,
	Cmovs_r64_rm64,
	Cmovns_r16_rm16,
	Cmovns_r32_rm32,
	Cmovns_r64_rm64,
	Cmovp_r16_rm16,
	Cmovp_r32_rm32,
	Cmovp_r64_rm64,
	Cmovnp_r16_rm16,
	Cmovnp_r32_rm32,
	Cmovnp_r64_rm64,
	Cmovl_r16_rm16,
	Cmovl_r32_rm32,
	Cmovl_r64_rm64,
	Cmovge_r16_rm16,
	Cmovge_r32_rm32,
	Cmovge_r64_rm64,
	Cmovle_r16_rm16,
	Cmovle_r32_rm32,
	Cmovle_r64_rm64,
	Cmovg_r16_rm16,
	Cmovg_r32_rm32,
	Cmovg_r64_rm64,
	VEX_Kandw_kr_kr_kr,
	VEX_Kandq_kr_kr_kr,
	VEX_Kandb_kr_kr_kr,
	VEX_Kandd_kr_kr_kr,
	VEX_Kandnw_kr_kr_kr,
	VEX_Kandnq_kr_kr_kr,
	VEX_Kandnb_kr_kr_kr,
	VEX_Kandnd_kr_kr_kr,
	VEX_Knotw_kr_kr,
	VEX_Knotq_kr_kr,
	VEX_Knotb_kr_kr,
	VEX_Knotd_kr_kr,
	VEX_Korw_kr_kr_kr,
	VEX_Korq_kr_kr_kr,
	VEX_Korb_kr_kr_kr,
	VEX_Kord_kr_kr_kr,
	VEX_Kxnorw_kr_kr_kr,
	VEX_Kxnorq_kr_kr_kr,
	VEX_Kxnorb_kr_kr_kr,
	VEX_Kxnord_kr_kr_kr,
	VEX_Kxorw_kr_kr_kr,
	VEX_Kxorq_kr_kr_kr,
	VEX_Kxorb_kr_kr_kr,
	VEX_Kxord_kr_kr_kr,
	VEX_Kaddw_kr_kr_kr,
	VEX_Kaddq_kr_kr_kr,
	VEX_Kaddb_kr_kr_kr,
	VEX_Kaddd_kr_kr_kr,
	VEX_Kunpckwd_kr_kr_kr,
	VEX_Kunpckdq_kr_kr_kr,
	VEX_Kunpckbw_kr_kr_kr,
	Movmskps_r32_xmm,
	Movmskps_r64_xmm,
	VEX_Vmovmskps_r32_xmm,
	VEX_Vmovmskps_r64_xmm,
	VEX_Vmovmskps_r32_ymm,
	VEX_Vmovmskps_r64_ymm,
	Movmskpd_r32_xmm,
	Movmskpd_r64_xmm,
	VEX_Vmovmskpd_r32_xmm,
	VEX_Vmovmskpd_r64_xmm,
	VEX_Vmovmskpd_r32_ymm,
	VEX_Vmovmskpd_r64_ymm,
	Sqrtps_xmm_xmmm128,
	VEX_Vsqrtps_xmm_xmmm128,
	VEX_Vsqrtps_ymm_ymmm256,
	EVEX_Vsqrtps_xmm_k1z_xmmm128b32,
	EVEX_Vsqrtps_ymm_k1z_ymmm256b32,
	EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er,
	Sqrtpd_xmm_xmmm128,
	VEX_Vsqrtpd_xmm_xmmm128,
	VEX_Vsqrtpd_ymm_ymmm256,
	EVEX_Vsqrtpd_xmm_k1z_xmmm128b64,
	EVEX_Vsqrtpd_ymm_k1z_ymmm256b64,
	EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er,
	Sqrtss_xmm_xmmm32,
	VEX_Vsqrtss_xmm_xmm_xmmm32,
	EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er,
	Sqrtsd_xmm_xmmm64,
	VEX_Vsqrtsd_xmm_xmm_xmmm64,
	EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er,
	Rsqrtps_xmm_xmmm128,
	VEX_Vrsqrtps_xmm_xmmm128,
	VEX_Vrsqrtps_ymm_ymmm256,
	Rsqrtss_xmm_xmmm32,
	VEX_Vrsqrtss_xmm_xmm_xmmm32,
	Rcpps_xmm_xmmm128,
	VEX_Vrcpps_xmm_xmmm128,
	VEX_Vrcpps_ymm_ymmm256,
	Rcpss_xmm_xmmm32,
	VEX_Vrcpss_xmm_xmm_xmmm32,
	Andps_xmm_xmmm128,
	VEX_Vandps_xmm_xmm_xmmm128,
	VEX_Vandps_ymm_ymm_ymmm256,
	EVEX_Vandps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vandps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vandps_zmm_k1z_zmm_zmmm512b32,
	Andpd_xmm_xmmm128,
	VEX_Vandpd_xmm_xmm_xmmm128,
	VEX_Vandpd_ymm_ymm_ymmm256,
	EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64,
	Andnps_xmm_xmmm128,
	VEX_Vandnps_xmm_xmm_xmmm128,
	VEX_Vandnps_ymm_ymm_ymmm256,
	EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32,
	Andnpd_xmm_xmmm128,
	VEX_Vandnpd_xmm_xmm_xmmm128,
	VEX_Vandnpd_ymm_ymm_ymmm256,
	EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64,
	Orps_xmm_xmmm128,
	VEX_Vorps_xmm_xmm_xmmm128,
	VEX_Vorps_ymm_ymm_ymmm256,
	EVEX_Vorps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vorps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vorps_zmm_k1z_zmm_zmmm512b32,
	Orpd_xmm_xmmm128,
	VEX_Vorpd_xmm_xmm_xmmm128,
	VEX_Vorpd_ymm_ymm_ymmm256,
	EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64,
	Xorps_xmm_xmmm128,
	VEX_Vxorps_xmm_xmm_xmmm128,
	VEX_Vxorps_ymm_ymm_ymmm256,
	EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32,
	Xorpd_xmm_xmmm128,
	VEX_Vxorpd_xmm_xmm_xmmm128,
	VEX_Vxorpd_ymm_ymm_ymmm256,
	EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64,
	Addps_xmm_xmmm128,
	VEX_Vaddps_xmm_xmm_xmmm128,
	VEX_Vaddps_ymm_ymm_ymmm256,
	EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er,
	Addpd_xmm_xmmm128,
	VEX_Vaddpd_xmm_xmm_xmmm128,
	VEX_Vaddpd_ymm_ymm_ymmm256,
	EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er,
	Addss_xmm_xmmm32,
	VEX_Vaddss_xmm_xmm_xmmm32,
	EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er,
	Addsd_xmm_xmmm64,
	VEX_Vaddsd_xmm_xmm_xmmm64,
	EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er,
	Mulps_xmm_xmmm128,
	VEX_Vmulps_xmm_xmm_xmmm128,
	VEX_Vmulps_ymm_ymm_ymmm256,
	EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er,
	Mulpd_xmm_xmmm128,
	VEX_Vmulpd_xmm_xmm_xmmm128,
	VEX_Vmulpd_ymm_ymm_ymmm256,
	EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er,
	Mulss_xmm_xmmm32,
	VEX_Vmulss_xmm_xmm_xmmm32,
	EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er,
	Mulsd_xmm_xmmm64,
	VEX_Vmulsd_xmm_xmm_xmmm64,
	EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er,
	Cvtps2pd_xmm_xmmm64,
	VEX_Vcvtps2pd_xmm_xmmm64,
	VEX_Vcvtps2pd_ymm_xmmm128,
	EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32,
	EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32,
	EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae,
	Cvtpd2ps_xmm_xmmm128,
	VEX_Vcvtpd2ps_xmm_xmmm128,
	VEX_Vcvtpd2ps_xmm_ymmm256,
	EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64,
	EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64,
	EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er,
	Cvtss2sd_xmm_xmmm32,
	VEX_Vcvtss2sd_xmm_xmm_xmmm32,
	EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae,
	Cvtsd2ss_xmm_xmmm64,
	VEX_Vcvtsd2ss_xmm_xmm_xmmm64,
	EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er,
	Cvtdq2ps_xmm_xmmm128,
	VEX_Vcvtdq2ps_xmm_xmmm128,
	VEX_Vcvtdq2ps_ymm_ymmm256,
	EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32,
	EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32,
	EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er,
	EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64,
	EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64,
	EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er,
	Cvtps2dq_xmm_xmmm128,
	VEX_Vcvtps2dq_xmm_xmmm128,
	VEX_Vcvtps2dq_ymm_ymmm256,
	EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32,
	EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32,
	EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er,
	Cvttps2dq_xmm_xmmm128,
	VEX_Vcvttps2dq_xmm_xmmm128,
	VEX_Vcvttps2dq_ymm_ymmm256,
	EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32,
	EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32,
	EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae,
	Subps_xmm_xmmm128,
	VEX_Vsubps_xmm_xmm_xmmm128,
	VEX_Vsubps_ymm_ymm_ymmm256,
	EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er,
	Subpd_xmm_xmmm128,
	VEX_Vsubpd_xmm_xmm_xmmm128,
	VEX_Vsubpd_ymm_ymm_ymmm256,
	EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er,
	Subss_xmm_xmmm32,
	VEX_Vsubss_xmm_xmm_xmmm32,
	EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er,
	Subsd_xmm_xmmm64,
	VEX_Vsubsd_xmm_xmm_xmmm64,
	EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er,
	Minps_xmm_xmmm128,
	VEX_Vminps_xmm_xmm_xmmm128,
	VEX_Vminps_ymm_ymm_ymmm256,
	EVEX_Vminps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vminps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae,
	Minpd_xmm_xmmm128,
	VEX_Vminpd_xmm_xmm_xmmm128,
	VEX_Vminpd_ymm_ymm_ymmm256,
	EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae,
	Minss_xmm_xmmm32,
	VEX_Vminss_xmm_xmm_xmmm32,
	EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae,
	Minsd_xmm_xmmm64,
	VEX_Vminsd_xmm_xmm_xmmm64,
	EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae,
	Divps_xmm_xmmm128,
	VEX_Vdivps_xmm_xmm_xmmm128,
	VEX_Vdivps_ymm_ymm_ymmm256,
	EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er,
	Divpd_xmm_xmmm128,
	VEX_Vdivpd_xmm_xmm_xmmm128,
	VEX_Vdivpd_ymm_ymm_ymmm256,
	EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er,
	Divss_xmm_xmmm32,
	VEX_Vdivss_xmm_xmm_xmmm32,
	EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er,
	Divsd_xmm_xmmm64,
	VEX_Vdivsd_xmm_xmm_xmmm64,
	EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er,
	Maxps_xmm_xmmm128,
	VEX_Vmaxps_xmm_xmm_xmmm128,
	VEX_Vmaxps_ymm_ymm_ymmm256,
	EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae,
	Maxpd_xmm_xmmm128,
	VEX_Vmaxpd_xmm_xmm_xmmm128,
	VEX_Vmaxpd_ymm_ymm_ymmm256,
	EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae,
	Maxss_xmm_xmmm32,
	VEX_Vmaxss_xmm_xmm_xmmm32,
	EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae,
	Maxsd_xmm_xmmm64,
	VEX_Vmaxsd_xmm_xmm_xmmm64,
	EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae,
	Punpcklbw_mm_mmm32,
	Punpcklbw_xmm_xmmm128,
	VEX_Vpunpcklbw_xmm_xmm_xmmm128,
	VEX_Vpunpcklbw_ymm_ymm_ymmm256,
	EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512,
	Punpcklwd_mm_mmm32,
	Punpcklwd_xmm_xmmm128,
	VEX_Vpunpcklwd_xmm_xmm_xmmm128,
	VEX_Vpunpcklwd_ymm_ymm_ymmm256,
	EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128,
	EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256,
	EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512,
	Punpckldq_mm_mmm32,
	Punpckldq_xmm_xmmm128,
	VEX_Vpunpckldq_xmm_xmm_xmmm128,
	VEX_Vpunpckldq_ymm_ymm_ymmm256,
	EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32,
	Packsswb_mm_mmm64,
	Packsswb_xmm_xmmm128,
	VEX_Vpacksswb_xmm_xmm_xmmm128,
	VEX_Vpacksswb_ymm_ymm_ymmm256,
	EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512,
	Pcmpgtb_mm_mmm64,
	Pcmpgtb_xmm_xmmm128,
	VEX_Vpcmpgtb_xmm_xmm_xmmm128,
	VEX_Vpcmpgtb_ymm_ymm_ymmm256,
	EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128,
	EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256,
	EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512,
	Pcmpgtw_mm_mmm64,
	Pcmpgtw_xmm_xmmm128,
	VEX_Vpcmpgtw_xmm_xmm_xmmm128,
	VEX_Vpcmpgtw_ymm_ymm_ymmm256,
	EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128,
	EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256,
	EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512,
	Pcmpgtd_mm_mmm64,
	Pcmpgtd_xmm_xmmm128,
	VEX_Vpcmpgtd_xmm_xmm_xmmm128,
	VEX_Vpcmpgtd_ymm_ymm_ymmm256,
	EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32,
	EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32,
	EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32,
	Packuswb_mm_mmm64,
	Packuswb_xmm_xmmm128,
	VEX_Vpackuswb_xmm_xmm_xmmm128,
	VEX_Vpackuswb_ymm_ymm_ymmm256,
	EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512,
	Punpckhbw_mm_mmm64,
	Punpckhbw_xmm_xmmm128,
	VEX_Vpunpckhbw_xmm_xmm_xmmm128,
	VEX_Vpunpckhbw_ymm_ymm_ymmm256,
	EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512,
	Punpckhwd_mm_mmm64,
	Punpckhwd_xmm_xmmm128,
	VEX_Vpunpckhwd_xmm_xmm_xmmm128,
	VEX_Vpunpckhwd_ymm_ymm_ymmm256,
	EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128,
	EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256,
	EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512,
	Punpckhdq_mm_mmm64,
	Punpckhdq_xmm_xmmm128,
	VEX_Vpunpckhdq_xmm_xmm_xmmm128,
	VEX_Vpunpckhdq_ymm_ymm_ymmm256,
	EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32,
	Packssdw_mm_mmm64,
	Packssdw_xmm_xmmm128,
	VEX_Vpackssdw_xmm_xmm_xmmm128,
	VEX_Vpackssdw_ymm_ymm_ymmm256,
	EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32,
	Punpcklqdq_xmm_xmmm128,
	VEX_Vpunpcklqdq_xmm_xmm_xmmm128,
	VEX_Vpunpcklqdq_ymm_ymm_ymmm256,
	EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64,
	Punpckhqdq_xmm_xmmm128,
	VEX_Vpunpckhqdq_xmm_xmm_xmmm128,
	VEX_Vpunpckhqdq_ymm_ymm_ymmm256,
	EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64,
	Movd_mm_rm32,
	Movq_mm_rm64,
	Movd_xmm_rm32,
	Movq_xmm_rm64,
	VEX_Vmovd_xmm_rm32,
	VEX_Vmovq_xmm_rm64,
	EVEX_Vmovd_xmm_rm32,
	EVEX_Vmovq_xmm_rm64,
	Movq_mm_mmm64,
	Movdqa_xmm_xmmm128,
	VEX_Vmovdqa_xmm_xmmm128,
	VEX_Vmovdqa_ymm_ymmm256,
	EVEX_Vmovdqa32_xmm_k1z_xmmm128,
	EVEX_Vmovdqa32_ymm_k1z_ymmm256,
	EVEX_Vmovdqa32_zmm_k1z_zmmm512,
	EVEX_Vmovdqa64_xmm_k1z_xmmm128,
	EVEX_Vmovdqa64_ymm_k1z_ymmm256,
	EVEX_Vmovdqa64_zmm_k1z_zmmm512,
	Movdqu_xmm_xmmm128,
	VEX_Vmovdqu_xmm_xmmm128,
	VEX_Vmovdqu_ymm_ymmm256,
	EVEX_Vmovdqu32_xmm_k1z_xmmm128,
	EVEX_Vmovdqu32_ymm_k1z_ymmm256,
	EVEX_Vmovdqu32_zmm_k1z_zmmm512,
	EVEX_Vmovdqu64_xmm_k1z_xmmm128,
	EVEX_Vmovdqu64_ymm_k1z_ymmm256,
	EVEX_Vmovdqu64_zmm_k1z_zmmm512,
	EVEX_Vmovdqu8_xmm_k1z_xmmm128,
	EVEX_Vmovdqu8_ymm_k1z_ymmm256,
	EVEX_Vmovdqu8_zmm_k1z_zmmm512,
	EVEX_Vmovdqu16_xmm_k1z_xmmm128,
	EVEX_Vmovdqu16_ymm_k1z_ymmm256,
	EVEX_Vmovdqu16_zmm_k1z_zmmm512,
	Pshufw_mm_mmm64_imm8,
	Pshufd_xmm_xmmm128_imm8,
	VEX_Vpshufd_xmm_xmmm128_imm8,
	VEX_Vpshufd_ymm_ymmm256_imm8,
	EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8,
	Pshufhw_xmm_xmmm128_imm8,
	VEX_Vpshufhw_xmm_xmmm128_imm8,
	VEX_Vpshufhw_ymm_ymmm256_imm8,
	EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8,
	EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8,
	EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8,
	Pshuflw_xmm_xmmm128_imm8,
	VEX_Vpshuflw_xmm_xmmm128_imm8,
	VEX_Vpshuflw_ymm_ymmm256_imm8,
	EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8,
	EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8,
	EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8,
	Psrlw_mm_imm8,
	Psrlw_xmm_imm8,
	VEX_Vpsrlw_xmm_xmm_imm8,
	VEX_Vpsrlw_ymm_ymm_imm8,
	EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8,
	EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8,
	EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8,
	Psraw_mm_imm8,
	Psraw_xmm_imm8,
	VEX_Vpsraw_xmm_xmm_imm8,
	VEX_Vpsraw_ymm_ymm_imm8,
	EVEX_Vpsraw_xmm_k1z_xmmm128_imm8,
	EVEX_Vpsraw_ymm_k1z_ymmm256_imm8,
	EVEX_Vpsraw_zmm_k1z_zmmm512_imm8,
	Psllw_mm_imm8,
	Psllw_xmm_imm8,
	VEX_Vpsllw_xmm_xmm_imm8,
	VEX_Vpsllw_ymm_ymm_imm8,
	EVEX_Vpsllw_xmm_k1z_xmmm128_imm8,
	EVEX_Vpsllw_ymm_k1z_ymmm256_imm8,
	EVEX_Vpsllw_zmm_k1z_zmmm512_imm8,
	EVEX_Vprord_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vprord_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vprord_zmm_k1z_zmmm512b32_imm8,
	EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8,
	EVEX_Vprold_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vprold_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vprold_zmm_k1z_zmmm512b32_imm8,
	EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8,
	Psrld_mm_imm8,
	Psrld_xmm_imm8,
	VEX_Vpsrld_xmm_xmm_imm8,
	VEX_Vpsrld_ymm_ymm_imm8,
	EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8,
	Psrad_mm_imm8,
	Psrad_xmm_imm8,
	VEX_Vpsrad_xmm_xmm_imm8,
	VEX_Vpsrad_ymm_ymm_imm8,
	EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8,
	EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8,
	Pslld_mm_imm8,
	Pslld_xmm_imm8,
	VEX_Vpslld_xmm_xmm_imm8,
	VEX_Vpslld_ymm_ymm_imm8,
	EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8,
	Psrlq_mm_imm8,
	Psrlq_xmm_imm8,
	VEX_Vpsrlq_xmm_xmm_imm8,
	VEX_Vpsrlq_ymm_ymm_imm8,
	EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8,
	Psrldq_xmm_imm8,
	VEX_Vpsrldq_xmm_xmm_imm8,
	VEX_Vpsrldq_ymm_ymm_imm8,
	EVEX_Vpsrldq_xmm_xmmm128_imm8,
	EVEX_Vpsrldq_ymm_ymmm256_imm8,
	EVEX_Vpsrldq_zmm_zmmm512_imm8,
	Psllq_mm_imm8,
	Psllq_xmm_imm8,
	VEX_Vpsllq_xmm_xmm_imm8,
	VEX_Vpsllq_ymm_ymm_imm8,
	EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8,
	Pslldq_xmm_imm8,
	VEX_Vpslldq_xmm_xmm_imm8,
	VEX_Vpslldq_ymm_ymm_imm8,
	EVEX_Vpslldq_xmm_xmmm128_imm8,
	EVEX_Vpslldq_ymm_ymmm256_imm8,
	EVEX_Vpslldq_zmm_zmmm512_imm8,
	Pcmpeqb_mm_mmm64,
	Pcmpeqb_xmm_xmmm128,
	VEX_Vpcmpeqb_xmm_xmm_xmmm128,
	VEX_Vpcmpeqb_ymm_ymm_ymmm256,
	EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128,
	EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256,
	EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512,
	Pcmpeqw_mm_mmm64,
	Pcmpeqw_xmm_xmmm128,
	VEX_Vpcmpeqw_xmm_xmm_xmmm128,
	VEX_Vpcmpeqw_ymm_ymm_ymmm256,
	EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128,
	EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256,
	EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512,
	Pcmpeqd_mm_mmm64,
	Pcmpeqd_xmm_xmmm128,
	VEX_Vpcmpeqd_xmm_xmm_xmmm128,
	VEX_Vpcmpeqd_ymm_ymm_ymmm256,
	EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32,
	EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32,
	EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32,
	Emms,
	VEX_Vzeroupper,
	VEX_Vzeroall,
	Vmread_rm32_r32,
	Vmread_rm64_r64,
	EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32,
	EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32,
	EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae,
	EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64,
	EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64,
	EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae,
	Extrq_xmm_imm8_imm8,
	EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32,
	EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32,
	EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae,
	EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64,
	EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64,
	EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae,
	EVEX_Vcvttss2usi_r32_xmmm32_sae,
	EVEX_Vcvttss2usi_r64_xmmm32_sae,
	Insertq_xmm_xmm_imm8_imm8,
	EVEX_Vcvttsd2usi_r32_xmmm64_sae,
	EVEX_Vcvttsd2usi_r64_xmmm64_sae,
	Vmwrite_r32_rm32,
	Vmwrite_r64_rm64,
	EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32,
	EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32,
	EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er,
	EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64,
	EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64,
	EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er,
	Extrq_xmm_xmm,
	EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32,
	EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32,
	EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er,
	EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64,
	EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64,
	EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er,
	EVEX_Vcvtss2usi_r32_xmmm32_er,
	EVEX_Vcvtss2usi_r64_xmmm32_er,
	Insertq_xmm_xmm,
	EVEX_Vcvtsd2usi_r32_xmmm64_er,
	EVEX_Vcvtsd2usi_r64_xmmm64_er,
	EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32,
	EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32,
	EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae,
	EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64,
	EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64,
	EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae,
	EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32,
	EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32,
	EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er,
	EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64,
	EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64,
	EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er,
	EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32,
	EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32,
	EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er,
	EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64,
	EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64,
	EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er,
	EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32,
	EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32,
	EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er,
	EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64,
	EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64,
	EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er,
	EVEX_Vcvtusi2ss_xmm_xmm_rm32_er,
	EVEX_Vcvtusi2ss_xmm_xmm_rm64_er,
	EVEX_Vcvtusi2sd_xmm_xmm_rm32_er,
	EVEX_Vcvtusi2sd_xmm_xmm_rm64_er,
	Haddpd_xmm_xmmm128,
	VEX_Vhaddpd_xmm_xmm_xmmm128,
	VEX_Vhaddpd_ymm_ymm_ymmm256,
	Haddps_xmm_xmmm128,
	VEX_Vhaddps_xmm_xmm_xmmm128,
	VEX_Vhaddps_ymm_ymm_ymmm256,
	Hsubpd_xmm_xmmm128,
	VEX_Vhsubpd_xmm_xmm_xmmm128,
	VEX_Vhsubpd_ymm_ymm_ymmm256,
	Hsubps_xmm_xmmm128,
	VEX_Vhsubps_xmm_xmm_xmmm128,
	VEX_Vhsubps_ymm_ymm_ymmm256,
	Movd_rm32_mm,
	Movq_rm64_mm,
	Movd_rm32_xmm,
	Movq_rm64_xmm,
	VEX_Vmovd_rm32_xmm,
	VEX_Vmovq_rm64_xmm,
	EVEX_Vmovd_rm32_xmm,
	EVEX_Vmovq_rm64_xmm,
	Movq_xmm_xmmm64,
	VEX_Vmovq_xmm_xmmm64,
	EVEX_Vmovq_xmm_xmmm64,
	Movq_mmm64_mm,
	Movdqa_xmmm128_xmm,
	VEX_Vmovdqa_xmmm128_xmm,
	VEX_Vmovdqa_ymmm256_ymm,
	EVEX_Vmovdqa32_xmmm128_k1z_xmm,
	EVEX_Vmovdqa32_ymmm256_k1z_ymm,
	EVEX_Vmovdqa32_zmmm512_k1z_zmm,
	EVEX_Vmovdqa64_xmmm128_k1z_xmm,
	EVEX_Vmovdqa64_ymmm256_k1z_ymm,
	EVEX_Vmovdqa64_zmmm512_k1z_zmm,
	Movdqu_xmmm128_xmm,
	VEX_Vmovdqu_xmmm128_xmm,
	VEX_Vmovdqu_ymmm256_ymm,
	EVEX_Vmovdqu32_xmmm128_k1z_xmm,
	EVEX_Vmovdqu32_ymmm256_k1z_ymm,
	EVEX_Vmovdqu32_zmmm512_k1z_zmm,
	EVEX_Vmovdqu64_xmmm128_k1z_xmm,
	EVEX_Vmovdqu64_ymmm256_k1z_ymm,
	EVEX_Vmovdqu64_zmmm512_k1z_zmm,
	EVEX_Vmovdqu8_xmmm128_k1z_xmm,
	EVEX_Vmovdqu8_ymmm256_k1z_ymm,
	EVEX_Vmovdqu8_zmmm512_k1z_zmm,
	EVEX_Vmovdqu16_xmmm128_k1z_xmm,
	EVEX_Vmovdqu16_ymmm256_k1z_ymm,
	EVEX_Vmovdqu16_zmmm512_k1z_zmm,
	Jo_rel16,
	Jo_rel32_32,
	Jo_rel32_64,
	Jno_rel16,
	Jno_rel32_32,
	Jno_rel32_64,
	Jb_rel16,
	Jb_rel32_32,
	Jb_rel32_64,
	Jae_rel16,
	Jae_rel32_32,
	Jae_rel32_64,
	Je_rel16,
	Je_rel32_32,
	Je_rel32_64,
	Jne_rel16,
	Jne_rel32_32,
	Jne_rel32_64,
	Jbe_rel16,
	Jbe_rel32_32,
	Jbe_rel32_64,
	Ja_rel16,
	Ja_rel32_32,
	Ja_rel32_64,
	Js_rel16,
	Js_rel32_32,
	Js_rel32_64,
	Jns_rel16,
	Jns_rel32_32,
	Jns_rel32_64,
	Jp_rel16,
	Jp_rel32_32,
	Jp_rel32_64,
	Jnp_rel16,
	Jnp_rel32_32,
	Jnp_rel32_64,
	Jl_rel16,
	Jl_rel32_32,
	Jl_rel32_64,
	Jge_rel16,
	Jge_rel32_32,
	Jge_rel32_64,
	Jle_rel16,
	Jle_rel32_32,
	Jle_rel32_64,
	Jg_rel16,
	Jg_rel32_32,
	Jg_rel32_64,
	Seto_rm8,
	Setno_rm8,
	Setb_rm8,
	Setae_rm8,
	Sete_rm8,
	Setne_rm8,
	Setbe_rm8,
	Seta_rm8,
	Sets_rm8,
	Setns_rm8,
	Setp_rm8,
	Setnp_rm8,
	Setl_rm8,
	Setge_rm8,
	Setle_rm8,
	Setg_rm8,
	VEX_Kmovw_kr_km16,
	VEX_Kmovq_kr_km64,
	VEX_Kmovb_kr_km8,
	VEX_Kmovd_kr_km32,
	VEX_Kmovw_m16_kr,
	VEX_Kmovq_m64_kr,
	VEX_Kmovb_m8_kr,
	VEX_Kmovd_m32_kr,
	VEX_Kmovw_kr_r32,
	VEX_Kmovb_kr_r32,
	VEX_Kmovd_kr_r32,
	VEX_Kmovq_kr_r64,
	VEX_Kmovw_r32_kr,
	VEX_Kmovb_r32_kr,
	VEX_Kmovd_r32_kr,
	VEX_Kmovq_r64_kr,
	VEX_Kortestw_kr_kr,
	VEX_Kortestq_kr_kr,
	VEX_Kortestb_kr_kr,
	VEX_Kortestd_kr_kr,
	VEX_Ktestw_kr_kr,
	VEX_Ktestq_kr_kr,
	VEX_Ktestb_kr_kr,
	VEX_Ktestd_kr_kr,
	Pushw_FS,
	Pushd_FS,
	Pushq_FS,
	Popw_FS,
	Popd_FS,
	Popq_FS,
	Cpuid,
	Bt_rm16_r16,
	Bt_rm32_r32,
	Bt_rm64_r64,
	Shld_rm16_r16_imm8,
	Shld_rm32_r32_imm8,
	Shld_rm64_r64_imm8,
	Shld_rm16_r16_CL,
	Shld_rm32_r32_CL,
	Shld_rm64_r64_CL,
	Montmul_16,
	Montmul_32,
	Montmul_64,
	Xsha1_16,
	Xsha1_32,
	Xsha1_64,
	Xsha256_16,
	Xsha256_32,
	Xsha256_64,
	Xbts_r16_rm16,
	Xbts_r32_rm32,
	Xstore_16,
	Xstore_32,
	Xstore_64,
	Xcryptecb_16,
	Xcryptecb_32,
	Xcryptecb_64,
	Xcryptcbc_16,
	Xcryptcbc_32,
	Xcryptcbc_64,
	Xcryptctr_16,
	Xcryptctr_32,
	Xcryptctr_64,
	Xcryptcfb_16,
	Xcryptcfb_32,
	Xcryptcfb_64,
	Xcryptofb_16,
	Xcryptofb_32,
	Xcryptofb_64,
	Ibts_rm16_r16,
	Ibts_rm32_r32,
	Cmpxchg486_rm8_r8,
	Cmpxchg486_rm16_r16,
	Cmpxchg486_rm32_r32,
	Pushw_GS,
	Pushd_GS,
	Pushq_GS,
	Popw_GS,
	Popd_GS,
	Popq_GS,
	Rsm,
	Bts_rm16_r16,
	Bts_rm32_r32,
	Bts_rm64_r64,
	Shrd_rm16_r16_imm8,
	Shrd_rm32_r32_imm8,
	Shrd_rm64_r64_imm8,
	Shrd_rm16_r16_CL,
	Shrd_rm32_r32_CL,
	Shrd_rm64_r64_CL,
	Fxsave_m512byte,
	Fxsave64_m512byte,
	Rdfsbase_r32,
	Rdfsbase_r64,
	Fxrstor_m512byte,
	Fxrstor64_m512byte,
	Rdgsbase_r32,
	Rdgsbase_r64,
	Ldmxcsr_m32,
	Wrfsbase_r32,
	Wrfsbase_r64,
	VEX_Vldmxcsr_m32,
	Stmxcsr_m32,
	Wrgsbase_r32,
	Wrgsbase_r64,
	VEX_Vstmxcsr_m32,
	Xsave_mem,
	Xsave64_mem,
	Ptwrite_rm32,
	Ptwrite_rm64,
	Xrstor_mem,
	Xrstor64_mem,
	Incsspd_r32,
	Incsspq_r64,
	Xsaveopt_mem,
	Xsaveopt64_mem,
	Clwb_m8,
	Tpause_r32,
	Tpause_r64,
	Clrssbsy_m64,
	Umonitor_r16,
	Umonitor_r32,
	Umonitor_r64,
	Umwait_r32,
	Umwait_r64,
	Clflush_m8,
	Clflushopt_m8,
	Lfence,
	Lfence_E9,
	Lfence_EA,
	Lfence_EB,
	Lfence_EC,
	Lfence_ED,
	Lfence_EE,
	Lfence_EF,
	Mfence,
	Mfence_F1,
	Mfence_F2,
	Mfence_F3,
	Mfence_F4,
	Mfence_F5,
	Mfence_F6,
	Mfence_F7,
	Sfence,
	Sfence_F9,
	Sfence_FA,
	Sfence_FB,
	Sfence_FC,
	Sfence_FD,
	Sfence_FE,
	Sfence_FF,
	Pcommit,
	Imul_r16_rm16,
	Imul_r32_rm32,
	Imul_r64_rm64,
	Cmpxchg_rm8_r8,
	Cmpxchg_rm16_r16,
	Cmpxchg_rm32_r32,
	Cmpxchg_rm64_r64,
	Lss_r16_m1616,
	Lss_r32_m1632,
	Lss_r64_m1664,
	Btr_rm16_r16,
	Btr_rm32_r32,
	Btr_rm64_r64,
	Lfs_r16_m1616,
	Lfs_r32_m1632,
	Lfs_r64_m1664,
	Lgs_r16_m1616,
	Lgs_r32_m1632,
	Lgs_r64_m1664,
	Movzx_r16_rm8,
	Movzx_r32_rm8,
	Movzx_r64_rm8,
	Movzx_r16_rm16,
	Movzx_r32_rm16,
	Movzx_r64_rm16,
	Jmpe_disp16,
	Jmpe_disp32,
	Popcnt_r16_rm16,
	Popcnt_r32_rm32,
	Popcnt_r64_rm64,
	Ud1_r16_rm16,
	Ud1_r32_rm32,
	Ud1_r64_rm64,
	Bt_rm16_imm8,
	Bt_rm32_imm8,
	Bt_rm64_imm8,
	Bts_rm16_imm8,
	Bts_rm32_imm8,
	Bts_rm64_imm8,
	Btr_rm16_imm8,
	Btr_rm32_imm8,
	Btr_rm64_imm8,
	Btc_rm16_imm8,
	Btc_rm32_imm8,
	Btc_rm64_imm8,
	Btc_rm16_r16,
	Btc_rm32_r32,
	Btc_rm64_r64,
	Bsf_r16_rm16,
	Bsf_r32_rm32,
	Bsf_r64_rm64,
	Tzcnt_r16_rm16,
	Tzcnt_r32_rm32,
	Tzcnt_r64_rm64,
	Bsr_r16_rm16,
	Bsr_r32_rm32,
	Bsr_r64_rm64,
	Lzcnt_r16_rm16,
	Lzcnt_r32_rm32,
	Lzcnt_r64_rm64,
	Movsx_r16_rm8,
	Movsx_r32_rm8,
	Movsx_r64_rm8,
	Movsx_r16_rm16,
	Movsx_r32_rm16,
	Movsx_r64_rm16,
	Xadd_rm8_r8,
	Xadd_rm16_r16,
	Xadd_rm32_r32,
	Xadd_rm64_r64,
	Cmpps_xmm_xmmm128_imm8,
	VEX_Vcmpps_xmm_xmm_xmmm128_imm8,
	VEX_Vcmpps_ymm_ymm_ymmm256_imm8,
	EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8,
	EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8,
	EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae,
	Cmppd_xmm_xmmm128_imm8,
	VEX_Vcmppd_xmm_xmm_xmmm128_imm8,
	VEX_Vcmppd_ymm_ymm_ymmm256_imm8,
	EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8,
	EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8,
	EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae,
	Cmpss_xmm_xmmm32_imm8,
	VEX_Vcmpss_xmm_xmm_xmmm32_imm8,
	EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae,
	Cmpsd_xmm_xmmm64_imm8,
	VEX_Vcmpsd_xmm_xmm_xmmm64_imm8,
	EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae,
	Movnti_m32_r32,
	Movnti_m64_r64,
	Pinsrw_mm_r32m16_imm8,
	Pinsrw_mm_r64m16_imm8,
	Pinsrw_xmm_r32m16_imm8,
	Pinsrw_xmm_r64m16_imm8,
	VEX_Vpinsrw_xmm_xmm_r32m16_imm8,
	VEX_Vpinsrw_xmm_xmm_r64m16_imm8,
	EVEX_Vpinsrw_xmm_xmm_r32m16_imm8,
	EVEX_Vpinsrw_xmm_xmm_r64m16_imm8,
	Pextrw_r32_mm_imm8,
	Pextrw_r64_mm_imm8,
	Pextrw_r32_xmm_imm8,
	Pextrw_r64_xmm_imm8,
	VEX_Vpextrw_r32_xmm_imm8,
	VEX_Vpextrw_r64_xmm_imm8,
	EVEX_Vpextrw_r32_xmm_imm8,
	EVEX_Vpextrw_r64_xmm_imm8,
	Shufps_xmm_xmmm128_imm8,
	VEX_Vshufps_xmm_xmm_xmmm128_imm8,
	VEX_Vshufps_ymm_ymm_ymmm256_imm8,
	EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8,
	Shufpd_xmm_xmmm128_imm8,
	VEX_Vshufpd_xmm_xmm_xmmm128_imm8,
	VEX_Vshufpd_ymm_ymm_ymmm256_imm8,
	EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8,
	Cmpxchg8b_m64,
	Cmpxchg16b_m128,
	Xrstors_mem,
	Xrstors64_mem,
	Xsavec_mem,
	Xsavec64_mem,
	Xsaves_mem,
	Xsaves64_mem,
	Vmptrld_m64,
	Vmclear_m64,
	Vmxon_m64,
	Rdrand_r16,
	Rdrand_r32,
	Rdrand_r64,
	Vmptrst_m64,
	Rdseed_r16,
	Rdseed_r32,
	Rdseed_r64,
	Rdpid_r32,
	Rdpid_r64,
	Bswap_r16,
	Bswap_r32,
	Bswap_r64,
	Addsubpd_xmm_xmmm128,
	VEX_Vaddsubpd_xmm_xmm_xmmm128,
	VEX_Vaddsubpd_ymm_ymm_ymmm256,
	Addsubps_xmm_xmmm128,
	VEX_Vaddsubps_xmm_xmm_xmmm128,
	VEX_Vaddsubps_ymm_ymm_ymmm256,
	Psrlw_mm_mmm64,
	Psrlw_xmm_xmmm128,
	VEX_Vpsrlw_xmm_xmm_xmmm128,
	VEX_Vpsrlw_ymm_ymm_xmmm128,
	EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128,
	Psrld_mm_mmm64,
	Psrld_xmm_xmmm128,
	VEX_Vpsrld_xmm_xmm_xmmm128,
	VEX_Vpsrld_ymm_ymm_xmmm128,
	EVEX_Vpsrld_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsrld_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsrld_zmm_k1z_zmm_xmmm128,
	Psrlq_mm_mmm64,
	Psrlq_xmm_xmmm128,
	VEX_Vpsrlq_xmm_xmm_xmmm128,
	VEX_Vpsrlq_ymm_ymm_xmmm128,
	EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128,
	Paddq_mm_mmm64,
	Paddq_xmm_xmmm128,
	VEX_Vpaddq_xmm_xmm_xmmm128,
	VEX_Vpaddq_ymm_ymm_ymmm256,
	EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64,
	Pmullw_mm_mmm64,
	Pmullw_xmm_xmmm128,
	VEX_Vpmullw_xmm_xmm_xmmm128,
	VEX_Vpmullw_ymm_ymm_ymmm256,
	EVEX_Vpmullw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmullw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmullw_zmm_k1z_zmm_zmmm512,
	Movq_xmmm64_xmm,
	VEX_Vmovq_xmmm64_xmm,
	EVEX_Vmovq_xmmm64_xmm,
	Movq2dq_xmm_mm,
	Movdq2q_mm_xmm,
	Pmovmskb_r32_mm,
	Pmovmskb_r64_mm,
	Pmovmskb_r32_xmm,
	Pmovmskb_r64_xmm,
	VEX_Vpmovmskb_r32_xmm,
	VEX_Vpmovmskb_r64_xmm,
	VEX_Vpmovmskb_r32_ymm,
	VEX_Vpmovmskb_r64_ymm,
	Psubusb_mm_mmm64,
	Psubusb_xmm_xmmm128,
	VEX_Vpsubusb_xmm_xmm_xmmm128,
	VEX_Vpsubusb_ymm_ymm_ymmm256,
	EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512,
	Psubusw_mm_mmm64,
	Psubusw_xmm_xmmm128,
	VEX_Vpsubusw_xmm_xmm_xmmm128,
	VEX_Vpsubusw_ymm_ymm_ymmm256,
	EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512,
	Pminub_mm_mmm64,
	Pminub_xmm_xmmm128,
	VEX_Vpminub_xmm_xmm_xmmm128,
	VEX_Vpminub_ymm_ymm_ymmm256,
	EVEX_Vpminub_xmm_k1z_xmm_xmmm128,
	EVEX_Vpminub_ymm_k1z_ymm_ymmm256,
	EVEX_Vpminub_zmm_k1z_zmm_zmmm512,
	Pand_mm_mmm64,
	Pand_xmm_xmmm128,
	VEX_Vpand_xmm_xmm_xmmm128,
	VEX_Vpand_ymm_ymm_ymmm256,
	EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64,
	Paddusb_mm_mmm64,
	Paddusb_xmm_xmmm128,
	VEX_Vpaddusb_xmm_xmm_xmmm128,
	VEX_Vpaddusb_ymm_ymm_ymmm256,
	EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512,
	Paddusw_mm_mmm64,
	Paddusw_xmm_xmmm128,
	VEX_Vpaddusw_xmm_xmm_xmmm128,
	VEX_Vpaddusw_ymm_ymm_ymmm256,
	EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512,
	Pmaxub_mm_mmm64,
	Pmaxub_xmm_xmmm128,
	VEX_Vpmaxub_xmm_xmm_xmmm128,
	VEX_Vpmaxub_ymm_ymm_ymmm256,
	EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512,
	Pandn_mm_mmm64,
	Pandn_xmm_xmmm128,
	VEX_Vpandn_xmm_xmm_xmmm128,
	VEX_Vpandn_ymm_ymm_ymmm256,
	EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64,
	Pavgb_mm_mmm64,
	Pavgb_xmm_xmmm128,
	VEX_Vpavgb_xmm_xmm_xmmm128,
	VEX_Vpavgb_ymm_ymm_ymmm256,
	EVEX_Vpavgb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpavgb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpavgb_zmm_k1z_zmm_zmmm512,
	Psraw_mm_mmm64,
	Psraw_xmm_xmmm128,
	VEX_Vpsraw_xmm_xmm_xmmm128,
	VEX_Vpsraw_ymm_ymm_xmmm128,
	EVEX_Vpsraw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsraw_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsraw_zmm_k1z_zmm_xmmm128,
	Psrad_mm_mmm64,
	Psrad_xmm_xmmm128,
	VEX_Vpsrad_xmm_xmm_xmmm128,
	VEX_Vpsrad_ymm_ymm_xmmm128,
	EVEX_Vpsrad_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsrad_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsrad_zmm_k1z_zmm_xmmm128,
	EVEX_Vpsraq_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsraq_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsraq_zmm_k1z_zmm_xmmm128,
	Pavgw_mm_mmm64,
	Pavgw_xmm_xmmm128,
	VEX_Vpavgw_xmm_xmm_xmmm128,
	VEX_Vpavgw_ymm_ymm_ymmm256,
	EVEX_Vpavgw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpavgw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpavgw_zmm_k1z_zmm_zmmm512,
	Pmulhuw_mm_mmm64,
	Pmulhuw_xmm_xmmm128,
	VEX_Vpmulhuw_xmm_xmm_xmmm128,
	VEX_Vpmulhuw_ymm_ymm_ymmm256,
	EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512,
	Pmulhw_mm_mmm64,
	Pmulhw_xmm_xmmm128,
	VEX_Vpmulhw_xmm_xmm_xmmm128,
	VEX_Vpmulhw_ymm_ymm_ymmm256,
	EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512,
	Cvttpd2dq_xmm_xmmm128,
	VEX_Vcvttpd2dq_xmm_xmmm128,
	VEX_Vcvttpd2dq_xmm_ymmm256,
	EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64,
	EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64,
	EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae,
	Cvtdq2pd_xmm_xmmm64,
	VEX_Vcvtdq2pd_xmm_xmmm64,
	VEX_Vcvtdq2pd_ymm_xmmm128,
	EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32,
	EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32,
	EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er,
	EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64,
	EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64,
	EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er,
	Cvtpd2dq_xmm_xmmm128,
	VEX_Vcvtpd2dq_xmm_xmmm128,
	VEX_Vcvtpd2dq_xmm_ymmm256,
	EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64,
	EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64,
	EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er,
	Movntq_m64_mm,
	Movntdq_m128_xmm,
	VEX_Vmovntdq_m128_xmm,
	VEX_Vmovntdq_m256_ymm,
	EVEX_Vmovntdq_m128_xmm,
	EVEX_Vmovntdq_m256_ymm,
	EVEX_Vmovntdq_m512_zmm,
	Psubsb_mm_mmm64,
	Psubsb_xmm_xmmm128,
	VEX_Vpsubsb_xmm_xmm_xmmm128,
	VEX_Vpsubsb_ymm_ymm_ymmm256,
	EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512,
	Psubsw_mm_mmm64,
	Psubsw_xmm_xmmm128,
	VEX_Vpsubsw_xmm_xmm_xmmm128,
	VEX_Vpsubsw_ymm_ymm_ymmm256,
	EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512,
	Pminsw_mm_mmm64,
	Pminsw_xmm_xmmm128,
	VEX_Vpminsw_xmm_xmm_xmmm128,
	VEX_Vpminsw_ymm_ymm_ymmm256,
	EVEX_Vpminsw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpminsw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpminsw_zmm_k1z_zmm_zmmm512,
	Por_mm_mmm64,
	Por_xmm_xmmm128,
	VEX_Vpor_xmm_xmm_xmmm128,
	VEX_Vpor_ymm_ymm_ymmm256,
	EVEX_Vpord_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpord_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpord_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vporq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vporq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vporq_zmm_k1z_zmm_zmmm512b64,
	Paddsb_mm_mmm64,
	Paddsb_xmm_xmmm128,
	VEX_Vpaddsb_xmm_xmm_xmmm128,
	VEX_Vpaddsb_ymm_ymm_ymmm256,
	EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512,
	Paddsw_mm_mmm64,
	Paddsw_xmm_xmmm128,
	VEX_Vpaddsw_xmm_xmm_xmmm128,
	VEX_Vpaddsw_ymm_ymm_ymmm256,
	EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512,
	Pmaxsw_mm_mmm64,
	Pmaxsw_xmm_xmmm128,
	VEX_Vpmaxsw_xmm_xmm_xmmm128,
	VEX_Vpmaxsw_ymm_ymm_ymmm256,
	EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512,
	Pxor_mm_mmm64,
	Pxor_xmm_xmmm128,
	VEX_Vpxor_xmm_xmm_xmmm128,
	VEX_Vpxor_ymm_ymm_ymmm256,
	EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64,
	Lddqu_xmm_m128,
	VEX_Vlddqu_xmm_m128,
	VEX_Vlddqu_ymm_m256,
	Psllw_mm_mmm64,
	Psllw_xmm_xmmm128,
	VEX_Vpsllw_xmm_xmm_xmmm128,
	VEX_Vpsllw_ymm_ymm_xmmm128,
	EVEX_Vpsllw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsllw_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsllw_zmm_k1z_zmm_xmmm128,
	Pslld_mm_mmm64,
	Pslld_xmm_xmmm128,
	VEX_Vpslld_xmm_xmm_xmmm128,
	VEX_Vpslld_ymm_ymm_xmmm128,
	EVEX_Vpslld_xmm_k1z_xmm_xmmm128,
	EVEX_Vpslld_ymm_k1z_ymm_xmmm128,
	EVEX_Vpslld_zmm_k1z_zmm_xmmm128,
	Psllq_mm_mmm64,
	Psllq_xmm_xmmm128,
	VEX_Vpsllq_xmm_xmm_xmmm128,
	VEX_Vpsllq_ymm_ymm_xmmm128,
	EVEX_Vpsllq_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsllq_ymm_k1z_ymm_xmmm128,
	EVEX_Vpsllq_zmm_k1z_zmm_xmmm128,
	Pmuludq_mm_mmm64,
	Pmuludq_xmm_xmmm128,
	VEX_Vpmuludq_xmm_xmm_xmmm128,
	VEX_Vpmuludq_ymm_ymm_ymmm256,
	EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64,
	Pmaddwd_mm_mmm64,
	Pmaddwd_xmm_xmmm128,
	VEX_Vpmaddwd_xmm_xmm_xmmm128,
	VEX_Vpmaddwd_ymm_ymm_ymmm256,
	EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512,
	Psadbw_mm_mmm64,
	Psadbw_xmm_xmmm128,
	VEX_Vpsadbw_xmm_xmm_xmmm128,
	VEX_Vpsadbw_ymm_ymm_ymmm256,
	EVEX_Vpsadbw_xmm_xmm_xmmm128,
	EVEX_Vpsadbw_ymm_ymm_ymmm256,
	EVEX_Vpsadbw_zmm_zmm_zmmm512,
	Maskmovq_rDI_mm_mm,
	Maskmovdqu_rDI_xmm_xmm,
	VEX_Vmaskmovdqu_rDI_xmm_xmm,
	Psubb_mm_mmm64,
	Psubb_xmm_xmmm128,
	VEX_Vpsubb_xmm_xmm_xmmm128,
	VEX_Vpsubb_ymm_ymm_ymmm256,
	EVEX_Vpsubb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsubb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsubb_zmm_k1z_zmm_zmmm512,
	Psubw_mm_mmm64,
	Psubw_xmm_xmmm128,
	VEX_Vpsubw_xmm_xmm_xmmm128,
	VEX_Vpsubw_ymm_ymm_ymmm256,
	EVEX_Vpsubw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsubw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsubw_zmm_k1z_zmm_zmmm512,
	Psubd_mm_mmm64,
	Psubd_xmm_xmmm128,
	VEX_Vpsubd_xmm_xmm_xmmm128,
	VEX_Vpsubd_ymm_ymm_ymmm256,
	EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32,
	Psubq_mm_mmm64,
	Psubq_xmm_xmmm128,
	VEX_Vpsubq_xmm_xmm_xmmm128,
	VEX_Vpsubq_ymm_ymm_ymmm256,
	EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64,
	Paddb_mm_mmm64,
	Paddb_xmm_xmmm128,
	VEX_Vpaddb_xmm_xmm_xmmm128,
	VEX_Vpaddb_ymm_ymm_ymmm256,
	EVEX_Vpaddb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpaddb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpaddb_zmm_k1z_zmm_zmmm512,
	Paddw_mm_mmm64,
	Paddw_xmm_xmmm128,
	VEX_Vpaddw_xmm_xmm_xmmm128,
	VEX_Vpaddw_ymm_ymm_ymmm256,
	EVEX_Vpaddw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpaddw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpaddw_zmm_k1z_zmm_zmmm512,
	Paddd_mm_mmm64,
	Paddd_xmm_xmmm128,
	VEX_Vpaddd_xmm_xmm_xmmm128,
	VEX_Vpaddd_ymm_ymm_ymmm256,
	EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32,
	Ud0_r16_rm16,
	Ud0_r32_rm32,
	Ud0_r64_rm64,
	Pshufb_mm_mmm64,
	Pshufb_xmm_xmmm128,
	VEX_Vpshufb_xmm_xmm_xmmm128,
	VEX_Vpshufb_ymm_ymm_ymmm256,
	EVEX_Vpshufb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpshufb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpshufb_zmm_k1z_zmm_zmmm512,
	Phaddw_mm_mmm64,
	Phaddw_xmm_xmmm128,
	VEX_Vphaddw_xmm_xmm_xmmm128,
	VEX_Vphaddw_ymm_ymm_ymmm256,
	Phaddd_mm_mmm64,
	Phaddd_xmm_xmmm128,
	VEX_Vphaddd_xmm_xmm_xmmm128,
	VEX_Vphaddd_ymm_ymm_ymmm256,
	Phaddsw_mm_mmm64,
	Phaddsw_xmm_xmmm128,
	VEX_Vphaddsw_xmm_xmm_xmmm128,
	VEX_Vphaddsw_ymm_ymm_ymmm256,
	Pmaddubsw_mm_mmm64,
	Pmaddubsw_xmm_xmmm128,
	VEX_Vpmaddubsw_xmm_xmm_xmmm128,
	VEX_Vpmaddubsw_ymm_ymm_ymmm256,
	EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512,
	Phsubw_mm_mmm64,
	Phsubw_xmm_xmmm128,
	VEX_Vphsubw_xmm_xmm_xmmm128,
	VEX_Vphsubw_ymm_ymm_ymmm256,
	Phsubd_mm_mmm64,
	Phsubd_xmm_xmmm128,
	VEX_Vphsubd_xmm_xmm_xmmm128,
	VEX_Vphsubd_ymm_ymm_ymmm256,
	Phsubsw_mm_mmm64,
	Phsubsw_xmm_xmmm128,
	VEX_Vphsubsw_xmm_xmm_xmmm128,
	VEX_Vphsubsw_ymm_ymm_ymmm256,
	Psignb_mm_mmm64,
	Psignb_xmm_xmmm128,
	VEX_Vpsignb_xmm_xmm_xmmm128,
	VEX_Vpsignb_ymm_ymm_ymmm256,
	Psignw_mm_mmm64,
	Psignw_xmm_xmmm128,
	VEX_Vpsignw_xmm_xmm_xmmm128,
	VEX_Vpsignw_ymm_ymm_ymmm256,
	Psignd_mm_mmm64,
	Psignd_xmm_xmmm128,
	VEX_Vpsignd_xmm_xmm_xmmm128,
	VEX_Vpsignd_ymm_ymm_ymmm256,
	Pmulhrsw_mm_mmm64,
	Pmulhrsw_xmm_xmmm128,
	VEX_Vpmulhrsw_xmm_xmm_xmmm128,
	VEX_Vpmulhrsw_ymm_ymm_ymmm256,
	EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512,
	VEX_Vpermilps_xmm_xmm_xmmm128,
	VEX_Vpermilps_ymm_ymm_ymmm256,
	EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32,
	VEX_Vpermilpd_xmm_xmm_xmmm128,
	VEX_Vpermilpd_ymm_ymm_ymmm256,
	EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64,
	VEX_Vtestps_xmm_xmmm128,
	VEX_Vtestps_ymm_ymmm256,
	VEX_Vtestpd_xmm_xmmm128,
	VEX_Vtestpd_ymm_ymmm256,
	Pblendvb_xmm_xmmm128,
	EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512,
	EVEX_Vpmovuswb_xmmm64_k1z_xmm,
	EVEX_Vpmovuswb_xmmm128_k1z_ymm,
	EVEX_Vpmovuswb_ymmm256_k1z_zmm,
	EVEX_Vpsravw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsravw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsravw_zmm_k1z_zmm_zmmm512,
	EVEX_Vpmovusdb_xmmm32_k1z_xmm,
	EVEX_Vpmovusdb_xmmm64_k1z_ymm,
	EVEX_Vpmovusdb_xmmm128_k1z_zmm,
	EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512,
	EVEX_Vpmovusqb_xmmm16_k1z_xmm,
	EVEX_Vpmovusqb_xmmm32_k1z_ymm,
	EVEX_Vpmovusqb_xmmm64_k1z_zmm,
	VEX_Vcvtph2ps_xmm_xmmm64,
	VEX_Vcvtph2ps_ymm_xmmm128,
	EVEX_Vcvtph2ps_xmm_k1z_xmmm64,
	EVEX_Vcvtph2ps_ymm_k1z_xmmm128,
	EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae,
	EVEX_Vpmovusdw_xmmm64_k1z_xmm,
	EVEX_Vpmovusdw_xmmm128_k1z_ymm,
	EVEX_Vpmovusdw_ymmm256_k1z_zmm,
	Blendvps_xmm_xmmm128,
	EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpmovusqw_xmmm32_k1z_xmm,
	EVEX_Vpmovusqw_xmmm64_k1z_ymm,
	EVEX_Vpmovusqw_xmmm128_k1z_zmm,
	Blendvpd_xmm_xmmm128,
	EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpmovusqd_xmmm64_k1z_xmm,
	EVEX_Vpmovusqd_xmmm128_k1z_ymm,
	EVEX_Vpmovusqd_ymmm256_k1z_zmm,
	VEX_Vpermps_ymm_ymm_ymmm256,
	EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64,
	Ptest_xmm_xmmm128,
	VEX_Vptest_xmm_xmmm128,
	VEX_Vptest_ymm_ymmm256,
	VEX_Vbroadcastss_xmm_m32,
	VEX_Vbroadcastss_ymm_m32,
	EVEX_Vbroadcastss_xmm_k1z_xmmm32,
	EVEX_Vbroadcastss_ymm_k1z_xmmm32,
	EVEX_Vbroadcastss_zmm_k1z_xmmm32,
	VEX_Vbroadcastsd_ymm_m64,
	EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64,
	EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64,
	EVEX_Vbroadcastsd_ymm_k1z_xmmm64,
	EVEX_Vbroadcastsd_zmm_k1z_xmmm64,
	VEX_Vbroadcastf128_ymm_m128,
	EVEX_Vbroadcastf32x4_ymm_k1z_m128,
	EVEX_Vbroadcastf32x4_zmm_k1z_m128,
	EVEX_Vbroadcastf64x2_ymm_k1z_m128,
	EVEX_Vbroadcastf64x2_zmm_k1z_m128,
	EVEX_Vbroadcastf32x8_zmm_k1z_m256,
	EVEX_Vbroadcastf64x4_zmm_k1z_m256,
	Pabsb_mm_mmm64,
	Pabsb_xmm_xmmm128,
	VEX_Vpabsb_xmm_xmmm128,
	VEX_Vpabsb_ymm_ymmm256,
	EVEX_Vpabsb_xmm_k1z_xmmm128,
	EVEX_Vpabsb_ymm_k1z_ymmm256,
	EVEX_Vpabsb_zmm_k1z_zmmm512,
	Pabsw_mm_mmm64,
	Pabsw_xmm_xmmm128,
	VEX_Vpabsw_xmm_xmmm128,
	VEX_Vpabsw_ymm_ymmm256,
	EVEX_Vpabsw_xmm_k1z_xmmm128,
	EVEX_Vpabsw_ymm_k1z_ymmm256,
	EVEX_Vpabsw_zmm_k1z_zmmm512,
	Pabsd_mm_mmm64,
	Pabsd_xmm_xmmm128,
	VEX_Vpabsd_xmm_xmmm128,
	VEX_Vpabsd_ymm_ymmm256,
	EVEX_Vpabsd_xmm_k1z_xmmm128b32,
	EVEX_Vpabsd_ymm_k1z_ymmm256b32,
	EVEX_Vpabsd_zmm_k1z_zmmm512b32,
	EVEX_Vpabsq_xmm_k1z_xmmm128b64,
	EVEX_Vpabsq_ymm_k1z_ymmm256b64,
	EVEX_Vpabsq_zmm_k1z_zmmm512b64,
	Pmovsxbw_xmm_xmmm64,
	VEX_Vpmovsxbw_xmm_xmmm64,
	VEX_Vpmovsxbw_ymm_xmmm128,
	EVEX_Vpmovsxbw_xmm_k1z_xmmm64,
	EVEX_Vpmovsxbw_ymm_k1z_xmmm128,
	EVEX_Vpmovsxbw_zmm_k1z_ymmm256,
	EVEX_Vpmovswb_xmmm64_k1z_xmm,
	EVEX_Vpmovswb_xmmm128_k1z_ymm,
	EVEX_Vpmovswb_ymmm256_k1z_zmm,
	Pmovsxbd_xmm_xmmm32,
	VEX_Vpmovsxbd_xmm_xmmm32,
	VEX_Vpmovsxbd_ymm_xmmm64,
	EVEX_Vpmovsxbd_xmm_k1z_xmmm32,
	EVEX_Vpmovsxbd_ymm_k1z_xmmm64,
	EVEX_Vpmovsxbd_zmm_k1z_xmmm128,
	EVEX_Vpmovsdb_xmmm32_k1z_xmm,
	EVEX_Vpmovsdb_xmmm64_k1z_ymm,
	EVEX_Vpmovsdb_xmmm128_k1z_zmm,
	Pmovsxbq_xmm_xmmm16,
	VEX_Vpmovsxbq_xmm_xmmm16,
	VEX_Vpmovsxbq_ymm_xmmm32,
	EVEX_Vpmovsxbq_xmm_k1z_xmmm16,
	EVEX_Vpmovsxbq_ymm_k1z_xmmm32,
	EVEX_Vpmovsxbq_zmm_k1z_xmmm64,
	EVEX_Vpmovsqb_xmmm16_k1z_xmm,
	EVEX_Vpmovsqb_xmmm32_k1z_ymm,
	EVEX_Vpmovsqb_xmmm64_k1z_zmm,
	Pmovsxwd_xmm_xmmm64,
	VEX_Vpmovsxwd_xmm_xmmm64,
	VEX_Vpmovsxwd_ymm_xmmm128,
	EVEX_Vpmovsxwd_xmm_k1z_xmmm64,
	EVEX_Vpmovsxwd_ymm_k1z_xmmm128,
	EVEX_Vpmovsxwd_zmm_k1z_ymmm256,
	EVEX_Vpmovsdw_xmmm64_k1z_xmm,
	EVEX_Vpmovsdw_xmmm128_k1z_ymm,
	EVEX_Vpmovsdw_ymmm256_k1z_zmm,
	Pmovsxwq_xmm_xmmm32,
	VEX_Vpmovsxwq_xmm_xmmm32,
	VEX_Vpmovsxwq_ymm_xmmm64,
	EVEX_Vpmovsxwq_xmm_k1z_xmmm32,
	EVEX_Vpmovsxwq_ymm_k1z_xmmm64,
	EVEX_Vpmovsxwq_zmm_k1z_xmmm128,
	EVEX_Vpmovsqw_xmmm32_k1z_xmm,
	EVEX_Vpmovsqw_xmmm64_k1z_ymm,
	EVEX_Vpmovsqw_xmmm128_k1z_zmm,
	Pmovsxdq_xmm_xmmm64,
	VEX_Vpmovsxdq_xmm_xmmm64,
	VEX_Vpmovsxdq_ymm_xmmm128,
	EVEX_Vpmovsxdq_xmm_k1z_xmmm64,
	EVEX_Vpmovsxdq_ymm_k1z_xmmm128,
	EVEX_Vpmovsxdq_zmm_k1z_ymmm256,
	EVEX_Vpmovsqd_xmmm64_k1z_xmm,
	EVEX_Vpmovsqd_xmmm128_k1z_ymm,
	EVEX_Vpmovsqd_ymmm256_k1z_zmm,
	EVEX_Vptestmb_kr_k1_xmm_xmmm128,
	EVEX_Vptestmb_kr_k1_ymm_ymmm256,
	EVEX_Vptestmb_kr_k1_zmm_zmmm512,
	EVEX_Vptestmw_kr_k1_xmm_xmmm128,
	EVEX_Vptestmw_kr_k1_ymm_ymmm256,
	EVEX_Vptestmw_kr_k1_zmm_zmmm512,
	EVEX_Vptestnmb_kr_k1_xmm_xmmm128,
	EVEX_Vptestnmb_kr_k1_ymm_ymmm256,
	EVEX_Vptestnmb_kr_k1_zmm_zmmm512,
	EVEX_Vptestnmw_kr_k1_xmm_xmmm128,
	EVEX_Vptestnmw_kr_k1_ymm_ymmm256,
	EVEX_Vptestnmw_kr_k1_zmm_zmmm512,
	EVEX_Vptestmd_kr_k1_xmm_xmmm128b32,
	EVEX_Vptestmd_kr_k1_ymm_ymmm256b32,
	EVEX_Vptestmd_kr_k1_zmm_zmmm512b32,
	EVEX_Vptestmq_kr_k1_xmm_xmmm128b64,
	EVEX_Vptestmq_kr_k1_ymm_ymmm256b64,
	EVEX_Vptestmq_kr_k1_zmm_zmmm512b64,
	EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32,
	EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32,
	EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32,
	EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64,
	EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64,
	EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64,
	Pmuldq_xmm_xmmm128,
	VEX_Vpmuldq_xmm_xmm_xmmm128,
	VEX_Vpmuldq_ymm_ymm_ymmm256,
	EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpmovm2b_xmm_kr,
	EVEX_Vpmovm2b_ymm_kr,
	EVEX_Vpmovm2b_zmm_kr,
	EVEX_Vpmovm2w_xmm_kr,
	EVEX_Vpmovm2w_ymm_kr,
	EVEX_Vpmovm2w_zmm_kr,
	Pcmpeqq_xmm_xmmm128,
	VEX_Vpcmpeqq_xmm_xmm_xmmm128,
	VEX_Vpcmpeqq_ymm_ymm_ymmm256,
	EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64,
	EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64,
	EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64,
	EVEX_Vpmovb2m_kr_xmm,
	EVEX_Vpmovb2m_kr_ymm,
	EVEX_Vpmovb2m_kr_zmm,
	EVEX_Vpmovw2m_kr_xmm,
	EVEX_Vpmovw2m_kr_ymm,
	EVEX_Vpmovw2m_kr_zmm,
	Movntdqa_xmm_m128,
	VEX_Vmovntdqa_xmm_m128,
	VEX_Vmovntdqa_ymm_m256,
	EVEX_Vmovntdqa_xmm_m128,
	EVEX_Vmovntdqa_ymm_m256,
	EVEX_Vmovntdqa_zmm_m512,
	EVEX_Vpbroadcastmb2q_xmm_kr,
	EVEX_Vpbroadcastmb2q_ymm_kr,
	EVEX_Vpbroadcastmb2q_zmm_kr,
	Packusdw_xmm_xmmm128,
	VEX_Vpackusdw_xmm_xmm_xmmm128,
	VEX_Vpackusdw_ymm_ymm_ymmm256,
	EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32,
	VEX_Vmaskmovps_xmm_xmm_m128,
	VEX_Vmaskmovps_ymm_ymm_m256,
	EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vmaskmovpd_xmm_xmm_m128,
	VEX_Vmaskmovpd_ymm_ymm_m256,
	EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vmaskmovps_m128_xmm_xmm,
	VEX_Vmaskmovps_m256_ymm_ymm,
	VEX_Vmaskmovpd_m128_xmm_xmm,
	VEX_Vmaskmovpd_m256_ymm_ymm,
	Pmovzxbw_xmm_xmmm64,
	VEX_Vpmovzxbw_xmm_xmmm64,
	VEX_Vpmovzxbw_ymm_xmmm128,
	EVEX_Vpmovzxbw_xmm_k1z_xmmm64,
	EVEX_Vpmovzxbw_ymm_k1z_xmmm128,
	EVEX_Vpmovzxbw_zmm_k1z_ymmm256,
	EVEX_Vpmovwb_xmmm64_k1z_xmm,
	EVEX_Vpmovwb_xmmm128_k1z_ymm,
	EVEX_Vpmovwb_ymmm256_k1z_zmm,
	Pmovzxbd_xmm_xmmm32,
	VEX_Vpmovzxbd_xmm_xmmm32,
	VEX_Vpmovzxbd_ymm_xmmm64,
	EVEX_Vpmovzxbd_xmm_k1z_xmmm32,
	EVEX_Vpmovzxbd_ymm_k1z_xmmm64,
	EVEX_Vpmovzxbd_zmm_k1z_xmmm128,
	EVEX_Vpmovdb_xmmm32_k1z_xmm,
	EVEX_Vpmovdb_xmmm64_k1z_ymm,
	EVEX_Vpmovdb_xmmm128_k1z_zmm,
	Pmovzxbq_xmm_xmmm16,
	VEX_Vpmovzxbq_xmm_xmmm16,
	VEX_Vpmovzxbq_ymm_xmmm32,
	EVEX_Vpmovzxbq_xmm_k1z_xmmm16,
	EVEX_Vpmovzxbq_ymm_k1z_xmmm32,
	EVEX_Vpmovzxbq_zmm_k1z_xmmm64,
	EVEX_Vpmovqb_xmmm16_k1z_xmm,
	EVEX_Vpmovqb_xmmm32_k1z_ymm,
	EVEX_Vpmovqb_xmmm64_k1z_zmm,
	Pmovzxwd_xmm_xmmm64,
	VEX_Vpmovzxwd_xmm_xmmm64,
	VEX_Vpmovzxwd_ymm_xmmm128,
	EVEX_Vpmovzxwd_xmm_k1z_xmmm64,
	EVEX_Vpmovzxwd_ymm_k1z_xmmm128,
	EVEX_Vpmovzxwd_zmm_k1z_ymmm256,
	EVEX_Vpmovdw_xmmm64_k1z_xmm,
	EVEX_Vpmovdw_xmmm128_k1z_ymm,
	EVEX_Vpmovdw_ymmm256_k1z_zmm,
	Pmovzxwq_xmm_xmmm32,
	VEX_Vpmovzxwq_xmm_xmmm32,
	VEX_Vpmovzxwq_ymm_xmmm64,
	EVEX_Vpmovzxwq_xmm_k1z_xmmm32,
	EVEX_Vpmovzxwq_ymm_k1z_xmmm64,
	EVEX_Vpmovzxwq_zmm_k1z_xmmm128,
	EVEX_Vpmovqw_xmmm32_k1z_xmm,
	EVEX_Vpmovqw_xmmm64_k1z_ymm,
	EVEX_Vpmovqw_xmmm128_k1z_zmm,
	Pmovzxdq_xmm_xmmm64,
	VEX_Vpmovzxdq_xmm_xmmm64,
	VEX_Vpmovzxdq_ymm_xmmm128,
	EVEX_Vpmovzxdq_xmm_k1z_xmmm64,
	EVEX_Vpmovzxdq_ymm_k1z_xmmm128,
	EVEX_Vpmovzxdq_zmm_k1z_ymmm256,
	EVEX_Vpmovqd_xmmm64_k1z_xmm,
	EVEX_Vpmovqd_xmmm128_k1z_ymm,
	EVEX_Vpmovqd_ymmm256_k1z_zmm,
	VEX_Vpermd_ymm_ymm_ymmm256,
	EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64,
	Pcmpgtq_xmm_xmmm128,
	VEX_Vpcmpgtq_xmm_xmm_xmmm128,
	VEX_Vpcmpgtq_ymm_ymm_ymmm256,
	EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64,
	EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64,
	EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64,
	Pminsb_xmm_xmmm128,
	VEX_Vpminsb_xmm_xmm_xmmm128,
	VEX_Vpminsb_ymm_ymm_ymmm256,
	EVEX_Vpminsb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpminsb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpminsb_zmm_k1z_zmm_zmmm512,
	EVEX_Vpmovm2d_xmm_kr,
	EVEX_Vpmovm2d_ymm_kr,
	EVEX_Vpmovm2d_zmm_kr,
	EVEX_Vpmovm2q_xmm_kr,
	EVEX_Vpmovm2q_ymm_kr,
	EVEX_Vpmovm2q_zmm_kr,
	Pminsd_xmm_xmmm128,
	VEX_Vpminsd_xmm_xmm_xmmm128,
	VEX_Vpminsd_ymm_ymm_ymmm256,
	EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpmovd2m_kr_xmm,
	EVEX_Vpmovd2m_kr_ymm,
	EVEX_Vpmovd2m_kr_zmm,
	EVEX_Vpmovq2m_kr_xmm,
	EVEX_Vpmovq2m_kr_ymm,
	EVEX_Vpmovq2m_kr_zmm,
	Pminuw_xmm_xmmm128,
	VEX_Vpminuw_xmm_xmm_xmmm128,
	VEX_Vpminuw_ymm_ymm_ymmm256,
	EVEX_Vpminuw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpminuw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpminuw_zmm_k1z_zmm_zmmm512,
	EVEX_Vpbroadcastmw2d_xmm_kr,
	EVEX_Vpbroadcastmw2d_ymm_kr,
	EVEX_Vpbroadcastmw2d_zmm_kr,
	Pminud_xmm_xmmm128,
	VEX_Vpminud_xmm_xmm_xmmm128,
	VEX_Vpminud_ymm_ymm_ymmm256,
	EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64,
	Pmaxsb_xmm_xmmm128,
	VEX_Vpmaxsb_xmm_xmm_xmmm128,
	VEX_Vpmaxsb_ymm_ymm_ymmm256,
	EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512,
	Pmaxsd_xmm_xmmm128,
	VEX_Vpmaxsd_xmm_xmm_xmmm128,
	VEX_Vpmaxsd_ymm_ymm_ymmm256,
	EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64,
	Pmaxuw_xmm_xmmm128,
	VEX_Vpmaxuw_xmm_xmm_xmmm128,
	VEX_Vpmaxuw_ymm_ymm_ymmm256,
	EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512,
	Pmaxud_xmm_xmmm128,
	VEX_Vpmaxud_xmm_xmm_xmmm128,
	VEX_Vpmaxud_ymm_ymm_ymmm256,
	EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64,
	Pmulld_xmm_xmmm128,
	VEX_Vpmulld_xmm_xmm_xmmm128,
	VEX_Vpmulld_ymm_ymm_ymmm256,
	EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64,
	Phminposuw_xmm_xmmm128,
	VEX_Vphminposuw_xmm_xmmm128,
	EVEX_Vgetexpps_xmm_k1z_xmmm128b32,
	EVEX_Vgetexpps_ymm_k1z_ymmm256b32,
	EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae,
	EVEX_Vgetexppd_xmm_k1z_xmmm128b64,
	EVEX_Vgetexppd_ymm_k1z_ymmm256b64,
	EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae,
	EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae,
	EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae,
	EVEX_Vplzcntd_xmm_k1z_xmmm128b32,
	EVEX_Vplzcntd_ymm_k1z_ymmm256b32,
	EVEX_Vplzcntd_zmm_k1z_zmmm512b32,
	EVEX_Vplzcntq_xmm_k1z_xmmm128b64,
	EVEX_Vplzcntq_ymm_k1z_ymmm256b64,
	EVEX_Vplzcntq_zmm_k1z_zmmm512b64,
	VEX_Vpsrlvd_xmm_xmm_xmmm128,
	VEX_Vpsrlvd_ymm_ymm_ymmm256,
	VEX_Vpsrlvq_xmm_xmm_xmmm128,
	VEX_Vpsrlvq_ymm_ymm_ymmm256,
	EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64,
	VEX_Vpsravd_xmm_xmm_xmmm128,
	VEX_Vpsravd_ymm_ymm_ymmm256,
	EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64,
	VEX_Vpsllvd_xmm_xmm_xmmm128,
	VEX_Vpsllvd_ymm_ymm_ymmm256,
	VEX_Vpsllvq_xmm_xmm_xmmm128,
	VEX_Vpsllvq_ymm_ymm_ymmm256,
	EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vrcp14ps_xmm_k1z_xmmm128b32,
	EVEX_Vrcp14ps_ymm_k1z_ymmm256b32,
	EVEX_Vrcp14ps_zmm_k1z_zmmm512b32,
	EVEX_Vrcp14pd_xmm_k1z_xmmm128b64,
	EVEX_Vrcp14pd_ymm_k1z_ymmm256b64,
	EVEX_Vrcp14pd_zmm_k1z_zmmm512b64,
	EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32,
	EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64,
	EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32,
	EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32,
	EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32,
	EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64,
	EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64,
	EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64,
	EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32,
	EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64,
	EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vp4dpwssd_zmm_k1z_zmmp3_m128,
	EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vp4dpwssds_zmm_k1z_zmmp3_m128,
	EVEX_Vpopcntb_xmm_k1z_xmmm128,
	EVEX_Vpopcntb_ymm_k1z_ymmm256,
	EVEX_Vpopcntb_zmm_k1z_zmmm512,
	EVEX_Vpopcntw_xmm_k1z_xmmm128,
	EVEX_Vpopcntw_ymm_k1z_ymmm256,
	EVEX_Vpopcntw_zmm_k1z_zmmm512,
	EVEX_Vpopcntd_xmm_k1z_xmmm128b32,
	EVEX_Vpopcntd_ymm_k1z_ymmm256b32,
	EVEX_Vpopcntd_zmm_k1z_zmmm512b32,
	EVEX_Vpopcntq_xmm_k1z_xmmm128b64,
	EVEX_Vpopcntq_ymm_k1z_ymmm256b64,
	EVEX_Vpopcntq_zmm_k1z_zmmm512b64,
	VEX_Vpbroadcastd_xmm_xmmm32,
	VEX_Vpbroadcastd_ymm_xmmm32,
	EVEX_Vpbroadcastd_xmm_k1z_xmmm32,
	EVEX_Vpbroadcastd_ymm_k1z_xmmm32,
	EVEX_Vpbroadcastd_zmm_k1z_xmmm32,
	VEX_Vpbroadcastq_xmm_xmmm64,
	VEX_Vpbroadcastq_ymm_xmmm64,
	EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64,
	EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64,
	EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64,
	EVEX_Vpbroadcastq_xmm_k1z_xmmm64,
	EVEX_Vpbroadcastq_ymm_k1z_xmmm64,
	EVEX_Vpbroadcastq_zmm_k1z_xmmm64,
	VEX_Vbroadcasti128_ymm_m128,
	EVEX_Vbroadcasti32x4_ymm_k1z_m128,
	EVEX_Vbroadcasti32x4_zmm_k1z_m128,
	EVEX_Vbroadcasti64x2_ymm_k1z_m128,
	EVEX_Vbroadcasti64x2_zmm_k1z_m128,
	EVEX_Vbroadcasti32x8_zmm_k1z_m256,
	EVEX_Vbroadcasti64x4_zmm_k1z_m256,
	EVEX_Vpexpandb_xmm_k1z_xmmm128,
	EVEX_Vpexpandb_ymm_k1z_ymmm256,
	EVEX_Vpexpandb_zmm_k1z_zmmm512,
	EVEX_Vpexpandw_xmm_k1z_xmmm128,
	EVEX_Vpexpandw_ymm_k1z_ymmm256,
	EVEX_Vpexpandw_zmm_k1z_zmmm512,
	EVEX_Vpcompressb_xmmm128_k1z_xmm,
	EVEX_Vpcompressb_ymmm256_k1z_ymm,
	EVEX_Vpcompressb_zmmm512_k1z_zmm,
	EVEX_Vpcompressw_xmmm128_k1z_xmm,
	EVEX_Vpcompressw_ymmm256_k1z_ymm,
	EVEX_Vpcompressw_zmmm512_k1z_zmm,
	EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512,
	EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512,
	EVEX_Vp2intersectd_kp1_xmm_xmmm128b32,
	EVEX_Vp2intersectd_kp1_ymm_ymmm256b32,
	EVEX_Vp2intersectd_kp1_zmm_zmmm512b32,
	EVEX_Vp2intersectq_kp1_xmm_xmmm128b64,
	EVEX_Vp2intersectq_kp1_ymm_ymmm256b64,
	EVEX_Vp2intersectq_kp1_zmm_zmmm512b64,
	EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512,
	EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512,
	EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32,
	EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32,
	EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32,
	EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128,
	EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256,
	EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512,
	EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128,
	EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256,
	EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512,
	EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64,
	VEX_Vpbroadcastb_xmm_xmmm8,
	VEX_Vpbroadcastb_ymm_xmmm8,
	EVEX_Vpbroadcastb_xmm_k1z_xmmm8,
	EVEX_Vpbroadcastb_ymm_k1z_xmmm8,
	EVEX_Vpbroadcastb_zmm_k1z_xmmm8,
	VEX_Vpbroadcastw_xmm_xmmm16,
	VEX_Vpbroadcastw_ymm_xmmm16,
	EVEX_Vpbroadcastw_xmm_k1z_xmmm16,
	EVEX_Vpbroadcastw_ymm_k1z_xmmm16,
	EVEX_Vpbroadcastw_zmm_k1z_xmmm16,
	EVEX_Vpbroadcastb_xmm_k1z_r32,
	EVEX_Vpbroadcastb_ymm_k1z_r32,
	EVEX_Vpbroadcastb_zmm_k1z_r32,
	EVEX_Vpbroadcastw_xmm_k1z_r32,
	EVEX_Vpbroadcastw_ymm_k1z_r32,
	EVEX_Vpbroadcastw_zmm_k1z_r32,
	EVEX_Vpbroadcastd_xmm_k1z_r32,
	EVEX_Vpbroadcastd_ymm_k1z_r32,
	EVEX_Vpbroadcastd_zmm_k1z_r32,
	EVEX_Vpbroadcastq_xmm_k1z_r64,
	EVEX_Vpbroadcastq_ymm_k1z_r64,
	EVEX_Vpbroadcastq_zmm_k1z_r64,
	EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128,
	EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256,
	EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512,
	EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128,
	EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256,
	EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512,
	EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32,
	EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64,
	Invept_r32_m128,
	Invept_r64_m128,
	Invvpid_r32_m128,
	Invvpid_r64_m128,
	Invpcid_r32_m128,
	Invpcid_r64_m128,
	EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vexpandps_xmm_k1z_xmmm128,
	EVEX_Vexpandps_ymm_k1z_ymmm256,
	EVEX_Vexpandps_zmm_k1z_zmmm512,
	EVEX_Vexpandpd_xmm_k1z_xmmm128,
	EVEX_Vexpandpd_ymm_k1z_ymmm256,
	EVEX_Vexpandpd_zmm_k1z_zmmm512,
	EVEX_Vpexpandd_xmm_k1z_xmmm128,
	EVEX_Vpexpandd_ymm_k1z_ymmm256,
	EVEX_Vpexpandd_zmm_k1z_zmmm512,
	EVEX_Vpexpandq_xmm_k1z_xmmm128,
	EVEX_Vpexpandq_ymm_k1z_ymmm256,
	EVEX_Vpexpandq_zmm_k1z_zmmm512,
	EVEX_Vcompressps_xmmm128_k1z_xmm,
	EVEX_Vcompressps_ymmm256_k1z_ymm,
	EVEX_Vcompressps_zmmm512_k1z_zmm,
	EVEX_Vcompresspd_xmmm128_k1z_xmm,
	EVEX_Vcompresspd_ymmm256_k1z_ymm,
	EVEX_Vcompresspd_zmmm512_k1z_zmm,
	EVEX_Vpcompressd_xmmm128_k1z_xmm,
	EVEX_Vpcompressd_ymmm256_k1z_ymm,
	EVEX_Vpcompressd_zmmm512_k1z_zmm,
	EVEX_Vpcompressq_xmmm128_k1z_xmm,
	EVEX_Vpcompressq_ymmm256_k1z_ymm,
	EVEX_Vpcompressq_zmmm512_k1z_zmm,
	VEX_Vpmaskmovd_xmm_xmm_m128,
	VEX_Vpmaskmovd_ymm_ymm_m256,
	VEX_Vpmaskmovq_xmm_xmm_m128,
	VEX_Vpmaskmovq_ymm_ymm_m256,
	EVEX_Vpermb_xmm_k1z_xmm_xmmm128,
	EVEX_Vpermb_ymm_k1z_ymm_ymmm256,
	EVEX_Vpermb_zmm_k1z_zmm_zmmm512,
	EVEX_Vpermw_xmm_k1z_xmm_xmmm128,
	EVEX_Vpermw_ymm_k1z_ymm_ymmm256,
	EVEX_Vpermw_zmm_k1z_zmm_zmmm512,
	VEX_Vpmaskmovd_m128_xmm_xmm,
	VEX_Vpmaskmovd_m256_ymm_ymm,
	VEX_Vpmaskmovq_m128_xmm_xmm,
	VEX_Vpmaskmovq_m256_ymm_ymm,
	EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128,
	EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256,
	EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512,
	VEX_Vpgatherdd_xmm_vm32x_xmm,
	VEX_Vpgatherdd_ymm_vm32y_ymm,
	VEX_Vpgatherdq_xmm_vm32x_xmm,
	VEX_Vpgatherdq_ymm_vm32x_ymm,
	EVEX_Vpgatherdd_xmm_k1_vm32x,
	EVEX_Vpgatherdd_ymm_k1_vm32y,
	EVEX_Vpgatherdd_zmm_k1_vm32z,
	EVEX_Vpgatherdq_xmm_k1_vm32x,
	EVEX_Vpgatherdq_ymm_k1_vm32x,
	EVEX_Vpgatherdq_zmm_k1_vm32y,
	VEX_Vpgatherqd_xmm_vm64x_xmm,
	VEX_Vpgatherqd_xmm_vm64y_xmm,
	VEX_Vpgatherqq_xmm_vm64x_xmm,
	VEX_Vpgatherqq_ymm_vm64y_ymm,
	EVEX_Vpgatherqd_xmm_k1_vm64x,
	EVEX_Vpgatherqd_xmm_k1_vm64y,
	EVEX_Vpgatherqd_ymm_k1_vm64z,
	EVEX_Vpgatherqq_xmm_k1_vm64x,
	EVEX_Vpgatherqq_ymm_k1_vm64y,
	EVEX_Vpgatherqq_zmm_k1_vm64z,
	VEX_Vgatherdps_xmm_vm32x_xmm,
	VEX_Vgatherdps_ymm_vm32y_ymm,
	VEX_Vgatherdpd_xmm_vm32x_xmm,
	VEX_Vgatherdpd_ymm_vm32x_ymm,
	EVEX_Vgatherdps_xmm_k1_vm32x,
	EVEX_Vgatherdps_ymm_k1_vm32y,
	EVEX_Vgatherdps_zmm_k1_vm32z,
	EVEX_Vgatherdpd_xmm_k1_vm32x,
	EVEX_Vgatherdpd_ymm_k1_vm32x,
	EVEX_Vgatherdpd_zmm_k1_vm32y,
	VEX_Vgatherqps_xmm_vm64x_xmm,
	VEX_Vgatherqps_xmm_vm64y_xmm,
	VEX_Vgatherqpd_xmm_vm64x_xmm,
	VEX_Vgatherqpd_ymm_vm64y_ymm,
	EVEX_Vgatherqps_xmm_k1_vm64x,
	EVEX_Vgatherqps_xmm_k1_vm64y,
	EVEX_Vgatherqps_ymm_k1_vm64z,
	EVEX_Vgatherqpd_xmm_k1_vm64x,
	EVEX_Vgatherqpd_ymm_k1_vm64y,
	EVEX_Vgatherqpd_zmm_k1_vm64z,
	VEX_Vfmaddsub132ps_xmm_xmm_xmmm128,
	VEX_Vfmaddsub132ps_ymm_ymm_ymmm256,
	VEX_Vfmaddsub132pd_xmm_xmm_xmmm128,
	VEX_Vfmaddsub132pd_ymm_ymm_ymmm256,
	EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmsubadd132ps_xmm_xmm_xmmm128,
	VEX_Vfmsubadd132ps_ymm_ymm_ymmm256,
	VEX_Vfmsubadd132pd_xmm_xmm_xmmm128,
	VEX_Vfmsubadd132pd_ymm_ymm_ymmm256,
	EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmadd132ps_xmm_xmm_xmmm128,
	VEX_Vfmadd132ps_ymm_ymm_ymmm256,
	VEX_Vfmadd132pd_xmm_xmm_xmmm128,
	VEX_Vfmadd132pd_ymm_ymm_ymmm256,
	EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmadd132ss_xmm_xmm_xmmm32,
	VEX_Vfmadd132sd_xmm_xmm_xmmm64,
	EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfmsub132ps_xmm_xmm_xmmm128,
	VEX_Vfmsub132ps_ymm_ymm_ymmm256,
	VEX_Vfmsub132pd_xmm_xmm_xmmm128,
	VEX_Vfmsub132pd_ymm_ymm_ymmm256,
	EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er,
	EVEX_V4fmaddps_zmm_k1z_zmmp3_m128,
	VEX_Vfmsub132ss_xmm_xmm_xmmm32,
	VEX_Vfmsub132sd_xmm_xmm_xmmm64,
	EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er,
	EVEX_V4fmaddss_xmm_k1z_xmmp3_m128,
	VEX_Vfnmadd132ps_xmm_xmm_xmmm128,
	VEX_Vfnmadd132ps_ymm_ymm_ymmm256,
	VEX_Vfnmadd132pd_xmm_xmm_xmmm128,
	VEX_Vfnmadd132pd_ymm_ymm_ymmm256,
	EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfnmadd132ss_xmm_xmm_xmmm32,
	VEX_Vfnmadd132sd_xmm_xmm_xmmm64,
	EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfnmsub132ps_xmm_xmm_xmmm128,
	VEX_Vfnmsub132ps_ymm_ymm_ymmm256,
	VEX_Vfnmsub132pd_xmm_xmm_xmmm128,
	VEX_Vfnmsub132pd_ymm_ymm_ymmm256,
	EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfnmsub132ss_xmm_xmm_xmmm32,
	VEX_Vfnmsub132sd_xmm_xmm_xmmm64,
	EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er,
	EVEX_Vpscatterdd_vm32x_k1_xmm,
	EVEX_Vpscatterdd_vm32y_k1_ymm,
	EVEX_Vpscatterdd_vm32z_k1_zmm,
	EVEX_Vpscatterdq_vm32x_k1_xmm,
	EVEX_Vpscatterdq_vm32x_k1_ymm,
	EVEX_Vpscatterdq_vm32y_k1_zmm,
	EVEX_Vpscatterqd_vm64x_k1_xmm,
	EVEX_Vpscatterqd_vm64y_k1_xmm,
	EVEX_Vpscatterqd_vm64z_k1_ymm,
	EVEX_Vpscatterqq_vm64x_k1_xmm,
	EVEX_Vpscatterqq_vm64y_k1_ymm,
	EVEX_Vpscatterqq_vm64z_k1_zmm,
	EVEX_Vscatterdps_vm32x_k1_xmm,
	EVEX_Vscatterdps_vm32y_k1_ymm,
	EVEX_Vscatterdps_vm32z_k1_zmm,
	EVEX_Vscatterdpd_vm32x_k1_xmm,
	EVEX_Vscatterdpd_vm32x_k1_ymm,
	EVEX_Vscatterdpd_vm32y_k1_zmm,
	EVEX_Vscatterqps_vm64x_k1_xmm,
	EVEX_Vscatterqps_vm64y_k1_xmm,
	EVEX_Vscatterqps_vm64z_k1_ymm,
	EVEX_Vscatterqpd_vm64x_k1_xmm,
	EVEX_Vscatterqpd_vm64y_k1_ymm,
	EVEX_Vscatterqpd_vm64z_k1_zmm,
	VEX_Vfmaddsub213ps_xmm_xmm_xmmm128,
	VEX_Vfmaddsub213ps_ymm_ymm_ymmm256,
	VEX_Vfmaddsub213pd_xmm_xmm_xmmm128,
	VEX_Vfmaddsub213pd_ymm_ymm_ymmm256,
	EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmsubadd213ps_xmm_xmm_xmmm128,
	VEX_Vfmsubadd213ps_ymm_ymm_ymmm256,
	VEX_Vfmsubadd213pd_xmm_xmm_xmmm128,
	VEX_Vfmsubadd213pd_ymm_ymm_ymmm256,
	EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmadd213ps_xmm_xmm_xmmm128,
	VEX_Vfmadd213ps_ymm_ymm_ymmm256,
	VEX_Vfmadd213pd_xmm_xmm_xmmm128,
	VEX_Vfmadd213pd_ymm_ymm_ymmm256,
	EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmadd213ss_xmm_xmm_xmmm32,
	VEX_Vfmadd213sd_xmm_xmm_xmmm64,
	EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfmsub213ps_xmm_xmm_xmmm128,
	VEX_Vfmsub213ps_ymm_ymm_ymmm256,
	VEX_Vfmsub213pd_xmm_xmm_xmmm128,
	VEX_Vfmsub213pd_ymm_ymm_ymmm256,
	EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er,
	EVEX_V4fnmaddps_zmm_k1z_zmmp3_m128,
	VEX_Vfmsub213ss_xmm_xmm_xmmm32,
	VEX_Vfmsub213sd_xmm_xmm_xmmm64,
	EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er,
	EVEX_V4fnmaddss_xmm_k1z_xmmp3_m128,
	VEX_Vfnmadd213ps_xmm_xmm_xmmm128,
	VEX_Vfnmadd213ps_ymm_ymm_ymmm256,
	VEX_Vfnmadd213pd_xmm_xmm_xmmm128,
	VEX_Vfnmadd213pd_ymm_ymm_ymmm256,
	EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfnmadd213ss_xmm_xmm_xmmm32,
	VEX_Vfnmadd213sd_xmm_xmm_xmmm64,
	EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfnmsub213ps_xmm_xmm_xmmm128,
	VEX_Vfnmsub213ps_ymm_ymm_ymmm256,
	VEX_Vfnmsub213pd_xmm_xmm_xmmm128,
	VEX_Vfnmsub213pd_ymm_ymm_ymmm256,
	EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfnmsub213ss_xmm_xmm_xmmm32,
	VEX_Vfnmsub213sd_xmm_xmm_xmmm64,
	EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er,
	EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64,
	EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64,
	VEX_Vfmaddsub231ps_xmm_xmm_xmmm128,
	VEX_Vfmaddsub231ps_ymm_ymm_ymmm256,
	VEX_Vfmaddsub231pd_xmm_xmm_xmmm128,
	VEX_Vfmaddsub231pd_ymm_ymm_ymmm256,
	EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmsubadd231ps_xmm_xmm_xmmm128,
	VEX_Vfmsubadd231ps_ymm_ymm_ymmm256,
	VEX_Vfmsubadd231pd_xmm_xmm_xmmm128,
	VEX_Vfmsubadd231pd_ymm_ymm_ymmm256,
	EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmadd231ps_xmm_xmm_xmmm128,
	VEX_Vfmadd231ps_ymm_ymm_ymmm256,
	VEX_Vfmadd231pd_xmm_xmm_xmmm128,
	VEX_Vfmadd231pd_ymm_ymm_ymmm256,
	EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmadd231ss_xmm_xmm_xmmm32,
	VEX_Vfmadd231sd_xmm_xmm_xmmm64,
	EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfmsub231ps_xmm_xmm_xmmm128,
	VEX_Vfmsub231ps_ymm_ymm_ymmm256,
	VEX_Vfmsub231pd_xmm_xmm_xmmm128,
	VEX_Vfmsub231pd_ymm_ymm_ymmm256,
	EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfmsub231ss_xmm_xmm_xmmm32,
	VEX_Vfmsub231sd_xmm_xmm_xmmm64,
	EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfnmadd231ps_xmm_xmm_xmmm128,
	VEX_Vfnmadd231ps_ymm_ymm_ymmm256,
	VEX_Vfnmadd231pd_xmm_xmm_xmmm128,
	VEX_Vfnmadd231pd_ymm_ymm_ymmm256,
	EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfnmadd231ss_xmm_xmm_xmmm32,
	VEX_Vfnmadd231sd_xmm_xmm_xmmm64,
	EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er,
	VEX_Vfnmsub231ps_xmm_xmm_xmmm128,
	VEX_Vfnmsub231ps_ymm_ymm_ymmm256,
	VEX_Vfnmsub231pd_xmm_xmm_xmmm128,
	VEX_Vfnmsub231pd_ymm_ymm_ymmm256,
	EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64,
	EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64,
	EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er,
	VEX_Vfnmsub231ss_xmm_xmm_xmmm32,
	VEX_Vfnmsub231sd_xmm_xmm_xmmm64,
	EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er,
	EVEX_Vpconflictd_xmm_k1z_xmmm128b32,
	EVEX_Vpconflictd_ymm_k1z_ymmm256b32,
	EVEX_Vpconflictd_zmm_k1z_zmmm512b32,
	EVEX_Vpconflictq_xmm_k1z_xmmm128b64,
	EVEX_Vpconflictq_ymm_k1z_ymmm256b64,
	EVEX_Vpconflictq_zmm_k1z_zmmm512b64,
	EVEX_Vgatherpf0dps_vm32z_k1,
	EVEX_Vgatherpf0dpd_vm32y_k1,
	EVEX_Vgatherpf1dps_vm32z_k1,
	EVEX_Vgatherpf1dpd_vm32y_k1,
	EVEX_Vscatterpf0dps_vm32z_k1,
	EVEX_Vscatterpf0dpd_vm32y_k1,
	EVEX_Vscatterpf1dps_vm32z_k1,
	EVEX_Vscatterpf1dpd_vm32y_k1,
	EVEX_Vgatherpf0qps_vm64z_k1,
	EVEX_Vgatherpf0qpd_vm64z_k1,
	EVEX_Vgatherpf1qps_vm64z_k1,
	EVEX_Vgatherpf1qpd_vm64z_k1,
	EVEX_Vscatterpf0qps_vm64z_k1,
	EVEX_Vscatterpf0qpd_vm64z_k1,
	EVEX_Vscatterpf1qps_vm64z_k1,
	EVEX_Vscatterpf1qpd_vm64z_k1,
	Sha1nexte_xmm_xmmm128,
	EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae,
	EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae,
	Sha1msg1_xmm_xmmm128,
	Sha1msg2_xmm_xmmm128,
	EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae,
	EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae,
	Sha256rnds2_xmm_xmmm128,
	EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae,
	EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae,
	Sha256msg1_xmm_xmmm128,
	EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae,
	EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae,
	Sha256msg2_xmm_xmmm128,
	EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae,
	EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae,
	Gf2p8mulb_xmm_xmmm128,
	VEX_Vgf2p8mulb_xmm_xmm_xmmm128,
	VEX_Vgf2p8mulb_ymm_ymm_ymmm256,
	EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128,
	EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256,
	EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512,
	Aesimc_xmm_xmmm128,
	VEX_Vaesimc_xmm_xmmm128,
	Aesenc_xmm_xmmm128,
	VEX_Vaesenc_xmm_xmm_xmmm128,
	VEX_Vaesenc_ymm_ymm_ymmm256,
	EVEX_Vaesenc_xmm_xmm_xmmm128,
	EVEX_Vaesenc_ymm_ymm_ymmm256,
	EVEX_Vaesenc_zmm_zmm_zmmm512,
	Aesenclast_xmm_xmmm128,
	VEX_Vaesenclast_xmm_xmm_xmmm128,
	VEX_Vaesenclast_ymm_ymm_ymmm256,
	EVEX_Vaesenclast_xmm_xmm_xmmm128,
	EVEX_Vaesenclast_ymm_ymm_ymmm256,
	EVEX_Vaesenclast_zmm_zmm_zmmm512,
	Aesdec_xmm_xmmm128,
	VEX_Vaesdec_xmm_xmm_xmmm128,
	VEX_Vaesdec_ymm_ymm_ymmm256,
	EVEX_Vaesdec_xmm_xmm_xmmm128,
	EVEX_Vaesdec_ymm_ymm_ymmm256,
	EVEX_Vaesdec_zmm_zmm_zmmm512,
	Aesdeclast_xmm_xmmm128,
	VEX_Vaesdeclast_xmm_xmm_xmmm128,
	VEX_Vaesdeclast_ymm_ymm_ymmm256,
	EVEX_Vaesdeclast_xmm_xmm_xmmm128,
	EVEX_Vaesdeclast_ymm_ymm_ymmm256,
	EVEX_Vaesdeclast_zmm_zmm_zmmm512,
	Movbe_r16_m16,
	Movbe_r32_m32,
	Movbe_r64_m64,
	Crc32_r32_rm8,
	Crc32_r64_rm8,
	Movbe_m16_r16,
	Movbe_m32_r32,
	Movbe_m64_r64,
	Crc32_r32_rm16,
	Crc32_r32_rm32,
	Crc32_r64_rm64,
	VEX_Andn_r32_r32_rm32,
	VEX_Andn_r64_r64_rm64,
	VEX_Blsr_r32_rm32,
	VEX_Blsr_r64_rm64,
	VEX_Blsmsk_r32_rm32,
	VEX_Blsmsk_r64_rm64,
	VEX_Blsi_r32_rm32,
	VEX_Blsi_r64_rm64,
	VEX_Bzhi_r32_rm32_r32,
	VEX_Bzhi_r64_rm64_r64,
	Wrussd_m32_r32,
	Wrussq_m64_r64,
	VEX_Pext_r32_r32_rm32,
	VEX_Pext_r64_r64_rm64,
	VEX_Pdep_r32_r32_rm32,
	VEX_Pdep_r64_r64_rm64,
	Wrssd_m32_r32,
	Wrssq_m64_r64,
	Adcx_r32_rm32,
	Adcx_r64_rm64,
	Adox_r32_rm32,
	Adox_r64_rm64,
	VEX_Mulx_r32_r32_rm32,
	VEX_Mulx_r64_r64_rm64,
	VEX_Bextr_r32_rm32_r32,
	VEX_Bextr_r64_rm64_r64,
	VEX_Shlx_r32_rm32_r32,
	VEX_Shlx_r64_rm64_r64,
	VEX_Sarx_r32_rm32_r32,
	VEX_Sarx_r64_rm64_r64,
	VEX_Shrx_r32_rm32_r32,
	VEX_Shrx_r64_rm64_r64,
	Movdir64b_r16_m512,
	Movdir64b_r32_m512,
	Movdir64b_r64_m512,
	Enqcmds_r16_m512,
	Enqcmds_r32_m512,
	Enqcmds_r64_m512,
	Enqcmd_r16_m512,
	Enqcmd_r32_m512,
	Enqcmd_r64_m512,
	Movdiri_m32_r32,
	Movdiri_m64_r64,
	VEX_Vpermq_ymm_ymmm256_imm8,
	EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8,
	VEX_Vpermpd_ymm_ymmm256_imm8,
	EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8,
	VEX_Vpblendd_xmm_xmm_xmmm128_imm8,
	VEX_Vpblendd_ymm_ymm_ymmm256_imm8,
	EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8,
	EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8,
	VEX_Vpermilps_xmm_xmmm128_imm8,
	VEX_Vpermilps_ymm_ymmm256_imm8,
	EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8,
	VEX_Vpermilpd_xmm_xmmm128_imm8,
	VEX_Vpermilpd_ymm_ymmm256_imm8,
	EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8,
	VEX_Vperm2f128_ymm_ymm_ymmm256_imm8,
	Roundps_xmm_xmmm128_imm8,
	VEX_Vroundps_xmm_xmmm128_imm8,
	VEX_Vroundps_ymm_ymmm256_imm8,
	EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae,
	Roundpd_xmm_xmmm128_imm8,
	VEX_Vroundpd_xmm_xmmm128_imm8,
	VEX_Vroundpd_ymm_ymmm256_imm8,
	EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae,
	Roundss_xmm_xmmm32_imm8,
	VEX_Vroundss_xmm_xmm_xmmm32_imm8,
	EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae,
	Roundsd_xmm_xmmm64_imm8,
	VEX_Vroundsd_xmm_xmm_xmmm64_imm8,
	EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae,
	Blendps_xmm_xmmm128_imm8,
	VEX_Vblendps_xmm_xmm_xmmm128_imm8,
	VEX_Vblendps_ymm_ymm_ymmm256_imm8,
	Blendpd_xmm_xmmm128_imm8,
	VEX_Vblendpd_xmm_xmm_xmmm128_imm8,
	VEX_Vblendpd_ymm_ymm_ymmm256_imm8,
	Pblendw_xmm_xmmm128_imm8,
	VEX_Vpblendw_xmm_xmm_xmmm128_imm8,
	VEX_Vpblendw_ymm_ymm_ymmm256_imm8,
	Palignr_mm_mmm64_imm8,
	Palignr_xmm_xmmm128_imm8,
	VEX_Vpalignr_xmm_xmm_xmmm128_imm8,
	VEX_Vpalignr_ymm_ymm_ymmm256_imm8,
	EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8,
	EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8,
	EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8,
	Pextrb_r32m8_xmm_imm8,
	Pextrb_r64m8_xmm_imm8,
	VEX_Vpextrb_r32m8_xmm_imm8,
	VEX_Vpextrb_r64m8_xmm_imm8,
	EVEX_Vpextrb_r32m8_xmm_imm8,
	EVEX_Vpextrb_r64m8_xmm_imm8,
	Pextrw_r32m16_xmm_imm8,
	Pextrw_r64m16_xmm_imm8,
	VEX_Vpextrw_r32m16_xmm_imm8,
	VEX_Vpextrw_r64m16_xmm_imm8,
	EVEX_Vpextrw_r32m16_xmm_imm8,
	EVEX_Vpextrw_r64m16_xmm_imm8,
	Pextrd_rm32_xmm_imm8,
	Pextrq_rm64_xmm_imm8,
	VEX_Vpextrd_rm32_xmm_imm8,
	VEX_Vpextrq_rm64_xmm_imm8,
	EVEX_Vpextrd_rm32_xmm_imm8,
	EVEX_Vpextrq_rm64_xmm_imm8,
	Extractps_rm32_xmm_imm8,
	Extractps_r64m32_xmm_imm8,
	VEX_Vextractps_rm32_xmm_imm8,
	VEX_Vextractps_r64m32_xmm_imm8,
	EVEX_Vextractps_rm32_xmm_imm8,
	EVEX_Vextractps_r64m32_xmm_imm8,
	VEX_Vinsertf128_ymm_ymm_xmmm128_imm8,
	EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8,
	EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8,
	EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8,
	EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8,
	VEX_Vextractf128_xmmm128_ymm_imm8,
	EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8,
	EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8,
	EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8,
	EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8,
	EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8,
	EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8,
	EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8,
	EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8,
	VEX_Vcvtps2ph_xmmm64_xmm_imm8,
	VEX_Vcvtps2ph_xmmm128_ymm_imm8,
	EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8,
	EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8,
	EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae,
	EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8,
	EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8,
	EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8,
	EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8,
	EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8,
	EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8,
	EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8,
	EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8,
	EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8,
	EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8,
	EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8,
	EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8,
	Pinsrb_xmm_r32m8_imm8,
	Pinsrb_xmm_r64m8_imm8,
	VEX_Vpinsrb_xmm_xmm_r32m8_imm8,
	VEX_Vpinsrb_xmm_xmm_r64m8_imm8,
	EVEX_Vpinsrb_xmm_xmm_r32m8_imm8,
	EVEX_Vpinsrb_xmm_xmm_r64m8_imm8,
	Insertps_xmm_xmmm32_imm8,
	VEX_Vinsertps_xmm_xmm_xmmm32_imm8,
	EVEX_Vinsertps_xmm_xmm_xmmm32_imm8,
	Pinsrd_xmm_rm32_imm8,
	Pinsrq_xmm_rm64_imm8,
	VEX_Vpinsrd_xmm_xmm_rm32_imm8,
	VEX_Vpinsrq_xmm_xmm_rm64_imm8,
	EVEX_Vpinsrd_xmm_xmm_rm32_imm8,
	EVEX_Vpinsrq_xmm_xmm_rm64_imm8,
	EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8,
	EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8,
	EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8,
	EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8,
	EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae,
	EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae,
	EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae,
	EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae,
	VEX_Kshiftrb_kr_kr_imm8,
	VEX_Kshiftrw_kr_kr_imm8,
	VEX_Kshiftrd_kr_kr_imm8,
	VEX_Kshiftrq_kr_kr_imm8,
	VEX_Kshiftlb_kr_kr_imm8,
	VEX_Kshiftlw_kr_kr_imm8,
	VEX_Kshiftld_kr_kr_imm8,
	VEX_Kshiftlq_kr_kr_imm8,
	VEX_Vinserti128_ymm_ymm_xmmm128_imm8,
	EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8,
	EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8,
	EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8,
	EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8,
	VEX_Vextracti128_xmmm128_ymm_imm8,
	EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8,
	EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8,
	EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8,
	EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8,
	EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8,
	EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8,
	EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8,
	EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8,
	EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8,
	EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8,
	EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8,
	EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8,
	EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8,
	EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8,
	EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8,
	EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8,
	EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8,
	EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8,
	EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8,
	EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8,
	Dpps_xmm_xmmm128_imm8,
	VEX_Vdpps_xmm_xmm_xmmm128_imm8,
	VEX_Vdpps_ymm_ymm_ymmm256_imm8,
	Dppd_xmm_xmmm128_imm8,
	VEX_Vdppd_xmm_xmm_xmmm128_imm8,
	Mpsadbw_xmm_xmmm128_imm8,
	VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8,
	VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8,
	EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8,
	EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8,
	EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8,
	EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8,
	EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8,
	Pclmulqdq_xmm_xmmm128_imm8,
	VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8,
	VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8,
	EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8,
	EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8,
	EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8,
	VEX_Vperm2i128_ymm_ymm_ymmm256_imm8,
	VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4,
	VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4,
	VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4,
	VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4,
	VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4,
	VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4,
	VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4,
	VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4,
	VEX_Vblendvps_xmm_xmm_xmmm128_xmm,
	VEX_Vblendvps_ymm_ymm_ymmm256_ymm,
	VEX_Vblendvpd_xmm_xmm_xmmm128_xmm,
	VEX_Vblendvpd_ymm_ymm_ymmm256_ymm,
	VEX_Vpblendvb_xmm_xmm_xmmm128_xmm,
	VEX_Vpblendvb_ymm_ymm_ymmm256_ymm,
	EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae,
	EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae,
	EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae,
	EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae,
	EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae,
	EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae,
	EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae,
	EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae,
	EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8,
	EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8,
	EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae,
	EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8,
	EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8,
	EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae,
	EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae,
	EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae,
	VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm,
	VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm,
	VEX_Vfmaddsubps_xmm_xmm_xmm_xmmm128,
	VEX_Vfmaddsubps_ymm_ymm_ymm_ymmm256,
	VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm,
	VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm,
	VEX_Vfmaddsubpd_xmm_xmm_xmm_xmmm128,
	VEX_Vfmaddsubpd_ymm_ymm_ymm_ymmm256,
	VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm,
	VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm,
	VEX_Vfmsubaddps_xmm_xmm_xmm_xmmm128,
	VEX_Vfmsubaddps_ymm_ymm_ymm_ymmm256,
	VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm,
	VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm,
	VEX_Vfmsubaddpd_xmm_xmm_xmm_xmmm128,
	VEX_Vfmsubaddpd_ymm_ymm_ymm_ymmm256,
	Pcmpestrm_xmm_xmmm128_imm8,
	Pcmpestrm64_xmm_xmmm128_imm8,
	VEX_Vpcmpestrm_xmm_xmmm128_imm8,
	VEX_Vpcmpestrm64_xmm_xmmm128_imm8,
	Pcmpestri_xmm_xmmm128_imm8,
	Pcmpestri64_xmm_xmmm128_imm8,
	VEX_Vpcmpestri_xmm_xmmm128_imm8,
	VEX_Vpcmpestri64_xmm_xmmm128_imm8,
	Pcmpistrm_xmm_xmmm128_imm8,
	VEX_Vpcmpistrm_xmm_xmmm128_imm8,
	Pcmpistri_xmm_xmmm128_imm8,
	VEX_Vpcmpistri_xmm_xmmm128_imm8,
	EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8,
	EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8,
	EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8,
	EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8,
	EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8,
	EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8,
	EVEX_Vfpclassss_kr_k1_xmmm32_imm8,
	EVEX_Vfpclasssd_kr_k1_xmmm64_imm8,
	VEX_Vfmaddps_xmm_xmm_xmmm128_xmm,
	VEX_Vfmaddps_ymm_ymm_ymmm256_ymm,
	VEX_Vfmaddps_xmm_xmm_xmm_xmmm128,
	VEX_Vfmaddps_ymm_ymm_ymm_ymmm256,
	VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm,
	VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm,
	VEX_Vfmaddpd_xmm_xmm_xmm_xmmm128,
	VEX_Vfmaddpd_ymm_ymm_ymm_ymmm256,
	VEX_Vfmaddss_xmm_xmm_xmmm32_xmm,
	VEX_Vfmaddss_xmm_xmm_xmm_xmmm32,
	VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm,
	VEX_Vfmaddsd_xmm_xmm_xmm_xmmm64,
	VEX_Vfmsubps_xmm_xmm_xmmm128_xmm,
	VEX_Vfmsubps_ymm_ymm_ymmm256_ymm,
	VEX_Vfmsubps_xmm_xmm_xmm_xmmm128,
	VEX_Vfmsubps_ymm_ymm_ymm_ymmm256,
	VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm,
	VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm,
	VEX_Vfmsubpd_xmm_xmm_xmm_xmmm128,
	VEX_Vfmsubpd_ymm_ymm_ymm_ymmm256,
	VEX_Vfmsubss_xmm_xmm_xmmm32_xmm,
	VEX_Vfmsubss_xmm_xmm_xmm_xmmm32,
	VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm,
	VEX_Vfmsubsd_xmm_xmm_xmm_xmmm64,
	EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8,
	EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8,
	EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8,
	EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8,
	EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8,
	EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8,
	EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8,
	EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8,
	EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8,
	EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8,
	EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8,
	EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8,
	VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm,
	VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm,
	VEX_Vfnmaddps_xmm_xmm_xmm_xmmm128,
	VEX_Vfnmaddps_ymm_ymm_ymm_ymmm256,
	VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm,
	VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm,
	VEX_Vfnmaddpd_xmm_xmm_xmm_xmmm128,
	VEX_Vfnmaddpd_ymm_ymm_ymm_ymmm256,
	VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm,
	VEX_Vfnmaddss_xmm_xmm_xmm_xmmm32,
	VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm,
	VEX_Vfnmaddsd_xmm_xmm_xmm_xmmm64,
	VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm,
	VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm,
	VEX_Vfnmsubps_xmm_xmm_xmm_xmmm128,
	VEX_Vfnmsubps_ymm_ymm_ymm_ymmm256,
	VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm,
	VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm,
	VEX_Vfnmsubpd_xmm_xmm_xmm_xmmm128,
	VEX_Vfnmsubpd_ymm_ymm_ymm_ymmm256,
	VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm,
	VEX_Vfnmsubss_xmm_xmm_xmm_xmmm32,
	VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm,
	VEX_Vfnmsubsd_xmm_xmm_xmm_xmmm64,
	Sha1rnds4_xmm_xmmm128_imm8,
	Gf2p8affineqb_xmm_xmmm128_imm8,
	VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8,
	VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8,
	EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8,
	Gf2p8affineinvqb_xmm_xmmm128_imm8,
	VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8,
	VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8,
	EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8,
	EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8,
	EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8,
	Aeskeygenassist_xmm_xmmm128_imm8,
	VEX_Vaeskeygenassist_xmm_xmmm128_imm8,
	VEX_Rorx_r32_rm32_imm8,
	VEX_Rorx_r64_rm64_imm8,
	XOP_Vpmacssww_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacsww_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacswd_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm,
	XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm,
	XOP_Vpcmov_xmm_xmm_xmmm128_xmm,
	XOP_Vpcmov_ymm_ymm_ymmm256_ymm,
	XOP_Vpcmov_xmm_xmm_xmm_xmmm128,
	XOP_Vpcmov_ymm_ymm_ymm_ymmm256,
	XOP_Vpperm_xmm_xmm_xmmm128_xmm,
	XOP_Vpperm_xmm_xmm_xmm_xmmm128,
	XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm,
	XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm,
	XOP_Vprotb_xmm_xmmm128_imm8,
	XOP_Vprotw_xmm_xmmm128_imm8,
	XOP_Vprotd_xmm_xmmm128_imm8,
	XOP_Vprotq_xmm_xmmm128_imm8,
	XOP_Vpcomb_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomw_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomd_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomq_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomub_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomuw_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomud_xmm_xmm_xmmm128_imm8,
	XOP_Vpcomuq_xmm_xmm_xmmm128_imm8,
	XOP_Blcfill_r32_rm32,
	XOP_Blcfill_r64_rm64,
	XOP_Blsfill_r32_rm32,
	XOP_Blsfill_r64_rm64,
	XOP_Blcs_r32_rm32,
	XOP_Blcs_r64_rm64,
	XOP_Tzmsk_r32_rm32,
	XOP_Tzmsk_r64_rm64,
	XOP_Blcic_r32_rm32,
	XOP_Blcic_r64_rm64,
	XOP_Blsic_r32_rm32,
	XOP_Blsic_r64_rm64,
	XOP_T1mskc_r32_rm32,
	XOP_T1mskc_r64_rm64,
	XOP_Blcmsk_r32_rm32,
	XOP_Blcmsk_r64_rm64,
	XOP_Blci_r32_rm32,
	XOP_Blci_r64_rm64,
	XOP_Llwpcb_r32,
	XOP_Llwpcb_r64,
	XOP_Slwpcb_r32,
	XOP_Slwpcb_r64,
	XOP_Vfrczps_xmm_xmmm128,
	XOP_Vfrczps_ymm_ymmm256,
	XOP_Vfrczpd_xmm_xmmm128,
	XOP_Vfrczpd_ymm_ymmm256,
	XOP_Vfrczss_xmm_xmmm32,
	XOP_Vfrczsd_xmm_xmmm64,
	XOP_Vprotb_xmm_xmmm128_xmm,
	XOP_Vprotb_xmm_xmm_xmmm128,
	XOP_Vprotw_xmm_xmmm128_xmm,
	XOP_Vprotw_xmm_xmm_xmmm128,
	XOP_Vprotd_xmm_xmmm128_xmm,
	XOP_Vprotd_xmm_xmm_xmmm128,
	XOP_Vprotq_xmm_xmmm128_xmm,
	XOP_Vprotq_xmm_xmm_xmmm128,
	XOP_Vpshlb_xmm_xmmm128_xmm,
	XOP_Vpshlb_xmm_xmm_xmmm128,
	XOP_Vpshlw_xmm_xmmm128_xmm,
	XOP_Vpshlw_xmm_xmm_xmmm128,
	XOP_Vpshld_xmm_xmmm128_xmm,
	XOP_Vpshld_xmm_xmm_xmmm128,
	XOP_Vpshlq_xmm_xmmm128_xmm,
	XOP_Vpshlq_xmm_xmm_xmmm128,
	XOP_Vpshab_xmm_xmmm128_xmm,
	XOP_Vpshab_xmm_xmm_xmmm128,
	XOP_Vpshaw_xmm_xmmm128_xmm,
	XOP_Vpshaw_xmm_xmm_xmmm128,
	XOP_Vpshad_xmm_xmmm128_xmm,
	XOP_Vpshad_xmm_xmm_xmmm128,
	XOP_Vpshaq_xmm_xmmm128_xmm,
	XOP_Vpshaq_xmm_xmm_xmmm128,
	XOP_Vphaddbw_xmm_xmmm128,
	XOP_Vphaddbd_xmm_xmmm128,
	XOP_Vphaddbq_xmm_xmmm128,
	XOP_Vphaddwd_xmm_xmmm128,
	XOP_Vphaddwq_xmm_xmmm128,
	XOP_Vphadddq_xmm_xmmm128,
	XOP_Vphaddubw_xmm_xmmm128,
	XOP_Vphaddubd_xmm_xmmm128,
	XOP_Vphaddubq_xmm_xmmm128,
	XOP_Vphadduwd_xmm_xmmm128,
	XOP_Vphadduwq_xmm_xmmm128,
	XOP_Vphaddudq_xmm_xmmm128,
	XOP_Vphsubbw_xmm_xmmm128,
	XOP_Vphsubwd_xmm_xmmm128,
	XOP_Vphsubdq_xmm_xmmm128,
	XOP_Bextr_r32_rm32_imm32,
	XOP_Bextr_r64_rm64_imm32,
	XOP_Lwpins_r32_rm32_imm32,
	XOP_Lwpins_r64_rm32_imm32,
	XOP_Lwpval_r32_rm32_imm32,
	XOP_Lwpval_r64_rm32_imm32,
	D3NOW_Pi2fw_mm_mmm64,
	D3NOW_Pi2fd_mm_mmm64,
	D3NOW_Pf2iw_mm_mmm64,
	D3NOW_Pf2id_mm_mmm64,
	D3NOW_Pfrcpv_mm_mmm64,
	D3NOW_Pfrsqrtv_mm_mmm64,
	D3NOW_Pfnacc_mm_mmm64,
	D3NOW_Pfpnacc_mm_mmm64,
	D3NOW_Pfcmpge_mm_mmm64,
	D3NOW_Pfmin_mm_mmm64,
	D3NOW_Pfrcp_mm_mmm64,
	D3NOW_Pfrsqrt_mm_mmm64,
	D3NOW_Pfsub_mm_mmm64,
	D3NOW_Pfadd_mm_mmm64,
	D3NOW_Pfcmpgt_mm_mmm64,
	D3NOW_Pfmax_mm_mmm64,
	D3NOW_Pfrcpit1_mm_mmm64,
	D3NOW_Pfrsqit1_mm_mmm64,
	D3NOW_Pfsubr_mm_mmm64,
	D3NOW_Pfacc_mm_mmm64,
	D3NOW_Pfcmpeq_mm_mmm64,
	D3NOW_Pfmul_mm_mmm64,
	D3NOW_Pfrcpit2_mm_mmm64,
	D3NOW_Pmulhrw_mm_mmm64,
	D3NOW_Pswapd_mm_mmm64,
	D3NOW_Pavgusb_mm_mmm64,
	Rmpadjust,
	Rmpupdate,
	Psmash,
	Pvalidatew,
	Pvalidated,
	Pvalidateq,
	Serialize,
	Xsusldtrk,
	Xresldtrk,
	Invlpgbw,
	Invlpgbd,
	Invlpgbq,
	Tlbsync,
	Prefetchreserved3_m8,
	Prefetchreserved4_m8,
	Prefetchreserved5_m8,
	Prefetchreserved6_m8,
	Prefetchreserved7_m8,
	Ud0,
	Vmgexit,
	Getsecq,
	VEX_Ldtilecfg_m512,
	VEX_Tilerelease,
	VEX_Sttilecfg_m512,
	VEX_Tilezero_tmm,
	VEX_Tileloaddt1_tmm_sibmem,
	VEX_Tilestored_sibmem_tmm,
	VEX_Tileloadd_tmm_sibmem,
	VEX_Tdpbf16ps_tmm_tmm_tmm,
	VEX_Tdpbuud_tmm_tmm_tmm,
	VEX_Tdpbusd_tmm_tmm_tmm,
	VEX_Tdpbsud_tmm_tmm_tmm,
	VEX_Tdpbssd_tmm_tmm_tmm,
	Fnstdw_AX,
	Fnstsg_AX,
	Rdshr_rm32,
	Wrshr_rm32,
	Smint,
	Dmint,
	Rdm,
	Svdc_m80_Sreg,
	Rsdc_Sreg_m80,
	Svldt_m80,
	Rsldt_m80,
	Svts_m80,
	Rsts_m80,
	Smint_0F7E,
	Bb0_reset,
	Bb1_reset,
	Cpu_write,
	Cpu_read,
	Altinst,
	Paveb_mm_mmm64,
	Paddsiw_mm_mmm64,
	Pmagw_mm_mmm64,
	Pdistib_mm_m64,
	Psubsiw_mm_mmm64,
	Pmvzb_mm_m64,
	Pmulhrw_mm_mmm64,
	Pmvnzb_mm_m64,
	Pmvlzb_mm_m64,
	Pmvgezb_mm_m64,
	Pmulhriw_mm_mmm64,
	Pmachriw_mm_m64,
	Cyrix_D9D7,
	Cyrix_D9E2,
	Ftstp,
	Cyrix_D9E7,
	Frint2,
	Frichop,
	Cyrix_DED8,
	Cyrix_DEDA,
	Cyrix_DEDC,
	Cyrix_DEDD,
	Cyrix_DEDE,
	Frinear,
	Tdcall,
	Seamret,
	Seamops,
	Seamcall,
	Aesencwide128kl_m384,
	Aesdecwide128kl_m384,
	Aesencwide256kl_m512,
	Aesdecwide256kl_m512,
	Loadiwkey_xmm_xmm,
	Aesenc128kl_xmm_m384,
	Aesdec128kl_xmm_m384,
	Aesenc256kl_xmm_m512,
	Aesdec256kl_xmm_m512,
	Encodekey128_r32_r32,
	Encodekey256_r32_r32,
	VEX_Vbroadcastss_xmm_xmm,
	VEX_Vbroadcastss_ymm_xmm,
	VEX_Vbroadcastsd_ymm_xmm,
	Vmgexit_F2,
	Uiret,
	Testui,
	Clui,
	Stui,
	Senduipi_r64,
	Hreset_imm8,
	VEX_Vpdpbusd_xmm_xmm_xmmm128,
	VEX_Vpdpbusd_ymm_ymm_ymmm256,
	VEX_Vpdpbusds_xmm_xmm_xmmm128,
	VEX_Vpdpbusds_ymm_ymm_ymmm256,
	VEX_Vpdpwssd_xmm_xmm_xmmm128,
	VEX_Vpdpwssd_ymm_ymm_ymmm256,
	VEX_Vpdpwssds_xmm_xmm_xmmm128,
	VEX_Vpdpwssds_ymm_ymm_ymmm256,
	Ccs_hash_16,
	Ccs_hash_32,
	Ccs_hash_64,
	Ccs_encrypt_16,
	Ccs_encrypt_32,
	Ccs_encrypt_64,
	Lkgs_rm16,
	Lkgs_r32m16,
	Lkgs_r64m16,
	Eretu,
	Erets,
	EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8,
	EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8,
	EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae,
	EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae,
	EVEX_Vcomish_xmm_xmmm16_sae,
	EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32,
	EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32,
	EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er,
	EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64,
	EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64,
	EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er,
	EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16,
	EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16,
	EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er,
	EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16,
	EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16,
	EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae,
	EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16,
	EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16,
	EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae,
	EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16,
	EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16,
	EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er,
	EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16,
	EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16,
	EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er,
	EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16,
	EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16,
	EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er,
	EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16,
	EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16,
	EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er,
	EVEX_Vcvtph2w_xmm_k1z_xmmm128b16,
	EVEX_Vcvtph2w_ymm_k1z_ymmm256b16,
	EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er,
	EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32,
	EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32,
	EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er,
	EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64,
	EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64,
	EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er,
	EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er,
	EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae,
	EVEX_Vcvtsh2si_r32_xmmm16_er,
	EVEX_Vcvtsh2si_r64_xmmm16_er,
	EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae,
	EVEX_Vcvtsh2usi_r32_xmmm16_er,
	EVEX_Vcvtsh2usi_r64_xmmm16_er,
	EVEX_Vcvtsi2sh_xmm_xmm_rm32_er,
	EVEX_Vcvtsi2sh_xmm_xmm_rm64_er,
	EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16,
	EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16,
	EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae,
	EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16,
	EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16,
	EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae,
	EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16,
	EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16,
	EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae,
	EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16,
	EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16,
	EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae,
	EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16,
	EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16,
	EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae,
	EVEX_Vcvttph2w_xmm_k1z_xmmm128b16,
	EVEX_Vcvttph2w_ymm_k1z_ymmm256b16,
	EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae,
	EVEX_Vcvttsh2si_r32_xmmm16_sae,
	EVEX_Vcvttsh2si_r64_xmmm16_sae,
	EVEX_Vcvttsh2usi_r32_xmmm16_sae,
	EVEX_Vcvttsh2usi_r64_xmmm16_sae,
	EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32,
	EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32,
	EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er,
	EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64,
	EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64,
	EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er,
	EVEX_Vcvtusi2sh_xmm_xmm_rm32_er,
	EVEX_Vcvtusi2sh_xmm_xmm_rm64_er,
	EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16,
	EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16,
	EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er,
	EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16,
	EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16,
	EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er,
	EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32,
	EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32,
	EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er,
	EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er,
	EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8,
	EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8,
	EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8,
	EVEX_Vfpclasssh_kr_k1_xmmm16_imm8,
	EVEX_Vgetexpph_xmm_k1z_xmmm128b16,
	EVEX_Vgetexpph_ymm_k1z_ymmm256b16,
	EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae,
	EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae,
	EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8,
	EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8,
	EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae,
	EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae,
	EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae,
	EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae,
	EVEX_Vminph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vminph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae,
	EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae,
	EVEX_Vmovsh_xmm_k1z_m16,
	EVEX_Vmovsh_m16_k1_xmm,
	EVEX_Vmovsh_xmm_k1z_xmm_xmm,
	EVEX_Vmovsh_xmm_k1z_xmm_xmm_MAP5_11,
	EVEX_Vmovw_xmm_r32m16,
	EVEX_Vmovw_xmm_r64m16,
	EVEX_Vmovw_r32m16_xmm,
	EVEX_Vmovw_r64m16_xmm,
	EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vrcpph_xmm_k1z_xmmm128b16,
	EVEX_Vrcpph_ymm_k1z_ymmm256b16,
	EVEX_Vrcpph_zmm_k1z_zmmm512b16,
	EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16,
	EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8,
	EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8,
	EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae,
	EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae,
	EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8,
	EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8,
	EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae,
	EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae,
	EVEX_Vrsqrtph_xmm_k1z_xmmm128b16,
	EVEX_Vrsqrtph_ymm_k1z_ymmm256b16,
	EVEX_Vrsqrtph_zmm_k1z_zmmm512b16,
	EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16,
	EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vsqrtph_xmm_k1z_xmmm128b16,
	EVEX_Vsqrtph_ymm_k1z_ymmm256b16,
	EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er,
	EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16,
	EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16,
	EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er,
	EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er,
	EVEX_Vucomish_xmm_xmmm16_sae,
	Rdudbg,
	Wrudbg,
	VEX_KNC_Jkzd_kr_rel8_64,
	VEX_KNC_Jknzd_kr_rel8_64,
	VEX_KNC_Vprefetchnta_m8,
	VEX_KNC_Vprefetch0_m8,
	VEX_KNC_Vprefetch1_m8,
	VEX_KNC_Vprefetch2_m8,
	VEX_KNC_Vprefetchenta_m8,
	VEX_KNC_Vprefetche0_m8,
	VEX_KNC_Vprefetche1_m8,
	VEX_KNC_Vprefetche2_m8,
	VEX_KNC_Kand_kr_kr,
	VEX_KNC_Kandn_kr_kr,
	VEX_KNC_Kandnr_kr_kr,
	VEX_KNC_Knot_kr_kr,
	VEX_KNC_Kor_kr_kr,
	VEX_KNC_Kxnor_kr_kr,
	VEX_KNC_Kxor_kr_kr,
	VEX_KNC_Kmerge2l1h_kr_kr,
	VEX_KNC_Kmerge2l1l_kr_kr,
	VEX_KNC_Jkzd_kr_rel32_64,
	VEX_KNC_Jknzd_kr_rel32_64,
	VEX_KNC_Kmov_kr_kr,
	VEX_KNC_Kmov_kr_r32,
	VEX_KNC_Kmov_r32_kr,
	VEX_KNC_Kconcath_r64_kr_kr,
	VEX_KNC_Kconcatl_r64_kr_kr,
	VEX_KNC_Kortest_kr_kr,
	VEX_KNC_Delay_r32,
	VEX_KNC_Delay_r64,
	VEX_KNC_Spflt_r32,
	VEX_KNC_Spflt_r64,
	VEX_KNC_Clevict1_m8,
	VEX_KNC_Clevict0_m8,
	VEX_KNC_Popcnt_r32_r32,
	VEX_KNC_Popcnt_r64_r64,
	VEX_KNC_Tzcnt_r32_r32,
	VEX_KNC_Tzcnt_r64_r64,
	VEX_KNC_Tzcnti_r32_r32,
	VEX_KNC_Tzcnti_r64_r64,
	VEX_KNC_Lzcnt_r32_r32,
	VEX_KNC_Lzcnt_r64_r64,
	VEX_KNC_Undoc_r32_rm32_128_F3_0F38_W0_F0,
	VEX_KNC_Undoc_r64_rm64_128_F3_0F38_W1_F0,
	VEX_KNC_Undoc_r32_rm32_128_F2_0F38_W0_F0,
	VEX_KNC_Undoc_r64_rm64_128_F2_0F38_W1_F0,
	VEX_KNC_Undoc_r32_rm32_128_F2_0F38_W0_F1,
	VEX_KNC_Undoc_r64_rm64_128_F2_0F38_W1_F1,
	VEX_KNC_Kextract_kr_r64_imm8,
	MVEX_Vprefetchnta_m,
	MVEX_Vprefetch0_m,
	MVEX_Vprefetch1_m,
	MVEX_Vprefetch2_m,
	MVEX_Vprefetchenta_m,
	MVEX_Vprefetche0_m,
	MVEX_Vprefetche1_m,
	MVEX_Vprefetche2_m,
	MVEX_Vmovaps_zmm_k1_zmmmt,
	MVEX_Vmovapd_zmm_k1_zmmmt,
	MVEX_Vmovaps_mt_k1_zmm,
	MVEX_Vmovapd_mt_k1_zmm,
	MVEX_Vmovnrapd_m_k1_zmm,
	MVEX_Vmovnrngoapd_m_k1_zmm,
	MVEX_Vmovnraps_m_k1_zmm,
	MVEX_Vmovnrngoaps_m_k1_zmm,
	MVEX_Vaddps_zmm_k1_zmm_zmmmt,
	MVEX_Vaddpd_zmm_k1_zmm_zmmmt,
	MVEX_Vmulps_zmm_k1_zmm_zmmmt,
	MVEX_Vmulpd_zmm_k1_zmm_zmmmt,
	MVEX_Vcvtps2pd_zmm_k1_zmmmt,
	MVEX_Vcvtpd2ps_zmm_k1_zmmmt,
	MVEX_Vsubps_zmm_k1_zmm_zmmmt,
	MVEX_Vsubpd_zmm_k1_zmm_zmmmt,
	MVEX_Vpcmpgtd_kr_k1_zmm_zmmmt,
	MVEX_Vmovdqa32_zmm_k1_zmmmt,
	MVEX_Vmovdqa64_zmm_k1_zmmmt,
	MVEX_Vpshufd_zmm_k1_zmmmt_imm8,
	MVEX_Vpsrld_zmm_k1_zmmmt_imm8,
	MVEX_Vpsrad_zmm_k1_zmmmt_imm8,
	MVEX_Vpslld_zmm_k1_zmmmt_imm8,
	MVEX_Vpcmpeqd_kr_k1_zmm_zmmmt,
	MVEX_Vcvtudq2pd_zmm_k1_zmmmt,
	MVEX_Vmovdqa32_mt_k1_zmm,
	MVEX_Vmovdqa64_mt_k1_zmm,
	MVEX_Clevict1_m,
	MVEX_Clevict0_m,
	MVEX_Vcmpps_kr_k1_zmm_zmmmt_imm8,
	MVEX_Vcmppd_kr_k1_zmm_zmmmt_imm8,
	MVEX_Vpandd_zmm_k1_zmm_zmmmt,
	MVEX_Vpandq_zmm_k1_zmm_zmmmt,
	MVEX_Vpandnd_zmm_k1_zmm_zmmmt,
	MVEX_Vpandnq_zmm_k1_zmm_zmmmt,
	MVEX_Vcvtdq2pd_zmm_k1_zmmmt,
	MVEX_Vpord_zmm_k1_zmm_zmmmt,
	MVEX_Vporq_zmm_k1_zmm_zmmmt,
	MVEX_Vpxord_zmm_k1_zmm_zmmmt,
	MVEX_Vpxorq_zmm_k1_zmm_zmmmt,
	MVEX_Vpsubd_zmm_k1_zmm_zmmmt,
	MVEX_Vpaddd_zmm_k1_zmm_zmmmt,
	MVEX_Vbroadcastss_zmm_k1_mt,
	MVEX_Vbroadcastsd_zmm_k1_mt,
	MVEX_Vbroadcastf32x4_zmm_k1_mt,
	MVEX_Vbroadcastf64x4_zmm_k1_mt,
	MVEX_Vptestmd_kr_k1_zmm_zmmmt,
	MVEX_Vpermd_zmm_k1_zmm_zmmmt,
	MVEX_Vpminsd_zmm_k1_zmm_zmmmt,
	MVEX_Vpminud_zmm_k1_zmm_zmmmt,
	MVEX_Vpmaxsd_zmm_k1_zmm_zmmmt,
	MVEX_Vpmaxud_zmm_k1_zmm_zmmmt,
	MVEX_Vpmulld_zmm_k1_zmm_zmmmt,
	MVEX_Vgetexpps_zmm_k1_zmmmt,
	MVEX_Vgetexppd_zmm_k1_zmmmt,
	MVEX_Vpsrlvd_zmm_k1_zmm_zmmmt,
	MVEX_Vpsravd_zmm_k1_zmm_zmmmt,
	MVEX_Vpsllvd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_48,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_49,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_4A,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_4B,
	MVEX_Vaddnps_zmm_k1_zmm_zmmmt,
	MVEX_Vaddnpd_zmm_k1_zmm_zmmmt,
	MVEX_Vgmaxabsps_zmm_k1_zmm_zmmmt,
	MVEX_Vgminps_zmm_k1_zmm_zmmmt,
	MVEX_Vgminpd_zmm_k1_zmm_zmmmt,
	MVEX_Vgmaxps_zmm_k1_zmm_zmmmt,
	MVEX_Vgmaxpd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_54,
	MVEX_Vfixupnanps_zmm_k1_zmm_zmmmt,
	MVEX_Vfixupnanpd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_56,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_57,
	MVEX_Vpbroadcastd_zmm_k1_mt,
	MVEX_Vpbroadcastq_zmm_k1_mt,
	MVEX_Vbroadcasti32x4_zmm_k1_mt,
	MVEX_Vbroadcasti64x4_zmm_k1_mt,
	MVEX_Vpadcd_zmm_k1_kr_zmmmt,
	MVEX_Vpaddsetcd_zmm_k1_kr_zmmmt,
	MVEX_Vpsbbd_zmm_k1_kr_zmmmt,
	MVEX_Vpsubsetbd_zmm_k1_kr_zmmmt,
	MVEX_Vpblendmd_zmm_k1_zmm_zmmmt,
	MVEX_Vpblendmq_zmm_k1_zmm_zmmmt,
	MVEX_Vblendmps_zmm_k1_zmm_zmmmt,
	MVEX_Vblendmpd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_67,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_68,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_69,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_6A,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_6B,
	MVEX_Vpsubrd_zmm_k1_zmm_zmmmt,
	MVEX_Vsubrps_zmm_k1_zmm_zmmmt,
	MVEX_Vsubrpd_zmm_k1_zmm_zmmmt,
	MVEX_Vpsbbrd_zmm_k1_kr_zmmmt,
	MVEX_Vpsubrsetbd_zmm_k1_kr_zmmmt,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_70,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_71,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_72,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_73,
	MVEX_Vpcmpltd_kr_k1_zmm_zmmmt,
	MVEX_Vscaleps_zmm_k1_zmm_zmmmt,
	MVEX_Vpmulhud_zmm_k1_zmm_zmmmt,
	MVEX_Vpmulhd_zmm_k1_zmm_zmmmt,
	MVEX_Vpgatherdd_zmm_k1_mvt,
	MVEX_Vpgatherdq_zmm_k1_mvt,
	MVEX_Vgatherdps_zmm_k1_mvt,
	MVEX_Vgatherdpd_zmm_k1_mvt,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_94,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W1_94,
	MVEX_Vfmadd132ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmadd132pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfmsub132ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmsub132pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmadd132ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmadd132pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmsub132ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmsub132pd_zmm_k1_zmm_zmmmt,
	MVEX_Vpscatterdd_mvt_k1_zmm,
	MVEX_Vpscatterdq_mvt_k1_zmm,
	MVEX_Vscatterdps_mvt_k1_zmm,
	MVEX_Vscatterdpd_mvt_k1_zmm,
	MVEX_Vfmadd233ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmadd213ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmadd213pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfmsub213ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmsub213pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmadd213ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmadd213pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmsub213ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmsub213pd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B0,
	MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B2,
	MVEX_Vpmadd233d_zmm_k1_zmm_zmmmt,
	MVEX_Vpmadd231d_zmm_k1_zmm_zmmmt,
	MVEX_Vfmadd231ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmadd231pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfmsub231ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfmsub231pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmadd231ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmadd231pd_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmsub231ps_zmm_k1_zmm_zmmmt,
	MVEX_Vfnmsub231pd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_C0,
	MVEX_Vgatherpf0hintdps_mvt_k1,
	MVEX_Vgatherpf0hintdpd_mvt_k1,
	MVEX_Vgatherpf0dps_mvt_k1,
	MVEX_Vgatherpf1dps_mvt_k1,
	MVEX_Vscatterpf0hintdps_mvt_k1,
	MVEX_Vscatterpf0hintdpd_mvt_k1,
	MVEX_Vscatterpf0dps_mvt_k1,
	MVEX_Vscatterpf1dps_mvt_k1,
	MVEX_Vexp223ps_zmm_k1_zmmmt,
	MVEX_Vlog2ps_zmm_k1_zmmmt,
	MVEX_Vrcp23ps_zmm_k1_zmmmt,
	MVEX_Vrsqrt23ps_zmm_k1_zmmmt,
	MVEX_Vaddsetsps_zmm_k1_zmm_zmmmt,
	MVEX_Vpaddsetsd_zmm_k1_zmm_zmmmt,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_CE,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W1_CE,
	MVEX_Undoc_zmm_k1_zmm_zmmmt_512_66_0F38_W0_CF,
	MVEX_Vloadunpackld_zmm_k1_mt,
	MVEX_Vloadunpacklq_zmm_k1_mt,
	MVEX_Vpackstoreld_mt_k1_zmm,
	MVEX_Vpackstorelq_mt_k1_zmm,
	MVEX_Vloadunpacklps_zmm_k1_mt,
	MVEX_Vloadunpacklpd_zmm_k1_mt,
	MVEX_Vpackstorelps_mt_k1_zmm,
	MVEX_Vpackstorelpd_mt_k1_zmm,
	MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D2,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_D2,
	MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D3,
	MVEX_Vloadunpackhd_zmm_k1_mt,
	MVEX_Vloadunpackhq_zmm_k1_mt,
	MVEX_Vpackstorehd_mt_k1_zmm,
	MVEX_Vpackstorehq_mt_k1_zmm,
	MVEX_Vloadunpackhps_zmm_k1_mt,
	MVEX_Vloadunpackhpd_zmm_k1_mt,
	MVEX_Vpackstorehps_mt_k1_zmm,
	MVEX_Vpackstorehpd_mt_k1_zmm,
	MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D6,
	MVEX_Undoc_zmm_k1_zmmmt_512_66_0F38_W0_D6,
	MVEX_Undoc_zmm_k1_zmmmt_512_0F38_W0_D7,
	MVEX_Valignd_zmm_k1_zmm_zmmmt_imm8,
	MVEX_Vpermf32x4_zmm_k1_zmmmt_imm8,
	MVEX_Vpcmpud_kr_k1_zmm_zmmmt_imm8,
	MVEX_Vpcmpd_kr_k1_zmm_zmmmt_imm8,
	MVEX_Vgetmantps_zmm_k1_zmmmt_imm8,
	MVEX_Vgetmantpd_zmm_k1_zmmmt_imm8,
	MVEX_Vrndfxpntps_zmm_k1_zmmmt_imm8,
	MVEX_Vrndfxpntpd_zmm_k1_zmmmt_imm8,
	MVEX_Vcvtfxpntudq2ps_zmm_k1_zmmmt_imm8,
	MVEX_Vcvtfxpntps2udq_zmm_k1_zmmmt_imm8,
	MVEX_Vcvtfxpntpd2udq_zmm_k1_zmmmt_imm8,
	MVEX_Vcvtfxpntdq2ps_zmm_k1_zmmmt_imm8,
	MVEX_Vcvtfxpntps2dq_zmm_k1_zmmmt_imm8,
	MVEX_Undoc_zmm_k1_zmmmt_imm8_512_66_0F3A_W0_D0,
	MVEX_Undoc_zmm_k1_zmmmt_imm8_512_66_0F3A_W0_D1,
	MVEX_Vcvtfxpntpd2dq_zmm_k1_zmmmt_imm8,
	Via_undoc_F30FA6F0_16,
	Via_undoc_F30FA6F0_32,
	Via_undoc_F30FA6F0_64,
	Via_undoc_F30FA6F8_16,
	Via_undoc_F30FA6F8_32,
	Via_undoc_F30FA6F8_64,
	Xsha512_16,
	Xsha512_32,
	Xsha512_64,
	Xstore_alt_16,
	Xstore_alt_32,
	Xstore_alt_64,
	Xsha512_alt_16,
	Xsha512_alt_32,
	Xsha512_alt_64,
	Zero_bytes
}


using Iced.Intel;

internal static class CodeExtensions
{
	internal static bool IgnoresSegment(this Code code)
	{
		if ((uint)(code - 290) <= 2u || (uint)(code - 1040) <= 3u || (uint)(code - 1047) <= 3u)
		{
			return true;
		}
		return false;
	}

	internal static bool IgnoresIndex(this Code code)
	{
		if (code == Code.Bndldx_bnd_mib || code == Code.Bndstx_mib_bnd)
		{
			return true;
		}
		return false;
	}

	internal static bool IsTileStrideIndex(this Code code)
	{
		if ((uint)(code - 4228) <= 2u)
		{
			return true;
		}
		return false;
	}
}


internal abstract class CodeReader
{
	public abstract int ReadByte();
}


internal enum CodeSize
{
	Unknown,
	Code16,
	Code32,
	Code64
}


internal abstract class CodeWriter
{
	public abstract void WriteByte(byte value);
}


internal struct ConstantOffsets
{
	public byte DisplacementOffset;

	public byte DisplacementSize;

	public byte ImmediateOffset;

	public byte ImmediateSize;

	public byte ImmediateOffset2;

	public byte ImmediateSize2;

	private byte pad1;

	private byte pad2;

	public readonly bool HasDisplacement => DisplacementSize != 0;

	public readonly bool HasImmediate => ImmediateSize != 0;

	public readonly bool HasImmediate2 => ImmediateSize2 != 0;
}


internal enum OpSize : byte
{
	Size16,
	Size32,
	Size64
}


using System;

[Flags]
internal enum StateFlags : uint
{
	IpRel64 = 1u,
	IpRel32 = 2u,
	HasRex = 8u,
	b = 0x10u,
	z = 0x20u,
	IsInvalid = 0x40u,
	W = 0x80u,
	NoImm = 0x100u,
	Addr64 = 0x200u,
	BranchImm8 = 0x400u,
	Xbegin = 0x800u,
	Lock = 0x1000u,
	AllowLock = 0x2000u,
	NoMoreBytes = 0x4000u,
	Has66 = 0x8000u,
	MvexSssMask = 7u,
	MvexSssShift = 0x10u,
	MvexEH = 0x80000u,
	EncodingMask = 7u,
	EncodingShift = 0x1Du
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class Decoder : IEnumerable<Instruction>, IEnumerable
{
	internal struct ZState
	{
		public uint instructionLength;

		public uint extraRegisterBase;

		public uint extraIndexRegisterBase;

		public uint extraBaseRegisterBase;

		public uint extraIndexRegisterBaseVSIB;

		public StateFlags flags;

		public MandatoryPrefixByte mandatoryPrefix;

		public byte segmentPrio;
	}

	internal struct State
	{
		public uint modrm;

		public uint mod;

		public uint reg;

		public uint rm;

		public ZState zs;

		public uint vvvv;

		public uint vvvv_invalidCheck;

		public uint aaa;

		public uint extraRegisterBaseEVEX;

		public uint extraBaseRegisterBaseEVEX;

		public uint vectorLength;

		public OpSize operandSize;

		public OpSize addressSize;

		public readonly EncodingKind Encoding => (EncodingKind)(((uint)zs.flags >> 29) & 7);
	}

	private readonly struct RegInfo2
	{
		public readonly Register baseReg;

		public readonly Register indexReg;

		public RegInfo2(Register baseReg, Register indexReg)
		{
			this.baseReg = baseReg;
			this.indexReg = indexReg;
		}

		public void Deconstruct(out Register baseReg, out Register indexReg)
		{
			baseReg = this.baseReg;
			indexReg = this.indexReg;
		}
	}

	public struct Enumerator : IEnumerator<Instruction>, IDisposable, IEnumerator
	{
		private readonly Decoder decoder;

		private Instruction instruction;

		public Instruction Current => instruction;

		Instruction IEnumerator<Instruction>.Current => Current;

		object IEnumerator.Current => Current;

		internal Enumerator(Decoder decoder)
		{
			this.decoder = decoder;
			instruction = default(Instruction);
		}

		public bool MoveNext()
		{
			decoder.Decode(out instruction);
			return instruction.Length != 0;
		}

		void IEnumerator.Reset()
		{
			throw new InvalidOperationException();
		}

		public void Dispose()
		{
		}
	}

	private ulong instructionPointer;

	private readonly CodeReader reader;

	private readonly RegInfo2[] memRegs16;

	private readonly OpCodeHandler[] handlers_MAP0;

	private readonly OpCodeHandler[] handlers_VEX_0F;

	private readonly OpCodeHandler[] handlers_VEX_0F38;

	private readonly OpCodeHandler[] handlers_VEX_0F3A;

	private readonly OpCodeHandler[] handlers_EVEX_0F;

	private readonly OpCodeHandler[] handlers_EVEX_0F38;

	private readonly OpCodeHandler[] handlers_EVEX_0F3A;

	private readonly OpCodeHandler[] handlers_EVEX_MAP5;

	private readonly OpCodeHandler[] handlers_EVEX_MAP6;

	private readonly OpCodeHandler[] handlers_XOP_MAP8;

	private readonly OpCodeHandler[] handlers_XOP_MAP9;

	private readonly OpCodeHandler[] handlers_XOP_MAP10;

	internal State state;

	internal uint displIndex;

	internal readonly DecoderOptions options;

	internal readonly uint invalidCheckMask;

	internal readonly uint is64bMode_and_W;

	internal readonly uint reg15Mask;

	private readonly uint maskE0;

	private readonly uint rexMask;

	internal readonly CodeSize defaultCodeSize;

	internal readonly OpSize defaultOperandSize;

	private readonly OpSize defaultAddressSize;

	internal readonly OpSize defaultInvertedOperandSize;

	internal readonly OpSize defaultInvertedAddressSize;

	internal readonly bool is64bMode;

	private static readonly RegInfo2[] s_memRegs16;

	public ulong IP
	{
		get
		{
			return instructionPointer;
		}
		set
		{
			instructionPointer = value;
		}
	}

	public int Bitness { get; }

	public DecoderError LastError
	{
		get
		{
			if ((state.zs.flags & StateFlags.NoMoreBytes) != 0)
			{
				return DecoderError.NoMoreBytes;
			}
			if ((state.zs.flags & StateFlags.IsInvalid) != 0)
			{
				return DecoderError.InvalidInstruction;
			}
			return DecoderError.None;
		}
	}

	static Decoder()
	{
		s_memRegs16 = new RegInfo2[8]
		{
			new RegInfo2(Register.BX, Register.SI),
			new RegInfo2(Register.BX, Register.DI),
			new RegInfo2(Register.BP, Register.SI),
			new RegInfo2(Register.BP, Register.DI),
			new RegInfo2(Register.SI, Register.None),
			new RegInfo2(Register.DI, Register.None),
			new RegInfo2(Register.BP, Register.None),
			new RegInfo2(Register.BX, Register.None)
		};
		_ = OpCodeHandler_Invalid.Instance;
		_ = InstructionMemorySizes.SizesNormal;
		_ = OpCodeHandler_D3NOW.CodeValues;
		_ = InstructionOpCounts.OpCount;
		_ = MnemonicUtilsData.toMnemonic;
	}

	private Decoder(CodeReader reader, ulong ip, DecoderOptions options, int bitness)
	{
		this.reader = reader ?? throw new ArgumentNullException("reader");
		instructionPointer = ip;
		this.options = options;
		invalidCheckMask = (((options & DecoderOptions.NoInvalidCheck) == 0) ? uint.MaxValue : 0u);
		memRegs16 = s_memRegs16;
		Bitness = bitness;
		switch (bitness)
		{
		case 64:
			is64bMode = true;
			defaultCodeSize = CodeSize.Code64;
			defaultOperandSize = OpSize.Size32;
			defaultInvertedOperandSize = OpSize.Size16;
			defaultAddressSize = OpSize.Size64;
			defaultInvertedAddressSize = OpSize.Size32;
			maskE0 = 224u;
			rexMask = 240u;
			break;
		case 32:
			is64bMode = false;
			defaultCodeSize = CodeSize.Code32;
			defaultOperandSize = OpSize.Size32;
			defaultInvertedOperandSize = OpSize.Size16;
			defaultAddressSize = OpSize.Size32;
			defaultInvertedAddressSize = OpSize.Size16;
			maskE0 = 0u;
			rexMask = 0u;
			break;
		default:
			is64bMode = false;
			defaultCodeSize = CodeSize.Code16;
			defaultOperandSize = OpSize.Size16;
			defaultInvertedOperandSize = OpSize.Size32;
			defaultAddressSize = OpSize.Size16;
			defaultInvertedAddressSize = OpSize.Size32;
			maskE0 = 0u;
			rexMask = 0u;
			break;
		}
		is64bMode_and_W = (is64bMode ? 128u : 0u);
		reg15Mask = (is64bMode ? 15u : 7u);
		handlers_MAP0 = OpCodeHandlersTables_Legacy.Handlers_MAP0;
		handlers_VEX_0F = OpCodeHandlersTables_VEX.Handlers_0F;
		handlers_VEX_0F38 = OpCodeHandlersTables_VEX.Handlers_0F38;
		handlers_VEX_0F3A = OpCodeHandlersTables_VEX.Handlers_0F3A;
		handlers_EVEX_0F = OpCodeHandlersTables_EVEX.Handlers_0F;
		handlers_EVEX_0F38 = OpCodeHandlersTables_EVEX.Handlers_0F38;
		handlers_EVEX_0F3A = OpCodeHandlersTables_EVEX.Handlers_0F3A;
		handlers_EVEX_MAP5 = OpCodeHandlersTables_EVEX.Handlers_MAP5;
		handlers_EVEX_MAP6 = OpCodeHandlersTables_EVEX.Handlers_MAP6;
		handlers_XOP_MAP8 = OpCodeHandlersTables_XOP.Handlers_MAP8;
		handlers_XOP_MAP9 = OpCodeHandlersTables_XOP.Handlers_MAP9;
		handlers_XOP_MAP10 = OpCodeHandlersTables_XOP.Handlers_MAP10;
	}

	public static Decoder Create(int bitness, CodeReader reader, ulong ip, DecoderOptions options = DecoderOptions.None)
	{
		if (bitness == 16 || bitness == 32 || bitness == 64)
		{
			return new Decoder(reader, ip, options, bitness);
		}
		throw new ArgumentOutOfRangeException("bitness");
	}

	public static Decoder Create(int bitness, byte[] data, ulong ip, DecoderOptions options = DecoderOptions.None)
	{
		return Create(bitness, new ByteArrayCodeReader(data), ip, options);
	}

	public static Decoder Create(int bitness, CodeReader reader, DecoderOptions options = DecoderOptions.None)
	{
		return Create(bitness, reader, 0uL, options);
	}

	public static Decoder Create(int bitness, byte[] data, DecoderOptions options = DecoderOptions.None)
	{
		return Create(bitness, new ByteArrayCodeReader(data), 0uL, options);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal uint ReadByte()
	{
		uint instructionLength = state.zs.instructionLength;
		if (instructionLength < 15)
		{
			uint num = (uint)reader.ReadByte();
			if (num <= 255)
			{
				state.zs.instructionLength = instructionLength + 1;
				return num;
			}
			state.zs.flags |= StateFlags.NoMoreBytes;
		}
		state.zs.flags |= StateFlags.IsInvalid;
		return 0u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal uint ReadUInt16()
	{
		return ReadByte() | (ReadByte() << 8);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal uint ReadUInt32()
	{
		return ReadByte() | (ReadByte() << 8) | (ReadByte() << 16) | (ReadByte() << 24);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ulong ReadUInt64()
	{
		return ReadUInt32() | ((ulong)ReadUInt32() << 32);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Instruction Decode()
	{
		Decode(out var instruction);
		return instruction;
	}

	public void Decode(out Instruction instruction)
	{
		instruction = default(Instruction);
		state.zs = default(ZState);
		state.operandSize = defaultOperandSize;
		state.addressSize = defaultAddressSize;
		uint num = ReadByte();
		if ((num & rexMask) == 64)
		{
			StateFlags stateFlags = state.zs.flags | StateFlags.HasRex;
			if ((num & 8) != 0)
			{
				stateFlags |= StateFlags.W;
				state.operandSize = OpSize.Size64;
			}
			state.zs.flags = stateFlags;
			state.zs.extraRegisterBase = (num << 1) & 8;
			state.zs.extraIndexRegisterBase = (num << 2) & 8;
			state.zs.extraBaseRegisterBase = (num << 3) & 8;
			num = ReadByte();
		}
		DecodeTable(handlers_MAP0[num], ref instruction);
		instruction.InternalCodeSize = defaultCodeSize;
		uint num2 = (uint)(instruction.Length = (int)state.zs.instructionLength);
		ulong num3 = instructionPointer;
		num3 = (instruction.NextIP = (instructionPointer = num3 + num2));
		StateFlags flags = state.zs.flags;
		if ((flags & (StateFlags.IpRel64 | StateFlags.IpRel32 | StateFlags.IsInvalid | StateFlags.Lock)) == 0)
		{
			return;
		}
		ulong num5 = (instruction.MemoryDisplacement64 += num3);
		if ((flags & (StateFlags.IpRel64 | StateFlags.IsInvalid | StateFlags.Lock)) != StateFlags.IpRel64)
		{
			if ((flags & StateFlags.IpRel64) == 0)
			{
				instruction.MemoryDisplacement64 = num5 - num3;
			}
			if ((flags & StateFlags.IpRel32) != 0)
			{
				instruction.MemoryDisplacement64 = (uint)((int)instruction.MemoryDisplacement64 + (int)num3);
			}
			if ((flags & StateFlags.IsInvalid) != 0 || ((uint)(flags & (StateFlags.Lock | StateFlags.AllowLock)) & invalidCheckMask) == 4096)
			{
				instruction = default(Instruction);
				state.zs.flags = flags | StateFlags.IsInvalid;
				instruction.InternalCodeSize = defaultCodeSize;
				instruction.Length = (int)num2;
				instruction.NextIP = num3;
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ResetRexPrefixState()
	{
		state.zs.flags &= ~(StateFlags.HasRex | StateFlags.W);
		if ((state.zs.flags & StateFlags.Has66) == 0)
		{
			state.operandSize = defaultOperandSize;
		}
		else
		{
			state.operandSize = defaultInvertedOperandSize;
		}
		state.zs.extraRegisterBase = 0u;
		state.zs.extraIndexRegisterBase = 0u;
		state.zs.extraBaseRegisterBase = 0u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void CallOpCodeHandlerXXTable(ref Instruction instruction)
	{
		uint num = ReadByte();
		DecodeTable(handlers_MAP0[num], ref instruction);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal uint GetCurrentInstructionPointer32()
	{
		return (uint)(int)instructionPointer + state.zs.instructionLength;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal ulong GetCurrentInstructionPointer64()
	{
		return instructionPointer + state.zs.instructionLength;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ClearMandatoryPrefix(ref Instruction instruction)
	{
		instruction.InternalClearHasRepeRepnePrefix();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void SetXacquireXrelease(ref Instruction instruction)
	{
		if (instruction.HasLockPrefix)
		{
			if (state.zs.mandatoryPrefix == MandatoryPrefixByte.PF2)
			{
				ClearMandatoryPrefixF2(ref instruction);
				instruction.InternalSetHasXacquirePrefix();
			}
			else if (state.zs.mandatoryPrefix == MandatoryPrefixByte.PF3)
			{
				ClearMandatoryPrefixF3(ref instruction);
				instruction.InternalSetHasXreleasePrefix();
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ClearMandatoryPrefixF3(ref Instruction instruction)
	{
		instruction.InternalClearHasRepePrefix();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ClearMandatoryPrefixF2(ref Instruction instruction)
	{
		instruction.InternalClearHasRepnePrefix();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void SetInvalidInstruction()
	{
		state.zs.flags |= StateFlags.IsInvalid;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void DecodeTable(OpCodeHandler[] table, ref Instruction instruction)
	{
		DecodeTable(table[ReadByte()], ref instruction);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void DecodeTable(OpCodeHandler handler, ref Instruction instruction)
	{
		if (handler.HasModRM)
		{
			uint num = ReadByte();
			state.modrm = num;
			state.mod = num >> 6;
			state.reg = (num >> 3) & 7;
			state.rm = num & 7;
		}
		handler.Decode(this, ref instruction);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ReadModRM()
	{
		uint num = ReadByte();
		state.modrm = num;
		state.mod = num >> 6;
		state.reg = (num >> 3) & 7;
		state.rm = num & 7;
	}

	internal void VEX2(ref Instruction instruction)
	{
		if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
		{
			SetInvalidInstruction();
		}
		state.zs.flags &= ~StateFlags.W;
		state.zs.extraIndexRegisterBase = 0u;
		state.zs.extraBaseRegisterBase = 0u;
		uint modrm = state.modrm;
		state.vectorLength = (modrm >> 2) & 1;
		state.zs.mandatoryPrefix = (MandatoryPrefixByte)(modrm & 3);
		modrm = ~modrm;
		state.zs.extraRegisterBase = (modrm >> 4) & 8;
		modrm = (modrm >> 3) & 0xF;
		state.vvvv = modrm;
		state.vvvv_invalidCheck = modrm;
		DecodeTable(handlers_VEX_0F, ref instruction);
	}

	internal void VEX3(ref Instruction instruction)
	{
		if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
		{
			SetInvalidInstruction();
		}
		state.zs.flags &= ~StateFlags.W;
		uint num = ReadByte();
		state.zs.flags |= (StateFlags)(num & 0x80);
		state.vectorLength = (num >> 2) & 1;
		state.zs.mandatoryPrefix = (MandatoryPrefixByte)(num & 3);
		num = (~num >> 3) & 0xF;
		state.vvvv_invalidCheck = num;
		state.vvvv = num & reg15Mask;
		uint modrm = state.modrm;
		uint num2 = ~modrm & maskE0;
		state.zs.extraRegisterBase = (num2 >> 4) & 8;
		state.zs.extraIndexRegisterBase = (num2 >> 3) & 8;
		state.zs.extraBaseRegisterBase = (num2 >> 2) & 8;
		uint num3 = ReadByte();
		OpCodeHandler[] array;
		switch ((int)(modrm & 0x1F))
		{
		case 1:
			array = handlers_VEX_0F;
			break;
		case 2:
			array = handlers_VEX_0F38;
			break;
		case 3:
			array = handlers_VEX_0F3A;
			break;
		default:
			SetInvalidInstruction();
			return;
		}
		DecodeTable(array[num3], ref instruction);
	}

	internal void XOP(ref Instruction instruction)
	{
		if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
		{
			SetInvalidInstruction();
		}
		state.zs.flags &= ~StateFlags.W;
		uint num = ReadByte();
		state.zs.flags |= (StateFlags)(num & 0x80);
		state.vectorLength = (num >> 2) & 1;
		state.zs.mandatoryPrefix = (MandatoryPrefixByte)(num & 3);
		num = (~num >> 3) & 0xF;
		state.vvvv_invalidCheck = num;
		state.vvvv = num & reg15Mask;
		uint modrm = state.modrm;
		uint num2 = ~modrm & maskE0;
		state.zs.extraRegisterBase = (num2 >> 4) & 8;
		state.zs.extraIndexRegisterBase = (num2 >> 3) & 8;
		state.zs.extraBaseRegisterBase = (num2 >> 2) & 8;
		uint num3 = ReadByte();
		OpCodeHandler[] array;
		switch ((int)(modrm & 0x1F))
		{
		case 8:
			array = handlers_XOP_MAP8;
			break;
		case 9:
			array = handlers_XOP_MAP9;
			break;
		case 10:
			array = handlers_XOP_MAP10;
			break;
		default:
			SetInvalidInstruction();
			return;
		}
		DecodeTable(array[num3], ref instruction);
	}

	internal void EVEX_MVEX(ref Instruction instruction)
	{
		if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
		{
			SetInvalidInstruction();
		}
		state.zs.flags &= ~StateFlags.W;
		uint modrm = state.modrm;
		uint num = ReadByte();
		uint num2 = ReadByte();
		uint num3 = ReadByte();
		uint num4 = ReadByte();
		if ((num & 4) != 0)
		{
			if ((modrm & 8) == 0)
			{
				state.zs.mandatoryPrefix = (MandatoryPrefixByte)(num & 3);
				state.zs.flags |= (StateFlags)(num & 0x80);
				uint num5 = num2 & 7;
				state.aaa = num5;
				instruction.InternalOpMask = num5;
				if ((num2 & 0x80) != 0)
				{
					if ((num5 ^ invalidCheckMask) == uint.MaxValue)
					{
						SetInvalidInstruction();
					}
					state.zs.flags |= StateFlags.z;
					instruction.InternalSetZeroingMasking();
				}
				state.zs.flags |= (StateFlags)(num2 & 0x10);
				state.vectorLength = (num2 >> 5) & 3;
				num = (~num >> 3) & 0xF;
				if (is64bMode)
				{
					uint num6 = (~num2 & 8) << 1;
					state.zs.extraIndexRegisterBaseVSIB = num6;
					num6 += num;
					state.vvvv = num6;
					state.vvvv_invalidCheck = num6;
					uint num7 = ~modrm;
					state.zs.extraRegisterBase = (num7 >> 4) & 8;
					state.zs.extraIndexRegisterBase = (num7 >> 3) & 8;
					state.extraRegisterBaseEVEX = num7 & 0x10;
					num7 >>= 2;
					state.extraBaseRegisterBaseEVEX = num7 & 0x18;
					state.zs.extraBaseRegisterBase = num7 & 8;
				}
				else
				{
					state.vvvv_invalidCheck = num;
					state.vvvv = num & 7;
					state.zs.flags |= (StateFlags)((~num2 & 8) << 3);
				}
				OpCodeHandler[] array;
				switch ((int)(modrm & 7))
				{
				case 1:
					array = handlers_EVEX_0F;
					break;
				case 2:
					array = handlers_EVEX_0F38;
					break;
				case 3:
					array = handlers_EVEX_0F3A;
					break;
				case 5:
					array = handlers_EVEX_MAP5;
					break;
				case 6:
					array = handlers_EVEX_MAP6;
					break;
				default:
					SetInvalidInstruction();
					return;
				}
				OpCodeHandler obj = array[num3];
				state.modrm = num4;
				state.mod = num4 >> 6;
				state.reg = (num4 >> 3) & 7;
				state.rm = num4 & 7;
				if ((((uint)(state.zs.flags & StateFlags.b) | state.vectorLength) & invalidCheckMask) == 3)
				{
					SetInvalidInstruction();
				}
				obj.Decode(this, ref instruction);
			}
			else
			{
				SetInvalidInstruction();
			}
		}
		else
		{
			SetInvalidInstruction();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal Register ReadOpSegReg()
	{
		uint reg = state.reg;
		if (reg < 6)
		{
			return (Register)(71 + reg);
		}
		SetInvalidInstruction();
		return Register.None;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool ReadOpMem(ref Instruction instruction)
	{
		if (state.addressSize == OpSize.Size64)
		{
			return ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, isVsib: false);
		}
		if (state.addressSize == OpSize.Size32)
		{
			return ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, isVsib: false);
		}
		ReadOpMem16(ref instruction, TupleType.N1);
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ReadOpMemSib(ref Instruction instruction)
	{
		bool flag;
		if (state.addressSize == OpSize.Size64)
		{
			flag = ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, isVsib: false);
		}
		else if (state.addressSize == OpSize.Size32)
		{
			flag = ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, isVsib: false);
		}
		else
		{
			ReadOpMem16(ref instruction, TupleType.N1);
			flag = false;
		}
		if (invalidCheckMask != 0 && !flag)
		{
			SetInvalidInstruction();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ReadOpMem_MPX(ref Instruction instruction)
	{
		if (is64bMode)
		{
			state.addressSize = OpSize.Size64;
			ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, isVsib: false);
			return;
		}
		if (state.addressSize == OpSize.Size32)
		{
			ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, isVsib: false);
			return;
		}
		ReadOpMem16(ref instruction, TupleType.N1);
		if (invalidCheckMask != 0)
		{
			SetInvalidInstruction();
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ReadOpMem(ref Instruction instruction, TupleType tupleType)
	{
		if (state.addressSize == OpSize.Size64)
		{
			ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, tupleType, isVsib: false);
		}
		else if (state.addressSize == OpSize.Size32)
		{
			ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, tupleType, isVsib: false);
		}
		else
		{
			ReadOpMem16(ref instruction, tupleType);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void ReadOpMem_VSIB(ref Instruction instruction, Register vsibIndex, TupleType tupleType)
	{
		bool flag;
		if (state.addressSize == OpSize.Size64)
		{
			flag = ReadOpMem32Or64(ref instruction, Register.RAX, vsibIndex, tupleType, isVsib: true);
		}
		else if (state.addressSize == OpSize.Size32)
		{
			flag = ReadOpMem32Or64(ref instruction, Register.EAX, vsibIndex, tupleType, isVsib: true);
		}
		else
		{
			ReadOpMem16(ref instruction, tupleType);
			flag = false;
		}
		if (invalidCheckMask != 0 && !flag)
		{
			SetInvalidInstruction();
		}
	}

	private void ReadOpMem16(ref Instruction instruction, TupleType tupleType)
	{
		RegInfo2 regInfo = memRegs16[state.rm];
		var (internalMemoryBase, internalMemoryIndex) = (RegInfo2)(ref regInfo);
		switch ((int)state.mod)
		{
		case 0:
			if (state.rm == 6)
			{
				instruction.InternalSetMemoryDisplSize(2u);
				displIndex = state.zs.instructionLength;
				instruction.MemoryDisplacement64 = ReadUInt16();
				internalMemoryBase = Register.None;
			}
			break;
		case 1:
			instruction.InternalSetMemoryDisplSize(1u);
			displIndex = state.zs.instructionLength;
			if (tupleType == TupleType.N1)
			{
				instruction.MemoryDisplacement64 = (ushort)(sbyte)ReadByte();
			}
			else
			{
				instruction.MemoryDisplacement64 = (ushort)(GetDisp8N(tupleType) * (uint)(sbyte)ReadByte());
			}
			break;
		default:
			instruction.InternalSetMemoryDisplSize(2u);
			displIndex = state.zs.instructionLength;
			instruction.MemoryDisplacement64 = ReadUInt16();
			break;
		}
		instruction.InternalMemoryBase = internalMemoryBase;
		instruction.InternalMemoryIndex = internalMemoryIndex;
	}

	private bool ReadOpMem32Or64(ref Instruction instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib)
	{
		uint num;
		uint scale;
		uint num2;
		switch ((int)state.mod)
		{
		case 0:
			if (state.rm == 4)
			{
				num = ReadByte();
				scale = 0u;
				num2 = 0u;
				break;
			}
			if (state.rm == 5)
			{
				displIndex = state.zs.instructionLength;
				if (state.addressSize == OpSize.Size64)
				{
					instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
					instruction.InternalSetMemoryDisplSize(4u);
				}
				else
				{
					instruction.MemoryDisplacement64 = ReadUInt32();
					instruction.InternalSetMemoryDisplSize(3u);
				}
				if (is64bMode)
				{
					if (state.addressSize == OpSize.Size64)
					{
						state.zs.flags |= StateFlags.IpRel64;
						instruction.InternalMemoryBase = Register.RIP;
					}
					else
					{
						state.zs.flags |= StateFlags.IpRel32;
						instruction.InternalMemoryBase = Register.EIP;
					}
				}
				return false;
			}
			instruction.InternalMemoryBase = (Register)((int)(state.zs.extraBaseRegisterBase + state.rm) + (int)baseReg);
			return false;
		case 1:
			if (state.rm == 4)
			{
				num = ReadByte();
				scale = 1u;
				displIndex = state.zs.instructionLength;
				num2 = ((tupleType != 0) ? (GetDisp8N(tupleType) * (uint)(sbyte)ReadByte()) : ((uint)(sbyte)ReadByte()));
				break;
			}
			instruction.InternalSetMemoryDisplSize(1u);
			displIndex = state.zs.instructionLength;
			if (state.addressSize == OpSize.Size64)
			{
				if (tupleType == TupleType.N1)
				{
					instruction.MemoryDisplacement64 = (ulong)(sbyte)ReadByte();
				}
				else
				{
					instruction.MemoryDisplacement64 = (ulong)(GetDisp8N(tupleType) * (sbyte)ReadByte());
				}
			}
			else if (tupleType == TupleType.N1)
			{
				instruction.MemoryDisplacement64 = (uint)(sbyte)ReadByte();
			}
			else
			{
				instruction.MemoryDisplacement64 = GetDisp8N(tupleType) * (uint)(sbyte)ReadByte();
			}
			instruction.InternalMemoryBase = (Register)((int)(state.zs.extraBaseRegisterBase + state.rm) + (int)baseReg);
			return false;
		default:
			if (state.rm == 4)
			{
				num = ReadByte();
				scale = ((state.addressSize == OpSize.Size64) ? 4u : 3u);
				displIndex = state.zs.instructionLength;
				num2 = ReadUInt32();
				break;
			}
			displIndex = state.zs.instructionLength;
			if (state.addressSize == OpSize.Size64)
			{
				instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
				instruction.InternalSetMemoryDisplSize(4u);
			}
			else
			{
				instruction.MemoryDisplacement64 = ReadUInt32();
				instruction.InternalSetMemoryDisplSize(3u);
			}
			instruction.InternalMemoryBase = (Register)((int)(state.zs.extraBaseRegisterBase + state.rm) + (int)baseReg);
			return false;
		}
		uint num3 = ((num >> 3) & 7) + state.zs.extraIndexRegisterBase;
		uint num4 = num & 7;
		instruction.InternalMemoryIndexScale = (int)(num >> 6);
		if (!isVsib)
		{
			if (num3 != 4)
			{
				instruction.InternalMemoryIndex = (Register)((int)num3 + (int)indexReg);
			}
		}
		else
		{
			instruction.InternalMemoryIndex = (Register)((int)(num3 + state.zs.extraIndexRegisterBaseVSIB) + (int)indexReg);
		}
		if (num4 == 5 && state.mod == 0)
		{
			displIndex = state.zs.instructionLength;
			if (state.addressSize == OpSize.Size64)
			{
				instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
				instruction.InternalSetMemoryDisplSize(4u);
			}
			else
			{
				instruction.MemoryDisplacement64 = ReadUInt32();
				instruction.InternalSetMemoryDisplSize(3u);
			}
		}
		else
		{
			instruction.InternalMemoryBase = (Register)((int)(num4 + state.zs.extraBaseRegisterBase) + (int)baseReg);
			instruction.InternalSetMemoryDisplSize(scale);
			if (state.addressSize == OpSize.Size64)
			{
				instruction.MemoryDisplacement64 = (ulong)(int)num2;
			}
			else
			{
				instruction.MemoryDisplacement64 = num2;
			}
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private uint GetDisp8N(TupleType tupleType)
	{
		return TupleTypeTable.GetDisp8N(tupleType, (state.zs.flags & StateFlags.b) != 0);
	}

	public ConstantOffsets GetConstantOffsets(in Instruction instruction)
	{
		ConstantOffsets result = default(ConstantOffsets);
		int memoryDisplSize = instruction.MemoryDisplSize;
		if (memoryDisplSize != 0)
		{
			result.DisplacementOffset = (byte)displIndex;
			if (memoryDisplSize == 8 && (state.zs.flags & StateFlags.Addr64) == 0)
			{
				result.DisplacementSize = 4;
			}
			else
			{
				result.DisplacementSize = (byte)memoryDisplSize;
			}
		}
		if ((state.zs.flags & StateFlags.NoImm) == 0)
		{
			int num = 0;
			for (int num2 = instruction.OpCount - 1; num2 >= 0; num2--)
			{
				switch (instruction.GetOpKind(num2))
				{
				case OpKind.Immediate8:
				case OpKind.Immediate8to16:
				case OpKind.Immediate8to32:
				case OpKind.Immediate8to64:
					result.ImmediateOffset = (byte)(instruction.Length - num - 1);
					result.ImmediateSize = 1;
					break;
				case OpKind.Immediate16:
					result.ImmediateOffset = (byte)(instruction.Length - num - 2);
					result.ImmediateSize = 2;
					break;
				case OpKind.Immediate32:
				case OpKind.Immediate32to64:
					result.ImmediateOffset = (byte)(instruction.Length - num - 4);
					result.ImmediateSize = 4;
					break;
				case OpKind.Immediate64:
					result.ImmediateOffset = (byte)(instruction.Length - num - 8);
					result.ImmediateSize = 8;
					break;
				case OpKind.Immediate8_2nd:
					result.ImmediateOffset2 = (byte)(instruction.Length - 1);
					result.ImmediateSize2 = 1;
					num = 1;
					continue;
				case OpKind.NearBranch16:
					if ((state.zs.flags & StateFlags.BranchImm8) != 0)
					{
						result.ImmediateOffset = (byte)(instruction.Length - 1);
						result.ImmediateSize = 1;
					}
					else if ((state.zs.flags & StateFlags.Xbegin) == 0)
					{
						result.ImmediateOffset = (byte)(instruction.Length - 2);
						result.ImmediateSize = 2;
					}
					else if (state.operandSize != 0)
					{
						result.ImmediateOffset = (byte)(instruction.Length - 4);
						result.ImmediateSize = 4;
					}
					else
					{
						result.ImmediateOffset = (byte)(instruction.Length - 2);
						result.ImmediateSize = 2;
					}
					continue;
				case OpKind.NearBranch32:
				case OpKind.NearBranch64:
					if ((state.zs.flags & StateFlags.BranchImm8) != 0)
					{
						result.ImmediateOffset = (byte)(instruction.Length - 1);
						result.ImmediateSize = 1;
					}
					else if ((state.zs.flags & StateFlags.Xbegin) == 0)
					{
						result.ImmediateOffset = (byte)(instruction.Length - 4);
						result.ImmediateSize = 4;
					}
					else if (state.operandSize != 0)
					{
						result.ImmediateOffset = (byte)(instruction.Length - 4);
						result.ImmediateSize = 4;
					}
					else
					{
						result.ImmediateOffset = (byte)(instruction.Length - 2);
						result.ImmediateSize = 2;
					}
					continue;
				case OpKind.FarBranch16:
					result.ImmediateOffset = (byte)(instruction.Length - 4);
					result.ImmediateSize = 2;
					result.ImmediateOffset2 = (byte)(instruction.Length - 2);
					result.ImmediateSize2 = 2;
					continue;
				case OpKind.FarBranch32:
					result.ImmediateOffset = (byte)(instruction.Length - 6);
					result.ImmediateSize = 4;
					result.ImmediateOffset2 = (byte)(instruction.Length - 2);
					result.ImmediateSize2 = 2;
					continue;
				default:
					continue;
				}
				break;
			}
		}
		return result;
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator<Instruction> IEnumerable<Instruction>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


internal struct ZState
{
	public uint instructionLength;

	public uint extraRegisterBase;

	public uint extraIndexRegisterBase;

	public uint extraBaseRegisterBase;

	public uint extraIndexRegisterBaseVSIB;

	public StateFlags flags;

	public MandatoryPrefixByte mandatoryPrefix;

	public byte segmentPrio;
}


internal struct State
{
	public uint modrm;

	public uint mod;

	public uint reg;

	public uint rm;

	public ZState zs;

	public uint vvvv;

	public uint vvvv_invalidCheck;

	public uint aaa;

	public uint extraRegisterBaseEVEX;

	public uint extraBaseRegisterBaseEVEX;

	public uint vectorLength;

	public OpSize operandSize;

	public OpSize addressSize;

	public readonly EncodingKind Encoding => (EncodingKind)(((uint)zs.flags >> 29) & 7);
}


private readonly struct RegInfo2
{
	public readonly Register baseReg;

	public readonly Register indexReg;

	public RegInfo2(Register baseReg, Register indexReg)
	{
		this.baseReg = baseReg;
		this.indexReg = indexReg;
	}

	public void Deconstruct(out Register baseReg, out Register indexReg)
	{
		baseReg = this.baseReg;
		indexReg = this.indexReg;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public struct Enumerator : IEnumerator<Instruction>, IDisposable, IEnumerator
{
	private readonly Decoder decoder;

	private Instruction instruction;

	public Instruction Current => instruction;

	Instruction IEnumerator<Instruction>.Current => Current;

	object IEnumerator.Current => Current;

	internal Enumerator(Decoder decoder)
	{
		this.decoder = decoder;
		instruction = default(Instruction);
	}

	public bool MoveNext()
	{
		decoder.Decode(out instruction);
		return instruction.Length != 0;
	}

	void IEnumerator.Reset()
	{
		throw new InvalidOperationException();
	}

	public void Dispose()
	{
	}
}


internal enum DecoderError
{
	None,
	InvalidInstruction,
	NoMoreBytes
}


using System;

[Flags]
internal enum DecoderOptions : uint
{
	None = 0u,
	NoInvalidCheck = 1u,
	AMD = 2u,
	ForceReservedNop = 4u,
	Umov = 8u,
	Xbts = 0x10u,
	Cmpxchg486A = 0x20u,
	OldFpu = 0x40u,
	Pcommit = 0x80u,
	Loadall286 = 0x100u,
	Loadall386 = 0x200u,
	Cl1invmb = 0x400u,
	MovTr = 0x800u,
	Jmpe = 0x1000u,
	NoPause = 0x2000u,
	NoWbnoinvd = 0x4000u,
	Udbg = 0x8000u,
	NoMPFX_0FBC = 0x10000u,
	NoMPFX_0FBD = 0x20000u,
	NoLahfSahf64 = 0x40000u,
	MPX = 0x80000u,
	Cyrix = 0x100000u,
	Cyrix_SMINT_0F7E = 0x200000u,
	Cyrix_DMI = 0x400000u,
	ALTINST = 0x800000u,
	KNC = 0x1000000u
}


using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class Encoder
{
	private static readonly uint[] s_immSizes = new uint[19]
	{
		0u, 1u, 2u, 4u, 8u, 3u, 2u, 4u, 6u, 1u,
		1u, 1u, 2u, 2u, 2u, 4u, 4u, 1u, 1u
	};

	internal uint Internal_PreventVEX2;

	internal uint Internal_VEX_WIG_LIG;

	internal uint Internal_VEX_LIG;

	internal uint Internal_EVEX_WIG;

	internal uint Internal_EVEX_LIG;

	internal const string ERROR_ONLY_1632_BIT_MODE = "The instruction can only be used in 16/32-bit mode";

	internal const string ERROR_ONLY_64_BIT_MODE = "The instruction can only be used in 64-bit mode";

	private readonly CodeWriter writer;

	private readonly int bitness;

	private readonly OpCodeHandler[] handlers;

	private readonly uint[] immSizes;

	private ulong currentRip;

	private string errorMessage;

	private OpCodeHandler handler;

	private uint eip;

	private uint displAddr;

	private uint immAddr;

	internal uint Immediate;

	internal uint ImmediateHi;

	private uint Displ;

	private uint DisplHi;

	private readonly EncoderFlags opSize16Flags;

	private readonly EncoderFlags opSize32Flags;

	private readonly EncoderFlags adrSize16Flags;

	private readonly EncoderFlags adrSize32Flags;

	internal uint OpCode;

	internal EncoderFlags EncoderFlags;

	private DisplSize DisplSize;

	internal ImmSize ImmSize;

	private byte ModRM;

	private byte Sib;

	public bool PreventVEX2
	{
		get
		{
			return Internal_PreventVEX2 != 0;
		}
		set
		{
			Internal_PreventVEX2 = (value ? uint.MaxValue : 0u);
		}
	}

	public uint VEX_WIG
	{
		get
		{
			return (Internal_VEX_WIG_LIG >> 7) & 1;
		}
		set
		{
			Internal_VEX_WIG_LIG = (Internal_VEX_WIG_LIG & 0xFFFFFF7Fu) | ((value & 1) << 7);
		}
	}

	public uint VEX_LIG
	{
		get
		{
			return (Internal_VEX_WIG_LIG >> 2) & 1;
		}
		set
		{
			Internal_VEX_WIG_LIG = (Internal_VEX_WIG_LIG & 0xFFFFFFFBu) | ((value & 1) << 2);
			Internal_VEX_LIG = (value & 1) << 2;
		}
	}

	public uint EVEX_WIG
	{
		get
		{
			return Internal_EVEX_WIG >> 7;
		}
		set
		{
			Internal_EVEX_WIG = (value & 1) << 7;
		}
	}

	public uint EVEX_LIG
	{
		get
		{
			return Internal_EVEX_LIG >> 5;
		}
		set
		{
			Internal_EVEX_LIG = (value & 3) << 5;
		}
	}

	public int Bitness => bitness;

	internal string? ErrorMessage
	{
		set
		{
			if (errorMessage == null)
			{
				errorMessage = value;
			}
		}
	}

	private static ReadOnlySpan<byte> SegmentOverrides => "&.6>de"u8;

	private Encoder(CodeWriter writer, int bitness)
	{
		if (writer == null)
		{
			ThrowHelper.ThrowArgumentNullException_writer();
		}
		immSizes = s_immSizes;
		this.writer = writer;
		this.bitness = bitness;
		handlers = OpCodeHandlers.Handlers;
		handler = null;
		opSize16Flags = ((bitness != 16) ? EncoderFlags.P66 : EncoderFlags.None);
		opSize32Flags = ((bitness == 16) ? EncoderFlags.P66 : EncoderFlags.None);
		adrSize16Flags = ((bitness != 16) ? EncoderFlags.P67 : EncoderFlags.None);
		adrSize32Flags = ((bitness != 32) ? EncoderFlags.P67 : EncoderFlags.None);
	}

	public static Encoder Create(int bitness, CodeWriter writer)
	{
		if (bitness == 16 || bitness == 32 || bitness == 64)
		{
			return new Encoder(writer, bitness);
		}
		throw new ArgumentOutOfRangeException("bitness");
	}

	public uint Encode(in Instruction instruction, ulong rip)
	{
		if (!TryEncode(in instruction, rip, out uint encodedLength, out string text))
		{
			ThrowEncoderException(in instruction, text);
		}
		return encodedLength;
	}

	private static void ThrowEncoderException(in Instruction instruction, string errorMessage)
	{
		throw new EncoderException(errorMessage, in instruction);
	}

	public bool TryEncode(in Instruction instruction, ulong rip, out uint encodedLength, [<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(false)] out string? errorMessage)
	{
		currentRip = rip;
		eip = (uint)rip;
		this.errorMessage = null;
		EncoderFlags = EncoderFlags.None;
		DisplSize = DisplSize.None;
		ImmSize = ImmSize.None;
		ModRM = 0;
		OpCodeHandler opCodeHandler = (handler = handlers[(int)instruction.Code]);
		OpCode = opCodeHandler.OpCode;
		if (opCodeHandler.GroupIndex >= 0)
		{
			EncoderFlags = EncoderFlags.ModRM;
			ModRM = (byte)(opCodeHandler.GroupIndex << 3);
		}
		if (opCodeHandler.RmGroupIndex >= 0)
		{
			EncoderFlags = EncoderFlags.ModRM;
			ModRM |= (byte)(opCodeHandler.RmGroupIndex | 0xC0);
		}
		switch (opCodeHandler.EncFlags3 & (EncFlags3.Bit16or32 | EncFlags3.Bit64))
		{
		case EncFlags3.Bit16or32:
			if (bitness == 64)
			{
				ErrorMessage = "The instruction can only be used in 16/32-bit mode";
			}
			break;
		case EncFlags3.Bit64:
			if (bitness != 64)
			{
				ErrorMessage = "The instruction can only be used in 64-bit mode";
			}
			break;
		default:
			throw new InvalidOperationException();
		case EncFlags3.Bit16or32 | EncFlags3.Bit64:
			break;
		}
		switch (opCodeHandler.OpSize)
		{
		case CodeSize.Code16:
			EncoderFlags |= opSize16Flags;
			break;
		case CodeSize.Code32:
			EncoderFlags |= opSize32Flags;
			break;
		case CodeSize.Code64:
			if ((opCodeHandler.EncFlags3 & EncFlags3.DefaultOpSize64) == 0)
			{
				EncoderFlags |= EncoderFlags.W;
			}
			break;
		default:
			throw new InvalidOperationException();
		case CodeSize.Unknown:
			break;
		}
		switch (opCodeHandler.AddrSize)
		{
		case CodeSize.Code16:
			EncoderFlags |= adrSize16Flags;
			break;
		case CodeSize.Code32:
			EncoderFlags |= adrSize32Flags;
			break;
		default:
			throw new InvalidOperationException();
		case CodeSize.Unknown:
		case CodeSize.Code64:
			break;
		}
		if (!opCodeHandler.IsSpecialInstr)
		{
			Op[] operands = opCodeHandler.Operands;
			for (int i = 0; i < operands.Length; i++)
			{
				operands[i].Encode(this, in instruction, i);
			}
			if ((opCodeHandler.EncFlags3 & EncFlags3.Fwait) != 0)
			{
				WriteByteInternal(155u);
			}
			opCodeHandler.Encode(this, in instruction);
			uint opCode = OpCode;
			if (!opCodeHandler.Is2ByteOpCode)
			{
				WriteByteInternal(opCode);
			}
			else
			{
				WriteByteInternal(opCode >> 8);
				WriteByteInternal(opCode);
			}
			if ((EncoderFlags & (EncoderFlags.ModRM | EncoderFlags.Displ)) != 0)
			{
				WriteModRM();
			}
			if (ImmSize != 0)
			{
				WriteImmediate();
			}
		}
		else
		{
			opCodeHandler.Encode(this, in instruction);
		}
		uint num = (uint)((int)currentRip - (int)rip);
		if (num > 15 && !opCodeHandler.IsSpecialInstr)
		{
			ErrorMessage = $"Instruction length > {15} bytes";
		}
		errorMessage = this.errorMessage;
		if (errorMessage != null)
		{
			encodedLength = 0u;
			return false;
		}
		encodedLength = num;
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool Verify(int operand, OpKind expected, OpKind actual)
	{
		if (expected == actual)
		{
			return true;
		}
		ErrorMessage = $"Operand {operand}: Expected: {expected}, actual: {actual}";
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool Verify(int operand, Register expected, Register actual)
	{
		if (expected == actual)
		{
			return true;
		}
		ErrorMessage = $"Operand {operand}: Expected: {expected}, actual: {actual}";
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal bool Verify(int operand, Register register, Register regLo, Register regHi)
	{
		if (bitness != 64 && regHi > regLo + 7)
		{
			regHi = regLo + 7;
		}
		if (regLo <= register && register <= regHi)
		{
			return true;
		}
		ErrorMessage = $"Operand {operand}: Register {register} is not between {regLo} and {regHi} (inclusive)";
		return false;
	}

	internal void AddBranch(OpKind opKind, int immSize, in Instruction instruction, int operand)
	{
		if (!Verify(operand, opKind, instruction.GetOpKind(operand)))
		{
			return;
		}
		switch (immSize)
		{
		case 1:
			switch (opKind)
			{
			case OpKind.NearBranch16:
				EncoderFlags |= opSize16Flags;
				ImmSize = ImmSize.RipRelSize1_Target16;
				Immediate = instruction.NearBranch16;
				break;
			case OpKind.NearBranch32:
				EncoderFlags |= opSize32Flags;
				ImmSize = ImmSize.RipRelSize1_Target32;
				Immediate = instruction.NearBranch32;
				break;
			case OpKind.NearBranch64:
			{
				ImmSize = ImmSize.RipRelSize1_Target64;
				ulong nearBranch = instruction.NearBranch64;
				Immediate = (uint)nearBranch;
				ImmediateHi = (uint)(nearBranch >> 32);
				break;
			}
			default:
				throw new InvalidOperationException();
			}
			break;
		case 2:
			if (opKind == OpKind.NearBranch16)
			{
				EncoderFlags |= opSize16Flags;
				ImmSize = ImmSize.RipRelSize2_Target16;
				Immediate = instruction.NearBranch16;
				break;
			}
			throw new InvalidOperationException();
		case 4:
			switch (opKind)
			{
			case OpKind.NearBranch32:
				EncoderFlags |= opSize32Flags;
				ImmSize = ImmSize.RipRelSize4_Target32;
				Immediate = instruction.NearBranch32;
				break;
			case OpKind.NearBranch64:
			{
				ImmSize = ImmSize.RipRelSize4_Target64;
				ulong nearBranch = instruction.NearBranch64;
				Immediate = (uint)nearBranch;
				ImmediateHi = (uint)(nearBranch >> 32);
				break;
			}
			default:
				throw new InvalidOperationException();
			}
			break;
		default:
			throw new InvalidOperationException();
		}
	}

	internal void AddBranchX(int immSize, in Instruction instruction, int operand)
	{
		if (bitness == 64)
		{
			if (Verify(operand, OpKind.NearBranch64, instruction.GetOpKind(operand)))
			{
				ulong nearBranch = instruction.NearBranch64;
				switch (immSize)
				{
				case 2:
					EncoderFlags |= EncoderFlags.P66;
					ImmSize = ImmSize.RipRelSize2_Target64;
					Immediate = (uint)nearBranch;
					ImmediateHi = (uint)(nearBranch >> 32);
					break;
				case 4:
					ImmSize = ImmSize.RipRelSize4_Target64;
					Immediate = (uint)nearBranch;
					ImmediateHi = (uint)(nearBranch >> 32);
					break;
				default:
					throw new InvalidOperationException();
				}
			}
		}
		else if (Verify(operand, OpKind.NearBranch32, instruction.GetOpKind(operand)))
		{
			switch (immSize)
			{
			case 2:
				EncoderFlags |= (EncoderFlags)((bitness & 0x20) << 2);
				ImmSize = ImmSize.RipRelSize2_Target32;
				Immediate = instruction.NearBranch32;
				break;
			case 4:
				EncoderFlags |= (EncoderFlags)((bitness & 0x10) << 3);
				ImmSize = ImmSize.RipRelSize4_Target32;
				Immediate = instruction.NearBranch32;
				break;
			default:
				throw new InvalidOperationException();
			}
		}
	}

	internal void AddBranchDisp(int displSize, in Instruction instruction, int operand)
	{
		OpKind expected;
		switch (displSize)
		{
		case 2:
			expected = OpKind.NearBranch16;
			ImmSize = ImmSize.Size2;
			Immediate = instruction.NearBranch16;
			break;
		case 4:
			expected = OpKind.NearBranch32;
			ImmSize = ImmSize.Size4;
			Immediate = instruction.NearBranch32;
			break;
		default:
			throw new InvalidOperationException();
		}
		Verify(operand, expected, instruction.GetOpKind(operand));
	}

	internal void AddFarBranch(in Instruction instruction, int operand, int size)
	{
		if (size == 2)
		{
			if (!Verify(operand, OpKind.FarBranch16, instruction.GetOpKind(operand)))
			{
				return;
			}
			ImmSize = ImmSize.Size2_2;
			Immediate = instruction.FarBranch16;
			ImmediateHi = instruction.FarBranchSelector;
		}
		else
		{
			if (!Verify(operand, OpKind.FarBranch32, instruction.GetOpKind(operand)))
			{
				return;
			}
			ImmSize = ImmSize.Size4_2;
			Immediate = instruction.FarBranch32;
			ImmediateHi = instruction.FarBranchSelector;
		}
		if (bitness != size * 8)
		{
			EncoderFlags |= EncoderFlags.P66;
		}
	}

	internal void SetAddrSize(int regSize)
	{
		if (bitness == 64)
		{
			switch (regSize)
			{
			case 2:
				ErrorMessage = $"Invalid register size: {regSize * 8}, must be 32-bit or 64-bit";
				break;
			case 4:
				EncoderFlags |= EncoderFlags.P67;
				break;
			}
		}
		else if (regSize == 8)
		{
			ErrorMessage = $"Invalid register size: {regSize * 8}, must be 16-bit or 32-bit";
		}
		else if (bitness == 16)
		{
			if (regSize == 4)
			{
				EncoderFlags |= EncoderFlags.P67;
			}
		}
		else if (regSize == 2)
		{
			EncoderFlags |= EncoderFlags.P67;
		}
	}

	internal void AddAbsMem(in Instruction instruction, int operand)
	{
		EncoderFlags |= EncoderFlags.Displ;
		OpKind opKind = instruction.GetOpKind(operand);
		if (opKind == OpKind.Memory)
		{
			if (instruction.MemoryBase != 0 || instruction.MemoryIndex != 0)
			{
				ErrorMessage = $"Operand {operand}: Absolute addresses can't have base and/or index regs";
				return;
			}
			if (instruction.MemoryIndexScale != 1)
			{
				ErrorMessage = $"Operand {operand}: Absolute addresses must have scale == *1";
				return;
			}
			switch (instruction.MemoryDisplSize)
			{
			case 2:
				if (bitness == 64)
				{
					ErrorMessage = $"Operand {operand}: 16-bit abs addresses can't be used in 64-bit mode";
					break;
				}
				if (bitness == 32)
				{
					EncoderFlags |= EncoderFlags.P67;
				}
				DisplSize = DisplSize.Size2;
				if (instruction.MemoryDisplacement64 > 65535)
				{
					ErrorMessage = $"Operand {operand}: Displacement must fit in a ushort";
				}
				else
				{
					Displ = instruction.MemoryDisplacement32;
				}
				break;
			case 4:
				EncoderFlags |= adrSize32Flags;
				DisplSize = DisplSize.Size4;
				if (instruction.MemoryDisplacement64 > uint.MaxValue)
				{
					ErrorMessage = $"Operand {operand}: Displacement must fit in a uint";
				}
				else
				{
					Displ = instruction.MemoryDisplacement32;
				}
				break;
			case 8:
				if (bitness != 64)
				{
					ErrorMessage = $"Operand {operand}: 64-bit abs address is only available in 64-bit mode";
				}
				else
				{
					DisplSize = DisplSize.Size8;
					ulong memoryDisplacement = instruction.MemoryDisplacement64;
					Displ = (uint)memoryDisplacement;
					DisplHi = (uint)(memoryDisplacement >> 32);
				}
				break;
			default:
				ErrorMessage = $"Operand {operand}: {"Instruction"}.{"MemoryDisplSize"} must be initialized to 2 (16-bit), 4 (32-bit) or 8 (64-bit)";
				break;
			}
		}
		else
		{
			ErrorMessage = $"Operand {operand}: Expected OpKind {"Memory"}, actual: {opKind}";
		}
	}

	internal void AddModRMRegister(in Instruction instruction, int operand, Register regLo, Register regHi)
	{
		if (!Verify(operand, OpKind.Register, instruction.GetOpKind(operand)))
		{
			return;
		}
		Register opRegister = instruction.GetOpRegister(operand);
		if (!Verify(operand, opRegister, regLo, regHi))
		{
			return;
		}
		uint num = (uint)(opRegister - regLo);
		if (regLo == Register.AL)
		{
			if (opRegister >= Register.SPL)
			{
				num -= 4;
				EncoderFlags |= EncoderFlags.REX;
			}
			else if (opRegister >= Register.AH)
			{
				EncoderFlags |= EncoderFlags.HighLegacy8BitRegs;
			}
		}
		ModRM |= (byte)((num & 7) << 3);
		EncoderFlags |= EncoderFlags.ModRM;
		EncoderFlags |= (EncoderFlags)((num & 8) >> 1);
		EncoderFlags |= (EncoderFlags)((num & 0x10) << 5);
	}

	internal void AddReg(in Instruction instruction, int operand, Register regLo, Register regHi)
	{
		if (!Verify(operand, OpKind.Register, instruction.GetOpKind(operand)))
		{
			return;
		}
		Register opRegister = instruction.GetOpRegister(operand);
		if (!Verify(operand, opRegister, regLo, regHi))
		{
			return;
		}
		uint num = (uint)(opRegister - regLo);
		if (regLo == Register.AL)
		{
			if (opRegister >= Register.SPL)
			{
				num -= 4;
				EncoderFlags |= EncoderFlags.REX;
			}
			else if (opRegister >= Register.AH)
			{
				EncoderFlags |= EncoderFlags.HighLegacy8BitRegs;
			}
		}
		OpCode |= num & 7;
		EncoderFlags |= (EncoderFlags)(num >> 3);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void AddRegOrMem(in Instruction instruction, int operand, Register regLo, Register regHi, bool allowMemOp, bool allowRegOp)
	{
		AddRegOrMem(in instruction, operand, regLo, regHi, Register.None, Register.None, allowMemOp, allowRegOp);
	}

	internal void AddRegOrMem(in Instruction instruction, int operand, Register regLo, Register regHi, Register vsibIndexRegLo, Register vsibIndexRegHi, bool allowMemOp, bool allowRegOp)
	{
		OpKind opKind = instruction.GetOpKind(operand);
		EncoderFlags |= EncoderFlags.ModRM;
		switch (opKind)
		{
		case OpKind.Register:
		{
			if (!allowRegOp)
			{
				ErrorMessage = $"Operand {operand}: register operand is not allowed";
				break;
			}
			Register opRegister = instruction.GetOpRegister(operand);
			if (!Verify(operand, opRegister, regLo, regHi))
			{
				break;
			}
			uint num2 = (uint)(opRegister - regLo);
			if (regLo == Register.AL)
			{
				if (opRegister >= Register.R8L)
				{
					num2 -= 4;
				}
				else if (opRegister >= Register.SPL)
				{
					num2 -= 4;
					EncoderFlags |= EncoderFlags.REX;
				}
				else if (opRegister >= Register.AH)
				{
					EncoderFlags |= EncoderFlags.HighLegacy8BitRegs;
				}
			}
			ModRM |= (byte)(num2 & 7);
			ModRM |= 192;
			EncoderFlags |= (EncoderFlags)((num2 >> 3) & 3);
			break;
		}
		case OpKind.Memory:
		{
			if (!allowMemOp)
			{
				ErrorMessage = $"Operand {operand}: memory operand is not allowed";
				break;
			}
			if (instruction.MemorySize.IsBroadcast())
			{
				EncoderFlags |= EncoderFlags.Broadcast;
			}
			CodeSize codeSize = instruction.CodeSize;
			if (codeSize == CodeSize.Unknown)
			{
				codeSize = ((bitness == 64) ? CodeSize.Code64 : ((bitness != 32) ? CodeSize.Code16 : CodeSize.Code32));
			}
			int num = InstructionUtils.GetAddressSizeInBytes(instruction.MemoryBase, instruction.MemoryIndex, instruction.MemoryDisplSize, codeSize) * 8;
			if (num != bitness)
			{
				EncoderFlags |= EncoderFlags.P67;
			}
			if ((EncoderFlags & EncoderFlags.RegIsMemory) != 0 && GetRegisterOpSize(in instruction) != num)
			{
				ErrorMessage = $"Operand {operand}: Register operand size must equal memory addressing mode (16/32/64)";
			}
			else if (num == 16)
			{
				if (vsibIndexRegLo != 0)
				{
					ErrorMessage = $"Operand {operand}: VSIB operands can't use 16-bit addressing. It must be 32-bit or 64-bit addressing";
				}
				else
				{
					AddMemOp16(in instruction, operand);
				}
			}
			else
			{
				AddMemOp(in instruction, operand, num, vsibIndexRegLo, vsibIndexRegHi);
			}
			break;
		}
		default:
			ErrorMessage = $"Operand {operand}: Expected a register or memory operand, but opKind is {opKind}";
			break;
		}
	}

	private static int GetRegisterOpSize(in Instruction instruction)
	{
		if (instruction.Op0Kind == OpKind.Register)
		{
			Register op0Register = instruction.Op0Register;
			if (op0Register.IsGPR64())
			{
				return 64;
			}
			if (op0Register.IsGPR32())
			{
				return 32;
			}
			if (op0Register.IsGPR16())
			{
				return 16;
			}
		}
		return 0;
	}

	private bool TryConvertToDisp8N(in Instruction instruction, int displ, out sbyte compressedValue)
	{
		TryConvertToDisp8N tryConvertToDisp8N = handler.TryConvertToDisp8N;
		if (tryConvertToDisp8N != null)
		{
			return tryConvertToDisp8N(this, handler, in instruction, displ, out compressedValue);
		}
		if (-128 <= displ && displ <= 127)
		{
			compressedValue = (sbyte)displ;
			return true;
		}
		compressedValue = 0;
		return false;
	}

	private void AddMemOp16(in Instruction instruction, int operand)
	{
		if (bitness == 64)
		{
			ErrorMessage = $"Operand {operand}: 16-bit addressing can't be used by 64-bit code";
			return;
		}
		Register memoryBase = instruction.MemoryBase;
		Register memoryIndex = instruction.MemoryIndex;
		int num = instruction.MemoryDisplSize;
		if (memoryBase != Register.BX || memoryIndex != Register.SI)
		{
			if (memoryBase == Register.BX && memoryIndex == Register.DI)
			{
				ModRM |= 1;
			}
			else if (memoryBase == Register.BP && memoryIndex == Register.SI)
			{
				ModRM |= 2;
			}
			else if (memoryBase == Register.BP && memoryIndex == Register.DI)
			{
				ModRM |= 3;
			}
			else if (memoryBase == Register.SI && memoryIndex == Register.None)
			{
				ModRM |= 4;
			}
			else if (memoryBase == Register.DI && memoryIndex == Register.None)
			{
				ModRM |= 5;
			}
			else if (memoryBase == Register.BP && memoryIndex == Register.None)
			{
				ModRM |= 6;
			}
			else if (memoryBase == Register.BX && memoryIndex == Register.None)
			{
				ModRM |= 7;
			}
			else
			{
				if (memoryBase != 0 || memoryIndex != 0)
				{
					ErrorMessage = $"Operand {operand}: Invalid 16-bit base + index registers: base={memoryBase}, index={memoryIndex}";
					return;
				}
				ModRM |= 6;
				DisplSize = DisplSize.Size2;
				if (instruction.MemoryDisplacement64 > 65535)
				{
					ErrorMessage = $"Operand {operand}: Displacement must fit in a ushort";
					return;
				}
				Displ = instruction.MemoryDisplacement32;
			}
		}
		if (memoryBase == Register.None && memoryIndex == Register.None)
		{
			return;
		}
		if ((long)instruction.MemoryDisplacement64 < -32768L || (long)instruction.MemoryDisplacement64 > 65535L)
		{
			ErrorMessage = $"Operand {operand}: Displacement must fit in a short or a ushort";
			return;
		}
		Displ = instruction.MemoryDisplacement32;
		if (num == 0 && memoryBase == Register.BP && memoryIndex == Register.None)
		{
			num = 1;
			if (Displ != 0)
			{
				ErrorMessage = $"Operand {operand}: Displacement must be 0 if displSize == 0";
				return;
			}
		}
		if (num == 1)
		{
			if (TryConvertToDisp8N(in instruction, (short)Displ, out var compressedValue))
			{
				Displ = (uint)compressedValue;
			}
			else
			{
				num = 2;
			}
		}
		switch (num)
		{
		case 0:
			if (Displ != 0)
			{
				ErrorMessage = $"Operand {operand}: Displacement must be 0 if displSize == 0";
			}
			break;
		case 1:
			if ((int)Displ < -128 || (int)Displ > 127)
			{
				ErrorMessage = $"Operand {operand}: Displacement must fit in an sbyte";
			}
			else
			{
				ModRM |= 64;
				DisplSize = DisplSize.Size1;
			}
			break;
		case 2:
			ModRM |= 128;
			DisplSize = DisplSize.Size2;
			break;
		default:
			ErrorMessage = $"Operand {operand}: Invalid displacement size: {num}, must be 0, 1, or 2";
			break;
		}
	}

	private void AddMemOp(in Instruction instruction, int operand, int addrSize, Register vsibIndexRegLo, Register vsibIndexRegHi)
	{
		if (bitness != 64 && addrSize == 64)
		{
			ErrorMessage = $"Operand {operand}: 64-bit addressing can only be used in 64-bit mode";
			return;
		}
		Register memoryBase = instruction.MemoryBase;
		Register memoryIndex = instruction.MemoryIndex;
		int num = instruction.MemoryDisplSize;
		Register register;
		Register register2;
		if (addrSize == 64)
		{
			register = Register.RAX;
			register2 = Register.R15;
		}
		else
		{
			register = Register.EAX;
			register2 = Register.R15D;
		}
		Register register3;
		Register regHi;
		if (vsibIndexRegLo != 0)
		{
			register3 = vsibIndexRegLo;
			regHi = vsibIndexRegHi;
		}
		else
		{
			register3 = register;
			regHi = register2;
		}
		if ((memoryBase != 0 && memoryBase != Register.RIP && memoryBase != Register.EIP && !Verify(operand, memoryBase, register, register2)) || (memoryIndex != 0 && !Verify(operand, memoryIndex, register3, regHi)))
		{
			return;
		}
		if (num != 0 && num != 1 && num != 4 && num != 8)
		{
			ErrorMessage = $"Operand {operand}: Invalid displ size: {num}, must be 0, 1, 4, 8";
			return;
		}
		if (memoryBase == Register.RIP || memoryBase == Register.EIP)
		{
			if (memoryIndex != 0)
			{
				ErrorMessage = $"Operand {operand}: RIP relative addressing can't use an index register";
				return;
			}
			if (instruction.InternalMemoryIndexScale != 0)
			{
				ErrorMessage = $"Operand {operand}: RIP relative addressing must use scale *1";
				return;
			}
			if (bitness != 64)
			{
				ErrorMessage = $"Operand {operand}: RIP/EIP relative addressing is only available in 64-bit mode";
				return;
			}
			if ((EncoderFlags & EncoderFlags.MustUseSib) != 0)
			{
				ErrorMessage = $"Operand {operand}: RIP/EIP relative addressing isn't supported";
				return;
			}
			ModRM |= 5;
			ulong memoryDisplacement = instruction.MemoryDisplacement64;
			if (memoryBase == Register.RIP)
			{
				DisplSize = DisplSize.RipRelSize4_Target64;
				Displ = (uint)memoryDisplacement;
				DisplHi = (uint)(memoryDisplacement >> 32);
				return;
			}
			DisplSize = DisplSize.RipRelSize4_Target32;
			if (memoryDisplacement > uint.MaxValue)
			{
				ErrorMessage = $"Operand {operand}: Target address doesn't fit in 32 bits: 0x{memoryDisplacement:X}";
			}
			else
			{
				Displ = (uint)memoryDisplacement;
			}
			return;
		}
		int internalMemoryIndexScale = instruction.InternalMemoryIndexScale;
		Displ = instruction.MemoryDisplacement32;
		if (addrSize == 64)
		{
			if ((long)instruction.MemoryDisplacement64 < -2147483648L || (long)instruction.MemoryDisplacement64 > 2147483647L)
			{
				ErrorMessage = $"Operand {operand}: Displacement must fit in an int";
				return;
			}
		}
		else if ((long)instruction.MemoryDisplacement64 < -2147483648L || (long)instruction.MemoryDisplacement64 > 4294967295L)
		{
			ErrorMessage = $"Operand {operand}: Displacement must fit in an int or a uint";
			return;
		}
		if (memoryBase == Register.None && memoryIndex == Register.None)
		{
			if (vsibIndexRegLo != 0)
			{
				ErrorMessage = $"Operand {operand}: VSIB addressing can't use an offset-only address";
			}
			else if (bitness == 64 || internalMemoryIndexScale != 0 || (EncoderFlags & EncoderFlags.MustUseSib) != 0)
			{
				ModRM |= 4;
				DisplSize = DisplSize.Size4;
				EncoderFlags |= EncoderFlags.Sib;
				Sib = (byte)(0x25 | (internalMemoryIndexScale << 6));
			}
			else
			{
				ModRM |= 5;
				DisplSize = DisplSize.Size4;
			}
			return;
		}
		int num2 = ((memoryBase == Register.None) ? (-1) : (memoryBase - register));
		int num3 = ((memoryIndex == Register.None) ? (-1) : (memoryIndex - register3));
		if (num == 0 && (num2 & 7) == 5)
		{
			num = 1;
			if (Displ != 0)
			{
				ErrorMessage = $"Operand {operand}: Displacement must be 0 if displSize == 0";
				return;
			}
		}
		if (num == 1)
		{
			if (TryConvertToDisp8N(in instruction, (int)Displ, out var compressedValue))
			{
				Displ = (uint)compressedValue;
			}
			else
			{
				num = addrSize / 8;
			}
		}
		if (memoryBase == Register.None)
		{
			DisplSize = DisplSize.Size4;
		}
		else if (num == 1)
		{
			if ((int)Displ < -128 || (int)Displ > 127)
			{
				ErrorMessage = $"Operand {operand}: Displacement must fit in an sbyte";
				return;
			}
			ModRM |= 64;
			DisplSize = DisplSize.Size1;
		}
		else if (num == addrSize / 8)
		{
			ModRM |= 128;
			DisplSize = DisplSize.Size4;
		}
		else
		{
			if (num != 0)
			{
				ErrorMessage = $"Operand {operand}: Invalid {"MemoryDisplSize"} value";
				return;
			}
			if (Displ != 0)
			{
				ErrorMessage = $"Operand {operand}: Displacement must be 0 if displSize == 0";
				return;
			}
		}
		if (memoryIndex == Register.None && (num2 & 7) != 4 && internalMemoryIndexScale == 0 && (EncoderFlags & EncoderFlags.MustUseSib) == 0)
		{
			ModRM |= (byte)(num2 & 7);
		}
		else
		{
			EncoderFlags |= EncoderFlags.Sib;
			Sib = (byte)(internalMemoryIndexScale << 6);
			ModRM |= 4;
			if (memoryIndex == Register.RSP || memoryIndex == Register.ESP)
			{
				ErrorMessage = $"Operand {operand}: ESP/RSP can't be used as an index register";
				return;
			}
			if (num2 < 0)
			{
				Sib |= 5;
			}
			else
			{
				Sib |= (byte)(num2 & 7);
			}
			if (num3 < 0)
			{
				Sib |= 32;
			}
			else
			{
				Sib |= (byte)((num3 & 7) << 3);
			}
		}
		if (num2 >= 0)
		{
			EncoderFlags |= (EncoderFlags)(num2 >> 3);
		}
		if (num3 >= 0)
		{
			EncoderFlags |= (EncoderFlags)((num3 >> 2) & 2);
			EncoderFlags |= (EncoderFlags)((num3 & 0x10) << 27);
		}
	}

	internal void WritePrefixes(in Instruction instruction, bool canWriteF3 = true)
	{
		Register segmentPrefix = instruction.SegmentPrefix;
		if (segmentPrefix != 0)
		{
			WriteByteInternal(SegmentOverrides[(int)(segmentPrefix - 71)]);
		}
		if ((EncoderFlags & EncoderFlags.PF0) != 0 || instruction.HasLockPrefix)
		{
			WriteByteInternal(240u);
		}
		if ((EncoderFlags & EncoderFlags.P66) != 0)
		{
			WriteByteInternal(102u);
		}
		if ((EncoderFlags & EncoderFlags.P67) != 0)
		{
			WriteByteInternal(103u);
		}
		if (canWriteF3 && instruction.HasRepePrefix)
		{
			WriteByteInternal(243u);
		}
		if (instruction.HasRepnePrefix)
		{
			WriteByteInternal(242u);
		}
	}

	private void WriteModRM()
	{
		if ((EncoderFlags & EncoderFlags.ModRM) != 0)
		{
			WriteByteInternal(ModRM);
			if ((EncoderFlags & EncoderFlags.Sib) != 0)
			{
				WriteByteInternal(Sib);
			}
		}
		displAddr = (uint)currentRip;
		switch (DisplSize)
		{
		case DisplSize.Size1:
			WriteByteInternal(Displ);
			break;
		case DisplSize.Size2:
		{
			uint num3 = Displ;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case DisplSize.Size4:
		{
			uint num3 = Displ;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		case DisplSize.Size8:
		{
			uint num3 = Displ;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			num3 = DisplHi;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		case DisplSize.RipRelSize4_Target32:
		{
			uint num4 = (uint)((int)currentRip + 4) + immSizes[(int)ImmSize];
			uint num3 = Displ - num4;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		case DisplSize.RipRelSize4_Target64:
		{
			ulong num = currentRip + 4 + immSizes[(int)ImmSize];
			long num2 = (long)((((ulong)DisplHi << 32) | Displ) - num);
			if (num2 < int.MinValue || num2 > int.MaxValue)
			{
				ErrorMessage = $"RIP relative distance is too far away: NextIP: 0x{num:X16} target: 0x{DisplHi:X8}{Displ:X8}, diff = {num2}, diff must fit in an Int32";
			}
			uint num3 = (uint)num2;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		default:
			throw new InvalidOperationException();
		case DisplSize.None:
			break;
		}
	}

	private void WriteImmediate()
	{
		immAddr = (uint)currentRip;
		switch (ImmSize)
		{
		case ImmSize.Size1:
		case ImmSize.SizeIbReg:
		case ImmSize.Size1OpCode:
			WriteByteInternal(Immediate);
			break;
		case ImmSize.Size2:
		{
			uint num3 = Immediate;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case ImmSize.Size4:
		{
			uint num3 = Immediate;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		case ImmSize.Size8:
		{
			uint num3 = Immediate;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			num3 = ImmediateHi;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		case ImmSize.Size2_1:
		{
			uint num3 = Immediate;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(ImmediateHi);
			break;
		}
		case ImmSize.Size1_1:
			WriteByteInternal(Immediate);
			WriteByteInternal(ImmediateHi);
			break;
		case ImmSize.Size2_2:
		{
			uint num3 = Immediate;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			num3 = ImmediateHi;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case ImmSize.Size4_2:
		{
			uint num3 = Immediate;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			num3 = ImmediateHi;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case ImmSize.RipRelSize1_Target16:
		{
			ushort num6 = (ushort)((int)currentRip + 1);
			short num7 = (short)((short)Immediate - (short)num6);
			if (num7 < -128 || num7 > 127)
			{
				ErrorMessage = $"Branch distance is too far away: NextIP: 0x{num6:X4} target: 0x{(ushort)Immediate:X4}, diff = {num7}, diff must fit in an Int8";
			}
			WriteByteInternal((uint)num7);
			break;
		}
		case ImmSize.RipRelSize1_Target32:
		{
			uint num4 = (uint)((int)currentRip + 1);
			int num5 = (int)(Immediate - num4);
			if (num5 < -128 || num5 > 127)
			{
				ErrorMessage = $"Branch distance is too far away: NextIP: 0x{num4:X8} target: 0x{Immediate:X8}, diff = {num5}, diff must fit in an Int8";
			}
			WriteByteInternal((uint)num5);
			break;
		}
		case ImmSize.RipRelSize1_Target64:
		{
			ulong num = currentRip + 1;
			long num2 = (long)((((ulong)ImmediateHi << 32) | Immediate) - num);
			if (num2 < -128 || num2 > 127)
			{
				ErrorMessage = $"Branch distance is too far away: NextIP: 0x{num:X16} target: 0x{ImmediateHi:X8}{Immediate:X8}, diff = {num2}, diff must fit in an Int8";
			}
			WriteByteInternal((uint)num2);
			break;
		}
		case ImmSize.RipRelSize2_Target16:
		{
			uint num4 = (uint)((int)currentRip + 2);
			uint num3 = Immediate - num4;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case ImmSize.RipRelSize2_Target32:
		{
			uint num4 = (uint)((int)currentRip + 2);
			int num5 = (int)(Immediate - num4);
			if (num5 < -32768 || num5 > 32767)
			{
				ErrorMessage = $"Branch distance is too far away: NextIP: 0x{num4:X8} target: 0x{Immediate:X8}, diff = {num5}, diff must fit in an Int16";
			}
			uint num3 = (uint)num5;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case ImmSize.RipRelSize2_Target64:
		{
			ulong num = currentRip + 2;
			long num2 = (long)((((ulong)ImmediateHi << 32) | Immediate) - num);
			if (num2 < -32768 || num2 > 32767)
			{
				ErrorMessage = $"Branch distance is too far away: NextIP: 0x{num:X16} target: 0x{ImmediateHi:X8}{Immediate:X8}, diff = {num2}, diff must fit in an Int16";
			}
			uint num3 = (uint)num2;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			break;
		}
		case ImmSize.RipRelSize4_Target32:
		{
			uint num4 = (uint)((int)currentRip + 4);
			uint num3 = Immediate - num4;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		case ImmSize.RipRelSize4_Target64:
		{
			ulong num = currentRip + 4;
			long num2 = (long)((((ulong)ImmediateHi << 32) | Immediate) - num);
			if (num2 < int.MinValue || num2 > int.MaxValue)
			{
				ErrorMessage = $"Branch distance is too far away: NextIP: 0x{num:X16} target: 0x{ImmediateHi:X8}{Immediate:X8}, diff = {num2}, diff must fit in an Int32";
			}
			uint num3 = (uint)num2;
			WriteByteInternal(num3);
			WriteByteInternal(num3 >> 8);
			WriteByteInternal(num3 >> 16);
			WriteByteInternal(num3 >> 24);
			break;
		}
		default:
			throw new InvalidOperationException();
		case ImmSize.None:
			break;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void WriteByte(byte value)
	{
		WriteByteInternal(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void WriteByteInternal(uint value)
	{
		writer.WriteByte((byte)value);
		currentRip++;
	}

	public ConstantOffsets GetConstantOffsets()
	{
		ConstantOffsets result = default(ConstantOffsets);
		switch (DisplSize)
		{
		case DisplSize.Size1:
			result.DisplacementSize = 1;
			result.DisplacementOffset = (byte)(displAddr - eip);
			break;
		case DisplSize.Size2:
			result.DisplacementSize = 2;
			result.DisplacementOffset = (byte)(displAddr - eip);
			break;
		case DisplSize.Size4:
		case DisplSize.RipRelSize4_Target32:
		case DisplSize.RipRelSize4_Target64:
			result.DisplacementSize = 4;
			result.DisplacementOffset = (byte)(displAddr - eip);
			break;
		case DisplSize.Size8:
			result.DisplacementSize = 8;
			result.DisplacementOffset = (byte)(displAddr - eip);
			break;
		default:
			throw new InvalidOperationException();
		case DisplSize.None:
			break;
		}
		switch (ImmSize)
		{
		case ImmSize.Size1:
		case ImmSize.RipRelSize1_Target16:
		case ImmSize.RipRelSize1_Target32:
		case ImmSize.RipRelSize1_Target64:
			result.ImmediateSize = 1;
			result.ImmediateOffset = (byte)(immAddr - eip);
			break;
		case ImmSize.Size1_1:
			result.ImmediateSize = 1;
			result.ImmediateOffset = (byte)(immAddr - eip);
			result.ImmediateSize2 = 1;
			result.ImmediateOffset2 = (byte)(immAddr - eip + 1);
			break;
		case ImmSize.Size2:
		case ImmSize.RipRelSize2_Target16:
		case ImmSize.RipRelSize2_Target32:
		case ImmSize.RipRelSize2_Target64:
			result.ImmediateSize = 2;
			result.ImmediateOffset = (byte)(immAddr - eip);
			break;
		case ImmSize.Size2_1:
			result.ImmediateSize = 2;
			result.ImmediateOffset = (byte)(immAddr - eip);
			result.ImmediateSize2 = 1;
			result.ImmediateOffset2 = (byte)(immAddr - eip + 2);
			break;
		case ImmSize.Size2_2:
			result.ImmediateSize = 2;
			result.ImmediateOffset = (byte)(immAddr - eip);
			result.ImmediateSize2 = 2;
			result.ImmediateOffset2 = (byte)(immAddr - eip + 2);
			break;
		case ImmSize.Size4:
		case ImmSize.RipRelSize4_Target32:
		case ImmSize.RipRelSize4_Target64:
			result.ImmediateSize = 4;
			result.ImmediateOffset = (byte)(immAddr - eip);
			break;
		case ImmSize.Size4_2:
			result.ImmediateSize = 4;
			result.ImmediateOffset = (byte)(immAddr - eip);
			result.ImmediateSize2 = 2;
			result.ImmediateOffset2 = (byte)(immAddr - eip + 4);
			break;
		case ImmSize.Size8:
			result.ImmediateSize = 8;
			result.ImmediateOffset = (byte)(immAddr - eip);
			break;
		default:
			throw new InvalidOperationException();
		case ImmSize.None:
		case ImmSize.SizeIbReg:
		case ImmSize.Size1OpCode:
			break;
		}
		return result;
	}
}


using System;
using System.Runtime.Serialization;
using Iced.Intel;

[Serializable]
internal class EncoderException : Exception
{
	public Instruction Instruction { get; }

	public EncoderException(string message, in Instruction instruction)
		: base(message)
	{
		Instruction = instruction;
	}

	protected EncoderException(SerializationInfo info, StreamingContext context)
		: base(info, context)
	{
	}
}


internal enum EncodingKind
{
	Legacy,
	VEX,
	EVEX,
	XOP,
	D3NOW,
	MVEX
}


using System;

internal static class HexUtils
{
	public static byte[] ToByteArray(string hexData)
	{
		if (hexData == null)
		{
			throw new ArgumentNullException("hexData");
		}
		if (hexData.Length == 0)
		{
			return Array2.Empty<byte>();
		}
		int num = 0;
		for (int i = 0; i < hexData.Length; i++)
		{
			if (hexData[i] != ' ')
			{
				num++;
			}
		}
		byte[] array = new byte[num / 2];
		int num2 = 0;
		int j = 0;
		while (true)
		{
			if (j < hexData.Length && char.IsWhiteSpace(hexData[j]))
			{
				j++;
				continue;
			}
			if (j >= hexData.Length)
			{
				break;
			}
			int num3 = TryParseHexChar(hexData[j++]);
			if (num3 < 0)
			{
				throw new ArgumentOutOfRangeException("hexData");
			}
			for (; j < hexData.Length && char.IsWhiteSpace(hexData[j]); j++)
			{
			}
			if (j >= hexData.Length)
			{
				throw new ArgumentOutOfRangeException("hexData");
			}
			int num4 = TryParseHexChar(hexData[j++]);
			if (num4 < 0)
			{
				throw new ArgumentOutOfRangeException("hexData");
			}
			array[num2++] = (byte)((num3 << 4) | num4);
		}
		if (num2 != array.Length)
		{
			throw new InvalidOperationException();
		}
		return array;
	}

	private static int TryParseHexChar(char c)
	{
		if ('0' <= c && c <= '9')
		{
			return c - 48;
		}
		if ('A' <= c && c <= 'F')
		{
			return c - 65 + 10;
		}
		if ('a' <= c && c <= 'f')
		{
			return c - 97 + 10;
		}
		return -1;
	}
}


using System.Runtime.CompilerServices;
using Iced.Intel;

internal static class IcedConstants
{
	internal const int MaxOpCount = 5;

	internal const int MaxInstructionLength = 15;

	internal const int RegisterBits = 8;

	internal const Register VMM_first = Register.ZMM0;

	internal const Register VMM_last = Register.ZMM31;

	internal const int VMM_count = 32;

	internal const Register XMM_last = Register.XMM31;

	internal const Register YMM_last = Register.YMM31;

	internal const Register ZMM_last = Register.ZMM31;

	internal const Register TMM_last = Register.TMM7;

	internal const int MaxCpuidFeatureInternalValues = 183;

	internal const MemorySize FirstBroadcastMemorySize = MemorySize.Broadcast32_Float16;

	internal const uint MvexStart = 4611u;

	internal const uint MvexLength = 207u;

	internal const int CC_a_EnumCount = 2;

	internal const int CC_ae_EnumCount = 3;

	internal const int CC_b_EnumCount = 3;

	internal const int CC_be_EnumCount = 2;

	internal const int CC_e_EnumCount = 2;

	internal const int CC_g_EnumCount = 2;

	internal const int CC_ge_EnumCount = 2;

	internal const int CC_l_EnumCount = 2;

	internal const int CC_le_EnumCount = 2;

	internal const int CC_ne_EnumCount = 2;

	internal const int CC_np_EnumCount = 2;

	internal const int CC_p_EnumCount = 2;

	internal const int CodeEnumCount = 4834;

	internal const int CodeSizeEnumCount = 4;

	internal const int ConditionCodeEnumCount = 17;

	internal const int CpuidFeatureEnumCount = 162;

	internal const int DecoderErrorEnumCount = 3;

	internal const int DecoratorKindEnumCount = 6;

	internal const int EncodingKindEnumCount = 6;

	internal const int FlowControlEnumCount = 10;

	internal const int FormatterSyntaxEnumCount = 4;

	internal const int FormatterTextKindEnumCount = 16;

	internal const int MandatoryPrefixEnumCount = 5;

	internal const int MemorySizeEnumCount = 160;

	internal const int MemorySizeOptionsEnumCount = 4;

	internal const int MnemonicEnumCount = 1838;

	internal const int MvexConvFnEnumCount = 13;

	internal const int MvexEHBitEnumCount = 3;

	internal const int MvexRegMemConvEnumCount = 17;

	internal const int MvexTupleTypeLutKindEnumCount = 14;

	internal const int NumberBaseEnumCount = 4;

	internal const int NumberKindEnumCount = 8;

	internal const int OpAccessEnumCount = 8;

	internal const int OpCodeOperandKindEnumCount = 109;

	internal const int OpCodeTableKindEnumCount = 9;

	internal const int OpKindEnumCount = 25;

	internal const int PrefixKindEnumCount = 18;

	internal const int RegisterEnumCount = 256;

	internal const int RelocKindEnumCount = 1;

	internal const int RepPrefixKindEnumCount = 3;

	internal const int RoundingControlEnumCount = 5;

	internal const int TupleTypeEnumCount = 19;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsMvex(Code code)
	{
		return false;
	}
}


using System.Runtime.CompilerServices;
using Iced.Intel;

internal static class IcedFeatures
{
	public static bool HasGasFormatter => false;

	public static bool HasIntelFormatter => false;

	public static bool HasMasmFormatter => false;

	public static bool HasNasmFormatter => false;

	public static bool HasFastFormatter => false;

	public static bool HasDecoder => true;

	public static bool HasEncoder => true;

	public static bool HasBlockEncoder => true;

	public static bool HasOpCodeInfo => false;

	public static bool HasInstructionInfo => false;

	public static void Initialize()
	{
		RuntimeHelpers.RunClassConstructor(typeof(Decoder).TypeHandle);
	}
}


internal enum RepPrefixKind
{
	None,
	Repe,
	Repne
}


using System;
using System.Runtime.CompilerServices;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal struct Instruction : IEquatable<Instruction>
{
	[Flags]
	private enum InstrFlags1 : uint
	{
		SegmentPrefixMask = 7u,
		SegmentPrefixShift = 5u,
		DataLengthMask = 0xFu,
		DataLengthShift = 8u,
		RoundingControlMask = 7u,
		RoundingControlShift = 0xCu,
		OpMaskMask = 7u,
		OpMaskShift = 0xFu,
		CodeSizeMask = 3u,
		CodeSizeShift = 0x12u,
		Broadcast = 0x4000000u,
		SuppressAllExceptions = 0x8000000u,
		ZeroingMasking = 0x10000000u,
		RepePrefix = 0x20000000u,
		RepnePrefix = 0x40000000u,
		LockPrefix = 0x80000000u,
		EqualsIgnoreMask = 0xC0000u
	}

	[Flags]
	private enum MvexInstrFlags : uint
	{
		MvexRegMemConvShift = 0x10u,
		MvexRegMemConvMask = 0x1Fu,
		EvictionHint = 0x80000000u
	}

	internal const int TOTAL_SIZE = 40;

	private ulong nextRip;

	private ulong memDispl;

	private uint flags1;

	private uint immediate;

	private ushort code;

	private byte memBaseReg;

	private byte memIndexReg;

	private byte reg0;

	private byte reg1;

	private byte reg2;

	private byte reg3;

	private byte opKind0;

	private byte opKind1;

	private byte opKind2;

	private byte opKind3;

	private byte scale;

	private byte displSize;

	private byte len;

	private byte pad;

	public ushort IP16
	{
		readonly get
		{
			return (ushort)((int)nextRip - Length);
		}
		set
		{
			nextRip = (uint)(value + Length);
		}
	}

	public uint IP32
	{
		readonly get
		{
			return (uint)((int)nextRip - Length);
		}
		set
		{
			nextRip = value + (uint)Length;
		}
	}

	public ulong IP
	{
		readonly get
		{
			return nextRip - (uint)Length;
		}
		set
		{
			nextRip = value + (uint)Length;
		}
	}

	public ushort NextIP16
	{
		readonly get
		{
			return (ushort)nextRip;
		}
		set
		{
			nextRip = value;
		}
	}

	public uint NextIP32
	{
		readonly get
		{
			return (uint)nextRip;
		}
		set
		{
			nextRip = value;
		}
	}

	public ulong NextIP
	{
		readonly get
		{
			return nextRip;
		}
		set
		{
			nextRip = value;
		}
	}

	public CodeSize CodeSize
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (CodeSize)((flags1 >> 18) & 3);
		}
		set
		{
			flags1 = (flags1 & 0xFFF3FFFFu) | (uint)((int)(value & CodeSize.Code64) << 18);
		}
	}

	internal CodeSize InternalCodeSize
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			flags1 |= (uint)((int)value << 18);
		}
	}

	public readonly bool IsInvalid
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return code == 0;
		}
	}

	public Code Code
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (Code)code;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			if ((uint)value >= 4834u)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_value();
			}
			code = (ushort)value;
		}
	}

	public readonly Mnemonic Mnemonic
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return Code.Mnemonic();
		}
	}

	public readonly int OpCount
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return InstructionOpCounts.OpCount[code];
		}
	}

	public int Length
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return len;
		}
		set
		{
			len = (byte)value;
		}
	}

	internal readonly bool Internal_HasRepeOrRepnePrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return (flags1 & 0x60000000) != 0;
		}
	}

	internal readonly uint HasAnyOf_Lock_Rep_Repne_Prefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return flags1 & 0xE0000000u;
		}
	}

	public bool HasXacquirePrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			if ((flags1 & 0x40000000) != 0)
			{
				return IsXacquireInstr();
			}
			return false;
		}
		set
		{
			if (value)
			{
				flags1 |= 1073741824u;
			}
			else
			{
				flags1 &= 3221225471u;
			}
		}
	}

	public bool HasXreleasePrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			if ((flags1 & 0x20000000) != 0)
			{
				return IsXreleaseInstr();
			}
			return false;
		}
		set
		{
			if (value)
			{
				flags1 |= 536870912u;
			}
			else
			{
				flags1 &= 3758096383u;
			}
		}
	}

	public bool HasRepPrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x20000000) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 536870912u;
			}
			else
			{
				flags1 &= 3758096383u;
			}
		}
	}

	public bool HasRepePrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x20000000) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 536870912u;
			}
			else
			{
				flags1 &= 3758096383u;
			}
		}
	}

	public bool HasRepnePrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x40000000) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 1073741824u;
			}
			else
			{
				flags1 &= 3221225471u;
			}
		}
	}

	public bool HasLockPrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x80000000u) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 2147483648u;
			}
			else
			{
				flags1 &= 2147483647u;
			}
		}
	}

	public OpKind Op0Kind
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (OpKind)opKind0;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			opKind0 = (byte)value;
		}
	}

	internal readonly bool Internal_Op0IsNotReg_or_Op1IsNotReg
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return (opKind0 | opKind1) != 0;
		}
	}

	public OpKind Op1Kind
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (OpKind)opKind1;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			opKind1 = (byte)value;
		}
	}

	public OpKind Op2Kind
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (OpKind)opKind2;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			opKind2 = (byte)value;
		}
	}

	public OpKind Op3Kind
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (OpKind)opKind3;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			opKind3 = (byte)value;
		}
	}

	public OpKind Op4Kind
	{
		readonly get
		{
			return OpKind.Immediate8;
		}
		set
		{
			if (value != OpKind.Immediate8)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_value();
			}
		}
	}

	public readonly bool HasSegmentPrefix
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ((flags1 >> 5) & 7) - 1 < 6;
		}
	}

	public Register SegmentPrefix
	{
		readonly get
		{
			uint num = ((flags1 >> 5) & 7) - 1;
			if (num >= 6)
			{
				return Register.None;
			}
			return (Register)(71 + num);
		}
		set
		{
			uint num = (uint)((value != 0) ? ((value - 71 + 1) & Register.DH) : Register.None);
			flags1 = (flags1 & 0xFFFFFF1Fu) | (num << 5);
		}
	}

	public readonly Register MemorySegment
	{
		get
		{
			Register segmentPrefix = SegmentPrefix;
			if (segmentPrefix != 0)
			{
				return segmentPrefix;
			}
			Register memoryBase = MemoryBase;
			if (memoryBase == Register.BP || memoryBase == Register.EBP || memoryBase == Register.ESP || memoryBase == Register.RBP || memoryBase == Register.RSP)
			{
				return Register.SS;
			}
			return Register.DS;
		}
	}

	public int MemoryDisplSize
	{
		readonly get
		{
			return displSize switch
			{
				0 => 0, 
				1 => 1, 
				2 => 2, 
				3 => 4, 
				_ => 8, 
			};
		}
		set
		{
			displSize = value switch
			{
				0 => 0, 
				1 => 1, 
				2 => 2, 
				4 => 3, 
				_ => 4, 
			};
		}
	}

	public bool IsBroadcast
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x4000000) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 67108864u;
			}
			else
			{
				flags1 &= 4227858431u;
			}
		}
	}

	public readonly MemorySize MemorySize
	{
		get
		{
			int index = (int)Code;
			if (IsBroadcast)
			{
				return (MemorySize)InstructionMemorySizes.SizesBcst[index];
			}
			return (MemorySize)InstructionMemorySizes.SizesNormal[index];
		}
	}

	public int MemoryIndexScale
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return 1 << (int)scale;
		}
		set
		{
			switch (value)
			{
			case 1:
				scale = 0;
				break;
			case 2:
				scale = 1;
				break;
			case 4:
				scale = 2;
				break;
			default:
				scale = 3;
				break;
			}
		}
	}

	internal int InternalMemoryIndexScale
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return scale;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			scale = (byte)value;
		}
	}

	public uint MemoryDisplacement32
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (uint)memDispl;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			memDispl = value;
		}
	}

	public ulong MemoryDisplacement64
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return memDispl;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			memDispl = value;
		}
	}

	public byte Immediate8
	{
		readonly get
		{
			return (byte)immediate;
		}
		set
		{
			immediate = value;
		}
	}

	internal uint InternalImmediate8
	{
		set
		{
			immediate = value;
		}
	}

	public byte Immediate8_2nd
	{
		readonly get
		{
			return (byte)memDispl;
		}
		set
		{
			memDispl = value;
		}
	}

	internal uint InternalImmediate8_2nd
	{
		set
		{
			memDispl = value;
		}
	}

	public ushort Immediate16
	{
		readonly get
		{
			return (ushort)immediate;
		}
		set
		{
			immediate = value;
		}
	}

	internal uint InternalImmediate16
	{
		set
		{
			immediate = value;
		}
	}

	public uint Immediate32
	{
		readonly get
		{
			return immediate;
		}
		set
		{
			immediate = value;
		}
	}

	public ulong Immediate64
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (memDispl << 32) | immediate;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			immediate = (uint)value;
			memDispl = (uint)(value >> 32);
		}
	}

	internal uint InternalImmediate64_lo
	{
		set
		{
			immediate = value;
		}
	}

	internal uint InternalImmediate64_hi
	{
		set
		{
			memDispl = value;
		}
	}

	public short Immediate8to16
	{
		readonly get
		{
			return (sbyte)immediate;
		}
		set
		{
			immediate = (uint)(sbyte)value;
		}
	}

	public int Immediate8to32
	{
		readonly get
		{
			return (sbyte)immediate;
		}
		set
		{
			immediate = (uint)(sbyte)value;
		}
	}

	public long Immediate8to64
	{
		readonly get
		{
			return (sbyte)immediate;
		}
		set
		{
			immediate = (uint)(sbyte)value;
		}
	}

	public long Immediate32to64
	{
		readonly get
		{
			return (int)immediate;
		}
		set
		{
			immediate = (uint)value;
		}
	}

	public ushort NearBranch16
	{
		readonly get
		{
			return (ushort)memDispl;
		}
		set
		{
			memDispl = value;
		}
	}

	internal uint InternalNearBranch16
	{
		set
		{
			memDispl = value;
		}
	}

	public uint NearBranch32
	{
		readonly get
		{
			return (uint)memDispl;
		}
		set
		{
			memDispl = value;
		}
	}

	public ulong NearBranch64
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return memDispl;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			memDispl = value;
		}
	}

	public readonly ulong NearBranchTarget => Op0Kind switch
	{
		OpKind.NearBranch16 => NearBranch16, 
		OpKind.NearBranch32 => NearBranch32, 
		OpKind.NearBranch64 => NearBranch64, 
		_ => 0uL, 
	};

	public ushort FarBranch16
	{
		readonly get
		{
			return (ushort)immediate;
		}
		set
		{
			immediate = value;
		}
	}

	internal uint InternalFarBranch16
	{
		set
		{
			immediate = value;
		}
	}

	public uint FarBranch32
	{
		readonly get
		{
			return immediate;
		}
		set
		{
			immediate = value;
		}
	}

	public ushort FarBranchSelector
	{
		readonly get
		{
			return (ushort)memDispl;
		}
		set
		{
			memDispl = value;
		}
	}

	internal uint InternalFarBranchSelector
	{
		set
		{
			memDispl = value;
		}
	}

	public Register MemoryBase
	{
		readonly get
		{
			return (Register)memBaseReg;
		}
		set
		{
			memBaseReg = (byte)value;
		}
	}

	internal Register InternalMemoryBase
	{
		set
		{
			memBaseReg = (byte)value;
		}
	}

	public Register MemoryIndex
	{
		readonly get
		{
			return (Register)memIndexReg;
		}
		set
		{
			memIndexReg = (byte)value;
		}
	}

	internal Register InternalMemoryIndex
	{
		set
		{
			memIndexReg = (byte)value;
		}
	}

	public Register Op0Register
	{
		readonly get
		{
			return (Register)reg0;
		}
		set
		{
			reg0 = (byte)value;
		}
	}

	internal Register InternalOp0Register
	{
		set
		{
			reg0 = (byte)value;
		}
	}

	public Register Op1Register
	{
		readonly get
		{
			return (Register)reg1;
		}
		set
		{
			reg1 = (byte)value;
		}
	}

	internal Register InternalOp1Register
	{
		set
		{
			reg1 = (byte)value;
		}
	}

	public Register Op2Register
	{
		readonly get
		{
			return (Register)reg2;
		}
		set
		{
			reg2 = (byte)value;
		}
	}

	internal Register InternalOp2Register
	{
		set
		{
			reg2 = (byte)value;
		}
	}

	public Register Op3Register
	{
		readonly get
		{
			return (Register)reg3;
		}
		set
		{
			reg3 = (byte)value;
		}
	}

	internal Register InternalOp3Register
	{
		set
		{
			reg3 = (byte)value;
		}
	}

	public Register Op4Register
	{
		readonly get
		{
			return Register.None;
		}
		set
		{
			if (value != 0)
			{
				ThrowHelper.ThrowArgumentOutOfRangeException_value();
			}
		}
	}

	public Register OpMask
	{
		readonly get
		{
			int num = (int)((flags1 >> 15) & 7);
			if (num != 0)
			{
				return (Register)(num + 173);
			}
			return Register.None;
		}
		set
		{
			uint num = (uint)((value != 0) ? ((value - 173) & Register.DH) : Register.None);
			flags1 = (flags1 & 0xFFFC7FFFu) | (num << 15);
		}
	}

	internal uint InternalOpMask
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 >> 15) & 7;
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			flags1 |= value << 15;
		}
	}

	public readonly bool HasOpMask
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return (flags1 & 0x38000) != 0;
		}
	}

	internal readonly bool HasOpMask_or_ZeroingMasking
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return (flags1 & 0x10038000) != 0;
		}
	}

	public bool ZeroingMasking
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x10000000) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 268435456u;
			}
			else
			{
				flags1 &= 4026531839u;
			}
		}
	}

	public bool MergingMasking
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x10000000) == 0;
		}
		set
		{
			if (value)
			{
				flags1 &= 4026531839u;
			}
			else
			{
				flags1 |= 268435456u;
			}
		}
	}

	public RoundingControl RoundingControl
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (RoundingControl)((flags1 >> 12) & 7);
		}
		set
		{
			flags1 = (flags1 & 0xFFFF8FFFu) | (uint)((int)value << 12);
		}
	}

	internal uint InternalRoundingControl
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			flags1 |= value << 12;
		}
	}

	internal readonly bool HasRoundingControlOrSae
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return (flags1 & 0x8007000) != 0;
		}
	}

	public int DeclareDataCount
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (int)(((flags1 >> 8) & 0xF) + 1);
		}
		set
		{
			flags1 = (flags1 & 0xFFFFF0FFu) | (uint)(((value - 1) & 0xF) << 8);
		}
	}

	internal uint InternalDeclareDataCount
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			flags1 |= value - 1 << 8;
		}
	}

	public readonly bool IsVsib
	{
		get
		{
			bool vsib;
			return TryGetVsib64(out vsib);
		}
	}

	public readonly bool IsVsib32
	{
		get
		{
			if (TryGetVsib64(out var vsib))
			{
				return !vsib;
			}
			return false;
		}
	}

	public readonly bool IsVsib64
	{
		get
		{
			bool vsib;
			return TryGetVsib64(out vsib) && vsib;
		}
	}

	public bool SuppressAllExceptions
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		readonly get
		{
			return (flags1 & 0x8000000) != 0;
		}
		set
		{
			if (value)
			{
				flags1 |= 134217728u;
			}
			else
			{
				flags1 &= 4160749567u;
			}
		}
	}

	public readonly bool IsIPRelativeMemoryOperand
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if (MemoryBase != Register.RIP)
			{
				return MemoryBase == Register.EIP;
			}
			return true;
		}
	}

	public readonly ulong IPRelativeMemoryAddress
	{
		get
		{
			if (MemoryBase != Register.EIP)
			{
				return MemoryDisplacement64;
			}
			return MemoryDisplacement32;
		}
	}

	private static void InitializeSignedImmediate(ref Instruction instruction, int operand, long immediate)
	{
		OpKind immediateOpKind = GetImmediateOpKind(instruction.Code, operand);
		instruction.SetOpKind(operand, immediateOpKind);
		switch (immediateOpKind)
		{
		case OpKind.Immediate8:
			if (-128 > immediate || immediate > 255)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate8_2nd:
			if (-128 > immediate || immediate > 255)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8_2nd = (byte)immediate;
			break;
		case OpKind.Immediate8to16:
			if (-128 > immediate || immediate > 127)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate8to32:
			if (-128 > immediate || immediate > 127)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate8to64:
			if (-128 > immediate || immediate > 127)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate16:
			if (-32768 > immediate || immediate > 65535)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate16 = (ushort)immediate;
			break;
		case OpKind.Immediate32:
			if (int.MinValue > immediate || immediate > uint.MaxValue)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.Immediate32 = (uint)immediate;
			break;
		case OpKind.Immediate32to64:
			if (int.MinValue > immediate || immediate > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.Immediate32 = (uint)immediate;
			break;
		case OpKind.Immediate64:
			instruction.Immediate64 = (ulong)immediate;
			break;
		default:
			throw new ArgumentOutOfRangeException("instruction");
		}
	}

	private static void InitializeUnsignedImmediate(ref Instruction instruction, int operand, ulong immediate)
	{
		OpKind immediateOpKind = GetImmediateOpKind(instruction.Code, operand);
		instruction.SetOpKind(operand, immediateOpKind);
		switch (immediateOpKind)
		{
		case OpKind.Immediate8:
			if (immediate > 255)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate8_2nd:
			if (immediate > 255)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8_2nd = (byte)immediate;
			break;
		case OpKind.Immediate8to16:
			if (immediate > 127 && (65408 > immediate || immediate > 65535))
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate8to32:
			if (immediate > 127 && (4294967168u > immediate || immediate > uint.MaxValue))
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate8to64:
			if (immediate + 128 > 255)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate8 = (byte)immediate;
			break;
		case OpKind.Immediate16:
			if (immediate > 65535)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.InternalImmediate16 = (ushort)immediate;
			break;
		case OpKind.Immediate32:
			if (immediate > uint.MaxValue)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.Immediate32 = (uint)immediate;
			break;
		case OpKind.Immediate32to64:
			if (immediate + 2147483648u > uint.MaxValue)
			{
				throw new ArgumentOutOfRangeException("immediate");
			}
			instruction.Immediate32 = (uint)immediate;
			break;
		case OpKind.Immediate64:
			instruction.Immediate64 = immediate;
			break;
		default:
			throw new ArgumentOutOfRangeException("instruction");
		}
	}

	private static OpKind GetImmediateOpKind(Code code, int operand)
	{
		OpCodeHandler[] handlers = OpCodeHandlers.Handlers;
		if ((uint)code >= (uint)handlers.Length)
		{
			throw new ArgumentOutOfRangeException("code");
		}
		Op[] operands = handlers[(int)code].Operands;
		if ((uint)operand >= (uint)operands.Length)
		{
			throw new ArgumentOutOfRangeException("operand", $"{code} doesn't have at least {operand + 1} operands");
		}
		OpKind opKind = operands[operand].GetImmediateOpKind();
		if (opKind == OpKind.Immediate8 && operand > 0 && operand + 1 == operands.Length)
		{
			OpKind immediateOpKind = operands[operand - 1].GetImmediateOpKind();
			if (immediateOpKind == OpKind.Immediate8 || immediateOpKind == OpKind.Immediate16)
			{
				opKind = OpKind.Immediate8_2nd;
			}
		}
		if (opKind == (OpKind)(-1))
		{
			throw new ArgumentException($"{code}'s op{operand} isn't an immediate operand");
		}
		return opKind;
	}

	private static OpKind GetNearBranchOpKind(Code code, int operand)
	{
		OpCodeHandler[] handlers = OpCodeHandlers.Handlers;
		if ((uint)code >= (uint)handlers.Length)
		{
			throw new ArgumentOutOfRangeException("code");
		}
		Op[] operands = handlers[(int)code].Operands;
		if ((uint)operand >= (uint)operands.Length)
		{
			throw new ArgumentOutOfRangeException("operand", $"{code} doesn't have at least {operand + 1} operands");
		}
		OpKind nearBranchOpKind = operands[operand].GetNearBranchOpKind();
		if (nearBranchOpKind == (OpKind)(-1))
		{
			throw new ArgumentException($"{code}'s op{operand} isn't a near branch operand");
		}
		return nearBranchOpKind;
	}

	private static OpKind GetFarBranchOpKind(Code code, int operand)
	{
		OpCodeHandler[] handlers = OpCodeHandlers.Handlers;
		if ((uint)code >= (uint)handlers.Length)
		{
			throw new ArgumentOutOfRangeException("code");
		}
		Op[] operands = handlers[(int)code].Operands;
		if ((uint)operand >= (uint)operands.Length)
		{
			throw new ArgumentOutOfRangeException("operand", $"{code} doesn't have at least {operand + 1} operands");
		}
		OpKind farBranchOpKind = operands[operand].GetFarBranchOpKind();
		if (farBranchOpKind == (OpKind)(-1))
		{
			throw new ArgumentException($"{code}'s op{operand} isn't a far branch operand");
		}
		return farBranchOpKind;
	}

	private static Instruction CreateString_Reg_SegRSI(Code code, int addressSize, Register register, Register segmentPrefix, RepPrefixKind repPrefix)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		switch (repPrefix)
		{
		case RepPrefixKind.Repe:
			result.InternalSetHasRepePrefix();
			break;
		case RepPrefixKind.Repne:
			result.InternalSetHasRepnePrefix();
			break;
		}
		result.Op0Register = register;
		switch (addressSize)
		{
		case 64:
			result.Op1Kind = OpKind.MemorySegRSI;
			break;
		case 32:
			result.Op1Kind = OpKind.MemorySegESI;
			break;
		case 16:
			result.Op1Kind = OpKind.MemorySegSI;
			break;
		default:
			throw new ArgumentOutOfRangeException("addressSize");
		}
		result.SegmentPrefix = segmentPrefix;
		return result;
	}

	private static Instruction CreateString_Reg_ESRDI(Code code, int addressSize, Register register, RepPrefixKind repPrefix)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		switch (repPrefix)
		{
		case RepPrefixKind.Repe:
			result.InternalSetHasRepePrefix();
			break;
		case RepPrefixKind.Repne:
			result.InternalSetHasRepnePrefix();
			break;
		}
		result.Op0Register = register;
		switch (addressSize)
		{
		case 64:
			result.Op1Kind = OpKind.MemoryESRDI;
			break;
		case 32:
			result.Op1Kind = OpKind.MemoryESEDI;
			break;
		case 16:
			result.Op1Kind = OpKind.MemoryESDI;
			break;
		default:
			throw new ArgumentOutOfRangeException("addressSize");
		}
		return result;
	}

	private static Instruction CreateString_ESRDI_Reg(Code code, int addressSize, Register register, RepPrefixKind repPrefix)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		switch (repPrefix)
		{
		case RepPrefixKind.Repe:
			result.InternalSetHasRepePrefix();
			break;
		case RepPrefixKind.Repne:
			result.InternalSetHasRepnePrefix();
			break;
		}
		switch (addressSize)
		{
		case 64:
			result.Op0Kind = OpKind.MemoryESRDI;
			break;
		case 32:
			result.Op0Kind = OpKind.MemoryESEDI;
			break;
		case 16:
			result.Op0Kind = OpKind.MemoryESDI;
			break;
		default:
			throw new ArgumentOutOfRangeException("addressSize");
		}
		result.Op1Register = register;
		return result;
	}

	private static Instruction CreateString_SegRSI_ESRDI(Code code, int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		switch (repPrefix)
		{
		case RepPrefixKind.Repe:
			result.InternalSetHasRepePrefix();
			break;
		case RepPrefixKind.Repne:
			result.InternalSetHasRepnePrefix();
			break;
		}
		switch (addressSize)
		{
		case 64:
			result.Op0Kind = OpKind.MemorySegRSI;
			result.Op1Kind = OpKind.MemoryESRDI;
			break;
		case 32:
			result.Op0Kind = OpKind.MemorySegESI;
			result.Op1Kind = OpKind.MemoryESEDI;
			break;
		case 16:
			result.Op0Kind = OpKind.MemorySegSI;
			result.Op1Kind = OpKind.MemoryESDI;
			break;
		default:
			throw new ArgumentOutOfRangeException("addressSize");
		}
		result.SegmentPrefix = segmentPrefix;
		return result;
	}

	private static Instruction CreateString_ESRDI_SegRSI(Code code, int addressSize, Register segmentPrefix, RepPrefixKind repPrefix)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		switch (repPrefix)
		{
		case RepPrefixKind.Repe:
			result.InternalSetHasRepePrefix();
			break;
		case RepPrefixKind.Repne:
			result.InternalSetHasRepnePrefix();
			break;
		}
		switch (addressSize)
		{
		case 64:
			result.Op0Kind = OpKind.MemoryESRDI;
			result.Op1Kind = OpKind.MemorySegRSI;
			break;
		case 32:
			result.Op0Kind = OpKind.MemoryESEDI;
			result.Op1Kind = OpKind.MemorySegESI;
			break;
		case 16:
			result.Op0Kind = OpKind.MemoryESDI;
			result.Op1Kind = OpKind.MemorySegSI;
			break;
		default:
			throw new ArgumentOutOfRangeException("addressSize");
		}
		result.SegmentPrefix = segmentPrefix;
		return result;
	}

	private static Instruction CreateMaskmov(Code code, int addressSize, Register register1, Register register2, Register segmentPrefix)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		switch (addressSize)
		{
		case 64:
			result.Op0Kind = OpKind.MemorySegRDI;
			break;
		case 32:
			result.Op0Kind = OpKind.MemorySegEDI;
			break;
		case 16:
			result.Op0Kind = OpKind.MemorySegDI;
			break;
		default:
			throw new ArgumentOutOfRangeException("addressSize");
		}
		result.Op1Register = register1;
		result.Op2Register = register2;
		result.SegmentPrefix = segmentPrefix;
		return result;
	}

	private static void InitMemoryOperand(ref Instruction instruction, in MemoryOperand memory)
	{
		instruction.InternalMemoryBase = memory.Base;
		instruction.InternalMemoryIndex = memory.Index;
		instruction.MemoryIndexScale = memory.Scale;
		instruction.MemoryDisplSize = memory.DisplSize;
		instruction.MemoryDisplacement64 = (ulong)memory.Displacement;
		instruction.IsBroadcast = memory.IsBroadcast;
		instruction.SegmentPrefix = memory.SegmentPrefix;
	}

	public static Instruction Create(Code code)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		return result;
	}

	public static Instruction Create(Code code, Register register)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		result.Op0Register = register;
		return result;
	}

	public static Instruction Create(Code code, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		InitializeSignedImmediate(ref instruction, 0, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		InitializeUnsignedImmediate(ref instruction, 0, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		result.Op0Register = register1;
		result.Op1Register = register2;
		return result;
	}

	public static Instruction Create(Code code, Register register, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		InitializeSignedImmediate(ref instruction, 1, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		InitializeUnsignedImmediate(ref instruction, 1, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, long immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		InitializeSignedImmediate(ref instruction, 1, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, ulong immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		InitializeUnsignedImmediate(ref instruction, 1, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, in MemoryOperand memory)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		instruction.Op1Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		return instruction;
	}

	public static Instruction Create(Code code, int immediate, Register register)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		InitializeSignedImmediate(ref instruction, 0, immediate);
		instruction.Op1Register = register;
		return instruction;
	}

	public static Instruction Create(Code code, uint immediate, Register register)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		InitializeUnsignedImmediate(ref instruction, 0, immediate);
		instruction.Op1Register = register;
		return instruction;
	}

	public static Instruction Create(Code code, int immediate1, int immediate2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		InitializeSignedImmediate(ref instruction, 0, immediate1);
		InitializeSignedImmediate(ref instruction, 1, immediate2);
		return instruction;
	}

	public static Instruction Create(Code code, uint immediate1, uint immediate2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		InitializeUnsignedImmediate(ref instruction, 0, immediate1);
		InitializeUnsignedImmediate(ref instruction, 1, immediate2);
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory, Register register)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op1Register = register;
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeSignedImmediate(ref instruction, 1, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeUnsignedImmediate(ref instruction, 1, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		result.Op0Register = register1;
		result.Op1Register = register2;
		result.Op2Register = register3;
		return result;
	}

	public static Instruction Create(Code code, Register register1, Register register2, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		InitializeSignedImmediate(ref instruction, 2, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		InitializeUnsignedImmediate(ref instruction, 2, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, in MemoryOperand memory)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, int immediate1, int immediate2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		InitializeSignedImmediate(ref instruction, 1, immediate1);
		InitializeSignedImmediate(ref instruction, 2, immediate2);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, uint immediate1, uint immediate2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		InitializeUnsignedImmediate(ref instruction, 1, immediate1);
		InitializeUnsignedImmediate(ref instruction, 2, immediate2);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, in MemoryOperand memory, Register register2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op2Register = register2;
		return instruction;
	}

	public static Instruction Create(Code code, Register register, in MemoryOperand memory, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		instruction.Op1Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeSignedImmediate(ref instruction, 2, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register, in MemoryOperand memory, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register;
		instruction.Op1Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeUnsignedImmediate(ref instruction, 2, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory, Register register1, Register register2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op1Register = register1;
		instruction.Op2Register = register2;
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory, Register register, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op1Register = register;
		InitializeSignedImmediate(ref instruction, 2, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, in MemoryOperand memory, Register register, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op1Register = register;
		InitializeUnsignedImmediate(ref instruction, 2, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		result.Op0Register = register1;
		result.Op1Register = register2;
		result.Op2Register = register3;
		result.Op3Register = register4;
		return result;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		InitializeSignedImmediate(ref instruction, 3, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		InitializeUnsignedImmediate(ref instruction, 3, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, in MemoryOperand memory)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		instruction.Op3Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, int immediate1, int immediate2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		InitializeSignedImmediate(ref instruction, 2, immediate1);
		InitializeSignedImmediate(ref instruction, 3, immediate2);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, uint immediate1, uint immediate2)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		InitializeUnsignedImmediate(ref instruction, 2, immediate1);
		InitializeUnsignedImmediate(ref instruction, 3, immediate2);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, in MemoryOperand memory, Register register3)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op3Register = register3;
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, in MemoryOperand memory, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeSignedImmediate(ref instruction, 3, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, in MemoryOperand memory, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeUnsignedImmediate(ref instruction, 3, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		instruction.Op3Register = register4;
		InitializeSignedImmediate(ref instruction, 4, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, Register register4, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		instruction.Op3Register = register4;
		InitializeUnsignedImmediate(ref instruction, 4, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, in MemoryOperand memory, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		instruction.Op3Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeSignedImmediate(ref instruction, 4, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, Register register3, in MemoryOperand memory, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Register = register3;
		instruction.Op3Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		InitializeUnsignedImmediate(ref instruction, 4, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, in MemoryOperand memory, Register register3, int immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op3Register = register3;
		InitializeSignedImmediate(ref instruction, 4, immediate);
		return instruction;
	}

	public static Instruction Create(Code code, Register register1, Register register2, in MemoryOperand memory, Register register3, uint immediate)
	{
		Instruction instruction = default(Instruction);
		instruction.Code = code;
		instruction.Op0Register = register1;
		instruction.Op1Register = register2;
		instruction.Op2Kind = OpKind.Memory;
		InitMemoryOperand(ref instruction, in memory);
		instruction.Op3Register = register3;
		InitializeUnsignedImmediate(ref instruction, 4, immediate);
		return instruction;
	}

	public static Instruction CreateBranch(Code code, ulong target)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		result.Op0Kind = GetNearBranchOpKind(code, 0);
		result.NearBranch64 = target;
		return result;
	}

	public static Instruction CreateBranch(Code code, ushort selector, uint offset)
	{
		Instruction result = default(Instruction);
		result.Code = code;
		result.Op0Kind = GetFarBranchOpKind(code, 0);
		result.FarBranchSelector = selector;
		result.FarBranch32 = offset;
		return result;
	}

	public static Instruction CreateXbegin(int bitness, ulong target)
	{
		Instruction result = default(Instruction);
		switch (bitness)
		{
		case 16:
			result.Code = Code.Xbegin_rel16;
			result.Op0Kind = OpKind.NearBranch32;
			result.NearBranch32 = (uint)target;
			break;
		case 32:
			result.Code = Code.Xbegin_rel32;
			result.Op0Kind = OpKind.NearBranch32;
			result.NearBranch32 = (uint)target;
			break;
		case 64:
			result.Code = Code.Xbegin_rel32;
			result.Op0Kind = OpKind.NearBranch64;
			result.NearBranch64 = target;
			break;
		default:
			throw new ArgumentOutOfRangeException("bitness");
		}
		return result;
	}

	public static Instruction CreateOutsb(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Outsb_DX_m8, addressSize, Register.DX, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepOutsb(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Outsb_DX_m8, addressSize, Register.DX, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateOutsw(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Outsw_DX_m16, addressSize, Register.DX, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepOutsw(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Outsw_DX_m16, addressSize, Register.DX, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateOutsd(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Outsd_DX_m32, addressSize, Register.DX, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepOutsd(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Outsd_DX_m32, addressSize, Register.DX, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateLodsb(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Lodsb_AL_m8, addressSize, Register.AL, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepLodsb(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Lodsb_AL_m8, addressSize, Register.AL, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateLodsw(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Lodsw_AX_m16, addressSize, Register.AX, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepLodsw(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Lodsw_AX_m16, addressSize, Register.AX, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateLodsd(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Lodsd_EAX_m32, addressSize, Register.EAX, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepLodsd(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Lodsd_EAX_m32, addressSize, Register.EAX, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateLodsq(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_SegRSI(Code.Lodsq_RAX_m64, addressSize, Register.RAX, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepLodsq(int addressSize)
	{
		return CreateString_Reg_SegRSI(Code.Lodsq_RAX_m64, addressSize, Register.RAX, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateScasb(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_ESRDI(Code.Scasb_AL_m8, addressSize, Register.AL, repPrefix);
	}

	public static Instruction CreateRepeScasb(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasb_AL_m8, addressSize, Register.AL, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneScasb(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasb_AL_m8, addressSize, Register.AL, RepPrefixKind.Repne);
	}

	public static Instruction CreateScasw(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_ESRDI(Code.Scasw_AX_m16, addressSize, Register.AX, repPrefix);
	}

	public static Instruction CreateRepeScasw(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasw_AX_m16, addressSize, Register.AX, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneScasw(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasw_AX_m16, addressSize, Register.AX, RepPrefixKind.Repne);
	}

	public static Instruction CreateScasd(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_ESRDI(Code.Scasd_EAX_m32, addressSize, Register.EAX, repPrefix);
	}

	public static Instruction CreateRepeScasd(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasd_EAX_m32, addressSize, Register.EAX, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneScasd(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasd_EAX_m32, addressSize, Register.EAX, RepPrefixKind.Repne);
	}

	public static Instruction CreateScasq(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_Reg_ESRDI(Code.Scasq_RAX_m64, addressSize, Register.RAX, repPrefix);
	}

	public static Instruction CreateRepeScasq(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasq_RAX_m64, addressSize, Register.RAX, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneScasq(int addressSize)
	{
		return CreateString_Reg_ESRDI(Code.Scasq_RAX_m64, addressSize, Register.RAX, RepPrefixKind.Repne);
	}

	public static Instruction CreateInsb(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Insb_m8_DX, addressSize, Register.DX, repPrefix);
	}

	public static Instruction CreateRepInsb(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Insb_m8_DX, addressSize, Register.DX, RepPrefixKind.Repe);
	}

	public static Instruction CreateInsw(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Insw_m16_DX, addressSize, Register.DX, repPrefix);
	}

	public static Instruction CreateRepInsw(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Insw_m16_DX, addressSize, Register.DX, RepPrefixKind.Repe);
	}

	public static Instruction CreateInsd(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Insd_m32_DX, addressSize, Register.DX, repPrefix);
	}

	public static Instruction CreateRepInsd(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Insd_m32_DX, addressSize, Register.DX, RepPrefixKind.Repe);
	}

	public static Instruction CreateStosb(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Stosb_m8_AL, addressSize, Register.AL, repPrefix);
	}

	public static Instruction CreateRepStosb(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Stosb_m8_AL, addressSize, Register.AL, RepPrefixKind.Repe);
	}

	public static Instruction CreateStosw(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Stosw_m16_AX, addressSize, Register.AX, repPrefix);
	}

	public static Instruction CreateRepStosw(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Stosw_m16_AX, addressSize, Register.AX, RepPrefixKind.Repe);
	}

	public static Instruction CreateStosd(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Stosd_m32_EAX, addressSize, Register.EAX, repPrefix);
	}

	public static Instruction CreateRepStosd(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Stosd_m32_EAX, addressSize, Register.EAX, RepPrefixKind.Repe);
	}

	public static Instruction CreateStosq(int addressSize, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_Reg(Code.Stosq_m64_RAX, addressSize, Register.RAX, repPrefix);
	}

	public static Instruction CreateRepStosq(int addressSize)
	{
		return CreateString_ESRDI_Reg(Code.Stosq_m64_RAX, addressSize, Register.RAX, RepPrefixKind.Repe);
	}

	public static Instruction CreateCmpsb(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsb_m8_m8, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepeCmpsb(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsb_m8_m8, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneCmpsb(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsb_m8_m8, addressSize, Register.None, RepPrefixKind.Repne);
	}

	public static Instruction CreateCmpsw(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsw_m16_m16, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepeCmpsw(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsw_m16_m16, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneCmpsw(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsw_m16_m16, addressSize, Register.None, RepPrefixKind.Repne);
	}

	public static Instruction CreateCmpsd(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsd_m32_m32, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepeCmpsd(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsd_m32_m32, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneCmpsd(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsd_m32_m32, addressSize, Register.None, RepPrefixKind.Repne);
	}

	public static Instruction CreateCmpsq(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsq_m64_m64, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepeCmpsq(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsq_m64_m64, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateRepneCmpsq(int addressSize)
	{
		return CreateString_SegRSI_ESRDI(Code.Cmpsq_m64_m64, addressSize, Register.None, RepPrefixKind.Repne);
	}

	public static Instruction CreateMovsb(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsb_m8_m8, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepMovsb(int addressSize)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsb_m8_m8, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateMovsw(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsw_m16_m16, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepMovsw(int addressSize)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsw_m16_m16, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateMovsd(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsd_m32_m32, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepMovsd(int addressSize)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsd_m32_m32, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateMovsq(int addressSize, Register segmentPrefix = Register.None, RepPrefixKind repPrefix = RepPrefixKind.None)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsq_m64_m64, addressSize, segmentPrefix, repPrefix);
	}

	public static Instruction CreateRepMovsq(int addressSize)
	{
		return CreateString_ESRDI_SegRSI(Code.Movsq_m64_m64, addressSize, Register.None, RepPrefixKind.Repe);
	}

	public static Instruction CreateMaskmovq(int addressSize, Register register1, Register register2, Register segmentPrefix = Register.None)
	{
		return CreateMaskmov(Code.Maskmovq_rDI_mm_mm, addressSize, register1, register2, segmentPrefix);
	}

	public static Instruction CreateMaskmovdqu(int addressSize, Register register1, Register register2, Register segmentPrefix = Register.None)
	{
		return CreateMaskmov(Code.Maskmovdqu_rDI_xmm_xmm, addressSize, register1, register2, segmentPrefix);
	}

	public static Instruction CreateVmaskmovdqu(int addressSize, Register register1, Register register2, Register segmentPrefix = Register.None)
	{
		return CreateMaskmov(Code.VEX_Vmaskmovdqu_rDI_xmm_xmm, addressSize, register1, register2, segmentPrefix);
	}

	public static Instruction CreateDeclareByte(byte b0)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 1u;
		result.SetDeclareByteValue(0, b0);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 2u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 3u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 4u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 5u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 6u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 7u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 8u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 9u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 10u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 11u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		result.SetDeclareByteValue(10, b10);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 12u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		result.SetDeclareByteValue(10, b10);
		result.SetDeclareByteValue(11, b11);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 13u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		result.SetDeclareByteValue(10, b10);
		result.SetDeclareByteValue(11, b11);
		result.SetDeclareByteValue(12, b12);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 14u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		result.SetDeclareByteValue(10, b10);
		result.SetDeclareByteValue(11, b11);
		result.SetDeclareByteValue(12, b12);
		result.SetDeclareByteValue(13, b13);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13, byte b14)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 15u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		result.SetDeclareByteValue(10, b10);
		result.SetDeclareByteValue(11, b11);
		result.SetDeclareByteValue(12, b12);
		result.SetDeclareByteValue(13, b13);
		result.SetDeclareByteValue(14, b14);
		return result;
	}

	public static Instruction CreateDeclareByte(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8, byte b9, byte b10, byte b11, byte b12, byte b13, byte b14, byte b15)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = 16u;
		result.SetDeclareByteValue(0, b0);
		result.SetDeclareByteValue(1, b1);
		result.SetDeclareByteValue(2, b2);
		result.SetDeclareByteValue(3, b3);
		result.SetDeclareByteValue(4, b4);
		result.SetDeclareByteValue(5, b5);
		result.SetDeclareByteValue(6, b6);
		result.SetDeclareByteValue(7, b7);
		result.SetDeclareByteValue(8, b8);
		result.SetDeclareByteValue(9, b9);
		result.SetDeclareByteValue(10, b10);
		result.SetDeclareByteValue(11, b11);
		result.SetDeclareByteValue(12, b12);
		result.SetDeclareByteValue(13, b13);
		result.SetDeclareByteValue(14, b14);
		result.SetDeclareByteValue(15, b15);
		return result;
	}

	public static Instruction CreateDeclareByte(ReadOnlySpan<byte> data)
	{
		if ((uint)(data.Length - 1) > 15u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = (uint)data.Length;
		for (int i = 0; i < data.Length; i++)
		{
			result.SetDeclareByteValue(i, data[i]);
		}
		return result;
	}

	public static Instruction CreateDeclareByte(byte[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareByte(data, 0, data.Length);
	}

	public static Instruction CreateDeclareByte(byte[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 15u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareByte;
		result.InternalDeclareDataCount = (uint)length;
		for (int i = 0; i < length; i++)
		{
			result.SetDeclareByteValue(i, data[index + i]);
		}
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 1u;
		result.SetDeclareWordValue(0, w0);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 2u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 3u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		result.SetDeclareWordValue(2, w2);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 4u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		result.SetDeclareWordValue(2, w2);
		result.SetDeclareWordValue(3, w3);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 5u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		result.SetDeclareWordValue(2, w2);
		result.SetDeclareWordValue(3, w3);
		result.SetDeclareWordValue(4, w4);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 6u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		result.SetDeclareWordValue(2, w2);
		result.SetDeclareWordValue(3, w3);
		result.SetDeclareWordValue(4, w4);
		result.SetDeclareWordValue(5, w5);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5, ushort w6)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 7u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		result.SetDeclareWordValue(2, w2);
		result.SetDeclareWordValue(3, w3);
		result.SetDeclareWordValue(4, w4);
		result.SetDeclareWordValue(5, w5);
		result.SetDeclareWordValue(6, w6);
		return result;
	}

	public static Instruction CreateDeclareWord(ushort w0, ushort w1, ushort w2, ushort w3, ushort w4, ushort w5, ushort w6, ushort w7)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = 8u;
		result.SetDeclareWordValue(0, w0);
		result.SetDeclareWordValue(1, w1);
		result.SetDeclareWordValue(2, w2);
		result.SetDeclareWordValue(3, w3);
		result.SetDeclareWordValue(4, w4);
		result.SetDeclareWordValue(5, w5);
		result.SetDeclareWordValue(6, w6);
		result.SetDeclareWordValue(7, w7);
		return result;
	}

	public static Instruction CreateDeclareWord(ReadOnlySpan<byte> data)
	{
		if ((uint)(data.Length - 1) > 15u || (data.Length & 1) != 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = (uint)data.Length / 2u;
		for (int i = 0; i < data.Length; i += 2)
		{
			uint num = (uint)(data[i] | (data[i + 1] << 8));
			result.SetDeclareWordValue(i / 2, (ushort)num);
		}
		return result;
	}

	public static Instruction CreateDeclareWord(byte[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareWord(data, 0, data.Length);
	}

	public static Instruction CreateDeclareWord(byte[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 15u || (length & 1) != 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = (uint)length / 2u;
		for (int i = 0; i < length; i += 2)
		{
			uint num = (uint)(data[index + i] | (data[index + i + 1] << 8));
			result.SetDeclareWordValue(i / 2, (ushort)num);
		}
		return result;
	}

	public static Instruction CreateDeclareWord(ReadOnlySpan<ushort> data)
	{
		if ((uint)(data.Length - 1) > 7u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = (uint)data.Length;
		for (int i = 0; i < data.Length; i++)
		{
			result.SetDeclareWordValue(i, data[i]);
		}
		return result;
	}

	public static Instruction CreateDeclareWord(ushort[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareWord(data, 0, data.Length);
	}

	public static Instruction CreateDeclareWord(ushort[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 7u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareWord;
		result.InternalDeclareDataCount = (uint)length;
		for (int i = 0; i < length; i++)
		{
			result.SetDeclareWordValue(i, data[index + i]);
		}
		return result;
	}

	public static Instruction CreateDeclareDword(uint d0)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = 1u;
		result.SetDeclareDwordValue(0, d0);
		return result;
	}

	public static Instruction CreateDeclareDword(uint d0, uint d1)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = 2u;
		result.SetDeclareDwordValue(0, d0);
		result.SetDeclareDwordValue(1, d1);
		return result;
	}

	public static Instruction CreateDeclareDword(uint d0, uint d1, uint d2)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = 3u;
		result.SetDeclareDwordValue(0, d0);
		result.SetDeclareDwordValue(1, d1);
		result.SetDeclareDwordValue(2, d2);
		return result;
	}

	public static Instruction CreateDeclareDword(uint d0, uint d1, uint d2, uint d3)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = 4u;
		result.SetDeclareDwordValue(0, d0);
		result.SetDeclareDwordValue(1, d1);
		result.SetDeclareDwordValue(2, d2);
		result.SetDeclareDwordValue(3, d3);
		return result;
	}

	public static Instruction CreateDeclareDword(ReadOnlySpan<byte> data)
	{
		if ((uint)(data.Length - 1) > 15u || (data.Length & 3) != 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = (uint)data.Length / 4u;
		for (int i = 0; i < data.Length; i += 4)
		{
			uint value = (uint)(data[i] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));
			result.SetDeclareDwordValue(i / 4, value);
		}
		return result;
	}

	public static Instruction CreateDeclareDword(byte[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareDword(data, 0, data.Length);
	}

	public static Instruction CreateDeclareDword(byte[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 15u || (length & 3) != 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = (uint)length / 4u;
		for (int i = 0; i < length; i += 4)
		{
			uint value = (uint)(data[index + i] | (data[index + i + 1] << 8) | (data[index + i + 2] << 16) | (data[index + i + 3] << 24));
			result.SetDeclareDwordValue(i / 4, value);
		}
		return result;
	}

	public static Instruction CreateDeclareDword(ReadOnlySpan<uint> data)
	{
		if ((uint)(data.Length - 1) > 3u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = (uint)data.Length;
		for (int i = 0; i < data.Length; i++)
		{
			result.SetDeclareDwordValue(i, data[i]);
		}
		return result;
	}

	public static Instruction CreateDeclareDword(uint[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareDword(data, 0, data.Length);
	}

	public static Instruction CreateDeclareDword(uint[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 3u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareDword;
		result.InternalDeclareDataCount = (uint)length;
		for (int i = 0; i < length; i++)
		{
			result.SetDeclareDwordValue(i, data[index + i]);
		}
		return result;
	}

	public static Instruction CreateDeclareQword(ulong q0)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareQword;
		result.InternalDeclareDataCount = 1u;
		result.SetDeclareQwordValue(0, q0);
		return result;
	}

	public static Instruction CreateDeclareQword(ulong q0, ulong q1)
	{
		Instruction result = default(Instruction);
		result.Code = Code.DeclareQword;
		result.InternalDeclareDataCount = 2u;
		result.SetDeclareQwordValue(0, q0);
		result.SetDeclareQwordValue(1, q1);
		return result;
	}

	public static Instruction CreateDeclareQword(ReadOnlySpan<byte> data)
	{
		if ((uint)(data.Length - 1) > 15u || (data.Length & 7) != 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareQword;
		result.InternalDeclareDataCount = (uint)data.Length / 8u;
		for (int i = 0; i < data.Length; i += 8)
		{
			uint num = (uint)(data[i] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24));
			uint num2 = (uint)(data[i + 4] | (data[i + 5] << 8) | (data[i + 6] << 16) | (data[i + 7] << 24));
			result.SetDeclareQwordValue(i / 8, num | ((ulong)num2 << 32));
		}
		return result;
	}

	public static Instruction CreateDeclareQword(byte[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareQword(data, 0, data.Length);
	}

	public static Instruction CreateDeclareQword(byte[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 15u || (length & 7) != 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareQword;
		result.InternalDeclareDataCount = (uint)length / 8u;
		for (int i = 0; i < length; i += 8)
		{
			uint num = (uint)(data[index + i] | (data[index + i + 1] << 8) | (data[index + i + 2] << 16) | (data[index + i + 3] << 24));
			uint num2 = (uint)(data[index + i + 4] | (data[index + i + 5] << 8) | (data[index + i + 6] << 16) | (data[index + i + 7] << 24));
			result.SetDeclareQwordValue(i / 8, num | ((ulong)num2 << 32));
		}
		return result;
	}

	public static Instruction CreateDeclareQword(ReadOnlySpan<ulong> data)
	{
		if ((uint)(data.Length - 1) > 1u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_data();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareQword;
		result.InternalDeclareDataCount = (uint)data.Length;
		for (int i = 0; i < data.Length; i++)
		{
			result.SetDeclareQwordValue(i, data[i]);
		}
		return result;
	}

	public static Instruction CreateDeclareQword(ulong[] data)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		return CreateDeclareQword(data, 0, data.Length);
	}

	public static Instruction CreateDeclareQword(ulong[] data, int index, int length)
	{
		if (data == null)
		{
			ThrowHelper.ThrowArgumentNullException_data();
		}
		if ((uint)(length - 1) > 1u)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_length();
		}
		if ((ulong)((long)(uint)index + (long)(uint)length) > (ulong)(uint)data.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction result = default(Instruction);
		result.Code = Code.DeclareQword;
		result.InternalDeclareDataCount = (uint)length;
		for (int i = 0; i < length; i++)
		{
			result.SetDeclareQwordValue(i, data[index + i]);
		}
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator ==(in Instruction left, in Instruction right)
	{
		return EqualsInternal(in left, in right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator !=(in Instruction left, in Instruction right)
	{
		return !EqualsInternal(in left, in right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public readonly bool Equals(in Instruction other)
	{
		return EqualsInternal(in this, in other);
	}

	readonly bool IEquatable<Instruction>.Equals(Instruction other)
	{
		return EqualsInternal(in this, in other);
	}

	private static bool EqualsInternal(in Instruction a, in Instruction b)
	{
		if (a.memDispl == b.memDispl && ((a.flags1 ^ b.flags1) & 0xFFF3FFFFu) == 0 && a.immediate == b.immediate && a.code == b.code && a.memBaseReg == b.memBaseReg && a.memIndexReg == b.memIndexReg && a.reg0 == b.reg0 && a.reg1 == b.reg1 && a.reg2 == b.reg2 && a.reg3 == b.reg3 && a.opKind0 == b.opKind0 && a.opKind1 == b.opKind1 && a.opKind2 == b.opKind2 && a.opKind3 == b.opKind3 && a.scale == b.scale && a.displSize == b.displSize)
		{
			return a.pad == b.pad;
		}
		return false;
	}

	public override readonly int GetHashCode()
	{
		return (int)((uint)((int)memDispl ^ (int)(memDispl >> 32)) ^ (flags1 & 0xFFF3FFFFu) ^ immediate ^ (uint)(code << 8) ^ (uint)(memBaseReg << 16) ^ (uint)(memIndexReg << 24) ^ reg3 ^ (uint)(reg2 << 8) ^ (uint)(reg1 << 16) ^ (uint)(reg0 << 24) ^ opKind3 ^ (uint)(opKind2 << 8) ^ (uint)(opKind1 << 16) ^ (uint)(opKind0 << 24) ^ scale ^ (uint)(displSize << 8)) ^ (pad << 16);
	}

	public override readonly bool Equals(object? obj)
	{
		if (obj is Instruction b)
		{
			return EqualsInternal(in this, in b);
		}
		return false;
	}

	public static bool EqualsAllBits(in Instruction a, in Instruction b)
	{
		if (a.nextRip == b.nextRip && a.memDispl == b.memDispl && a.flags1 == b.flags1 && a.immediate == b.immediate && a.code == b.code && a.memBaseReg == b.memBaseReg && a.memIndexReg == b.memIndexReg && a.reg0 == b.reg0 && a.reg1 == b.reg1 && a.reg2 == b.reg2 && a.reg3 == b.reg3 && a.opKind0 == b.opKind0 && a.opKind1 == b.opKind1 && a.opKind2 == b.opKind2 && a.opKind3 == b.opKind3 && a.scale == b.scale && a.displSize == b.displSize && a.len == b.len)
		{
			return a.pad == b.pad;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetCodeNoCheck(Code code)
	{
		this.code = (ushort)code;
	}

	private readonly bool IsXacquireInstr()
	{
		if (Op0Kind != OpKind.Memory)
		{
			return false;
		}
		if (HasLockPrefix)
		{
			return Code != Code.Cmpxchg16b_m128;
		}
		return Mnemonic == Mnemonic.Xchg;
	}

	private readonly bool IsXreleaseInstr()
	{
		if (Op0Kind != OpKind.Memory)
		{
			return false;
		}
		if (HasLockPrefix)
		{
			return Code != Code.Cmpxchg16b_m128;
		}
		Code code = Code;
		if ((uint)(code - 275) <= 7u || code == Code.Mov_rm8_imm8 || (uint)(code - 403) <= 2u)
		{
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetHasXacquirePrefix()
	{
		flags1 |= 1073741824u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetHasXreleasePrefix()
	{
		flags1 |= 536870912u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetHasRepePrefix()
	{
		flags1 = (flags1 & 0xBFFFFFFFu) | 0x20000000;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalClearHasRepePrefix()
	{
		flags1 &= 3758096383u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalClearHasRepeRepnePrefix()
	{
		flags1 &= 2684354559u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetHasRepnePrefix()
	{
		flags1 = (flags1 & 0xDFFFFFFFu) | 0x40000000;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalClearHasRepnePrefix()
	{
		flags1 &= 3221225471u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetHasLockPrefix()
	{
		flags1 |= 2147483648u;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalClearHasLockPrefix()
	{
		flags1 &= 2147483647u;
	}

	public readonly OpKind GetOpKind(int operand)
	{
		switch (operand)
		{
		case 0:
			return Op0Kind;
		case 1:
			return Op1Kind;
		case 2:
			return Op2Kind;
		case 3:
			return Op3Kind;
		case 4:
			return Op4Kind;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_operand();
			return OpKind.Register;
		}
	}

	public readonly bool HasOpKind(OpKind opKind)
	{
		for (int i = 0; i < OpCount; i++)
		{
			if (GetOpKind(i) == opKind)
			{
				return true;
			}
		}
		return false;
	}

	public void SetOpKind(int operand, OpKind opKind)
	{
		switch (operand)
		{
		case 0:
			Op0Kind = opKind;
			break;
		case 1:
			Op1Kind = opKind;
			break;
		case 2:
			Op2Kind = opKind;
			break;
		case 3:
			Op3Kind = opKind;
			break;
		case 4:
			Op4Kind = opKind;
			break;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_operand();
			break;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetMemoryDisplSize(uint scale)
	{
		displSize = (byte)scale;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetIsBroadcast()
	{
		flags1 |= 67108864u;
	}

	public readonly ulong GetImmediate(int operand)
	{
		return GetOpKind(operand) switch
		{
			OpKind.Immediate8 => Immediate8, 
			OpKind.Immediate8_2nd => Immediate8_2nd, 
			OpKind.Immediate16 => Immediate16, 
			OpKind.Immediate32 => Immediate32, 
			OpKind.Immediate64 => Immediate64, 
			OpKind.Immediate8to16 => (ulong)Immediate8to16, 
			OpKind.Immediate8to32 => (ulong)Immediate8to32, 
			OpKind.Immediate8to64 => (ulong)Immediate8to64, 
			OpKind.Immediate32to64 => (ulong)Immediate32to64, 
			_ => throw new ArgumentException($"Op{operand} isn't an immediate operand", "operand"), 
		};
	}

	public void SetImmediate(int operand, int immediate)
	{
		SetImmediate(operand, (ulong)immediate);
	}

	public void SetImmediate(int operand, uint immediate)
	{
		SetImmediate(operand, (ulong)immediate);
	}

	public void SetImmediate(int operand, long immediate)
	{
		SetImmediate(operand, (ulong)immediate);
	}

	public void SetImmediate(int operand, ulong immediate)
	{
		switch (GetOpKind(operand))
		{
		case OpKind.Immediate8:
			Immediate8 = (byte)immediate;
			return;
		case OpKind.Immediate8to16:
			Immediate8to16 = (short)immediate;
			return;
		case OpKind.Immediate8to32:
			Immediate8to32 = (int)immediate;
			return;
		case OpKind.Immediate8to64:
			Immediate8to64 = (long)immediate;
			return;
		case OpKind.Immediate8_2nd:
			Immediate8_2nd = (byte)immediate;
			return;
		case OpKind.Immediate16:
			Immediate16 = (ushort)immediate;
			return;
		case OpKind.Immediate32to64:
			Immediate32to64 = (long)immediate;
			return;
		case OpKind.Immediate32:
			Immediate32 = (uint)immediate;
			return;
		case OpKind.Immediate64:
			Immediate64 = immediate;
			return;
		}
		throw new ArgumentException($"Op{operand} isn't an immediate operand", "operand");
	}

	public readonly Register GetOpRegister(int operand)
	{
		switch (operand)
		{
		case 0:
			return Op0Register;
		case 1:
			return Op1Register;
		case 2:
			return Op2Register;
		case 3:
			return Op3Register;
		case 4:
			return Op4Register;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_operand();
			return Register.None;
		}
	}

	public void SetOpRegister(int operand, Register register)
	{
		switch (operand)
		{
		case 0:
			Op0Register = register;
			break;
		case 1:
			Op1Register = register;
			break;
		case 2:
			Op2Register = register;
			break;
		case 3:
			Op3Register = register;
			break;
		case 4:
			Op4Register = register;
			break;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_operand();
			break;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetZeroingMasking()
	{
		flags1 |= 268435456u;
	}

	public void SetDeclareByteValue(int index, sbyte value)
	{
		SetDeclareByteValue(index, (byte)value);
	}

	public void SetDeclareByteValue(int index, byte value)
	{
		switch (index)
		{
		case 0:
			reg0 = value;
			break;
		case 1:
			reg1 = value;
			break;
		case 2:
			reg2 = value;
			break;
		case 3:
			reg3 = value;
			break;
		case 4:
			immediate = (immediate & 0xFFFFFF00u) | value;
			break;
		case 5:
			immediate = (immediate & 0xFFFF00FFu) | (uint)(value << 8);
			break;
		case 6:
			immediate = (immediate & 0xFF00FFFFu) | (uint)(value << 16);
			break;
		case 7:
			immediate = (immediate & 0xFFFFFF) | (uint)(value << 24);
			break;
		case 8:
			memDispl = (memDispl & 0xFFFFFFFFFFFFFF00uL) | value;
			break;
		case 9:
			memDispl = (memDispl & 0xFFFFFFFFFFFF00FFuL) | ((ulong)value << 8);
			break;
		case 10:
			memDispl = (memDispl & 0xFFFFFFFFFF00FFFFuL) | ((ulong)value << 16);
			break;
		case 11:
			memDispl = (memDispl & 0xFFFFFFFF00FFFFFFuL) | ((ulong)value << 24);
			break;
		case 12:
			memDispl = (memDispl & 0xFFFFFF00FFFFFFFFuL) | ((ulong)value << 32);
			break;
		case 13:
			memDispl = (memDispl & 0xFFFF00FFFFFFFFFFuL) | ((ulong)value << 40);
			break;
		case 14:
			memDispl = (memDispl & 0xFF00FFFFFFFFFFFFuL) | ((ulong)value << 48);
			break;
		case 15:
			memDispl = (memDispl & 0xFFFFFFFFFFFFFFL) | ((ulong)value << 56);
			break;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			break;
		}
	}

	public readonly byte GetDeclareByteValue(int index)
	{
		switch (index)
		{
		case 0:
			return reg0;
		case 1:
			return reg1;
		case 2:
			return reg2;
		case 3:
			return reg3;
		case 4:
			return (byte)immediate;
		case 5:
			return (byte)(immediate >> 8);
		case 6:
			return (byte)(immediate >> 16);
		case 7:
			return (byte)(immediate >> 24);
		case 8:
			return (byte)memDispl;
		case 9:
			return (byte)((uint)memDispl >> 8);
		case 10:
			return (byte)((uint)memDispl >> 16);
		case 11:
			return (byte)((uint)memDispl >> 24);
		case 12:
			return (byte)(memDispl >> 32);
		case 13:
			return (byte)(memDispl >> 40);
		case 14:
			return (byte)(memDispl >> 48);
		case 15:
			return (byte)(memDispl >> 56);
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			return 0;
		}
	}

	public void SetDeclareWordValue(int index, short value)
	{
		SetDeclareWordValue(index, (ushort)value);
	}

	public void SetDeclareWordValue(int index, ushort value)
	{
		switch (index)
		{
		case 0:
			reg0 = (byte)value;
			reg1 = (byte)(value >> 8);
			break;
		case 1:
			reg2 = (byte)value;
			reg3 = (byte)(value >> 8);
			break;
		case 2:
			immediate = (immediate & 0xFFFF0000u) | value;
			break;
		case 3:
			immediate = (uint)((ushort)immediate | (value << 16));
			break;
		case 4:
			memDispl = (memDispl & 0xFFFFFFFFFFFF0000uL) | value;
			break;
		case 5:
			memDispl = (memDispl & 0xFFFFFFFF0000FFFFuL) | ((ulong)value << 16);
			break;
		case 6:
			memDispl = (memDispl & 0xFFFF0000FFFFFFFFuL) | ((ulong)value << 32);
			break;
		case 7:
			memDispl = (memDispl & 0xFFFFFFFFFFFFL) | ((ulong)value << 48);
			break;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			break;
		}
	}

	public readonly ushort GetDeclareWordValue(int index)
	{
		switch (index)
		{
		case 0:
			return (ushort)(reg0 | (reg1 << 8));
		case 1:
			return (ushort)(reg2 | (reg3 << 8));
		case 2:
			return (ushort)immediate;
		case 3:
			return (ushort)(immediate >> 16);
		case 4:
			return (ushort)memDispl;
		case 5:
			return (ushort)((uint)memDispl >> 16);
		case 6:
			return (ushort)(memDispl >> 32);
		case 7:
			return (ushort)(memDispl >> 48);
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			return 0;
		}
	}

	public void SetDeclareDwordValue(int index, int value)
	{
		SetDeclareDwordValue(index, (uint)value);
	}

	public void SetDeclareDwordValue(int index, uint value)
	{
		switch (index)
		{
		case 0:
			reg0 = (byte)value;
			reg1 = (byte)(value >> 8);
			reg2 = (byte)(value >> 16);
			reg3 = (byte)(value >> 24);
			break;
		case 1:
			immediate = value;
			break;
		case 2:
			memDispl = (memDispl & 0xFFFFFFFF00000000uL) | value;
			break;
		case 3:
			memDispl = (memDispl & 0xFFFFFFFFu) | ((ulong)value << 32);
			break;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			break;
		}
	}

	public readonly uint GetDeclareDwordValue(int index)
	{
		switch (index)
		{
		case 0:
			return (uint)(reg0 | (reg1 << 8) | (reg2 << 16) | (reg3 << 24));
		case 1:
			return immediate;
		case 2:
			return (uint)memDispl;
		case 3:
			return (uint)(memDispl >> 32);
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			return 0u;
		}
	}

	public void SetDeclareQwordValue(int index, long value)
	{
		SetDeclareQwordValue(index, (ulong)value);
	}

	public void SetDeclareQwordValue(int index, ulong value)
	{
		switch (index)
		{
		case 0:
		{
			uint num = (uint)value;
			reg0 = (byte)num;
			reg1 = (byte)(num >> 8);
			reg2 = (byte)(num >> 16);
			reg3 = (byte)(num >> 24);
			immediate = (uint)(value >> 32);
			break;
		}
		case 1:
			memDispl = value;
			break;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			break;
		}
	}

	public readonly ulong GetDeclareQwordValue(int index)
	{
		switch (index)
		{
		case 0:
			return (ulong)reg0 | (ulong)(uint)(reg1 << 8) | (uint)(reg2 << 16) | (uint)(reg3 << 24) | ((ulong)immediate << 32);
		case 1:
			return memDispl;
		default:
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
			return 0uL;
		}
	}

	public readonly bool TryGetVsib64(out bool vsib64)
	{
		switch (Code)
		{
		case Code.VEX_Vpgatherdd_xmm_vm32x_xmm:
		case Code.VEX_Vpgatherdd_ymm_vm32y_ymm:
		case Code.VEX_Vpgatherdq_xmm_vm32x_xmm:
		case Code.VEX_Vpgatherdq_ymm_vm32x_ymm:
		case Code.EVEX_Vpgatherdd_xmm_k1_vm32x:
		case Code.EVEX_Vpgatherdd_ymm_k1_vm32y:
		case Code.EVEX_Vpgatherdd_zmm_k1_vm32z:
		case Code.EVEX_Vpgatherdq_xmm_k1_vm32x:
		case Code.EVEX_Vpgatherdq_ymm_k1_vm32x:
		case Code.EVEX_Vpgatherdq_zmm_k1_vm32y:
		case Code.VEX_Vgatherdps_xmm_vm32x_xmm:
		case Code.VEX_Vgatherdps_ymm_vm32y_ymm:
		case Code.VEX_Vgatherdpd_xmm_vm32x_xmm:
		case Code.VEX_Vgatherdpd_ymm_vm32x_ymm:
		case Code.EVEX_Vgatherdps_xmm_k1_vm32x:
		case Code.EVEX_Vgatherdps_ymm_k1_vm32y:
		case Code.EVEX_Vgatherdps_zmm_k1_vm32z:
		case Code.EVEX_Vgatherdpd_xmm_k1_vm32x:
		case Code.EVEX_Vgatherdpd_ymm_k1_vm32x:
		case Code.EVEX_Vgatherdpd_zmm_k1_vm32y:
		case Code.EVEX_Vpscatterdd_vm32x_k1_xmm:
		case Code.EVEX_Vpscatterdd_vm32y_k1_ymm:
		case Code.EVEX_Vpscatterdd_vm32z_k1_zmm:
		case Code.EVEX_Vpscatterdq_vm32x_k1_xmm:
		case Code.EVEX_Vpscatterdq_vm32x_k1_ymm:
		case Code.EVEX_Vpscatterdq_vm32y_k1_zmm:
		case Code.EVEX_Vscatterdps_vm32x_k1_xmm:
		case Code.EVEX_Vscatterdps_vm32y_k1_ymm:
		case Code.EVEX_Vscatterdps_vm32z_k1_zmm:
		case Code.EVEX_Vscatterdpd_vm32x_k1_xmm:
		case Code.EVEX_Vscatterdpd_vm32x_k1_ymm:
		case Code.EVEX_Vscatterdpd_vm32y_k1_zmm:
		case Code.EVEX_Vgatherpf0dps_vm32z_k1:
		case Code.EVEX_Vgatherpf0dpd_vm32y_k1:
		case Code.EVEX_Vgatherpf1dps_vm32z_k1:
		case Code.EVEX_Vgatherpf1dpd_vm32y_k1:
		case Code.EVEX_Vscatterpf0dps_vm32z_k1:
		case Code.EVEX_Vscatterpf0dpd_vm32y_k1:
		case Code.EVEX_Vscatterpf1dps_vm32z_k1:
		case Code.EVEX_Vscatterpf1dpd_vm32y_k1:
		case Code.MVEX_Vpgatherdd_zmm_k1_mvt:
		case Code.MVEX_Vpgatherdq_zmm_k1_mvt:
		case Code.MVEX_Vgatherdps_zmm_k1_mvt:
		case Code.MVEX_Vgatherdpd_zmm_k1_mvt:
		case Code.MVEX_Vpscatterdd_mvt_k1_zmm:
		case Code.MVEX_Vpscatterdq_mvt_k1_zmm:
		case Code.MVEX_Vscatterdps_mvt_k1_zmm:
		case Code.MVEX_Vscatterdpd_mvt_k1_zmm:
		case Code.MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B0:
		case Code.MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_B2:
		case Code.MVEX_Undoc_zmm_k1_mvt_512_66_0F38_W0_C0:
		case Code.MVEX_Vgatherpf0hintdps_mvt_k1:
		case Code.MVEX_Vgatherpf0hintdpd_mvt_k1:
		case Code.MVEX_Vgatherpf0dps_mvt_k1:
		case Code.MVEX_Vgatherpf1dps_mvt_k1:
		case Code.MVEX_Vscatterpf0hintdps_mvt_k1:
		case Code.MVEX_Vscatterpf0hintdpd_mvt_k1:
		case Code.MVEX_Vscatterpf0dps_mvt_k1:
		case Code.MVEX_Vscatterpf1dps_mvt_k1:
			vsib64 = false;
			return true;
		case Code.VEX_Vpgatherqd_xmm_vm64x_xmm:
		case Code.VEX_Vpgatherqd_xmm_vm64y_xmm:
		case Code.VEX_Vpgatherqq_xmm_vm64x_xmm:
		case Code.VEX_Vpgatherqq_ymm_vm64y_ymm:
		case Code.EVEX_Vpgatherqd_xmm_k1_vm64x:
		case Code.EVEX_Vpgatherqd_xmm_k1_vm64y:
		case Code.EVEX_Vpgatherqd_ymm_k1_vm64z:
		case Code.EVEX_Vpgatherqq_xmm_k1_vm64x:
		case Code.EVEX_Vpgatherqq_ymm_k1_vm64y:
		case Code.EVEX_Vpgatherqq_zmm_k1_vm64z:
		case Code.VEX_Vgatherqps_xmm_vm64x_xmm:
		case Code.VEX_Vgatherqps_xmm_vm64y_xmm:
		case Code.VEX_Vgatherqpd_xmm_vm64x_xmm:
		case Code.VEX_Vgatherqpd_ymm_vm64y_ymm:
		case Code.EVEX_Vgatherqps_xmm_k1_vm64x:
		case Code.EVEX_Vgatherqps_xmm_k1_vm64y:
		case Code.EVEX_Vgatherqps_ymm_k1_vm64z:
		case Code.EVEX_Vgatherqpd_xmm_k1_vm64x:
		case Code.EVEX_Vgatherqpd_ymm_k1_vm64y:
		case Code.EVEX_Vgatherqpd_zmm_k1_vm64z:
		case Code.EVEX_Vpscatterqd_vm64x_k1_xmm:
		case Code.EVEX_Vpscatterqd_vm64y_k1_xmm:
		case Code.EVEX_Vpscatterqd_vm64z_k1_ymm:
		case Code.EVEX_Vpscatterqq_vm64x_k1_xmm:
		case Code.EVEX_Vpscatterqq_vm64y_k1_ymm:
		case Code.EVEX_Vpscatterqq_vm64z_k1_zmm:
		case Code.EVEX_Vscatterqps_vm64x_k1_xmm:
		case Code.EVEX_Vscatterqps_vm64y_k1_xmm:
		case Code.EVEX_Vscatterqps_vm64z_k1_ymm:
		case Code.EVEX_Vscatterqpd_vm64x_k1_xmm:
		case Code.EVEX_Vscatterqpd_vm64y_k1_ymm:
		case Code.EVEX_Vscatterqpd_vm64z_k1_zmm:
		case Code.EVEX_Vgatherpf0qps_vm64z_k1:
		case Code.EVEX_Vgatherpf0qpd_vm64z_k1:
		case Code.EVEX_Vgatherpf1qps_vm64z_k1:
		case Code.EVEX_Vgatherpf1qpd_vm64z_k1:
		case Code.EVEX_Vscatterpf0qps_vm64z_k1:
		case Code.EVEX_Vscatterpf0qpd_vm64z_k1:
		case Code.EVEX_Vscatterpf1qps_vm64z_k1:
		case Code.EVEX_Vscatterpf1qpd_vm64z_k1:
			vsib64 = true;
			return true;
		default:
			vsib64 = false;
			return false;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void InternalSetSuppressAllExceptions()
	{
		flags1 |= 134217728u;
	}

	public override readonly string ToString()
	{
		return base.ToString() ?? string.Empty;
	}

	public readonly ulong GetVirtualAddress(int operand, int elementIndex, VAGetRegisterValue getRegisterValue)
	{
		if (getRegisterValue == null)
		{
			throw new ArgumentNullException("getRegisterValue");
		}
		VARegisterValueProviderDelegateImpl registerValueProvider = new VARegisterValueProviderDelegateImpl(getRegisterValue);
		if (TryGetVirtualAddress(operand, elementIndex, registerValueProvider, out var result))
		{
			return result;
		}
		return 0uL;
	}

	public readonly ulong GetVirtualAddress(int operand, int elementIndex, IVARegisterValueProvider registerValueProvider)
	{
		if (registerValueProvider == null)
		{
			throw new ArgumentNullException("registerValueProvider");
		}
		VARegisterValueProviderAdapter registerValueProvider2 = new VARegisterValueProviderAdapter(registerValueProvider);
		if (TryGetVirtualAddress(operand, elementIndex, registerValueProvider2, out var result))
		{
			return result;
		}
		return 0uL;
	}

	public readonly bool TryGetVirtualAddress(int operand, int elementIndex, out ulong result, VATryGetRegisterValue getRegisterValue)
	{
		if (getRegisterValue == null)
		{
			throw new ArgumentNullException("getRegisterValue");
		}
		VATryGetRegisterValueDelegateImpl registerValueProvider = new VATryGetRegisterValueDelegateImpl(getRegisterValue);
		return TryGetVirtualAddress(operand, elementIndex, registerValueProvider, out result);
	}

	public readonly bool TryGetVirtualAddress(int operand, int elementIndex, IVATryGetRegisterValueProvider registerValueProvider, out ulong result)
	{
		if (registerValueProvider == null)
		{
			throw new ArgumentNullException("registerValueProvider");
		}
		ulong value2;
		ulong value;
		switch (GetOpKind(operand))
		{
		case OpKind.Register:
		case OpKind.NearBranch16:
		case OpKind.NearBranch32:
		case OpKind.NearBranch64:
		case OpKind.FarBranch16:
		case OpKind.FarBranch32:
		case OpKind.Immediate8:
		case OpKind.Immediate8_2nd:
		case OpKind.Immediate16:
		case OpKind.Immediate32:
		case OpKind.Immediate64:
		case OpKind.Immediate8to16:
		case OpKind.Immediate8to32:
		case OpKind.Immediate8to64:
		case OpKind.Immediate32to64:
			result = 0uL;
			return true;
		case OpKind.MemorySegSI:
			if (registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.SI, 0, 0, out value))
			{
				result = value2 + (ushort)value;
				return true;
			}
			break;
		case OpKind.MemorySegESI:
			if (registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.ESI, 0, 0, out value))
			{
				result = value2 + (uint)value;
				return true;
			}
			break;
		case OpKind.MemorySegRSI:
			if (registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.RSI, 0, 0, out value))
			{
				result = value2 + value;
				return true;
			}
			break;
		case OpKind.MemorySegDI:
			if (registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.DI, 0, 0, out value))
			{
				result = value2 + (ushort)value;
				return true;
			}
			break;
		case OpKind.MemorySegEDI:
			if (registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.EDI, 0, 0, out value))
			{
				result = value2 + (uint)value;
				return true;
			}
			break;
		case OpKind.MemorySegRDI:
			if (registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.RDI, 0, 0, out value))
			{
				result = value2 + value;
				return true;
			}
			break;
		case OpKind.MemoryESDI:
			if (registerValueProvider.TryGetRegisterValue(Register.ES, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.DI, 0, 0, out value))
			{
				result = value2 + (ushort)value;
				return true;
			}
			break;
		case OpKind.MemoryESEDI:
			if (registerValueProvider.TryGetRegisterValue(Register.ES, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.EDI, 0, 0, out value))
			{
				result = value2 + (uint)value;
				return true;
			}
			break;
		case OpKind.MemoryESRDI:
			if (registerValueProvider.TryGetRegisterValue(Register.ES, 0, 0, out value2) && registerValueProvider.TryGetRegisterValue(Register.RDI, 0, 0, out value))
			{
				result = value2 + value;
				return true;
			}
			break;
		case OpKind.Memory:
		{
			Register memoryBase = MemoryBase;
			Register memoryIndex = MemoryIndex;
			int addressSizeInBytes = InstructionUtils.GetAddressSizeInBytes(memoryBase, memoryIndex, MemoryDisplSize, CodeSize);
			ulong num = MemoryDisplacement64;
			ulong num2 = addressSizeInBytes switch
			{
				8 => ulong.MaxValue, 
				4 => 4294967295uL, 
				_ => 65535uL, 
			};
			if (memoryBase != 0 && memoryBase != Register.RIP && memoryBase != Register.EIP)
			{
				if (!registerValueProvider.TryGetRegisterValue(memoryBase, 0, 0, out value))
				{
					break;
				}
				num += value;
			}
			Code code = Code;
			if (memoryIndex != 0 && !code.IgnoresIndex() && !code.IsTileStrideIndex())
			{
				if (TryGetVsib64(out var vsib))
				{
					bool flag;
					if (vsib)
					{
						flag = registerValueProvider.TryGetRegisterValue(memoryIndex, elementIndex, 8, out value);
					}
					else
					{
						flag = registerValueProvider.TryGetRegisterValue(memoryIndex, elementIndex, 4, out value);
						value = (ulong)(int)value;
					}
					if (!flag)
					{
						break;
					}
					num += value << InternalMemoryIndexScale;
				}
				else
				{
					if (!registerValueProvider.TryGetRegisterValue(memoryIndex, 0, 0, out value))
					{
						break;
					}
					num += value << InternalMemoryIndexScale;
				}
			}
			num &= num2;
			if (!code.IgnoresSegment())
			{
				if (!registerValueProvider.TryGetRegisterValue(MemorySegment, 0, 0, out value2))
				{
					break;
				}
				num += value2;
			}
			result = num;
			return true;
		}
		default:
			throw new InvalidOperationException();
		}
		result = 0uL;
		return false;
	}
}


using System;

[Flags]
private enum InstrFlags1 : uint
{
	SegmentPrefixMask = 7u,
	SegmentPrefixShift = 5u,
	DataLengthMask = 0xFu,
	DataLengthShift = 8u,
	RoundingControlMask = 7u,
	RoundingControlShift = 0xCu,
	OpMaskMask = 7u,
	OpMaskShift = 0xFu,
	CodeSizeMask = 3u,
	CodeSizeShift = 0x12u,
	Broadcast = 0x4000000u,
	SuppressAllExceptions = 0x8000000u,
	ZeroingMasking = 0x10000000u,
	RepePrefix = 0x20000000u,
	RepnePrefix = 0x40000000u,
	LockPrefix = 0x80000000u,
	EqualsIgnoreMask = 0xC0000u
}


using System;

[Flags]
private enum MvexInstrFlags : uint
{
	MvexRegMemConvShift = 0x10u,
	MvexRegMemConvMask = 0x1Fu,
	EvictionHint = 0x80000000u
}


using Iced.Intel;

internal delegate ulong VAGetRegisterValue(Register register, int elementIndex, int elementSize);


using Iced.Intel;

internal interface IVARegisterValueProvider
{
	ulong GetRegisterValue(Register register, int elementIndex, int elementSize);
}


using Iced.Intel;

internal delegate bool VATryGetRegisterValue(Register register, int elementIndex, int elementSize, out ulong value);


using Iced.Intel;

internal interface IVATryGetRegisterValueProvider
{
	bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, out ulong value);
}


using System;
using Iced.Intel;

internal sealed class VARegisterValueProviderDelegateImpl : IVATryGetRegisterValueProvider
{
	private readonly VAGetRegisterValue getRegisterValue;

	public VARegisterValueProviderDelegateImpl(VAGetRegisterValue getRegisterValue)
	{
		this.getRegisterValue = getRegisterValue ?? throw new ArgumentNullException("getRegisterValue");
	}

	public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, out ulong value)
	{
		value = getRegisterValue(register, elementIndex, elementSize);
		return true;
	}
}


using Iced.Intel;

internal sealed class VARegisterValueProviderAdapter : IVATryGetRegisterValueProvider
{
	private readonly IVARegisterValueProvider provider;

	public VARegisterValueProviderAdapter(IVARegisterValueProvider provider)
	{
		this.provider = provider;
	}

	public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, out ulong value)
	{
		value = provider.GetRegisterValue(register, elementIndex, elementSize);
		return true;
	}
}


using Iced.Intel;

internal sealed class VATryGetRegisterValueDelegateImpl : IVATryGetRegisterValueProvider
{
	private readonly VATryGetRegisterValue getRegisterValue;

	public VATryGetRegisterValueDelegateImpl(VATryGetRegisterValue getRegisterValue)
	{
		this.getRegisterValue = getRegisterValue;
	}

	public bool TryGetRegisterValue(Register register, int elementIndex, int elementSize, out ulong value)
	{
		return getRegisterValue(register, elementIndex, elementSize, out value);
	}
}


using Iced.Intel;

internal static class InstructionInfoExtensions
{
	public static Code NegateConditionCode(this Code code)
	{
		uint num;
		if ((num = (uint)(code - 1854)) <= 47 || (num = (uint)(code - 159)) <= 47 || (num = (uint)(code - 1169)) <= 47)
		{
			if (((num / 3) & 1) != 0)
			{
				return code - 3;
			}
			return code + 3;
		}
		num = (uint)(code - 1902);
		if (num <= 15)
		{
			return (Code)((num ^ 1) + 1902);
		}
		num = (uint)(code - 657);
		if (num <= 13)
		{
			return (Code)(657 + (num + 7) % 14);
		}
		return code;
	}

	public static Code ToShortBranch(this Code code)
	{
		uint num = (uint)(code - 1854);
		if (num <= 47)
		{
			return (Code)(num + 159);
		}
		num = (uint)(code - 694);
		if (num <= 2)
		{
			return (Code)(num + 699);
		}
		return code;
	}

	public static Code ToNearBranch(this Code code)
	{
		uint num = (uint)(code - 159);
		if (num <= 47)
		{
			return (Code)(num + 1854);
		}
		num = (uint)(code - 699);
		if (num <= 2)
		{
			return (Code)(num + 694);
		}
		return code;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Iced.Intel;

[DebuggerDisplay("Count = {Count}")]
[DebuggerTypeProxy(typeof(InstructionListDebugView))]
[EditorBrowsable(EditorBrowsableState.Never)]
internal sealed class InstructionList : IList<Instruction>, ICollection<Instruction>, IEnumerable<Instruction>, IEnumerable, IReadOnlyList<Instruction>, IReadOnlyCollection<Instruction>, IList, ICollection
{
	public struct Enumerator : IEnumerator<Instruction>, IDisposable, IEnumerator
	{
		private readonly InstructionList list;

		private int index;

		public ref Instruction Current => ref list.elements[index];

		Instruction IEnumerator<Instruction>.Current => list.elements[index];

		object IEnumerator.Current => list.elements[index];

		internal Enumerator(InstructionList list)
		{
			this.list = list;
			index = -1;
		}

		public bool MoveNext()
		{
			index++;
			return index < list.count;
		}

		void IEnumerator.Reset()
		{
			throw new NotSupportedException();
		}

		public void Dispose()
		{
		}
	}

	private Instruction[] elements;

	private int count;

	public int Count => count;

	int ICollection<Instruction>.Count => count;

	int ICollection.Count => count;

	int IReadOnlyCollection<Instruction>.Count => count;

	public int Capacity => elements.Length;

	bool ICollection<Instruction>.IsReadOnly => false;

	bool IList.IsReadOnly => false;

	bool IList.IsFixedSize => false;

	bool ICollection.IsSynchronized => false;

	object ICollection.SyncRoot => this;

	public ref Instruction this[int index] => ref elements[index];

	Instruction IList<Instruction>.this[int index]
	{
		get
		{
			return elements[index];
		}
		set
		{
			elements[index] = value;
		}
	}

	Instruction IReadOnlyList<Instruction>.this[int index] => elements[index];

	object? IList.this[int index]
	{
		get
		{
			return elements[index];
		}
		set
		{
			if (value == null)
			{
				ThrowHelper.ThrowArgumentNullException_value();
			}
			if (!(value is Instruction))
			{
				ThrowHelper.ThrowArgumentException();
			}
			elements[index] = (Instruction)value;
		}
	}

	public InstructionList()
	{
		elements = Array2.Empty<Instruction>();
	}

	public InstructionList(int capacity)
	{
		if (capacity < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_capacity();
		}
		elements = ((capacity == 0) ? Array2.Empty<Instruction>() : new Instruction[capacity]);
	}

	public InstructionList(InstructionList list)
	{
		if (list == null)
		{
			ThrowHelper.ThrowArgumentNullException_list();
		}
		int num = list.count;
		if (num == 0)
		{
			elements = Array2.Empty<Instruction>();
			return;
		}
		Instruction[] destinationArray = (elements = new Instruction[num]);
		count = num;
		Array.Copy(list.elements, 0, destinationArray, 0, num);
	}

	public InstructionList(IEnumerable<Instruction> collection)
	{
		if (collection == null)
		{
			ThrowHelper.ThrowArgumentNullException_collection();
		}
		if (collection is ICollection<Instruction> { Count: var num } collection2)
		{
			if (num == 0)
			{
				elements = Array2.Empty<Instruction>();
				return;
			}
			collection2.CopyTo(elements = new Instruction[num], 0);
			count = num;
			return;
		}
		elements = Array2.Empty<Instruction>();
		foreach (Instruction item in collection)
		{
			Add(item);
		}
	}

	private void SetMinCapacity(int minCapacity)
	{
		Instruction[] array = elements;
		uint num = (uint)array.Length;
		if (minCapacity > (int)num)
		{
			uint num2 = num * 2;
			if (num2 < 4)
			{
				num2 = 4u;
			}
			if (num2 < (uint)minCapacity)
			{
				num2 = (uint)minCapacity;
			}
			if (num2 > 2146435071)
			{
				num2 = 2146435071u;
			}
			Instruction[] destinationArray = new Instruction[num2];
			Array.Copy(array, 0, destinationArray, 0, count);
			elements = destinationArray;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public ref Instruction AllocUninitializedElement()
	{
		int num = count;
		Instruction[] array = elements;
		if (num == array.Length)
		{
			SetMinCapacity(num + 1);
			array = elements;
		}
		count = num + 1;
		return ref array[num];
	}

	private void MakeRoom(int index, int extraLength)
	{
		SetMinCapacity(count + extraLength);
		int num = count - index;
		if (num != 0)
		{
			Instruction[] array = elements;
			Array.Copy(array, index, array, index + extraLength, num);
		}
	}

	public void Insert(int index, in Instruction instruction)
	{
		int num = count;
		if ((uint)index > (uint)num)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		MakeRoom(index, 1);
		elements[index] = instruction;
		count = num + 1;
	}

	void IList<Instruction>.Insert(int index, Instruction instruction)
	{
		Insert(index, in instruction);
	}

	void IList.Insert(int index, object value)
	{
		if (value == null)
		{
			ThrowHelper.ThrowArgumentNullException_value();
		}
		if (!(value is Instruction))
		{
			ThrowHelper.ThrowArgumentException();
		}
		Insert(index, (Instruction)value);
	}

	public void RemoveAt(int index)
	{
		int num = count;
		if ((uint)index >= (uint)num)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		int num2 = (count = num - 1) - index;
		if (num2 != 0)
		{
			Instruction[] array = elements;
			Array.Copy(array, index + 1, array, index, num2);
		}
	}

	void IList<Instruction>.RemoveAt(int index)
	{
		RemoveAt(index);
	}

	void IList.RemoveAt(int index)
	{
		RemoveAt(index);
	}

	public void AddRange(IEnumerable<Instruction> collection)
	{
		InsertRange(count, collection);
	}

	public void InsertRange(int index, IEnumerable<Instruction> collection)
	{
		if ((uint)index > (uint)count)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		if (collection == null)
		{
			ThrowHelper.ThrowArgumentNullException_collection();
		}
		if (collection is InstructionList { count: var num } instructionList)
		{
			if (num != 0)
			{
				MakeRoom(index, num);
				count += num;
				Array.Copy(instructionList.elements, 0, elements, index, num);
			}
			return;
		}
		if (collection is IList<Instruction> { Count: var num2 } list)
		{
			if (num2 != 0)
			{
				MakeRoom(index, num2);
				count += num2;
				Instruction[] array = elements;
				for (int i = 0; i < num2; i++)
				{
					array[index + i] = list[i];
				}
			}
			return;
		}
		if (collection is IReadOnlyList<Instruction> { Count: var num3 } readOnlyList)
		{
			if (num3 != 0)
			{
				MakeRoom(index, num3);
				count += num3;
				Instruction[] array2 = elements;
				for (int j = 0; j < num3; j++)
				{
					array2[index + j] = readOnlyList[j];
				}
			}
			return;
		}
		foreach (Instruction item in collection)
		{
			Instruction instruction = item;
			Insert(index++, in instruction);
		}
	}

	public void RemoveRange(int index, int count)
	{
		if (index < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		if (count < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		if ((uint)(index + count) > (uint)this.count)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		int num = this.count;
		int num2 = (this.count = num - count) - index;
		if (num2 != 0)
		{
			Instruction[] array = elements;
			Array.Copy(array, index + count, array, index, num2);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Add(in Instruction instruction)
	{
		int num = count;
		Instruction[] array = elements;
		if (num == array.Length)
		{
			SetMinCapacity(num + 1);
			array = elements;
		}
		array[num] = instruction;
		count = num + 1;
	}

	void ICollection<Instruction>.Add(Instruction instruction)
	{
		Add(in instruction);
	}

	int IList.Add(object value)
	{
		if (value == null)
		{
			ThrowHelper.ThrowArgumentNullException_value();
		}
		if (!(value is Instruction))
		{
			ThrowHelper.ThrowArgumentException();
		}
		Add((Instruction)value);
		return count - 1;
	}

	public void Clear()
	{
		count = 0;
	}

	void ICollection<Instruction>.Clear()
	{
		Clear();
	}

	void IList.Clear()
	{
		Clear();
	}

	public bool Contains(in Instruction instruction)
	{
		return IndexOf(in instruction) >= 0;
	}

	bool ICollection<Instruction>.Contains(Instruction instruction)
	{
		return Contains(in instruction);
	}

	bool IList.Contains(object value)
	{
		if (value is Instruction instruction)
		{
			return Contains(in instruction);
		}
		return false;
	}

	public int IndexOf(in Instruction instruction)
	{
		Instruction[] array = elements;
		int num = count;
		for (int i = 0; i < num; i++)
		{
			if (array[i] == instruction)
			{
				return i;
			}
		}
		return -1;
	}

	int IList<Instruction>.IndexOf(Instruction instruction)
	{
		return IndexOf(in instruction);
	}

	int IList.IndexOf(object value)
	{
		if (value is Instruction instruction)
		{
			return IndexOf(in instruction);
		}
		return -1;
	}

	public int IndexOf(in Instruction instruction, int index)
	{
		int num = count;
		if ((uint)index > (uint)num)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction[] array = elements;
		for (int i = index; i < num; i++)
		{
			if (array[i] == instruction)
			{
				return i;
			}
		}
		return -1;
	}

	public int IndexOf(in Instruction instruction, int index, int count)
	{
		if (index < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		if (count < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		int num = index + count;
		if ((uint)num > (uint)this.count)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		Instruction[] array = elements;
		for (int i = index; i < num; i++)
		{
			if (array[i] == instruction)
			{
				return i;
			}
		}
		return -1;
	}

	public int LastIndexOf(in Instruction instruction)
	{
		for (int num = count - 1; num >= 0; num--)
		{
			if (elements[num] == instruction)
			{
				return num;
			}
		}
		return -1;
	}

	public int LastIndexOf(in Instruction instruction, int index)
	{
		int num = count;
		if ((uint)index > (uint)num)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		Instruction[] array = elements;
		for (int num2 = num - 1; num2 >= index; num2--)
		{
			if (array[num2] == instruction)
			{
				return num2;
			}
		}
		return -1;
	}

	public int LastIndexOf(in Instruction instruction, int index, int count)
	{
		if (index < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		if (count < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		int num = index + count;
		if ((uint)num > (uint)this.count)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		Instruction[] array = elements;
		for (int num2 = num - 1; num2 >= index; num2--)
		{
			if (array[num2] == instruction)
			{
				return num2;
			}
		}
		return -1;
	}

	public bool Remove(in Instruction instruction)
	{
		int num = IndexOf(in instruction);
		if (num >= 0)
		{
			RemoveAt(num);
		}
		return num >= 0;
	}

	bool ICollection<Instruction>.Remove(Instruction instruction)
	{
		return Remove(in instruction);
	}

	void IList.Remove(object value)
	{
		if (value is Instruction instruction)
		{
			Remove(in instruction);
		}
	}

	public void CopyTo(Instruction[] array)
	{
		CopyTo(array, 0);
	}

	public void CopyTo(Instruction[] array, int arrayIndex)
	{
		Array.Copy(elements, 0, array, arrayIndex, count);
	}

	void ICollection<Instruction>.CopyTo(Instruction[] array, int arrayIndex)
	{
		CopyTo(array, arrayIndex);
	}

	void ICollection.CopyTo(Array array, int index)
	{
		if (array == null)
		{
			ThrowHelper.ThrowArgumentNullException_array();
		}
		else if (array is Instruction[] array2)
		{
			CopyTo(array2, index);
		}
		else
		{
			ThrowHelper.ThrowArgumentException();
		}
	}

	public void CopyTo(int index, Instruction[] array, int arrayIndex, int count)
	{
		Array.Copy(elements, index, array, arrayIndex, count);
	}

	public InstructionList GetRange(int index, int count)
	{
		if (index < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_index();
		}
		if (count < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		if ((uint)(index + count) > (uint)this.count)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_count();
		}
		InstructionList instructionList = new InstructionList(count);
		Array.Copy(elements, index, instructionList.elements, 0, count);
		instructionList.count = count;
		return instructionList;
	}

	public Enumerator GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator<Instruction> IEnumerable<Instruction>.GetEnumerator()
	{
		return new Enumerator(this);
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return new Enumerator(this);
	}

	public ReadOnlyCollection<Instruction> AsReadOnly()
	{
		return new ReadOnlyCollection<Instruction>(this);
	}

	public Instruction[] ToArray()
	{
		int num = count;
		if (num == 0)
		{
			return Array2.Empty<Instruction>();
		}
		Instruction[] array = new Instruction[num];
		Array.Copy(elements, 0, array, 0, array.Length);
		return array;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;

public struct Enumerator : IEnumerator<Instruction>, IDisposable, IEnumerator
{
	private readonly InstructionList list;

	private int index;

	public ref Instruction Current => ref list.elements[index];

	Instruction IEnumerator<Instruction>.Current => list.elements[index];

	object IEnumerator.Current => list.elements[index];

	internal Enumerator(InstructionList list)
	{
		this.list = list;
		index = -1;
	}

	public bool MoveNext()
	{
		index++;
		return index < list.count;
	}

	void IEnumerator.Reset()
	{
		throw new NotSupportedException();
	}

	public void Dispose()
	{
	}
}


using System;
using System.Diagnostics;
using Iced.Intel;

internal sealed class InstructionListDebugView
{
	private readonly InstructionList list;

	[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
	public Instruction[] Items => list.ToArray();

	public InstructionListDebugView(InstructionList list)
	{
		this.list = list ?? throw new ArgumentNullException("list");
	}
}


using System;

internal static class InstructionMemorySizes
{
	internal static ReadOnlySpan<byte> SizesNormal => new byte[4834]
	{
		0, 0, 0, 0, 0, 1, 2, 3, 5, 1,
		2, 3, 5, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 2, 3, 5, 1, 2, 3, 5, 0,
		0, 0, 0, 0, 0, 0, 1, 2, 3, 5,
		1, 2, 3, 5, 0, 0, 0, 0, 0, 0,
		0, 0, 1, 2, 3, 5, 1, 2, 3, 5,
		0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
		3, 5, 1, 2, 3, 5, 0, 0, 0, 0,
		0, 1, 2, 3, 5, 1, 2, 3, 5, 0,
		0, 0, 0, 0, 1, 2, 3, 5, 1, 2,
		3, 5, 0, 0, 0, 0, 0, 1, 2, 3,
		5, 1, 2, 3, 5, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 22, 23, 2, 2, 10, 11,
		11, 0, 0, 0, 10, 11, 12, 0, 0, 0,
		10, 11, 12, 1, 2, 3, 1, 2, 3, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
		1, 1, 1, 1, 1, 2, 3, 5, 2, 3,
		5, 2, 3, 5, 2, 3, 5, 2, 3, 5,
		2, 3, 5, 2, 3, 5, 2, 3, 5, 1,
		1, 1, 1, 1, 1, 1, 1, 2, 3, 5,
		2, 3, 5, 2, 3, 5, 2, 3, 5, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 2, 3,
		5, 1, 2, 3, 5, 1, 2, 3, 5, 1,
		2, 3, 5, 1, 2, 3, 5, 2, 2, 2,
		0, 0, 0, 2, 2, 2, 2, 3, 5, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 2, 3, 5, 1, 2, 3,
		5, 1, 2, 3, 5, 1, 2, 3, 5, 0,
		0, 0, 0, 1, 2, 3, 5, 1, 2, 3,
		5, 1, 2, 3, 5, 0, 0, 0, 0, 1,
		1, 1, 1, 1, 1, 1, 9, 2, 3, 5,
		2, 3, 5, 2, 3, 5, 2, 3, 5, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 10, 11,
		12, 0, 0, 0, 0, 0, 0, 16, 17, 16,
		17, 1, 0, 2, 3, 5, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
		1, 1, 1, 9, 2, 3, 5, 2, 3, 5,
		2, 3, 5, 2, 3, 5, 2, 3, 5, 2,
		3, 5, 2, 3, 5, 10, 11, 12, 1, 1,
		1, 1, 1, 1, 1, 9, 2, 3, 5, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 2, 3,
		5, 2, 3, 5, 2, 3, 5, 10, 11, 12,
		0, 0, 0, 1, 29, 29, 29, 29, 29, 29,
		29, 29, 0, 0, 0, 0, 0, 0, 0, 0,
		29, 29, 29, 34, 35, 2, 34, 34, 35, 35,
		2, 2, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 11, 11, 11, 11, 11, 11, 11,
		11, 0, 0, 0, 0, 0, 11, 11, 11, 11,
		31, 31, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 30,
		30, 30, 30, 30, 30, 30, 30, 0, 0, 0,
		0, 0, 0, 0, 0, 30, 12, 30, 30, 36,
		37, 36, 36, 37, 37, 2, 2, 0, 0, 0,
		0, 0, 0, 10, 10, 10, 10, 10, 10, 10,
		10, 0, 0, 0, 0, 0, 0, 0, 0, 10,
		10, 10, 10, 42, 12, 42, 12, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 1, 9, 1, 9, 1, 9, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 10, 11,
		12, 2, 3, 5, 10, 11, 12, 2, 3, 5,
		10, 11, 12, 0, 0, 0, 0, 0, 0, 1,
		1, 2, 3, 5, 2, 3, 5, 19, 20, 21,
		16, 17, 18, 19, 20, 21, 16, 17, 18, 2,
		3, 5, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		19, 20, 26, 26, 27, 26, 26, 27, 26, 26,
		27, 26, 26, 27, 2, 2, 2, 5, 2, 2,
		2, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 2, 2, 2, 2, 2, 2, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		2, 3, 5, 1, 1, 1, 0, 1, 2, 3,
		1, 2, 3, 74, 74, 90, 74, 90, 106, 75,
		75, 91, 75, 91, 107, 29, 0, 29, 0, 29,
		30, 0, 30, 0, 30, 74, 74, 90, 74, 90,
		106, 75, 75, 91, 75, 91, 107, 29, 0, 29,
		0, 29, 30, 0, 30, 0, 30, 0, 63, 0,
		63, 0, 63, 30, 30, 30, 74, 74, 90, 74,
		90, 106, 30, 30, 91, 30, 91, 107, 63, 63,
		63, 30, 30, 30, 74, 74, 90, 74, 90, 106,
		75, 75, 91, 75, 91, 107, 74, 74, 90, 74,
		90, 106, 75, 75, 91, 75, 91, 107, 0, 0,
		0, 63, 63, 63, 30, 30, 30, 74, 74, 90,
		74, 90, 106, 63, 63, 63, 30, 30, 30, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 2, 3,
		5, 2, 3, 5, 2, 3, 5, 2, 3, 5,
		2, 3, 5, 1, 1, 1, 1, 0, 24, 25,
		3, 5, 3, 5, 0, 24, 25, 3, 5, 3,
		5, 1, 0, 0, 0, 0, 2, 3, 5, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 74,
		74, 90, 74, 90, 106, 75, 75, 91, 75, 91,
		107, 74, 74, 90, 74, 90, 106, 75, 75, 91,
		75, 91, 107, 61, 61, 11, 12, 11, 12, 11,
		12, 11, 12, 11, 12, 11, 12, 74, 74, 90,
		74, 90, 106, 75, 75, 91, 75, 91, 107, 29,
		30, 63, 75, 29, 29, 29, 29, 29, 29, 30,
		30, 30, 30, 30, 30, 63, 75, 29, 29, 29,
		29, 29, 29, 30, 30, 30, 30, 30, 30, 29,
		29, 29, 30, 30, 30, 29, 30, 29, 30, 29,
		30, 0, 0, 0, 0, 0, 0, 0, 0, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 2, 3,
		5, 2, 3, 5, 2, 3, 5, 2, 3, 5,
		2, 3, 5, 2, 3, 5, 2, 3, 5, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 2, 3,
		5, 2, 3, 5, 2, 3, 5, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		74, 74, 90, 74, 90, 106, 75, 75, 91, 75,
		91, 107, 29, 29, 29, 30, 30, 30, 74, 74,
		90, 29, 29, 74, 74, 90, 29, 29, 74, 74,
		90, 74, 90, 106, 75, 75, 91, 75, 91, 107,
		74, 74, 90, 74, 90, 106, 75, 75, 91, 75,
		91, 107, 74, 74, 90, 74, 90, 106, 75, 75,
		91, 75, 91, 107, 74, 74, 90, 74, 90, 106,
		75, 75, 91, 75, 91, 107, 74, 74, 90, 74,
		90, 106, 75, 75, 91, 75, 91, 107, 29, 29,
		29, 30, 30, 30, 74, 74, 90, 74, 90, 106,
		75, 75, 91, 75, 91, 107, 29, 29, 29, 30,
		30, 30, 63, 63, 74, 63, 74, 90, 75, 75,
		91, 75, 91, 107, 29, 29, 29, 30, 30, 30,
		69, 69, 83, 69, 83, 100, 72, 86, 103, 74,
		74, 90, 74, 90, 106, 74, 74, 90, 74, 90,
		106, 74, 74, 90, 74, 90, 106, 75, 75, 91,
		75, 91, 107, 29, 29, 29, 30, 30, 30, 74,
		74, 90, 74, 90, 106, 75, 75, 91, 75, 91,
		107, 29, 29, 29, 30, 30, 30, 74, 74, 90,
		74, 90, 106, 75, 75, 91, 75, 91, 107, 29,
		29, 29, 30, 30, 30, 74, 74, 90, 74, 90,
		106, 75, 75, 91, 75, 91, 107, 29, 29, 29,
		30, 30, 30, 50, 64, 64, 78, 64, 78, 95,
		52, 66, 66, 80, 66, 80, 97, 11, 68, 68,
		82, 68, 82, 99, 59, 67, 67, 81, 67, 81,
		98, 57, 65, 65, 79, 65, 79, 96, 59, 67,
		67, 81, 67, 81, 98, 61, 69, 69, 83, 69,
		83, 100, 59, 67, 67, 81, 67, 81, 98, 56,
		64, 64, 78, 64, 78, 95, 58, 66, 66, 80,
		66, 80, 97, 60, 68, 68, 82, 68, 82, 99,
		61, 69, 69, 83, 69, 83, 100, 71, 71, 85,
		71, 85, 102, 71, 71, 85, 71, 85, 102, 3,
		5, 3, 5, 3, 5, 3, 5, 5, 68, 68,
		82, 68, 82, 99, 71, 85, 102, 68, 68, 82,
		68, 82, 99, 71, 85, 102, 64, 78, 95, 66,
		80, 97, 58, 68, 68, 82, 68, 82, 99, 66,
		66, 80, 66, 80, 97, 66, 66, 80, 66, 80,
		97, 0, 0, 0, 0, 66, 80, 97, 0, 0,
		0, 0, 67, 81, 98, 0, 0, 0, 0, 66,
		80, 97, 68, 82, 99, 71, 85, 102, 68, 82,
		99, 71, 85, 102, 0, 0, 0, 0, 68, 82,
		99, 0, 0, 0, 0, 69, 83, 100, 72, 86,
		103, 0, 0, 0, 0, 68, 82, 99, 0, 0,
		0, 0, 71, 85, 102, 0, 0, 0, 6, 87,
		104, 0, 0, 0, 0, 71, 85, 102, 0, 0,
		0, 6, 87, 104, 56, 64, 64, 78, 64, 78,
		95, 58, 66, 66, 80, 66, 80, 97, 60, 68,
		68, 82, 68, 82, 99, 0, 0, 0, 3, 5,
		74, 90, 106, 75, 91, 107, 0, 63, 74, 90,
		75, 91, 107, 29, 29, 0, 30, 30, 3, 5,
		74, 90, 106, 75, 91, 107, 0, 63, 74, 90,
		75, 91, 107, 29, 29, 0, 30, 30, 63, 74,
		90, 75, 91, 107, 60, 68, 82, 71, 85, 102,
		68, 82, 99, 71, 85, 102, 63, 74, 90, 75,
		91, 107, 3, 5, 3, 5, 75, 75, 91, 74,
		74, 90, 75, 75, 91, 74, 74, 90, 3, 5,
		3, 5, 3, 5, 3, 5, 5, 5, 5, 5,
		68, 68, 82, 68, 82, 99, 71, 85, 102, 68,
		68, 82, 68, 82, 99, 71, 85, 102, 64, 78,
		95, 66, 80, 97, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 2, 5,
		1, 3, 2, 5, 1, 3, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 2, 3, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 2, 3, 1,
		2, 3, 0, 0, 0, 0, 0, 0, 0, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 38, 39,
		0, 0, 38, 39, 0, 0, 3, 0, 0, 3,
		3, 0, 0, 3, 40, 41, 3, 5, 40, 41,
		0, 0, 40, 41, 1, 0, 0, 5, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		10, 11, 12, 1, 2, 3, 5, 16, 17, 18,
		2, 3, 5, 16, 17, 18, 16, 17, 18, 1,
		1, 1, 2, 2, 2, 0, 0, 2, 3, 5,
		2, 3, 5, 2, 3, 5, 2, 3, 5, 2,
		3, 5, 2, 3, 5, 2, 3, 5, 2, 3,
		5, 2, 3, 5, 2, 3, 5, 2, 3, 5,
		9, 9, 9, 10, 10, 10, 1, 2, 3, 5,
		74, 74, 90, 74, 90, 106, 75, 75, 91, 75,
		91, 107, 29, 29, 29, 30, 30, 30, 3, 5,
		2, 2, 2, 2, 2, 2, 2, 2, 0, 0,
		0, 0, 0, 0, 0, 0, 74, 74, 90, 74,
		90, 106, 75, 75, 91, 75, 91, 107, 5, 6,
		40, 41, 40, 41, 40, 41, 5, 5, 5, 0,
		0, 0, 5, 0, 0, 0, 0, 0, 0, 0,
		0, 75, 75, 91, 74, 74, 90, 58, 66, 66,
		66, 66, 66, 66, 60, 68, 68, 68, 68, 68,
		68, 5, 71, 71, 71, 71, 71, 71, 5, 71,
		71, 85, 71, 85, 102, 59, 67, 67, 81, 67,
		81, 98, 5, 5, 5, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 56, 64, 64, 78, 64,
		78, 95, 58, 66, 66, 80, 66, 80, 97, 56,
		64, 64, 78, 64, 78, 95, 5, 6, 6, 87,
		68, 82, 99, 71, 85, 102, 56, 64, 64, 78,
		64, 78, 95, 58, 66, 66, 80, 66, 80, 97,
		56, 64, 64, 78, 64, 78, 95, 5, 6, 6,
		87, 68, 82, 99, 71, 85, 102, 56, 64, 64,
		78, 64, 78, 95, 59, 67, 67, 67, 67, 67,
		67, 61, 69, 69, 69, 69, 69, 69, 72, 72,
		72, 58, 66, 66, 80, 66, 80, 97, 58, 66,
		66, 80, 66, 80, 97, 59, 67, 67, 81, 67,
		81, 98, 75, 75, 91, 75, 91, 107, 61, 61,
		69, 61, 69, 83, 72, 86, 103, 75, 75, 91,
		75, 91, 107, 60, 68, 68, 82, 68, 82, 99,
		57, 65, 65, 79, 65, 79, 96, 59, 67, 67,
		81, 67, 81, 98, 59, 67, 67, 81, 67, 81,
		98, 5, 6, 6, 87, 68, 82, 99, 71, 85,
		102, 57, 65, 65, 79, 65, 79, 96, 59, 67,
		67, 81, 67, 81, 98, 59, 67, 67, 81, 67,
		81, 98, 5, 6, 6, 87, 68, 82, 99, 71,
		85, 102, 6, 6, 7, 58, 66, 66, 66, 66,
		66, 66, 60, 68, 68, 68, 68, 68, 68, 5,
		71, 71, 71, 71, 71, 71, 60, 68, 68, 82,
		68, 82, 99, 59, 67, 67, 81, 67, 81, 98,
		56, 64, 64, 78, 64, 78, 95, 5, 6, 6,
		56, 64, 64, 78, 64, 78, 95, 58, 66, 66,
		80, 66, 80, 97, 60, 68, 68, 82, 68, 82,
		99, 12, 71, 71, 85, 71, 85, 102, 56, 64,
		64, 78, 64, 78, 95, 58, 66, 66, 80, 66,
		80, 97, 60, 68, 68, 82, 68, 82, 99, 2,
		3, 5, 56, 64, 64, 78, 64, 78, 95, 58,
		66, 66, 80, 60, 68, 68, 82, 59, 67, 67,
		81, 57, 65, 65, 79, 65, 79, 96, 58, 66,
		66, 80, 60, 68, 68, 82, 59, 67, 67, 81,
		57, 65, 65, 79, 59, 67, 67, 81, 61, 69,
		69, 83, 59, 67, 67, 81, 67, 81, 98, 74,
		90, 74, 90, 106, 75, 91, 75, 91, 107, 74,
		90, 75, 91, 64, 66, 80, 97, 56, 64, 78,
		66, 80, 97, 50, 56, 64, 66, 80, 97, 48,
		50, 56, 62, 73, 62, 73, 89, 58, 66, 80,
		74, 68, 82, 99, 71, 85, 102, 52, 58, 66,
		75, 68, 82, 99, 71, 85, 102, 60, 68, 82,
		90, 90, 106, 91, 107, 6, 6, 7, 29, 29,
		29, 29, 29, 30, 63, 63, 30, 30, 32, 74,
		74, 75, 75, 90, 91, 57, 65, 65, 79, 65,
		79, 96, 59, 67, 67, 81, 67, 81, 98, 61,
		69, 69, 83, 69, 83, 100, 72, 86, 103, 57,
		57, 65, 57, 65, 79, 57, 65, 79, 51, 51,
		57, 51, 57, 65, 51, 57, 65, 49, 49, 51,
		49, 51, 57, 49, 51, 57, 59, 59, 67, 59,
		67, 81, 59, 67, 81, 53, 53, 59, 53, 59,
		67, 53, 59, 67, 61, 61, 69, 61, 69, 83,
		61, 69, 83, 64, 78, 95, 66, 80, 97, 64,
		78, 95, 66, 80, 97, 68, 82, 99, 71, 85,
		102, 68, 82, 99, 71, 85, 102, 69, 69, 83,
		69, 83, 100, 0, 0, 0, 0, 0, 0, 71,
		71, 85, 71, 85, 102, 0, 0, 0, 0, 0,
		0, 6, 6, 7, 6, 7, 8, 0, 0, 0,
		69, 69, 83, 69, 83, 100, 74, 90, 74, 90,
		106, 75, 91, 107, 75, 91, 29, 30, 74, 90,
		75, 91, 56, 56, 64, 56, 64, 78, 56, 64,
		78, 50, 50, 56, 50, 56, 64, 50, 56, 64,
		48, 48, 50, 48, 50, 56, 48, 50, 56, 58,
		58, 66, 58, 66, 80, 58, 66, 80, 52, 52,
		58, 52, 58, 66, 52, 58, 66, 60, 60, 68,
		60, 68, 82, 60, 68, 82, 82, 82, 99, 85,
		102, 72, 72, 86, 72, 86, 103, 65, 65, 79,
		65, 79, 96, 0, 0, 0, 0, 0, 0, 69,
		69, 83, 69, 83, 100, 72, 86, 103, 0, 0,
		0, 0, 0, 0, 66, 66, 80, 66, 80, 97,
		0, 0, 0, 68, 68, 82, 68, 82, 99, 71,
		85, 102, 65, 65, 79, 65, 79, 96, 69, 69,
		83, 69, 83, 100, 72, 86, 103, 66, 66, 80,
		66, 80, 97, 68, 68, 82, 68, 82, 99, 71,
		85, 102, 69, 69, 83, 69, 83, 100, 72, 86,
		103, 66, 66, 74, 90, 106, 75, 91, 107, 29,
		30, 68, 82, 99, 71, 85, 102, 68, 82, 71,
		85, 68, 82, 99, 71, 85, 102, 68, 82, 68,
		82, 99, 71, 85, 102, 68, 82, 71, 85, 68,
		82, 99, 71, 85, 102, 74, 90, 106, 75, 91,
		107, 29, 30, 74, 90, 106, 75, 91, 107, 29,
		30, 65, 79, 96, 65, 79, 96, 67, 81, 98,
		77, 94, 109, 67, 67, 81, 98, 67, 64, 78,
		95, 66, 80, 97, 68, 82, 99, 71, 85, 102,
		11, 11, 11, 11, 11, 12, 12, 60, 60, 60,
		12, 12, 12, 13, 68, 68, 71, 71, 82, 85,
		64, 78, 95, 66, 80, 97, 64, 78, 95, 66,
		80, 97, 68, 82, 99, 71, 85, 102, 74, 90,
		106, 75, 91, 107, 64, 78, 95, 66, 80, 97,
		68, 82, 99, 71, 85, 102, 66, 80, 97, 68,
		82, 99, 71, 85, 102, 66, 80, 97, 74, 90,
		106, 74, 90, 106, 68, 82, 99, 71, 85, 102,
		64, 78, 95, 66, 80, 97, 68, 82, 99, 71,
		85, 102, 74, 90, 106, 75, 91, 107, 9, 9,
		9, 9, 9, 10, 10, 10, 10, 10, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		64, 78, 95, 66, 80, 97, 68, 82, 99, 71,
		85, 102, 74, 90, 106, 75, 91, 107, 6, 6,
		6, 6, 6, 6, 71, 85, 102, 74, 90, 106,
		75, 91, 107, 68, 82, 99, 71, 85, 102, 74,
		90, 106, 75, 91, 107, 68, 82, 99, 71, 85,
		102, 68, 82, 71, 85, 64, 78, 95, 66, 80,
		97, 68, 82, 71, 85, 64, 78, 95, 11, 11,
		12, 12, 11, 11, 11, 12, 12, 12, 11, 11,
		12, 12, 11, 11, 11, 12, 12, 12, 29, 29,
		30, 30, 29, 29, 29, 30, 30, 30, 29, 29,
		30, 30, 29, 29, 29, 30, 30, 30, 74, 90,
		75, 91, 74, 90, 106, 75, 91, 107, 74, 90,
		75, 91, 74, 90, 106, 75, 91, 107, 74, 90,
		75, 91, 74, 90, 106, 75, 91, 107, 29, 30,
		29, 30, 74, 90, 75, 91, 74, 90, 106, 75,
		91, 107, 74, 29, 30, 29, 30, 74, 74, 90,
		75, 91, 74, 90, 106, 75, 91, 107, 29, 30,
		29, 30, 74, 90, 75, 91, 74, 90, 106, 75,
		91, 107, 29, 30, 29, 30, 11, 11, 11, 12,
		12, 12, 11, 11, 11, 12, 12, 12, 29, 29,
		29, 30, 30, 30, 29, 29, 29, 30, 30, 30,
		74, 90, 75, 91, 74, 90, 106, 75, 91, 107,
		74, 90, 75, 91, 74, 90, 106, 75, 91, 107,
		74, 90, 75, 91, 74, 90, 106, 75, 91, 107,
		29, 30, 29, 30, 74, 90, 75, 91, 74, 90,
		106, 75, 91, 107, 74, 29, 30, 29, 30, 74,
		74, 90, 75, 91, 74, 90, 106, 75, 91, 107,
		29, 30, 29, 30, 74, 90, 75, 91, 74, 90,
		106, 75, 91, 107, 29, 30, 29, 30, 70, 84,
		101, 70, 84, 101, 74, 90, 75, 91, 74, 90,
		106, 75, 91, 107, 74, 90, 75, 91, 74, 90,
		106, 75, 91, 107, 74, 90, 75, 91, 74, 90,
		106, 75, 91, 107, 29, 30, 29, 30, 74, 90,
		75, 91, 74, 90, 106, 75, 91, 107, 29, 30,
		29, 30, 74, 90, 75, 91, 74, 90, 106, 75,
		91, 107, 29, 30, 29, 30, 74, 90, 75, 91,
		74, 90, 106, 75, 91, 107, 29, 30, 29, 30,
		68, 82, 99, 71, 85, 102, 29, 30, 29, 30,
		29, 30, 29, 30, 29, 30, 29, 30, 29, 30,
		29, 30, 68, 106, 107, 68, 68, 106, 107, 68,
		29, 30, 68, 106, 107, 68, 29, 30, 64, 64,
		78, 64, 78, 95, 6, 6, 6, 6, 87, 6,
		87, 104, 6, 6, 87, 6, 87, 104, 6, 6,
		87, 6, 87, 104, 6, 6, 87, 6, 87, 104,
		2, 3, 5, 1, 1, 2, 3, 5, 2, 3,
		5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
		5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
		5, 3, 5, 3, 5, 3, 5, 3, 5, 11,
		12, 3, 5, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 3, 5, 85, 85, 102, 91, 91, 107,
		68, 82, 68, 82, 99, 71, 85, 102, 74, 90,
		74, 90, 106, 75, 91, 75, 91, 107, 92, 74,
		74, 90, 74, 90, 106, 75, 75, 91, 75, 91,
		107, 29, 29, 29, 30, 30, 30, 74, 74, 90,
		75, 75, 91, 66, 66, 80, 56, 64, 64, 78,
		64, 78, 95, 1, 1, 1, 1, 1, 1, 2,
		2, 2, 2, 2, 2, 3, 5, 3, 5, 3,
		5, 29, 29, 29, 29, 29, 29, 32, 74, 74,
		75, 75, 32, 74, 74, 75, 75, 90, 91, 90,
		91, 62, 73, 62, 73, 89, 68, 82, 99, 71,
		85, 102, 69, 83, 100, 72, 86, 103, 1, 1,
		1, 1, 1, 1, 29, 29, 29, 3, 5, 3,
		5, 3, 5, 90, 106, 91, 107, 68, 82, 99,
		71, 85, 102, 74, 90, 106, 75, 91, 107, 29,
		30, 0, 0, 0, 0, 0, 0, 0, 0, 13,
		68, 68, 71, 71, 13, 68, 68, 71, 71, 82,
		85, 82, 85, 64, 78, 95, 66, 80, 97, 65,
		79, 96, 67, 81, 98, 74, 74, 90, 75, 75,
		64, 64, 78, 64, 78, 95, 82, 99, 85, 102,
		71, 71, 85, 71, 85, 102, 87, 74, 90, 74,
		90, 75, 91, 75, 91, 74, 90, 75, 91, 64,
		78, 74, 90, 106, 75, 91, 107, 29, 30, 74,
		90, 106, 75, 91, 107, 29, 30, 74, 90, 106,
		75, 91, 107, 29, 30, 74, 90, 74, 90, 75,
		91, 75, 91, 74, 90, 74, 90, 75, 91, 75,
		91, 64, 64, 64, 64, 64, 64, 64, 64, 64,
		64, 64, 64, 74, 90, 106, 75, 91, 107, 29,
		30, 74, 90, 74, 90, 75, 91, 75, 91, 29,
		29, 30, 30, 74, 90, 74, 90, 75, 91, 75,
		91, 29, 29, 30, 30, 66, 80, 97, 68, 82,
		99, 71, 85, 102, 66, 80, 97, 68, 82, 99,
		71, 85, 102, 74, 90, 74, 90, 75, 91, 75,
		91, 29, 29, 30, 30, 74, 90, 74, 90, 75,
		91, 75, 91, 29, 29, 30, 30, 68, 64, 64,
		78, 64, 78, 95, 64, 64, 78, 64, 78, 95,
		6, 6, 3, 5, 67, 67, 69, 69, 69, 67,
		67, 69, 69, 69, 6, 7, 6, 7, 64, 64,
		67, 67, 64, 66, 68, 71, 65, 67, 69, 72,
		64, 66, 68, 71, 3, 5, 3, 5, 3, 5,
		3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
		3, 5, 0, 0, 0, 0, 74, 90, 75, 91,
		29, 30, 64, 64, 66, 66, 68, 68, 71, 71,
		64, 64, 66, 66, 68, 68, 71, 71, 65, 65,
		67, 67, 69, 69, 72, 72, 65, 65, 65, 67,
		67, 69, 64, 64, 64, 66, 66, 68, 65, 67,
		69, 3, 5, 3, 3, 3, 3, 59, 61, 63,
		63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
		63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
		59, 60, 56, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
		1, 0, 0, 0, 43, 0, 43, 0, 44, 44,
		44, 0, 0, 0, 0, 0, 0, 0, 3, 3,
		0, 0, 0, 45, 45, 45, 45, 45, 45, 0,
		0, 0, 0, 0, 0, 56, 59, 58, 56, 59,
		56, 59, 56, 57, 57, 59, 58, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 46, 46, 47, 47, 0, 46, 46,
		47, 47, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 65, 79, 65, 79, 67, 81,
		67, 81, 0, 0, 0, 0, 0, 0, 2, 2,
		2, 0, 0, 73, 89, 105, 28, 73, 89, 105,
		28, 28, 69, 83, 100, 75, 91, 107, 62, 73,
		89, 54, 62, 73, 62, 73, 89, 54, 62, 73,
		62, 73, 89, 54, 62, 73, 73, 89, 105, 73,
		89, 105, 74, 90, 106, 72, 86, 103, 30, 28,
		28, 28, 28, 28, 28, 11, 12, 29, 62, 73,
		89, 54, 62, 73, 62, 73, 89, 54, 62, 73,
		73, 89, 105, 73, 89, 105, 28, 28, 28, 28,
		68, 82, 99, 71, 85, 102, 3, 5, 66, 80,
		97, 67, 81, 98, 73, 89, 105, 28, 76, 93,
		108, 76, 93, 108, 54, 54, 76, 93, 108, 76,
		93, 108, 54, 54, 73, 89, 105, 73, 89, 105,
		73, 89, 105, 73, 89, 105, 73, 89, 105, 73,
		89, 105, 73, 89, 105, 73, 89, 105, 73, 89,
		105, 73, 89, 105, 73, 89, 105, 73, 89, 105,
		28, 28, 28, 28, 28, 28, 73, 89, 105, 73,
		89, 105, 73, 89, 105, 73, 89, 105, 73, 89,
		105, 73, 89, 105, 28, 28, 28, 28, 28, 28,
		73, 89, 105, 28, 73, 89, 105, 28, 73, 89,
		105, 28, 73, 89, 105, 28, 73, 89, 105, 28,
		28, 28, 0, 0, 2, 2, 2, 2, 73, 89,
		105, 28, 73, 89, 105, 28, 73, 89, 105, 28,
		73, 89, 105, 28, 73, 89, 105, 28, 73, 89,
		105, 28, 73, 89, 105, 28, 73, 89, 105, 28,
		28, 0, 0, 0, 0, 1, 1, 1, 1, 1,
		1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 3, 5, 3, 5, 3, 5,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0
	};

	internal static ReadOnlySpan<byte> SizesBcst => new byte[4834]
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 123, 138, 153,
		0, 0, 0, 124, 139, 154, 0, 0, 0, 123,
		138, 153, 0, 0, 0, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 123, 138, 153, 0, 0, 0, 124,
		139, 154, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 123, 138, 153, 0, 0, 0, 124, 139, 154,
		0, 0, 0, 123, 138, 153, 0, 0, 0, 124,
		139, 154, 0, 0, 0, 123, 138, 153, 0, 0,
		0, 124, 139, 154, 0, 0, 0, 123, 138, 153,
		0, 0, 0, 124, 139, 154, 0, 0, 0, 123,
		138, 153, 0, 0, 0, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 123, 138, 153,
		0, 0, 0, 124, 139, 154, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 114, 123, 138, 0, 0,
		0, 124, 139, 154, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 118, 133, 148, 121, 136, 151, 0,
		0, 0, 123, 138, 153, 0, 0, 0, 123, 138,
		153, 0, 0, 0, 123, 138, 153, 0, 0, 0,
		124, 139, 154, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 123, 138, 153, 0, 0, 0, 124, 139,
		154, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		123, 138, 153, 0, 0, 0, 124, 139, 154, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 123, 138,
		153, 0, 0, 0, 124, 139, 154, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 117, 132, 147, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 118,
		133, 148, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 117, 132, 147,
		0, 0, 0, 0, 118, 133, 148, 0, 0, 0,
		120, 135, 150, 0, 0, 0, 120, 135, 150, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 117, 132, 147, 120, 135, 150, 117, 132,
		147, 120, 135, 150, 0, 0, 0, 0, 117, 132,
		147, 0, 0, 0, 0, 118, 133, 148, 121, 136,
		151, 0, 0, 0, 0, 117, 132, 147, 0, 0,
		0, 0, 120, 135, 150, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 120, 135, 150, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 117, 132, 147, 0, 0, 0, 0, 0,
		123, 138, 153, 124, 139, 154, 0, 114, 123, 138,
		124, 139, 154, 0, 0, 0, 0, 0, 0, 0,
		123, 138, 153, 124, 139, 154, 0, 114, 123, 138,
		124, 139, 154, 0, 0, 0, 0, 0, 114, 123,
		138, 124, 139, 154, 111, 117, 132, 120, 135, 150,
		117, 132, 147, 120, 135, 150, 114, 123, 138, 124,
		139, 154, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 123, 138, 153, 0, 0, 0, 124,
		139, 154, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 123,
		138, 153, 0, 0, 0, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 120, 135, 150, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		117, 132, 147, 120, 135, 150, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 117, 132, 147, 120, 135, 150, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 124, 139, 154, 0, 0,
		0, 112, 118, 133, 121, 136, 151, 0, 0, 0,
		124, 139, 154, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 117, 132, 147, 120, 135,
		150, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 120,
		135, 150, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		127, 142, 157, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 117, 132,
		147, 0, 0, 0, 0, 120, 135, 150, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 123, 138, 153, 0, 0, 124, 139, 154, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 117, 132, 147, 120, 135, 150, 0, 0, 0,
		0, 117, 132, 147, 120, 135, 150, 0, 0, 0,
		0, 138, 153, 139, 154, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 118, 133, 148, 121, 136, 151, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 117, 132, 147, 120, 135,
		150, 117, 132, 147, 120, 135, 150, 0, 0, 0,
		126, 141, 158, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 120, 135, 150, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 118, 133, 148, 0, 0, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 132, 147, 135,
		150, 0, 0, 0, 121, 136, 151, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 118, 133, 148, 121, 136, 151, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 120,
		135, 150, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 118, 133, 148, 121, 136, 151, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 120,
		135, 150, 0, 0, 0, 118, 133, 148, 121, 136,
		151, 0, 0, 123, 138, 153, 124, 139, 154, 0,
		0, 117, 132, 147, 120, 135, 150, 0, 0, 0,
		0, 117, 132, 147, 120, 135, 150, 0, 0, 117,
		132, 147, 120, 135, 150, 0, 0, 0, 0, 117,
		132, 147, 120, 135, 150, 123, 138, 153, 124, 139,
		154, 0, 0, 123, 138, 153, 124, 139, 154, 0,
		0, 117, 132, 147, 117, 132, 147, 125, 140, 156,
		129, 144, 159, 0, 125, 140, 156, 0, 0, 0,
		0, 0, 0, 0, 117, 132, 147, 120, 135, 150,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 117, 132, 147, 120, 135, 150, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 0, 0,
		117, 132, 147, 120, 135, 150, 0, 0, 0, 117,
		132, 147, 120, 135, 150, 0, 0, 0, 123, 138,
		153, 123, 138, 153, 117, 132, 147, 120, 135, 150,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 120,
		135, 150, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 120,
		135, 150, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 120, 135, 150, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 123, 138, 153, 124,
		139, 154, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 123, 138, 153, 124,
		139, 154, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 123, 138, 153, 124, 139, 154,
		0, 0, 0, 0, 123, 138, 153, 124, 139, 154,
		0, 0, 0, 0, 123, 138, 153, 124, 139, 154,
		0, 0, 0, 0, 0, 0, 0, 0, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 123, 138, 153, 124, 139, 154,
		0, 0, 0, 0, 0, 0, 0, 0, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 119, 134,
		149, 119, 134, 149, 0, 0, 0, 0, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 123, 138,
		153, 124, 139, 154, 0, 0, 0, 0, 0, 0,
		0, 0, 123, 138, 153, 124, 139, 154, 0, 0,
		0, 0, 0, 0, 0, 0, 123, 138, 153, 124,
		139, 154, 0, 0, 0, 0, 0, 0, 0, 0,
		123, 138, 153, 124, 139, 154, 0, 0, 0, 0,
		117, 132, 147, 120, 135, 150, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 153, 154, 0, 0, 153, 154, 0,
		0, 0, 0, 153, 154, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 135, 150, 0, 139, 154,
		0, 0, 117, 132, 147, 120, 135, 150, 0, 0,
		123, 138, 153, 0, 0, 124, 139, 154, 0, 0,
		0, 0, 123, 138, 153, 0, 0, 0, 124, 139,
		154, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 117, 132, 147, 120,
		135, 150, 118, 133, 148, 121, 136, 151, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 138, 153, 139, 154, 117, 132, 147,
		120, 135, 150, 123, 138, 153, 124, 139, 154, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 132, 147, 135, 150,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 123, 138, 153, 124, 139, 154, 0, 0, 123,
		138, 153, 124, 139, 154, 0, 0, 123, 138, 153,
		124, 139, 154, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 123, 138, 153, 124, 139, 154, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 117, 132,
		147, 120, 135, 150, 0, 0, 0, 117, 132, 147,
		120, 135, 150, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 120, 135, 150, 0, 0, 0, 120, 135, 150,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 122, 137, 152, 0, 122, 137, 152,
		0, 0, 118, 133, 148, 124, 139, 154, 113, 122,
		137, 110, 113, 122, 113, 122, 137, 110, 113, 122,
		113, 122, 137, 110, 113, 122, 122, 137, 152, 122,
		137, 152, 123, 138, 153, 121, 136, 151, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 113, 122,
		137, 110, 113, 122, 113, 122, 137, 110, 113, 122,
		122, 137, 152, 122, 137, 152, 0, 0, 0, 0,
		117, 132, 147, 120, 135, 150, 0, 0, 116, 131,
		146, 115, 130, 145, 122, 137, 152, 0, 128, 143,
		155, 128, 143, 155, 0, 0, 128, 143, 155, 128,
		143, 155, 0, 0, 122, 137, 152, 122, 137, 152,
		122, 137, 152, 122, 137, 152, 122, 137, 152, 122,
		137, 152, 122, 137, 152, 122, 137, 152, 122, 137,
		152, 122, 137, 152, 122, 137, 152, 122, 137, 152,
		0, 0, 0, 0, 0, 0, 122, 137, 152, 122,
		137, 152, 122, 137, 152, 122, 137, 152, 122, 137,
		152, 122, 137, 152, 0, 0, 0, 0, 0, 0,
		122, 137, 152, 0, 122, 137, 152, 0, 122, 137,
		152, 0, 122, 137, 152, 0, 122, 137, 152, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 122, 137,
		152, 0, 122, 137, 152, 0, 122, 137, 152, 0,
		122, 137, 152, 0, 122, 137, 152, 0, 122, 137,
		152, 0, 122, 137, 152, 0, 122, 137, 152, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0
	};
}


using System;

internal static class InstructionOpCounts
{
	internal static ReadOnlySpan<byte> OpCount => new byte[4834]
	{
		0, 0, 0, 0, 0, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 1, 1, 1,
		1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 1, 1, 1, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 1, 1,
		1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 1, 1, 1, 1, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		0, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 0, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 0, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 0, 0, 2, 2, 2, 2, 2, 2,
		2, 1, 1, 1, 3, 3, 3, 1, 1, 1,
		3, 3, 3, 2, 2, 2, 2, 2, 2, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 1, 1, 1, 0,
		0, 0, 2, 2, 2, 0, 0, 0, 0, 0,
		0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 1, 1, 1, 0, 0, 0, 2, 2, 2,
		2, 2, 1, 2, 2, 2, 1, 1, 2, 2,
		2, 0, 0, 0, 1, 1, 1, 0, 0, 0,
		0, 1, 0, 0, 0, 0, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		1, 1, 0, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 2, 0, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
		1, 2, 2, 2, 2, 0, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 2, 2, 1,
		1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
		2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 2, 1,
		1, 2, 2, 1, 1, 1, 1, 1, 1, 1,
		1, 2, 2, 2, 0, 2, 2, 2, 2, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 2, 1,
		1, 1, 1, 1, 1, 2, 2, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 2, 2, 2, 2, 2,
		2, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2, 2, 2, 0, 0,
		0, 2, 2, 1, 1, 1, 1, 1, 1, 2,
		2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 2, 2, 2, 2, 2, 2, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		2, 2, 2, 1, 1, 1, 0, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 3, 2, 3, 2,
		2, 3, 2, 3, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 3, 2,
		3, 2, 2, 3, 2, 3, 2, 2, 2, 3,
		3, 3, 3, 2, 3, 3, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
		2, 3, 3, 3, 3, 3, 2, 3, 3, 3,
		3, 3, 2, 3, 3, 3, 3, 3, 2, 3,
		3, 2, 3, 3, 2, 3, 3, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 1, 1, 1, 1, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 1, 1, 1, 0, 0, 1, 1, 1, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 0, 0, 0, 0, 0, 0, 0, 0, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
		3, 3, 3, 3, 3, 2, 2, 2, 2, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 3, 3, 2, 3, 3, 2, 2,
		2, 2, 3, 2, 2, 2, 2, 3, 2, 3,
		3, 3, 3, 3, 2, 3, 3, 3, 3, 3,
		2, 3, 3, 3, 3, 3, 2, 3, 3, 3,
		3, 3, 2, 3, 3, 3, 3, 3, 2, 3,
		3, 3, 3, 3, 2, 3, 3, 3, 3, 3,
		2, 3, 3, 3, 3, 3, 2, 3, 3, 3,
		3, 3, 2, 3, 3, 3, 3, 3, 2, 3,
		3, 2, 3, 3, 2, 3, 3, 3, 3, 3,
		2, 3, 3, 3, 3, 3, 2, 3, 3, 2,
		3, 3, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 3, 3, 2, 3, 3,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 3, 3, 3, 3, 3, 2, 3, 3,
		3, 3, 3, 2, 3, 3, 2, 3, 3, 2,
		3, 3, 3, 3, 3, 2, 3, 3, 3, 3,
		3, 2, 3, 3, 2, 3, 3, 2, 3, 3,
		3, 3, 3, 2, 3, 3, 3, 3, 3, 2,
		3, 3, 2, 3, 3, 2, 3, 3, 3, 3,
		3, 2, 3, 3, 3, 3, 3, 2, 3, 3,
		2, 3, 3, 2, 2, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 3, 3, 3, 2, 2, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 3, 3, 3, 3, 3, 2,
		2, 3, 3, 3, 3, 3, 2, 2, 3, 3,
		3, 3, 3, 2, 2, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 3, 3, 3, 2, 3, 3,
		3, 3, 3, 2, 3, 3, 3, 3, 3, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 0, 0, 0, 2, 2,
		2, 2, 2, 2, 2, 2, 3, 2, 2, 2,
		2, 2, 2, 2, 2, 4, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 3, 3, 3, 3, 2, 3, 3, 2,
		3, 3, 2, 3, 3, 2, 3, 3, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 1, 1, 1, 1, 1, 1, 0, 2,
		2, 2, 3, 3, 3, 3, 3, 3, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 2, 2, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 2, 2, 2,
		2, 2, 1, 1, 1, 1, 1, 1, 0, 2,
		2, 2, 3, 3, 3, 3, 3, 3, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 1, 1, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 4, 4, 4, 4, 4, 3, 4, 4, 4,
		4, 4, 3, 4, 4, 3, 4, 4, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
		4, 4, 3, 4, 4, 4, 4, 4, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 2, 3, 3, 2, 3, 3, 2, 2, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 3, 3, 3, 3, 3, 2,
		2, 3, 3, 3, 3, 3, 2, 2, 3, 3,
		3, 3, 3, 3, 3, 3, 2, 2, 3, 3,
		3, 3, 3, 2, 2, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 3, 3, 3, 2, 2, 3,
		3, 3, 3, 3, 3, 3, 3, 2, 2, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 3, 3, 3, 3, 3, 2, 2, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 3, 3, 3, 3, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 3, 3, 3, 3, 3, 2,
		2, 3, 3, 3, 3, 3, 2, 2, 3, 3,
		3, 3, 3, 2, 2, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 3, 3, 3, 2, 2, 3,
		3, 3, 3, 3, 2, 2, 3, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 3, 3, 3, 3, 3, 2,
		2, 2, 2, 2, 3, 3, 3, 3, 3, 2,
		2, 3, 3, 2, 2, 3, 3, 2, 2, 3,
		3, 2, 2, 3, 3, 3, 3, 3, 2, 2,
		3, 3, 2, 2, 3, 3, 2, 2, 3, 3,
		2, 2, 3, 3, 2, 2, 3, 3, 2, 2,
		3, 3, 2, 2, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 2,
		2, 2, 2, 2, 3, 3, 3, 2, 2, 2,
		3, 3, 3, 2, 2, 2, 3, 3, 3, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 2, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 2, 3, 3,
		3, 3, 3, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
		3, 2, 3, 3, 3, 3, 3, 2, 3, 3,
		3, 3, 3, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 3, 3, 3, 2, 2,
		2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
		2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
		3, 3, 2, 3, 3, 3, 3, 3, 2, 3,
		3, 3, 3, 3, 3, 3, 3, 2, 3, 3,
		3, 3, 3, 2, 3, 3, 3, 3, 3, 3,
		3, 3, 2, 3, 3, 3, 3, 3, 3, 3,
		3, 2, 2, 2, 2, 2, 2, 2, 2, 3,
		3, 2, 2, 2, 2, 2, 2, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 2, 2, 2, 2, 2,
		2, 3, 3, 2, 2, 2, 2, 2, 2, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 2, 2,
		2, 2, 2, 2, 3, 3, 3, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 3, 3,
		3, 3, 2, 2, 2, 2, 2, 2, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		2, 2, 2, 2, 2, 2, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 2, 2, 2, 2, 3, 3, 2, 3,
		3, 3, 3, 3, 2, 2, 2, 3, 3, 3,
		3, 3, 2, 3, 3, 3, 3, 3, 2, 3,
		3, 3, 3, 3, 2, 3, 3, 3, 3, 3,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 3, 3, 2, 2, 2, 2, 2, 2, 3,
		3, 2, 2, 3, 3, 3, 3, 2, 2, 2,
		2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
		4, 4, 4, 4, 4, 4, 4, 4, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 4, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 4, 4, 3, 4, 4, 3, 4, 4,
		3, 4, 4, 3, 4, 4, 3, 3, 4, 4,
		4, 4, 4, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
		4, 4, 3, 3, 3, 3, 3, 4, 4, 3,
		3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 3, 3,
		4, 4, 4, 4, 3, 4, 4, 3, 3, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 3, 3, 3, 3, 3, 3, 4,
		4, 3, 3, 3, 3, 3, 3, 3, 3, 4,
		4, 4, 4, 4, 3, 3, 3, 3, 3, 4,
		4, 3, 3, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 3, 4, 4, 3, 4,
		3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		3, 4, 4, 4, 4, 4, 4, 5, 5, 5,
		5, 5, 5, 5, 5, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 3, 3, 3,
		3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 3, 3, 4,
		4, 4, 4, 4, 3, 4, 4, 4, 4, 4,
		3, 3, 3, 3, 4, 4, 4, 4, 4, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 4, 3, 3, 3, 3, 4, 4, 4, 4,
		4, 4, 4, 4, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 1, 1, 1, 1, 2, 2, 2, 2,
		2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
		1, 0, 0, 0, 1, 0, 1, 1, 2, 2,
		2, 3, 3, 3, 3, 3, 1, 1, 1, 1,
		0, 0, 0, 2, 2, 1, 1, 1, 1, 0,
		0, 0, 0, 0, 0, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 0, 0, 0,
		0, 0, 1, 1, 3, 3, 3, 3, 3, 3,
		3, 3, 0, 0, 0, 0, 0, 0, 1, 1,
		1, 0, 0, 3, 3, 3, 3, 4, 4, 4,
		4, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 3, 3,
		2, 2, 3, 2, 2, 3, 3, 3, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 3, 3, 2, 2,
		2, 2, 2, 2, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 2, 2, 2, 3, 3, 3,
		3, 4, 3, 3, 3, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 2, 2, 2, 2, 3, 3,
		3, 3, 2, 2, 2, 3, 3, 3, 3, 4,
		3, 3, 3, 4, 2, 2, 2, 3, 3, 3,
		3, 3, 2, 2, 2, 3, 3, 3, 3, 3,
		2, 0, 0, 2, 2, 1, 1, 1, 1, 1,
		1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 3, 3, 2,
		1, 1, 1, 1, 1, 1, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 1, 1, 1, 1, 1, 1, 1, 1, 2,
		2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
		3, 2, 2, 3, 3, 3, 2, 2, 3, 3,
		3, 3, 3, 2, 2, 2, 1, 1, 4, 4,
		3, 3, 3, 3, 2, 3, 3, 3, 3, 3,
		3, 2, 2, 2, 2, 3, 3, 3, 3, 3,
		3, 3, 2, 2, 3, 3, 3, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 2, 2, 2, 2, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 2, 2, 2, 2, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 2, 2, 2,
		2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 2, 1, 1, 1, 1, 1, 1, 1,
		1, 2, 2, 2, 2, 3, 3, 3, 3, 3,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		2, 2, 4, 3, 4, 4, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0
	};
}


using Iced.Intel;

internal static class InstructionUtils
{
	public static int GetAddressSizeInBytes(Register baseReg, Register indexReg, int displSize, CodeSize codeSize)
	{
		if ((Register.RAX <= baseReg && baseReg <= Register.R15) || (Register.RAX <= indexReg && indexReg <= Register.R15) || baseReg == Register.RIP)
		{
			return 8;
		}
		if ((Register.EAX <= baseReg && baseReg <= Register.R15D) || (Register.EAX <= indexReg && indexReg <= Register.R15D) || baseReg == Register.EIP)
		{
			return 4;
		}
		if ((Register.AX <= baseReg && baseReg <= Register.DI) || (Register.AX <= indexReg && indexReg <= Register.DI))
		{
			return 2;
		}
		if (displSize == 2 || displSize == 4 || displSize == 8)
		{
			return displSize;
		}
		return codeSize switch
		{
			CodeSize.Code64 => 8, 
			CodeSize.Code32 => 4, 
			CodeSize.Code16 => 2, 
			_ => 8, 
		};
	}
}


internal enum MandatoryPrefixByte : uint
{
	None,
	P66,
	PF3,
	PF2
}


using Iced.Intel;

internal readonly struct MemoryOperand
{
	public readonly Register SegmentPrefix;

	public readonly Register Base;

	public readonly Register Index;

	public readonly int Scale;

	public readonly long Displacement;

	public readonly int DisplSize;

	public readonly bool IsBroadcast;

	public MemoryOperand(Register @base, Register index, int scale, long displacement, int displSize, bool isBroadcast, Register segmentPrefix)
	{
		SegmentPrefix = segmentPrefix;
		Base = @base;
		Index = index;
		Scale = scale;
		Displacement = displacement;
		DisplSize = displSize;
		IsBroadcast = isBroadcast;
	}

	public MemoryOperand(Register @base, Register index, int scale, bool isBroadcast, Register segmentPrefix)
	{
		SegmentPrefix = segmentPrefix;
		Base = @base;
		Index = index;
		Scale = scale;
		Displacement = 0L;
		DisplSize = 0;
		IsBroadcast = isBroadcast;
	}

	public MemoryOperand(Register @base, long displacement, int displSize, bool isBroadcast, Register segmentPrefix)
	{
		SegmentPrefix = segmentPrefix;
		Base = @base;
		Index = Register.None;
		Scale = 1;
		Displacement = displacement;
		DisplSize = displSize;
		IsBroadcast = isBroadcast;
	}

	public MemoryOperand(Register index, int scale, long displacement, int displSize, bool isBroadcast, Register segmentPrefix)
	{
		SegmentPrefix = segmentPrefix;
		Base = Register.None;
		Index = index;
		Scale = scale;
		Displacement = displacement;
		DisplSize = displSize;
		IsBroadcast = isBroadcast;
	}

	public MemoryOperand(Register @base, long displacement, bool isBroadcast, Register segmentPrefix)
	{
		SegmentPrefix = segmentPrefix;
		Base = @base;
		Index = Register.None;
		Scale = 1;
		Displacement = displacement;
		DisplSize = 1;
		IsBroadcast = isBroadcast;
	}

	public MemoryOperand(Register @base, Register index, int scale, long displacement, int displSize)
	{
		SegmentPrefix = Register.None;
		Base = @base;
		Index = index;
		Scale = scale;
		Displacement = displacement;
		DisplSize = displSize;
		IsBroadcast = false;
	}

	public MemoryOperand(Register @base, Register index, int scale)
	{
		SegmentPrefix = Register.None;
		Base = @base;
		Index = index;
		Scale = scale;
		Displacement = 0L;
		DisplSize = 0;
		IsBroadcast = false;
	}

	public MemoryOperand(Register @base, Register index)
	{
		SegmentPrefix = Register.None;
		Base = @base;
		Index = index;
		Scale = 1;
		Displacement = 0L;
		DisplSize = 0;
		IsBroadcast = false;
	}

	public MemoryOperand(Register @base, long displacement, int displSize)
	{
		SegmentPrefix = Register.None;
		Base = @base;
		Index = Register.None;
		Scale = 1;
		Displacement = displacement;
		DisplSize = displSize;
		IsBroadcast = false;
	}

	public MemoryOperand(Register index, int scale, long displacement, int displSize)
	{
		SegmentPrefix = Register.None;
		Base = Register.None;
		Index = index;
		Scale = scale;
		Displacement = displacement;
		DisplSize = displSize;
		IsBroadcast = false;
	}

	public MemoryOperand(Register @base, long displacement)
	{
		SegmentPrefix = Register.None;
		Base = @base;
		Index = Register.None;
		Scale = 1;
		Displacement = displacement;
		DisplSize = 1;
		IsBroadcast = false;
	}

	public MemoryOperand(Register @base)
	{
		SegmentPrefix = Register.None;
		Base = @base;
		Index = Register.None;
		Scale = 1;
		Displacement = 0L;
		DisplSize = 0;
		IsBroadcast = false;
	}

	public MemoryOperand(ulong displacement, int displSize)
	{
		SegmentPrefix = Register.None;
		Base = Register.None;
		Index = Register.None;
		Scale = 1;
		Displacement = (long)displacement;
		DisplSize = displSize;
		IsBroadcast = false;
	}
}


internal enum MemorySize
{
	Unknown,
	UInt8,
	UInt16,
	UInt32,
	UInt52,
	UInt64,
	UInt128,
	UInt256,
	UInt512,
	Int8,
	Int16,
	Int32,
	Int64,
	Int128,
	Int256,
	Int512,
	SegPtr16,
	SegPtr32,
	SegPtr64,
	WordOffset,
	DwordOffset,
	QwordOffset,
	Bound16_WordWord,
	Bound32_DwordDword,
	Bnd32,
	Bnd64,
	Fword6,
	Fword10,
	Float16,
	Float32,
	Float64,
	Float80,
	Float128,
	BFloat16,
	FpuEnv14,
	FpuEnv28,
	FpuState94,
	FpuState108,
	Fxsave_512Byte,
	Fxsave64_512Byte,
	Xsave,
	Xsave64,
	Bcd,
	Tilecfg,
	Tile,
	SegmentDescSelector,
	KLHandleAes128,
	KLHandleAes256,
	Packed16_UInt8,
	Packed16_Int8,
	Packed32_UInt8,
	Packed32_Int8,
	Packed32_UInt16,
	Packed32_Int16,
	Packed32_Float16,
	Packed32_BFloat16,
	Packed64_UInt8,
	Packed64_Int8,
	Packed64_UInt16,
	Packed64_Int16,
	Packed64_UInt32,
	Packed64_Int32,
	Packed64_Float16,
	Packed64_Float32,
	Packed128_UInt8,
	Packed128_Int8,
	Packed128_UInt16,
	Packed128_Int16,
	Packed128_UInt32,
	Packed128_Int32,
	Packed128_UInt52,
	Packed128_UInt64,
	Packed128_Int64,
	Packed128_Float16,
	Packed128_Float32,
	Packed128_Float64,
	Packed128_2xFloat16,
	Packed128_2xBFloat16,
	Packed256_UInt8,
	Packed256_Int8,
	Packed256_UInt16,
	Packed256_Int16,
	Packed256_UInt32,
	Packed256_Int32,
	Packed256_UInt52,
	Packed256_UInt64,
	Packed256_Int64,
	Packed256_UInt128,
	Packed256_Int128,
	Packed256_Float16,
	Packed256_Float32,
	Packed256_Float64,
	Packed256_Float128,
	Packed256_2xFloat16,
	Packed256_2xBFloat16,
	Packed512_UInt8,
	Packed512_Int8,
	Packed512_UInt16,
	Packed512_Int16,
	Packed512_UInt32,
	Packed512_Int32,
	Packed512_UInt52,
	Packed512_UInt64,
	Packed512_Int64,
	Packed512_UInt128,
	Packed512_Float16,
	Packed512_Float32,
	Packed512_Float64,
	Packed512_2xFloat16,
	Packed512_2xBFloat16,
	Broadcast32_Float16,
	Broadcast64_UInt32,
	Broadcast64_Int32,
	Broadcast64_Float16,
	Broadcast64_Float32,
	Broadcast128_Int16,
	Broadcast128_UInt16,
	Broadcast128_UInt32,
	Broadcast128_Int32,
	Broadcast128_UInt52,
	Broadcast128_UInt64,
	Broadcast128_Int64,
	Broadcast128_Float16,
	Broadcast128_Float32,
	Broadcast128_Float64,
	Broadcast128_2xInt16,
	Broadcast128_2xInt32,
	Broadcast128_2xUInt32,
	Broadcast128_2xFloat16,
	Broadcast128_2xBFloat16,
	Broadcast256_Int16,
	Broadcast256_UInt16,
	Broadcast256_UInt32,
	Broadcast256_Int32,
	Broadcast256_UInt52,
	Broadcast256_UInt64,
	Broadcast256_Int64,
	Broadcast256_Float16,
	Broadcast256_Float32,
	Broadcast256_Float64,
	Broadcast256_2xInt16,
	Broadcast256_2xInt32,
	Broadcast256_2xUInt32,
	Broadcast256_2xFloat16,
	Broadcast256_2xBFloat16,
	Broadcast512_Int16,
	Broadcast512_UInt16,
	Broadcast512_UInt32,
	Broadcast512_Int32,
	Broadcast512_UInt52,
	Broadcast512_UInt64,
	Broadcast512_Int64,
	Broadcast512_Float16,
	Broadcast512_Float32,
	Broadcast512_Float64,
	Broadcast512_2xFloat16,
	Broadcast512_2xInt16,
	Broadcast512_2xUInt32,
	Broadcast512_2xInt32,
	Broadcast512_2xBFloat16
}


using System;
using Iced.Intel;

internal static class MemorySizeExtensions
{
	internal static readonly MemorySizeInfo[] MemorySizeInfos = GetMemorySizeInfos();

	public static bool IsBroadcast(this MemorySize memorySize)
	{
		return memorySize >= MemorySize.Broadcast32_Float16;
	}

	private static MemorySizeInfo[] GetMemorySizeInfos()
	{
		ReadOnlySpan<byte> readOnlySpan = new byte[480]
		{
			0, 0, 0, 1, 33, 0, 2, 66, 0, 3,
			99, 0, 4, 165, 0, 5, 165, 0, 6, 8,
			1, 7, 74, 1, 8, 140, 1, 9, 33, 128,
			10, 66, 128, 11, 99, 128, 12, 165, 128, 13,
			8, 129, 14, 74, 129, 15, 140, 129, 16, 99,
			0, 17, 132, 0, 18, 198, 0, 19, 66, 0,
			20, 99, 0, 21, 165, 0, 2, 67, 0, 3,
			101, 0, 24, 165, 0, 25, 8, 1, 26, 132,
			0, 27, 198, 0, 28, 66, 128, 29, 99, 128,
			30, 165, 128, 31, 198, 128, 32, 8, 129, 33,
			66, 128, 34, 231, 0, 35, 41, 1, 36, 173,
			1, 37, 206, 1, 38, 239, 1, 39, 239, 1,
			40, 0, 0, 41, 0, 0, 42, 198, 128, 43,
			140, 1, 44, 0, 0, 45, 198, 0, 46, 107,
			1, 47, 140, 1, 1, 34, 0, 9, 34, 128,
			1, 35, 0, 9, 35, 128, 2, 67, 0, 10,
			67, 128, 28, 67, 128, 33, 67, 128, 1, 37,
			0, 9, 37, 128, 2, 69, 0, 10, 69, 128,
			3, 101, 0, 11, 101, 128, 28, 69, 128, 29,
			101, 128, 1, 40, 0, 9, 40, 128, 2, 72,
			0, 10, 72, 128, 3, 104, 0, 11, 104, 128,
			4, 168, 0, 5, 168, 0, 12, 168, 128, 28,
			72, 128, 29, 104, 128, 30, 168, 128, 54, 104,
			128, 55, 104, 128, 1, 42, 0, 9, 42, 128,
			2, 74, 0, 10, 74, 128, 3, 106, 0, 11,
			106, 128, 4, 170, 0, 5, 170, 0, 12, 170,
			128, 6, 10, 1, 13, 10, 129, 28, 74, 128,
			29, 106, 128, 30, 170, 128, 32, 10, 129, 54,
			106, 128, 55, 106, 128, 1, 44, 0, 9, 44,
			128, 2, 76, 0, 10, 76, 128, 3, 108, 0,
			11, 108, 128, 4, 172, 0, 5, 172, 0, 12,
			172, 128, 6, 12, 1, 28, 76, 128, 29, 108,
			128, 30, 172, 128, 54, 108, 128, 55, 108, 128,
			28, 66, 128, 3, 99, 0, 11, 99, 128, 28,
			66, 128, 29, 99, 128, 10, 66, 0, 2, 66,
			0, 3, 99, 0, 11, 99, 128, 4, 165, 0,
			5, 165, 0, 12, 165, 128, 28, 66, 128, 29,
			99, 128, 30, 165, 128, 53, 99, 128, 61, 165,
			128, 60, 165, 0, 54, 99, 128, 55, 99, 128,
			10, 66, 0, 2, 66, 0, 3, 99, 0, 11,
			99, 128, 4, 165, 0, 5, 165, 0, 12, 165,
			128, 28, 66, 128, 29, 99, 128, 30, 165, 128,
			53, 99, 128, 61, 165, 128, 60, 165, 0, 54,
			99, 128, 55, 99, 128, 10, 66, 0, 2, 66,
			0, 3, 99, 0, 11, 99, 128, 4, 165, 0,
			5, 165, 0, 12, 165, 128, 28, 66, 128, 29,
			99, 128, 30, 165, 128, 54, 99, 128, 53, 99,
			128, 60, 165, 0, 61, 165, 128, 55, 99, 128
		};
		ushort[] array = new ushort[16]
		{
			0, 1, 2, 4, 6, 8, 10, 14, 16, 28,
			32, 48, 64, 94, 108, 512
		};
		MemorySizeInfo[] array2 = new MemorySizeInfo[160];
		int num = 0;
		int num2 = 0;
		while (num < array2.Length)
		{
			MemorySize elementType = (MemorySize)readOnlySpan[num2];
			uint num3 = (uint)((readOnlySpan[num2 + 2] << 8) | readOnlySpan[num2 + 1]);
			ushort size = array[num3 & 0x1F];
			ushort elementSize = array[(num3 >> 5) & 0x1F];
			array2[num] = new MemorySizeInfo((MemorySize)num, size, elementSize, elementType, (num3 & 0x8000) != 0, num >= 110);
			num++;
			num2 += 3;
		}
		return array2;
	}

	public static MemorySizeInfo GetInfo(this MemorySize memorySize)
	{
		MemorySizeInfo[] memorySizeInfos = MemorySizeInfos;
		if ((uint)memorySize >= (uint)memorySizeInfos.Length)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_memorySize();
		}
		return memorySizeInfos[(int)memorySize];
	}

	public static int GetSize(this MemorySize memorySize)
	{
		return memorySize.GetInfo().Size;
	}

	public static int GetElementSize(this MemorySize memorySize)
	{
		return memorySize.GetInfo().ElementSize;
	}

	public static MemorySize GetElementType(this MemorySize memorySize)
	{
		return memorySize.GetInfo().ElementType;
	}

	public static MemorySizeInfo GetElementTypeInfo(this MemorySize memorySize)
	{
		return memorySize.GetInfo().ElementType.GetInfo();
	}

	public static bool IsSigned(this MemorySize memorySize)
	{
		return memorySize.GetInfo().IsSigned;
	}

	public static bool IsPacked(this MemorySize memorySize)
	{
		return memorySize.GetInfo().IsPacked;
	}

	public static int GetElementCount(this MemorySize memorySize)
	{
		return memorySize.GetInfo().ElementCount;
	}
}


using Iced.Intel;

internal readonly struct MemorySizeInfo
{
	private readonly ushort size;

	private readonly ushort elementSize;

	private readonly byte memorySize;

	private readonly byte elementType;

	private readonly bool isSigned;

	private readonly bool isBroadcast;

	public MemorySize MemorySize => (MemorySize)memorySize;

	public int Size => size;

	public int ElementSize => elementSize;

	public MemorySize ElementType => (MemorySize)elementType;

	public bool IsSigned => isSigned;

	public bool IsBroadcast => isBroadcast;

	public bool IsPacked => elementSize < size;

	public int ElementCount
	{
		get
		{
			if (elementSize != size)
			{
				return size / elementSize;
			}
			return 1;
		}
	}

	public MemorySizeInfo(MemorySize memorySize, int size, int elementSize, MemorySize elementType, bool isSigned, bool isBroadcast)
	{
		if (size < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_size();
		}
		if (elementSize < 0)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_elementSize();
		}
		if (elementSize > size)
		{
			ThrowHelper.ThrowArgumentOutOfRangeException_elementSize();
		}
		this.memorySize = (byte)memorySize;
		this.size = (ushort)size;
		this.elementSize = (ushort)elementSize;
		this.elementType = (byte)elementType;
		this.isSigned = isSigned;
		this.isBroadcast = isBroadcast;
	}
}


internal enum Mnemonic
{
	INVALID,
	Aaa,
	Aad,
	Aam,
	Aas,
	Adc,
	Adcx,
	Add,
	Addpd,
	Addps,
	Addsd,
	Addss,
	Addsubpd,
	Addsubps,
	Adox,
	Aesdec,
	Aesdeclast,
	Aesenc,
	Aesenclast,
	Aesimc,
	Aeskeygenassist,
	And,
	Andn,
	Andnpd,
	Andnps,
	Andpd,
	Andps,
	Arpl,
	Bextr,
	Blcfill,
	Blci,
	Blcic,
	Blcmsk,
	Blcs,
	Blendpd,
	Blendps,
	Blendvpd,
	Blendvps,
	Blsfill,
	Blsi,
	Blsic,
	Blsmsk,
	Blsr,
	Bndcl,
	Bndcn,
	Bndcu,
	Bndldx,
	Bndmk,
	Bndmov,
	Bndstx,
	Bound,
	Bsf,
	Bsr,
	Bswap,
	Bt,
	Btc,
	Btr,
	Bts,
	Bzhi,
	Call,
	Cbw,
	Cdq,
	Cdqe,
	Cl1invmb,
	Clac,
	Clc,
	Cld,
	Cldemote,
	Clflush,
	Clflushopt,
	Clgi,
	Cli,
	Clrssbsy,
	Clts,
	Clwb,
	Clzero,
	Cmc,
	Cmova,
	Cmovae,
	Cmovb,
	Cmovbe,
	Cmove,
	Cmovg,
	Cmovge,
	Cmovl,
	Cmovle,
	Cmovne,
	Cmovno,
	Cmovnp,
	Cmovns,
	Cmovo,
	Cmovp,
	Cmovs,
	Cmp,
	Cmppd,
	Cmpps,
	Cmpsb,
	Cmpsd,
	Cmpsq,
	Cmpss,
	Cmpsw,
	Cmpxchg,
	Cmpxchg16b,
	Cmpxchg8b,
	Comisd,
	Comiss,
	Cpuid,
	Cqo,
	Crc32,
	Cvtdq2pd,
	Cvtdq2ps,
	Cvtpd2dq,
	Cvtpd2pi,
	Cvtpd2ps,
	Cvtpi2pd,
	Cvtpi2ps,
	Cvtps2dq,
	Cvtps2pd,
	Cvtps2pi,
	Cvtsd2si,
	Cvtsd2ss,
	Cvtsi2sd,
	Cvtsi2ss,
	Cvtss2sd,
	Cvtss2si,
	Cvttpd2dq,
	Cvttpd2pi,
	Cvttps2dq,
	Cvttps2pi,
	Cvttsd2si,
	Cvttss2si,
	Cwd,
	Cwde,
	Daa,
	Das,
	Db,
	Dd,
	Dec,
	Div,
	Divpd,
	Divps,
	Divsd,
	Divss,
	Dppd,
	Dpps,
	Dq,
	Dw,
	Emms,
	Encls,
	Enclu,
	Enclv,
	Endbr32,
	Endbr64,
	Enqcmd,
	Enqcmds,
	Enter,
	Extractps,
	Extrq,
	F2xm1,
	Fabs,
	Fadd,
	Faddp,
	Fbld,
	Fbstp,
	Fchs,
	Fclex,
	Fcmovb,
	Fcmovbe,
	Fcmove,
	Fcmovnb,
	Fcmovnbe,
	Fcmovne,
	Fcmovnu,
	Fcmovu,
	Fcom,
	Fcomi,
	Fcomip,
	Fcomp,
	Fcompp,
	Fcos,
	Fdecstp,
	Fdisi,
	Fdiv,
	Fdivp,
	Fdivr,
	Fdivrp,
	Femms,
	Feni,
	Ffree,
	Ffreep,
	Fiadd,
	Ficom,
	Ficomp,
	Fidiv,
	Fidivr,
	Fild,
	Fimul,
	Fincstp,
	Finit,
	Fist,
	Fistp,
	Fisttp,
	Fisub,
	Fisubr,
	Fld,
	Fld1,
	Fldcw,
	Fldenv,
	Fldl2e,
	Fldl2t,
	Fldlg2,
	Fldln2,
	Fldpi,
	Fldz,
	Fmul,
	Fmulp,
	Fnclex,
	Fndisi,
	Fneni,
	Fninit,
	Fnop,
	Fnsave,
	Fnsetpm,
	Fnstcw,
	Fnstenv,
	Fnstsw,
	Fpatan,
	Fprem,
	Fprem1,
	Fptan,
	Frndint,
	Frstor,
	Frstpm,
	Fsave,
	Fscale,
	Fsetpm,
	Fsin,
	Fsincos,
	Fsqrt,
	Fst,
	Fstcw,
	Fstdw,
	Fstenv,
	Fstp,
	Fstpnce,
	Fstsg,
	Fstsw,
	Fsub,
	Fsubp,
	Fsubr,
	Fsubrp,
	Ftst,
	Fucom,
	Fucomi,
	Fucomip,
	Fucomp,
	Fucompp,
	Fxam,
	Fxch,
	Fxrstor,
	Fxrstor64,
	Fxsave,
	Fxsave64,
	Fxtract,
	Fyl2x,
	Fyl2xp1,
	Getsec,
	Gf2p8affineinvqb,
	Gf2p8affineqb,
	Gf2p8mulb,
	Haddpd,
	Haddps,
	Hlt,
	Hsubpd,
	Hsubps,
	Ibts,
	Idiv,
	Imul,
	In,
	Inc,
	Incsspd,
	Incsspq,
	Insb,
	Insd,
	Insertps,
	Insertq,
	Insw,
	Int,
	Int1,
	Into,
	Invd,
	Invept,
	Invlpg,
	Invlpga,
	Invpcid,
	Invvpid,
	Iret,
	Ja,
	Jae,
	Jb,
	Jbe,
	Jcxz,
	Je,
	Jecxz,
	Jg,
	Jge,
	Jl,
	Jle,
	Jmp,
	Jmpe,
	Jne,
	Jno,
	Jnp,
	Jns,
	Jo,
	Jp,
	Jrcxz,
	Js,
	Kaddb,
	Kaddd,
	Kaddq,
	Kaddw,
	Kandb,
	Kandd,
	Kandnb,
	Kandnd,
	Kandnq,
	Kandnw,
	Kandq,
	Kandw,
	Kmovb,
	Kmovd,
	Kmovq,
	Kmovw,
	Knotb,
	Knotd,
	Knotq,
	Knotw,
	Korb,
	Kord,
	Korq,
	Kortestb,
	Kortestd,
	Kortestq,
	Kortestw,
	Korw,
	Kshiftlb,
	Kshiftld,
	Kshiftlq,
	Kshiftlw,
	Kshiftrb,
	Kshiftrd,
	Kshiftrq,
	Kshiftrw,
	Ktestb,
	Ktestd,
	Ktestq,
	Ktestw,
	Kunpckbw,
	Kunpckdq,
	Kunpckwd,
	Kxnorb,
	Kxnord,
	Kxnorq,
	Kxnorw,
	Kxorb,
	Kxord,
	Kxorq,
	Kxorw,
	Lahf,
	Lar,
	Lddqu,
	Ldmxcsr,
	Lds,
	Lea,
	Leave,
	Les,
	Lfence,
	Lfs,
	Lgdt,
	Lgs,
	Lidt,
	Lldt,
	Llwpcb,
	Lmsw,
	Loadall,
	Lodsb,
	Lodsd,
	Lodsq,
	Lodsw,
	Loop,
	Loope,
	Loopne,
	Lsl,
	Lss,
	Ltr,
	Lwpins,
	Lwpval,
	Lzcnt,
	Maskmovdqu,
	Maskmovq,
	Maxpd,
	Maxps,
	Maxsd,
	Maxss,
	Mcommit,
	Mfence,
	Minpd,
	Minps,
	Minsd,
	Minss,
	Monitor,
	Monitorx,
	Montmul,
	Mov,
	Movapd,
	Movaps,
	Movbe,
	Movd,
	Movddup,
	Movdir64b,
	Movdiri,
	Movdq2q,
	Movdqa,
	Movdqu,
	Movhlps,
	Movhpd,
	Movhps,
	Movlhps,
	Movlpd,
	Movlps,
	Movmskpd,
	Movmskps,
	Movntdq,
	Movntdqa,
	Movnti,
	Movntpd,
	Movntps,
	Movntq,
	Movntsd,
	Movntss,
	Movq,
	Movq2dq,
	Movsb,
	Movsd,
	Movshdup,
	Movsldup,
	Movsq,
	Movss,
	Movsw,
	Movsx,
	Movsxd,
	Movupd,
	Movups,
	Movzx,
	Mpsadbw,
	Mul,
	Mulpd,
	Mulps,
	Mulsd,
	Mulss,
	Mulx,
	Mwait,
	Mwaitx,
	Neg,
	Nop,
	Not,
	Or,
	Orpd,
	Orps,
	Out,
	Outsb,
	Outsd,
	Outsw,
	Pabsb,
	Pabsd,
	Pabsw,
	Packssdw,
	Packsswb,
	Packusdw,
	Packuswb,
	Paddb,
	Paddd,
	Paddq,
	Paddsb,
	Paddsw,
	Paddusb,
	Paddusw,
	Paddw,
	Palignr,
	Pand,
	Pandn,
	Pause,
	Pavgb,
	Pavgusb,
	Pavgw,
	Pblendvb,
	Pblendw,
	Pclmulqdq,
	Pcmpeqb,
	Pcmpeqd,
	Pcmpeqq,
	Pcmpeqw,
	Pcmpestri,
	Pcmpestri64,
	Pcmpestrm,
	Pcmpestrm64,
	Pcmpgtb,
	Pcmpgtd,
	Pcmpgtq,
	Pcmpgtw,
	Pcmpistri,
	Pcmpistrm,
	Pcommit,
	Pconfig,
	Pdep,
	Pext,
	Pextrb,
	Pextrd,
	Pextrq,
	Pextrw,
	Pf2id,
	Pf2iw,
	Pfacc,
	Pfadd,
	Pfcmpeq,
	Pfcmpge,
	Pfcmpgt,
	Pfmax,
	Pfmin,
	Pfmul,
	Pfnacc,
	Pfpnacc,
	Pfrcp,
	Pfrcpit1,
	Pfrcpit2,
	Pfrcpv,
	Pfrsqit1,
	Pfrsqrt,
	Pfrsqrtv,
	Pfsub,
	Pfsubr,
	Phaddd,
	Phaddsw,
	Phaddw,
	Phminposuw,
	Phsubd,
	Phsubsw,
	Phsubw,
	Pi2fd,
	Pi2fw,
	Pinsrb,
	Pinsrd,
	Pinsrq,
	Pinsrw,
	Pmaddubsw,
	Pmaddwd,
	Pmaxsb,
	Pmaxsd,
	Pmaxsw,
	Pmaxub,
	Pmaxud,
	Pmaxuw,
	Pminsb,
	Pminsd,
	Pminsw,
	Pminub,
	Pminud,
	Pminuw,
	Pmovmskb,
	Pmovsxbd,
	Pmovsxbq,
	Pmovsxbw,
	Pmovsxdq,
	Pmovsxwd,
	Pmovsxwq,
	Pmovzxbd,
	Pmovzxbq,
	Pmovzxbw,
	Pmovzxdq,
	Pmovzxwd,
	Pmovzxwq,
	Pmuldq,
	Pmulhrsw,
	Pmulhrw,
	Pmulhuw,
	Pmulhw,
	Pmulld,
	Pmullw,
	Pmuludq,
	Pop,
	Popa,
	Popcnt,
	Popf,
	Por,
	Prefetch,
	Prefetchnta,
	Prefetcht0,
	Prefetcht1,
	Prefetcht2,
	Prefetchw,
	Prefetchwt1,
	Psadbw,
	Pshufb,
	Pshufd,
	Pshufhw,
	Pshuflw,
	Pshufw,
	Psignb,
	Psignd,
	Psignw,
	Pslld,
	Pslldq,
	Psllq,
	Psllw,
	Psrad,
	Psraw,
	Psrld,
	Psrldq,
	Psrlq,
	Psrlw,
	Psubb,
	Psubd,
	Psubq,
	Psubsb,
	Psubsw,
	Psubusb,
	Psubusw,
	Psubw,
	Pswapd,
	Ptest,
	Ptwrite,
	Punpckhbw,
	Punpckhdq,
	Punpckhqdq,
	Punpckhwd,
	Punpcklbw,
	Punpckldq,
	Punpcklqdq,
	Punpcklwd,
	Push,
	Pusha,
	Pushf,
	Pxor,
	Rcl,
	Rcpps,
	Rcpss,
	Rcr,
	Rdfsbase,
	Rdgsbase,
	Rdmsr,
	Rdpid,
	Rdpkru,
	Rdpmc,
	Rdpru,
	Rdrand,
	Rdseed,
	Rdsspd,
	Rdsspq,
	Rdtsc,
	Rdtscp,
	Reservednop,
	Ret,
	Retf,
	Rol,
	Ror,
	Rorx,
	Roundpd,
	Roundps,
	Roundsd,
	Roundss,
	Rsm,
	Rsqrtps,
	Rsqrtss,
	Rstorssp,
	Sahf,
	Sal,
	Salc,
	Sar,
	Sarx,
	Saveprevssp,
	Sbb,
	Scasb,
	Scasd,
	Scasq,
	Scasw,
	Seta,
	Setae,
	Setb,
	Setbe,
	Sete,
	Setg,
	Setge,
	Setl,
	Setle,
	Setne,
	Setno,
	Setnp,
	Setns,
	Seto,
	Setp,
	Sets,
	Setssbsy,
	Sfence,
	Sgdt,
	Sha1msg1,
	Sha1msg2,
	Sha1nexte,
	Sha1rnds4,
	Sha256msg1,
	Sha256msg2,
	Sha256rnds2,
	Shl,
	Shld,
	Shlx,
	Shr,
	Shrd,
	Shrx,
	Shufpd,
	Shufps,
	Sidt,
	Skinit,
	Sldt,
	Slwpcb,
	Smsw,
	Sqrtpd,
	Sqrtps,
	Sqrtsd,
	Sqrtss,
	Stac,
	Stc,
	Std,
	Stgi,
	Sti,
	Stmxcsr,
	Stosb,
	Stosd,
	Stosq,
	Stosw,
	Str,
	Sub,
	Subpd,
	Subps,
	Subsd,
	Subss,
	Swapgs,
	Syscall,
	Sysenter,
	Sysexit,
	Sysret,
	T1mskc,
	Test,
	Tpause,
	Tzcnt,
	Tzmsk,
	Ucomisd,
	Ucomiss,
	Ud0,
	Ud1,
	Ud2,
	Umonitor,
	Umov,
	Umwait,
	Unpckhpd,
	Unpckhps,
	Unpcklpd,
	Unpcklps,
	V4fmaddps,
	V4fmaddss,
	V4fnmaddps,
	V4fnmaddss,
	Vaddpd,
	Vaddps,
	Vaddsd,
	Vaddss,
	Vaddsubpd,
	Vaddsubps,
	Vaesdec,
	Vaesdeclast,
	Vaesenc,
	Vaesenclast,
	Vaesimc,
	Vaeskeygenassist,
	Valignd,
	Valignq,
	Vandnpd,
	Vandnps,
	Vandpd,
	Vandps,
	Vblendmpd,
	Vblendmps,
	Vblendpd,
	Vblendps,
	Vblendvpd,
	Vblendvps,
	Vbroadcastf128,
	Vbroadcastf32x2,
	Vbroadcastf32x4,
	Vbroadcastf32x8,
	Vbroadcastf64x2,
	Vbroadcastf64x4,
	Vbroadcasti128,
	Vbroadcasti32x2,
	Vbroadcasti32x4,
	Vbroadcasti32x8,
	Vbroadcasti64x2,
	Vbroadcasti64x4,
	Vbroadcastsd,
	Vbroadcastss,
	Vcmppd,
	Vcmpps,
	Vcmpsd,
	Vcmpss,
	Vcomisd,
	Vcomiss,
	Vcompresspd,
	Vcompressps,
	Vcvtdq2pd,
	Vcvtdq2ps,
	Vcvtne2ps2bf16,
	Vcvtneps2bf16,
	Vcvtpd2dq,
	Vcvtpd2ps,
	Vcvtpd2qq,
	Vcvtpd2udq,
	Vcvtpd2uqq,
	Vcvtph2ps,
	Vcvtps2dq,
	Vcvtps2pd,
	Vcvtps2ph,
	Vcvtps2qq,
	Vcvtps2udq,
	Vcvtps2uqq,
	Vcvtqq2pd,
	Vcvtqq2ps,
	Vcvtsd2si,
	Vcvtsd2ss,
	Vcvtsd2usi,
	Vcvtsi2sd,
	Vcvtsi2ss,
	Vcvtss2sd,
	Vcvtss2si,
	Vcvtss2usi,
	Vcvttpd2dq,
	Vcvttpd2qq,
	Vcvttpd2udq,
	Vcvttpd2uqq,
	Vcvttps2dq,
	Vcvttps2qq,
	Vcvttps2udq,
	Vcvttps2uqq,
	Vcvttsd2si,
	Vcvttsd2usi,
	Vcvttss2si,
	Vcvttss2usi,
	Vcvtudq2pd,
	Vcvtudq2ps,
	Vcvtuqq2pd,
	Vcvtuqq2ps,
	Vcvtusi2sd,
	Vcvtusi2ss,
	Vdbpsadbw,
	Vdivpd,
	Vdivps,
	Vdivsd,
	Vdivss,
	Vdpbf16ps,
	Vdppd,
	Vdpps,
	Verr,
	Verw,
	Vexp2pd,
	Vexp2ps,
	Vexpandpd,
	Vexpandps,
	Vextractf128,
	Vextractf32x4,
	Vextractf32x8,
	Vextractf64x2,
	Vextractf64x4,
	Vextracti128,
	Vextracti32x4,
	Vextracti32x8,
	Vextracti64x2,
	Vextracti64x4,
	Vextractps,
	Vfixupimmpd,
	Vfixupimmps,
	Vfixupimmsd,
	Vfixupimmss,
	Vfmadd132pd,
	Vfmadd132ps,
	Vfmadd132sd,
	Vfmadd132ss,
	Vfmadd213pd,
	Vfmadd213ps,
	Vfmadd213sd,
	Vfmadd213ss,
	Vfmadd231pd,
	Vfmadd231ps,
	Vfmadd231sd,
	Vfmadd231ss,
	Vfmaddpd,
	Vfmaddps,
	Vfmaddsd,
	Vfmaddss,
	Vfmaddsub132pd,
	Vfmaddsub132ps,
	Vfmaddsub213pd,
	Vfmaddsub213ps,
	Vfmaddsub231pd,
	Vfmaddsub231ps,
	Vfmaddsubpd,
	Vfmaddsubps,
	Vfmsub132pd,
	Vfmsub132ps,
	Vfmsub132sd,
	Vfmsub132ss,
	Vfmsub213pd,
	Vfmsub213ps,
	Vfmsub213sd,
	Vfmsub213ss,
	Vfmsub231pd,
	Vfmsub231ps,
	Vfmsub231sd,
	Vfmsub231ss,
	Vfmsubadd132pd,
	Vfmsubadd132ps,
	Vfmsubadd213pd,
	Vfmsubadd213ps,
	Vfmsubadd231pd,
	Vfmsubadd231ps,
	Vfmsubaddpd,
	Vfmsubaddps,
	Vfmsubpd,
	Vfmsubps,
	Vfmsubsd,
	Vfmsubss,
	Vfnmadd132pd,
	Vfnmadd132ps,
	Vfnmadd132sd,
	Vfnmadd132ss,
	Vfnmadd213pd,
	Vfnmadd213ps,
	Vfnmadd213sd,
	Vfnmadd213ss,
	Vfnmadd231pd,
	Vfnmadd231ps,
	Vfnmadd231sd,
	Vfnmadd231ss,
	Vfnmaddpd,
	Vfnmaddps,
	Vfnmaddsd,
	Vfnmaddss,
	Vfnmsub132pd,
	Vfnmsub132ps,
	Vfnmsub132sd,
	Vfnmsub132ss,
	Vfnmsub213pd,
	Vfnmsub213ps,
	Vfnmsub213sd,
	Vfnmsub213ss,
	Vfnmsub231pd,
	Vfnmsub231ps,
	Vfnmsub231sd,
	Vfnmsub231ss,
	Vfnmsubpd,
	Vfnmsubps,
	Vfnmsubsd,
	Vfnmsubss,
	Vfpclasspd,
	Vfpclassps,
	Vfpclasssd,
	Vfpclassss,
	Vfrczpd,
	Vfrczps,
	Vfrczsd,
	Vfrczss,
	Vgatherdpd,
	Vgatherdps,
	Vgatherpf0dpd,
	Vgatherpf0dps,
	Vgatherpf0qpd,
	Vgatherpf0qps,
	Vgatherpf1dpd,
	Vgatherpf1dps,
	Vgatherpf1qpd,
	Vgatherpf1qps,
	Vgatherqpd,
	Vgatherqps,
	Vgetexppd,
	Vgetexpps,
	Vgetexpsd,
	Vgetexpss,
	Vgetmantpd,
	Vgetmantps,
	Vgetmantsd,
	Vgetmantss,
	Vgf2p8affineinvqb,
	Vgf2p8affineqb,
	Vgf2p8mulb,
	Vhaddpd,
	Vhaddps,
	Vhsubpd,
	Vhsubps,
	Vinsertf128,
	Vinsertf32x4,
	Vinsertf32x8,
	Vinsertf64x2,
	Vinsertf64x4,
	Vinserti128,
	Vinserti32x4,
	Vinserti32x8,
	Vinserti64x2,
	Vinserti64x4,
	Vinsertps,
	Vlddqu,
	Vldmxcsr,
	Vmaskmovdqu,
	Vmaskmovpd,
	Vmaskmovps,
	Vmaxpd,
	Vmaxps,
	Vmaxsd,
	Vmaxss,
	Vmcall,
	Vmclear,
	Vmfunc,
	Vminpd,
	Vminps,
	Vminsd,
	Vminss,
	Vmlaunch,
	Vmload,
	Vmmcall,
	Vmovapd,
	Vmovaps,
	Vmovd,
	Vmovddup,
	Vmovdqa,
	Vmovdqa32,
	Vmovdqa64,
	Vmovdqu,
	Vmovdqu16,
	Vmovdqu32,
	Vmovdqu64,
	Vmovdqu8,
	Vmovhlps,
	Vmovhpd,
	Vmovhps,
	Vmovlhps,
	Vmovlpd,
	Vmovlps,
	Vmovmskpd,
	Vmovmskps,
	Vmovntdq,
	Vmovntdqa,
	Vmovntpd,
	Vmovntps,
	Vmovq,
	Vmovsd,
	Vmovshdup,
	Vmovsldup,
	Vmovss,
	Vmovupd,
	Vmovups,
	Vmpsadbw,
	Vmptrld,
	Vmptrst,
	Vmread,
	Vmresume,
	Vmrun,
	Vmsave,
	Vmulpd,
	Vmulps,
	Vmulsd,
	Vmulss,
	Vmwrite,
	Vmxoff,
	Vmxon,
	Vorpd,
	Vorps,
	Vp2intersectd,
	Vp2intersectq,
	Vp4dpwssd,
	Vp4dpwssds,
	Vpabsb,
	Vpabsd,
	Vpabsq,
	Vpabsw,
	Vpackssdw,
	Vpacksswb,
	Vpackusdw,
	Vpackuswb,
	Vpaddb,
	Vpaddd,
	Vpaddq,
	Vpaddsb,
	Vpaddsw,
	Vpaddusb,
	Vpaddusw,
	Vpaddw,
	Vpalignr,
	Vpand,
	Vpandd,
	Vpandn,
	Vpandnd,
	Vpandnq,
	Vpandq,
	Vpavgb,
	Vpavgw,
	Vpblendd,
	Vpblendmb,
	Vpblendmd,
	Vpblendmq,
	Vpblendmw,
	Vpblendvb,
	Vpblendw,
	Vpbroadcastb,
	Vpbroadcastd,
	Vpbroadcastmb2q,
	Vpbroadcastmw2d,
	Vpbroadcastq,
	Vpbroadcastw,
	Vpclmulqdq,
	Vpcmov,
	Vpcmpb,
	Vpcmpd,
	Vpcmpeqb,
	Vpcmpeqd,
	Vpcmpeqq,
	Vpcmpeqw,
	Vpcmpestri,
	Vpcmpestri64,
	Vpcmpestrm,
	Vpcmpestrm64,
	Vpcmpgtb,
	Vpcmpgtd,
	Vpcmpgtq,
	Vpcmpgtw,
	Vpcmpistri,
	Vpcmpistrm,
	Vpcmpq,
	Vpcmpub,
	Vpcmpud,
	Vpcmpuq,
	Vpcmpuw,
	Vpcmpw,
	Vpcomb,
	Vpcomd,
	Vpcompressb,
	Vpcompressd,
	Vpcompressq,
	Vpcompressw,
	Vpcomq,
	Vpcomub,
	Vpcomud,
	Vpcomuq,
	Vpcomuw,
	Vpcomw,
	Vpconflictd,
	Vpconflictq,
	Vpdpbusd,
	Vpdpbusds,
	Vpdpwssd,
	Vpdpwssds,
	Vperm2f128,
	Vperm2i128,
	Vpermb,
	Vpermd,
	Vpermi2b,
	Vpermi2d,
	Vpermi2pd,
	Vpermi2ps,
	Vpermi2q,
	Vpermi2w,
	Vpermil2pd,
	Vpermil2ps,
	Vpermilpd,
	Vpermilps,
	Vpermpd,
	Vpermps,
	Vpermq,
	Vpermt2b,
	Vpermt2d,
	Vpermt2pd,
	Vpermt2ps,
	Vpermt2q,
	Vpermt2w,
	Vpermw,
	Vpexpandb,
	Vpexpandd,
	Vpexpandq,
	Vpexpandw,
	Vpextrb,
	Vpextrd,
	Vpextrq,
	Vpextrw,
	Vpgatherdd,
	Vpgatherdq,
	Vpgatherqd,
	Vpgatherqq,
	Vphaddbd,
	Vphaddbq,
	Vphaddbw,
	Vphaddd,
	Vphadddq,
	Vphaddsw,
	Vphaddubd,
	Vphaddubq,
	Vphaddubw,
	Vphaddudq,
	Vphadduwd,
	Vphadduwq,
	Vphaddw,
	Vphaddwd,
	Vphaddwq,
	Vphminposuw,
	Vphsubbw,
	Vphsubd,
	Vphsubdq,
	Vphsubsw,
	Vphsubw,
	Vphsubwd,
	Vpinsrb,
	Vpinsrd,
	Vpinsrq,
	Vpinsrw,
	Vplzcntd,
	Vplzcntq,
	Vpmacsdd,
	Vpmacsdqh,
	Vpmacsdql,
	Vpmacssdd,
	Vpmacssdqh,
	Vpmacssdql,
	Vpmacsswd,
	Vpmacssww,
	Vpmacswd,
	Vpmacsww,
	Vpmadcsswd,
	Vpmadcswd,
	Vpmadd52huq,
	Vpmadd52luq,
	Vpmaddubsw,
	Vpmaddwd,
	Vpmaskmovd,
	Vpmaskmovq,
	Vpmaxsb,
	Vpmaxsd,
	Vpmaxsq,
	Vpmaxsw,
	Vpmaxub,
	Vpmaxud,
	Vpmaxuq,
	Vpmaxuw,
	Vpminsb,
	Vpminsd,
	Vpminsq,
	Vpminsw,
	Vpminub,
	Vpminud,
	Vpminuq,
	Vpminuw,
	Vpmovb2m,
	Vpmovd2m,
	Vpmovdb,
	Vpmovdw,
	Vpmovm2b,
	Vpmovm2d,
	Vpmovm2q,
	Vpmovm2w,
	Vpmovmskb,
	Vpmovq2m,
	Vpmovqb,
	Vpmovqd,
	Vpmovqw,
	Vpmovsdb,
	Vpmovsdw,
	Vpmovsqb,
	Vpmovsqd,
	Vpmovsqw,
	Vpmovswb,
	Vpmovsxbd,
	Vpmovsxbq,
	Vpmovsxbw,
	Vpmovsxdq,
	Vpmovsxwd,
	Vpmovsxwq,
	Vpmovusdb,
	Vpmovusdw,
	Vpmovusqb,
	Vpmovusqd,
	Vpmovusqw,
	Vpmovuswb,
	Vpmovw2m,
	Vpmovwb,
	Vpmovzxbd,
	Vpmovzxbq,
	Vpmovzxbw,
	Vpmovzxdq,
	Vpmovzxwd,
	Vpmovzxwq,
	Vpmuldq,
	Vpmulhrsw,
	Vpmulhuw,
	Vpmulhw,
	Vpmulld,
	Vpmullq,
	Vpmullw,
	Vpmultishiftqb,
	Vpmuludq,
	Vpopcntb,
	Vpopcntd,
	Vpopcntq,
	Vpopcntw,
	Vpor,
	Vpord,
	Vporq,
	Vpperm,
	Vprold,
	Vprolq,
	Vprolvd,
	Vprolvq,
	Vprord,
	Vprorq,
	Vprorvd,
	Vprorvq,
	Vprotb,
	Vprotd,
	Vprotq,
	Vprotw,
	Vpsadbw,
	Vpscatterdd,
	Vpscatterdq,
	Vpscatterqd,
	Vpscatterqq,
	Vpshab,
	Vpshad,
	Vpshaq,
	Vpshaw,
	Vpshlb,
	Vpshld,
	Vpshldd,
	Vpshldq,
	Vpshldvd,
	Vpshldvq,
	Vpshldvw,
	Vpshldw,
	Vpshlq,
	Vpshlw,
	Vpshrdd,
	Vpshrdq,
	Vpshrdvd,
	Vpshrdvq,
	Vpshrdvw,
	Vpshrdw,
	Vpshufb,
	Vpshufbitqmb,
	Vpshufd,
	Vpshufhw,
	Vpshuflw,
	Vpsignb,
	Vpsignd,
	Vpsignw,
	Vpslld,
	Vpslldq,
	Vpsllq,
	Vpsllvd,
	Vpsllvq,
	Vpsllvw,
	Vpsllw,
	Vpsrad,
	Vpsraq,
	Vpsravd,
	Vpsravq,
	Vpsravw,
	Vpsraw,
	Vpsrld,
	Vpsrldq,
	Vpsrlq,
	Vpsrlvd,
	Vpsrlvq,
	Vpsrlvw,
	Vpsrlw,
	Vpsubb,
	Vpsubd,
	Vpsubq,
	Vpsubsb,
	Vpsubsw,
	Vpsubusb,
	Vpsubusw,
	Vpsubw,
	Vpternlogd,
	Vpternlogq,
	Vptest,
	Vptestmb,
	Vptestmd,
	Vptestmq,
	Vptestmw,
	Vptestnmb,
	Vptestnmd,
	Vptestnmq,
	Vptestnmw,
	Vpunpckhbw,
	Vpunpckhdq,
	Vpunpckhqdq,
	Vpunpckhwd,
	Vpunpcklbw,
	Vpunpckldq,
	Vpunpcklqdq,
	Vpunpcklwd,
	Vpxor,
	Vpxord,
	Vpxorq,
	Vrangepd,
	Vrangeps,
	Vrangesd,
	Vrangess,
	Vrcp14pd,
	Vrcp14ps,
	Vrcp14sd,
	Vrcp14ss,
	Vrcp28pd,
	Vrcp28ps,
	Vrcp28sd,
	Vrcp28ss,
	Vrcpps,
	Vrcpss,
	Vreducepd,
	Vreduceps,
	Vreducesd,
	Vreducess,
	Vrndscalepd,
	Vrndscaleps,
	Vrndscalesd,
	Vrndscaless,
	Vroundpd,
	Vroundps,
	Vroundsd,
	Vroundss,
	Vrsqrt14pd,
	Vrsqrt14ps,
	Vrsqrt14sd,
	Vrsqrt14ss,
	Vrsqrt28pd,
	Vrsqrt28ps,
	Vrsqrt28sd,
	Vrsqrt28ss,
	Vrsqrtps,
	Vrsqrtss,
	Vscalefpd,
	Vscalefps,
	Vscalefsd,
	Vscalefss,
	Vscatterdpd,
	Vscatterdps,
	Vscatterpf0dpd,
	Vscatterpf0dps,
	Vscatterpf0qpd,
	Vscatterpf0qps,
	Vscatterpf1dpd,
	Vscatterpf1dps,
	Vscatterpf1qpd,
	Vscatterpf1qps,
	Vscatterqpd,
	Vscatterqps,
	Vshuff32x4,
	Vshuff64x2,
	Vshufi32x4,
	Vshufi64x2,
	Vshufpd,
	Vshufps,
	Vsqrtpd,
	Vsqrtps,
	Vsqrtsd,
	Vsqrtss,
	Vstmxcsr,
	Vsubpd,
	Vsubps,
	Vsubsd,
	Vsubss,
	Vtestpd,
	Vtestps,
	Vucomisd,
	Vucomiss,
	Vunpckhpd,
	Vunpckhps,
	Vunpcklpd,
	Vunpcklps,
	Vxorpd,
	Vxorps,
	Vzeroall,
	Vzeroupper,
	Wait,
	Wbinvd,
	Wbnoinvd,
	Wrfsbase,
	Wrgsbase,
	Wrmsr,
	Wrpkru,
	Wrssd,
	Wrssq,
	Wrussd,
	Wrussq,
	Xabort,
	Xadd,
	Xbegin,
	Xbts,
	Xchg,
	Xcryptcbc,
	Xcryptcfb,
	Xcryptctr,
	Xcryptecb,
	Xcryptofb,
	Xend,
	Xgetbv,
	Xlatb,
	Xor,
	Xorpd,
	Xorps,
	Xrstor,
	Xrstor64,
	Xrstors,
	Xrstors64,
	Xsave,
	Xsave64,
	Xsavec,
	Xsavec64,
	Xsaveopt,
	Xsaveopt64,
	Xsaves,
	Xsaves64,
	Xsetbv,
	Xsha1,
	Xsha256,
	Xstore,
	Xtest,
	Rmpadjust,
	Rmpupdate,
	Psmash,
	Pvalidate,
	Serialize,
	Xsusldtrk,
	Xresldtrk,
	Invlpgb,
	Tlbsync,
	Vmgexit,
	Getsecq,
	Sysexitq,
	Ldtilecfg,
	Tilerelease,
	Sttilecfg,
	Tilezero,
	Tileloaddt1,
	Tilestored,
	Tileloadd,
	Tdpbf16ps,
	Tdpbuud,
	Tdpbusd,
	Tdpbsud,
	Tdpbssd,
	Sysretq,
	Fnstdw,
	Fnstsg,
	Rdshr,
	Wrshr,
	Smint,
	Dmint,
	Rdm,
	Svdc,
	Rsdc,
	Svldt,
	Rsldt,
	Svts,
	Rsts,
	Bb0_reset,
	Bb1_reset,
	Cpu_write,
	Cpu_read,
	Altinst,
	Paveb,
	Paddsiw,
	Pmagw,
	Pdistib,
	Psubsiw,
	Pmvzb,
	Pmvnzb,
	Pmvlzb,
	Pmvgezb,
	Pmulhriw,
	Pmachriw,
	Ftstp,
	Frint2,
	Frichop,
	Frinear,
	Undoc,
	Tdcall,
	Seamret,
	Seamops,
	Seamcall,
	Aesencwide128kl,
	Aesdecwide128kl,
	Aesencwide256kl,
	Aesdecwide256kl,
	Loadiwkey,
	Aesenc128kl,
	Aesdec128kl,
	Aesenc256kl,
	Aesdec256kl,
	Encodekey128,
	Encodekey256,
	Pushad,
	Popad,
	Pushfd,
	Pushfq,
	Popfd,
	Popfq,
	Iretd,
	Iretq,
	Int3,
	Uiret,
	Testui,
	Clui,
	Stui,
	Senduipi,
	Hreset,
	Ccs_hash,
	Ccs_encrypt,
	Lkgs,
	Eretu,
	Erets,
	Storeall,
	Vaddph,
	Vaddsh,
	Vcmpph,
	Vcmpsh,
	Vcomish,
	Vcvtdq2ph,
	Vcvtpd2ph,
	Vcvtph2dq,
	Vcvtph2pd,
	Vcvtph2psx,
	Vcvtph2qq,
	Vcvtph2udq,
	Vcvtph2uqq,
	Vcvtph2uw,
	Vcvtph2w,
	Vcvtps2phx,
	Vcvtqq2ph,
	Vcvtsd2sh,
	Vcvtsh2sd,
	Vcvtsh2si,
	Vcvtsh2ss,
	Vcvtsh2usi,
	Vcvtsi2sh,
	Vcvtss2sh,
	Vcvttph2dq,
	Vcvttph2qq,
	Vcvttph2udq,
	Vcvttph2uqq,
	Vcvttph2uw,
	Vcvttph2w,
	Vcvttsh2si,
	Vcvttsh2usi,
	Vcvtudq2ph,
	Vcvtuqq2ph,
	Vcvtusi2sh,
	Vcvtuw2ph,
	Vcvtw2ph,
	Vdivph,
	Vdivsh,
	Vfcmaddcph,
	Vfmaddcph,
	Vfcmaddcsh,
	Vfmaddcsh,
	Vfcmulcph,
	Vfmulcph,
	Vfcmulcsh,
	Vfmulcsh,
	Vfmaddsub132ph,
	Vfmaddsub213ph,
	Vfmaddsub231ph,
	Vfmsubadd132ph,
	Vfmsubadd213ph,
	Vfmsubadd231ph,
	Vfmadd132ph,
	Vfmadd213ph,
	Vfmadd231ph,
	Vfnmadd132ph,
	Vfnmadd213ph,
	Vfnmadd231ph,
	Vfmadd132sh,
	Vfmadd213sh,
	Vfmadd231sh,
	Vfnmadd132sh,
	Vfnmadd213sh,
	Vfnmadd231sh,
	Vfmsub132ph,
	Vfmsub213ph,
	Vfmsub231ph,
	Vfnmsub132ph,
	Vfnmsub213ph,
	Vfnmsub231ph,
	Vfmsub132sh,
	Vfmsub213sh,
	Vfmsub231sh,
	Vfnmsub132sh,
	Vfnmsub213sh,
	Vfnmsub231sh,
	Vfpclassph,
	Vfpclasssh,
	Vgetexpph,
	Vgetexpsh,
	Vgetmantph,
	Vgetmantsh,
	Vmaxph,
	Vmaxsh,
	Vminph,
	Vminsh,
	Vmovsh,
	Vmovw,
	Vmulph,
	Vmulsh,
	Vrcpph,
	Vrcpsh,
	Vreduceph,
	Vreducesh,
	Vrndscaleph,
	Vrndscalesh,
	Vrsqrtph,
	Vrsqrtsh,
	Vscalefph,
	Vscalefsh,
	Vsqrtph,
	Vsqrtsh,
	Vsubph,
	Vsubsh,
	Vucomish,
	Rdudbg,
	Wrudbg,
	Clevict0,
	Clevict1,
	Delay,
	Jknzd,
	Jkzd,
	Kand,
	Kandn,
	Kandnr,
	Kconcath,
	Kconcatl,
	Kextract,
	Kmerge2l1h,
	Kmerge2l1l,
	Kmov,
	Knot,
	Kor,
	Kortest,
	Kxnor,
	Kxor,
	Spflt,
	Tzcnti,
	Vaddnpd,
	Vaddnps,
	Vaddsetsps,
	Vcvtfxpntdq2ps,
	Vcvtfxpntpd2dq,
	Vcvtfxpntpd2udq,
	Vcvtfxpntps2dq,
	Vcvtfxpntps2udq,
	Vcvtfxpntudq2ps,
	Vexp223ps,
	Vfixupnanpd,
	Vfixupnanps,
	Vfmadd233ps,
	Vgatherpf0hintdpd,
	Vgatherpf0hintdps,
	Vgmaxabsps,
	Vgmaxpd,
	Vgmaxps,
	Vgminpd,
	Vgminps,
	Vloadunpackhd,
	Vloadunpackhpd,
	Vloadunpackhps,
	Vloadunpackhq,
	Vloadunpackld,
	Vloadunpacklpd,
	Vloadunpacklps,
	Vloadunpacklq,
	Vlog2ps,
	Vmovnrapd,
	Vmovnraps,
	Vmovnrngoapd,
	Vmovnrngoaps,
	Vpackstorehd,
	Vpackstorehpd,
	Vpackstorehps,
	Vpackstorehq,
	Vpackstoreld,
	Vpackstorelpd,
	Vpackstorelps,
	Vpackstorelq,
	Vpadcd,
	Vpaddsetcd,
	Vpaddsetsd,
	Vpcmpltd,
	Vpermf32x4,
	Vpmadd231d,
	Vpmadd233d,
	Vpmulhd,
	Vpmulhud,
	Vprefetch0,
	Vprefetch1,
	Vprefetch2,
	Vprefetche0,
	Vprefetche1,
	Vprefetche2,
	Vprefetchenta,
	Vprefetchnta,
	Vpsbbd,
	Vpsbbrd,
	Vpsubrd,
	Vpsubrsetbd,
	Vpsubsetbd,
	Vrcp23ps,
	Vrndfxpntpd,
	Vrndfxpntps,
	Vrsqrt23ps,
	Vscaleps,
	Vscatterpf0hintdpd,
	Vscatterpf0hintdps,
	Vsubrpd,
	Vsubrps,
	Xsha512,
	Xstore_alt,
	Xsha512_alt,
	Zero_bytes
}


using System.Runtime.CompilerServices;
using Iced.Intel;

internal static class MnemonicUtils
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Mnemonic Mnemonic(this Code code)
	{
		return (Mnemonic)MnemonicUtilsData.toMnemonic[(int)code];
	}
}


internal static class MnemonicUtilsData
{
	internal static readonly ushort[] toMnemonic = new ushort[4834]
	{
		0, 135, 146, 136, 145, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 640, 640, 590,
		590, 467, 467, 467, 467, 467, 467, 467, 467, 467,
		467, 467, 467, 640, 640, 590, 5, 5, 5, 5,
		5, 5, 5, 5, 5, 5, 5, 5, 640, 640,
		590, 590, 681, 681, 681, 681, 681, 681, 681, 681,
		681, 681, 681, 681, 640, 640, 590, 590, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		133, 740, 740, 740, 740, 740, 740, 740, 740, 740,
		740, 740, 740, 134, 1518, 1518, 1518, 1518, 1518, 1518,
		1518, 1518, 1518, 1518, 1518, 1518, 1, 93, 93, 93,
		93, 93, 93, 93, 93, 93, 93, 93, 93, 4,
		279, 279, 137, 137, 640, 640, 640, 590, 590, 590,
		641, 1612, 591, 1613, 50, 50, 27, 27, 451, 451,
		451, 640, 640, 640, 277, 277, 277, 640, 640, 640,
		277, 277, 277, 282, 286, 283, 471, 473, 472, 314,
		314, 314, 311, 311, 311, 299, 299, 299, 298, 298,
		298, 302, 302, 302, 310, 310, 310, 300, 300, 300,
		297, 297, 297, 317, 317, 317, 313, 313, 313, 315,
		315, 315, 312, 312, 312, 306, 306, 306, 305, 305,
		305, 307, 307, 307, 304, 304, 304, 7, 467, 5,
		681, 21, 740, 1518, 93, 7, 7, 7, 467, 467,
		467, 5, 5, 5, 681, 681, 681, 21, 21, 21,
		740, 740, 740, 1518, 1518, 1518, 93, 93, 93, 7,
		467, 5, 681, 21, 740, 1518, 93, 7, 7, 7,
		467, 467, 467, 5, 5, 5, 681, 681, 681, 21,
		21, 21, 740, 740, 740, 1518, 1518, 1518, 93, 93,
		93, 751, 751, 751, 751, 1509, 1509, 1509, 1509, 414,
		414, 414, 414, 414, 414, 414, 414, 414, 414, 414,
		374, 374, 374, 414, 414, 414, 590, 590, 590, 465,
		465, 465, 1509, 1509, 1509, 492, 60, 132, 62, 131,
		61, 107, 59, 59, 1494, 642, 1614, 1615, 593, 1616,
		1617, 675, 369, 414, 414, 414, 414, 414, 414, 414,
		414, 443, 449, 444, 447, 96, 100, 97, 98, 751,
		751, 751, 751, 735, 738, 736, 737, 386, 389, 387,
		388, 682, 685, 683, 684, 414, 414, 414, 414, 664,
		665, 644, 647, 712, 715, 676, 678, 664, 664, 664,
		665, 665, 665, 644, 644, 644, 647, 647, 647, 712,
		712, 712, 715, 715, 715, 676, 676, 676, 678, 678,
		678, 662, 662, 662, 662, 662, 662, 376, 376, 373,
		373, 414, 1505, 414, 414, 414, 1507, 1507, 155, 155,
		155, 375, 375, 375, 663, 663, 663, 663, 663, 663,
		1620, 287, 289, 296, 1618, 1619, 664, 665, 644, 647,
		712, 715, 676, 678, 664, 664, 664, 665, 665, 665,
		644, 644, 644, 647, 647, 647, 712, 712, 712, 715,
		715, 715, 676, 676, 676, 678, 678, 678, 664, 665,
		644, 647, 712, 715, 676, 678, 664, 664, 664, 665,
		665, 665, 644, 644, 644, 647, 647, 647, 712, 712,
		712, 715, 715, 715, 676, 676, 676, 678, 678, 678,
		3, 2, 677, 1517, 160, 214, 174, 177, 247, 249,
		182, 184, 160, 214, 174, 177, 247, 249, 182, 184,
		204, 239, 243, 207, 207, 206, 224, 242, 224, 242,
		223, 240, 204, 258, 220, 244, 164, 159, 251, 257,
		205, 209, 208, 212, 210, 211, 213, 158, 264, 229,
		226, 263, 228, 180, 197, 227, 265, 238, 237, 230,
		234, 236, 179, 190, 196, 191, 192, 202, 203, 193,
		194, 166, 168, 167, 173, 256, 195, 201, 199, 200,
		204, 243, 169, 171, 170, 172, 218, 187, 217, 181,
		216, 165, 219, 198, 222, 235, 232, 253, 175, 160,
		214, 174, 177, 247, 249, 182, 184, 160, 214, 174,
		177, 249, 247, 184, 182, 204, 201, 239, 243, 231,
		231, 221, 233, 221, 233, 225, 246, 188, 258, 239,
		243, 252, 255, 190, 196, 191, 192, 202, 203, 193,
		194, 161, 215, 177, 178, 250, 248, 185, 183, 195,
		201, 199, 200, 162, 195, 163, 200, 189, 258, 243,
		243, 225, 246, 241, 245, 254, 176, 392, 392, 392,
		392, 392, 392, 392, 391, 391, 391, 391, 391, 391,
		391, 390, 390, 390, 390, 390, 390, 390, 301, 301,
		303, 303, 303, 316, 316, 278, 278, 278, 470, 470,
		470, 59, 59, 59, 308, 308, 308, 308, 308, 308,
		308, 308, 278, 278, 278, 470, 470, 470, 288, 272,
		76, 751, 751, 466, 464, 456, 277, 138, 276, 751,
		751, 751, 751, 751, 751, 466, 466, 466, 464, 464,
		464, 456, 456, 456, 277, 277, 277, 138, 138, 138,
		276, 276, 276, 65, 730, 71, 733, 66, 731, 279,
		137, 279, 279, 279, 137, 137, 137, 59, 59, 59,
		59, 59, 59, 308, 308, 308, 308, 308, 308, 640,
		640, 640, 722, 722, 722, 739, 739, 739, 382, 382,
		382, 395, 395, 395, 869, 869, 869, 870, 870, 870,
		309, 309, 704, 704, 704, 720, 720, 720, 379, 379,
		379, 381, 381, 381, 724, 724, 724, 674, 384, 384,
		384, 292, 150, 1025, 1032, 1070, 1078, 514, 411, 411,
		411, 462, 64, 729, 148, 1516, 1533, 1027, 1515, 1537,
		149, 1071, 1071, 1071, 1034, 1033, 1033, 1033, 1072, 1072,
		1072, 732, 70, 721, 293, 293, 293, 702, 680, 652,
		1500, 745, 660, 412, 412, 412, 405, 463, 75, 75,
		75, 654, 370, 370, 370, 393, 393, 393, 1632, 385,
		746, 73, 385, 749, 1562, 290, 1495, 1496, 63, 759,
		661, 661, 661, 595, 600, 601, 186, 761, 761, 761,
		761, 761, 761, 453, 1065, 1065, 1065, 1065, 1065, 452,
		1064, 1064, 1064, 1064, 1064, 448, 1063, 1063, 1063, 1063,
		444, 1060, 1060, 1060, 1060, 453, 1065, 1065, 1065, 1065,
		1065, 452, 1064, 1064, 1064, 1064, 1064, 448, 1063, 1063,
		1063, 1063, 444, 1060, 1060, 1060, 1060, 425, 430, 1047,
		1052, 1047, 1052, 429, 1051, 1051, 446, 1062, 1062, 1062,
		1062, 1062, 419, 1038, 1038, 1038, 1038, 1038, 430, 1052,
		1052, 429, 1051, 1051, 766, 1489, 1489, 1489, 1489, 1489,
		765, 1488, 1488, 1488, 1488, 1488, 764, 1487, 1487, 1487,
		1487, 1487, 763, 1486, 1486, 1486, 1486, 1486, 428, 1050,
		1050, 427, 1049, 1049, 426, 1048, 1048, 445, 1061, 1061,
		1061, 1061, 1061, 427, 1049, 1049, 426, 1048, 1048, 661,
		661, 661, 661, 661, 661, 661, 661, 661, 661, 661,
		661, 661, 661, 661, 661, 661, 661, 661, 661, 661,
		661, 661, 661, 596, 597, 598, 599, 46, 48, 48,
		43, 43, 45, 45, 49, 48, 48, 47, 47, 44,
		44, 67, 657, 658, 152, 151, 465, 465, 465, 414,
		414, 414, 414, 414, 414, 414, 414, 414, 414, 416,
		1036, 1036, 1036, 1036, 1036, 415, 1035, 1035, 1035, 1035,
		1035, 416, 1036, 1036, 1036, 1036, 1036, 415, 1035, 1035,
		1035, 1035, 1035, 115, 114, 122, 122, 839, 839, 839,
		839, 121, 121, 838, 838, 838, 838, 437, 1058, 1058,
		1058, 1058, 1058, 436, 1057, 1057, 1057, 1057, 1057, 440,
		439, 128, 126, 130, 130, 853, 853, 853, 853, 129,
		129, 851, 851, 851, 851, 118, 112, 124, 124, 841,
		841, 841, 841, 119, 119, 835, 835, 835, 835, 756,
		1485, 1485, 755, 1484, 1484, 105, 104, 814, 813, 814,
		813, 1499, 659, 650, 653, 747, 748, 1549, 266, 90,
		90, 90, 87, 87, 87, 79, 79, 79, 78, 78,
		78, 81, 81, 81, 86, 86, 86, 80, 80, 80,
		77, 77, 77, 92, 92, 92, 89, 89, 89, 91,
		91, 91, 88, 88, 88, 84, 84, 84, 83, 83,
		83, 85, 85, 85, 82, 82, 82, 329, 328, 322,
		323, 327, 326, 324, 325, 337, 336, 334, 335, 345,
		340, 338, 339, 364, 363, 361, 362, 368, 367, 365,
		366, 321, 320, 318, 319, 360, 359, 358, 432, 432,
		1054, 1054, 1054, 1054, 431, 431, 1053, 1053, 1053, 1053,
		726, 1474, 1474, 1474, 1474, 1474, 725, 1473, 1473, 1473,
		1473, 1473, 728, 1476, 1476, 727, 1475, 1475, 672, 1449,
		1449, 673, 1450, 645, 1427, 1427, 646, 1428, 26, 788,
		788, 788, 788, 788, 25, 787, 787, 787, 787, 787,
		24, 786, 786, 786, 786, 786, 23, 785, 785, 785,
		785, 785, 469, 1081, 1081, 1081, 1081, 1081, 468, 1080,
		1080, 1080, 1080, 1080, 1520, 1491, 1491, 1491, 1491, 1491,
		1519, 1490, 1490, 1490, 1490, 1490, 9, 772, 772, 772,
		772, 772, 8, 771, 771, 771, 771, 771, 11, 774,
		774, 10, 773, 773, 458, 1074, 1074, 1074, 1074, 1074,
		457, 1073, 1073, 1073, 1073, 1073, 460, 1076, 1076, 459,
		1075, 1075, 117, 828, 828, 828, 828, 828, 113, 822,
		822, 822, 822, 822, 123, 840, 840, 120, 836, 836,
		110, 818, 818, 818, 818, 818, 834, 834, 834, 116,
		827, 827, 827, 827, 827, 127, 847, 847, 847, 847,
		847, 742, 1479, 1479, 1479, 1479, 1479, 741, 1478, 1478,
		1478, 1478, 1478, 744, 1481, 1481, 743, 1480, 1480, 408,
		1029, 1029, 1029, 1029, 1029, 407, 1028, 1028, 1028, 1028,
		1028, 410, 1031, 1031, 409, 1030, 1030, 140, 863, 863,
		863, 863, 863, 139, 862, 862, 862, 862, 862, 142,
		865, 865, 141, 864, 864, 402, 1022, 1022, 1022, 1022,
		1022, 401, 1021, 1021, 1021, 1021, 1021, 404, 1024, 1024,
		403, 1023, 1023, 636, 636, 1408, 1408, 1408, 1408, 1408,
		639, 639, 1411, 1411, 1411, 1411, 1411, 637, 637, 1409,
		1409, 1409, 1409, 1409, 478, 478, 1091, 1091, 1091, 1091,
		1091, 507, 507, 1136, 1136, 1136, 1136, 1136, 510, 510,
		1139, 1139, 1139, 1139, 1139, 508, 508, 1137, 1137, 1137,
		1137, 1137, 480, 480, 1093, 1093, 1093, 1093, 1093, 632,
		632, 1404, 1404, 1404, 1404, 1404, 635, 635, 1407, 1407,
		1407, 1407, 1407, 633, 633, 1405, 1405, 1405, 1405, 1405,
		477, 477, 1090, 1090, 1090, 1090, 1090, 638, 1410, 1410,
		1410, 1410, 1410, 634, 1406, 1406, 1406, 1406, 1406, 418,
		441, 418, 441, 1037, 1059, 1037, 1059, 441, 423, 1039,
		1039, 1040, 1040, 1040, 1041, 1041, 1041, 424, 1042, 1042,
		1044, 1044, 1044, 1045, 1045, 1045, 1046, 1046, 1046, 1043,
		1043, 1043, 607, 604, 1359, 1359, 1359, 1359, 1359, 605,
		1360, 1360, 1360, 1360, 1360, 606, 1361, 1361, 1361, 1361,
		1361, 620, 620, 1384, 1384, 1384, 1384, 1384, 616, 616,
		1377, 1377, 1377, 1377, 1377, 614, 614, 1371, 1371, 1371,
		1371, 1371, 1324, 1324, 1324, 1325, 1325, 1325, 1320, 1320,
		1320, 1321, 1321, 1321, 617, 617, 1378, 1378, 1378, 1378,
		1378, 615, 615, 1372, 1372, 1372, 1372, 1372, 1373, 1373,
		1373, 611, 611, 1365, 1365, 1365, 1365, 1365, 619, 619,
		1380, 1380, 1380, 1380, 1380, 618, 1379, 1379, 1379, 1379,
		1379, 613, 613, 1367, 1367, 1367, 1367, 1367, 612, 1366,
		1366, 1366, 1366, 1366, 499, 499, 1128, 1128, 1128, 1128,
		1128, 502, 502, 1131, 1131, 1131, 1131, 1131, 500, 500,
		1129, 1129, 1129, 1129, 1129, 147, 1493, 1492, 1069, 1069,
		849, 849, 849, 845, 845, 845, 157, 850, 850, 850,
		846, 846, 846, 854, 854, 285, 852, 852, 1077, 1077,
		831, 831, 831, 824, 824, 824, 157, 832, 832, 832,
		825, 825, 825, 842, 842, 285, 837, 837, 848, 848,
		848, 844, 844, 844, 855, 855, 855, 857, 857, 857,
		856, 856, 856, 858, 858, 858, 830, 830, 830, 823,
		823, 823, 860, 860, 859, 859, 270, 1001, 1001, 271,
		1002, 1002, 273, 1003, 1003, 274, 1004, 1004, 418, 441,
		418, 441, 1037, 1059, 1037, 1059, 441, 1059, 1059, 441,
		423, 1039, 1039, 1040, 1040, 1040, 1041, 1041, 1041, 424,
		1042, 1042, 1044, 1044, 1044, 1045, 1045, 1045, 1046, 1046,
		1046, 1043, 1043, 1043, 314, 314, 314, 311, 311, 311,
		299, 299, 299, 298, 298, 298, 302, 302, 302, 310,
		310, 310, 300, 300, 300, 297, 297, 297, 317, 317,
		317, 313, 313, 313, 315, 315, 315, 312, 312, 312,
		306, 306, 306, 305, 305, 305, 307, 307, 307, 304,
		304, 304, 699, 696, 688, 687, 690, 695, 689, 686,
		701, 698, 700, 697, 693, 692, 694, 691, 333, 332,
		330, 331, 333, 332, 330, 331, 333, 330, 331, 332,
		333, 330, 331, 332, 344, 343, 341, 342, 357, 356,
		354, 355, 640, 640, 640, 590, 590, 590, 106, 54,
		54, 54, 713, 713, 713, 713, 713, 713, 413, 413,
		413, 1534, 1534, 1534, 1535, 1535, 1535, 1508, 1508, 1536,
		1536, 1536, 1513, 1513, 1513, 1510, 1510, 1510, 1512, 1512,
		1512, 1511, 1511, 1511, 1514, 1514, 1514, 275, 275, 101,
		101, 101, 640, 640, 640, 590, 590, 590, 671, 57,
		57, 57, 716, 716, 716, 716, 716, 716, 261, 262,
		648, 648, 259, 260, 649, 649, 372, 1497, 1497, 1017,
		734, 1498, 1498, 1477, 1525, 1526, 631, 631, 1521, 1522,
		280, 281, 1529, 1530, 74, 752, 752, 72, 760, 760,
		760, 762, 762, 68, 69, 377, 377, 377, 377, 377,
		377, 377, 377, 406, 406, 406, 406, 406, 406, 406,
		406, 703, 703, 703, 703, 703, 703, 703, 703, 513,
		277, 277, 277, 101, 101, 101, 101, 394, 394, 394,
		56, 56, 56, 378, 378, 378, 380, 380, 380, 454,
		454, 454, 454, 454, 454, 309, 309, 592, 592, 592,
		758, 758, 758, 54, 54, 54, 57, 57, 57, 56,
		56, 56, 55, 55, 55, 55, 55, 55, 51, 51,
		51, 753, 753, 753, 52, 52, 52, 398, 398, 398,
		450, 450, 450, 450, 450, 450, 1506, 1506, 1506, 1506,
		95, 810, 810, 810, 810, 810, 94, 809, 809, 809,
		809, 809, 99, 812, 812, 97, 811, 811, 435, 435,
		554, 554, 554, 554, 1227, 1227, 1227, 1227, 520, 520,
		520, 520, 1197, 1197, 1197, 1197, 719, 1472, 1472, 1472,
		1472, 1472, 718, 1471, 1471, 1471, 1471, 1471, 103, 102,
		1523, 1524, 1527, 1528, 1531, 1532, 1067, 1026, 1079, 655,
		655, 655, 1068, 656, 656, 656, 651, 651, 53, 53,
		53, 12, 775, 775, 13, 776, 776, 620, 620, 1384,
		1384, 1384, 1384, 1384, 617, 617, 1378, 1378, 1378, 1378,
		1378, 619, 619, 1380, 1380, 1380, 1380, 1380, 483, 483,
		1096, 1096, 1096, 1096, 1096, 588, 588, 1309, 1309, 1309,
		1309, 1309, 441, 1059, 1059, 442, 422, 569, 569, 569,
		569, 1272, 1272, 1272, 1272, 626, 626, 1390, 1390, 1390,
		1390, 1390, 627, 627, 1391, 1391, 1391, 1391, 1391, 566,
		566, 1260, 1260, 1260, 1260, 1260, 490, 490, 1103, 1103,
		1104, 1104, 1104, 1108, 1108, 1108, 486, 486, 1099, 1099,
		1099, 1099, 1099, 487, 487, 1100, 1100, 1100, 1100, 1100,
		560, 560, 1252, 1252, 1252, 1252, 1252, 491, 491, 1105,
		1105, 1106, 1106, 1106, 1107, 1107, 1107, 493, 493, 1109,
		1109, 1109, 1109, 1109, 616, 616, 1377, 1377, 1377, 1377,
		1377, 615, 615, 1372, 1372, 1372, 1372, 1372, 1373, 1373,
		1373, 495, 495, 1110, 1110, 1110, 1110, 1110, 585, 585,
		1305, 1305, 1305, 1305, 1305, 586, 586, 1306, 1306, 1306,
		1306, 1306, 125, 843, 843, 843, 843, 843, 109, 817,
		817, 817, 817, 817, 833, 833, 833, 111, 821, 821,
		821, 821, 821, 438, 433, 1055, 1055, 1055, 1055, 1055,
		624, 624, 1388, 1388, 1388, 1388, 1388, 625, 625, 1389,
		1389, 1389, 1389, 1389, 565, 565, 1259, 1259, 1259, 1259,
		1259, 594, 594, 1316, 1316, 1317, 1317, 1317, 1318, 1318,
		1318, 484, 484, 1097, 1097, 1097, 1097, 1097, 485, 485,
		1098, 1098, 1098, 1098, 1098, 559, 559, 1251, 1251, 1251,
		1251, 1251, 643, 643, 1412, 1412, 1413, 1413, 1413, 1414,
		1414, 1414, 371, 1016, 1016, 614, 614, 1371, 1371, 1371,
		1371, 1371, 611, 611, 1365, 1365, 1365, 1365, 1365, 613,
		613, 1367, 1367, 1367, 1367, 1367, 589, 589, 1311, 1311,
		1311, 1311, 1311, 556, 556, 1245, 1245, 1245, 1245, 1245,
		602, 602, 1332, 1332, 1332, 1332, 1332, 400, 399, 1018,
		621, 621, 1385, 1385, 1385, 1385, 1385, 628, 628, 1392,
		1392, 1392, 1392, 1392, 622, 622, 1386, 1386, 1386, 1386,
		1386, 623, 623, 1387, 1387, 1387, 1387, 1387, 481, 481,
		1094, 1094, 1094, 1094, 1094, 488, 488, 1101, 1101, 1101,
		1101, 1101, 482, 482, 1095, 1095, 1095, 1095, 1095, 757,
		757, 757, 603, 603, 1357, 1357, 1357, 1357, 1357, 544,
		544, 1214, 1214, 542, 542, 1205, 1205, 543, 543, 1207,
		1207, 555, 555, 1244, 1244, 1244, 1244, 1244, 548, 548,
		1222, 1222, 546, 546, 1219, 1219, 547, 547, 1221, 1221,
		608, 608, 1362, 1362, 610, 610, 1364, 1364, 609, 609,
		1363, 1363, 583, 583, 1304, 1304, 1304, 1304, 1304, 1179,
		1179, 1179, 1179, 1179, 1178, 1178, 1178, 1178, 1178, 1483,
		1483, 1482, 1482, 496, 1383, 1383, 1383, 1294, 1294, 1294,
		1376, 1376, 1376, 1289, 1289, 1289, 1370, 1370, 1370, 1291,
		1291, 1291, 826, 826, 826, 826, 826, 1290, 1290, 1290,
		37, 1326, 1326, 1326, 1327, 1327, 1327, 1293, 1293, 1293,
		36, 1322, 1322, 1322, 1323, 1323, 1323, 1292, 1292, 1292,
		1181, 1181, 1181, 1180, 1180, 630, 1395, 1395, 808, 808,
		808, 808, 808, 807, 796, 796, 807, 807, 795, 797,
		797, 799, 799, 798, 800, 474, 474, 1086, 1086, 1086,
		1086, 1086, 476, 476, 1089, 1089, 1089, 1089, 1089, 475,
		475, 1087, 1087, 1087, 1087, 1087, 1088, 1088, 1088, 572,
		1285, 1285, 1285, 1285, 1285, 1282, 1282, 1282, 570, 1283,
		1283, 1283, 1283, 1283, 1277, 1277, 1277, 571, 1284, 1284,
		1284, 1284, 1284, 1279, 1279, 1279, 574, 1287, 1287, 1287,
		1287, 1287, 1278, 1278, 1278, 575, 1288, 1288, 1288, 1288,
		1288, 1281, 1281, 1281, 573, 1286, 1286, 1286, 1286, 1286,
		1280, 1280, 1280, 1396, 1396, 1396, 1399, 1399, 1399, 1400,
		1400, 1400, 1403, 1403, 1403, 1397, 1397, 1397, 1398, 1398,
		1398, 1401, 1401, 1401, 1402, 1402, 1402, 582, 1303, 1303,
		1303, 1303, 1303, 1268, 1268, 1268, 1271, 1271, 1271, 501,
		1130, 1130, 1130, 1130, 1130, 1264, 1264, 1264, 1295, 1295,
		1295, 434, 1056, 1056, 1056, 1056, 1056, 1120, 1120, 1120,
		479, 1092, 1092, 1092, 1092, 1092, 1020, 1020, 1452, 1452,
		1452, 1451, 1451, 1451, 1019, 1019, 1454, 1453, 1020, 1020,
		1019, 1019, 578, 1299, 1299, 1299, 1299, 1299, 1296, 1296,
		1296, 576, 1297, 1297, 1297, 1297, 1297, 1266, 1266, 1266,
		577, 1298, 1298, 1298, 1298, 1298, 1274, 1274, 1274, 580,
		1301, 1301, 1301, 1301, 1301, 1267, 1267, 1267, 581, 1302,
		1302, 1302, 1302, 1302, 1276, 1276, 1276, 579, 1300, 1300,
		1300, 1300, 1300, 1275, 1275, 1275, 1169, 1169, 1169, 1182,
		1182, 509, 1138, 1138, 1138, 1138, 1138, 563, 1256, 1256,
		1256, 1256, 1256, 1269, 1269, 1269, 1270, 1270, 1270, 564,
		1257, 1257, 1257, 1257, 1257, 1258, 1258, 1258, 1265, 1265,
		1265, 1273, 1273, 1273, 568, 1263, 1263, 1263, 1263, 1263,
		1121, 1121, 1121, 567, 1261, 1261, 1261, 1261, 1261, 1262,
		1262, 1262, 557, 1248, 1248, 1248, 1248, 1248, 558, 1249,
		1249, 1249, 1249, 1249, 1250, 1250, 1250, 562, 1255, 1255,
		1255, 1255, 1255, 561, 1253, 1253, 1253, 1253, 1253, 1254,
		1254, 1254, 587, 1307, 1307, 1307, 1307, 1307, 1308, 1308,
		1308, 545, 1217, 991, 991, 991, 990, 990, 990, 993,
		992, 1228, 1228, 1228, 1229, 1229, 1229, 1381, 1381, 1382,
		1382, 1381, 1381, 1381, 1382, 1382, 1382, 1374, 1374, 1374,
		1374, 1374, 1375, 1375, 1375, 1368, 1368, 1369, 1369, 1368,
		1368, 1368, 1369, 1369, 1369, 1420, 1420, 1420, 1419, 1419,
		1419, 1422, 1421, 1442, 1442, 1442, 1441, 1441, 1441, 1444,
		1443, 1162, 1162, 1162, 1163, 1163, 1163, 1164, 1164, 1164,
		866, 866, 866, 1084, 1165, 1165, 1165, 1085, 1312, 1312,
		1312, 1315, 1315, 1315, 1313, 1313, 1313, 1314, 1314, 1314,
		1119, 1119, 1119, 1119, 1119, 1122, 1122, 802, 802, 802,
		1122, 1122, 1122, 801, 803, 803, 805, 805, 804, 806,
		1190, 1190, 1190, 1193, 1193, 1193, 1150, 1150, 1150, 1153,
		1153, 1153, 1113, 1113, 1113, 1114, 1114, 1114, 790, 790,
		790, 789, 789, 789, 1112, 1112, 1112, 1115, 1115, 1115,
		1082, 1082, 1082, 1083, 1083, 1083, 1347, 1347, 1347, 1345,
		1345, 1345, 1346, 1346, 1346, 1355, 1355, 1355, 820, 820,
		820, 819, 819, 819, 1353, 1353, 1353, 1354, 1354, 1354,
		1170, 1170, 1170, 1175, 1175, 1175, 1171, 1171, 1171, 1174,
		1174, 1174, 1173, 1173, 1173, 1172, 1172, 1172, 1118, 1118,
		1118, 1118, 1118, 1123, 1123, 1123, 1123, 1123, 1118, 1118,
		1118, 1123, 1123, 1123, 1119, 1119, 1119, 1122, 1122, 1122,
		1183, 1183, 1183, 1188, 1188, 1188, 1184, 1184, 1184, 1187,
		1187, 1187, 1186, 1186, 1186, 1185, 1185, 1185, 291, 291,
		295, 295, 294, 294, 1310, 1310, 1310, 874, 874, 874,
		873, 873, 873, 1191, 1191, 1191, 1192, 1192, 1192, 816,
		816, 816, 815, 815, 815, 1151, 1151, 1151, 1152, 1152,
		1152, 1246, 1246, 1247, 1247, 1168, 1168, 1168, 1189, 1189,
		1189, 1246, 1246, 1247, 1247, 1358, 1358, 1358, 1198, 1198,
		1199, 1199, 1198, 1198, 1198, 1199, 1199, 1199, 1200, 1200,
		1201, 1201, 1200, 1200, 1200, 1201, 1201, 1201, 979, 979,
		978, 978, 979, 979, 979, 978, 978, 978, 989, 989,
		988, 988, 989, 989, 989, 988, 988, 988, 907, 907,
		906, 906, 907, 907, 907, 906, 906, 906, 927, 927,
		926, 926, 927, 927, 927, 926, 926, 926, 891, 891,
		890, 890, 891, 891, 891, 890, 890, 890, 893, 892,
		893, 892, 915, 915, 914, 914, 915, 915, 915, 914,
		914, 914, 767, 917, 916, 917, 916, 768, 939, 939,
		938, 938, 939, 939, 939, 938, 938, 938, 941, 940,
		941, 940, 955, 955, 954, 954, 955, 955, 955, 954,
		954, 954, 957, 956, 957, 956, 1333, 1333, 1333, 1334,
		1334, 1334, 1335, 1335, 1335, 1336, 1336, 1336, 1456, 1456,
		1456, 1455, 1455, 1455, 1466, 1466, 1466, 1465, 1465, 1465,
		909, 909, 908, 908, 909, 909, 909, 908, 908, 908,
		929, 929, 928, 928, 929, 929, 929, 928, 928, 928,
		895, 895, 894, 894, 895, 895, 895, 894, 894, 894,
		897, 896, 897, 896, 919, 919, 918, 918, 919, 919,
		919, 918, 918, 918, 769, 921, 920, 921, 920, 770,
		943, 943, 942, 942, 943, 943, 943, 942, 942, 942,
		945, 944, 945, 944, 959, 959, 958, 958, 959, 959,
		959, 958, 958, 958, 961, 960, 961, 960, 1243, 1243,
		1243, 1242, 1242, 1242, 911, 911, 910, 910, 911, 911,
		911, 910, 910, 910, 931, 931, 930, 930, 931, 931,
		931, 930, 930, 930, 899, 899, 898, 898, 899, 899,
		899, 898, 898, 898, 901, 900, 901, 900, 923, 923,
		922, 922, 923, 923, 923, 922, 922, 922, 925, 924,
		925, 924, 947, 947, 946, 946, 947, 947, 947, 946,
		946, 946, 949, 948, 949, 948, 963, 963, 962, 962,
		963, 963, 963, 962, 962, 962, 965, 964, 965, 964,
		1160, 1160, 1160, 1161, 1161, 1161, 981, 980, 985, 984,
		1458, 1457, 1462, 1461, 983, 982, 987, 986, 1460, 1459,
		1464, 1463, 707, 872, 871, 705, 706, 1424, 1423, 711,
		1426, 1425, 709, 1446, 1445, 710, 1448, 1447, 269, 1000,
		1000, 1000, 1000, 1000, 19, 781, 17, 779, 779, 779,
		779, 779, 18, 780, 780, 780, 780, 780, 15, 777,
		777, 777, 777, 777, 16, 778, 778, 778, 778, 778,
		417, 417, 417, 108, 108, 417, 417, 417, 108, 108,
		108, 22, 22, 42, 42, 41, 41, 39, 39, 58,
		58, 1503, 1504, 516, 516, 515, 515, 1501, 1502, 6,
		6, 14, 14, 461, 461, 28, 28, 714, 714, 679,
		679, 717, 717, 420, 420, 420, 154, 154, 154, 153,
		153, 153, 421, 421, 1182, 1182, 1182, 1180, 1180, 1180,
		1111, 1111, 783, 783, 783, 784, 784, 784, 1179, 1179,
		1179, 1179, 1179, 1178, 1178, 1178, 1178, 1178, 1166, 668,
		1438, 1438, 1434, 1434, 1434, 667, 1437, 1437, 1433, 1433,
		1433, 670, 1440, 1436, 669, 1439, 1435, 35, 792, 792,
		34, 791, 791, 497, 1117, 1117, 489, 489, 1102, 1102,
		1102, 1102, 1102, 517, 517, 1194, 1194, 1194, 1194, 520,
		520, 1197, 1197, 1197, 1197, 518, 519, 1195, 1196, 1195,
		1196, 156, 156, 885, 885, 885, 885, 1005, 1006, 1006,
		1008, 1008, 875, 876, 876, 878, 878, 1007, 1009, 877,
		879, 829, 829, 829, 829, 829, 1144, 1144, 1144, 1145,
		1145, 1145, 1127, 1127, 1127, 1142, 1142, 1142, 551, 551,
		1224, 1224, 1224, 1224, 284, 1015, 1015, 552, 553, 1225,
		1226, 1225, 1226, 1467, 1467, 1468, 1468, 1393, 1393, 1393,
		1394, 1394, 1394, 995, 995, 995, 994, 994, 994, 997,
		996, 350, 353, 351, 352, 346, 349, 347, 348, 1010,
		1011, 1011, 1013, 1013, 880, 881, 881, 883, 883, 1012,
		1014, 882, 884, 1143, 1143, 1143, 1146, 1146, 1146, 1126,
		1126, 1126, 1147, 1147, 1147, 144, 868, 868, 143, 867,
		455, 1066, 1066, 861, 861, 861, 1469, 1469, 1470, 1470,
		498, 1124, 1124, 1124, 1124, 1124, 1167, 1177, 1177, 1177,
		1177, 1176, 1176, 1176, 1176, 794, 794, 793, 793, 1116,
		1116, 1416, 1416, 1416, 1415, 1415, 1415, 1418, 1417, 887,
		887, 887, 886, 886, 886, 889, 888, 1430, 1430, 1430,
		1429, 1429, 1429, 1432, 1431, 913, 913, 913, 913, 912,
		912, 912, 912, 933, 933, 933, 933, 932, 932, 932,
		932, 505, 506, 1134, 1135, 503, 504, 1132, 1133, 512,
		1141, 511, 1140, 971, 971, 971, 970, 970, 970, 973,
		972, 903, 903, 903, 903, 902, 902, 902, 902, 905,
		905, 904, 904, 935, 935, 935, 935, 934, 934, 934,
		934, 937, 937, 936, 936, 1348, 1348, 1348, 1343, 1343,
		1343, 1344, 1344, 1344, 1356, 1356, 1356, 1351, 1351, 1351,
		1352, 1352, 1352, 951, 951, 951, 951, 950, 950, 950,
		950, 953, 953, 952, 952, 967, 967, 967, 967, 966,
		966, 966, 966, 969, 969, 968, 968, 708, 268, 999,
		999, 999, 999, 999, 267, 998, 998, 998, 998, 998,
		20, 782, 666, 666, 1237, 1236, 1235, 1233, 1234, 1239,
		1238, 1232, 1230, 1231, 1125, 1125, 1125, 1125, 1319, 1319,
		1240, 1241, 1328, 1331, 1329, 1330, 1148, 1159, 1149, 1154,
		1155, 1158, 1156, 1157, 29, 29, 38, 38, 33, 33,
		754, 754, 31, 31, 40, 40, 750, 750, 32, 32,
		30, 30, 383, 383, 723, 723, 975, 975, 974, 974,
		977, 976, 1328, 1328, 1331, 1331, 1329, 1329, 1330, 1330,
		1341, 1341, 1350, 1350, 1342, 1342, 1349, 1349, 1337, 1337,
		1340, 1340, 1338, 1338, 1339, 1339, 1204, 1202, 1203, 1215,
		1216, 1206, 1210, 1208, 1209, 1212, 1213, 1211, 1218, 1223,
		1220, 28, 28, 396, 396, 397, 397, 550, 549, 522,
		521, 536, 539, 531, 532, 526, 529, 533, 538, 540,
		524, 527, 528, 534, 537, 541, 523, 525, 530, 535,
		584, 629, 494, 1538, 1539, 1540, 1541, 1541, 1541, 1542,
		1543, 1544, 1545, 1545, 1545, 1546, 600, 595, 595, 595,
		595, 757, 1547, 1548, 1550, 1551, 1552, 1553, 1554, 1555,
		1556, 1557, 1558, 1559, 1560, 1561, 1563, 1564, 1565, 1566,
		1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1567,
		1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585,
		1586, 584, 1587, 1588, 1589, 1590, 1591, 1596, 1596, 1592,
		1596, 1593, 1594, 1596, 1596, 1596, 1596, 1596, 1595, 1597,
		1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607,
		1608, 1609, 1610, 1611, 808, 808, 807, 1547, 1621, 1622,
		1623, 1624, 1625, 1626, 1162, 1162, 1163, 1163, 1164, 1164,
		1165, 1165, 1627, 1627, 1627, 1628, 1628, 1628, 1629, 1629,
		1629, 1630, 1631, 1633, 1633, 1633, 1634, 1635, 1635, 1635,
		1636, 1637, 1638, 1638, 1638, 1639, 1639, 1639, 1640, 1640,
		1640, 1641, 1641, 1641, 1642, 1642, 1642, 1643, 1643, 1643,
		1644, 1644, 1644, 1645, 1645, 1645, 1646, 1646, 1646, 1647,
		1647, 1647, 1648, 1648, 1648, 1649, 1649, 1649, 1650, 1651,
		1652, 1652, 1653, 1654, 1654, 1655, 1655, 1656, 1657, 1657,
		1657, 1658, 1658, 1658, 1659, 1659, 1659, 1660, 1660, 1660,
		1661, 1661, 1661, 1662, 1662, 1662, 1663, 1663, 1664, 1664,
		1665, 1665, 1665, 1666, 1666, 1666, 1667, 1667, 1668, 1668,
		1668, 1669, 1669, 1669, 1670, 1670, 1670, 1671, 1672, 1672,
		1672, 1673, 1673, 1673, 1674, 1675, 1676, 1676, 1676, 1677,
		1677, 1677, 1678, 1679, 1680, 1680, 1680, 1681, 1681, 1681,
		1682, 1682, 1682, 1683, 1683, 1683, 1684, 1684, 1684, 1685,
		1685, 1685, 1686, 1686, 1686, 1687, 1687, 1687, 1688, 1688,
		1688, 1689, 1689, 1689, 1690, 1690, 1690, 1691, 1691, 1691,
		1692, 1693, 1694, 1695, 1696, 1697, 1698, 1698, 1698, 1699,
		1699, 1699, 1700, 1700, 1700, 1701, 1701, 1701, 1702, 1702,
		1702, 1703, 1703, 1703, 1704, 1705, 1706, 1707, 1708, 1709,
		1710, 1710, 1710, 1711, 1712, 1712, 1712, 1713, 1714, 1714,
		1714, 1715, 1716, 1716, 1716, 1717, 1718, 1718, 1718, 1719,
		1720, 1720, 1720, 1720, 1721, 1721, 1721, 1721, 1722, 1722,
		1722, 1723, 1724, 1724, 1724, 1725, 1726, 1726, 1726, 1727,
		1728, 1728, 1728, 1729, 1730, 1730, 1730, 1731, 1732, 1732,
		1732, 1733, 1734, 1734, 1734, 1735, 1736, 1736, 1736, 1737,
		1738, 1739, 1740, 1745, 1744, 1819, 1812, 1813, 1814, 1818,
		1815, 1816, 1817, 1746, 1747, 1748, 1755, 1756, 1758, 1759,
		1752, 1753, 1745, 1744, 1754, 1754, 1754, 1749, 1750, 1757,
		1743, 1743, 1760, 1760, 1742, 1741, 592, 592, 753, 753,
		1761, 1761, 398, 398, 1596, 1596, 1596, 1596, 1596, 1596,
		1751, 1819, 1812, 1813, 1814, 1818, 1815, 1816, 1817, 1036,
		1035, 1036, 1035, 1791, 1793, 1792, 1794, 772, 771, 1074,
		1073, 828, 822, 1479, 1478, 1137, 1040, 1041, 1359, 1378,
		1372, 1365, 1129, 855, 1040, 1041, 1742, 1741, 810, 809,
		1104, 1108, 1106, 1107, 817, 1317, 1318, 1413, 1414, 1386,
		1095, 808, 807, 797, 800, 1397, 1169, 1257, 1261, 1249,
		1253, 1307, 991, 990, 1381, 1374, 1368, 1596, 1596, 1596,
		1596, 1763, 1762, 1777, 1781, 1780, 1779, 1778, 1596, 1773,
		1772, 1596, 1596, 1119, 1122, 803, 806, 1803, 1804, 1820,
		1824, 1113, 1114, 790, 789, 1596, 1596, 1596, 1596, 1596,
		1822, 1833, 1832, 1821, 1823, 1596, 1596, 1596, 1596, 1806,
		1829, 1811, 1810, 1198, 1199, 979, 978, 1596, 1596, 891,
		890, 915, 914, 939, 938, 955, 954, 1333, 1334, 1456,
		1455, 1774, 895, 894, 919, 918, 943, 942, 959, 958,
		1596, 1596, 1809, 1808, 899, 898, 923, 922, 947, 946,
		963, 962, 1596, 1776, 1775, 981, 985, 1831, 1830, 1458,
		1462, 1771, 1790, 1825, 1828, 1764, 1805, 1596, 1596, 1596,
		1786, 1789, 1799, 1802, 1788, 1787, 1801, 1800, 1596, 1596,
		1596, 1782, 1785, 1795, 1798, 1784, 1783, 1797, 1796, 1596,
		1596, 1596, 783, 1807, 1144, 1127, 995, 994, 1827, 1826,
		1770, 1769, 1767, 1765, 1768, 1596, 1596, 1766, 1596, 1596,
		1596, 1596, 1596, 1596, 1834, 1834, 1834, 1835, 1835, 1835,
		1836, 1836, 1836, 1837
	};
}


internal enum OpKind
{
	Register,
	NearBranch16,
	NearBranch32,
	NearBranch64,
	FarBranch16,
	FarBranch32,
	Immediate8,
	Immediate8_2nd,
	Immediate16,
	Immediate32,
	Immediate64,
	Immediate8to16,
	Immediate8to32,
	Immediate8to64,
	Immediate32to64,
	MemorySegSI,
	MemorySegESI,
	MemorySegRSI,
	MemorySegDI,
	MemorySegEDI,
	MemorySegRDI,
	MemoryESDI,
	MemoryESEDI,
	MemoryESRDI,
	Memory
}


using System;
using System.ComponentModel;

internal enum Register
{
	None,
	AL,
	CL,
	DL,
	BL,
	AH,
	CH,
	DH,
	BH,
	SPL,
	BPL,
	SIL,
	DIL,
	R8L,
	R9L,
	R10L,
	R11L,
	R12L,
	R13L,
	R14L,
	R15L,
	AX,
	CX,
	DX,
	BX,
	SP,
	BP,
	SI,
	DI,
	R8W,
	R9W,
	R10W,
	R11W,
	R12W,
	R13W,
	R14W,
	R15W,
	EAX,
	ECX,
	EDX,
	EBX,
	ESP,
	EBP,
	ESI,
	EDI,
	R8D,
	R9D,
	R10D,
	R11D,
	R12D,
	R13D,
	R14D,
	R15D,
	RAX,
	RCX,
	RDX,
	RBX,
	RSP,
	RBP,
	RSI,
	RDI,
	R8,
	R9,
	R10,
	R11,
	R12,
	R13,
	R14,
	R15,
	EIP,
	RIP,
	ES,
	CS,
	SS,
	DS,
	FS,
	GS,
	XMM0,
	XMM1,
	XMM2,
	XMM3,
	XMM4,
	XMM5,
	XMM6,
	XMM7,
	XMM8,
	XMM9,
	XMM10,
	XMM11,
	XMM12,
	XMM13,
	XMM14,
	XMM15,
	XMM16,
	XMM17,
	XMM18,
	XMM19,
	XMM20,
	XMM21,
	XMM22,
	XMM23,
	XMM24,
	XMM25,
	XMM26,
	XMM27,
	XMM28,
	XMM29,
	XMM30,
	XMM31,
	YMM0,
	YMM1,
	YMM2,
	YMM3,
	YMM4,
	YMM5,
	YMM6,
	YMM7,
	YMM8,
	YMM9,
	YMM10,
	YMM11,
	YMM12,
	YMM13,
	YMM14,
	YMM15,
	YMM16,
	YMM17,
	YMM18,
	YMM19,
	YMM20,
	YMM21,
	YMM22,
	YMM23,
	YMM24,
	YMM25,
	YMM26,
	YMM27,
	YMM28,
	YMM29,
	YMM30,
	YMM31,
	ZMM0,
	ZMM1,
	ZMM2,
	ZMM3,
	ZMM4,
	ZMM5,
	ZMM6,
	ZMM7,
	ZMM8,
	ZMM9,
	ZMM10,
	ZMM11,
	ZMM12,
	ZMM13,
	ZMM14,
	ZMM15,
	ZMM16,
	ZMM17,
	ZMM18,
	ZMM19,
	ZMM20,
	ZMM21,
	ZMM22,
	ZMM23,
	ZMM24,
	ZMM25,
	ZMM26,
	ZMM27,
	ZMM28,
	ZMM29,
	ZMM30,
	ZMM31,
	K0,
	K1,
	K2,
	K3,
	K4,
	K5,
	K6,
	K7,
	BND0,
	BND1,
	BND2,
	BND3,
	CR0,
	CR1,
	CR2,
	CR3,
	CR4,
	CR5,
	CR6,
	CR7,
	CR8,
	CR9,
	CR10,
	CR11,
	CR12,
	CR13,
	CR14,
	CR15,
	DR0,
	DR1,
	DR2,
	DR3,
	DR4,
	DR5,
	DR6,
	DR7,
	DR8,
	DR9,
	DR10,
	DR11,
	DR12,
	DR13,
	DR14,
	DR15,
	ST0,
	ST1,
	ST2,
	ST3,
	ST4,
	ST5,
	ST6,
	ST7,
	MM0,
	MM1,
	MM2,
	MM3,
	MM4,
	MM5,
	MM6,
	MM7,
	TR0,
	TR1,
	TR2,
	TR3,
	TR4,
	TR5,
	TR6,
	TR7,
	TMM0,
	TMM1,
	TMM2,
	TMM3,
	TMM4,
	TMM5,
	TMM6,
	TMM7,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUse0,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUseFA,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUseFB,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUseFC,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUseFD,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUseFE,
	[Obsolete("Not part of the public API", false)]
	[EditorBrowsable(EditorBrowsableState.Never)]
	DontUseFF
}


using Iced.Intel;

internal static class RegisterExtensions
{
	public static bool IsSegmentRegister(this Register register)
	{
		if (Register.ES <= register)
		{
			return register <= Register.GS;
		}
		return false;
	}

	public static bool IsGPR(this Register register)
	{
		if (Register.AL <= register)
		{
			return register <= Register.R15;
		}
		return false;
	}

	public static bool IsGPR8(this Register register)
	{
		if (Register.AL <= register)
		{
			return register <= Register.R15L;
		}
		return false;
	}

	public static bool IsGPR16(this Register register)
	{
		if (Register.AX <= register)
		{
			return register <= Register.R15W;
		}
		return false;
	}

	public static bool IsGPR32(this Register register)
	{
		if (Register.EAX <= register)
		{
			return register <= Register.R15D;
		}
		return false;
	}

	public static bool IsGPR64(this Register register)
	{
		if (Register.RAX <= register)
		{
			return register <= Register.R15;
		}
		return false;
	}

	public static bool IsXMM(this Register register)
	{
		if (Register.XMM0 <= register)
		{
			return register <= Register.XMM31;
		}
		return false;
	}

	public static bool IsYMM(this Register register)
	{
		if (Register.YMM0 <= register)
		{
			return register <= Register.YMM31;
		}
		return false;
	}

	public static bool IsZMM(this Register register)
	{
		if (Register.ZMM0 <= register)
		{
			return register <= Register.ZMM31;
		}
		return false;
	}

	public static bool IsIP(this Register register)
	{
		if (register != Register.EIP)
		{
			return register == Register.RIP;
		}
		return true;
	}

	public static bool IsK(this Register register)
	{
		if (Register.K0 <= register)
		{
			return register <= Register.K7;
		}
		return false;
	}

	public static bool IsCR(this Register register)
	{
		if (Register.CR0 <= register)
		{
			return register <= Register.CR15;
		}
		return false;
	}

	public static bool IsDR(this Register register)
	{
		if (Register.DR0 <= register)
		{
			return register <= Register.DR15;
		}
		return false;
	}

	public static bool IsTR(this Register register)
	{
		if (Register.TR0 <= register)
		{
			return register <= Register.TR7;
		}
		return false;
	}

	public static bool IsST(this Register register)
	{
		if (Register.ST0 <= register)
		{
			return register <= Register.ST7;
		}
		return false;
	}

	public static bool IsBND(this Register register)
	{
		if (Register.BND0 <= register)
		{
			return register <= Register.BND3;
		}
		return false;
	}

	public static bool IsMM(this Register register)
	{
		if (Register.MM0 <= register)
		{
			return register <= Register.MM7;
		}
		return false;
	}

	public static bool IsTMM(this Register register)
	{
		if (Register.TMM0 <= register)
		{
			return register <= Register.TMM7;
		}
		return false;
	}

	public static bool IsVectorRegister(this Register register)
	{
		if (Register.XMM0 <= register)
		{
			return register <= Register.ZMM31;
		}
		return false;
	}
}


internal enum RoundingControl
{
	None,
	RoundToNearest,
	RoundDown,
	RoundUp,
	RoundTowardZero
}


using System.Diagnostics;

internal static class Static
{
	[Conditional("E3967789CA584C48B3D02600CAB3C7B2")]
	public static void Assert(byte ignored)
	{
	}
}


using System.IO;
using Iced.Intel;

internal sealed class StreamCodeReader : CodeReader
{
	public readonly Stream Stream;

	public StreamCodeReader(Stream stream)
	{
		Stream = stream;
	}

	public override int ReadByte()
	{
		return Stream.ReadByte();
	}
}


using System.IO;
using Iced.Intel;

internal sealed class StreamCodeWriter : CodeWriter
{
	public readonly Stream Stream;

	public StreamCodeWriter(Stream stream)
	{
		Stream = stream;
	}

	public override void WriteByte(byte value)
	{
		Stream.WriteByte(value);
	}
}


using System;
using System.Diagnostics.CodeAnalysis;

internal static class ThrowHelper
{
	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentException()
	{
		throw new ArgumentException();
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowInvalidOperationException()
	{
		throw new InvalidOperationException();
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_codeWriter()
	{
		throw new ArgumentNullException("codeWriter");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_data()
	{
		throw new ArgumentNullException("data");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_writer()
	{
		throw new ArgumentNullException("writer");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_options()
	{
		throw new ArgumentNullException("options");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_value()
	{
		throw new ArgumentNullException("value");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_list()
	{
		throw new ArgumentNullException("list");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_collection()
	{
		throw new ArgumentNullException("collection");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_array()
	{
		throw new ArgumentNullException("array");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_sb()
	{
		throw new ArgumentNullException("sb");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentNullException_output()
	{
		throw new ArgumentNullException("output");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_value()
	{
		throw new ArgumentOutOfRangeException("value");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_index()
	{
		throw new ArgumentOutOfRangeException("index");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_count()
	{
		throw new ArgumentOutOfRangeException("count");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_length()
	{
		throw new ArgumentOutOfRangeException("length");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_operand()
	{
		throw new ArgumentOutOfRangeException("operand");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_instructionOperand()
	{
		throw new ArgumentOutOfRangeException("instructionOperand");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_capacity()
	{
		throw new ArgumentOutOfRangeException("capacity");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_memorySize()
	{
		throw new ArgumentOutOfRangeException("memorySize");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_size()
	{
		throw new ArgumentOutOfRangeException("size");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_elementSize()
	{
		throw new ArgumentOutOfRangeException("elementSize");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_register()
	{
		throw new ArgumentOutOfRangeException("register");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_code()
	{
		throw new ArgumentOutOfRangeException("code");
	}

	[<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturn]
	internal static void ThrowArgumentOutOfRangeException_data()
	{
		throw new ArgumentOutOfRangeException("data");
	}
}


internal enum TupleType
{
	N1,
	N2,
	N4,
	N8,
	N16,
	N32,
	N64,
	N8b4,
	N16b4,
	N32b4,
	N64b4,
	N16b8,
	N32b8,
	N64b8,
	N4b2,
	N8b2,
	N16b2,
	N32b2,
	N64b2
}


using System;
using System.Runtime.CompilerServices;
using Iced.Intel;

internal static class TupleTypeTable
{
	private static ReadOnlySpan<byte> tupleTypeData => new byte[38]
	{
		1, 1, 2, 2, 4, 4, 8, 8, 16, 16,
		32, 32, 64, 64, 8, 4, 16, 4, 32, 4,
		64, 4, 16, 8, 32, 8, 64, 8, 4, 2,
		8, 2, 16, 2, 32, 2, 64, 2
	};

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static uint GetDisp8N(TupleType tupleType, bool bcst)
	{
		int index = ((int)tupleType << 1) | (bcst ? 1 : 0);
		return tupleTypeData[index];
	}
}


internal enum VectorLength
{
	L128,
	L256,
	L512,
	Unknown
}


using System;

internal ref struct DataReader
{
	private readonly ReadOnlySpan<byte> data;

	private readonly char[] stringData;

	private int index;

	public int Index
	{
		readonly get
		{
			return index;
		}
		set
		{
			index = value;
		}
	}

	public readonly bool CanRead => (uint)index < (uint)data.Length;

	public DataReader(ReadOnlySpan<byte> data)
		: this(data, 0)
	{
	}

	public DataReader(ReadOnlySpan<byte> data, int maxStringLength)
	{
		this.data = data;
		stringData = ((maxStringLength == 0) ? Array2.Empty<char>() : new char[maxStringLength]);
		index = 0;
	}

	public byte ReadByte()
	{
		return data[index++];
	}

	public uint ReadCompressedUInt32()
	{
		uint num = 0u;
		for (int i = 0; i < 32; i += 7)
		{
			uint num2 = ReadByte();
			if ((num2 & 0x80) == 0)
			{
				return num | (num2 << i);
			}
			num |= (num2 & 0x7F) << i;
		}
		throw new InvalidOperationException();
	}

	public string ReadAsciiString()
	{
		int num = ReadByte();
		char[] array = stringData;
		for (int i = 0; i < num; i++)
		{
			array[i] = (char)ReadByte();
		}
		return new string(array, 0, num);
	}
}


