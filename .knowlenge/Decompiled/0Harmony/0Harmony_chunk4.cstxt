internal static class EncoderData
{
	internal static readonly uint[] EncFlags1 = GetEncFlags1();

	internal static readonly uint[] EncFlags2 = GetEncFlags2();

	internal static readonly uint[] EncFlags3 = GetEncFlags3();

	private static uint[] GetEncFlags1()
	{
		return new uint[4834]
		{
			0u, 0u, 0u, 0u, 0u, 2055u, 2312u, 2825u, 3339u, 912u,
			1042u, 1174u, 1434u, 6829u, 7471u, 7601u, 7730u, 39u, 39u, 39u,
			39u, 2055u, 2312u, 2825u, 3339u, 912u, 1042u, 1174u, 1434u, 6829u,
			7471u, 7601u, 7730u, 40u, 40u, 40u, 2055u, 2312u, 2825u, 3339u,
			912u, 1042u, 1174u, 1434u, 6829u, 7471u, 7601u, 7730u, 41u, 41u,
			41u, 41u, 2055u, 2312u, 2825u, 3339u, 912u, 1042u, 1174u, 1434u,
			6829u, 7471u, 7601u, 7730u, 42u, 42u, 42u, 42u, 2055u, 2312u,
			2825u, 3339u, 912u, 1042u, 1174u, 1434u, 6829u, 7471u, 7601u, 7730u,
			0u, 2055u, 2312u, 2825u, 3339u, 912u, 1042u, 1174u, 1434u, 6829u,
			7471u, 7601u, 7730u, 0u, 2055u, 2312u, 2825u, 3339u, 912u, 1042u,
			1174u, 1434u, 6829u, 7471u, 7601u, 7730u, 0u, 2055u, 2312u, 2825u,
			3339u, 912u, 1042u, 1174u, 1434u, 6829u, 7471u, 7601u, 7730u, 0u,
			21u, 25u, 21u, 25u, 21u, 25u, 29u, 21u, 25u, 29u,
			0u, 0u, 0u, 0u, 530u, 534u, 2312u, 2825u, 1042u, 1174u,
			1178u, 58u, 59u, 60u, 951314u, 967830u, 984474u, 55u, 56u, 57u,
			902162u, 918678u, 935322u, 6207u, 6207u, 6207u, 7984u, 7984u, 7984u, 66u,
			67u, 68u, 66u, 67u, 68u, 66u, 67u, 68u, 66u, 67u,
			68u, 66u, 67u, 68u, 66u, 67u, 68u, 66u, 67u, 68u,
			66u, 67u, 68u, 66u, 67u, 68u, 66u, 67u, 68u, 66u,
			67u, 68u, 66u, 67u, 68u, 66u, 67u, 68u, 66u, 67u,
			68u, 66u, 67u, 68u, 66u, 67u, 68u, 6791u, 6791u, 6791u,
			6791u, 6791u, 6791u, 6791u, 6791u, 7432u, 7561u, 7691u, 7432u, 7561u,
			7691u, 7432u, 7561u, 7691u, 7432u, 7561u, 7691u, 7432u, 7561u, 7691u,
			7432u, 7561u, 7691u, 7432u, 7561u, 7691u, 7432u, 7561u, 7691u, 6791u,
			6791u, 6791u, 6791u, 6791u, 6791u, 6791u, 6791u, 7048u, 7177u, 7307u,
			7048u, 7177u, 7307u, 7048u, 7177u, 7307u, 7048u, 7177u, 7307u, 7048u,
			7177u, 7307u, 7048u, 7177u, 7307u, 7048u, 7177u, 7307u, 7048u, 7177u,
			7307u, 2055u, 2312u, 2825u, 3339u, 2055u, 2312u, 2825u, 3339u, 2055u,
			2312u, 2825u, 3339u, 912u, 1042u, 1174u, 1434u, 3848u, 3849u, 3851u,
			530u, 534u, 538u, 1054u, 1182u, 1438u, 8u, 9u, 11u, 0u,
			0u, 0u, 6037u, 6297u, 6429u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 1u, 2u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 429u, 431u, 433u, 434u, 5763u, 6019u, 6275u,
			6403u, 7999u, 7999u, 7999u, 7999u, 8126u, 8126u, 8126u, 8126u, 6829u,
			7471u, 7601u, 7730u, 5823u, 6079u, 6335u, 6463u, 7981u, 7983u, 7985u,
			7986u, 8109u, 8111u, 8113u, 8114u, 6801u, 7445u, 7577u, 7837u, 6791u,
			6791u, 6791u, 6791u, 6791u, 6791u, 6791u, 6791u, 6792u, 6793u, 6795u,
			6792u, 6793u, 6795u, 6792u, 6793u, 6795u, 6792u, 6793u, 6795u, 6792u,
			6793u, 6795u, 6792u, 6793u, 6795u, 6792u, 6793u, 6795u, 6792u, 6793u,
			6795u, 58u, 58u, 58u, 0u, 0u, 0u, 530u, 534u, 530u,
			534u, 6791u, 53u, 7432u, 7561u, 7691u, 72u, 73u, 6842u, 6842u,
			6842u, 0u, 0u, 0u, 58u, 58u, 58u, 0u, 0u, 0u,
			0u, 53u, 0u, 0u, 0u, 0u, 6919u, 6919u, 6919u, 6919u,
			6919u, 6919u, 6919u, 6919u, 6920u, 6921u, 6923u, 6920u, 6921u, 6923u,
			6920u, 6921u, 6923u, 6920u, 6921u, 6923u, 6920u, 6921u, 6923u, 6920u,
			6921u, 6923u, 6920u, 6921u, 6923u, 6920u, 6921u, 6923u, 5895u, 5895u,
			5895u, 5895u, 5895u, 5895u, 5895u, 5895u, 5896u, 5897u, 5899u, 5896u,
			5897u, 5899u, 5896u, 5897u, 5899u, 5896u, 5897u, 5899u, 5896u, 5897u,
			5899u, 5896u, 5897u, 5899u, 5896u, 5897u, 5899u, 5896u, 5897u, 5899u,
			53u, 53u, 0u, 65u, 4u, 4u, 4u, 4u, 4u, 4u,
			4u, 4u, 6707u, 6707u, 6707u, 6707u, 6707u, 6707u, 6707u, 6707u,
			4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u,
			4u, 4u, 52u, 6707u, 0u, 52u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 4u, 4u, 4u, 4u, 4u, 4u, 4u,
			4u, 6707u, 6707u, 6707u, 6707u, 0u, 4u, 4u, 4u, 4u,
			4u, 4u, 6707u, 6707u, 6707u, 6707u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 6707u, 6707u, 4u,
			4u, 4u, 4u, 4u, 4u, 4u, 4u, 6580u, 6580u, 6707u,
			6707u, 6580u, 6580u, 6580u, 6580u, 4u, 4u, 4u, 4u, 4u,
			4u, 4u, 4u, 4u, 4u, 4u, 4u, 52u, 6707u, 52u,
			52u, 6707u, 6707u, 4u, 4u, 4u, 4u, 4u, 4u, 4u,
			4u, 6580u, 6580u, 6707u, 0u, 6580u, 6580u, 6580u, 6580u, 4u,
			4u, 4u, 4u, 4u, 4u, 4u, 4u, 52u, 6707u, 52u,
			52u, 47u, 47u, 47u, 47u, 6707u, 6707u, 66u, 67u, 66u,
			67u, 68u, 66u, 68u, 66u, 67u, 66u, 67u, 68u, 66u,
			68u, 66u, 67u, 66u, 67u, 68u, 66u, 68u, 66u, 67u,
			66u, 67u, 68u, 66u, 68u, 6829u, 6831u, 6833u, 5813u, 6069u,
			6325u, 69u, 70u, 71u, 69u, 70u, 71u, 1u, 2u, 66u,
			67u, 68u, 6189u, 6191u, 6193u, 5808u, 6064u, 6320u, 0u, 0u,
			0u, 6791u, 6791u, 7u, 7u, 7u, 7u, 7u, 7u, 7432u,
			7561u, 7691u, 7432u, 7561u, 7691u, 8u, 9u, 11u, 8u, 9u,
			11u, 8u, 9u, 11u, 8u, 9u, 11u, 8u, 9u, 11u,
			8u, 9u, 11u, 0u, 0u, 0u, 0u, 0u, 0u, 7u,
			7u, 8u, 9u, 11u, 8u, 9u, 11u, 8u, 9u, 11u,
			4u, 4u, 4u, 8u, 9u, 11u, 4u, 4u, 4u, 8u,
			9u, 11u, 8u, 9u, 11u, 8u, 9u, 11u, 8u, 9u,
			11u, 8u, 9u, 11u, 8u, 9u, 11u, 8u, 9u, 11u,
			8u, 9u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u,
			4u, 4u, 4u, 4u, 8u, 9u, 11u, 4u, 8u, 9u,
			11u, 4u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			2312u, 2825u, 3339u, 4u, 4u, 4u, 0u, 2055u, 2312u, 2825u,
			912u, 1042u, 1174u, 1825u, 532u, 601u, 340u, 376u, 411u, 1825u,
			532u, 601u, 340u, 376u, 411u, 1825u, 87444u, 84u, 22228u, 52u,
			1825u, 87444u, 84u, 22228u, 52u, 4238u, 1288u, 1609u, 650u, 779u,
			876u, 4238u, 1288u, 1609u, 650u, 779u, 876u, 4238u, 83349u, 1281u,
			21205u, 641u, 4238u, 83349u, 1281u, 21205u, 641u, 4385u, 545u, 87444u,
			5524u, 22228u, 1748u, 545u, 5524u, 1748u, 1825u, 532u, 601u, 340u,
			376u, 411u, 1825u, 532u, 601u, 340u, 376u, 411u, 4228u, 1281u,
			641u, 4228u, 1281u, 641u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 4385u, 87444u,
			22228u, 545u, 5524u, 1748u, 545u, 5524u, 1748u, 1825u, 532u, 601u,
			340u, 376u, 411u, 4228u, 1281u, 641u, 4228u, 1281u, 641u, 2312u,
			2825u, 3339u, 2312u, 2825u, 3339u, 2312u, 2825u, 3339u, 2312u, 2825u,
			3339u, 2312u, 2825u, 3339u, 2312u, 2825u, 3339u, 2312u, 2825u, 3339u,
			2312u, 2825u, 3339u, 4u, 4u, 4u, 4u, 806u, 1958u, 1958u,
			1318u, 1574u, 1318u, 1574u, 4870u, 4879u, 4879u, 678u, 678u, 1318u,
			1574u, 4u, 24u, 28u, 0u, 0u, 8u, 9u, 11u, 2147488152u,
			2147488156u, 4632u, 4636u, 2147486755u, 2147487267u, 3108u, 3620u, 4760u, 3109u, 1825u,
			532u, 601u, 340u, 376u, 411u, 1825u, 532u, 601u, 340u, 376u,
			411u, 4238u, 1288u, 1609u, 650u, 779u, 876u, 4238u, 1288u, 1609u,
			650u, 779u, 876u, 1697u, 1697u, 1185u, 1441u, 26004u, 30100u, 8916u,
			9940u, 1185u, 1441u, 26004u, 30100u, 1073750740u, 9940u, 4228u, 1281u, 1601u,
			641u, 769u, 865u, 4228u, 1281u, 1601u, 641u, 769u, 865u, 4228u,
			4228u, 1823u, 1823u, 1814u, 1818u, 523u, 526u, 333u, 335u, 1814u,
			1818u, 523u, 526u, 333u, 335u, 1823u, 1823u, 1814u, 1818u, 523u,
			526u, 333u, 335u, 1814u, 1818u, 523u, 526u, 333u, 335u, 1825u,
			532u, 340u, 1825u, 532u, 340u, 1825u, 1825u, 532u, 532u, 340u,
			340u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1042u,
			1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u,
			1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u,
			1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 1042u,
			1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u,
			1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 74961u, 74961u, 74961u,
			74961u, 74961u, 74961u, 74961u, 74961u, 1169u, 1169u, 1169u, 1169u, 74961u,
			74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 74961u,
			74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 74961u, 4374u, 4378u,
			1355u, 1358u, 1675u, 1678u, 4374u, 4378u, 1355u, 1358u, 1675u, 1678u,
			1825u, 532u, 601u, 340u, 376u, 411u, 1825u, 532u, 601u, 340u,
			376u, 411u, 1825u, 34196u, 10964u, 1825u, 34196u, 10964u, 1825u, 532u,
			601u, 1825u, 34196u, 1825u, 532u, 601u, 1825u, 34196u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u,
			10964u, 1825u, 34196u, 10964u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 10964u, 1825u,
			34196u, 10964u, 1825u, 532u, 537u, 340u, 344u, 379u, 1825u, 532u,
			596u, 340u, 372u, 408u, 1825u, 34196u, 10964u, 1825u, 34196u, 10964u,
			1825u, 532u, 601u, 340u, 376u, 411u, 340u, 372u, 408u, 1825u,
			532u, 601u, 340u, 376u, 411u, 1825u, 532u, 601u, 340u, 376u,
			411u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1825u, 34196u, 10964u, 1825u, 34196u, 10964u, 1825u,
			34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u,
			13243u, 1825u, 34196u, 10964u, 1825u, 34196u, 10964u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u,
			34196u, 10964u, 1825u, 34196u, 10964u, 1825u, 34196u, 38617u, 10964u, 12120u,
			13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 10964u,
			1825u, 34196u, 10964u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u,
			13243u, 1695u, 1825u, 34196u, 38617u, 10961u, 12113u, 13233u, 1695u, 1825u,
			34196u, 38617u, 10961u, 12113u, 13233u, 1695u, 1825u, 34196u, 38617u, 10961u,
			12113u, 13233u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1183u,
			1439u, 1185u, 1441u, 404u, 468u, 276u, 308u, 1695u, 1825u, 532u,
			601u, 340u, 376u, 411u, 340u, 376u, 411u, 1825u, 532u, 601u,
			340u, 376u, 411u, 340u, 376u, 411u, 340u, 376u, 411u, 340u,
			376u, 411u, 870047u, 870177u, 127508u, 127577u, 32084u, 32120u, 32155u, 870177u,
			127508u, 127577u, 32084u, 32120u, 32155u, 870177u, 127508u, 127577u, 32084u, 32120u,
			32155u, 6816u, 6818u, 128342u, 128667u, 32086u, 32122u, 32157u, 6816u, 6818u,
			128342u, 128667u, 32086u, 32122u, 32157u, 6816u, 6818u, 128342u, 128667u, 32086u,
			32122u, 32157u, 32086u, 32122u, 32157u, 32086u, 32122u, 32157u, 32086u, 32122u,
			32157u, 32086u, 32122u, 32157u, 6816u, 6818u, 128342u, 128667u, 32086u, 32122u,
			32157u, 6816u, 6818u, 128342u, 128667u, 32086u, 32122u, 32157u, 32086u, 32122u,
			32157u, 6816u, 6818u, 128342u, 128667u, 32086u, 32122u, 32157u, 6816u, 6818u,
			128342u, 128667u, 32086u, 32122u, 32157u, 6818u, 128342u, 128667u, 32086u, 32122u,
			32157u, 6816u, 6818u, 128342u, 128667u, 32086u, 32122u, 32157u, 6818u, 128342u,
			128667u, 32086u, 32122u, 32157u, 1695u, 1825u, 34196u, 38617u, 10961u, 12113u,
			13233u, 1695u, 1825u, 34196u, 38617u, 10961u, 12113u, 13233u, 1695u, 1825u,
			34196u, 38617u, 10961u, 12113u, 13233u, 0u, 0u, 0u, 2825u, 3339u,
			340u, 376u, 411u, 340u, 372u, 408u, 875170u, 340u, 344u, 379u,
			340u, 376u, 411u, 333u, 335u, 112021793u, 333u, 335u, 1174u, 1434u,
			340u, 376u, 411u, 340u, 372u, 408u, 4385u, 340u, 344u, 379u,
			340u, 376u, 411u, 333u, 335u, 4385u, 333u, 335u, 340u, 344u,
			379u, 340u, 376u, 411u, 340u, 344u, 1073742203u, 340u, 376u, 411u,
			340u, 376u, 411u, 340u, 372u, 408u, 340u, 344u, 379u, 340u,
			376u, 411u, 8916u, 9940u, 1073750740u, 9940u, 1825u, 34196u, 38617u, 1825u,
			34196u, 38617u, 1825u, 34196u, 38617u, 1825u, 34196u, 38617u, 3977u, 3979u,
			4233u, 4235u, 1286u, 1287u, 648u, 649u, 1825u, 532u, 340u, 3981u,
			4238u, 1288u, 1609u, 650u, 779u, 876u, 650u, 779u, 876u, 4238u,
			1288u, 1609u, 650u, 779u, 876u, 650u, 779u, 876u, 650u, 779u,
			876u, 650u, 779u, 876u, 69u, 70u, 71u, 69u, 70u, 71u,
			69u, 70u, 71u, 69u, 70u, 71u, 69u, 70u, 71u, 69u,
			70u, 71u, 69u, 70u, 71u, 69u, 70u, 71u, 69u, 70u,
			71u, 69u, 70u, 71u, 69u, 70u, 71u, 69u, 70u, 71u,
			69u, 70u, 71u, 69u, 70u, 71u, 69u, 70u, 71u, 69u,
			70u, 71u, 7u, 7u, 7u, 7u, 7u, 7u, 7u, 7u,
			7u, 7u, 7u, 7u, 7u, 7u, 7u, 7u, 657u, 657u,
			657u, 657u, 1089u, 1089u, 1089u, 1089u, 785u, 785u, 785u, 977u,
			1163u, 1163u, 1163u, 1166u, 1169u, 1169u, 1169u, 1169u, 1169u, 1169u,
			1169u, 1169u, 43u, 43u, 43u, 43u, 43u, 43u, 0u, 2312u,
			2825u, 3339u, 870664u, 871177u, 871691u, 755976u, 756489u, 757003u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 1042u, 1174u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 2312u, 2825u, 2055u,
			2312u, 2825u, 44u, 44u, 44u, 44u, 44u, 44u, 0u, 2312u,
			2825u, 3339u, 870664u, 871177u, 871691u, 755976u, 756489u, 757003u, 4u, 4u,
			24u, 28u, 4u, 4u, 24u, 28u, 4u, 24u, 28u, 1u,
			4u, 24u, 28u, 1u, 4u, 4u, 9u, 11u, 4u, 4u,
			24u, 28u, 4u, 4u, 4u, 24u, 28u, 4u, 20u, 24u,
			28u, 24u, 28u, 4u, 4u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			1042u, 1174u, 1434u, 2055u, 2312u, 2825u, 3339u, 530u, 534u, 538u,
			2312u, 2825u, 3339u, 530u, 534u, 538u, 530u, 534u, 538u, 914u,
			918u, 922u, 1042u, 1046u, 1050u, 74u, 75u, 1042u, 1174u, 1434u,
			1042u, 1174u, 1434u, 6792u, 6793u, 6795u, 6792u, 6793u, 6795u, 6792u,
			6793u, 6795u, 6792u, 6793u, 6795u, 2312u, 2825u, 3339u, 1042u, 1174u,
			1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u, 1042u, 1174u, 1434u,
			914u, 918u, 922u, 1042u, 1046u, 1050u, 2055u, 2312u, 2825u, 3339u,
			870177u, 8160660u, 8165081u, 1026769u, 1027921u, 1029041u, 870177u, 8160660u, 8165081u, 1026769u,
			1027921u, 1029041u, 870177u, 8160660u, 1026769u, 870177u, 8160660u, 1026769u, 2820u, 3332u,
			869535u, 869791u, 869537u, 869793u, 8152468u, 8156564u, 1024724u, 1025748u, 872470u, 872474u,
			872726u, 872730u, 128331u, 128334u, 32429u, 32431u, 870177u, 8160660u, 8165081u, 1026772u,
			1027928u, 1029051u, 870177u, 8160660u, 8165081u, 1026772u, 1027928u, 1029051u, 4u, 4u,
			4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, 4u, 20u,
			24u, 28u, 4u, 20u, 24u, 28u, 24u, 28u, 21u, 25u,
			29u, 1825u, 34196u, 38617u, 1825u, 34196u, 38617u, 1695u, 1825u, 34196u,
			34521u, 10964u, 11096u, 11195u, 1695u, 1825u, 34196u, 34521u, 10964u, 11096u,
			11195u, 1695u, 1825u, 34196u, 34521u, 10964u, 11096u, 11195u, 1695u, 1825u,
			34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 4238u, 1288u, 650u, 4129u, 4383u, 4118u, 4122u, 4374u,
			4378u, 1355u, 1358u, 1675u, 1678u, 1695u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 34521u, 10964u, 11096u,
			11195u, 1695u, 1825u, 34196u, 34521u, 10964u, 11096u, 11195u, 10964u, 11096u,
			11195u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u,
			34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1825u, 532u, 596u, 340u, 372u, 408u, 1825u, 532u,
			537u, 340u, 344u, 1073742203u, 340u, 376u, 411u, 1825u, 532u, 596u,
			340u, 372u, 408u, 3972u, 4228u, 1281u, 1601u, 641u, 769u, 865u,
			1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u,
			13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u,
			13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u,
			34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 545u, 84u, 89u, 1695u, 1825u, 34196u, 34521u, 10964u,
			11096u, 11195u, 1695u, 1825u, 34196u, 34521u, 10964u, 11096u, 11195u, 1695u,
			1825u, 34196u, 34521u, 10964u, 11096u, 11195u, 1695u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 528320u, 561344u, 87328u,
			1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u,
			13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u,
			34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1042u,
			1174u, 1434u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u,
			1825u, 34196u, 38617u, 1695u, 1825u, 34196u, 38617u, 1695u, 1825u, 34196u,
			38617u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1695u, 1825u,
			34196u, 38617u, 1695u, 1825u, 34196u, 38617u, 1695u, 1825u, 34196u, 38617u,
			1695u, 1825u, 34196u, 38617u, 1695u, 1825u, 34196u, 38617u, 1695u, 1825u,
			34196u, 38617u, 1695u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 34196u,
			38617u, 10964u, 12120u, 13243u, 34196u, 38617u, 10964u, 12120u, 13243u, 532u,
			601u, 532u, 601u, 1825u, 10964u, 12120u, 13243u, 650u, 778u, 875u,
			10964u, 12120u, 13243u, 650u, 778u, 874u, 10964u, 12120u, 13243u, 650u,
			778u, 874u, 532u, 537u, 340u, 344u, 379u, 650u, 778u, 875u,
			1825u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 650u, 778u, 874u,
			1825u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 650u, 778u, 875u,
			38617u, 12120u, 13243u, 12120u, 13243u, 1825u, 532u, 601u, 84u, 89u,
			340u, 344u, 347u, 89u, 344u, 347u, 344u, 347u, 89u, 56u,
			59u, 56u, 59u, 59u, 59u, 1695u, 1825u, 532u, 601u, 340u,
			376u, 411u, 1695u, 1825u, 532u, 601u, 340u, 376u, 411u, 1695u,
			1825u, 532u, 601u, 340u, 376u, 411u, 340u, 376u, 411u, 1825u,
			532u, 537u, 340u, 344u, 379u, 650u, 778u, 875u, 1825u, 532u,
			537u, 340u, 344u, 347u, 650u, 778u, 874u, 1825u, 532u, 537u,
			340u, 344u, 347u, 650u, 778u, 874u, 1825u, 532u, 537u, 340u,
			344u, 379u, 650u, 778u, 875u, 1825u, 532u, 537u, 340u, 344u,
			347u, 650u, 778u, 874u, 1825u, 532u, 537u, 340u, 344u, 379u,
			650u, 778u, 875u, 10961u, 12113u, 13233u, 10961u, 12113u, 13233u, 10961u,
			12113u, 13233u, 10961u, 12113u, 13233u, 10961u, 12113u, 13233u, 10961u, 12113u,
			13233u, 10961u, 12113u, 13233u, 10961u, 12113u, 13233u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 628u, 632u, 635u, 628u, 632u, 635u, 1825u,
			34196u, 38617u, 10961u, 12113u, 13233u, 689u, 817u, 913u, 689u, 817u,
			913u, 545u, 84u, 89u, 52u, 56u, 59u, 628u, 632u, 635u,
			1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 5524u, 5849u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 5524u, 5849u, 10964u, 10964u, 83329u, 104129u,
			83329u, 104129u, 1825u, 532u, 537u, 340u, 344u, 379u, 650u, 778u,
			875u, 1825u, 532u, 537u, 340u, 344u, 347u, 650u, 778u, 874u,
			1825u, 532u, 537u, 340u, 344u, 347u, 650u, 778u, 874u, 1825u,
			532u, 537u, 340u, 344u, 379u, 650u, 778u, 875u, 1825u, 532u,
			537u, 340u, 344u, 347u, 650u, 778u, 874u, 1825u, 532u, 537u,
			340u, 344u, 379u, 650u, 778u, 875u, 38617u, 12120u, 13243u, 12120u,
			13243u, 1825u, 34196u, 38617u, 10961u, 12113u, 13233u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 628u, 632u, 635u, 628u, 632u, 635u, 1825u,
			34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 689u, 817u,
			913u, 689u, 817u, 913u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			628u, 632u, 635u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u,
			10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u,
			13243u, 1825u, 532u, 340u, 376u, 411u, 340u, 376u, 411u, 10964u,
			10964u, 340u, 376u, 411u, 340u, 376u, 411u, 34196u, 38617u, 34196u,
			38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 38617u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 38617u, 34196u, 38617u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 340u, 376u, 411u, 340u, 376u,
			411u, 10964u, 10964u, 340u, 376u, 411u, 340u, 376u, 411u, 10964u,
			10964u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			10964u, 12120u, 13243u, 2011u, 10964u, 12120u, 13243u, 2011u, 340u, 376u,
			411u, 340u, 376u, 411u, 340u, 376u, 411u, 340u, 376u, 411u,
			532u, 537u, 340u, 344u, 347u, 532u, 537u, 340u, 344u, 347u,
			340u, 344u, 347u, 89u, 56u, 59u, 56u, 59u, 59u, 59u,
			340u, 376u, 411u, 340u, 376u, 411u, 650u, 779u, 876u, 650u,
			779u, 876u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			10962u, 12114u, 13234u, 10962u, 12114u, 13234u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 340u, 372u,
			408u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 532u, 537u,
			340u, 344u, 347u, 532u, 537u, 340u, 344u, 347u, 468u, 472u,
			475u, 468u, 472u, 475u, 468u, 472u, 475u, 532u, 536u, 539u,
			10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 534u, 538u,
			534u, 538u, 534u, 538u, 10964u, 12120u, 13243u, 340u, 376u, 411u,
			340u, 376u, 411u, 340u, 376u, 411u, 340u, 376u, 411u, 650u,
			779u, 876u, 650u, 779u, 876u, 650u, 779u, 876u, 650u, 779u,
			876u, 5524u, 5849u, 5524u, 5849u, 10964u, 12120u, 13243u, 10964u, 12120u,
			13243u, 83329u, 104129u, 83329u, 104129u, 10961u, 12113u, 13233u, 90260u, 110873u,
			90260u, 110745u, 84u, 152u, 219u, 84u, 88u, 155u, 90324u, 90452u,
			90324u, 110937u, 116u, 180u, 248u, 116u, 184u, 251u, 90260u, 110873u,
			90260u, 110745u, 84u, 152u, 219u, 84u, 88u, 155u, 90324u, 90452u,
			90324u, 110937u, 116u, 180u, 248u, 116u, 184u, 251u, 34196u, 38617u,
			34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 38617u,
			34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 38617u,
			34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 34196u,
			10964u, 10964u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 2011u, 34196u, 34196u, 10964u, 10964u, 1780u, 34196u, 38617u,
			34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 34196u,
			10964u, 10964u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 34196u, 34196u, 10964u, 10964u, 642u, 772u, 870u, 642u,
			770u, 868u, 643u, 645u, 775u, 643u, 773u, 871u, 642u, 772u,
			870u, 642u, 770u, 868u, 643u, 645u, 775u, 643u, 773u, 871u,
			34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			34196u, 34196u, 10964u, 10964u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 2011u, 34196u, 34196u, 10964u, 10964u, 1780u,
			34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			34196u, 34196u, 10964u, 10964u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 34196u, 34196u, 10964u, 10964u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 34196u, 34196u, 10964u, 10964u, 34196u, 38617u,
			34196u, 38617u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 34196u,
			10964u, 10964u, 34196u, 38617u, 34196u, 38617u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 34196u, 34196u, 10964u, 10964u, 34196u, 38617u, 34196u, 38617u,
			10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 34196u, 34196u, 10964u, 10964u,
			340u, 376u, 411u, 340u, 376u, 411u, 6u, 4u, 6u, 4u,
			6u, 4u, 6u, 4u, 7u, 7u, 7u, 7u, 7u, 7u,
			7u, 7u, 1825u, 411u, 411u, 1825u, 1825u, 411u, 411u, 1825u,
			10964u, 10964u, 1825u, 411u, 411u, 1825u, 10964u, 10964u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1825u, 532u, 1825u, 34196u, 38617u, 10964u,
			12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u, 1825u, 34196u,
			38617u, 10964u, 12120u, 13243u, 1825u, 34196u, 38617u, 10964u, 12120u, 13243u,
			530u, 534u, 538u, 918u, 922u, 2308u, 2820u, 3332u, 1046u, 1174u,
			1434u, 25419u, 29710u, 397u, 464u, 397u, 464u, 397u, 464u, 53643u,
			65998u, 2820u, 3332u, 25419u, 29710u, 25419u, 29710u, 2820u, 3332u, 1174u,
			1434u, 1174u, 1434u, 25419u, 29710u, 53643u, 65998u, 53643u, 65998u, 53643u,
			65998u, 53643u, 65998u, 531u, 535u, 539u, 531u, 535u, 539u, 531u,
			535u, 539u, 2820u, 3332u, 127577u, 32120u, 32155u, 127577u, 32120u, 32155u,
			8160660u, 8165081u, 1026772u, 1027928u, 1029051u, 1026772u, 1027928u, 1029051u, 127508u, 127577u,
			32084u, 32120u, 32155u, 127508u, 127577u, 32084u, 32120u, 32155u, 8165081u, 870177u,
			127508u, 127577u, 32084u, 32120u, 32155u, 870177u, 127508u, 127577u, 32084u, 32120u,
			32155u, 870177u, 8160660u, 1026772u, 870177u, 8160660u, 1026772u, 870177u, 8160660u, 8165081u,
			870177u, 8160660u, 8165081u, 870177u, 8160660u, 8165081u, 870047u, 870177u, 8160660u, 8165081u,
			1026772u, 1027928u, 1029051u, 872585u, 872587u, 128262u, 128263u, 32392u, 32393u, 872585u,
			872587u, 128262u, 128263u, 32392u, 32393u, 872585u, 872587u, 128262u, 128263u, 32392u,
			32393u, 872585u, 872587u, 128262u, 128263u, 32392u, 32393u, 8160985u, 1026904u, 1027003u,
			1026904u, 1027003u, 128584u, 32522u, 32618u, 32522u, 32618u, 1028027u, 1028027u, 32619u,
			32619u, 128264u, 128584u, 32394u, 32522u, 32619u, 1026769u, 1027921u, 1029041u, 1026769u,
			1027921u, 1029041u, 1026769u, 1027921u, 1029041u, 1026769u, 1027921u, 1029041u, 869537u, 869793u,
			8152468u, 8156564u, 1024724u, 1025748u, 870177u, 8160660u, 1026772u, 869537u, 869793u, 8152468u,
			8156564u, 1024724u, 1025748u, 1027928u, 1029051u, 1027928u, 1029051u, 1026772u, 1027928u, 1029051u,
			1026772u, 1027928u, 1029051u, 32084u, 32120u, 32155u, 32084u, 32120u, 32155u, 1026772u,
			1026772u, 128145u, 128145u, 128145u, 128145u, 128145u, 128145u, 128145u, 128145u, 8160985u,
			1026904u, 1027003u, 1026904u, 1027003u, 128584u, 32522u, 32618u, 32522u, 32618u, 1028027u,
			1028027u, 32619u, 32619u, 1026769u, 1027921u, 1029041u, 1026769u, 1027921u, 1029041u, 1026769u,
			1027921u, 1029041u, 1026769u, 1027921u, 1029041u, 870177u, 8160660u, 8165081u, 870177u, 8160660u,
			870177u, 8160660u, 8165081u, 1026772u, 1027928u, 1029051u, 1027928u, 1029051u, 1027928u, 1029051u,
			870177u, 8160660u, 8165081u, 1026772u, 1027928u, 1029051u, 8165081u, 509642132u, 510957273u, 505513364u,
			505796313u, 509642132u, 510957273u, 505513364u, 505796313u, 6063508u, 7378649u, 6063508u, 7378649u, 6063508u,
			7378649u, 1026772u, 1027928u, 1029051u, 1026772u, 1027928u, 1029051u, 1026772u, 1026772u, 1026772u,
			1027928u, 1029051u, 1026772u, 1027928u, 1029051u, 1026772u, 1026772u, 32084u, 32120u, 32155u,
			32084u, 32120u, 32155u, 1026772u, 1026772u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u,
			7378649u, 2192788u, 2475737u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u, 7378649u, 2192788u,
			2475737u, 870177u, 870177u, 127508u, 127508u, 870177u, 870177u, 127508u, 127508u, 870177u,
			127508u, 870177u, 127508u, 32081u, 32113u, 32145u, 32081u, 32113u, 32145u, 32081u,
			32081u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u,
			2192788u, 6063508u, 2192788u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u, 7378649u, 2192788u,
			2475737u, 6063508u, 2192788u, 6063508u, 2192788u, 1026772u, 1027928u, 1029051u, 1026772u, 1027928u,
			1029051u, 1026772u, 1027928u, 1029051u, 1026772u, 1027928u, 1029051u, 1026772u, 1027928u, 1029051u,
			1026772u, 1027928u, 1029051u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u, 7378649u, 2192788u,
			2475737u, 6063508u, 2192788u, 6063508u, 2192788u, 6063508u, 7378649u, 2192788u, 2475737u, 6063508u,
			7378649u, 2192788u, 2475737u, 6063508u, 2192788u, 6063508u, 2192788u, 870177u, 870177u, 8160660u,
			8165081u, 1026772u, 1027928u, 1029051u, 870177u, 8160660u, 8165081u, 1026772u, 1027928u, 1029051u,
			870177u, 127508u, 127371u, 127438u, 429451u, 429451u, 429451u, 429451u, 429451u, 429451u,
			429451u, 429451u, 429451u, 429451u, 429451u, 528878u, 112011u, 147950u, 429451u, 112011u,
			429451u, 429451u, 17515u, 17515u, 17515u, 17515u, 560523u, 560523u, 560523u, 560523u,
			560523u, 560523u, 560523u, 560523u, 39u, 74u, 39u, 74u, 39u, 74u,
			39u, 74u, 39u, 74u, 39u, 74u, 39u, 74u, 39u, 74u,
			39u, 74u, 6u, 9u, 6u, 9u, 107u, 142u, 107u, 142u,
			107u, 107u, 12395u, 3467u, 12395u, 3467u, 12395u, 3467u, 12395u, 3467u,
			12395u, 3467u, 12395u, 3467u, 12395u, 3467u, 12395u, 3467u, 12395u, 3467u,
			12395u, 3467u, 12395u, 3467u, 12395u, 3467u, 107u, 107u, 107u, 107u,
			107u, 107u, 107u, 107u, 107u, 107u, 107u, 107u, 107u, 107u,
			107u, 18469u, 18504u, 18471u, 18474u, 18471u, 18474u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 4u, 4u, 4u, 4u,
			4u, 0u, 0u, 0u, 1u, 0u, 1u, 36u, 2276u, 2339u,
			2276u, 158052u, 158052u, 158052u, 158052u, 158052u, 47u, 47u, 9u, 9u,
			0u, 0u, 0u, 3844u, 542u, 4u, 4u, 4u, 4u, 0u,
			0u, 0u, 0u, 0u, 0u, 1695u, 1695u, 1695u, 543u, 1695u,
			543u, 1695u, 543u, 543u, 543u, 1695u, 543u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 4u, 4u, 4u, 4u, 4385u, 545u, 545u,
			545u, 545u, 3094u, 3094u, 1364u, 1369u, 1369u, 0u, 0u, 0u,
			0u, 0u, 28u, 53u, 34196u, 38617u, 34196u, 38617u, 34196u, 38617u,
			34196u, 38617u, 0u, 0u, 0u, 0u, 0u, 0u, 8u, 9u,
			11u, 0u, 0u, 10964u, 12120u, 13243u, 10964u, 1026769u, 1027921u, 1029041u,
			1026769u, 340u, 340u, 372u, 408u, 340u, 372u, 404u, 340u, 344u,
			379u, 340u, 344u, 347u, 340u, 344u, 379u, 340u, 344u, 347u,
			340u, 344u, 379u, 340u, 344u, 347u, 340u, 376u, 411u, 340u,
			376u, 411u, 340u, 372u, 408u, 340u, 372u, 404u, 10964u, 10964u,
			333u, 335u, 10964u, 333u, 335u, 8916u, 9940u, 10964u, 340u, 344u,
			379u, 340u, 344u, 347u, 340u, 344u, 379u, 340u, 344u, 347u,
			340u, 376u, 411u, 340u, 376u, 411u, 333u, 335u, 333u, 335u,
			340u, 372u, 408u, 340u, 372u, 404u, 8916u, 9940u, 340u, 376u,
			411u, 340u, 376u, 411u, 10964u, 12120u, 13243u, 10964u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 10964u, 10964u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 10964u, 10964u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u,
			10964u, 10964u, 10964u, 10964u, 10964u, 10964u, 10964u, 12120u, 13243u, 10964u,
			12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u, 13243u, 10964u, 12120u,
			13243u, 10964u, 12120u, 13243u, 10964u, 10964u, 10964u, 10964u, 10964u, 10964u,
			32081u, 32113u, 32145u, 32081u, 340u, 376u, 411u, 10964u, 32084u, 32120u,
			32155u, 1026772u, 10964u, 12120u, 13243u, 10964u, 10964u, 12120u, 13243u, 10964u,
			52u, 641u, 22228u, 21205u, 276u, 308u, 648u, 649u, 10964u, 12120u,
			13243u, 10964u, 340u, 376u, 411u, 10964u, 32084u, 32120u, 32155u, 1026772u,
			32084u, 32120u, 32155u, 1026772u, 340u, 376u, 411u, 10964u, 10964u, 12120u,
			13243u, 10964u, 340u, 376u, 411u, 10964u, 10964u, 12120u, 13243u, 10964u,
			340u, 0u, 0u, 2131u, 2131u, 1u, 1u, 1u, 1u, 1u,
			1u, 1u, 1u, 1169u, 1169u, 1169u, 1169u, 1169u, 1169u, 1169u,
			1169u, 1169u, 2195u, 2195u, 1169u, 785u, 1163u, 74958u, 74958u, 1169u,
			12u, 15u, 12u, 15u, 1u, 1u, 779u, 974u, 779u, 974u,
			779u, 974u, 779u, 974u, 395u, 462u, 395u, 462u, 395u, 462u,
			127953u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 54u,
			54u, 97u, 97u, 97u, 97u, 97u, 97u, 886u, 886u, 886u,
			886u, 54u, 54u, 886u, 886u, 884u, 54u, 54u, 2102u, 2103u,
			2103u, 2103u, 884u, 54u, 97u, 97u, 1u, 1u, 33652u, 33652u,
			886u, 886u, 886u, 886u, 54u, 886u, 886u, 886u, 886u, 886u,
			886u, 22u, 22u, 22u, 22u, 884u, 886u, 886u, 886u, 886u,
			886u, 886u, 54u, 54u, 886u, 886u, 886u, 54u, 54u, 54u,
			54u, 886u, 886u, 886u, 886u, 886u, 886u, 886u, 886u, 886u,
			886u, 886u, 886u, 22u, 22u, 22u, 22u, 854u, 854u, 854u,
			854u, 886u, 886u, 886u, 886u, 886u, 54u, 54u, 54u, 54u,
			886u, 886u, 886u, 854u, 854u, 886u, 886u, 886u, 886u, 884u,
			886u, 886u, 886u, 38u, 38u, 38u, 38u, 886u, 886u, 886u,
			886u, 886u, 886u, 886u, 886u, 886u, 886u, 98u, 98u, 98u,
			98u, 886u, 886u, 886u, 886u, 886u, 886u, 886u, 886u, 886u,
			38u, 38u, 886u, 886u, 886u, 886u, 886u, 886u, 886u, 886u,
			886u, 886u, 38u, 2u, 2u, 2u, 2u, 2u, 2u, 2u,
			2u, 54u, 54u, 54u, 54u, 886u, 886u, 886u, 886u, 886u,
			22u, 22u, 97u, 97u, 22u, 22u, 97u, 97u, 54u, 54u,
			54u, 22u, 22u, 97u, 97u, 22u, 22u, 97u, 97u, 54u,
			54u, 54u, 33654u, 2102u, 33652u, 33652u, 2102u, 2102u, 2102u, 2102u,
			2102u, 2102u, 2102u, 2102u, 2102u, 2102u, 2102u, 2102u, 0u, 0u,
			0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
			0u, 0u, 0u, 0u
		};
	}

	private static uint[] GetEncFlags2()
	{
		return new uint[4834]
		{
			0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 2u,
			3u, 3u, 3u, 4u, 5u, 5u, 5u, 6u, 6u, 7u,
			7u, 8u, 9u, 9u, 9u, 10u, 11u, 11u, 11u, 12u,
			13u, 13u, 13u, 14u, 14u, 15u, 16u, 17u, 17u, 17u,
			18u, 19u, 19u, 19u, 20u, 21u, 21u, 21u, 22u, 22u,
			23u, 23u, 24u, 25u, 25u, 25u, 26u, 27u, 27u, 27u,
			28u, 29u, 29u, 29u, 30u, 30u, 31u, 31u, 32u, 33u,
			33u, 33u, 34u, 35u, 35u, 35u, 36u, 37u, 37u, 37u,
			39u, 40u, 41u, 41u, 41u, 42u, 43u, 43u, 43u, 44u,
			45u, 45u, 45u, 47u, 48u, 49u, 49u, 49u, 50u, 51u,
			51u, 51u, 52u, 53u, 53u, 53u, 55u, 56u, 57u, 57u,
			57u, 58u, 59u, 59u, 59u, 60u, 61u, 61u, 61u, 63u,
			64u, 64u, 72u, 72u, 80u, 80u, 80u, 88u, 88u, 88u,
			96u, 96u, 97u, 97u, 98u, 98u, 99u, 99u, 99u, 99u,
			99u, 104u, 104u, 104u, 105u, 105u, 105u, 106u, 106u, 106u,
			107u, 107u, 107u, 108u, 109u, 109u, 110u, 111u, 111u, 112u,
			112u, 112u, 113u, 113u, 113u, 114u, 114u, 114u, 115u, 115u,
			115u, 116u, 116u, 116u, 117u, 117u, 117u, 118u, 118u, 118u,
			119u, 119u, 119u, 120u, 120u, 120u, 121u, 121u, 121u, 122u,
			122u, 122u, 123u, 123u, 123u, 124u, 124u, 124u, 125u, 125u,
			125u, 126u, 126u, 126u, 127u, 127u, 127u, 2147483776u, 2281701504u, 2415919232u,
			2550136960u, 2684354688u, 2818572416u, 2952790144u, 3087007872u, 2147483777u, 2147483777u, 2147483777u, 2281701505u, 2281701505u,
			2281701505u, 2415919233u, 2415919233u, 2415919233u, 2550136961u, 2550136961u, 2550136961u, 2684354689u, 2684354689u, 2684354689u,
			2818572417u, 2818572417u, 2818572417u, 2952790145u, 2952790145u, 2952790145u, 3087007873u, 3087007873u, 3087007873u, 2147483778u,
			2281701506u, 2415919234u, 2550136962u, 2684354690u, 2818572418u, 2952790146u, 3087007874u, 2147483779u, 2147483779u, 2147483779u,
			2281701507u, 2281701507u, 2281701507u, 2415919235u, 2415919235u, 2415919235u, 2550136963u, 2550136963u, 2550136963u, 2684354691u,
			2684354691u, 2684354691u, 2818572419u, 2818572419u, 2818572419u, 2952790147u, 2952790147u, 2952790147u, 3087007875u, 3087007875u,
			3087007875u, 132u, 133u, 133u, 133u, 134u, 135u, 135u, 135u, 136u,
			137u, 137u, 137u, 138u, 139u, 139u, 139u, 140u, 140u, 140u,
			141u, 141u, 141u, 142u, 142u, 142u, 2147483791u, 2147483791u, 2147483791u, 144u,
			144u, 144u, 144u, 144u, 144u, 1075839120u, 152u, 152u, 152u, 153u,
			153u, 153u, 154u, 154u, 155u, 156u, 156u, 156u, 157u, 157u,
			157u, 158u, 159u, 160u, 161u, 161u, 161u, 162u, 163u, 163u,
			163u, 164u, 165u, 165u, 165u, 166u, 167u, 167u, 167u, 168u,
			169u, 169u, 169u, 170u, 171u, 171u, 171u, 172u, 173u, 173u,
			173u, 174u, 175u, 175u, 175u, 176u, 184u, 184u, 184u, 2147483840u,
			2281701568u, 2415919296u, 2550137024u, 2684354752u, 2818572480u, 2952790208u, 3087007936u, 2147483841u, 2147483841u, 2147483841u,
			2281701569u, 2281701569u, 2281701569u, 2415919297u, 2415919297u, 2415919297u, 2550137025u, 2550137025u, 2550137025u, 2684354753u,
			2684354753u, 2684354753u, 2818572481u, 2818572481u, 2818572481u, 2952790209u, 2952790209u, 2952790209u, 3087007937u, 3087007937u,
			3087007937u, 194u, 194u, 194u, 195u, 195u, 195u, 196u, 196u, 197u,
			197u, 2147483846u, 116472u, 2147483847u, 2147483847u, 2147483847u, 116728u, 116728u, 200u, 200u,
			200u, 201u, 201u, 201u, 202u, 202u, 202u, 203u, 203u, 203u,
			204u, 205u, 206u, 207u, 207u, 207u, 2147483856u, 2281701584u, 2415919312u, 2550137040u,
			2684354768u, 2818572496u, 2952790224u, 3087007952u, 2147483857u, 2147483857u, 2147483857u, 2281701585u, 2281701585u, 2281701585u,
			2415919313u, 2415919313u, 2415919313u, 2550137041u, 2550137041u, 2550137041u, 2684354769u, 2684354769u, 2684354769u, 2818572497u,
			2818572497u, 2818572497u, 2952790225u, 2952790225u, 2952790225u, 3087007953u, 3087007953u, 3087007953u, 2147483858u, 2281701586u,
			2415919314u, 2550137042u, 2684354770u, 2818572498u, 2952790226u, 3087007954u, 2147483859u, 2147483859u, 2147483859u, 2281701587u,
			2281701587u, 2281701587u, 2415919315u, 2415919315u, 2415919315u, 2550137043u, 2550137043u, 2550137043u, 2684354771u, 2684354771u,
			2684354771u, 2818572499u, 2818572499u, 2818572499u, 2952790227u, 2952790227u, 2952790227u, 3087007955u, 3087007955u, 3087007955u,
			212u, 213u, 214u, 215u, 2147483864u, 2281701592u, 2415919320u, 2550137048u, 2684354776u, 2818572504u,
			2952790232u, 3087007960u, 121024u, 121032u, 121040u, 121048u, 121056u, 121064u, 121072u, 121080u,
			2147483865u, 2415919321u, 2550137049u, 2684354777u, 2684354777u, 2818572505u, 2952790233u, 2952790233u, 2952790233u, 2952790233u,
			3087007961u, 3087007961u, 121280u, 121288u, 121296u, 121304u, 121312u, 121313u, 121316u, 121317u,
			121320u, 121321u, 121322u, 121323u, 121324u, 121325u, 121326u, 121328u, 121329u, 121330u,
			121331u, 121332u, 121333u, 121334u, 121335u, 121336u, 121337u, 121338u, 121339u, 121340u,
			121341u, 121342u, 121343u, 2147483866u, 2281701594u, 2415919322u, 2550137050u, 2684354778u, 2818572506u, 2952790234u,
			3087007962u, 121536u, 121544u, 121552u, 121560u, 121577u, 2147483867u, 2281701595u, 2415919323u, 2550137051u,
			2818572507u, 3087007963u, 121792u, 121800u, 121808u, 121816u, 121824u, 121824u, 121825u, 121825u,
			121826u, 121826u, 121827u, 121827u, 121828u, 121828u, 121829u, 121832u, 121840u, 2147483868u,
			2281701596u, 2415919324u, 2550137052u, 2684354780u, 2818572508u, 2952790236u, 3087007964u, 122048u, 122056u, 122064u,
			122072u, 122080u, 122088u, 122096u, 122104u, 2147483869u, 2281701597u, 2415919325u, 2550137053u, 2684354781u,
			2684354781u, 2952790237u, 2952790237u, 2952790237u, 2952790237u, 3087007965u, 3087007965u, 122304u, 122312u, 122320u,
			122328u, 122336u, 122344u, 2147483870u, 2281701598u, 2415919326u, 2550137054u, 2684354782u, 2818572510u, 2952790238u,
			3087007966u, 122560u, 122568u, 122576u, 122585u, 122592u, 122600u, 122608u, 122616u, 2147483871u,
			2281701599u, 2415919327u, 2550137055u, 2684354783u, 2818572511u, 2952790239u, 3087007967u, 122816u, 122824u, 122832u,
			122840u, 122848u, 122848u, 122849u, 122850u, 122856u, 122864u, 224u, 224u, 224u,
			224u, 224u, 224u, 224u, 225u, 225u, 225u, 225u, 225u, 225u,
			225u, 226u, 226u, 226u, 226u, 226u, 226u, 226u, 227u, 227u,
			227u, 227u, 227u, 227u, 227u, 228u, 229u, 229u, 230u, 231u,
			231u, 232u, 232u, 232u, 233u, 233u, 233u, 234u, 234u, 235u,
			235u, 235u, 236u, 237u, 237u, 238u, 239u, 239u, 241u, 244u,
			245u, 2147483894u, 2281701622u, 2415919350u, 2550137078u, 2684354806u, 2818572534u, 2952790262u, 3087007990u, 2147483895u,
			2147483895u, 2147483895u, 2281701623u, 2281701623u, 2281701623u, 2415919351u, 2415919351u, 2415919351u, 2550137079u, 2550137079u,
			2550137079u, 2684354807u, 2684354807u, 2684354807u, 2818572535u, 2818572535u, 2818572535u, 2952790263u, 2952790263u, 2952790263u,
			3087007991u, 3087007991u, 3087007991u, 248u, 249u, 250u, 251u, 252u, 253u, 2147483902u,
			2281701630u, 2147483903u, 2147483903u, 2147483903u, 2281701631u, 2281701631u, 2281701631u, 2415919359u, 2415919359u, 2415919359u,
			2550137087u, 2550137087u, 2550137087u, 2684354815u, 2684354815u, 2684354815u, 2818572543u, 2818572543u, 2818572543u, 2952790271u,
			2952790271u, 2952790271u, 2147614720u, 2147614720u, 2147614720u, 2281832448u, 2281832448u, 2281832448u, 2416050176u, 2416050176u,
			2416050176u, 2550267904u, 2550267904u, 2550267904u, 2684485632u, 2684485632u, 2684485632u, 2818703360u, 2818703360u, 2818703360u,
			2952921088u, 2952921088u, 2147614721u, 2147614721u, 2147614721u, 2281832449u, 2281832449u, 2281832449u, 2416050177u, 2416050177u,
			2416050177u, 2550267905u, 2550267905u, 2550267905u, 2684485633u, 2684485633u, 2684485633u, 3894542337u, 2952921089u, 2952921089u,
			2952921089u, 3087138817u, 1073938880u, 1073938881u, 1073938882u, 1073938883u, 1073938884u, 1073938885u, 1073938888u, 1073938888u,
			1073938888u, 1073938889u, 1073938890u, 1073938891u, 1073938895u, 1073938896u, 1073938897u, 1073938900u, 1073938901u, 1073938902u,
			1073938903u, 197080u, 197080u, 197080u, 197081u, 197082u, 197082u, 197082u, 197083u, 197083u,
			197083u, 197084u, 197085u, 197086u, 197087u, 197087u, 197087u, 1076036072u, 1076036074u, 1073938926u,
			1073938927u, 197112u, 197113u, 1073938938u, 1073938938u, 1073938938u, 1076036090u, 1073938939u, 197116u, 197116u,
			197116u, 197117u, 131074u, 131074u, 131074u, 131075u, 131075u, 131075u, 131076u, 131077u,
			131077u, 131078u, 131079u, 131079u, 131079u, 131080u, 131081u, 1075970057u, 131082u, 131083u,
			131085u, 131085u, 131085u, 2147614733u, 2281832461u, 2416050189u, 131086u, 131088u, 131089u, 131089u,
			131090u, 131091u, 131091u, 1073872912u, 1149370384u, 1166147600u, 1140981776u, 1157758992u, 1174536208u, 1074921488u,
			1150418960u, 1167196176u, 1146224656u, 1163001872u, 1179779088u, 1075970064u, 1117913104u, 1117913104u, 1109524496u, 1109524496u,
			1077018640u, 1118961680u, 1118961680u, 1114767376u, 1114767376u, 1073872913u, 1149370385u, 1166147601u, 1140981777u, 1157758993u,
			1174536209u, 1074921489u, 1150418961u, 1167196177u, 1146224657u, 1163001873u, 1179779089u, 1075970065u, 1117913105u, 1117913105u,
			1109524497u, 1109524497u, 1077018641u, 1118961681u, 1118961681u, 1114767377u, 1114767377u, 1073872914u, 1073872914u, 1149370386u,
			1149370386u, 1140981778u, 1140981778u, 1074921490u, 1150418962u, 1146224658u, 1075970066u, 1151467538u, 1168244754u, 1143078930u,
			1159856146u, 1176633362u, 1077018642u, 1152516114u, 1169293330u, 1148321810u, 1165099026u, 1181876242u, 1073872915u, 1149370387u,
			1140981779u, 1074921491u, 1150418963u, 1146224659u, 1073872916u, 1149370388u, 1166147604u, 1140981780u, 1157758996u, 1174536212u,
			1074921492u, 1150418964u, 1167196180u, 1146224660u, 1163001876u, 1179779092u, 1073872917u, 1149370389u, 1166147605u, 1140981781u,
			1157758997u, 1174536213u, 1074921493u, 1150418965u, 1167196181u, 1146224661u, 1163001877u, 1179779093u, 1073872918u, 1149370390u,
			1140981782u, 1073872918u, 1149370390u, 1140981782u, 1074921494u, 1150418966u, 1146224662u, 1075970070u, 1151467542u, 1168244758u,
			1143078934u, 1159856150u, 1176633366u, 1073872919u, 1149370391u, 1140981783u, 1074921495u, 1150418967u, 1146224663u, 131096u,
			131096u, 131096u, 131097u, 131097u, 131097u, 131098u, 131098u, 131098u, 131099u, 131099u,
			131099u, 131100u, 131100u, 131100u, 131101u, 131101u, 131101u, 131102u, 131102u, 131102u,
			131103u, 131103u, 131103u, 2147614744u, 2281832472u, 2416050200u, 2550267928u, 1073872922u, 1074921498u, 1074921498u,
			1075970074u, 1075970074u, 1077018650u, 1077018650u, 1073872923u, 1074921499u, 1074921499u, 1075970075u, 1075970075u, 1077018651u,
			1077018651u, 3221356572u, 3357671454u, 3357671454u, 1076043514u, 1076043515u, 2147614751u, 2147614751u, 2147614751u, 131104u,
			131104u, 131105u, 131105u, 131106u, 131106u, 131107u, 131107u, 131108u, 131110u, 1073872936u,
			1149370408u, 1166147624u, 1140981800u, 1157759016u, 1174536232u, 1074921512u, 1150418984u, 1167196200u, 1146224680u, 1163001896u,
			1179779112u, 1073872937u, 1149370409u, 1166147625u, 1140981801u, 1157759017u, 1174536233u, 1074921513u, 1150418985u, 1167196201u,
			1146224681u, 1163001897u, 1179779113u, 1073872938u, 1074921514u, 1075970090u, 1075970090u, 1122107434u, 1113718826u, 1122107434u,
			1113718826u, 1077018666u, 1077018666u, 1123156010u, 1114767402u, 1123156010u, 1114767402u, 1073872939u, 1149370411u, 1166147627u,
			1140981803u, 1157759019u, 1174536235u, 1074921515u, 1150418987u, 1167196203u, 1146224683u, 1163001899u, 1179779115u, 1075970091u,
			1077018667u, 1073872940u, 1074921516u, 1075970092u, 1075970092u, 1122107436u, 1113718828u, 1122107436u, 1113718828u, 1077018668u,
			1077018668u, 1123156012u, 1114767404u, 1123156012u, 1114767404u, 1073872941u, 1074921517u, 1075970093u, 1075970093u, 1122107437u,
			1113718829u, 1122107437u, 1113718829u, 1077018669u, 1077018669u, 1123156013u, 1114767405u, 1123156013u, 1114767405u, 1073872942u,
			1115815982u, 1107427374u, 1074921518u, 1116864558u, 1112670254u, 1073872943u, 1074921519u, 1115815983u, 1116864559u, 1107427375u,
			1112670255u, 131120u, 131121u, 131122u, 131123u, 131124u, 131125u, 131125u, 1073872951u, 131136u,
			131136u, 131136u, 131137u, 131137u, 131137u, 131138u, 131138u, 131138u, 131139u, 131139u,
			131139u, 131140u, 131140u, 131140u, 131141u, 131141u, 131141u, 131142u, 131142u, 131142u,
			131143u, 131143u, 131143u, 131144u, 131144u, 131144u, 131145u, 131145u, 131145u, 131146u,
			131146u, 131146u, 131147u, 131147u, 131147u, 131148u, 131148u, 131148u, 131149u, 131149u,
			131149u, 131150u, 131150u, 131150u, 131151u, 131151u, 131151u, 1090650177u, 1094844481u, 1091698753u,
			1095893057u, 1090650178u, 1094844482u, 1091698754u, 1095893058u, 1073872964u, 1078067268u, 1074921540u, 1079115844u, 1090650181u,
			1094844485u, 1091698757u, 1095893061u, 1090650182u, 1094844486u, 1091698758u, 1095893062u, 1090650183u, 1094844487u, 1091698759u,
			1095893063u, 1090650186u, 1094844490u, 1091698762u, 1095893066u, 1090650187u, 1094844491u, 1091698763u, 1073872976u, 1073872976u,
			1153564752u, 1145176144u, 1170341968u, 1161953360u, 1074921552u, 1074921552u, 1154613328u, 1146224720u, 1171390544u, 1163001936u,
			1073872977u, 1149370449u, 1166147665u, 1140981841u, 1157759057u, 1174536273u, 1074921553u, 1150419025u, 1167196241u, 1146224721u,
			1163001937u, 1179779153u, 1075970129u, 1117913169u, 1109524561u, 1077018705u, 1118961745u, 1114767441u, 1073872978u, 1149370450u,
			1166147666u, 1075970130u, 1117913170u, 1073872979u, 1149370451u, 1166147667u, 1075970131u, 1117913171u, 1073872980u, 1149370452u,
			1166147668u, 1140981844u, 1157759060u, 1174536276u, 1074921556u, 1150419028u, 1167196244u, 1146224724u, 1163001940u, 1179779156u,
			1073872981u, 1149370453u, 1166147669u, 1140981845u, 1157759061u, 1174536277u, 1074921557u, 1150419029u, 1167196245u, 1146224725u,
			1163001941u, 1179779157u, 1073872982u, 1149370454u, 1166147670u, 1140981846u, 1157759062u, 1174536278u, 1074921558u, 1150419030u,
			1167196246u, 1146224726u, 1163001942u, 1179779158u, 1073872983u, 1149370455u, 1166147671u, 1140981847u, 1157759063u, 1174536279u,
			1074921559u, 1150419031u, 1167196247u, 1146224727u, 1163001943u, 1179779159u, 1073872984u, 1149370456u, 1166147672u, 1140981848u,
			1157759064u, 1174536280u, 1074921560u, 1150419032u, 1167196248u, 1146224728u, 1163001944u, 1179779160u, 1075970136u, 1117913176u,
			1109524568u, 1077018712u, 1118961752u, 1114767448u, 1073872985u, 1149370457u, 1166147673u, 1140981849u, 1157759065u, 1174536281u,
			1074921561u, 1150419033u, 1167196249u, 1146224729u, 1163001945u, 1179779161u, 1075970137u, 1117913177u, 1109524569u, 1077018713u,
			1118961753u, 1114767449u, 1073872986u, 1149370458u, 1166147674u, 1140981850u, 1157759066u, 1174536282u, 1074921562u, 1150419034u,
			1167196250u, 1146224730u, 1163001946u, 1179779162u, 1075970138u, 1117913178u, 1109524570u, 1077018714u, 1118961754u, 1114767450u,
			1073872987u, 1149370459u, 1166147675u, 1140981851u, 1157759067u, 1174536283u, 1145176155u, 1161953371u, 1178730587u, 1074921563u,
			1150419035u, 1167196251u, 1142030427u, 1158807643u, 1175584859u, 1075970139u, 1151467611u, 1168244827u, 1143079003u, 1159856219u,
			1176633435u, 1073872988u, 1149370460u, 1166147676u, 1140981852u, 1157759068u, 1174536284u, 1074921564u, 1150419036u, 1167196252u,
			1146224732u, 1163001948u, 1179779164u, 1075970140u, 1117913180u, 1109524572u, 1077018716u, 1118961756u, 1114767452u, 1073872989u,
			1149370461u, 1166147677u, 1140981853u, 1157759069u, 1174536285u, 1074921565u, 1150419037u, 1167196253u, 1146224733u, 1163001949u,
			1179779165u, 1075970141u, 1117913181u, 1109524573u, 1077018717u, 1118961757u, 1114767453u, 1073872990u, 1149370462u, 1166147678u,
			1140981854u, 1157759070u, 1174536286u, 1074921566u, 1150419038u, 1167196254u, 1146224734u, 1163001950u, 1179779166u, 1075970142u,
			1117913182u, 1109524574u, 1077018718u, 1118961758u, 1114767454u, 1073872991u, 1149370463u, 1166147679u, 1140981855u, 1157759071u,
			1174536287u, 1074921567u, 1150419039u, 1167196255u, 1146224735u, 1163001951u, 1179779167u, 1075970143u, 1117913183u, 1109524575u,
			1077018719u, 1118961759u, 1114767455u, 1073872992u, 1074921568u, 1150419040u, 1167196256u, 1150419040u, 1167196256u, 1183973472u,
			1073872993u, 1074921569u, 1150419041u, 1167196257u, 1150419041u, 1167196257u, 1183973473u, 1073872994u, 1074921570u, 1150419042u,
			1167196258u, 1142030434u, 1158807650u, 1175584866u, 1073872995u, 1074921571u, 1150419043u, 1167196259u, 1150419043u, 1167196259u,
			1183973475u, 1073872996u, 1074921572u, 1150419044u, 1167196260u, 1150419044u, 1167196260u, 1183973476u, 1073872997u, 1074921573u,
			1150419045u, 1167196261u, 1150419045u, 1167196261u, 1183973477u, 1073872998u, 1074921574u, 1150419046u, 1167196262u, 1142030438u,
			1158807654u, 1175584870u, 1073872999u, 1074921575u, 1150419047u, 1167196263u, 1150419047u, 1167196263u, 1183973479u, 1073873000u,
			1074921576u, 1150419048u, 1167196264u, 1150419048u, 1167196264u, 1183973480u, 1073873001u, 1074921577u, 1150419049u, 1167196265u,
			1150419049u, 1167196265u, 1183973481u, 1073873002u, 1074921578u, 1150419050u, 1167196266u, 1142030442u, 1158807658u, 1175584874u,
			1073873003u, 1074921579u, 1150419051u, 1167196267u, 1142030443u, 1158807659u, 1175584875u, 1074921580u, 1150419052u, 1167196268u,
			1146224748u, 1163001964u, 1179779180u, 1074921581u, 1150419053u, 1167196269u, 1146224749u, 1163001965u, 1179779181u, 1073873006u,
			1073873006u, 1074921582u, 1074921582u, 1154613358u, 1146224750u, 1154613358u, 1146224750u, 1073873007u, 1074921583u, 1150419055u,
			1167196271u, 1142030447u, 1158807663u, 1175584879u, 1146224751u, 1163001967u, 1179779183u, 1075970159u, 1151467631u, 1168244847u,
			1143079023u, 1159856239u, 1176633455u, 1147273327u, 1164050543u, 1180827759u, 1144127599u, 1160904815u, 1177682031u, 1148321903u,
			1165099119u, 1181876335u, 1073873008u, 1074921584u, 1150419056u, 1167196272u, 1142030448u, 1158807664u, 1175584880u, 1075970160u,
			1151467632u, 1168244848u, 1151467632u, 1168244848u, 1185022064u, 1077018736u, 1152516208u, 1169293424u, 1152516208u, 1169293424u,
			1186070640u, 3489792113u, 3490840689u, 3566338161u, 3583115377u, 3566338161u, 3583115377u, 3599892593u, 3758227569u, 3759276145u,
			3834773617u, 3851550833u, 3834773617u, 3851550833u, 3868328049u, 4026663025u, 4027711601u, 4103209073u, 4119986289u, 4103209073u,
			4119986289u, 4136763505u, 3289514098u, 3306291314u, 3323068530u, 3293708402u, 3310485618u, 3327262834u, 3423731826u, 3440509042u,
			3457286258u, 3427926130u, 3444703346u, 3461480562u, 3489792114u, 3490840690u, 3566338162u, 3583115378u, 3557949554u, 3574726770u,
			3591503986u, 3758227570u, 3759276146u, 3834773618u, 3851550834u, 3826385010u, 3843162226u, 3859939442u, 3830579314u, 3847356530u,
			3864133746u, 4026663026u, 4027711602u, 4103209074u, 4119986290u, 4094820466u, 4111597682u, 4128374898u, 3489792115u, 3490840691u,
			3566338163u, 3583115379u, 3562143859u, 3578921075u, 3595698291u, 3625058419u, 3700555891u, 3717333107u, 3700555891u, 3717333107u,
			3734110323u, 4026663027u, 4027711603u, 4103209075u, 4119986291u, 4099014771u, 4115791987u, 4132569203u, 4161929331u, 4237426803u,
			4254204019u, 4237426803u, 4254204019u, 4270981235u, 1073873012u, 1074921588u, 1150419060u, 1167196276u, 1150419060u, 1167196276u,
			1183973492u, 1073873013u, 1074921589u, 1150419061u, 1167196277u, 1150419061u, 1167196277u, 1183973493u, 1073873014u, 1074921590u,
			1150419062u, 1167196278u, 1142030454u, 1158807670u, 1175584886u, 1073873015u, 1149370487u, 1166147703u, 1073873016u, 1073873016u,
			1140981880u, 1157759096u, 1174536312u, 1145176184u, 1161953400u, 1178730616u, 3222405240u, 1142030456u, 1158807672u, 1175584888u,
			1146224760u, 1163001976u, 1179779192u, 1122107512u, 1113718904u, 1077018744u, 1123156088u, 1114767480u, 1073873017u, 1073873017u,
			1140981881u, 1157759097u, 1174536313u, 1145176185u, 1161953401u, 1178730617u, 1074921593u, 1142030457u, 1158807673u, 1175584889u,
			1146224761u, 1163001977u, 1179779193u, 1122107513u, 1113718905u, 1077018745u, 1123156089u, 1114767481u, 1142030458u, 1158807674u,
			1175584890u, 1146224762u, 1163001978u, 1179779194u, 1143079034u, 1159856250u, 1176633466u, 1147273338u, 1164050554u, 1180827770u,
			1144127610u, 1160904826u, 1177682042u, 1148321914u, 1165099130u, 1181876346u, 1142030459u, 1158807675u, 1175584891u, 1146224763u,
			1163001979u, 1179779195u, 1122107515u, 1113718907u, 1123156091u, 1114767483u, 1074921596u, 1150419068u, 1167196284u, 1077018748u,
			1152516220u, 1169293436u, 1074921597u, 1150419069u, 1167196285u, 1077018749u, 1152516221u, 1169293437u, 1073873022u, 1073873022u,
			1074921598u, 1074921598u, 1154613374u, 1146224766u, 1154613374u, 1146224766u, 1075970174u, 1151467646u, 1147273342u, 1073873023u,
			1074921599u, 1150419071u, 1167196287u, 1142030463u, 1158807679u, 1175584895u, 1146224767u, 1163001983u, 1179779199u, 1075970175u,
			1151467647u, 1168244863u, 1143079039u, 1159856255u, 1176633471u, 1147273343u, 1164050559u, 1180827775u, 1144127615u, 1160904831u,
			1177682047u, 1148321919u, 1165099135u, 1181876351u, 131200u, 131200u, 131200u, 131201u, 131201u, 131201u,
			131202u, 131202u, 131202u, 131203u, 131203u, 131203u, 131204u, 131204u, 131204u, 131205u,
			131205u, 131205u, 131206u, 131206u, 131206u, 131207u, 131207u, 131207u, 131208u, 131208u,
			131208u, 131209u, 131209u, 131209u, 131210u, 131210u, 131210u, 131211u, 131211u, 131211u,
			131212u, 131212u, 131212u, 131213u, 131213u, 131213u, 131214u, 131214u, 131214u, 131215u,
			131215u, 131215u, 131216u, 131217u, 131218u, 131219u, 131220u, 131221u, 131222u, 131223u,
			131224u, 131225u, 131226u, 131227u, 131228u, 131229u, 131230u, 131231u, 1073873040u, 1078067344u,
			1074921616u, 1079115920u, 1073873041u, 1078067345u, 1074921617u, 1079115921u, 1073873042u, 1074921618u, 1089601682u, 1081213074u,
			1073873043u, 1074921619u, 1089601683u, 1081213075u, 1073873048u, 1078067352u, 1074921624u, 1079115928u, 1073873049u, 1078067353u,
			1074921625u, 1079115929u, 131232u, 131232u, 131232u, 131233u, 131233u, 131233u, 131234u, 131235u,
			131235u, 131235u, 131236u, 131236u, 131236u, 131237u, 131237u, 131237u, 1076078272u, 1076078272u,
			1076078272u, 1076078280u, 1076078280u, 1076078280u, 1076078288u, 1076078288u, 1076078288u, 131238u, 131238u, 239552u,
			239552u, 239552u, 1076078536u, 1076078536u, 1076078536u, 1076078544u, 1076078544u, 1076078544u, 1076078552u, 1076078552u,
			1076078552u, 1076078560u, 1076078560u, 1076078560u, 1076078568u, 1076078568u, 1076078568u, 131239u, 131239u, 131238u,
			131239u, 131239u, 131240u, 131240u, 131240u, 131241u, 131241u, 131241u, 131242u, 131243u,
			131243u, 131243u, 131244u, 131244u, 131244u, 131245u, 131245u, 131245u, 3221356718u, 3221356718u,
			3223453870u, 3223453870u, 3355574446u, 3355574446u, 3357671598u, 3357671598u, 3489792174u, 3491889326u, 3491889326u, 3548512430u,
			3624009902u, 3626107054u, 3626107054u, 3682730158u, 3758227630u, 3758227630u, 3760324782u, 3760324782u, 3892445358u, 3892445358u,
			3894542510u, 3894542510u, 4026663086u, 4026663086u, 4027711662u, 4027711662u, 4027711662u, 4028760238u, 4028760238u, 4028760238u,
			4028760238u, 4029808814u, 4029808814u, 4160880814u, 4161929390u, 1073983208u, 1073983209u, 1073983210u, 1073983211u, 1073983212u,
			1073983213u, 1073983214u, 1073983215u, 1073983216u, 1073983217u, 1073983218u, 1073983219u, 1073983220u, 1073983221u, 1073983222u,
			1073983223u, 1073983224u, 1073983225u, 1073983226u, 1073983227u, 1073983228u, 1073983229u, 1073983230u, 1073983231u, 1075031800u,
			131247u, 131247u, 131247u, 131248u, 131249u, 131249u, 131249u, 131250u, 131250u, 131250u,
			131251u, 131251u, 131251u, 131252u, 131252u, 131252u, 131253u, 131253u, 131253u, 131254u,
			131254u, 131254u, 131255u, 131255u, 131255u, 131256u, 131256u, 1075970232u, 1075970232u, 1075970232u,
			131257u, 131257u, 131257u, 2684485818u, 2684485818u, 2684485818u, 2818703546u, 2818703546u, 2818703546u, 2952921274u,
			2952921274u, 2952921274u, 3087139002u, 3087139002u, 3087139002u, 131259u, 131259u, 131259u, 131260u, 131260u,
			131260u, 1075970236u, 1075970236u, 1075970236u, 131261u, 131261u, 131261u, 1075970237u, 1075970237u, 1075970237u,
			131262u, 131262u, 131262u, 131263u, 131263u, 131263u, 131264u, 131265u, 131265u, 131265u,
			1073873090u, 1149370562u, 1166147778u, 1140981954u, 1157759170u, 1174536386u, 1074921666u, 1150419138u, 1167196354u, 1146224834u,
			1163002050u, 1179779266u, 1075970242u, 1117913282u, 1109524674u, 1077018818u, 1118961858u, 1114767554u, 1073873091u, 1073873091u,
			1073873092u, 1073873092u, 1074921668u, 1074921668u, 1154613444u, 1146224836u, 1154613444u, 1146224836u, 1073873093u, 1073873093u,
			1074921669u, 1074921669u, 1154613445u, 1146224837u, 1154613445u, 1146224837u, 1073873094u, 1149370566u, 1166147782u, 1140981958u,
			1157759174u, 1174536390u, 1074921670u, 1150419142u, 1167196358u, 1146224838u, 1163002054u, 1179779270u, 2281832647u, 2281832647u,
			3624009927u, 3624009927u, 3758227655u, 3758227655u, 3892445383u, 3892445383u, 4026663111u, 4027711687u, 4028760263u, 2952921287u,
			2952921287u, 2952921287u, 4160880839u, 3087139015u, 3087139015u, 3087139015u, 4162977991u, 4162977991u, 131272u, 131272u,
			131272u, 1074921680u, 1150419152u, 1167196368u, 1077018832u, 1152516304u, 1169293520u, 1073873105u, 1074921681u, 1150419153u,
			1167196369u, 1150419153u, 1167196369u, 1183973585u, 1073873106u, 1074921682u, 1150419154u, 1167196370u, 1142030546u, 1158807762u,
			1175584978u, 1073873107u, 1074921683u, 1150419155u, 1167196371u, 1146224851u, 1163002067u, 1179779283u, 1073873108u, 1074921684u,
			1150419156u, 1167196372u, 1146224852u, 1163002068u, 1179779284u, 1073873109u, 1074921685u, 1150419157u, 1167196373u, 1150419157u,
			1167196373u, 1183973589u, 1074921686u, 1150419158u, 1146224854u, 1075970262u, 1077018838u, 1073873111u, 1073873111u, 1074921687u,
			1074921687u, 1154613463u, 1146224855u, 1171390679u, 1163002071u, 1073873112u, 1074921688u, 1150419160u, 1167196376u, 1150419160u,
			1167196376u, 1183973592u, 1073873113u, 1074921689u, 1150419161u, 1167196377u, 1150419161u, 1167196377u, 1183973593u, 1073873114u,
			1074921690u, 1150419162u, 1167196378u, 1150419162u, 1167196378u, 1183973594u, 1073873115u, 1074921691u, 1150419163u, 1167196379u,
			1142030555u, 1158807771u, 1175584987u, 1146224859u, 1163002075u, 1179779291u, 1073873116u, 1074921692u, 1150419164u, 1167196380u,
			1150419164u, 1167196380u, 1183973596u, 1073873117u, 1074921693u, 1150419165u, 1167196381u, 1150419165u, 1167196381u, 1183973597u,
			1073873118u, 1074921694u, 1150419166u, 1167196382u, 1150419166u, 1167196382u, 1183973598u, 1073873119u, 1074921695u, 1150419167u,
			1167196383u, 1142030559u, 1158807775u, 1175584991u, 1146224863u, 1163002079u, 1179779295u, 1073873120u, 1074921696u, 1150419168u,
			1167196384u, 1150419168u, 1167196384u, 1183973600u, 1073873121u, 1074921697u, 1150419169u, 1167196385u, 1150419169u, 1167196385u,
			1183973601u, 1073873122u, 1074921698u, 1150419170u, 1167196386u, 1142030562u, 1158807778u, 1175584994u, 1146224866u, 1163002082u,
			1179779298u, 1073873123u, 1074921699u, 1150419171u, 1167196387u, 1150419171u, 1167196387u, 1183973603u, 1073873124u, 1074921700u,
			1150419172u, 1167196388u, 1150419172u, 1167196388u, 1183973604u, 1073873125u, 1074921701u, 1150419173u, 1167196389u, 1150419173u,
			1167196389u, 1183973605u, 1074921702u, 1150419174u, 1167196390u, 1146224870u, 1163002086u, 1179779302u, 1075970278u, 1151467750u,
			1168244966u, 1143079142u, 1159856358u, 1176633574u, 1147273446u, 1164050662u, 1180827878u, 1077018854u, 1152516326u, 1169293542u,
			1148322022u, 1165099238u, 1181876454u, 1073873127u, 1074921703u, 1150419175u, 1167196391u, 1142030567u, 1158807783u, 1175584999u,
			1073873128u, 1074921704u, 1150419176u, 1167196392u, 1150419176u, 1167196392u, 1183973608u, 1073873129u, 1074921705u, 1150419177u,
			1167196393u, 1150419177u, 1167196393u, 1183973609u, 1073873130u, 1074921706u, 1150419178u, 1167196394u, 1150419178u, 1167196394u,
			1183973610u, 1073873131u, 1074921707u, 1150419179u, 1167196395u, 1142030571u, 1158807787u, 1175585003u, 1146224875u, 1163002091u,
			1179779307u, 1073873132u, 1074921708u, 1150419180u, 1167196396u, 1150419180u, 1167196396u, 1183973612u, 1073873133u, 1074921709u,
			1150419181u, 1167196397u, 1150419181u, 1167196397u, 1183973613u, 1073873134u, 1074921710u, 1150419182u, 1167196398u, 1150419182u,
			1167196398u, 1183973614u, 1073873135u, 1074921711u, 1150419183u, 1167196399u, 1142030575u, 1158807791u, 1175585007u, 1146224879u,
			1163002095u, 1179779311u, 1077018864u, 1152516336u, 1169293552u, 1073873137u, 1074921713u, 1150419185u, 1167196401u, 1150419185u,
			1167196401u, 1183973617u, 1073873138u, 1074921714u, 1150419186u, 1167196402u, 1142030578u, 1158807794u, 1175585010u, 1073873139u,
			1074921715u, 1150419187u, 1167196403u, 1146224883u, 1163002099u, 1179779315u, 1073873140u, 1074921716u, 1150419188u, 1167196404u,
			1146224884u, 1163002100u, 1179779316u, 1073873141u, 1074921717u, 1150419189u, 1167196405u, 1150419189u, 1167196405u, 1183973621u,
			1073873142u, 1074921718u, 1150419190u, 1167196406u, 1150419190u, 1167196406u, 1183973622u, 1073873143u, 1074921719u, 1150419191u,
			1073873144u, 1074921720u, 1150419192u, 1167196408u, 1150419192u, 1167196408u, 1183973624u, 1073873145u, 1074921721u, 1150419193u,
			1167196409u, 1150419193u, 1167196409u, 1183973625u, 1073873146u, 1074921722u, 1150419194u, 1167196410u, 1142030586u, 1158807802u,
			1175585018u, 1073873147u, 1074921723u, 1150419195u, 1167196411u, 1146224891u, 1163002107u, 1179779323u, 1073873148u, 1074921724u,
			1150419196u, 1167196412u, 1150419196u, 1167196412u, 1183973628u, 1073873149u, 1074921725u, 1150419197u, 1167196413u, 1150419197u,
			1167196413u, 1183973629u, 1073873150u, 1074921726u, 1150419198u, 1167196414u, 1142030590u, 1158807806u, 1175585022u, 131327u,
			131327u, 131327u, 1074003968u, 1075052544u, 1150550016u, 1167327232u, 1150550016u, 1167327232u, 1184104448u, 1074003969u,
			1075052545u, 1150550017u, 1167327233u, 1074003970u, 1075052546u, 1150550018u, 1167327234u, 1074003971u, 1075052547u, 1150550019u,
			1167327235u, 1074003972u, 1075052548u, 1150550020u, 1167327236u, 1150550020u, 1167327236u, 1184104452u, 1074003973u, 1075052549u,
			1150550021u, 1167327237u, 1074003974u, 1075052550u, 1150550022u, 1167327238u, 1074003975u, 1075052551u, 1150550023u, 1167327239u,
			1074003976u, 1075052552u, 1150550024u, 1167327240u, 1074003977u, 1075052553u, 1150550025u, 1167327241u, 1074003978u, 1075052554u,
			1150550026u, 1167327242u, 1074003979u, 1075052555u, 1150550027u, 1167327243u, 1150550027u, 1167327243u, 1184104459u, 1142161420u,
			1158938636u, 1142161420u, 1158938636u, 1175715852u, 1142161421u, 1158938637u, 1146355725u, 1163132941u, 1179910157u, 1142161422u,
			1158938638u, 1142161423u, 1158938639u, 1075052560u, 1146355728u, 1163132944u, 1179910160u, 1143210000u, 1159987216u, 1176764432u,
			1146355729u, 1163132945u, 1179910161u, 1143210001u, 1159987217u, 1176764433u, 1146355730u, 1163132946u, 1179910162u, 1143210002u,
			1159987218u, 1176764434u, 1142161427u, 1158938643u, 1142161427u, 1158938643u, 1175715859u, 1143210003u, 1159987219u, 1176764435u,
			1075052564u, 1142161428u, 1158938644u, 1175715860u, 1146355732u, 1163132948u, 1179910164u, 1143210004u, 1159987220u, 1176764436u,
			1075052565u, 1142161429u, 1158938645u, 1175715861u, 1146355733u, 1163132949u, 1179910165u, 1143210005u, 1159987221u, 1176764437u,
			1158938646u, 1158938646u, 1175715862u, 1163132950u, 1179910166u, 1075052567u, 1150550039u, 1167327255u, 1142161432u, 1158938648u,
			1142161432u, 1158938648u, 1175715864u, 1158938649u, 1158938649u, 1175715865u, 1163132953u, 1179910169u, 1158938650u, 1158938650u,
			1175715866u, 1163132954u, 1179910170u, 1175715867u, 1179910171u, 1074003996u, 1075052572u, 1150550044u, 1167327260u, 1150550044u,
			1167327260u, 1184104476u, 1074003997u, 1075052573u, 1150550045u, 1167327261u, 1150550045u, 1167327261u, 1184104477u, 1074003998u,
			1075052574u, 1150550046u, 1167327262u, 1142161438u, 1158938654u, 1175715870u, 1146355743u, 1163132959u, 1179910175u, 1075052576u,
			1150550048u, 1167327264u, 1150550048u, 1167327264u, 1184104480u, 1143210016u, 1159987232u, 1176764448u, 1075052577u, 1150550049u,
			1167327265u, 1150550049u, 1167327265u, 1184104481u, 1143210017u, 1159987233u, 1176764449u, 1075052578u, 1150550050u, 1167327266u,
			1150550050u, 1167327266u, 1184104482u, 1143210018u, 1159987234u, 1176764450u, 1075052579u, 1150550051u, 1167327267u, 1150550051u,
			1167327267u, 1184104483u, 1143210019u, 1159987235u, 1176764451u, 1075052580u, 1150550052u, 1167327268u, 1150550052u, 1167327268u,
			1184104484u, 1143210020u, 1159987236u, 1176764452u, 1075052581u, 1150550053u, 1167327269u, 1142161445u, 1158938661u, 1175715877u,
			1143210021u, 1159987237u, 1176764453u, 1142161446u, 1158938662u, 1175715878u, 1146355750u, 1163132966u, 1179910182u, 1143210022u,
			1159987238u, 1176764454u, 1147404326u, 1164181542u, 1180958758u, 1142161447u, 1158938663u, 1175715879u, 1146355751u, 1163132967u,
			1179910183u, 1143210023u, 1159987239u, 1176764455u, 1147404327u, 1164181543u, 1180958759u, 1075052584u, 1150550056u, 1167327272u,
			1146355752u, 1163132968u, 1179910184u, 1143210024u, 1159987240u, 1176764456u, 1147404328u, 1164181544u, 1180958760u, 1075052585u,
			1150550057u, 1167327273u, 1146355753u, 1163132969u, 1179910185u, 1143210025u, 1159987241u, 1176764457u, 1147404329u, 1164181545u,
			1180958761u, 1075052586u, 1150550058u, 1167327274u, 1142161450u, 1158938666u, 1175715882u, 1147404330u, 1164181546u, 1180958762u,
			1075052587u, 1150550059u, 1167327275u, 1142161451u, 1158938667u, 1175715883u, 1142161452u, 1158938668u, 1142161452u, 1158938668u,
			1175715884u, 1146355756u, 1163132972u, 1179910188u, 1142161453u, 1158938669u, 1108607021u, 1112801325u, 1142161454u, 1158938670u,
			1142161455u, 1158938671u, 1075052592u, 1150550064u, 1167327280u, 1150550064u, 1167327280u, 1184104496u, 1143210032u, 1159987248u,
			1176764464u, 1075052593u, 1150550065u, 1167327281u, 1150550065u, 1167327281u, 1184104497u, 1143210033u, 1159987249u, 1176764465u,
			1075052594u, 1150550066u, 1167327282u, 1150550066u, 1167327282u, 1184104498u, 1143210034u, 1159987250u, 1176764466u, 1075052595u,
			1150550067u, 1167327283u, 1150550067u, 1167327283u, 1184104499u, 1143210035u, 1159987251u, 1176764467u, 1075052596u, 1150550068u,
			1167327284u, 1150550068u, 1167327284u, 1184104500u, 1143210036u, 1159987252u, 1176764468u, 1075052597u, 1150550069u, 1167327285u,
			1142161461u, 1158938677u, 1175715893u, 1143210037u, 1159987253u, 1176764469u, 1158938678u, 1158938678u, 1175715894u, 1163132982u,
			1179910198u, 1075052599u, 1150550071u, 1167327287u, 1146355767u, 1163132983u, 1179910199u, 1075052600u, 1150550072u, 1167327288u,
			1150550072u, 1167327288u, 1184104504u, 1143210040u, 1159987256u, 1176764472u, 1147404344u, 1164181560u, 1180958776u, 1075052601u,
			1150550073u, 1167327289u, 1142161465u, 1158938681u, 1175715897u, 1146355769u, 1163132985u, 1179910201u, 1143210041u, 1159987257u,
			1176764473u, 1147404345u, 1164181561u, 1180958777u, 1075052602u, 1150550074u, 1167327290u, 1150550074u, 1167327290u, 1184104506u,
			1143210042u, 1159987258u, 1176764474u, 1075052603u, 1150550075u, 1167327291u, 1142161467u, 1158938683u, 1175715899u, 1146355771u,
			1163132987u, 1179910203u, 1075052604u, 1150550076u, 1167327292u, 1150550076u, 1167327292u, 1184104508u, 1075052605u, 1150550077u,
			1167327293u, 1142161469u, 1158938685u, 1175715901u, 1146355773u, 1163132989u, 1179910205u, 1075052606u, 1150550078u, 1167327294u,
			1150550078u, 1167327294u, 1184104510u, 1075052607u, 1150550079u, 1167327295u, 1142161471u, 1158938687u, 1175715903u, 1146355775u,
			1163132991u, 1179910207u, 1075052608u, 1150550080u, 1167327296u, 1142161472u, 1158938688u, 1175715904u, 1146355776u, 1163132992u,
			1179910208u, 1075052609u, 1150550081u, 1142161474u, 1158938690u, 1175715906u, 1146355778u, 1163132994u, 1179910210u, 1108607043u,
			1112801347u, 1142161476u, 1158938692u, 1175715908u, 1146355780u, 1163132996u, 1179910212u, 1142161477u, 1158938693u, 1146355781u,
			1163132997u, 1142161477u, 1158938693u, 1175715909u, 1146355781u, 1163132997u, 1179910213u, 1142161478u, 1158938694u, 1142161478u,
			1158938694u, 1175715910u, 1146355782u, 1163132998u, 1179910214u, 1142161479u, 1158938695u, 1146355783u, 1163132999u, 1142161479u,
			1158938695u, 1175715911u, 1146355783u, 1163132999u, 1179910215u, 1142161484u, 1158938700u, 1175715916u, 1146355788u, 1163133004u,
			1179910220u, 1108607053u, 1112801357u, 1142161486u, 1158938702u, 1175715918u, 1146355790u, 1163133006u, 1179910222u, 1108607055u,
			1112801359u, 1142161488u, 1158938704u, 1175715920u, 1142161489u, 1158938705u, 1175715921u, 1142161490u, 1158938706u, 1175715922u,
			1143210066u, 1159987282u, 1176764498u, 1177813074u, 1142161491u, 1158938707u, 1175715923u, 1177813075u, 1142161492u, 1158938708u,
			1175715924u, 1146355796u, 1163133012u, 1179910228u, 1142161493u, 1158938709u, 1175715925u, 1146355797u, 1163133013u, 1179910229u,
			1142161496u, 1158938712u, 1142161496u, 1158938712u, 1175715928u, 1142161497u, 1158938713u, 1142161497u, 1158938713u, 1175715929u,
			1146355801u, 1163133017u, 1179910233u, 1158938714u, 1158938714u, 1175715930u, 1163133018u, 1179910234u, 1175715931u, 1179910235u,
			1142161506u, 1158938722u, 1175715938u, 1146355810u, 1163133026u, 1179910242u, 1142161507u, 1158938723u, 1175715939u, 1146355811u,
			1163133027u, 1179910243u, 1142161508u, 1158938724u, 1175715940u, 1146355812u, 1163133028u, 1179910244u, 1142161509u, 1158938725u,
			1175715941u, 1146355813u, 1163133029u, 1179910245u, 1142161510u, 1158938726u, 1175715942u, 1146355814u, 1163133030u, 1179910246u,
			1144258664u, 1161035880u, 1177813096u, 1148452968u, 1165230184u, 1182007400u, 1146355824u, 1163133040u, 1179910256u, 1142161521u,
			1158938737u, 1175715953u, 1146355825u, 1163133041u, 1179910257u, 1146355826u, 1163133042u, 1179910258u, 1143210098u, 1159987314u,
			1176764530u, 1144258674u, 1161035890u, 1177813106u, 1142161523u, 1158938739u, 1175715955u, 1146355827u, 1163133043u, 1179910259u,
			1142161525u, 1158938741u, 1175715957u, 1146355829u, 1163133045u, 1179910261u, 1142161526u, 1158938742u, 1175715958u, 1146355830u,
			1163133046u, 1179910262u, 1142161527u, 1158938743u, 1175715959u, 1146355831u, 1163133047u, 1179910263u, 1142161528u, 1158938744u,
			1142161528u, 1158938744u, 1175715960u, 1142161529u, 1158938745u, 1142161529u, 1158938745u, 1175715961u, 1142161530u, 1158938746u,
			1175715962u, 1142161531u, 1158938747u, 1175715963u, 1154744444u, 1171521660u, 1188298876u, 1146355836u, 1163133052u, 1179910268u,
			1142161533u, 1158938749u, 1175715965u, 1146355837u, 1163133053u, 1179910269u, 1142161534u, 1158938750u, 1175715966u, 1146355838u,
			1163133054u, 1179910270u, 1142161535u, 1158938751u, 1175715967u, 1146355839u, 1163133055u, 1179910271u, 1075052672u, 1075052672u,
			1075052673u, 1075052673u, 1075052674u, 1075052674u, 1146355843u, 1163133059u, 1179910275u, 1142161544u, 1158938760u, 1175715976u,
			1146355848u, 1163133064u, 1179910280u, 1142161545u, 1158938761u, 1175715977u, 1146355849u, 1163133065u, 1179910281u, 1142161546u,
			1158938762u, 1175715978u, 1146355850u, 1163133066u, 1179910282u, 1142161547u, 1158938763u, 1175715979u, 1146355851u, 1163133067u,
			1179910283u, 1142161548u, 1158938764u, 1146355852u, 1163133068u, 1142161549u, 1158938765u, 1175715981u, 1146355853u, 1163133069u,
			1179910285u, 1142161550u, 1158938766u, 1146355854u, 1163133070u, 1142161551u, 1158938767u, 1175715983u, 1142161552u, 1158938768u,
			1146355856u, 1163133072u, 1142161552u, 1158938768u, 1175715984u, 1146355856u, 1163133072u, 1179910288u, 1142161553u, 1158938769u,
			1146355857u, 1163133073u, 1142161553u, 1158938769u, 1175715985u, 1146355857u, 1163133073u, 1179910289u, 1142161554u, 1158938770u,
			1146355858u, 1163133074u, 1142161554u, 1158938770u, 1175715986u, 1146355858u, 1163133074u, 1179910290u, 1142161555u, 1158938771u,
			1146355859u, 1163133075u, 1142161555u, 1158938771u, 1175715987u, 1146355859u, 1163133075u, 1179910291u, 1142161558u, 1158938774u,
			1146355862u, 1163133078u, 1142161558u, 1158938774u, 1175715990u, 1146355862u, 1163133078u, 1179910294u, 1142161559u, 1158938775u,
			1146355863u, 1163133079u, 1142161559u, 1158938775u, 1175715991u, 1146355863u, 1163133079u, 1179910295u, 1142161560u, 1158938776u,
			1146355864u, 1163133080u, 1142161560u, 1158938776u, 1175715992u, 1146355864u, 1163133080u, 1179910296u, 1108607129u, 1112801433u,
			1108607129u, 1112801433u, 1142161562u, 1158938778u, 1146355866u, 1163133082u, 1142161562u, 1158938778u, 1175715994u, 1146355866u,
			1163133082u, 1179910298u, 1177813146u, 1108607131u, 1112801435u, 1108607131u, 1112801435u, 1110704283u, 1142161564u, 1158938780u,
			1146355868u, 1163133084u, 1142161564u, 1158938780u, 1175715996u, 1146355868u, 1163133084u, 1179910300u, 1108607133u, 1112801437u,
			1108607133u, 1112801437u, 1142161566u, 1158938782u, 1146355870u, 1163133086u, 1142161566u, 1158938782u, 1175715998u, 1146355870u,
			1163133086u, 1179910302u, 1108607135u, 1112801439u, 1108607135u, 1112801439u, 1142161568u, 1158938784u, 1175716000u, 1146355872u,
			1163133088u, 1179910304u, 1142161569u, 1158938785u, 1175716001u, 1146355873u, 1163133089u, 1179910305u, 1142161570u, 1158938786u,
			1175716002u, 1146355874u, 1163133090u, 1179910306u, 1142161571u, 1158938787u, 1175716003u, 1146355875u, 1163133091u, 1179910307u,
			1142161574u, 1158938790u, 1146355878u, 1163133094u, 1142161574u, 1158938790u, 1175716006u, 1146355878u, 1163133094u, 1179910310u,
			1142161575u, 1158938791u, 1146355879u, 1163133095u, 1142161575u, 1158938791u, 1175716007u, 1146355879u, 1163133095u, 1179910311u,
			1142161576u, 1158938792u, 1146355880u, 1163133096u, 1142161576u, 1158938792u, 1175716008u, 1146355880u, 1163133096u, 1179910312u,
			1108607145u, 1112801449u, 1108607145u, 1112801449u, 1142161578u, 1158938794u, 1146355882u, 1163133098u, 1142161578u, 1158938794u,
			1175716010u, 1146355882u, 1163133098u, 1179910314u, 1177813162u, 1108607147u, 1112801451u, 1108607147u, 1112801451u, 1110704299u,
			1142161580u, 1158938796u, 1146355884u, 1163133100u, 1142161580u, 1158938796u, 1175716012u, 1146355884u, 1163133100u, 1179910316u,
			1108607149u, 1112801453u, 1108607149u, 1112801453u, 1142161582u, 1158938798u, 1146355886u, 1163133102u, 1142161582u, 1158938798u,
			1175716014u, 1146355886u, 1163133102u, 1179910318u, 1108607151u, 1112801455u, 1108607151u, 1112801455u, 1146355892u, 1163133108u,
			1179910324u, 1146355893u, 1163133109u, 1179910325u, 1142161590u, 1158938806u, 1146355894u, 1163133110u, 1142161590u, 1158938806u,
			1175716022u, 1146355894u, 1163133110u, 1179910326u, 1142161591u, 1158938807u, 1146355895u, 1163133111u, 1142161591u, 1158938807u,
			1175716023u, 1146355895u, 1163133111u, 1179910327u, 1142161592u, 1158938808u, 1146355896u, 1163133112u, 1142161592u, 1158938808u,
			1175716024u, 1146355896u, 1163133112u, 1179910328u, 1108607161u, 1112801465u, 1108607161u, 1112801465u, 1142161594u, 1158938810u,
			1146355898u, 1163133114u, 1142161594u, 1158938810u, 1175716026u, 1146355898u, 1163133114u, 1179910330u, 1108607163u, 1112801467u,
			1108607163u, 1112801467u, 1142161596u, 1158938812u, 1146355900u, 1163133116u, 1142161596u, 1158938812u, 1175716028u, 1146355900u,
			1163133116u, 1179910332u, 1108607165u, 1112801469u, 1108607165u, 1112801469u, 1142161598u, 1158938814u, 1146355902u, 1163133118u,
			1142161598u, 1158938814u, 1175716030u, 1146355902u, 1163133118u, 1179910334u, 1108607167u, 1112801471u, 1108607167u, 1112801471u,
			1142161604u, 1158938820u, 1175716036u, 1146355908u, 1163133124u, 1179910340u, 3457417414u, 3461611718u, 3591635142u, 3595829446u,
			3994288326u, 3998482630u, 4128506054u, 4132700358u, 3457417415u, 3461611719u, 3591635143u, 3595829447u, 3994288327u, 3998482631u,
			4128506055u, 4132700359u, 1074004168u, 1175716040u, 1179910344u, 1074004169u, 1074004170u, 1175716042u, 1179910346u, 1074004171u,
			1108607179u, 1112801483u, 1074004172u, 1175716044u, 1179910348u, 1074004173u, 1108607181u, 1112801485u, 1075052751u, 1142161615u,
			1158938831u, 1142161615u, 1158938831u, 1175716047u, 1075052763u, 1150550235u, 1075052764u, 1150550236u, 1167327452u, 1150550236u,
			1167327452u, 1184104668u, 1075052765u, 1150550237u, 1167327453u, 1150550237u, 1167327453u, 1184104669u, 1075052766u, 1150550238u,
			1167327454u, 1150550238u, 1167327454u, 1184104670u, 1075052767u, 1150550239u, 1167327455u, 1150550239u, 1167327455u, 1184104671u,
			262384u, 262384u, 262384u, 1077149936u, 1077149936u, 262385u, 262385u, 262385u, 1077149937u, 1077149937u,
			1077149937u, 1136918770u, 1128530162u, 3418620147u, 3410231539u, 3552837875u, 3544449267u, 3687055603u, 3678666995u, 1136918773u,
			1128530165u, 1075052789u, 1075052789u, 1139015925u, 1130627317u, 1140064501u, 1131675893u, 1074004214u, 1074004214u, 1075052790u,
			1075052790u, 1076101366u, 1076101366u, 1140064502u, 1131675894u, 1136918775u, 1128530167u, 1137967351u, 1129578743u, 1139015927u,
			1130627319u, 1140064503u, 1131675895u, 1075052792u, 1075052792u, 1075052792u, 1076101368u, 1076101368u, 1076101368u, 1077149944u,
			1077149944u, 1077149944u, 1074004217u, 1074004217u, 1163264000u, 1163264000u, 1180041216u, 1163264001u, 1163264001u, 1180041217u,
			1142292482u, 1159069698u, 1142292483u, 1159069699u, 1175846915u, 1146486787u, 1163264003u, 1180041219u, 1142292484u, 1159069700u,
			1142292484u, 1159069700u, 1175846916u, 1142292485u, 1159069701u, 1146486789u, 1163264005u, 1180041221u, 1159069702u, 1075183624u,
			1150681096u, 1167458312u, 1142292488u, 1159069704u, 1175846920u, 1075183625u, 1150681097u, 1167458313u, 1146486793u, 1163264009u,
			1180041225u, 1075183626u, 1117126666u, 1108738058u, 1075183627u, 1117126667u, 1112932363u, 1075183628u, 1150681100u, 1167458316u,
			1075183629u, 1150681101u, 1167458317u, 1075183630u, 1150681102u, 1167458318u, 1074135055u, 1075183631u, 1150681103u, 1167458319u,
			1150681103u, 1167458319u, 1184235535u, 1075183636u, 1075183636u, 1154875412u, 1146486804u, 1154875412u, 1146486804u, 1075183637u,
			1075183637u, 1154875413u, 1146486805u, 1154875413u, 1146486805u, 1075183638u, 1075183638u, 1154875414u, 1146486806u, 1154875414u,
			1146486806u, 1075183639u, 1075183639u, 1154875415u, 1146486807u, 1154875415u, 1146486807u, 1159069720u, 1159069720u, 1175846936u,
			1163264024u, 1180041240u, 1159069721u, 1159069721u, 1175846937u, 1163264025u, 1180041241u, 1175846938u, 1180041242u, 1175846939u,
			1180041243u, 1142292509u, 1159069725u, 1142292509u, 1159069725u, 1175846941u, 1142292510u, 1159069726u, 1175846942u, 1146486814u,
			1163264030u, 1180041246u, 1142292511u, 1159069727u, 1175846943u, 1146486815u, 1163264031u, 1180041247u, 1075183648u, 1075183648u,
			1154875424u, 1146486816u, 1154875424u, 1146486816u, 1075183649u, 1150681121u, 1142292513u, 1075183650u, 1075183650u, 1154875426u,
			1146486818u, 1154875426u, 1146486818u, 1159069731u, 1175846947u, 1163264035u, 1180041251u, 1142292517u, 1159069733u, 1175846949u,
			1146486821u, 1163264037u, 1180041253u, 1142292518u, 1159069734u, 1175846950u, 1146486822u, 1163264038u, 1180041254u, 1108738087u,
			1112932391u, 1075183664u, 1079377968u, 1075183665u, 1079377969u, 1075183666u, 1079377970u, 1075183667u, 1079377971u, 1159069752u,
			1159069752u, 1175846968u, 1163264056u, 1180041272u, 1159069753u, 1159069753u, 1175846969u, 1163264057u, 1180041273u, 1175846970u,
			1180041274u, 1175846971u, 1180041275u, 1142292542u, 1159069758u, 1175846974u, 1146486846u, 1163264062u, 1180041278u, 1142292543u,
			1159069759u, 1175846975u, 1146486847u, 1163264063u, 1180041279u, 1075183680u, 1150681152u, 1167458368u, 1075183681u, 1150681153u,
			1075183682u, 1150681154u, 1167458370u, 1142292546u, 1159069762u, 1175846978u, 1159069763u, 1175846979u, 1163264067u, 1180041283u,
			1075183684u, 1150681156u, 1167458372u, 1150681156u, 1167458372u, 1184235588u, 1159069766u, 1142292552u, 1159069768u, 1146486856u,
			1163264072u, 1142292553u, 1159069769u, 1146486857u, 1163264073u, 1142292554u, 1159069770u, 1142292555u, 1159069771u, 1142292556u,
			1159069772u, 1142292560u, 1159069776u, 1175846992u, 1146486864u, 1163264080u, 1180041296u, 1108738129u, 1112932433u, 1142292564u,
			1159069780u, 1175846996u, 1146486868u, 1163264084u, 1180041300u, 1108738133u, 1112932437u, 1142292566u, 1159069782u, 1175846998u,
			1146486870u, 1163264086u, 1180041302u, 1108738135u, 1112932439u, 1142292572u, 1159069788u, 1146486876u, 1163264092u, 1142292573u,
			1159069789u, 1146486877u, 1163264093u, 1142292574u, 1159069790u, 1146486878u, 1163264094u, 1142292575u, 1159069791u, 1146486879u,
			1163264095u, 1075183712u, 1075183712u, 1154875488u, 1146486880u, 1075183713u, 1075183713u, 1154875489u, 1146486881u, 1075183714u,
			1150681186u, 1075183715u, 1150681187u, 1142292582u, 1159069798u, 1175847014u, 1146486886u, 1163264102u, 1180041318u, 1108738151u,
			1112932455u, 1142292584u, 1159069800u, 1146486888u, 1163264104u, 1142292585u, 1159069801u, 1146486889u, 1163264105u, 1108738154u,
			1112932458u, 1108738155u, 1112932459u, 1142292588u, 1159069804u, 1146486892u, 1163264108u, 1142292589u, 1159069805u, 1146486893u,
			1163264109u, 1108738158u, 1112932462u, 1108738159u, 1112932463u, 1146486896u, 1163264112u, 1180041328u, 1142292593u, 1159069809u,
			1175847025u, 1146486897u, 1163264113u, 1180041329u, 1146486898u, 1163264114u, 1180041330u, 1142292595u, 1159069811u, 1175847027u,
			1146486899u, 1163264115u, 1180041331u, 1142292600u, 1159069816u, 1146486904u, 1163264120u, 1142292601u, 1159069817u, 1146486905u,
			1163264121u, 1108738170u, 1112932474u, 1108738171u, 1112932475u, 1142292604u, 1159069820u, 1146486908u, 1163264124u, 1142292605u,
			1159069821u, 1146486909u, 1163264125u, 1108738174u, 1112932478u, 1108738175u, 1112932479u, 1074135244u, 1075183822u, 1146486990u,
			1163264206u, 1146486990u, 1163264206u, 1180041422u, 1075183823u, 1146486991u, 1163264207u, 1146486991u, 1163264207u, 1180041423u,
			1075183839u, 1150681311u, 1140195568u, 1131806960u, 1140850821u, 1140850822u, 1140850823u, 1140850830u, 1140850831u, 1140850837u,
			1140850838u, 1140850839u, 1140850846u, 1140850847u, 1140850850u, 1157628066u, 1145045154u, 1161822370u, 1140850851u, 1145045155u,
			1140850854u, 1140850870u, 1140850880u, 1140850881u, 1140850882u, 1140850883u, 1140850892u, 1140850893u, 1140850894u, 1140850895u,
			1140850924u, 1140850925u, 1140850926u, 1140850927u, 3368157185u, 3359768577u, 3502374913u, 3493986305u, 3636592641u, 3628204033u,
			3770810369u, 3762421761u, 3905028097u, 3896639489u, 4039245825u, 4030857217u, 4173463553u, 4165074945u, 3368157186u, 3359768578u,
			4039245826u, 4030857218u, 3233939474u, 3225550866u, 3368157202u, 3359768594u, 1140981888u, 1157759104u, 1140981889u, 1157759105u,
			1140981890u, 1140981891u, 1140981904u, 1145176208u, 1140981905u, 1145176209u, 1140981906u, 1145176210u, 1140981907u, 1145176211u,
			1140981908u, 1145176212u, 1140981909u, 1145176213u, 1140981910u, 1145176214u, 1140981911u, 1145176215u, 1140981912u, 1145176216u,
			1140981913u, 1145176217u, 1140981914u, 1145176218u, 1140981915u, 1145176219u, 1140981953u, 1140981954u, 1140981955u, 1140981958u,
			1140981959u, 1140981963u, 1140981969u, 1140981970u, 1140981971u, 1140981974u, 1140981975u, 1140981979u, 1140981985u, 1140981986u,
			1140981987u, 1086586896u, 1078198288u, 3234070546u, 3225681938u, 3368288274u, 3359899666u, 12u, 13u, 28u,
			29u, 134u, 135u, 138u, 142u, 144u, 148u, 150u, 151u, 154u,
			158u, 160u, 164u, 166u, 167u, 170u, 174u, 176u, 180u, 182u,
			183u, 187u, 191u, 1076036094u, 1077084670u, 1076036095u, 1077084671u, 1077084671u, 1077084671u, 1073938920u,
			1077084648u, 1077084649u, 1073938942u, 1073938942u, 1073938942u, 1073938943u, 2550267917u, 2684485645u, 2818703373u, 2952921101u,
			3087138829u, 131327u, 1076036057u, 1073872951u, 3288596553u, 1141197248u, 3289645129u, 1144258633u, 1142161483u, 1143210059u,
			1144258635u, 1143210076u, 1141112926u, 1142161502u, 1143210078u, 1144258654u, 122849u, 122850u, 2147614774u, 2147614775u,
			131128u, 131129u, 131130u, 131192u, 131193u, 2147614842u, 2147614843u, 2147614844u, 2147614845u, 131198u,
			131130u, 131131u, 131132u, 131133u, 131135u, 131152u, 131153u, 131154u, 131156u, 131157u,
			131160u, 131161u, 131162u, 131163u, 131164u, 131165u, 131166u, 121303u, 121314u, 121318u,
			121319u, 121852u, 122364u, 122584u, 122586u, 122588u, 122589u, 122590u, 122876u, 1074987468u,
			1074987469u, 1074987470u, 1074987471u, 3223584984u, 3357802712u, 3492020440u, 3626238168u, 1076101340u, 1076101340u, 1076101341u,
			1076101342u, 1076101343u, 1076101370u, 1076101371u, 1142161432u, 1158938648u, 1158938649u, 1077084633u, 1076036076u, 1076036077u,
			1076036078u, 1076036079u, 4028760263u, 1076359360u, 1142161488u, 1158938704u, 1142161489u, 1158938705u, 1142161490u, 1158938706u,
			1142161491u, 1158938707u, 1076078312u, 1076078312u, 1076078312u, 1076078576u, 1076078576u, 1076078576u, 4029808640u, 4029808640u,
			4029808640u, 1076036042u, 1077084618u, 1141506136u, 1158283352u, 1175060568u, 1110048856u, 1141244098u, 1158021314u, 1174798530u,
			1109786818u, 1107951663u, 1141506139u, 1158283355u, 1175060571u, 1146749018u, 1163526234u, 1180303450u, 1142554715u, 1159331931u,
			1176109147u, 1141506138u, 1158283354u, 1175060570u, 1142685715u, 1159462931u, 1176240147u, 1142554747u, 1159331963u, 1176109179u,
			1141506169u, 1158283385u, 1175060601u, 1142554745u, 1159331961u, 1176109177u, 1141506173u, 1158283389u, 1175060605u, 1142554749u,
			1159331965u, 1176109181u, 1142554653u, 1159331869u, 1176109085u, 1145700443u, 1162477659u, 1179254875u, 1115291738u, 1110048858u,
			1122631725u, 1114243117u, 1108082707u, 1122631801u, 1114243193u, 1122631722u, 1114243114u, 1107951645u, 1143603291u, 1160380507u,
			1177157723u, 1142554746u, 1159331962u, 1176109178u, 1141506168u, 1158283384u, 1175060600u, 1142554744u, 1159331960u, 1176109176u,
			1141506172u, 1158283388u, 1175060604u, 1142554748u, 1159331964u, 1176109180u, 1122631724u, 1114243116u, 1122631800u, 1114243192u,
			1144651898u, 1161429114u, 1178206330u, 1148846202u, 1165623418u, 1182400634u, 1122631803u, 1114243195u, 1144651901u, 1161429117u,
			1178206333u, 1143603325u, 1160380541u, 1177157757u, 1141506142u, 1158283358u, 1175060574u, 1110048862u, 1144782934u, 1161560150u,
			1178337366u, 1143734358u, 1160511574u, 1177288790u, 1111228503u, 1110179927u, 1144783062u, 1161560278u, 1178337494u, 1143734486u,
			1160511702u, 1177288918u, 1111228631u, 1110180055u, 1142685846u, 1159463062u, 1176240278u, 1142685862u, 1159463078u, 1176240294u,
			1142685878u, 1159463094u, 1176240310u, 1142685847u, 1159463063u, 1176240279u, 1142685863u, 1159463079u, 1176240295u, 1142685879u,
			1159463095u, 1176240311u, 1142685848u, 1159463064u, 1176240280u, 1142685864u, 1159463080u, 1176240296u, 1142685880u, 1159463096u,
			1176240312u, 1142685852u, 1159463068u, 1176240284u, 1142685868u, 1159463084u, 1176240300u, 1142685884u, 1159463100u, 1176240316u,
			1109131417u, 1109131433u, 1109131449u, 1109131421u, 1109131437u, 1109131453u, 1142685850u, 1159463066u, 1176240282u, 1142685866u,
			1159463082u, 1176240298u, 1142685882u, 1159463098u, 1176240314u, 1142685854u, 1159463070u, 1176240286u, 1142685870u, 1159463086u,
			1176240302u, 1142685886u, 1159463102u, 1176240318u, 1109131419u, 1109131435u, 1109131451u, 1109131423u, 1109131439u, 1109131455u,
			1141244006u, 1158021222u, 1174798438u, 1107689575u, 1142685762u, 1159462978u, 1176240194u, 1109131331u, 1141243942u, 1158021158u,
			1174798374u, 1107689511u, 1141506143u, 1158283359u, 1175060575u, 1110048863u, 1141506141u, 1158283357u, 1175060573u, 1110048861u,
			1110048784u, 1110048785u, 1110048784u, 1110048785u, 1155137646u, 1146749038u, 1155137662u, 1146749054u, 1141506137u, 1158283353u,
			1175060569u, 1110048857u, 1142685772u, 1159462988u, 1176240204u, 1109131341u, 1141243990u, 1158021206u, 1174798422u, 1107689559u,
			1141243912u, 1158021128u, 1174798344u, 1107689482u, 1142685774u, 1159462990u, 1176240206u, 1109131343u, 1142685740u, 1159462956u,
			1176240172u, 1109131309u, 1141506129u, 1158283345u, 1175060561u, 1110048849u, 1141506140u, 1158283356u, 1175060572u, 1110048860u,
			1107951662u, 131086u, 131087u, 1140850804u, 1140850805u, 3296854040u, 3431071768u, 3565289496u, 3699507224u, 3833724952u,
			3967942680u, 4102160408u, 4236378136u, 1140981825u, 1140981826u, 1140981827u, 1140981828u, 1140981829u, 1140981830u, 1140981831u,
			1140981832u, 1140981833u, 1140981892u, 1140981893u, 1140981904u, 1140981906u, 1140981907u, 1140981909u, 1140981911u, 1140981912u,
			4108452014u, 4100063406u, 4109500590u, 4101111982u, 4238475438u, 4239524014u, 1155662008u, 1147273400u, 1155662012u, 1147273404u,
			1156710588u, 1148321980u, 1155662013u, 1147273405u, 1143210224u, 1147404528u, 1144258800u, 1148453104u, 1144258801u, 1148453105u,
			1142292542u, 3330408472u, 3464626200u, 3598843928u, 3733061656u, 3867279384u, 4001497112u, 4135714840u, 4269932568u, 1174536232u,
			1179779112u, 1174536233u, 1179779113u, 1180827689u, 1180827689u, 1177681961u, 1177681961u, 1174536280u, 1179779160u, 1174536281u,
			1179779161u, 1174536282u, 1179779162u, 1174536284u, 1179779164u, 1175584870u, 1175584879u, 1179779183u, 1175584880u, 3591503986u,
			3859939442u, 4128374898u, 1175584886u, 1176633466u, 1175584895u, 1179779199u, 4272029870u, 4273078446u, 1174536386u, 1179779266u,
			1175584987u, 1179779291u, 1175584991u, 1179779295u, 1176633574u, 1175585003u, 1179779307u, 1175585007u, 1179779311u, 1175585018u,
			1175585022u, 1175715864u, 1179910169u, 1175715866u, 1179910171u, 1175715879u, 1175715894u, 1175715897u, 1175715899u, 1175715901u,
			1175715903u, 1175715904u, 1175715906u, 1179910210u, 1175715909u, 1175715910u, 1175715911u, 1175715912u, 1175715913u, 1175715914u,
			1175715915u, 1175715920u, 1179910224u, 1175715921u, 1175715922u, 1179910226u, 1175715923u, 1179910227u, 1175715924u, 1175715925u,
			1179910229u, 1175715926u, 1175715927u, 1175715928u, 1179910233u, 1175715930u, 1179910235u, 1175715932u, 1175715933u, 1175715934u,
			1175715935u, 1175715940u, 1179910244u, 1175715941u, 1179910245u, 1175715943u, 1175715944u, 1175715945u, 1175715946u, 1175715947u,
			1175715948u, 1175715949u, 1179910253u, 1175715950u, 1175715951u, 1175715952u, 1175715953u, 1175715954u, 1175715955u, 1175715956u,
			1175715972u, 1175715974u, 1175715975u, 1175715984u, 1179910288u, 1175715986u, 1179910290u, 1175715988u, 1179910292u, 1175715992u,
			1179910296u, 1175715994u, 1179910298u, 1175715996u, 1179910300u, 1175715998u, 1179910302u, 1175716000u, 1179910304u, 1175716002u,
			1179910306u, 1175716004u, 1175716008u, 1179910312u, 1175716010u, 1179910314u, 1175716012u, 1179910316u, 1175716014u, 1179910318u,
			1175716016u, 1175716018u, 1175716020u, 1175716021u, 1175716024u, 1179910328u, 1175716026u, 1179910330u, 1175716028u, 1179910332u,
			1175716030u, 1179910334u, 1175716032u, 3323199686u, 3327393990u, 3457417414u, 3591635142u, 3860070598u, 3864264902u, 3994288326u,
			4128506054u, 1175716040u, 1175716041u, 1175716042u, 1175716043u, 1175716044u, 1175716045u, 1175716046u, 1179910350u, 1175716047u,
			1174667472u, 1178861776u, 1175716048u, 1179910352u, 1174667473u, 1178861777u, 1175716049u, 1179910353u, 1174667474u, 1175716050u,
			1174667475u, 1174667476u, 1178861780u, 1175716052u, 1179910356u, 1174667477u, 1178861781u, 1175716053u, 1179910357u, 1174667478u,
			1175716054u, 1174667479u, 1175846915u, 1175846919u, 1175846942u, 1175846943u, 1175846950u, 1180041254u, 1175846994u, 1180041298u,
			1174798538u, 1175847114u, 1182138570u, 1174798539u, 1175847115u, 1175847120u, 1175847121u, 1182138598u, 1076078320u, 1076078320u,
			1076078320u, 1076078328u, 1076078328u, 1076078328u, 1076078304u, 1076078304u, 1076078304u, 1076078584u, 1076078584u, 1076078584u,
			1076078296u, 1076078296u, 1076078296u, 0u
		};
	}

	private static uint[] GetEncFlags3()
	{
		return new uint[4834]
		{
			196608u, 196608u, 196608u, 196608u, 196608u, 2031616u, 2031624u, 2031632u, 1966104u, 196608u,
			196616u, 196624u, 131096u, 196608u, 196616u, 196624u, 131096u, 65544u, 65552u, 65544u,
			65552u, 2031616u, 2031624u, 2031632u, 1966104u, 196608u, 196616u, 196624u, 131096u, 196608u,
			196616u, 196624u, 131096u, 65544u, 65552u, 65544u, 2031616u, 2031624u, 2031632u, 1966104u,
			196608u, 196616u, 196624u, 131096u, 196608u, 196616u, 196624u, 131096u, 65544u, 65552u,
			65544u, 65552u, 2031616u, 2031624u, 2031632u, 1966104u, 196608u, 196616u, 196624u, 131096u,
			196608u, 196616u, 196624u, 131096u, 65544u, 65552u, 65544u, 65552u, 2031616u, 2031624u,
			2031632u, 1966104u, 196608u, 196616u, 196624u, 131096u, 196608u, 196616u, 196624u, 131096u,
			65536u, 2031616u, 2031624u, 2031632u, 1966104u, 196608u, 196616u, 196624u, 131096u, 196608u,
			196616u, 196624u, 131096u, 65536u, 2031616u, 2031624u, 2031632u, 1966104u, 196608u, 196616u,
			196624u, 131096u, 196608u, 196616u, 196624u, 131096u, 65536u, 196608u, 196616u, 196624u,
			131096u, 196608u, 196616u, 196624u, 131096u, 196608u, 196616u, 196624u, 131096u, 65536u,
			65544u, 65552u, 65544u, 65552u, 196616u, 65552u, 135192u, 196616u, 65552u, 135192u,
			65544u, 65552u, 65544u, 65552u, 65544u, 65552u, 65544u, 65552u, 131080u, 131088u,
			131096u, 196616u, 65552u, 135192u, 196616u, 196624u, 131096u, 196616u, 65552u, 135192u,
			196616u, 196624u, 131096u, 2293760u, 2293768u, 2293776u, 2293760u, 2293768u, 2293776u, 25362440u,
			25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u,
			25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u,
			25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u,
			25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u,
			25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 2031616u, 2031616u, 2031616u,
			2031616u, 2031616u, 2031616u, 2031616u, 196608u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u,
			1966104u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u,
			2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 196616u, 196624u, 131096u, 1900544u,
			1900544u, 1900544u, 1900544u, 1900544u, 1900544u, 1900544u, 65536u, 2031624u, 2031632u, 1966104u,
			2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 2031624u,
			2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 196616u, 196624u,
			131096u, 196608u, 196616u, 196624u, 131096u, 2031616u, 2031624u, 2031632u, 1966104u, 1245184u,
			1245192u, 1245200u, 1179672u, 196608u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 65552u, 135192u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196608u, 196616u, 196624u, 131096u, 196616u,
			196624u, 131096u, 65544u, 65552u, 196608u, 196616u, 65552u, 135192u, 196616u, 65552u,
			135192u, 196608u, 196608u, 196608u, 196616u, 196624u, 131096u, 196608u, 196616u, 196624u,
			131096u, 2293760u, 2293768u, 2293776u, 2228248u, 6488064u, 6488072u, 6488080u, 6422552u, 196608u,
			196616u, 196624u, 131096u, 2293760u, 2293768u, 2293776u, 2228248u, 2293760u, 2293768u, 2293776u,
			2228248u, 6488064u, 6488072u, 6488080u, 6422552u, 196608u, 196616u, 196624u, 131096u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 8585224u, 8454160u, 8540184u, 8585224u, 8454160u, 8540184u, 65544u, 65552u, 65544u,
			65552u, 1245184u, 196608u, 1245192u, 1245200u, 1179672u, 196616u, 196624u, 196616u, 65552u,
			135192u, 196616u, 65552u, 135192u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196608u, 196608u, 65536u, 196616u, 196624u, 131096u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196616u, 196624u, 131096u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			65536u, 65536u, 65536u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196616u, 196624u, 196608u, 196616u, 229384u, 196624u, 229392u,
			196608u, 229376u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 229376u, 196608u, 229376u,
			196608u, 229376u, 196608u, 229376u, 196608u, 229376u, 65536u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196616u,
			196624u, 196616u, 229384u, 196624u, 229392u, 196608u, 229376u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 229376u, 98304u, 98304u, 196608u, 196608u, 65576u, 65584u, 196680u,
			65616u, 151640u, 131176u, 151672u, 65576u, 65584u, 196680u, 65616u, 151640u, 131176u,
			151672u, 65576u, 65584u, 196680u, 65616u, 151640u, 131176u, 151672u, 65576u, 65584u,
			196680u, 65616u, 151640u, 131176u, 151672u, 196608u, 196616u, 196624u, 196608u, 196616u,
			196624u, 8585224u, 8454160u, 8540184u, 8585224u, 8454160u, 8540184u, 65544u, 65552u, 196616u,
			65552u, 151576u, 196608u, 196616u, 196624u, 196608u, 196616u, 196624u, 196608u, 196608u,
			196608u, 196608u, 196608u, 2031616u, 2031616u, 196608u, 196608u, 196608u, 196608u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u,
			1966104u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 2031616u,
			2031616u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 42139656u, 42008592u, 42094616u,
			196616u, 196624u, 131096u, 42139656u, 42008592u, 42094616u, 196616u, 196624u, 131096u, 196616u,
			65552u, 135192u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			65544u, 65552u, 65544u, 65552u, 131072u, 65544u, 65552u, 131072u, 65544u, 65552u,
			131072u, 65544u, 65552u, 131072u, 196616u, 196624u, 131096u, 196608u, 196616u, 196624u,
			131096u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 65568u, 196672u,
			131168u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 65568u, 196672u, 131168u, 196608u, 65568u, 196672u, 131168u, 65568u, 196672u,
			131168u, 196608u, 196608u, 196608u, 65568u, 196672u, 131168u, 196608u, 196608u, 196608u,
			196608u, 131072u, 196608u, 65568u, 196672u, 131168u, 196608u, 196608u, 65568u, 196672u,
			131168u, 196608u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 65536u, 65536u,
			196608u, 196608u, 65536u, 196608u, 131096u, 196608u, 196608u, 196608u, 65536u, 196608u,
			196616u, 196624u, 131096u, 196608u, 196608u, 196608u, 196608u, 65536u, 65544u, 65552u,
			65536u, 65544u, 65552u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u, 1610809346u, 1610809602u,
			196608u, 196609u, 196609u, 1610809346u, 1610809730u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u,
			1610810114u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u,
			1610809346u, 537067778u, 196608u, 196609u, 196609u, 1610809346u, 537067906u, 196608u, 196608u, 196609u,
			196609u, 196610u, 196994u, 196608u, 196609u, 196994u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196609u, 196609u, 1610809730u, 1610809986u, 1610810114u, 196608u, 196609u,
			196994u, 196608u, 196609u, 196994u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u,
			196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919234u,
			1677919362u, 1677919490u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u,
			196610u, 196608u, 196609u, 196994u, 196608u, 196609u, 196994u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196994u, 196608u, 196609u, 196994u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196608u, 196608u, 196608u, 196608u, 196608u, 65536u, 131072u,
			65536u, 131072u, 65536u, 131072u, 196608u, 65536u, 131072u, 65536u, 131072u, 65536u,
			131072u, 196608u, 196608u, 131096u, 196608u, 196608u, 196616u, 196624u, 131096u, 65536u,
			131072u, 65536u, 131072u, 65536u, 131072u, 65536u, 131072u, 65536u, 65536u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u,
			1610810114u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196608u, 131096u, 196609u, 131073u, 134414594u,
			134349186u, 196608u, 131096u, 196609u, 131073u, 134414594u, 134349186u, 196608u, 196609u, 196609u,
			197122u, 197250u, 197378u, 196608u, 196609u, 196609u, 197122u, 197250u, 197378u, 196608u,
			196608u, 196608u, 196608u, 196608u, 131096u, 196609u, 131073u, 268632322u, 268566786u, 196608u,
			131096u, 196609u, 131073u, 268632450u, 268566914u, 196608u, 196608u, 196608u, 131096u, 196609u,
			131073u, 134414594u, 134349058u, 196608u, 131096u, 196609u, 131073u, 134414722u, 134349186u, 196608u,
			196609u, 268632322u, 196608u, 196609u, 268632450u, 196608u, 196608u, 196609u, 196609u, 268632322u,
			268632450u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 131096u, 196608u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196608u, 131096u,
			196609u, 131073u, 196609u, 131073u, 196608u, 131096u, 196609u, 131073u, 196609u, 131073u,
			196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 196608u, 196609u, 196609u, 1677919618u,
			1677919746u, 1812137602u, 196608u, 196609u, 1745027330u, 196608u, 196609u, 1745027458u, 196608u, 196609u,
			196609u, 196608u, 196609u, 196608u, 196609u, 196609u, 196608u, 196609u, 196608u, 196609u,
			196609u, 1677919234u, 1677919362u, 1677919490u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u,
			196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196608u, 196609u, 196609u, 1677919618u,
			1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196608u, 196609u,
			196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u,
			196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919234u,
			1677919362u, 1812137218u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1812137602u, 196608u, 196609u,
			1745027330u, 196608u, 196609u, 1745027458u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u,
			196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1812137602u, 196608u, 196609u, 1745027330u, 196608u,
			196609u, 1745027458u, 196608u, 196609u, 196609u, 1677919106u, 1677919234u, 1946354818u, 196608u, 196609u,
			196609u, 1677919618u, 1677919746u, 1812137602u, 196608u, 196609u, 1879245058u, 196608u, 196609u, 1745027458u,
			196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196608u,
			196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u,
			1946354946u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 196608u, 196609u, 196609u,
			1677919618u, 1677919746u, 1812137602u, 196608u, 196609u, 1745027330u, 196608u, 196609u, 1745027458u, 196608u,
			196609u, 196609u, 1677919234u, 1677919362u, 1946354946u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u,
			1946355330u, 196608u, 196609u, 1879245058u, 196608u, 196609u, 1879245186u, 196608u, 196609u, 196609u,
			1677919234u, 1677919362u, 1812137218u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1812137602u, 196608u,
			196609u, 1745027330u, 196608u, 196609u, 1745027458u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u,
			1946354946u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1946355330u, 196608u, 196609u, 1879245058u,
			196608u, 196609u, 1879245186u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u,
			196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u,
			196609u, 1677919234u, 1677919362u, 1677919490u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u,
			1610810114u, 196608u, 196608u, 196609u, 196609u, 537068034u, 537068162u, 537068290u, 196608u, 196608u,
			196609u, 196609u, 537068034u, 537068162u, 537068290u, 196608u, 196608u, 196609u, 196609u, 604177410u,
			604177538u, 604177666u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u,
			196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u,
			196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196608u, 196609u, 196609u,
			1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u,
			131096u, 196608u, 131096u, 196609u, 131073u, 196866u, 131458u, 196608u, 196608u, 196609u,
			196609u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u,
			1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1677919234u, 1677919362u,
			1677919490u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u,
			1677919490u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u,
			1677919874u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196608u, 196608u,
			196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 197122u, 197250u,
			197378u, 196608u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u,
			196609u, 197122u, 197250u, 197378u, 196608u, 196608u, 196609u, 196609u, 537068034u, 537068162u,
			537068290u, 196608u, 196608u, 196609u, 196609u, 537068034u, 537068162u, 537068290u, 196608u, 196608u,
			196609u, 196609u, 604177410u, 604177538u, 604177666u, 196608u, 196609u, 196609u, 65536u, 131072u,
			1677919234u, 1677919362u, 1946354946u, 1677919618u, 1677919746u, 1946355330u, 196608u, 1677919106u, 1677919234u, 1946354818u,
			1677919618u, 1677919746u, 1946355330u, 268632322u, 268566786u, 196608u, 268632450u, 268566914u, 65536u, 131072u,
			1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196608u, 1677919106u, 1677919234u, 1812137090u,
			1677919618u, 1677919746u, 1812137602u, 134414594u, 134349058u, 196608u, 134414722u, 134349186u, 1677919106u, 1677919234u,
			1946354818u, 1677919618u, 1677919746u, 1946355330u, 1677919106u, 1677919234u, 1812137090u, 1677919618u, 1677919746u, 1812137602u,
			1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 1677919106u, 1677919234u, 1812137090u, 1677919618u,
			1677919746u, 1812137602u, 134414594u, 134349186u, 134414594u, 134349186u, 196608u, 196609u, 196609u, 196608u,
			196609u, 196609u, 196608u, 196609u, 196609u, 196608u, 196609u, 196609u, 196608u, 131096u,
			196608u, 131096u, 196609u, 131073u, 196866u, 131458u, 196608u, 196609u, 196994u, 196608u,
			196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u,
			1610810114u, 1610809858u, 1610809986u, 1610810114u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u,
			25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u,
			25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u,
			25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u,
			25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u, 25231376u, 25317400u, 25362440u,
			25231376u, 25317400u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 131073u,
			196609u, 196609u, 196609u, 131073u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196616u, 65552u, 135192u, 196616u, 65552u, 135192u, 196608u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 65568u, 196672u,
			131168u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u, 65544u, 65552u, 2162720u,
			2293824u, 2228320u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u, 65568u, 196672u,
			131168u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u, 65544u, 65552u, 65536u,
			65544u, 65552u, 196616u, 65552u, 135192u, 196616u, 65552u, 135192u, 196608u, 2031624u,
			2031632u, 1966104u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196608u, 131096u,
			131072u, 131096u, 196608u, 131096u, 131072u, 131096u, 196608u, 131072u, 131096u, 196609u,
			196608u, 131072u, 131096u, 196609u, 196608u, 131096u, 196608u, 131096u, 196608u, 131096u,
			196608u, 131096u, 196608u, 131096u, 196608u, 196608u, 131096u, 196608u, 65568u, 196672u,
			131168u, 196608u, 131096u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196616u, 196624u, 131096u, 2031616u, 2031624u, 2031632u, 1966104u, 196616u, 196624u, 131096u,
			2031624u, 2031632u, 1966104u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u,
			196624u, 131096u, 196616u, 196624u, 131096u, 65544u, 65552u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 2031624u, 2031632u, 1966104u, 2031624u,
			2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 2031624u, 2031632u, 1966104u, 196616u, 196624u,
			131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u, 131096u,
			196616u, 196624u, 131096u, 196616u, 196624u, 131096u, 2031616u, 2031624u, 2031632u, 1966104u,
			196608u, 196609u, 196609u, 604177410u, 604177538u, 872613122u, 196608u, 196609u, 196609u, 604177794u,
			604177922u, 872613506u, 196608u, 196609u, 805503234u, 196608u, 196609u, 805503362u, 196608u, 131096u,
			196608u, 131096u, 196608u, 131096u, 196609u, 131073u, 196738u, 131202u, 196608u, 131096u,
			196608u, 131096u, 196609u, 131073u, 196610u, 131074u, 196608u, 196609u, 196609u, 1677919234u,
			1677919362u, 1677919490u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 2031616u, 393240u,
			196608u, 131096u, 196608u, 131096u, 196608u, 131096u, 196608u, 196608u, 196608u, 196616u,
			196624u, 131096u, 196608u, 196616u, 196624u, 131096u, 65536u, 131072u, 196616u, 196624u,
			131096u, 196608u, 196609u, 196609u, 196608u, 196609u, 196609u, 196608u, 196608u, 196609u,
			196609u, 1610809858u, 1610809858u, 1610809858u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809858u,
			1610809858u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809858u, 1610809858u, 196608u, 196608u,
			196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196609u, 196994u, 196608u, 196608u, 196608u, 131096u, 196608u,
			131096u, 196609u, 131073u, 196609u, 131073u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u,
			196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u,
			1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u,
			196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u,
			196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196608u, 196609u,
			196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809858u,
			1610809858u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809858u, 1610809858u, 1610809858u, 1610809858u,
			1610809858u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1946355330u, 196608u, 196609u,
			196609u, 1677919106u, 1677919234u, 1812137090u, 1677919618u, 1677919746u, 1812137602u, 196608u, 196609u, 196609u,
			1677919618u, 1677919746u, 1812137602u, 196608u, 196608u, 196609u, 196609u, 197122u, 197250u, 197378u,
			196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u,
			196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u,
			1610810114u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u,
			1677919874u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u,
			1677919746u, 1677919874u, 196608u, 196609u, 196609u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809858u, 1610809858u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809858u, 1610809858u, 196608u,
			196608u, 196609u, 196609u, 1610809858u, 1610809858u, 1610809858u, 196608u, 196608u, 196609u, 196609u,
			1677919618u, 1677919746u, 1677919874u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u,
			196608u, 196608u, 196609u, 196609u, 197122u, 197250u, 197378u, 196608u, 196608u, 196609u,
			196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u,
			196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u,
			1677919490u, 196608u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196608u,
			196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196616u,
			196624u, 131096u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u,
			196608u, 196609u, 196609u, 196608u, 196608u, 196609u, 196609u, 196608u, 196608u, 196609u,
			196609u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196608u,
			196609u, 196609u, 196608u, 196608u, 196609u, 196609u, 196608u, 196608u, 196609u, 196609u,
			196608u, 196608u, 196609u, 196609u, 196608u, 196608u, 196609u, 196609u, 196608u, 196608u,
			196609u, 196609u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196609u,
			196609u, 1677919234u, 1677919362u, 1677919490u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196609u,
			196609u, 196609u, 196609u, 196608u, 1610809858u, 1610809986u, 1610810114u, 1610809730u, 1610809858u, 1610809986u,
			1610809858u, 1610809986u, 1610810114u, 1610809602u, 1610809730u, 1610809858u, 1610809858u, 1610809986u, 1610810114u, 1610809474u,
			1610809602u, 1610809730u, 196609u, 196609u, 1610809730u, 1610809858u, 1879245442u, 1610809730u, 1610809858u, 1610809986u,
			196608u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1610809602u, 1610809730u, 1610809858u,
			196608u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1610809730u, 1610809858u, 1610809986u,
			196609u, 1677919362u, 1677919490u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 196609u, 196609u,
			1610809602u, 1610809602u, 1610809602u, 196609u, 1610809730u, 1610809730u, 1610809730u, 1610809730u, 196609u, 1610809858u,
			1610809858u, 1610809858u, 1610809858u, 1610809986u, 1610809986u, 196608u, 196608u, 196609u, 196609u, 1610809858u,
			1610809986u, 1610810114u, 196608u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u,
			196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196608u,
			196609u, 196609u, 1610809730u, 1610809858u, 1610809986u, 1610809730u, 1610809858u, 1610809986u, 196608u, 196609u,
			196609u, 1610809602u, 1610809730u, 1610809858u, 1610809602u, 1610809730u, 1610809858u, 196608u, 196609u, 196609u,
			1610809474u, 1610809602u, 1610809730u, 1610809474u, 1610809602u, 1610809730u, 196608u, 196609u, 196609u, 1610809730u,
			1610809858u, 1610809986u, 1610809730u, 1610809858u, 1610809986u, 196608u, 196609u, 196609u, 1610809602u, 1610809730u,
			1610809858u, 1610809602u, 1610809730u, 1610809858u, 196608u, 196609u, 196609u, 1610809730u, 1610809858u, 1610809986u,
			1610809730u, 1610809858u, 1610809986u, 537068034u, 537068162u, 537068290u, 537068034u, 537068162u, 537068290u, 537068034u,
			537068162u, 537068290u, 537068034u, 537068162u, 537068290u, 604177410u, 604177538u, 604177666u, 604177794u, 604177922u,
			604178050u, 604177410u, 604177538u, 604177666u, 604177794u, 604177922u, 604178050u, 196608u, 196609u, 196609u,
			1677919618u, 1677919746u, 1677919874u, 196610u, 196610u, 196610u, 196610u, 196610u, 196610u, 196608u,
			196609u, 196609u, 604177794u, 604177922u, 604178050u, 196610u, 196610u, 196610u, 196610u, 196610u,
			196610u, 196608u, 196609u, 196609u, 197122u, 197250u, 197378u, 196610u, 196610u, 196610u,
			196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 196609u, 196609u, 1677919234u, 1677919362u,
			1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u, 1745027330u, 1745027458u, 196609u, 196609u,
			196609u, 196609u, 196608u, 196609u, 196609u, 1610809730u, 1610809858u, 1610809986u, 1610809730u, 1610809858u,
			1610809986u, 196608u, 196609u, 196609u, 1610809602u, 1610809730u, 1610809858u, 1610809602u, 1610809730u, 1610809858u,
			196608u, 196609u, 196609u, 1610809474u, 1610809602u, 1610809730u, 1610809474u, 1610809602u, 1610809730u, 196608u,
			196609u, 196609u, 1610809730u, 1610809858u, 1610809986u, 1610809730u, 1610809858u, 1610809986u, 196608u, 196609u,
			196609u, 1610809602u, 1610809730u, 1610809858u, 1610809602u, 1610809730u, 1610809858u, 196608u, 196609u, 196609u,
			1610809730u, 1610809858u, 1610809986u, 1610809730u, 1610809858u, 1610809986u, 196609u, 1677919362u, 1677919490u, 1677919746u,
			1677919874u, 196608u, 196609u, 196609u, 604177794u, 604177922u, 604178050u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196610u, 196610u, 196610u, 196610u, 196610u, 196610u, 196608u,
			196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196610u, 196610u,
			196610u, 196610u, 196610u, 196610u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u,
			196610u, 196610u, 196610u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u,
			1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u,
			196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u,
			1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u,
			1677919874u, 196608u, 196609u, 1677919234u, 1677919362u, 1946354946u, 1677919618u, 1677919746u, 1946355330u, 1879245058u,
			1879245186u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196609u, 196609u,
			196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196609u, 1677919234u,
			1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196609u, 196609u, 196609u, 1677919234u,
			1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u,
			1677919874u, 1610809602u, 1610809730u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1610809602u,
			1610809730u, 1677919234u, 1677919362u, 1677919490u, 1677919234u, 1677919362u, 1677919490u, 1677919234u, 1677919362u, 1677919490u,
			1677919234u, 1677919362u, 1677919490u, 1610809858u, 1677919234u, 1677919362u, 1677919490u, 1610809858u, 1610809858u, 1610809986u,
			1610810114u, 1610809858u, 1610809986u, 1610810114u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u,
			196609u, 196609u, 1610809602u, 1610809602u, 1610809602u, 196609u, 196609u, 1610809730u, 1610809730u, 1610809730u,
			1610809730u, 1610809730u, 1610809730u, 196609u, 1610809858u, 1610809858u, 1610809858u, 1610809858u, 1610809986u, 1610809986u,
			1610809346u, 1610809346u, 1610809346u, 1610809474u, 1610809474u, 1610809474u, 1610809346u, 1610809346u, 1610809346u, 1610809474u,
			1610809474u, 1610809474u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1677919234u, 1677919362u,
			1677919490u, 1677919618u, 1677919746u, 1677919874u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u,
			67306498u, 67306626u, 67306754u, 67306882u, 67307010u, 67307138u, 1610809858u, 1610809986u, 1610810114u, 1677919234u,
			1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 1610809858u, 1610809986u, 1610810114u, 1677919234u, 1677919362u,
			1677919490u, 1677919234u, 1677919362u, 1677919490u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u,
			1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 1677919234u, 1677919362u, 1677919490u, 1677919618u,
			1677919746u, 1677919874u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196609u,
			1610809346u, 1610809346u, 1610809346u, 196609u, 196609u, 1610809474u, 1610809474u, 1610809474u, 1610809346u, 1610809346u,
			1610809346u, 1610809346u, 1610809346u, 1610809346u, 1610809346u, 1610809346u, 1610809346u, 1610743810u, 1610743810u, 1610743810u,
			1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u, 1610810114u, 1677919234u, 1677919362u, 1677919490u, 1677919618u,
			1677919746u, 1677919874u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 65536u, 131072u,
			65536u, 131072u, 65536u, 131072u, 1677919618u, 1677919746u, 1677919874u, 1610809602u, 1610809602u, 1610809602u,
			1610809730u, 1610809730u, 1610809730u, 1610809602u, 1610809602u, 1610809602u, 1610809730u, 1610809730u, 1610809730u, 1610809602u,
			1610809602u, 1610809602u, 1610809730u, 1610809730u, 1610809730u, 1610809602u, 1610809602u, 1610809602u, 1610809730u, 1610809730u,
			1610809730u, 196609u, 196609u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 1610809858u, 1610809986u,
			1610810114u, 196609u, 196609u, 196609u, 196609u, 537068034u, 537068162u, 537068290u, 196609u, 196609u,
			196609u, 196609u, 2684551426u, 2684551426u, 2684551426u, 2684551554u, 2684551554u, 2684551554u, 196609u, 196609u,
			196609u, 196609u, 2684551426u, 2684551426u, 2684551426u, 2684551554u, 2684551554u, 2684551554u, 196609u, 196609u,
			196609u, 196609u, 2684551426u, 2684551426u, 2684551426u, 2684551554u, 2684551554u, 2684551554u, 196609u, 196609u,
			196609u, 196609u, 2684551426u, 2684551426u, 2684551426u, 2684551554u, 2684551554u, 2684551554u, 196609u, 196609u,
			196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u,
			196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u,
			196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u,
			1745027330u, 1745027458u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u,
			1677919746u, 1812137602u, 1610809858u, 196609u, 196609u, 1745027330u, 1745027458u, 1610809858u, 196609u, 196609u,
			196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u,
			1745027330u, 1745027458u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u,
			1677919746u, 1812137602u, 196609u, 196609u, 1745027330u, 1745027458u, 2684551426u, 2684551426u, 2684551426u, 2684551554u,
			2684551554u, 2684551554u, 2684551426u, 2684551426u, 2684551426u, 2684551554u, 2684551554u, 2684551554u, 2684551426u, 2684551426u,
			2684551426u, 2684551554u, 2684551554u, 2684551554u, 2684551426u, 2684551426u, 2684551426u, 2684551554u, 2684551554u, 2684551554u,
			196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u,
			196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u,
			196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u,
			196609u, 196609u, 1745027330u, 1745027458u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u,
			1812137218u, 1677919618u, 1677919746u, 1812137602u, 1610809858u, 196609u, 196609u, 1745027330u, 1745027458u, 1610809858u,
			196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u,
			196609u, 196609u, 1745027330u, 1745027458u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u,
			1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u, 1745027330u, 1745027458u, 1677919618u, 1677919746u,
			1677919874u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u,
			1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u,
			1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u,
			1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u, 1745027330u, 1745027458u, 196609u, 196609u,
			196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u,
			1745027330u, 1745027458u, 196609u, 196609u, 196609u, 196609u, 1677919234u, 1677919362u, 1812137218u, 1677919618u,
			1677919746u, 1812137602u, 196609u, 196609u, 1745027330u, 1745027458u, 196609u, 196609u, 196609u, 196609u,
			1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 196609u, 196609u, 1745027330u, 1745027458u,
			1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 2684551426u, 2684551554u, 2684551426u, 2684551554u,
			2684551426u, 2684551554u, 2684551426u, 2684551554u, 2684551426u, 2684551554u, 2684551426u, 2684551554u, 2684551426u, 2684551554u,
			2684551426u, 2684551554u, 196608u, 1946354946u, 1946355330u, 196608u, 196608u, 1946354946u, 1946355330u, 196608u,
			1879245058u, 1879245186u, 196608u, 1946354946u, 1946355330u, 196608u, 1879245058u, 1879245186u, 196608u, 196609u,
			196609u, 1610809858u, 1610809986u, 1610810114u, 196608u, 196609u, 196608u, 196609u, 196609u, 197122u,
			197250u, 197378u, 196608u, 196609u, 196609u, 197122u, 197250u, 197378u, 196608u, 196609u,
			196609u, 197122u, 197250u, 197378u, 196608u, 196609u, 196609u, 197122u, 197250u, 197378u,
			196616u, 196624u, 131096u, 196608u, 131096u, 196616u, 196624u, 131096u, 196616u, 196624u,
			131096u, 196609u, 131073u, 196609u, 131073u, 196609u, 131073u, 196609u, 131073u, 196609u,
			131073u, 196608u, 131096u, 196609u, 131073u, 196609u, 131073u, 196608u, 131096u, 196608u,
			131096u, 196608u, 131096u, 196609u, 131073u, 196609u, 131073u, 196609u, 131073u, 196609u,
			131073u, 196609u, 131073u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u, 65568u,
			196672u, 131168u, 196608u, 131096u, 196609u, 1677919746u, 1677919874u, 196609u, 1677919746u, 1677919874u,
			196609u, 196609u, 1677919234u, 1677919362u, 1677919490u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196609u,
			1677919234u, 1677919362u, 1677919490u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u, 196609u, 196608u,
			196609u, 196609u, 1677919234u, 1677919362u, 1946354946u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u,
			1946355330u, 196608u, 196609u, 1879245058u, 196608u, 196609u, 1879245186u, 196608u, 196609u, 196609u,
			196608u, 196609u, 196609u, 196608u, 196609u, 196609u, 196608u, 196608u, 196609u, 196609u,
			1610809858u, 1610809986u, 1610810114u, 196608u, 131096u, 196609u, 131073u, 196610u, 131074u, 196608u,
			131096u, 196609u, 131073u, 196738u, 131202u, 196608u, 131096u, 196609u, 131073u, 196866u,
			131458u, 196608u, 131096u, 196609u, 131073u, 196866u, 131330u, 196609u, 1610809858u, 1610809858u,
			1610809858u, 1610809858u, 196609u, 1610809858u, 1610809858u, 1610809858u, 1610809858u, 1610809986u, 1610809986u, 1610809986u,
			1610809986u, 196609u, 196609u, 1610809730u, 1610809858u, 1879245442u, 604177410u, 604177538u, 604177666u, 604177794u,
			604177922u, 604178050u, 604177410u, 604177538u, 604177666u, 604177794u, 604177922u, 604178050u, 196608u, 131096u,
			196609u, 131073u, 196610u, 131074u, 196608u, 196609u, 196866u, 196608u, 131096u, 196609u,
			131073u, 196866u, 131458u, 1677919362u, 1677919490u, 1677919746u, 1677919874u, 1677919234u, 1677919362u, 1677919490u,
			1677919618u, 1677919746u, 1677919874u, 1677919234u, 1677919362u, 1946354946u, 1677919618u, 1677919746u, 1946355330u, 1879245058u,
			1879245186u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			1610809858u, 1610809858u, 1610809858u, 1610809858u, 196609u, 1610809858u, 1610809858u, 1610809858u, 1610809858u, 1610809986u,
			1610809986u, 1610809986u, 1610809986u, 537068034u, 537068162u, 537068290u, 537068034u, 537068162u, 537068290u, 537068034u,
			537068162u, 537068290u, 537068034u, 537068162u, 537068290u, 196608u, 196609u, 196609u, 196608u, 196609u,
			196608u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 1677919362u, 1677919490u, 1677919746u, 1677919874u,
			196608u, 196609u, 196609u, 197122u, 197250u, 197378u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 1677919234u, 1677919362u, 1946354946u, 1677919618u, 1677919746u, 1946355330u, 1879245058u, 1879245186u, 1677919234u,
			1677919362u, 1946354946u, 1677919618u, 1677919746u, 1946355330u, 1879245058u, 1879245186u, 1677919234u, 1677919362u, 1946354946u,
			1677919618u, 1677919746u, 1946355330u, 1879245058u, 1879245186u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196608u, 131096u, 196609u, 131073u, 196608u, 131096u, 196609u, 131073u, 196608u,
			196609u, 196608u, 196609u, 604177410u, 604177538u, 604177666u, 604177794u, 604177922u, 604178050u, 537067778u,
			537067906u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 1610809858u, 1610809986u, 1610810114u, 1677919234u, 1677919362u,
			1677919490u, 1677919618u, 1677919746u, 1677919874u, 1610809858u, 1610809986u, 1610810114u, 1677919234u, 1677919362u, 1677919490u,
			1677919618u, 1677919746u, 1677919874u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u, 196608u, 196608u, 196609u,
			196609u, 1677919618u, 1677919746u, 1677919874u, 196608u, 196609u, 196609u, 1677919618u, 1677919746u, 1677919874u,
			196608u, 196609u, 196609u, 131073u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 131075u, 196611u, 131075u, 196611u, 131075u,
			196611u, 131075u, 196611u, 131075u, 196611u, 131075u, 196611u, 131075u, 196611u, 131075u,
			196611u, 131075u, 196611u, 131075u, 196611u, 131075u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u, 196611u,
			196611u, 196611u, 131075u, 196611u, 131075u, 196611u, 131075u, 196612u, 196612u, 196612u,
			196612u, 65540u, 65540u, 196612u, 196612u, 196612u, 196612u, 196612u, 196612u, 196612u,
			196612u, 196612u, 196612u, 196612u, 196612u, 196612u, 196612u, 196612u, 196612u, 196612u,
			196612u, 196612u, 196612u, 131072u, 131072u, 131072u, 65568u, 196672u, 131168u, 196608u,
			196608u, 196608u, 65568u, 196672u, 131168u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 131096u, 131073u, 131073u, 131073u, 139265u, 131073u, 131073u,
			131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 65536u, 65536u, 65536u, 65536u,
			65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u,
			65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u,
			65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u,
			65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 65536u, 196608u,
			131072u, 131072u, 131072u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u, 196608u,
			196608u, 196608u, 196608u, 196608u, 196609u, 196609u, 196609u, 196608u, 131072u, 131072u,
			131072u, 131072u, 131072u, 196608u, 196609u, 196609u, 196609u, 196609u, 196609u, 196609u,
			196609u, 196609u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u, 131080u, 131088u,
			131096u, 131072u, 131072u, 1677920258u, 1677920386u, 1812138242u, 1745027202u, 604178434u, 604178562u, 872614146u,
			805503106u, 268632194u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 1677920130u, 1677920258u,
			1812138114u, 1677920002u, 1677920130u, 1946355714u, 1677920130u, 1677920258u, 1946355842u, 1677920002u, 1677920130u, 1812137986u,
			1677920130u, 1677920258u, 1812138114u, 1677920002u, 1677920130u, 1812137986u, 1677920258u, 1677920386u, 1812138242u, 1677920258u,
			1677920386u, 1812138242u, 1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 1745027458u, 1879244930u,
			134414466u, 134348930u, 1879244930u, 134414466u, 134348930u, 134414594u, 134349186u, 1745027330u, 1677920130u, 1677920258u,
			1946355842u, 1677920002u, 1677920130u, 1946355714u, 1677920130u, 1677920258u, 1946355842u, 1677920002u, 1677920130u, 1946355714u,
			1677920258u, 1677920386u, 1946355970u, 1677920258u, 1677920386u, 1946355970u, 268632194u, 268566658u, 268632194u, 268566658u,
			1677919234u, 1677919362u, 1812137218u, 1677919618u, 1677919746u, 1812137602u, 134414594u, 134349186u, 1677920258u, 1677920386u,
			1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1745027202u, 1677919234u, 1677919362u,
			1812137218u, 1677919234u, 1677919362u, 1812137218u, 1745027330u, 1745027330u, 1677919234u, 1677919362u, 1812137218u, 1677919234u,
			1677919362u, 1812137218u, 1745027330u, 1745027330u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u,
			1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u,
			1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u,
			1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u,
			1745027202u, 1745027202u, 1745027202u, 1745027202u, 1745027202u, 1745027202u, 1677920258u, 1677920386u, 1812138242u, 1677920258u,
			1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u, 1812138242u, 1677920258u, 1677920386u,
			1812138242u, 1677920258u, 1677920386u, 1812138242u, 1745027202u, 1745027202u, 1745027202u, 1745027202u, 1745027202u, 1745027202u,
			604178434u, 604178562u, 604178690u, 537067650u, 1677920258u, 1677920386u, 1946355970u, 1879244930u, 1677920258u, 1677920386u,
			1946355970u, 1879244930u, 1677920258u, 1677920386u, 1946355970u, 1879244930u, 1677920258u, 1677920386u, 1946355970u, 1879244930u,
			1610809474u, 537067650u, 1610809346u, 1610809346u, 196738u, 131202u, 196738u, 131202u, 1677920258u, 1677920386u,
			1812138242u, 1745027202u, 1677920258u, 1677920386u, 1677920514u, 1610809474u, 1677920258u, 1677920386u, 1946355970u, 1879244930u,
			1677920258u, 1677920386u, 1946355970u, 1879244930u, 1677920258u, 1677920386u, 1677920514u, 1610809474u, 1677920258u, 1677920386u,
			1812138242u, 1745027202u, 1677920258u, 1677920386u, 1812138242u, 1745027202u, 1677920258u, 1677920386u, 1812138242u, 1745027202u,
			268632194u, 196608u, 196608u, 151553u, 151553u, 131073u, 131073u, 131073u, 131073u, 131073u,
			131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u,
			131073u, 131073u, 151553u, 151553u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u,
			131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u,
			131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u, 131073u,
			131073u, 131077u, 131077u, 131077u, 131077u, 131077u, 131077u, 131077u, 131077u, 537001989u,
			537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 939655173u, 939655173u, 939655173u,
			939655173u, 805437445u, 939655173u, 939655173u, 939655173u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u,
			537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 131077u, 131077u, 805437445u, 805437445u,
			537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u,
			537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u,
			537001989u, 537001989u, 805437445u, 805437445u, 537001989u, 537001989u, 537001989u, 939655173u, 939655173u, 939655173u,
			939655173u, 939655173u, 939655173u, 805437445u, 805437445u, 805437445u, 805437445u, 805437445u, 939655173u, 805437445u,
			805437445u, 939655173u, 939655173u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u,
			537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u,
			537001989u, 939655173u, 939655173u, 537001989u, 537001989u, 939655173u, 939655173u, 939655173u, 939655173u, 537001989u,
			939655173u, 537001989u, 537001989u, 2684485637u, 2684485637u, 2684485637u, 2684485637u, 939655173u, 939655173u, 939655173u,
			939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 2684485637u, 2684485637u, 2684485637u,
			2684485637u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u,
			3087138821u, 3087138821u, 537001989u, 537001989u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u,
			939655173u, 939655173u, 3087138821u, 2684485637u, 2684485637u, 2684485637u, 2684485637u, 2684485637u, 2684485637u, 2684485637u,
			2684485637u, 805437445u, 805437445u, 805437445u, 805437445u, 3087138821u, 2684485637u, 939655173u, 939655173u, 939655173u,
			537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 939655173u, 939655173u,
			939655173u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 537001989u, 939655173u,
			939655173u, 939655173u, 537001989u, 537001989u, 537001989u, 537001989u, 805437445u, 805437445u, 939655173u, 939655173u,
			939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 939655173u, 65568u, 196672u,
			131168u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u, 65568u, 196672u, 131168u,
			65568u, 196672u, 131168u, 196608u
		};
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal delegate bool TryConvertToDisp8N(Encoder encoder, OpCodeHandler handler, in Instruction instruction, int displ, out sbyte compressedValue);


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal abstract class OpCodeHandler
{
	internal readonly uint OpCode;

	internal readonly bool Is2ByteOpCode;

	internal readonly int GroupIndex;

	internal readonly int RmGroupIndex;

	internal readonly bool IsSpecialInstr;

	internal readonly EncFlags3 EncFlags3;

	internal readonly CodeSize OpSize;

	internal readonly CodeSize AddrSize;

	internal readonly TryConvertToDisp8N? TryConvertToDisp8N;

	internal readonly Op[] Operands;

	protected OpCodeHandler(EncFlags2 encFlags2, EncFlags3 encFlags3, bool isSpecialInstr, TryConvertToDisp8N? tryConvertToDisp8N, Op[] operands)
	{
		EncFlags3 = encFlags3;
		OpCode = GetOpCode(encFlags2);
		Is2ByteOpCode = (encFlags2 & EncFlags2.OpCodeIs2Bytes) != 0;
		GroupIndex = ((((uint)encFlags2 & 0x80000000u) == 0) ? (-1) : ((int)(((uint)encFlags2 >> 27) & 7)));
		RmGroupIndex = (((encFlags3 & EncFlags3.HasRmGroupIndex) == 0) ? (-1) : ((int)(((uint)encFlags2 >> 27) & 7)));
		IsSpecialInstr = isSpecialInstr;
		OpSize = (CodeSize)(((uint)encFlags3 >> 3) & 3);
		AddrSize = (CodeSize)(((uint)encFlags3 >> 5) & 3);
		TryConvertToDisp8N = tryConvertToDisp8N;
		Operands = operands;
	}

	protected static uint GetOpCode(EncFlags2 encFlags2)
	{
		return (ushort)encFlags2;
	}

	public abstract void Encode(Encoder encoder, in Instruction instruction);
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class InvalidHandler : OpCodeHandler
{
	internal const string ERROR_MESSAGE = "Can't encode an invalid instruction";

	public InvalidHandler()
		: base(EncFlags2.None, EncFlags3.Bit16or32 | EncFlags3.Bit64, isSpecialInstr: false, null, Array2.Empty<Op>())
	{
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		encoder.ErrorMessage = "Can't encode an invalid instruction";
	}
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class DeclareDataHandler : OpCodeHandler
{
	private readonly int elemLength;

	private readonly int maxLength;

	public DeclareDataHandler(Code code)
		: base(EncFlags2.None, EncFlags3.Bit16or32 | EncFlags3.Bit64, isSpecialInstr: true, null, Array2.Empty<Op>())
	{
		elemLength = code switch
		{
			Code.DeclareByte => 1, 
			Code.DeclareWord => 2, 
			Code.DeclareDword => 4, 
			Code.DeclareQword => 8, 
			_ => throw new InvalidOperationException(), 
		};
		maxLength = 16 / elemLength;
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		int declareDataCount = instruction.DeclareDataCount;
		if (declareDataCount < 1 || declareDataCount > maxLength)
		{
			encoder.ErrorMessage = $"Invalid db/dw/dd/dq data count. Count = {declareDataCount}, max count = {maxLength}";
		}
		else
		{
			int num = declareDataCount * elemLength;
			for (int i = 0; i < num; i++)
			{
				encoder.WriteByteInternal(instruction.GetDeclareByteValue(i));
			}
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class ZeroBytesHandler : OpCodeHandler
{
	public ZeroBytesHandler(Code code)
		: base(EncFlags2.None, EncFlags3.Bit16or32 | EncFlags3.Bit64, isSpecialInstr: true, null, Array2.Empty<Op>())
	{
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
	}
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class LegacyHandler : OpCodeHandler
{
	private readonly uint tableByte1;

	private readonly uint tableByte2;

	private readonly uint mandatoryPrefix;

	private static Op[] CreateOps(EncFlags1 encFlags1)
	{
		int num = (int)(encFlags1 & EncFlags1.Legacy_OpMask);
		int num2 = (int)(((uint)encFlags1 >> 7) & 0x7F);
		int num3 = (int)(((uint)encFlags1 >> 14) & 0x7F);
		int num4 = (int)(((uint)encFlags1 >> 21) & 0x7F);
		if (num4 != 0)
		{
			return new Op[4]
			{
				OpHandlerData.LegacyOps[num - 1],
				OpHandlerData.LegacyOps[num2 - 1],
				OpHandlerData.LegacyOps[num3 - 1],
				OpHandlerData.LegacyOps[num4 - 1]
			};
		}
		if (num3 != 0)
		{
			return new Op[3]
			{
				OpHandlerData.LegacyOps[num - 1],
				OpHandlerData.LegacyOps[num2 - 1],
				OpHandlerData.LegacyOps[num3 - 1]
			};
		}
		if (num2 != 0)
		{
			return new Op[2]
			{
				OpHandlerData.LegacyOps[num - 1],
				OpHandlerData.LegacyOps[num2 - 1]
			};
		}
		if (num != 0)
		{
			return new Op[1] { OpHandlerData.LegacyOps[num - 1] };
		}
		return Array2.Empty<Op>();
	}

	public LegacyHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
		: base(encFlags2, encFlags3, isSpecialInstr: false, null, CreateOps(encFlags1))
	{
		switch ((LegacyOpCodeTable)(((uint)encFlags2 >> 17) & 7))
		{
		case LegacyOpCodeTable.MAP0:
			tableByte1 = 0u;
			tableByte2 = 0u;
			break;
		case LegacyOpCodeTable.MAP0F:
			tableByte1 = 15u;
			tableByte2 = 0u;
			break;
		case LegacyOpCodeTable.MAP0F38:
			tableByte1 = 15u;
			tableByte2 = 56u;
			break;
		case LegacyOpCodeTable.MAP0F3A:
			tableByte1 = 15u;
			tableByte2 = 58u;
			break;
		default:
			throw new InvalidOperationException();
		}
		mandatoryPrefix = (MandatoryPrefixByte)(((uint)encFlags2 >> 20) & 3) switch
		{
			MandatoryPrefixByte.None => 0u, 
			MandatoryPrefixByte.P66 => 102u, 
			MandatoryPrefixByte.PF3 => 243u, 
			MandatoryPrefixByte.PF2 => 242u, 
			_ => throw new InvalidOperationException(), 
		};
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		uint num = mandatoryPrefix;
		encoder.WritePrefixes(in instruction, num != 243);
		if (num != 0)
		{
			encoder.WriteByteInternal(num);
		}
		num = (uint)encoder.EncoderFlags;
		num &= 0x4F;
		if (num != 0)
		{
			if ((encoder.EncoderFlags & EncoderFlags.HighLegacy8BitRegs) != 0)
			{
				encoder.ErrorMessage = "Registers AH, CH, DH, BH can't be used if there's a REX prefix. Use AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8L-R15L instead.";
			}
			num |= 0x40;
			encoder.WriteByteInternal(num);
		}
		if ((num = tableByte1) != 0)
		{
			encoder.WriteByteInternal(num);
			if ((num = tableByte2) != 0)
			{
				encoder.WriteByteInternal(num);
			}
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class VexHandler : OpCodeHandler
{
	private readonly uint table;

	private readonly uint lastByte;

	private readonly uint mask_W_L;

	private readonly uint mask_L;

	private readonly uint W1;

	private static Op[] CreateOps(EncFlags1 encFlags1)
	{
		int num = (int)(encFlags1 & EncFlags1.VEX_OpMask);
		int num2 = (int)(((uint)encFlags1 >> 6) & 0x3F);
		int num3 = (int)(((uint)encFlags1 >> 12) & 0x3F);
		int num4 = (int)(((uint)encFlags1 >> 18) & 0x3F);
		int num5 = (int)(((uint)encFlags1 >> 24) & 0x3F);
		if (num5 != 0)
		{
			return new Op[5]
			{
				OpHandlerData.VexOps[num - 1],
				OpHandlerData.VexOps[num2 - 1],
				OpHandlerData.VexOps[num3 - 1],
				OpHandlerData.VexOps[num4 - 1],
				OpHandlerData.VexOps[num5 - 1]
			};
		}
		if (num4 != 0)
		{
			return new Op[4]
			{
				OpHandlerData.VexOps[num - 1],
				OpHandlerData.VexOps[num2 - 1],
				OpHandlerData.VexOps[num3 - 1],
				OpHandlerData.VexOps[num4 - 1]
			};
		}
		if (num3 != 0)
		{
			return new Op[3]
			{
				OpHandlerData.VexOps[num - 1],
				OpHandlerData.VexOps[num2 - 1],
				OpHandlerData.VexOps[num3 - 1]
			};
		}
		if (num2 != 0)
		{
			return new Op[2]
			{
				OpHandlerData.VexOps[num - 1],
				OpHandlerData.VexOps[num2 - 1]
			};
		}
		if (num != 0)
		{
			return new Op[1] { OpHandlerData.VexOps[num - 1] };
		}
		return Array2.Empty<Op>();
	}

	public VexHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
		: base(encFlags2, encFlags3, isSpecialInstr: false, null, CreateOps(encFlags1))
	{
		table = ((uint)encFlags2 >> 17) & 7;
		WBit wBit = (WBit)(((uint)encFlags2 >> 22) & 3);
		W1 = ((wBit == WBit.W1) ? uint.MaxValue : 0u);
		LBit lBit = (LBit)(((uint)encFlags2 >> 24) & 7);
		if (lBit == LBit.L1 || lBit == LBit.L256)
		{
			lastByte = 4u;
		}
		if (W1 != 0)
		{
			lastByte |= 128u;
		}
		lastByte |= ((uint)encFlags2 >> 20) & 3;
		if (wBit == WBit.WIG)
		{
			mask_W_L |= 128u;
		}
		if (lBit == LBit.LIG)
		{
			mask_W_L |= 4u;
			mask_L |= 4u;
		}
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		encoder.WritePrefixes(in instruction);
		uint encoderFlags = (uint)encoder.EncoderFlags;
		uint num = lastByte;
		num |= (~encoderFlags >> 24) & 0x78;
		if ((encoder.Internal_PreventVEX2 | W1 | (table - 1) | (encoderFlags & 0xB)) != 0)
		{
			encoder.WriteByteInternal(196u);
			uint num2 = table;
			num2 |= (~encoderFlags & 7) << 5;
			encoder.WriteByteInternal(num2);
			num |= mask_W_L & encoder.Internal_VEX_WIG_LIG;
			encoder.WriteByteInternal(num);
		}
		else
		{
			encoder.WriteByteInternal(197u);
			num |= (~encoderFlags & 4) << 5;
			num |= mask_L & encoder.Internal_VEX_LIG;
			encoder.WriteByteInternal(num);
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class XopHandler : OpCodeHandler
{
	private readonly uint table;

	private readonly uint lastByte;

	private static Op[] CreateOps(EncFlags1 encFlags1)
	{
		int num = (int)(encFlags1 & EncFlags1.XOP_OpMask);
		int num2 = (int)(((uint)encFlags1 >> 5) & 0x1F);
		int num3 = (int)(((uint)encFlags1 >> 10) & 0x1F);
		int num4 = (int)(((uint)encFlags1 >> 15) & 0x1F);
		if (num4 != 0)
		{
			return new Op[4]
			{
				OpHandlerData.XopOps[num - 1],
				OpHandlerData.XopOps[num2 - 1],
				OpHandlerData.XopOps[num3 - 1],
				OpHandlerData.XopOps[num4 - 1]
			};
		}
		if (num3 != 0)
		{
			return new Op[3]
			{
				OpHandlerData.XopOps[num - 1],
				OpHandlerData.XopOps[num2 - 1],
				OpHandlerData.XopOps[num3 - 1]
			};
		}
		if (num2 != 0)
		{
			return new Op[2]
			{
				OpHandlerData.XopOps[num - 1],
				OpHandlerData.XopOps[num2 - 1]
			};
		}
		if (num != 0)
		{
			return new Op[1] { OpHandlerData.XopOps[num - 1] };
		}
		return Array2.Empty<Op>();
	}

	public XopHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
		: base(encFlags2, encFlags3, isSpecialInstr: false, null, CreateOps(encFlags1))
	{
		table = 8 + (((uint)encFlags2 >> 17) & 7);
		LBit lBit = (LBit)(((uint)encFlags2 >> 24) & 7);
		if (lBit == LBit.L1 || lBit == LBit.L256)
		{
			lastByte = 4u;
		}
		if ((((uint)encFlags2 >> 22) & 3) == 1)
		{
			lastByte |= 128u;
		}
		lastByte |= ((uint)encFlags2 >> 20) & 3;
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		encoder.WritePrefixes(in instruction);
		encoder.WriteByteInternal(143u);
		uint encoderFlags = (uint)encoder.EncoderFlags;
		uint num = table;
		num |= (~encoderFlags & 7) << 5;
		encoder.WriteByteInternal(num);
		num = lastByte;
		num |= (~encoderFlags >> 24) & 0x78;
		encoder.WriteByteInternal(num);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class EvexHandler : OpCodeHandler
{
	private sealed class TryConvertToDisp8NImpl
	{
		public static bool TryConvertToDisp8N(Encoder encoder, OpCodeHandler handler, in Instruction instruction, int displ, out sbyte compressedValue)
		{
			int disp8N = (int)TupleTypeTable.GetDisp8N(((EvexHandler)handler).tupleType, (encoder.EncoderFlags & EncoderFlags.Broadcast) != 0);
			int num = displ / disp8N;
			if (num * disp8N == displ && -128 <= num && num <= 127)
			{
				compressedValue = (sbyte)num;
				return true;
			}
			compressedValue = 0;
			return false;
		}
	}

	private readonly WBit wbit;

	private readonly TupleType tupleType;

	private readonly uint table;

	private readonly uint p1Bits;

	private readonly uint llBits;

	private readonly uint mask_W;

	private readonly uint mask_LL;

	private static readonly TryConvertToDisp8N tryConvertToDisp8N = TryConvertToDisp8NImpl.TryConvertToDisp8N;

	private static Op[] CreateOps(EncFlags1 encFlags1)
	{
		int num = (int)(encFlags1 & EncFlags1.XOP_OpMask);
		int num2 = (int)(((uint)encFlags1 >> 5) & 0x1F);
		int num3 = (int)(((uint)encFlags1 >> 10) & 0x1F);
		int num4 = (int)(((uint)encFlags1 >> 15) & 0x1F);
		if (num4 != 0)
		{
			return new Op[4]
			{
				OpHandlerData.EvexOps[num - 1],
				OpHandlerData.EvexOps[num2 - 1],
				OpHandlerData.EvexOps[num3 - 1],
				OpHandlerData.EvexOps[num4 - 1]
			};
		}
		if (num3 != 0)
		{
			return new Op[3]
			{
				OpHandlerData.EvexOps[num - 1],
				OpHandlerData.EvexOps[num2 - 1],
				OpHandlerData.EvexOps[num3 - 1]
			};
		}
		if (num2 != 0)
		{
			return new Op[2]
			{
				OpHandlerData.EvexOps[num - 1],
				OpHandlerData.EvexOps[num2 - 1]
			};
		}
		if (num != 0)
		{
			return new Op[1] { OpHandlerData.EvexOps[num - 1] };
		}
		return Array2.Empty<Op>();
	}

	public EvexHandler(EncFlags1 encFlags1, EncFlags2 encFlags2, EncFlags3 encFlags3)
		: base(encFlags2, encFlags3, isSpecialInstr: false, tryConvertToDisp8N, CreateOps(encFlags1))
	{
		tupleType = (TupleType)(((uint)encFlags3 >> 7) & 0x1F);
		table = ((uint)encFlags2 >> 17) & 7;
		p1Bits = 4 | (((uint)encFlags2 >> 20) & 3);
		wbit = (WBit)(((uint)encFlags2 >> 22) & 3);
		if (wbit == WBit.W1)
		{
			p1Bits |= 128u;
		}
		switch ((LBit)(((uint)encFlags2 >> 24) & 7))
		{
		case LBit.LIG:
			llBits = 0u;
			mask_LL = 96u;
			break;
		case LBit.L0:
		case LBit.LZ:
		case LBit.L128:
			llBits = 0u;
			break;
		case LBit.L1:
		case LBit.L256:
			llBits = 32u;
			break;
		case LBit.L512:
			llBits = 64u;
			break;
		default:
			throw new InvalidOperationException();
		}
		if (wbit == WBit.WIG)
		{
			mask_W |= 128u;
		}
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		encoder.WritePrefixes(in instruction);
		uint encoderFlags = (uint)encoder.EncoderFlags;
		encoder.WriteByteInternal(98u);
		uint num = table;
		num |= (encoderFlags & 7) << 5;
		num |= (encoderFlags >> 5) & 0x10;
		num ^= 0xFFFFFFF0u;
		encoder.WriteByteInternal(num);
		num = p1Bits;
		num |= (~encoderFlags >> 24) & 0x78;
		num |= mask_W & encoder.Internal_EVEX_WIG;
		encoder.WriteByteInternal(num);
		num = instruction.InternalOpMask;
		if (num != 0)
		{
			if ((EncFlags3 & EncFlags3.OpMaskRegister) == 0)
			{
				encoder.ErrorMessage = "The instruction doesn't support opmask registers";
			}
		}
		else if (((uint)EncFlags3 & 0x80000000u) != 0)
		{
			encoder.ErrorMessage = "The instruction must use an opmask register";
		}
		num |= (encoderFlags >> 28) & 8;
		if (instruction.SuppressAllExceptions)
		{
			if ((EncFlags3 & EncFlags3.SuppressAllExceptions) == 0)
			{
				encoder.ErrorMessage = "The instruction doesn't support suppress-all-exceptions";
			}
			num |= 0x10;
		}
		RoundingControl roundingControl = instruction.RoundingControl;
		if (roundingControl != 0)
		{
			if ((EncFlags3 & EncFlags3.RoundingControl) == 0)
			{
				encoder.ErrorMessage = "The instruction doesn't support rounding control";
			}
			num |= 0x10;
			num |= (uint)((int)(roundingControl - 1) << 5);
		}
		else if ((EncFlags3 & EncFlags3.SuppressAllExceptions) == 0 || !instruction.SuppressAllExceptions)
		{
			num |= llBits;
		}
		if ((encoderFlags & 0x400) != 0)
		{
			num |= 0x10;
		}
		else if (instruction.IsBroadcast)
		{
			encoder.ErrorMessage = "The instruction doesn't support broadcasting";
		}
		if (instruction.ZeroingMasking)
		{
			if ((EncFlags3 & EncFlags3.ZeroingMasking) == 0)
			{
				encoder.ErrorMessage = "The instruction doesn't support zeroing masking";
			}
			num |= 0x80;
		}
		num ^= 8;
		num |= mask_LL & encoder.Internal_EVEX_LIG;
		encoder.WriteByteInternal(num);
	}
}


private sealed class TryConvertToDisp8NImpl
{
	public static bool TryConvertToDisp8N(Encoder encoder, OpCodeHandler handler, in Instruction instruction, int displ, out sbyte compressedValue)
	{
		int disp8N = (int)TupleTypeTable.GetDisp8N(((EvexHandler)handler).tupleType, (encoder.EncoderFlags & EncoderFlags.Broadcast) != 0);
		int num = displ / disp8N;
		if (num * disp8N == displ && -128 <= num && num <= 127)
		{
			compressedValue = (sbyte)num;
			return true;
		}
		compressedValue = 0;
		return false;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class D3nowHandler : OpCodeHandler
{
	private static readonly Op[] operands = new Op[2]
	{
		new OpModRM_reg(Register.MM0, Register.MM7),
		new OpModRM_rm(Register.MM0, Register.MM7)
	};

	private readonly uint immediate;

	public D3nowHandler(EncFlags2 encFlags2, EncFlags3 encFlags3)
		: base((EncFlags2)(((ulong)encFlags2 & 0xFFFFFFFFFFFF0000uL) | 0xF), encFlags3, isSpecialInstr: false, null, operands)
	{
		immediate = OpCodeHandler.GetOpCode(encFlags2);
	}

	public override void Encode(Encoder encoder, in Instruction instruction)
	{
		encoder.WritePrefixes(in instruction);
		encoder.WriteByteInternal(15u);
		encoder.ImmSize = ImmSize.Size1OpCode;
		encoder.Immediate = immediate;
	}
}


internal enum DisplSize
{
	None,
	Size1,
	Size2,
	Size4,
	Size8,
	RipRelSize4_Target32,
	RipRelSize4_Target64
}


internal enum ImmSize
{
	None,
	Size1,
	Size2,
	Size4,
	Size8,
	Size2_1,
	Size1_1,
	Size2_2,
	Size4_2,
	RipRelSize1_Target16,
	RipRelSize1_Target32,
	RipRelSize1_Target64,
	RipRelSize2_Target16,
	RipRelSize2_Target32,
	RipRelSize2_Target64,
	RipRelSize4_Target32,
	RipRelSize4_Target64,
	SizeIbReg,
	Size1OpCode
}


using System;

[Flags]
internal enum EncoderFlags : uint
{
	None = 0u,
	B = 1u,
	X = 2u,
	R = 4u,
	W = 8u,
	ModRM = 0x10u,
	Sib = 0x20u,
	REX = 0x40u,
	P66 = 0x80u,
	P67 = 0x100u,
	R2 = 0x200u,
	Broadcast = 0x400u,
	HighLegacy8BitRegs = 0x800u,
	Displ = 0x1000u,
	PF0 = 0x2000u,
	RegIsMemory = 0x4000u,
	MustUseSib = 0x8000u,
	VvvvvShift = 0x1Bu,
	VvvvvMask = 0x1Fu
}


internal enum LegacyOpCodeTable
{
	MAP0,
	MAP0F,
	MAP0F38,
	MAP0F3A
}


internal enum VexOpCodeTable
{
	MAP0,
	MAP0F,
	MAP0F38,
	MAP0F3A
}


internal enum XopOpCodeTable
{
	MAP8,
	MAP9,
	MAP10
}


internal enum EvexOpCodeTable
{
	MAP0F = 1,
	MAP0F38 = 2,
	MAP0F3A = 3,
	MAP5 = 5,
	MAP6 = 6
}


internal enum MvexOpCodeTable
{
	MAP0F = 1,
	MAP0F38,
	MAP0F3A
}


using System;

[Flags]
internal enum EncFlags1 : uint
{
	None = 0u,
	Legacy_OpMask = 0x7Fu,
	Legacy_Op0Shift = 0u,
	Legacy_Op1Shift = 7u,
	Legacy_Op2Shift = 0xEu,
	Legacy_Op3Shift = 0x15u,
	VEX_OpMask = 0x3Fu,
	VEX_Op0Shift = 0u,
	VEX_Op1Shift = 6u,
	VEX_Op2Shift = 0xCu,
	VEX_Op3Shift = 0x12u,
	VEX_Op4Shift = 0x18u,
	XOP_OpMask = 0x1Fu,
	XOP_Op0Shift = 0u,
	XOP_Op1Shift = 5u,
	XOP_Op2Shift = 0xAu,
	XOP_Op3Shift = 0xFu,
	EVEX_OpMask = 0x1Fu,
	EVEX_Op0Shift = 0u,
	EVEX_Op1Shift = 5u,
	EVEX_Op2Shift = 0xAu,
	EVEX_Op3Shift = 0xFu,
	MVEX_OpMask = 0xFu,
	MVEX_Op0Shift = 0u,
	MVEX_Op1Shift = 4u,
	MVEX_Op2Shift = 8u,
	MVEX_Op3Shift = 0xCu,
	IgnoresRoundingControl = 0x40000000u,
	AmdLockRegBit = 0x80000000u
}


using System;

[Flags]
internal enum EncFlags2 : uint
{
	None = 0u,
	OpCodeShift = 0u,
	OpCodeIs2Bytes = 0x10000u,
	TableShift = 0x11u,
	TableMask = 7u,
	MandatoryPrefixShift = 0x14u,
	MandatoryPrefixMask = 3u,
	WBitShift = 0x16u,
	WBitMask = 3u,
	LBitShift = 0x18u,
	LBitMask = 7u,
	GroupIndexShift = 0x1Bu,
	GroupIndexMask = 7u,
	HasMandatoryPrefix = 0x40000000u,
	HasGroupIndex = 0x80000000u
}


using System;

[Flags]
internal enum EncFlags3 : uint
{
	None = 0u,
	EncodingShift = 0u,
	EncodingMask = 7u,
	OperandSizeShift = 3u,
	OperandSizeMask = 3u,
	AddressSizeShift = 5u,
	AddressSizeMask = 3u,
	TupleTypeShift = 7u,
	TupleTypeMask = 0x1Fu,
	DefaultOpSize64 = 0x1000u,
	HasRmGroupIndex = 0x2000u,
	IntelForceOpSize64 = 0x4000u,
	Fwait = 0x8000u,
	Bit16or32 = 0x10000u,
	Bit64 = 0x20000u,
	Lock = 0x40000u,
	Xacquire = 0x80000u,
	Xrelease = 0x100000u,
	Rep = 0x200000u,
	Repne = 0x400000u,
	Bnd = 0x800000u,
	HintTaken = 0x1000000u,
	Notrack = 0x2000000u,
	Broadcast = 0x4000000u,
	RoundingControl = 0x8000000u,
	SuppressAllExceptions = 0x10000000u,
	OpMaskRegister = 0x20000000u,
	ZeroingMasking = 0x40000000u,
	RequireOpMaskRegister = 0x80000000u
}


internal enum WBit : uint
{
	W0,
	W1,
	WIG,
	WIG32
}


internal enum LBit : uint
{
	L0,
	L1,
	LIG,
	LZ,
	L128,
	L256,
	L512
}


using System;
using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal static class OpCodeHandlers
{
	public static readonly OpCodeHandler[] Handlers;

	static OpCodeHandlers()
	{
		uint[] encFlags = EncoderData.EncFlags1;
		uint[] encFlags2 = EncoderData.EncFlags2;
		uint[] encFlags3 = EncoderData.EncFlags3;
		OpCodeHandler[] array = new OpCodeHandler[4834];
		int i = 0;
		InvalidHandler invalidHandler = new InvalidHandler();
		for (; i < encFlags.Length; i++)
		{
			EncFlags3 encFlags4 = (EncFlags3)encFlags3[i];
			OpCodeHandler opCodeHandler;
			switch ((EncodingKind)(encFlags4 & EncFlags3.EncodingMask))
			{
			case EncodingKind.Legacy:
			{
				Code code = (Code)i;
				opCodeHandler = ((code != 0) ? ((code > Code.DeclareQword) ? ((code != Code.Zero_bytes) ? ((OpCodeHandler)new LegacyHandler((EncFlags1)encFlags[i], (EncFlags2)encFlags2[i], encFlags4)) : ((OpCodeHandler)new ZeroBytesHandler(code))) : new DeclareDataHandler(code)) : invalidHandler);
				break;
			}
			case EncodingKind.VEX:
				opCodeHandler = new VexHandler((EncFlags1)encFlags[i], (EncFlags2)encFlags2[i], encFlags4);
				break;
			case EncodingKind.EVEX:
				opCodeHandler = new EvexHandler((EncFlags1)encFlags[i], (EncFlags2)encFlags2[i], encFlags4);
				break;
			case EncodingKind.XOP:
				opCodeHandler = new XopHandler((EncFlags1)encFlags[i], (EncFlags2)encFlags2[i], encFlags4);
				break;
			case EncodingKind.D3NOW:
				opCodeHandler = new D3nowHandler((EncFlags2)encFlags2[i], encFlags4);
				break;
			case EncodingKind.MVEX:
				opCodeHandler = invalidHandler;
				break;
			default:
				throw new InvalidOperationException();
			}
			array[i] = opCodeHandler;
		}
		if (i != array.Length)
		{
			throw new InvalidOperationException();
		}
		Handlers = array;
	}
}


using Iced.Intel;

internal abstract class Op
{
	public abstract void Encode(Encoder encoder, in Instruction instruction, int operand);

	public virtual OpKind GetImmediateOpKind()
	{
		return (OpKind)(-1);
	}

	public virtual OpKind GetNearBranchOpKind()
	{
		return (OpKind)(-1);
	}

	public virtual OpKind GetFarBranchOpKind()
	{
		return (OpKind)(-1);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpModRM_rm_mem_only : Op
{
	private readonly bool mustUseSib;

	public OpModRM_rm_mem_only(bool mustUseSib)
	{
		this.mustUseSib = mustUseSib;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (mustUseSib)
		{
			encoder.EncoderFlags |= EncoderFlags.MustUseSib;
		}
		encoder.AddRegOrMem(in instruction, operand, Register.None, Register.None, allowMemOp: true, allowRegOp: false);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpModRM_rm : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpModRM_rm(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddRegOrMem(in instruction, operand, regLo, regHi, allowMemOp: true, allowRegOp: true);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpRegEmbed8 : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpRegEmbed8(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddReg(in instruction, operand, regLo, regHi);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpModRM_rm_reg_only : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpModRM_rm_reg_only(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddRegOrMem(in instruction, operand, regLo, regHi, allowMemOp: false, allowRegOp: true);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpModRM_reg : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpModRM_reg(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddModRMRegister(in instruction, operand, regLo, regHi);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpModRM_reg_mem : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpModRM_reg_mem(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddModRMRegister(in instruction, operand, regLo, regHi);
		encoder.EncoderFlags |= EncoderFlags.RegIsMemory;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpModRM_regF0 : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpModRM_regF0(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Bitness != 64 && instruction.GetOpKind(operand) == OpKind.Register && instruction.GetOpRegister(operand) >= regLo + 8 && instruction.GetOpRegister(operand) <= regLo + 15)
		{
			encoder.EncoderFlags |= EncoderFlags.PF0;
			encoder.AddModRMRegister(in instruction, operand, regLo + 8, regLo + 15);
		}
		else
		{
			encoder.AddModRMRegister(in instruction, operand, regLo, regHi);
		}
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpReg : Op
{
	private readonly Register register;

	public OpReg(Register register)
	{
		this.register = register;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.Verify(operand, OpKind.Register, instruction.GetOpKind(operand));
		encoder.Verify(operand, register, instruction.GetOpRegister(operand));
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpRegSTi : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Register, instruction.GetOpKind(operand)))
		{
			Register opRegister = instruction.GetOpRegister(operand);
			if (encoder.Verify(operand, opRegister, Register.ST0, Register.ST7))
			{
				encoder.OpCode |= (uint)(opRegister - 217);
			}
		}
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OprDI : Op
{
	private static int GetRegSize(OpKind opKind)
	{
		return opKind switch
		{
			OpKind.MemorySegRDI => 8, 
			OpKind.MemorySegEDI => 4, 
			OpKind.MemorySegDI => 2, 
			_ => 0, 
		};
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		int regSize = GetRegSize(instruction.GetOpKind(operand));
		if (regSize == 0)
		{
			encoder.ErrorMessage = $"Operand {operand}: expected OpKind = {"MemorySegDI"}, {"MemorySegEDI"} or {"MemorySegRDI"}";
		}
		else
		{
			encoder.SetAddrSize(regSize);
		}
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpIb : Op
{
	private readonly OpKind opKind;

	public OpIb(OpKind opKind)
	{
		this.opKind = opKind;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		switch (encoder.ImmSize)
		{
		case ImmSize.Size1:
			if (encoder.Verify(operand, OpKind.Immediate8_2nd, instruction.GetOpKind(operand)))
			{
				encoder.ImmSize = ImmSize.Size1_1;
				encoder.ImmediateHi = instruction.Immediate8_2nd;
			}
			return;
		case ImmSize.Size2:
			if (encoder.Verify(operand, OpKind.Immediate8_2nd, instruction.GetOpKind(operand)))
			{
				encoder.ImmSize = ImmSize.Size2_1;
				encoder.ImmediateHi = instruction.Immediate8_2nd;
			}
			return;
		}
		OpKind actual = instruction.GetOpKind(operand);
		if (encoder.Verify(operand, opKind, actual))
		{
			encoder.ImmSize = ImmSize.Size1;
			encoder.Immediate = instruction.Immediate8;
		}
	}

	public override OpKind GetImmediateOpKind()
	{
		return opKind;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpIw : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Immediate16, instruction.GetOpKind(operand)))
		{
			encoder.ImmSize = ImmSize.Size2;
			encoder.Immediate = instruction.Immediate16;
		}
	}

	public override OpKind GetImmediateOpKind()
	{
		return OpKind.Immediate16;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpId : Op
{
	private readonly OpKind opKind;

	public OpId(OpKind opKind)
	{
		this.opKind = opKind;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		OpKind actual = instruction.GetOpKind(operand);
		if (encoder.Verify(operand, opKind, actual))
		{
			encoder.ImmSize = ImmSize.Size4;
			encoder.Immediate = instruction.Immediate32;
		}
	}

	public override OpKind GetImmediateOpKind()
	{
		return opKind;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpIq : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Immediate64, instruction.GetOpKind(operand)))
		{
			encoder.ImmSize = ImmSize.Size8;
			ulong immediate = instruction.Immediate64;
			encoder.Immediate = (uint)immediate;
			encoder.ImmediateHi = (uint)(immediate >> 32);
		}
	}

	public override OpKind GetImmediateOpKind()
	{
		return OpKind.Immediate64;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpI4 : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		OpKind opKind = instruction.GetOpKind(operand);
		if (encoder.Verify(operand, OpKind.Immediate8, opKind))
		{
			if (instruction.Immediate8 > 15)
			{
				encoder.ErrorMessage = $"Operand {operand}: Immediate value must be 0-15, but value is 0x{instruction.Immediate8:X2}";
			}
			else
			{
				encoder.ImmSize = ImmSize.Size1;
				encoder.Immediate |= instruction.Immediate8;
			}
		}
	}

	public override OpKind GetImmediateOpKind()
	{
		return OpKind.Immediate8;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpX : Op
{
	internal static int GetXRegSize(OpKind opKind)
	{
		return opKind switch
		{
			OpKind.MemorySegRSI => 8, 
			OpKind.MemorySegESI => 4, 
			OpKind.MemorySegSI => 2, 
			_ => 0, 
		};
	}

	internal static int GetYRegSize(OpKind opKind)
	{
		return opKind switch
		{
			OpKind.MemoryESRDI => 8, 
			OpKind.MemoryESEDI => 4, 
			OpKind.MemoryESDI => 2, 
			_ => 0, 
		};
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		int xRegSize = GetXRegSize(instruction.GetOpKind(operand));
		if (xRegSize == 0)
		{
			encoder.ErrorMessage = $"Operand {operand}: expected OpKind = {"MemorySegSI"}, {"MemorySegESI"} or {"MemorySegRSI"}";
			return;
		}
		Code code = instruction.Code;
		if ((uint)(code - 331) <= 3u)
		{
			int yRegSize = GetYRegSize(instruction.Op0Kind);
			if (xRegSize != yRegSize)
			{
				encoder.ErrorMessage = $"Same sized register must be used: reg #1 size = {yRegSize * 8}, reg #2 size = {xRegSize * 8}";
				return;
			}
		}
		encoder.SetAddrSize(xRegSize);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpY : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		int yRegSize = OpX.GetYRegSize(instruction.GetOpKind(operand));
		if (yRegSize == 0)
		{
			encoder.ErrorMessage = $"Operand {operand}: expected OpKind = {"MemoryESDI"}, {"MemoryESEDI"} or {"MemoryESRDI"}";
			return;
		}
		Code code = instruction.Code;
		if ((uint)(code - 335) <= 3u)
		{
			int xRegSize = OpX.GetXRegSize(instruction.Op0Kind);
			if (xRegSize != yRegSize)
			{
				encoder.ErrorMessage = $"Same sized register must be used: reg #1 size = {xRegSize * 8}, reg #2 size = {yRegSize * 8}";
				return;
			}
		}
		encoder.SetAddrSize(yRegSize);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpMRBX : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Memory, instruction.GetOpKind(operand)))
		{
			Register memoryBase = instruction.MemoryBase;
			if (instruction.MemoryDisplSize != 0 || instruction.MemoryDisplacement64 != 0L || instruction.MemoryIndexScale != 1 || instruction.MemoryIndex != Register.AL || (memoryBase != Register.BX && memoryBase != Register.EBX && memoryBase != Register.RBX))
			{
				encoder.ErrorMessage = $"Operand {operand}: Operand must be [bx+al], [ebx+al], or [rbx+al]";
			}
			else
			{
				encoder.SetAddrSize(memoryBase switch
				{
					Register.RBX => 8, 
					Register.EBX => 4, 
					_ => 2, 
				});
			}
		}
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpJ : Op
{
	private readonly OpKind opKind;

	private readonly int immSize;

	public OpJ(OpKind opKind, int immSize)
	{
		this.opKind = opKind;
		this.immSize = immSize;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddBranch(opKind, immSize, in instruction, operand);
	}

	public override OpKind GetNearBranchOpKind()
	{
		return opKind;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpJx : Op
{
	private readonly int immSize;

	public OpJx(int immSize)
	{
		this.immSize = immSize;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddBranchX(immSize, in instruction, operand);
	}

	public override OpKind GetNearBranchOpKind()
	{
		return base.GetNearBranchOpKind();
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpJdisp : Op
{
	private readonly int displSize;

	public OpJdisp(int displSize)
	{
		this.displSize = displSize;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddBranchDisp(displSize, in instruction, operand);
	}

	public override OpKind GetNearBranchOpKind()
	{
		if (displSize != 2)
		{
			return OpKind.NearBranch32;
		}
		return OpKind.NearBranch16;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpA : Op
{
	private readonly int size;

	public OpA(int size)
	{
		this.size = size;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddFarBranch(in instruction, operand, size);
	}

	public override OpKind GetFarBranchOpKind()
	{
		if (size != 2)
		{
			return OpKind.FarBranch32;
		}
		return OpKind.FarBranch16;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpO : Op
{
	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.AddAbsMem(in instruction, operand);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpImm : Op
{
	private readonly byte value;

	public OpImm(byte value)
	{
		this.value = value;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Immediate8, instruction.GetOpKind(operand)) && instruction.Immediate8 != value)
		{
			encoder.ErrorMessage = $"Operand {operand}: Expected 0x{value:X2}, actual: 0x{instruction.Immediate8:X2}";
		}
	}

	public override OpKind GetImmediateOpKind()
	{
		return OpKind.Immediate8;
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpHx : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpHx(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Register, instruction.GetOpKind(operand)))
		{
			Register opRegister = instruction.GetOpRegister(operand);
			if (encoder.Verify(operand, opRegister, regLo, regHi))
			{
				encoder.EncoderFlags |= (EncoderFlags)(opRegister - regLo << 27);
			}
		}
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpVsib : Op
{
	private readonly Register vsibIndexRegLo;

	private readonly Register vsibIndexRegHi;

	public OpVsib(Register regLo, Register regHi)
	{
		vsibIndexRegLo = regLo;
		vsibIndexRegHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		encoder.EncoderFlags |= EncoderFlags.MustUseSib;
		encoder.AddRegOrMem(in instruction, operand, Register.None, Register.None, vsibIndexRegLo, vsibIndexRegHi, allowMemOp: true, allowRegOp: false);
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal sealed class OpIsX : Op
{
	private readonly Register regLo;

	private readonly Register regHi;

	public OpIsX(Register regLo, Register regHi)
	{
		this.regLo = regLo;
		this.regHi = regHi;
	}

	public override void Encode(Encoder encoder, in Instruction instruction, int operand)
	{
		if (encoder.Verify(operand, OpKind.Register, instruction.GetOpKind(operand)))
		{
			Register opRegister = instruction.GetOpRegister(operand);
			if (encoder.Verify(operand, opRegister, regLo, regHi))
			{
				encoder.ImmSize = ImmSize.SizeIbReg;
				encoder.Immediate = (uint)(opRegister - regLo << 4);
			}
		}
	}
}


using Iced.Intel;
using Iced.Intel.EncoderInternal;

internal static class OpHandlerData
{
	public static readonly Op[] LegacyOps = new Op[75]
	{
		new OpA(2),
		new OpA(4),
		new OpO(),
		new OpModRM_rm_mem_only(mustUseSib: false),
		new OpModRM_rm_mem_only(mustUseSib: false),
		new OpModRM_rm_mem_only(mustUseSib: false),
		new OpModRM_rm(Register.AL, Register.R15L),
		new OpModRM_rm(Register.AX, Register.R15W),
		new OpModRM_rm(Register.EAX, Register.R15D),
		new OpModRM_rm(Register.EAX, Register.R15D),
		new OpModRM_rm(Register.RAX, Register.R15),
		new OpModRM_rm(Register.RAX, Register.R15),
		new OpModRM_rm(Register.MM0, Register.MM7),
		new OpModRM_rm(Register.XMM0, Register.XMM15),
		new OpModRM_rm(Register.BND0, Register.BND3),
		new OpModRM_reg(Register.AL, Register.R15L),
		new OpRegEmbed8(Register.AL, Register.R15L),
		new OpModRM_reg(Register.AX, Register.R15W),
		new OpModRM_reg_mem(Register.AX, Register.R15W),
		new OpModRM_rm_reg_only(Register.AX, Register.R15W),
		new OpRegEmbed8(Register.AX, Register.R15W),
		new OpModRM_reg(Register.EAX, Register.R15D),
		new OpModRM_reg_mem(Register.EAX, Register.R15D),
		new OpModRM_rm_reg_only(Register.EAX, Register.R15D),
		new OpRegEmbed8(Register.EAX, Register.R15D),
		new OpModRM_reg(Register.RAX, Register.R15),
		new OpModRM_reg_mem(Register.RAX, Register.R15),
		new OpModRM_rm_reg_only(Register.RAX, Register.R15),
		new OpRegEmbed8(Register.RAX, Register.R15),
		new OpModRM_reg(Register.ES, Register.GS),
		new OpModRM_reg(Register.MM0, Register.MM7),
		new OpModRM_rm_reg_only(Register.MM0, Register.MM7),
		new OpModRM_reg(Register.XMM0, Register.XMM15),
		new OpModRM_rm_reg_only(Register.XMM0, Register.XMM15),
		new OpModRM_regF0(Register.CR0, Register.CR15),
		new OpModRM_reg(Register.DR0, Register.DR15),
		new OpModRM_reg(Register.TR0, Register.TR7),
		new OpModRM_reg(Register.BND0, Register.BND3),
		new OpReg(Register.ES),
		new OpReg(Register.CS),
		new OpReg(Register.SS),
		new OpReg(Register.DS),
		new OpReg(Register.FS),
		new OpReg(Register.GS),
		new OpReg(Register.AL),
		new OpReg(Register.CL),
		new OpReg(Register.AX),
		new OpReg(Register.DX),
		new OpReg(Register.EAX),
		new OpReg(Register.RAX),
		new OpReg(Register.ST0),
		new OpRegSTi(),
		new OpIb(OpKind.Immediate8),
		new OpImm(1),
		new OpIb(OpKind.Immediate8to16),
		new OpIb(OpKind.Immediate8to32),
		new OpIb(OpKind.Immediate8to64),
		new OpIw(),
		new OpId(OpKind.Immediate32),
		new OpId(OpKind.Immediate32to64),
		new OpIq(),
		new OpX(),
		new OpY(),
		new OprDI(),
		new OpMRBX(),
		new OpJ(OpKind.NearBranch16, 1),
		new OpJ(OpKind.NearBranch32, 1),
		new OpJ(OpKind.NearBranch64, 1),
		new OpJ(OpKind.NearBranch16, 2),
		new OpJ(OpKind.NearBranch32, 4),
		new OpJ(OpKind.NearBranch64, 4),
		new OpJx(2),
		new OpJx(4),
		new OpJdisp(2),
		new OpJdisp(4)
	};

	public static readonly Op[] VexOps = new Op[38]
	{
		new OpModRM_rm_mem_only(mustUseSib: false),
		new OpVsib(Register.XMM0, Register.XMM15),
		new OpVsib(Register.XMM0, Register.XMM15),
		new OpVsib(Register.YMM0, Register.YMM15),
		new OpVsib(Register.YMM0, Register.YMM15),
		new OpModRM_rm(Register.EAX, Register.R15D),
		new OpModRM_rm(Register.RAX, Register.R15),
		new OpModRM_rm(Register.XMM0, Register.XMM15),
		new OpModRM_rm(Register.YMM0, Register.YMM15),
		new OpModRM_rm(Register.K0, Register.K7),
		new OpModRM_reg(Register.EAX, Register.R15D),
		new OpModRM_rm_reg_only(Register.EAX, Register.R15D),
		new OpHx(Register.EAX, Register.R15D),
		new OpModRM_reg(Register.RAX, Register.R15),
		new OpModRM_rm_reg_only(Register.RAX, Register.R15),
		new OpHx(Register.RAX, Register.R15),
		new OpModRM_reg(Register.K0, Register.K7),
		new OpModRM_rm_reg_only(Register.K0, Register.K7),
		new OpHx(Register.K0, Register.K7),
		new OpModRM_reg(Register.XMM0, Register.XMM15),
		new OpModRM_rm_reg_only(Register.XMM0, Register.XMM15),
		new OpHx(Register.XMM0, Register.XMM15),
		new OpIsX(Register.XMM0, Register.XMM15),
		new OpIsX(Register.XMM0, Register.XMM15),
		new OpModRM_reg(Register.YMM0, Register.YMM15),
		new OpModRM_rm_reg_only(Register.YMM0, Register.YMM15),
		new OpHx(Register.YMM0, Register.YMM15),
		new OpIsX(Register.YMM0, Register.YMM15),
		new OpIsX(Register.YMM0, Register.YMM15),
		new OpI4(),
		new OpIb(OpKind.Immediate8),
		new OprDI(),
		new OpJ(OpKind.NearBranch64, 1),
		new OpJ(OpKind.NearBranch64, 4),
		new OpModRM_rm_mem_only(mustUseSib: true),
		new OpModRM_reg(Register.TMM0, Register.TMM7),
		new OpModRM_rm_reg_only(Register.TMM0, Register.TMM7),
		new OpHx(Register.TMM0, Register.TMM7)
	};

	public static readonly Op[] XopOps = new Op[18]
	{
		new OpModRM_rm(Register.EAX, Register.R15D),
		new OpModRM_rm(Register.RAX, Register.R15),
		new OpModRM_rm(Register.XMM0, Register.XMM15),
		new OpModRM_rm(Register.YMM0, Register.YMM15),
		new OpModRM_reg(Register.EAX, Register.R15D),
		new OpModRM_rm_reg_only(Register.EAX, Register.R15D),
		new OpHx(Register.EAX, Register.R15D),
		new OpModRM_reg(Register.RAX, Register.R15),
		new OpModRM_rm_reg_only(Register.RAX, Register.R15),
		new OpHx(Register.RAX, Register.R15),
		new OpModRM_reg(Register.XMM0, Register.XMM15),
		new OpHx(Register.XMM0, Register.XMM15),
		new OpIsX(Register.XMM0, Register.XMM15),
		new OpModRM_reg(Register.YMM0, Register.YMM15),
		new OpHx(Register.YMM0, Register.YMM15),
		new OpIsX(Register.YMM0, Register.YMM15),
		new OpIb(OpKind.Immediate8),
		new OpId(OpKind.Immediate32)
	};

	public static readonly Op[] EvexOps = new Op[31]
	{
		new OpModRM_rm_mem_only(mustUseSib: false),
		new OpVsib(Register.XMM0, Register.XMM31),
		new OpVsib(Register.XMM0, Register.XMM31),
		new OpVsib(Register.YMM0, Register.YMM31),
		new OpVsib(Register.YMM0, Register.YMM31),
		new OpVsib(Register.ZMM0, Register.ZMM31),
		new OpVsib(Register.ZMM0, Register.ZMM31),
		new OpModRM_rm(Register.EAX, Register.R15D),
		new OpModRM_rm(Register.RAX, Register.R15),
		new OpModRM_rm(Register.XMM0, Register.XMM31),
		new OpModRM_rm(Register.YMM0, Register.YMM31),
		new OpModRM_rm(Register.ZMM0, Register.ZMM31),
		new OpModRM_reg(Register.EAX, Register.R15D),
		new OpModRM_rm_reg_only(Register.EAX, Register.R15D),
		new OpModRM_reg(Register.RAX, Register.R15),
		new OpModRM_rm_reg_only(Register.RAX, Register.R15),
		new OpModRM_reg(Register.K0, Register.K7),
		new OpModRM_reg(Register.K0, Register.K7),
		new OpModRM_rm_reg_only(Register.K0, Register.K7),
		new OpModRM_reg(Register.XMM0, Register.XMM31),
		new OpModRM_rm_reg_only(Register.XMM0, Register.XMM31),
		new OpHx(Register.XMM0, Register.XMM31),
		new OpHx(Register.XMM0, Register.XMM31),
		new OpModRM_reg(Register.YMM0, Register.YMM31),
		new OpModRM_rm_reg_only(Register.YMM0, Register.YMM31),
		new OpHx(Register.YMM0, Register.YMM31),
		new OpModRM_reg(Register.ZMM0, Register.ZMM31),
		new OpModRM_rm_reg_only(Register.ZMM0, Register.ZMM31),
		new OpHx(Register.ZMM0, Register.ZMM31),
		new OpHx(Register.ZMM0, Register.ZMM31),
		new OpIb(OpKind.Immediate8)
	};
}


internal enum EvexOpCodeHandlerKind : byte
{
	Invalid,
	Invalid2,
	Dup,
	HandlerReference,
	ArrayReference,
	RM,
	Group,
	W,
	MandatoryPrefix2,
	VectorLength,
	VectorLength_er,
	Ed_V_Ib,
	Ev_VX,
	Ev_VX_Ib,
	Gv_W_er,
	GvM_VX_Ib,
	HkWIb_3,
	HkWIb_3b,
	HWIb,
	KkHW_3,
	KkHW_3b,
	KkHWIb_sae_3,
	KkHWIb_sae_3b,
	KkHWIb_3,
	KkHWIb_3b,
	KkWIb_3,
	KkWIb_3b,
	KP1HW,
	KR,
	MV,
	V_H_Ev_er,
	V_H_Ev_Ib,
	VHM,
	VHW_3,
	VHW_4,
	VHWIb,
	VK,
	Vk_VSIB,
	VkEv_REXW_2,
	VkEv_REXW_3,
	VkHM,
	VkHW_3,
	VkHW_3b,
	VkHW_5,
	VkHW_er_4,
	VkHW_er_4b,
	VkHWIb_3,
	VkHWIb_3b,
	VkHWIb_5,
	VkHWIb_er_4,
	VkHWIb_er_4b,
	VkM,
	VkW_3,
	VkW_3b,
	VkW_4,
	VkW_4b,
	VkW_er_4,
	VkW_er_5,
	VkW_er_6,
	VkWIb_3,
	VkWIb_3b,
	VkWIb_er,
	VM,
	VSIB_k1,
	VSIB_k1_VX,
	VW,
	VW_er,
	VX_Ev,
	WkHV,
	WkV_3,
	WkV_4a,
	WkV_4b,
	WkVIb,
	WkVIb_er,
	WV,
	VkHW_er_ur_3,
	VkHW_er_ur_3b
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class EvexOpCodeHandlerReader : OpCodeHandlerReader
{
	public override int ReadHandlers(ref TableDeserializer deserializer, OpCodeHandler?[] result, int resultIndex)
	{
		ref OpCodeHandler reference = ref result[resultIndex];
		switch (deserializer.ReadEvexOpCodeHandlerKind())
		{
		case EvexOpCodeHandlerKind.Invalid:
			reference = OpCodeHandler_Invalid.Instance;
			return 1;
		case EvexOpCodeHandlerKind.Invalid2:
			result[resultIndex] = OpCodeHandler_Invalid.Instance;
			result[resultIndex + 1] = OpCodeHandler_Invalid.Instance;
			return 2;
		case EvexOpCodeHandlerKind.Dup:
		{
			int num = deserializer.ReadInt32();
			OpCodeHandler opCodeHandler = deserializer.ReadHandler();
			for (int i = 0; i < num; i++)
			{
				result[resultIndex + i] = opCodeHandler;
			}
			return num;
		}
		case EvexOpCodeHandlerKind.HandlerReference:
			reference = deserializer.ReadHandlerReference();
			return 1;
		case EvexOpCodeHandlerKind.ArrayReference:
			throw new InvalidOperationException();
		case EvexOpCodeHandlerKind.RM:
			reference = new OpCodeHandler_RM(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case EvexOpCodeHandlerKind.Group:
			reference = new OpCodeHandler_Group(deserializer.ReadArrayReference(4u));
			return 1;
		case EvexOpCodeHandlerKind.W:
			reference = new OpCodeHandler_W(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case EvexOpCodeHandlerKind.MandatoryPrefix2:
			reference = new OpCodeHandler_MandatoryPrefix2(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case EvexOpCodeHandlerKind.VectorLength:
			reference = new OpCodeHandler_VectorLength_EVEX(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case EvexOpCodeHandlerKind.VectorLength_er:
			reference = new OpCodeHandler_VectorLength_EVEX_er(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case EvexOpCodeHandlerKind.Ed_V_Ib:
		{
			Code code;
			reference = new OpCodeHandler_EVEX_Ed_V_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1, deserializer.ReadTupleType(), deserializer.ReadTupleType());
			return 1;
		}
		case EvexOpCodeHandlerKind.Ev_VX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_EVEX_Ev_VX(code, code + 1, deserializer.ReadTupleType(), deserializer.ReadTupleType());
			return 1;
		}
		case EvexOpCodeHandlerKind.Ev_VX_Ib:
		{
			Code code;
			reference = new OpCodeHandler_EVEX_Ev_VX_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case EvexOpCodeHandlerKind.Gv_W_er:
		{
			Code code;
			reference = new OpCodeHandler_EVEX_Gv_W_er(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1, deserializer.ReadTupleType(), deserializer.ReadBoolean());
			return 1;
		}
		case EvexOpCodeHandlerKind.GvM_VX_Ib:
		{
			Code code;
			reference = new OpCodeHandler_EVEX_GvM_VX_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1, deserializer.ReadTupleType(), deserializer.ReadTupleType());
			return 1;
		}
		case EvexOpCodeHandlerKind.HkWIb_3:
			reference = new OpCodeHandler_EVEX_HkWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.HkWIb_3b:
			reference = new OpCodeHandler_EVEX_HkWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.HWIb:
			reference = new OpCodeHandler_EVEX_HWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.KkHW_3:
			reference = new OpCodeHandler_EVEX_KkHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.KkHW_3b:
			reference = new OpCodeHandler_EVEX_KkHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.KkHWIb_sae_3:
			reference = new OpCodeHandler_EVEX_KkHWIb_sae(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.KkHWIb_sae_3b:
			reference = new OpCodeHandler_EVEX_KkHWIb_sae(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.KkHWIb_3:
			reference = new OpCodeHandler_EVEX_KkHWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.KkHWIb_3b:
			reference = new OpCodeHandler_EVEX_KkHWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.KkWIb_3:
			reference = new OpCodeHandler_EVEX_KkWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.KkWIb_3b:
			reference = new OpCodeHandler_EVEX_KkWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.KP1HW:
			reference = new OpCodeHandler_EVEX_KP1HW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.KR:
			reference = new OpCodeHandler_EVEX_KR(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case EvexOpCodeHandlerKind.MV:
			reference = new OpCodeHandler_EVEX_MV(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.V_H_Ev_er:
		{
			Code code;
			reference = new OpCodeHandler_EVEX_V_H_Ev_er(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1, deserializer.ReadTupleType(), deserializer.ReadTupleType());
			return 1;
		}
		case EvexOpCodeHandlerKind.V_H_Ev_Ib:
		{
			Code code;
			reference = new OpCodeHandler_EVEX_V_H_Ev_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1, deserializer.ReadTupleType(), deserializer.ReadTupleType());
			return 1;
		}
		case EvexOpCodeHandlerKind.VHM:
			reference = new OpCodeHandler_EVEX_VHM(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VHW_3:
			reference = new OpCodeHandler_EVEX_VHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VHW_4:
			reference = new OpCodeHandler_EVEX_VHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VHWIb:
			reference = new OpCodeHandler_EVEX_VHWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VK:
			reference = new OpCodeHandler_EVEX_VK(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case EvexOpCodeHandlerKind.Vk_VSIB:
			reference = new OpCodeHandler_EVEX_Vk_VSIB(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VkEv_REXW_2:
			reference = new OpCodeHandler_EVEX_VkEv_REXW(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case EvexOpCodeHandlerKind.VkEv_REXW_3:
			reference = new OpCodeHandler_EVEX_VkEv_REXW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadCode());
			return 1;
		case EvexOpCodeHandlerKind.VkHM:
			reference = new OpCodeHandler_EVEX_VkHM(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VkHW_3:
			reference = new OpCodeHandler_EVEX_VkHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHW_3b:
			reference = new OpCodeHandler_EVEX_VkHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkHW_5:
			reference = new OpCodeHandler_EVEX_VkHW(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHW_er_4:
			reference = new OpCodeHandler_EVEX_VkHW_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), deserializer.ReadBoolean(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHW_er_4b:
			reference = new OpCodeHandler_EVEX_VkHW_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), deserializer.ReadBoolean(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkHW_er_ur_3:
			reference = new OpCodeHandler_EVEX_VkHW_er_ur(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHW_er_ur_3b:
			reference = new OpCodeHandler_EVEX_VkHW_er_ur(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkHWIb_3:
			reference = new OpCodeHandler_EVEX_VkHWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHWIb_3b:
			reference = new OpCodeHandler_EVEX_VkHWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkHWIb_5:
			reference = new OpCodeHandler_EVEX_VkHWIb(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHWIb_er_4:
			reference = new OpCodeHandler_EVEX_VkHWIb_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkHWIb_er_4b:
			reference = new OpCodeHandler_EVEX_VkHWIb_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkM:
			reference = new OpCodeHandler_EVEX_VkM(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VkW_3:
			reference = new OpCodeHandler_EVEX_VkW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkW_3b:
			reference = new OpCodeHandler_EVEX_VkW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkW_4:
			reference = new OpCodeHandler_EVEX_VkW(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkW_4b:
			reference = new OpCodeHandler_EVEX_VkW(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkW_er_4:
			reference = new OpCodeHandler_EVEX_VkW_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), deserializer.ReadBoolean());
			return 1;
		case EvexOpCodeHandlerKind.VkW_er_5:
			reference = new OpCodeHandler_EVEX_VkW_er(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), deserializer.ReadBoolean());
			return 1;
		case EvexOpCodeHandlerKind.VkW_er_6:
			reference = new OpCodeHandler_EVEX_VkW_er(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), deserializer.ReadBoolean(), deserializer.ReadBoolean());
			return 1;
		case EvexOpCodeHandlerKind.VkWIb_3:
			reference = new OpCodeHandler_EVEX_VkWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: false);
			return 1;
		case EvexOpCodeHandlerKind.VkWIb_3b:
			reference = new OpCodeHandler_EVEX_VkWIb(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), canBroadcast: true);
			return 1;
		case EvexOpCodeHandlerKind.VkWIb_er:
			reference = new OpCodeHandler_EVEX_VkWIb_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VM:
			reference = new OpCodeHandler_EVEX_VM(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VSIB_k1:
			reference = new OpCodeHandler_EVEX_VSIB_k1(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VSIB_k1_VX:
			reference = new OpCodeHandler_EVEX_VSIB_k1_VX(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VW:
			reference = new OpCodeHandler_EVEX_VW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VW_er:
			reference = new OpCodeHandler_EVEX_VW_er(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.VX_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_EVEX_VX_Ev(code, code + 1, deserializer.ReadTupleType(), deserializer.ReadTupleType());
			return 1;
		}
		case EvexOpCodeHandlerKind.WkHV:
			reference = new OpCodeHandler_EVEX_WkHV(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case EvexOpCodeHandlerKind.WkV_3:
			reference = new OpCodeHandler_EVEX_WkV(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.WkV_4a:
			reference = new OpCodeHandler_EVEX_WkV(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.WkV_4b:
			reference = new OpCodeHandler_EVEX_WkV(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType(), deserializer.ReadBoolean());
			return 1;
		case EvexOpCodeHandlerKind.WkVIb:
			reference = new OpCodeHandler_EVEX_WkVIb(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.WkVIb_er:
			reference = new OpCodeHandler_EVEX_WkVIb_er(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		case EvexOpCodeHandlerKind.WV:
			reference = new OpCodeHandler_EVEX_WV(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadTupleType());
			return 1;
		default:
			throw new InvalidOperationException();
		}
	}
}


using System;

[Flags]
internal enum HandlerFlags : uint
{
	None = 0u,
	Xacquire = 1u,
	Xrelease = 2u,
	XacquireXreleaseNoLock = 4u,
	Lock = 8u
}


using System;

[Flags]
internal enum LegacyHandlerFlags : uint
{
	HandlerReg = 1u,
	HandlerMem = 2u,
	Handler66Reg = 4u,
	Handler66Mem = 8u,
	HandlerF3Reg = 0x10u,
	HandlerF3Mem = 0x20u,
	HandlerF2Reg = 0x40u,
	HandlerF2Mem = 0x80u
}


internal enum LegacyOpCodeHandlerKind : byte
{
	Bitness,
	Bitness_DontReadModRM,
	Invalid,
	Invalid_NoModRM,
	Invalid2,
	Dup,
	Null,
	HandlerReference,
	ArrayReference,
	RM,
	Options3,
	Options5,
	Options_DontReadModRM,
	AnotherTable,
	Group,
	Group8x64,
	Group8x8,
	MandatoryPrefix,
	MandatoryPrefix4,
	Ev_REXW_1a,
	MandatoryPrefix_NoModRM,
	MandatoryPrefix3,
	D3NOW,
	EVEX,
	VEX2,
	VEX3,
	XOP,
	AL_DX,
	Ap,
	B_BM,
	B_Ev,
	B_MIB,
	BM_B,
	BranchIw,
	BranchSimple,
	C_R_3a,
	C_R_3b,
	DX_AL,
	DX_eAX,
	eAX_DX,
	Eb_1,
	Eb_2,
	Eb_CL,
	Eb_Gb_1,
	Eb_Gb_2,
	Eb_Ib_1,
	Eb_Ib_2,
	Eb1,
	Ed_V_Ib,
	Ep,
	Ev_3a,
	Ev_3b,
	Ev_4,
	Ev_CL,
	Ev_Gv_32_64,
	Ev_Gv_3a,
	Ev_Gv_3b,
	Ev_Gv_4,
	Ev_Gv_CL,
	Ev_Gv_Ib,
	Ev_Gv_REX,
	Ev_Ib_3,
	Ev_Ib_4,
	Ev_Ib2_3,
	Ev_Ib2_4,
	Ev_Iz_3,
	Ev_Iz_4,
	Ev_P,
	Ev_REXW,
	Ev_Sw,
	Ev_VX,
	Ev1,
	Evj,
	Evw,
	Ew,
	Gb_Eb,
	Gdq_Ev,
	Gv_Eb,
	Gv_Eb_REX,
	Gv_Ev_32_64,
	Gv_Ev_3a,
	Gv_Ev_3b,
	Gv_Ev_Ib,
	Gv_Ev_Ib_REX,
	Gv_Ev_Iz,
	Gv_Ev_REX,
	Gv_Ev2,
	Gv_Ev3,
	Gv_Ew,
	Gv_M,
	Gv_M_as,
	Gv_Ma,
	Gv_Mp_2,
	Gv_Mp_3,
	Gv_Mv,
	Gv_N,
	Gv_N_Ib_REX,
	Gv_RX,
	Gv_W,
	GvM_VX_Ib,
	Ib,
	Ib3,
	IbReg,
	IbReg2,
	Iw_Ib,
	Jb,
	Jb2,
	Jdisp,
	Jx,
	Jz,
	M_1,
	M_2,
	M_REXW_2,
	M_REXW_4,
	MemBx,
	Mf_1,
	Mf_2a,
	Mf_2b,
	MIB_B,
	MP,
	Ms,
	MV,
	Mv_Gv,
	Mv_Gv_REXW,
	NIb,
	Ob_Reg,
	Ov_Reg,
	P_Ev,
	P_Ev_Ib,
	P_Q,
	P_Q_Ib,
	P_R,
	P_W,
	PushEv,
	PushIb2,
	PushIz,
	PushOpSizeReg_4a,
	PushOpSizeReg_4b,
	PushSimple2,
	PushSimpleReg,
	Q_P,
	R_C_3a,
	R_C_3b,
	rDI_P_N,
	rDI_VX_RX,
	Reg,
	Reg_Ib2,
	Reg_Iz,
	Reg_Ob,
	Reg_Ov,
	Reg_Xb,
	Reg_Xv,
	Reg_Xv2,
	Reg_Yb,
	Reg_Yv,
	RegIb,
	RegIb3,
	RegIz2,
	Reservednop,
	RIb,
	RIbIb,
	Rv,
	Rv_32_64,
	RvMw_Gw,
	Simple,
	Simple_ModRM,
	Simple2_3a,
	Simple2_3b,
	Simple2Iw,
	Simple3,
	Simple4,
	Simple5,
	Simple5_ModRM_as,
	SimpleReg,
	ST_STi,
	STi,
	STi_ST,
	Sw_Ev,
	V_Ev,
	VM,
	VN,
	VQ,
	VRIbIb,
	VW_2,
	VW_3,
	VWIb_2,
	VWIb_3,
	VX_E_Ib,
	VX_Ev,
	Wbinvd,
	WV,
	Xb_Yb,
	Xchg_Reg_rAX,
	Xv_Yv,
	Yb_Reg,
	Yb_Xb,
	Yv_Reg,
	Yv_Reg2,
	Yv_Xv,
	Simple4b,
	Options1632_1,
	Options1632_2,
	M_Sw,
	Sw_M,
	Rq,
	Gd_Rd,
	PrefixEsCsSsDs,
	PrefixFsGs,
	Prefix66,
	Prefix67,
	PrefixF0,
	PrefixF2,
	PrefixF3,
	PrefixREX,
	Simple5_a32
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class LegacyOpCodeHandlerReader : OpCodeHandlerReader
{
	public override int ReadHandlers(ref TableDeserializer deserializer, OpCodeHandler?[] result, int resultIndex)
	{
		ref OpCodeHandler reference = ref result[resultIndex];
		switch (deserializer.ReadLegacyOpCodeHandlerKind())
		{
		case LegacyOpCodeHandlerKind.Bitness:
			reference = new OpCodeHandler_Bitness(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.Bitness_DontReadModRM:
			reference = new OpCodeHandler_Bitness_DontReadModRM(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.Invalid:
			reference = OpCodeHandler_Invalid.Instance;
			return 1;
		case LegacyOpCodeHandlerKind.Invalid_NoModRM:
			reference = OpCodeHandler_Invalid_NoModRM.Instance;
			return 1;
		case LegacyOpCodeHandlerKind.Invalid2:
			result[resultIndex] = OpCodeHandler_Invalid.Instance;
			result[resultIndex + 1] = OpCodeHandler_Invalid.Instance;
			return 2;
		case LegacyOpCodeHandlerKind.Dup:
		{
			int num = deserializer.ReadInt32();
			OpCodeHandler opCodeHandler = deserializer.ReadHandlerOrNull();
			for (int i = 0; i < num; i++)
			{
				result[resultIndex + i] = opCodeHandler;
			}
			return num;
		}
		case LegacyOpCodeHandlerKind.Null:
			reference = null;
			return 1;
		case LegacyOpCodeHandlerKind.HandlerReference:
			reference = deserializer.ReadHandlerReference();
			return 1;
		case LegacyOpCodeHandlerKind.ArrayReference:
			throw new InvalidOperationException();
		case LegacyOpCodeHandlerKind.RM:
			reference = new OpCodeHandler_RM(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.Options1632_1:
			reference = new OpCodeHandler_Options1632(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions());
			return 1;
		case LegacyOpCodeHandlerKind.Options1632_2:
			reference = new OpCodeHandler_Options1632(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions());
			return 1;
		case LegacyOpCodeHandlerKind.Options3:
			reference = new OpCodeHandler_Options(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions());
			return 1;
		case LegacyOpCodeHandlerKind.Options5:
			reference = new OpCodeHandler_Options(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions());
			return 1;
		case LegacyOpCodeHandlerKind.Options_DontReadModRM:
			reference = new OpCodeHandler_Options_DontReadModRM(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions());
			return 1;
		case LegacyOpCodeHandlerKind.AnotherTable:
			reference = new OpCodeHandler_AnotherTable(deserializer.ReadArrayReference(8u));
			return 1;
		case LegacyOpCodeHandlerKind.Group:
			reference = new OpCodeHandler_Group(deserializer.ReadArrayReference(8u));
			return 1;
		case LegacyOpCodeHandlerKind.Group8x64:
			reference = new OpCodeHandler_Group8x64(deserializer.ReadArrayReference(8u), deserializer.ReadArrayReference(8u));
			return 1;
		case LegacyOpCodeHandlerKind.Group8x8:
			reference = new OpCodeHandler_Group8x8(deserializer.ReadArrayReference(8u), deserializer.ReadArrayReference(8u));
			return 1;
		case LegacyOpCodeHandlerKind.MandatoryPrefix:
			reference = new OpCodeHandler_MandatoryPrefix(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.MandatoryPrefix4:
			reference = new OpCodeHandler_MandatoryPrefix4(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), (uint)deserializer.ReadInt32());
			return 1;
		case LegacyOpCodeHandlerKind.MandatoryPrefix_NoModRM:
			reference = new OpCodeHandler_MandatoryPrefix_NoModRM(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.MandatoryPrefix3:
			reference = new OpCodeHandler_MandatoryPrefix3(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadLegacyHandlerFlags());
			return 1;
		case LegacyOpCodeHandlerKind.D3NOW:
			reference = new OpCodeHandler_D3NOW();
			return 1;
		case LegacyOpCodeHandlerKind.EVEX:
			reference = new OpCodeHandler_EVEX(deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.VEX2:
			reference = new OpCodeHandler_VEX2(deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.VEX3:
			reference = new OpCodeHandler_VEX3(deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.XOP:
			reference = new OpCodeHandler_XOP(deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.AL_DX:
			reference = new OpCodeHandler_AL_DX(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Ap:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ap(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.B_BM:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_B_BM(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.B_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_B_Ev(code, code + 1, deserializer.ReadBoolean());
			return 1;
		}
		case LegacyOpCodeHandlerKind.B_MIB:
			reference = new OpCodeHandler_B_MIB(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.BM_B:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_BM_B(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.BranchIw:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_BranchIw(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.BranchSimple:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_BranchSimple(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.C_R_3a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_C_R(code, code + 1, deserializer.ReadRegister());
			return 1;
		}
		case LegacyOpCodeHandlerKind.C_R_3b:
			reference = new OpCodeHandler_C_R(deserializer.ReadCode(), Code.INVALID, deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.DX_AL:
			reference = new OpCodeHandler_DX_AL(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.DX_eAX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_DX_eAX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.eAX_DX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_eAX_DX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Eb_1:
			reference = new OpCodeHandler_Eb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Eb_2:
			reference = new OpCodeHandler_Eb(deserializer.ReadCode(), deserializer.ReadHandlerFlags());
			return 1;
		case LegacyOpCodeHandlerKind.Eb_CL:
			reference = new OpCodeHandler_Eb_CL(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Eb_Gb_1:
			reference = new OpCodeHandler_Eb_Gb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Eb_Gb_2:
			reference = new OpCodeHandler_Eb_Gb(deserializer.ReadCode(), deserializer.ReadHandlerFlags());
			return 1;
		case LegacyOpCodeHandlerKind.Eb_Ib_1:
			reference = new OpCodeHandler_Eb_Ib(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Eb_Ib_2:
			reference = new OpCodeHandler_Eb_Ib(deserializer.ReadCode(), deserializer.ReadHandlerFlags());
			return 1;
		case LegacyOpCodeHandlerKind.Eb1:
			reference = new OpCodeHandler_Eb_1(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Ed_V_Ib:
		{
			Code code;
			reference = new OpCodeHandler_Ed_V_Ib(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ep:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ep(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_3a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_3b:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev(code, code + 1, Code.INVALID);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev(code, code + 1, code + 2, deserializer.ReadHandlerFlags());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_CL:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_CL(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_32_64:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv_32_64(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_3a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_3b:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv(code, code + 1, Code.INVALID);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv(code, code + 1, code + 2, deserializer.ReadHandlerFlags());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_CL:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv_CL(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_Ib:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv_Ib(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Gv_REX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Gv_REX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Ib_3:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Ib(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Ib_4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Ib(code, code + 1, code + 2, deserializer.ReadHandlerFlags());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Ib2_3:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Ib2(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Ib2_4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Ib2(code, code + 1, code + 2, deserializer.ReadHandlerFlags());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Iz_3:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Iz(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Iz_4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Iz(code, code + 1, code + 2, deserializer.ReadHandlerFlags());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_P:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_P(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_REXW_1a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_REXW(code, Code.INVALID, (uint)deserializer.ReadInt32());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_REXW:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_REXW(code, code + 1, (uint)deserializer.ReadInt32());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_Sw:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_Sw(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev_VX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_VX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ev1:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ev_1(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Evj:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Evj(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Evw:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Evw(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ew:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ew(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gb_Eb:
			reference = new OpCodeHandler_Gb_Eb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Gdq_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gdq_Ev(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Eb:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Eb(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Eb_REX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Eb_REX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_32_64:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev_32_64(code, code + 1, deserializer.ReadBoolean(), deserializer.ReadBoolean());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_3a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_3b:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev(code, code + 1, Code.INVALID);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_Ib:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev_Ib(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_Ib_REX:
		{
			Code code;
			reference = new OpCodeHandler_Gv_Ev_Ib_REX(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_Iz:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev_Iz(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev_REX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev_REX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev2(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ev3:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ev3(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ew:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ew(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_M:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_M(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_M_as:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_M_as(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Ma:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Ma(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Mp_2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Mp(code, code + 1, Code.INVALID);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Mp_3:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Mp(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_Mv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_Mv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_N:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_N(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_N_Ib_REX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Gv_N_Ib_REX(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_RX:
		{
			Code code;
			reference = new OpCodeHandler_Gv_RX(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Gv_W:
		{
			Code code;
			reference = new OpCodeHandler_Gv_W(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.GvM_VX_Ib:
		{
			Code code;
			reference = new OpCodeHandler_GvM_VX_Ib(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Ib:
			reference = new OpCodeHandler_Ib(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Ib3:
			reference = new OpCodeHandler_Ib3(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.IbReg:
			reference = new OpCodeHandler_IbReg(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.IbReg2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_IbReg2(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Iw_Ib:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Iw_Ib(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Jb:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Jb(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Jb2:
			reference = new OpCodeHandler_Jb2(deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Jdisp:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Jdisp(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Jx:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Jx(code, code + 1, deserializer.ReadCode());
			return 1;
		}
		case LegacyOpCodeHandlerKind.Jz:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Jz(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.M_1:
			reference = new OpCodeHandler_M(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.M_2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_M(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.M_REXW_2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_M_REXW(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.M_REXW_4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_M_REXW(code, code + 1, deserializer.ReadHandlerFlags(), deserializer.ReadHandlerFlags());
			return 1;
		}
		case LegacyOpCodeHandlerKind.MemBx:
			reference = new OpCodeHandler_MemBx(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Mf_1:
			reference = new OpCodeHandler_Mf(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Mf_2a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Mf(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Mf_2b:
			reference = new OpCodeHandler_Mf(deserializer.ReadCode(), deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.MIB_B:
			reference = new OpCodeHandler_MIB_B(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.MP:
			reference = new OpCodeHandler_MP(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Ms:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ms(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.MV:
			reference = new OpCodeHandler_MV(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Mv_Gv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Mv_Gv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Mv_Gv_REXW:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Mv_Gv_REXW(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.NIb:
			reference = new OpCodeHandler_NIb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Ob_Reg:
			reference = new OpCodeHandler_Ob_Reg(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Ov_Reg:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Ov_Reg(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.P_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_P_Ev(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.P_Ev_Ib:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_P_Ev_Ib(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.P_Q:
			reference = new OpCodeHandler_P_Q(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.P_Q_Ib:
			reference = new OpCodeHandler_P_Q_Ib(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.P_R:
			reference = new OpCodeHandler_P_R(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.P_W:
			reference = new OpCodeHandler_P_W(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.PushEv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_PushEv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.PushIb2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_PushIb2(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.PushIz:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_PushIz(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.PushOpSizeReg_4a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_PushOpSizeReg(code, code + 1, code + 2, deserializer.ReadRegister());
			return 1;
		}
		case LegacyOpCodeHandlerKind.PushOpSizeReg_4b:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_PushOpSizeReg(code, code + 1, Code.INVALID, deserializer.ReadRegister());
			return 1;
		}
		case LegacyOpCodeHandlerKind.PushSimple2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_PushSimple2(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.PushSimpleReg:
		{
			Code code;
			reference = new OpCodeHandler_PushSimpleReg(deserializer.ReadInt32(), code = deserializer.ReadCode(), code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Q_P:
			reference = new OpCodeHandler_Q_P(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.R_C_3a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_R_C(code, code + 1, deserializer.ReadRegister());
			return 1;
		}
		case LegacyOpCodeHandlerKind.R_C_3b:
			reference = new OpCodeHandler_R_C(deserializer.ReadCode(), Code.INVALID, deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.rDI_P_N:
			reference = new OpCodeHandler_rDI_P_N(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.rDI_VX_RX:
			reference = new OpCodeHandler_rDI_VX_RX(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Reg:
			reference = new OpCodeHandler_Reg(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Reg_Ib2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Reg_Ib2(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Reg_Iz:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Reg_Iz(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Reg_Ob:
			reference = new OpCodeHandler_Reg_Ob(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Reg_Ov:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Reg_Ov(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Reg_Xb:
			reference = new OpCodeHandler_Reg_Xb(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Reg_Xv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Reg_Xv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Reg_Xv2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Reg_Xv2(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Reg_Yb:
			reference = new OpCodeHandler_Reg_Yb(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Reg_Yv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Reg_Yv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.RegIb:
			reference = new OpCodeHandler_RegIb(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.RegIb3:
			reference = new OpCodeHandler_RegIb3(deserializer.ReadInt32());
			return 1;
		case LegacyOpCodeHandlerKind.RegIz2:
			reference = new OpCodeHandler_RegIz2(deserializer.ReadInt32());
			return 1;
		case LegacyOpCodeHandlerKind.Reservednop:
			reference = new OpCodeHandler_Reservednop(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case LegacyOpCodeHandlerKind.RIb:
			reference = new OpCodeHandler_RIb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.RIbIb:
			reference = new OpCodeHandler_RIbIb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Rv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Rv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Rv_32_64:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Rv_32_64(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.RvMw_Gw:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_RvMw_Gw(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple:
			reference = new OpCodeHandler_Simple(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Simple_ModRM:
			reference = new OpCodeHandler_Simple_ModRM(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Simple2_3a:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple2(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple2_3b:
			reference = new OpCodeHandler_Simple2(deserializer.ReadCode(), deserializer.ReadCode(), deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Simple2Iw:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple2Iw(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple3:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple3(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple4:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple4(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple4b:
		{
			Code code = deserializer.ReadCode();
			Code code2 = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple4(code, code2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple5:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple5(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple5_a32:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple5_a32(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Simple5_ModRM_as:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Simple5_ModRM_as(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.SimpleReg:
			reference = new OpCodeHandler_SimpleReg(deserializer.ReadCode(), deserializer.ReadInt32());
			return 1;
		case LegacyOpCodeHandlerKind.ST_STi:
			reference = new OpCodeHandler_ST_STi(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.STi:
			reference = new OpCodeHandler_STi(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.STi_ST:
			reference = new OpCodeHandler_STi_ST(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Sw_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Sw_Ev(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.V_Ev:
		{
			Code code;
			reference = new OpCodeHandler_V_Ev(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.VM:
			reference = new OpCodeHandler_VM(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VN:
			reference = new OpCodeHandler_VN(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VQ:
			reference = new OpCodeHandler_VQ(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VRIbIb:
			reference = new OpCodeHandler_VRIbIb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VW_2:
			reference = new OpCodeHandler_VW(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VW_3:
			reference = new OpCodeHandler_VW(deserializer.ReadCode(), deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VWIb_2:
			reference = new OpCodeHandler_VWIb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.VWIb_3:
		{
			Code code;
			reference = new OpCodeHandler_VWIb(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.VX_E_Ib:
		{
			Code code;
			reference = new OpCodeHandler_VX_E_Ib(code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.VX_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VX_Ev(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Wbinvd:
			reference = new OpCodeHandler_Wbinvd();
			return 1;
		case LegacyOpCodeHandlerKind.WV:
			reference = new OpCodeHandler_WV(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Xb_Yb:
			reference = new OpCodeHandler_Xb_Yb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Xchg_Reg_rAX:
			reference = new OpCodeHandler_Xchg_Reg_rAX(deserializer.ReadInt32());
			return 1;
		case LegacyOpCodeHandlerKind.Xv_Yv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Xv_Yv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Yb_Reg:
			reference = new OpCodeHandler_Yb_Reg(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Yb_Xb:
			reference = new OpCodeHandler_Yb_Xb(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Yv_Reg:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Yv_Reg(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Yv_Reg2:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Yv_Reg2(code, code + 1);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Yv_Xv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Yv_Xv(code, code + 1, code + 2);
			return 1;
		}
		case LegacyOpCodeHandlerKind.M_Sw:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_M_Sw(code);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Sw_M:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_Sw_M(code);
			return 1;
		}
		case LegacyOpCodeHandlerKind.Rq:
			reference = new OpCodeHandler_Rq(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.Gd_Rd:
			reference = new OpCodeHandler_Gd_Rd(deserializer.ReadCode());
			return 1;
		case LegacyOpCodeHandlerKind.PrefixEsCsSsDs:
			reference = new OpCodeHandler_PrefixEsCsSsDs(deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.PrefixFsGs:
			reference = new OpCodeHandler_PrefixFsGs(deserializer.ReadRegister());
			return 1;
		case LegacyOpCodeHandlerKind.Prefix66:
			reference = new OpCodeHandler_Prefix66();
			return 1;
		case LegacyOpCodeHandlerKind.Prefix67:
			reference = new OpCodeHandler_Prefix67();
			return 1;
		case LegacyOpCodeHandlerKind.PrefixF0:
			reference = new OpCodeHandler_PrefixF0();
			return 1;
		case LegacyOpCodeHandlerKind.PrefixF2:
			reference = new OpCodeHandler_PrefixF2();
			return 1;
		case LegacyOpCodeHandlerKind.PrefixF3:
			reference = new OpCodeHandler_PrefixF3();
			return 1;
		case LegacyOpCodeHandlerKind.PrefixREX:
			reference = new OpCodeHandler_PrefixREX(deserializer.ReadHandler(), (uint)deserializer.ReadInt32());
			return 1;
		default:
			throw new InvalidOperationException();
		}
	}
}


using Iced.Intel;

internal abstract class OpCodeHandler
{
	public readonly bool HasModRM;

	protected OpCodeHandler()
	{
	}

	protected OpCodeHandler(bool hasModRM)
	{
		HasModRM = hasModRM;
	}

	public abstract void Decode(Decoder decoder, ref Instruction instruction);
}


using Iced.Intel.DecoderInternal;

internal abstract class OpCodeHandlerModRM : OpCodeHandler
{
	protected OpCodeHandlerModRM()
		: base(hasModRM: true)
	{
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Invalid : OpCodeHandlerModRM
{
	public static readonly OpCodeHandler_Invalid Instance = new OpCodeHandler_Invalid();

	private OpCodeHandler_Invalid()
	{
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.SetInvalidInstruction();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Invalid_NoModRM : OpCodeHandler
{
	public static readonly OpCodeHandler_Invalid_NoModRM Instance = new OpCodeHandler_Invalid_NoModRM();

	private OpCodeHandler_Invalid_NoModRM()
	{
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.SetInvalidInstruction();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_Simple(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple_ModRM : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Simple_ModRM(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Group8x8 : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] tableLow;

	private readonly OpCodeHandler[] tableHigh;

	public OpCodeHandler_Group8x8(OpCodeHandler[] tableLow, OpCodeHandler[] tableHigh)
	{
		if (tableLow.Length != 8)
		{
			throw new ArgumentOutOfRangeException("tableLow");
		}
		if (tableHigh.Length != 8)
		{
			throw new ArgumentOutOfRangeException("tableHigh");
		}
		this.tableLow = tableLow;
		this.tableHigh = tableHigh;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler opCodeHandler = ((decoder.state.mod != 3) ? tableLow[decoder.state.reg] : tableHigh[decoder.state.reg]);
		opCodeHandler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Group8x64 : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] tableLow;

	private readonly OpCodeHandler[] tableHigh;

	public OpCodeHandler_Group8x64(OpCodeHandler[] tableLow, OpCodeHandler?[] tableHigh)
	{
		if (tableLow.Length != 8)
		{
			throw new ArgumentOutOfRangeException("tableLow");
		}
		if (tableHigh.Length != 64)
		{
			throw new ArgumentOutOfRangeException("tableHigh");
		}
		this.tableLow = tableLow;
		this.tableHigh = tableHigh;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler opCodeHandler = ((decoder.state.mod != 3) ? tableLow[decoder.state.reg] : (tableHigh[decoder.state.modrm & 0x3F] ?? tableLow[decoder.state.reg]));
		opCodeHandler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Group : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] groupHandlers;

	public OpCodeHandler_Group(OpCodeHandler[] groupHandlers)
	{
		this.groupHandlers = groupHandlers ?? throw new ArgumentNullException("groupHandlers");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		groupHandlers[decoder.state.reg].Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_AnotherTable : OpCodeHandler
{
	private readonly OpCodeHandler[] otherTable;

	public OpCodeHandler_AnotherTable(OpCodeHandler[] otherTable)
	{
		this.otherTable = otherTable ?? throw new ArgumentNullException("otherTable");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.DecodeTable(otherTable, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MandatoryPrefix2 : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_MandatoryPrefix2(OpCodeHandler handler)
		: this(handler, OpCodeHandler_Invalid.Instance, OpCodeHandler_Invalid.Instance, OpCodeHandler_Invalid.Instance)
	{
	}

	public OpCodeHandler_MandatoryPrefix2(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
	{
		handlers = new OpCodeHandler[4]
		{
			handler ?? throw new ArgumentNullException("handler"),
			handler66 ?? throw new ArgumentNullException("handler66"),
			handlerF3 ?? throw new ArgumentNullException("handlerF3"),
			handlerF2 ?? throw new ArgumentNullException("handlerF2")
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		handlers[(uint)decoder.state.zs.mandatoryPrefix].Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MandatoryPrefix2_NoModRM : OpCodeHandler
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_MandatoryPrefix2_NoModRM(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
	{
		handlers = new OpCodeHandler[4]
		{
			handler ?? throw new ArgumentNullException("handler"),
			handler66 ?? throw new ArgumentNullException("handler66"),
			handlerF3 ?? throw new ArgumentNullException("handlerF3"),
			handlerF2 ?? throw new ArgumentNullException("handlerF2")
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		handlers[(uint)decoder.state.zs.mandatoryPrefix].Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_W : OpCodeHandlerModRM
{
	private readonly OpCodeHandler handlerW0;

	private readonly OpCodeHandler handlerW1;

	public OpCodeHandler_W(OpCodeHandler handlerW0, OpCodeHandler handlerW1)
	{
		this.handlerW0 = handlerW0 ?? throw new ArgumentNullException("handlerW0");
		this.handlerW1 = handlerW1 ?? throw new ArgumentNullException("handlerW1");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		(((decoder.state.zs.flags & StateFlags.W) != 0) ? handlerW1 : handlerW0).Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Bitness : OpCodeHandler
{
	private readonly OpCodeHandler handler1632;

	private readonly OpCodeHandler handler64;

	public OpCodeHandler_Bitness(OpCodeHandler handler1632, OpCodeHandler handler64)
	{
		this.handler1632 = handler1632;
		this.handler64 = handler64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler opCodeHandler = ((!decoder.is64bMode) ? handler1632 : handler64);
		if (opCodeHandler.HasModRM)
		{
			decoder.ReadModRM();
		}
		opCodeHandler.Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Bitness_DontReadModRM : OpCodeHandlerModRM
{
	private readonly OpCodeHandler handler1632;

	private readonly OpCodeHandler handler64;

	public OpCodeHandler_Bitness_DontReadModRM(OpCodeHandler handler1632, OpCodeHandler handler64)
	{
		this.handler1632 = handler1632;
		this.handler64 = handler64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler opCodeHandler = ((!decoder.is64bMode) ? handler1632 : handler64);
		opCodeHandler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RM : OpCodeHandlerModRM
{
	private readonly OpCodeHandler reg;

	private readonly OpCodeHandler mem;

	public OpCodeHandler_RM(OpCodeHandler reg, OpCodeHandler mem)
	{
		this.reg = reg ?? throw new ArgumentNullException("reg");
		this.mem = mem ?? throw new ArgumentNullException("mem");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		((decoder.state.mod == 3) ? reg : mem).Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal readonly struct HandlerOptions
{
	public readonly OpCodeHandler handler;

	public readonly DecoderOptions options;

	public HandlerOptions(OpCodeHandler handler, DecoderOptions options)
	{
		this.handler = handler;
		this.options = options;
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Options1632 : OpCodeHandler
{
	private readonly OpCodeHandler defaultHandler;

	private readonly HandlerOptions[] infos;

	private readonly DecoderOptions infoOptions;

	public OpCodeHandler_Options1632(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1)
	{
		this.defaultHandler = defaultHandler ?? throw new ArgumentNullException("defaultHandler");
		infos = new HandlerOptions[1]
		{
			new HandlerOptions(handler1, options1)
		};
		infoOptions = options1;
	}

	public OpCodeHandler_Options1632(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1, OpCodeHandler handler2, DecoderOptions options2)
	{
		this.defaultHandler = defaultHandler ?? throw new ArgumentNullException("defaultHandler");
		infos = new HandlerOptions[2]
		{
			new HandlerOptions(handler1 ?? throw new ArgumentNullException("handler1"), options1),
			new HandlerOptions(handler2 ?? throw new ArgumentNullException("handler2"), options2)
		};
		infoOptions = options1 | options2;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler handler = defaultHandler;
		DecoderOptions options = decoder.options;
		if (!decoder.is64bMode && (decoder.options & infoOptions) != 0)
		{
			HandlerOptions[] array = infos;
			for (int i = 0; i < array.Length; i++)
			{
				HandlerOptions handlerOptions = array[i];
				if ((options & handlerOptions.options) != 0)
				{
					handler = handlerOptions.handler;
					break;
				}
			}
		}
		if (handler.HasModRM)
		{
			decoder.ReadModRM();
		}
		handler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Options : OpCodeHandler
{
	private readonly OpCodeHandler defaultHandler;

	private readonly HandlerOptions[] infos;

	private readonly DecoderOptions infoOptions;

	public OpCodeHandler_Options(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1)
	{
		this.defaultHandler = defaultHandler ?? throw new ArgumentNullException("defaultHandler");
		infos = new HandlerOptions[1]
		{
			new HandlerOptions(handler1, options1)
		};
		infoOptions = options1;
	}

	public OpCodeHandler_Options(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1, OpCodeHandler handler2, DecoderOptions options2)
	{
		this.defaultHandler = defaultHandler ?? throw new ArgumentNullException("defaultHandler");
		infos = new HandlerOptions[2]
		{
			new HandlerOptions(handler1 ?? throw new ArgumentNullException("handler1"), options1),
			new HandlerOptions(handler2 ?? throw new ArgumentNullException("handler2"), options2)
		};
		infoOptions = options1 | options2;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler handler = defaultHandler;
		DecoderOptions options = decoder.options;
		if ((decoder.options & infoOptions) != 0)
		{
			HandlerOptions[] array = infos;
			for (int i = 0; i < array.Length; i++)
			{
				HandlerOptions handlerOptions = array[i];
				if ((options & handlerOptions.options) != 0)
				{
					handler = handlerOptions.handler;
					break;
				}
			}
		}
		if (handler.HasModRM)
		{
			decoder.ReadModRM();
		}
		handler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Options_DontReadModRM : OpCodeHandlerModRM
{
	private readonly OpCodeHandler defaultHandler;

	private readonly HandlerOptions[] infos;

	public OpCodeHandler_Options_DontReadModRM(OpCodeHandler defaultHandler, OpCodeHandler handler1, DecoderOptions options1)
	{
		this.defaultHandler = defaultHandler ?? throw new ArgumentNullException("defaultHandler");
		infos = new HandlerOptions[1]
		{
			new HandlerOptions(handler1, options1)
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler handler = defaultHandler;
		DecoderOptions options = decoder.options;
		HandlerOptions[] array = infos;
		for (int i = 0; i < array.Length; i++)
		{
			HandlerOptions handlerOptions = array[i];
			if ((options & handlerOptions.options) != 0)
			{
				handler = handlerOptions.handler;
				break;
			}
		}
		handler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel.DecoderInternal;

internal static class OpCodeHandlersTables_EVEX
{
	internal static readonly OpCodeHandler[] Handlers_0F;

	internal static readonly OpCodeHandler[] Handlers_0F38;

	internal static readonly OpCodeHandler[] Handlers_0F3A;

	internal static readonly OpCodeHandler[] Handlers_MAP5;

	internal static readonly OpCodeHandler[] Handlers_MAP6;

	private const int MaxIdNames = 10;

	private const uint Handlers_0FIndex = 9u;

	private const uint Handlers_0F38Index = 5u;

	private const uint Handlers_0F3AIndex = 6u;

	private const uint Handlers_MAP5Index = 7u;

	private const uint Handlers_MAP6Index = 8u;

	static OpCodeHandlersTables_EVEX()
	{
		EvexOpCodeHandlerReader handlerReader = new EvexOpCodeHandlerReader();
		TableDeserializer tableDeserializer = new TableDeserializer(handlerReader, 10, GetSerializedTables());
		tableDeserializer.Deserialize();
		Handlers_0F = tableDeserializer.GetTable(9u);
		Handlers_0F38 = tableDeserializer.GetTable(5u);
		Handlers_0F3A = tableDeserializer.GetTable(6u);
		Handlers_MAP5 = tableDeserializer.GetTable(7u);
		Handlers_MAP6 = tableDeserializer.GetTable(8u);
	}

	private static ReadOnlySpan<byte> GetSerializedTables()
	{
		return new byte[12430]
		{
			1, 8, 1, 8, 0, 9, 16, 77, 227, 12,
			4, 16, 109, 228, 12, 5, 16, 141, 229, 12,
			6, 0, 0, 0, 8, 0, 9, 16, 77, 234,
			12, 4, 16, 109, 235, 12, 5, 16, 141, 236,
			12, 6, 0, 0, 0, 8, 0, 9, 16, 77,
			241, 12, 4, 16, 109, 242, 12, 5, 16, 141,
			243, 12, 6, 0, 0, 0, 1, 8, 8, 0,
			7, 9, 17, 77, 244, 12, 8, 17, 109, 245,
			12, 9, 17, 141, 246, 12, 10, 9, 17, 77,
			247, 12, 11, 17, 109, 248, 12, 12, 17, 141,
			249, 12, 13, 0, 0, 8, 0, 7, 9, 17,
			77, 250, 12, 8, 17, 109, 251, 12, 9, 17,
			141, 252, 12, 10, 9, 17, 77, 253, 12, 11,
			17, 109, 254, 12, 12, 17, 141, 255, 12, 13,
			0, 0, 8, 0, 7, 9, 17, 77, 132, 13,
			8, 17, 109, 133, 13, 9, 17, 141, 134, 13,
			10, 0, 0, 0, 0, 8, 0, 7, 9, 17,
			77, 139, 13, 8, 17, 109, 140, 13, 9, 17,
			141, 141, 13, 10, 9, 17, 77, 142, 13, 11,
			17, 109, 143, 13, 12, 17, 141, 144, 13, 13,
			0, 0, 0, 8, 0, 7, 9, 17, 77, 149,
			13, 8, 17, 109, 150, 13, 9, 17, 141, 151,
			13, 10, 0, 0, 0, 0, 1, 8, 1, 8,
			0, 7, 0, 9, 17, 77, 156, 13, 11, 17,
			109, 157, 13, 12, 17, 141, 158, 13, 13, 0,
			0, 8, 0, 9, 18, 77, 162, 13, 4, 18,
			109, 163, 13, 5, 18, 141, 164, 13, 6, 0,
			0, 1, 8, 0, 7, 0, 9, 17, 77, 169,
			13, 11, 17, 109, 170, 13, 12, 17, 141, 171,
			13, 13, 0, 0, 8, 0, 9, 18, 77, 175,
			13, 4, 18, 109, 176, 13, 5, 18, 141, 177,
			13, 6, 0, 0, 1, 8, 0, 8, 0, 7,
			9, 0, 0, 63, 141, 140, 28, 2, 9, 0,
			0, 63, 109, 141, 28, 3, 0, 0, 8, 0,
			7, 9, 0, 0, 63, 141, 142, 28, 2, 9,
			0, 0, 63, 109, 143, 28, 3, 0, 0, 1,
			8, 0, 7, 9, 0, 0, 63, 141, 144, 28,
			2, 9, 0, 0, 63, 109, 145, 28, 3, 0,
			0, 8, 0, 7, 9, 0, 0, 63, 141, 146,
			28, 2, 9, 0, 0, 63, 109, 147, 28, 3,
			0, 0, 0, 1, 8, 0, 8, 0, 7, 9,
			0, 0, 63, 141, 148, 28, 2, 9, 0, 0,
			63, 141, 149, 28, 3, 0, 0, 8, 0, 7,
			9, 0, 0, 63, 141, 150, 28, 2, 9, 0,
			0, 63, 141, 151, 28, 3, 0, 0, 1, 8,
			0, 7, 9, 0, 0, 63, 141, 152, 28, 2,
			9, 0, 0, 63, 141, 153, 28, 3, 0, 0,
			8, 0, 7, 9, 0, 0, 63, 141, 154, 28,
			2, 9, 0, 0, 63, 141, 155, 28, 3, 0,
			0, 0, 1, 128, 2, 8, 0, 9, 41, 77,
			134, 20, 4, 41, 109, 135, 20, 5, 41, 141,
			136, 20, 6, 0, 0, 2, 3, 0, 8, 0,
			9, 41, 77, 153, 20, 4, 41, 109, 154, 20,
			5, 41, 141, 155, 20, 6, 0, 0, 2, 6,
			0, 8, 0, 9, 41, 77, 184, 20, 4, 41,
			109, 185, 20, 5, 41, 141, 186, 20, 6, 0,
			0, 8, 0, 7, 9, 42, 77, 189, 20, 8,
			42, 109, 190, 20, 9, 42, 141, 191, 20, 10,
			0, 0, 0, 8, 0, 7, 0, 9, 42, 77,
			194, 20, 11, 42, 109, 195, 20, 12, 42, 141,
			196, 20, 13, 0, 0, 1, 8, 0, 7, 0,
			9, 41, 77, 202, 20, 4, 41, 109, 203, 20,
			5, 41, 141, 204, 20, 6, 7, 9, 70, 77,
			77, 205, 20, 3, 70, 77, 109, 206, 20, 4,
			70, 109, 141, 207, 20, 5, 0, 0, 8, 0,
			7, 0, 9, 41, 77, 208, 20, 4, 41, 109,
			209, 20, 5, 41, 141, 210, 20, 6, 7, 9,
			70, 77, 77, 211, 20, 2, 70, 77, 109, 212,
			20, 3, 70, 77, 141, 213, 20, 4, 0, 0,
			8, 0, 7, 0, 9, 41, 77, 214, 20, 4,
			41, 109, 215, 20, 5, 41, 141, 216, 20, 6,
			7, 9, 70, 77, 77, 217, 20, 1, 70, 77,
			109, 218, 20, 2, 70, 77, 141, 219, 20, 3,
			0, 0, 8, 0, 7, 10, 58, 77, 77, 222,
			20, 3, 1, 0, 58, 109, 77, 223, 20, 4,
			1, 0, 58, 141, 109, 224, 20, 5, 1, 0,
			0, 7, 9, 70, 77, 77, 225, 20, 3, 70,
			77, 109, 226, 20, 4, 70, 109, 141, 227, 20,
			5, 0, 0, 8, 0, 7, 9, 42, 77, 229,
			20, 8, 42, 109, 230, 20, 9, 42, 141, 231,
			20, 10, 9, 42, 77, 232, 20, 11, 42, 109,
			233, 20, 12, 42, 141, 234, 20, 13, 7, 9,
			70, 77, 77, 235, 20, 2, 70, 77, 109, 236,
			20, 3, 70, 77, 141, 237, 20, 4, 0, 0,
			8, 0, 7, 9, 42, 77, 239, 20, 8, 42,
			109, 240, 20, 9, 42, 141, 241, 20, 10, 9,
			42, 77, 242, 20, 11, 42, 109, 243, 20, 12,
			42, 141, 244, 20, 13, 7, 9, 70, 77, 77,
			245, 20, 3, 70, 77, 109, 246, 20, 4, 70,
			109, 141, 247, 20, 5, 0, 0, 8, 0, 7,
			9, 0, 42, 109, 249, 20, 9, 42, 141, 250,
			20, 10, 9, 0, 42, 109, 251, 20, 12, 42,
			141, 252, 20, 13, 0, 0, 0, 8, 0, 7,
			9, 54, 77, 77, 130, 21, 2, 54, 109, 77,
			131, 21, 2, 54, 141, 77, 132, 21, 2, 0,
			0, 0, 8, 0, 7, 9, 0, 54, 109, 77,
			134, 21, 3, 54, 141, 77, 135, 21, 3, 9,
			0, 54, 109, 77, 136, 21, 3, 54, 141, 77,
			137, 21, 3, 0, 0, 8, 0, 7, 9, 0,
			51, 109, 139, 21, 4, 51, 141, 140, 21, 4,
			9, 0, 51, 109, 141, 21, 4, 51, 141, 142,
			21, 4, 0, 0, 8, 0, 7, 9, 0, 0,
			51, 141, 143, 21, 5, 9, 0, 0, 51, 141,
			144, 21, 5, 0, 0, 8, 0, 9, 52, 77,
			149, 21, 4, 52, 109, 150, 21, 5, 52, 141,
			151, 21, 6, 0, 0, 8, 0, 9, 52, 77,
			156, 21, 4, 52, 109, 157, 21, 5, 52, 141,
			158, 21, 6, 0, 0, 8, 0, 7, 9, 53,
			77, 163, 21, 8, 53, 109, 164, 21, 9, 53,
			141, 165, 21, 10, 0, 0, 0, 8, 0, 7,
			0, 9, 53, 77, 166, 21, 11, 53, 109, 167,
			21, 12, 53, 141, 168, 21, 13, 0, 0, 8,
			0, 9, 54, 77, 77, 172, 21, 3, 54, 109,
			77, 173, 21, 4, 54, 141, 109, 174, 21, 5,
			7, 9, 70, 77, 77, 175, 21, 3, 70, 77,
			109, 176, 21, 4, 70, 109, 141, 177, 21, 5,
			0, 0, 8, 0, 9, 54, 77, 77, 181, 21,
			2, 54, 109, 77, 182, 21, 3, 54, 141, 77,
			183, 21, 4, 7, 9, 70, 77, 77, 184, 21,
			2, 70, 77, 109, 185, 21, 3, 70, 77, 141,
			186, 21, 4, 0, 0, 8, 0, 9, 54, 77,
			77, 190, 21, 1, 54, 109, 77, 191, 21, 2,
			54, 141, 77, 192, 21, 3, 7, 9, 70, 77,
			77, 193, 21, 1, 70, 77, 109, 194, 21, 2,
			70, 77, 141, 195, 21, 3, 0, 0, 8, 0,
			9, 54, 77, 77, 199, 21, 3, 54, 109, 77,
			200, 21, 4, 54, 141, 109, 201, 21, 5, 7,
			9, 70, 77, 77, 202, 21, 3, 70, 77, 109,
			203, 21, 4, 70, 109, 141, 204, 21, 5, 0,
			0, 8, 0, 9, 54, 77, 77, 208, 21, 2,
			54, 109, 77, 209, 21, 3, 54, 141, 77, 210,
			21, 4, 7, 9, 70, 77, 77, 211, 21, 2,
			70, 77, 109, 212, 21, 3, 70, 77, 141, 213,
			21, 4, 0, 0, 8, 0, 7, 9, 54, 77,
			77, 217, 21, 3, 54, 109, 77, 218, 21, 4,
			54, 141, 109, 219, 21, 5, 0, 7, 9, 70,
			77, 77, 220, 21, 3, 70, 77, 109, 221, 21,
			4, 70, 109, 141, 222, 21, 5, 0, 0, 8,
			0, 7, 9, 19, 77, 223, 21, 4, 19, 109,
			224, 21, 5, 19, 141, 225, 21, 6, 9, 19,
			77, 226, 21, 4, 19, 109, 227, 21, 5, 19,
			141, 228, 21, 6, 7, 9, 19, 77, 229, 21,
			4, 19, 109, 230, 21, 5, 19, 141, 231, 21,
			6, 9, 19, 77, 232, 21, 4, 19, 109, 233,
			21, 5, 19, 141, 234, 21, 6, 0, 8, 0,
			7, 9, 20, 77, 235, 21, 8, 20, 109, 236,
			21, 9, 20, 141, 237, 21, 10, 9, 20, 77,
			238, 21, 11, 20, 109, 239, 21, 12, 20, 141,
			240, 21, 13, 7, 9, 20, 77, 241, 21, 8,
			20, 109, 242, 21, 9, 20, 141, 243, 21, 10,
			9, 20, 77, 244, 21, 11, 20, 109, 245, 21,
			12, 20, 141, 246, 21, 13, 0, 8, 0, 7,
			0, 9, 42, 77, 250, 21, 11, 42, 109, 251,
			21, 12, 42, 141, 252, 21, 13, 7, 9, 36,
			77, 253, 21, 36, 109, 254, 21, 36, 141, 255,
			21, 9, 36, 77, 128, 22, 36, 109, 129, 22,
			36, 141, 130, 22, 0, 8, 0, 7, 0, 9,
			20, 77, 134, 22, 11, 20, 109, 135, 22, 12,
			20, 141, 136, 22, 13, 7, 9, 28, 77, 137,
			22, 28, 109, 138, 22, 28, 141, 139, 22, 9,
			28, 77, 140, 22, 28, 109, 141, 22, 28, 141,
			142, 22, 0, 8, 0, 7, 9, 62, 77, 146,
			22, 4, 62, 109, 147, 22, 5, 62, 141, 148,
			22, 6, 0, 7, 0, 9, 36, 77, 149, 22,
			36, 109, 150, 22, 36, 141, 151, 22, 0, 8,
			0, 7, 9, 42, 77, 155, 22, 8, 42, 109,
			156, 22, 9, 42, 141, 157, 22, 10, 0, 0,
			0, 8, 0, 7, 10, 45, 77, 160, 22, 8,
			0, 45, 109, 161, 22, 9, 0, 45, 141, 162,
			22, 10, 0, 10, 45, 77, 163, 22, 11, 0,
			45, 109, 164, 22, 12, 0, 45, 141, 165, 22,
			13, 0, 0, 0, 8, 0, 7, 44, 77, 168,
			22, 2, 0, 44, 77, 169, 22, 3, 0, 0,
			0, 1, 8, 0, 9, 54, 77, 77, 177, 22,
			3, 54, 109, 77, 178, 22, 4, 54, 141, 109,
			179, 22, 5, 7, 9, 70, 77, 77, 180, 22,
			3, 70, 77, 109, 181, 22, 4, 70, 109, 141,
			182, 22, 5, 0, 0, 8, 0, 9, 54, 77,
			77, 186, 22, 2, 54, 109, 77, 187, 22, 3,
			54, 141, 77, 188, 22, 4, 7, 9, 70, 77,
			77, 189, 22, 2, 70, 77, 109, 190, 22, 3,
			70, 77, 141, 191, 22, 4, 0, 0, 8, 0,
			9, 54, 77, 77, 195, 22, 1, 54, 109, 77,
			196, 22, 2, 54, 141, 77, 197, 22, 3, 7,
			9, 70, 77, 77, 198, 22, 1, 70, 77, 109,
			199, 22, 2, 70, 77, 141, 200, 22, 3, 0,
			0, 8, 0, 9, 54, 77, 77, 204, 22, 3,
			54, 109, 77, 205, 22, 4, 54, 141, 109, 206,
			22, 5, 7, 9, 70, 77, 77, 207, 22, 3,
			70, 77, 109, 208, 22, 4, 70, 109, 141, 209,
			22, 5, 0, 0, 8, 0, 9, 54, 77, 77,
			213, 22, 2, 54, 109, 77, 214, 22, 3, 54,
			141, 77, 215, 22, 4, 7, 9, 70, 77, 77,
			216, 22, 2, 70, 77, 109, 217, 22, 3, 70,
			77, 141, 218, 22, 4, 0, 0, 8, 0, 7,
			9, 54, 77, 77, 222, 22, 3, 54, 109, 77,
			223, 22, 4, 54, 141, 109, 224, 22, 5, 0,
			7, 9, 70, 77, 77, 225, 22, 3, 70, 77,
			109, 226, 22, 4, 70, 109, 141, 227, 22, 5,
			0, 0, 8, 0, 7, 9, 0, 42, 109, 229,
			22, 9, 42, 141, 230, 22, 10, 9, 0, 42,
			109, 231, 22, 12, 42, 141, 232, 22, 13, 0,
			0, 8, 0, 7, 0, 9, 20, 77, 236, 22,
			11, 20, 109, 237, 22, 12, 20, 141, 238, 22,
			13, 0, 0, 8, 0, 9, 41, 77, 242, 22,
			4, 41, 109, 243, 22, 5, 41, 141, 244, 22,
			6, 7, 9, 36, 77, 245, 22, 36, 109, 246,
			22, 36, 141, 247, 22, 9, 36, 77, 248, 22,
			36, 109, 249, 22, 36, 141, 250, 22, 0, 8,
			0, 7, 9, 42, 77, 254, 22, 8, 42, 109,
			255, 22, 9, 42, 141, 128, 23, 10, 9, 42,
			77, 129, 23, 11, 42, 109, 130, 23, 12, 42,
			141, 131, 23, 13, 7, 9, 28, 77, 132, 23,
			28, 109, 133, 23, 28, 141, 134, 23, 9, 28,
			77, 135, 23, 28, 109, 136, 23, 28, 141, 137,
			23, 0, 8, 0, 9, 41, 77, 141, 23, 4,
			41, 109, 142, 23, 5, 41, 141, 143, 23, 6,
			7, 9, 36, 77, 144, 23, 36, 109, 145, 23,
			36, 141, 146, 23, 0, 0, 8, 0, 7, 9,
			42, 77, 150, 23, 8, 42, 109, 151, 23, 9,
			42, 141, 152, 23, 10, 9, 42, 77, 153, 23,
			11, 42, 109, 154, 23, 12, 42, 141, 155, 23,
			13, 0, 0, 8, 0, 9, 41, 77, 159, 23,
			4, 41, 109, 160, 23, 5, 41, 141, 161, 23,
			6, 0, 0, 8, 0, 7, 9, 42, 77, 165,
			23, 8, 42, 109, 166, 23, 9, 42, 141, 167,
			23, 10, 9, 42, 77, 168, 23, 11, 42, 109,
			169, 23, 12, 42, 141, 170, 23, 13, 0, 0,
			8, 0, 9, 41, 77, 174, 23, 4, 41, 109,
			175, 23, 5, 41, 141, 176, 23, 6, 0, 0,
			8, 0, 7, 9, 42, 77, 180, 23, 8, 42,
			109, 181, 23, 9, 42, 141, 182, 23, 10, 9,
			42, 77, 183, 23, 11, 42, 109, 184, 23, 12,
			42, 141, 185, 23, 13, 0, 0, 8, 0, 7,
			9, 42, 77, 189, 23, 8, 42, 109, 190, 23,
			9, 42, 141, 191, 23, 10, 9, 42, 77, 192,
			23, 11, 42, 109, 193, 23, 12, 42, 141, 194,
			23, 13, 0, 0, 0, 8, 0, 7, 10, 56,
			77, 197, 23, 8, 1, 56, 109, 198, 23, 9,
			1, 56, 141, 199, 23, 10, 1, 10, 56, 77,
			200, 23, 11, 1, 56, 109, 201, 23, 12, 1,
			56, 141, 202, 23, 13, 1, 0, 0, 8, 0,
			7, 44, 77, 203, 23, 2, 1, 44, 77, 204,
			23, 3, 1, 0, 0, 8, 0, 7, 9, 53,
			77, 205, 23, 8, 53, 109, 206, 23, 9, 53,
			141, 207, 23, 10, 9, 53, 77, 208, 23, 11,
			53, 109, 209, 23, 12, 53, 141, 210, 23, 13,
			0, 0, 8, 0, 7, 9, 42, 77, 215, 23,
			8, 42, 109, 216, 23, 9, 42, 141, 217, 23,
			10, 9, 42, 77, 218, 23, 11, 42, 109, 219,
			23, 12, 42, 141, 220, 23, 13, 0, 0, 8,
			0, 7, 9, 42, 77, 223, 23, 8, 42, 109,
			224, 23, 9, 42, 141, 225, 23, 10, 9, 42,
			77, 226, 23, 11, 42, 109, 227, 23, 12, 42,
			141, 228, 23, 13, 0, 0, 8, 0, 7, 9,
			42, 77, 233, 23, 8, 42, 109, 234, 23, 9,
			42, 141, 235, 23, 10, 9, 42, 77, 236, 23,
			11, 42, 109, 237, 23, 12, 42, 141, 238, 23,
			13, 0, 0, 2, 4, 0, 8, 0, 7, 9,
			53, 77, 239, 23, 8, 53, 109, 240, 23, 9,
			53, 141, 241, 23, 10, 9, 53, 77, 242, 23,
			11, 53, 109, 243, 23, 12, 53, 141, 244, 23,
			13, 0, 0, 8, 0, 7, 41, 77, 245, 23,
			2, 41, 77, 246, 23, 3, 0, 0, 8, 0,
			7, 9, 53, 77, 247, 23, 8, 53, 109, 248,
			23, 9, 53, 141, 249, 23, 10, 9, 53, 77,
			250, 23, 11, 53, 109, 251, 23, 12, 53, 141,
			252, 23, 13, 0, 0, 8, 0, 7, 41, 77,
			253, 23, 2, 41, 77, 254, 23, 3, 0, 0,
			8, 0, 7, 9, 42, 77, 255, 23, 8, 42,
			109, 128, 24, 9, 42, 141, 129, 24, 10, 0,
			0, 0, 8, 0, 7, 9, 42, 77, 130, 24,
			8, 42, 109, 131, 24, 9, 42, 141, 132, 24,
			10, 0, 0, 0, 8, 0, 7, 9, 42, 77,
			133, 24, 8, 42, 109, 134, 24, 9, 42, 141,
			135, 24, 10, 0, 7, 9, 42, 77, 136, 24,
			8, 42, 109, 137, 24, 9, 42, 141, 138, 24,
			10, 0, 7, 9, 0, 0, 40, 141, 139, 24,
			4, 0, 8, 0, 7, 9, 42, 77, 140, 24,
			8, 42, 109, 141, 24, 9, 42, 141, 142, 24,
			10, 0, 0, 7, 9, 0, 0, 40, 141, 143,
			24, 4, 0, 8, 0, 7, 9, 52, 77, 144,
			24, 4, 52, 109, 145, 24, 5, 52, 141, 146,
			24, 6, 9, 52, 77, 147, 24, 4, 52, 109,
			148, 24, 5, 52, 141, 149, 24, 6, 0, 0,
			8, 0, 7, 9, 53, 77, 150, 24, 8, 53,
			109, 151, 24, 9, 53, 141, 152, 24, 10, 9,
			53, 77, 153, 24, 11, 53, 109, 154, 24, 12,
			53, 141, 155, 24, 13, 0, 0, 1, 8, 0,
			7, 9, 54, 77, 77, 158, 24, 2, 54, 109,
			77, 159, 24, 2, 54, 141, 77, 160, 24, 2,
			0, 0, 0, 8, 0, 7, 9, 54, 77, 77,
			163, 24, 3, 54, 109, 77, 164, 24, 3, 54,
			141, 77, 165, 24, 3, 9, 54, 77, 77, 166,
			24, 3, 54, 109, 77, 167, 24, 3, 54, 141,
			77, 168, 24, 3, 0, 0, 8, 0, 7, 9,
			0, 51, 109, 170, 24, 4, 51, 141, 171, 24,
			4, 9, 0, 51, 109, 172, 24, 4, 51, 141,
			173, 24, 4, 0, 0, 8, 0, 7, 9, 0,
			0, 51, 141, 174, 24, 5, 9, 0, 0, 51,
			141, 175, 24, 5, 0, 0, 2, 6, 0, 8,
			0, 7, 9, 52, 77, 176, 24, 0, 52, 109,
			177, 24, 0, 52, 141, 178, 24, 0, 9, 52,
			77, 179, 24, 1, 52, 109, 180, 24, 1, 52,
			141, 181, 24, 1, 0, 0, 8, 0, 7, 9,
			69, 77, 182, 24, 0, 69, 109, 183, 24, 0,
			69, 141, 184, 24, 0, 9, 69, 77, 185, 24,
			1, 69, 109, 186, 24, 1, 69, 141, 187, 24,
			1, 0, 0, 8, 0, 7, 9, 42, 77, 188,
			24, 8, 42, 109, 189, 24, 9, 42, 141, 190,
			24, 10, 9, 42, 77, 191, 24, 11, 42, 109,
			192, 24, 12, 42, 141, 193, 24, 13, 0, 0,
			8, 0, 7, 9, 42, 77, 194, 24, 8, 42,
			109, 195, 24, 9, 42, 141, 196, 24, 10, 9,
			42, 77, 197, 24, 11, 42, 109, 198, 24, 12,
			42, 141, 199, 24, 13, 0, 0, 8, 0, 7,
			9, 41, 77, 200, 24, 4, 41, 109, 201, 24,
			5, 41, 141, 202, 24, 6, 9, 41, 77, 203,
			24, 4, 41, 109, 204, 24, 5, 41, 141, 205,
			24, 6, 0, 0, 0, 8, 0, 0, 0, 7,
			9, 27, 77, 206, 24, 8, 27, 109, 207, 24,
			9, 27, 141, 208, 24, 10, 9, 27, 77, 209,
			24, 11, 27, 109, 210, 24, 12, 27, 141, 211,
			24, 13, 2, 7, 0, 8, 0, 7, 0, 9,
			41, 77, 212, 24, 4, 41, 109, 213, 24, 5,
			41, 141, 214, 24, 6, 0, 0, 8, 0, 7,
			9, 42, 77, 215, 24, 8, 42, 109, 216, 24,
			9, 42, 141, 217, 24, 10, 9, 42, 77, 218,
			24, 11, 42, 109, 219, 24, 12, 42, 141, 220,
			24, 13, 0, 0, 8, 0, 7, 0, 9, 41,
			77, 221, 24, 4, 41, 109, 222, 24, 5, 41,
			141, 223, 24, 6, 7, 9, 55, 77, 77, 224,
			24, 8, 55, 77, 109, 225, 24, 9, 55, 109,
			141, 226, 24, 10, 0, 7, 9, 42, 77, 227,
			24, 8, 42, 109, 228, 24, 9, 42, 141, 229,
			24, 10, 0, 8, 0, 7, 9, 42, 77, 230,
			24, 8, 42, 109, 231, 24, 9, 42, 141, 232,
			24, 10, 9, 42, 77, 233, 24, 11, 42, 109,
			234, 24, 12, 42, 141, 235, 24, 13, 0, 0,
			0, 8, 0, 7, 9, 41, 77, 236, 24, 4,
			41, 109, 237, 24, 5, 41, 141, 238, 24, 6,
			9, 41, 77, 239, 24, 4, 41, 109, 240, 24,
			5, 41, 141, 241, 24, 6, 0, 0, 8, 0,
			7, 9, 42, 77, 242, 24, 8, 42, 109, 243,
			24, 9, 42, 141, 244, 24, 10, 9, 42, 77,
			245, 24, 11, 42, 109, 246, 24, 12, 42, 141,
			247, 24, 13, 0, 0, 8, 0, 7, 9, 42,
			77, 248, 24, 8, 42, 109, 249, 24, 9, 42,
			141, 250, 24, 10, 9, 42, 77, 251, 24, 11,
			42, 109, 252, 24, 12, 42, 141, 253, 24, 13,
			0, 0, 8, 0, 7, 9, 54, 77, 77, 128,
			25, 0, 54, 109, 77, 129, 25, 0, 54, 141,
			77, 130, 25, 0, 0, 0, 0, 8, 0, 7,
			9, 54, 77, 77, 133, 25, 1, 54, 109, 77,
			134, 25, 1, 54, 141, 77, 135, 25, 1, 0,
			0, 0, 8, 0, 7, 9, 38, 77, 136, 25,
			38, 109, 137, 25, 38, 141, 138, 25, 0, 0,
			0, 8, 0, 7, 9, 38, 77, 139, 25, 38,
			109, 140, 25, 38, 141, 141, 25, 0, 0, 0,
			8, 0, 9, 39, 77, 142, 25, 145, 25, 39,
			109, 143, 25, 146, 25, 39, 141, 144, 25, 147,
			25, 0, 0, 8, 0, 7, 9, 41, 77, 148,
			25, 4, 41, 109, 149, 25, 5, 41, 141, 150,
			25, 6, 9, 41, 77, 151, 25, 4, 41, 109,
			152, 25, 5, 41, 141, 153, 25, 6, 0, 0,
			8, 0, 7, 9, 42, 77, 154, 25, 8, 42,
			109, 155, 25, 9, 42, 141, 156, 25, 10, 9,
			42, 77, 157, 25, 11, 42, 109, 158, 25, 12,
			42, 141, 159, 25, 13, 0, 0, 8, 0, 7,
			9, 42, 77, 160, 25, 8, 42, 109, 161, 25,
			9, 42, 141, 162, 25, 10, 9, 42, 77, 163,
			25, 11, 42, 109, 164, 25, 12, 42, 141, 165,
			25, 13, 0, 0, 2, 3, 0, 8, 0, 7,
			0, 9, 42, 77, 172, 25, 11, 42, 109, 173,
			25, 12, 42, 141, 174, 25, 13, 0, 0, 2,
			4, 0, 8, 0, 7, 9, 52, 77, 175, 25,
			2, 52, 109, 176, 25, 2, 52, 141, 177, 25,
			2, 9, 52, 77, 178, 25, 3, 52, 109, 179,
			25, 3, 52, 141, 180, 25, 3, 0, 0, 8,
			0, 7, 9, 52, 77, 181, 25, 2, 52, 109,
			182, 25, 2, 52, 141, 183, 25, 2, 9, 52,
			77, 184, 25, 3, 52, 109, 185, 25, 3, 52,
			141, 186, 25, 3, 0, 0, 8, 0, 7, 9,
			69, 77, 187, 25, 2, 69, 109, 188, 25, 2,
			69, 141, 189, 25, 2, 9, 69, 77, 190, 25,
			3, 69, 109, 191, 25, 3, 69, 141, 192, 25,
			3, 0, 0, 8, 0, 7, 9, 69, 77, 193,
			25, 2, 69, 109, 194, 25, 2, 69, 141, 195,
			25, 2, 9, 69, 77, 196, 25, 3, 69, 109,
			197, 25, 3, 69, 141, 198, 25, 3, 0, 0,
			0, 8, 0, 7, 9, 41, 77, 203, 25, 4,
			41, 109, 204, 25, 5, 41, 141, 205, 25, 6,
			9, 41, 77, 206, 25, 4, 41, 109, 207, 25,
			5, 41, 141, 208, 25, 6, 0, 0, 0, 8,
			0, 7, 9, 19, 77, 213, 25, 4, 19, 109,
			214, 25, 5, 19, 141, 215, 25, 6, 0, 0,
			0, 8, 0, 7, 9, 37, 77, 77, 220, 25,
			2, 37, 109, 109, 221, 25, 2, 37, 141, 141,
			222, 25, 2, 9, 37, 77, 77, 223, 25, 3,
			37, 109, 77, 224, 25, 3, 37, 141, 109, 225,
			25, 3, 0, 0, 8, 0, 7, 9, 37, 77,
			77, 230, 25, 2, 37, 77, 109, 231, 25, 2,
			37, 109, 141, 232, 25, 2, 9, 37, 77, 77,
			233, 25, 3, 37, 109, 109, 234, 25, 3, 37,
			141, 141, 235, 25, 3, 0, 0, 8, 0, 7,
			9, 37, 77, 77, 240, 25, 2, 37, 109, 109,
			241, 25, 2, 37, 141, 141, 242, 25, 2, 9,
			37, 77, 77, 243, 25, 3, 37, 109, 77, 244,
			25, 3, 37, 141, 109, 245, 25, 3, 0, 0,
			8, 0, 7, 9, 37, 77, 77, 250, 25, 2,
			37, 77, 109, 251, 25, 2, 37, 109, 141, 252,
			25, 2, 9, 37, 77, 77, 253, 25, 3, 37,
			109, 109, 254, 25, 3, 37, 141, 141, 255, 25,
			3, 0, 0, 1, 8, 0, 7, 10, 45, 77,
			132, 26, 8, 0, 45, 109, 133, 26, 9, 0,
			45, 141, 134, 26, 10, 0, 10, 45, 77, 135,
			26, 11, 0, 45, 109, 136, 26, 12, 0, 45,
			141, 137, 26, 13, 0, 0, 0, 8, 0, 7,
			10, 45, 77, 142, 26, 8, 0, 45, 109, 143,
			26, 9, 0, 45, 141, 144, 26, 10, 0, 10,
			45, 77, 145, 26, 11, 0, 45, 109, 146, 26,
			12, 0, 45, 141, 147, 26, 13, 0, 0, 0,
			8, 0, 7, 10, 45, 77, 152, 26, 8, 0,
			45, 109, 153, 26, 9, 0, 45, 141, 154, 26,
			10, 0, 10, 45, 77, 155, 26, 11, 0, 45,
			109, 156, 26, 12, 0, 45, 141, 157, 26, 13,
			0, 0, 0, 8, 0, 7, 44, 77, 160, 26,
			2, 0, 44, 77, 161, 26, 3, 0, 0, 0,
			8, 0, 7, 10, 45, 77, 166, 26, 8, 0,
			45, 109, 167, 26, 9, 0, 45, 141, 168, 26,
			10, 0, 10, 45, 77, 169, 26, 11, 0, 45,
			109, 170, 26, 12, 0, 45, 141, 171, 26, 13,
			0, 0, 7, 9, 0, 0, 40, 141, 172, 26,
			4, 0, 8, 0, 7, 44, 77, 175, 26, 2,
			0, 44, 77, 176, 26, 3, 0, 0, 7, 40,
			77, 177, 26, 4, 0, 8, 0, 7, 10, 45,
			77, 182, 26, 8, 0, 45, 109, 183, 26, 9,
			0, 45, 141, 184, 26, 10, 0, 10, 45, 77,
			185, 26, 11, 0, 45, 109, 186, 26, 12, 0,
			45, 141, 187, 26, 13, 0, 0, 0, 8, 0,
			7, 44, 77, 190, 26, 2, 0, 44, 77, 191,
			26, 3, 0, 0, 0, 8, 0, 7, 10, 45,
			77, 196, 26, 8, 0, 45, 109, 197, 26, 9,
			0, 45, 141, 198, 26, 10, 0, 10, 45, 77,
			199, 26, 11, 0, 45, 109, 200, 26, 12, 0,
			45, 141, 201, 26, 13, 0, 0, 0, 8, 0,
			7, 44, 77, 204, 26, 2, 0, 44, 77, 205,
			26, 3, 0, 0, 0, 8, 0, 7, 9, 64,
			77, 77, 206, 26, 2, 64, 109, 109, 207, 26,
			2, 64, 141, 141, 208, 26, 2, 9, 64, 77,
			77, 209, 26, 3, 64, 77, 109, 210, 26, 3,
			64, 109, 141, 211, 26, 3, 0, 0, 8, 0,
			7, 9, 64, 77, 77, 212, 26, 2, 64, 109,
			77, 213, 26, 2, 64, 141, 109, 214, 26, 2,
			9, 64, 77, 77, 215, 26, 3, 64, 109, 109,
			216, 26, 3, 64, 141, 141, 217, 26, 3, 0,
			0, 8, 0, 7, 9, 64, 77, 77, 218, 26,
			2, 64, 109, 109, 219, 26, 2, 64, 141, 141,
			220, 26, 2, 9, 64, 77, 77, 221, 26, 3,
			64, 77, 109, 222, 26, 3, 64, 109, 141, 223,
			26, 3, 0, 0, 8, 0, 7, 9, 64, 77,
			77, 224, 26, 2, 64, 109, 77, 225, 26, 2,
			64, 141, 109, 226, 26, 2, 9, 64, 77, 77,
			227, 26, 3, 64, 109, 109, 228, 26, 3, 64,
			141, 141, 229, 26, 3, 0, 0, 1, 8, 0,
			7, 10, 45, 77, 234, 26, 8, 0, 45, 109,
			235, 26, 9, 0, 45, 141, 236, 26, 10, 0,
			10, 45, 77, 237, 26, 11, 0, 45, 109, 238,
			26, 12, 0, 45, 141, 239, 26, 13, 0, 0,
			0, 8, 0, 7, 10, 45, 77, 244, 26, 8,
			0, 45, 109, 245, 26, 9, 0, 45, 141, 246,
			26, 10, 0, 10, 45, 77, 247, 26, 11, 0,
			45, 109, 248, 26, 12, 0, 45, 141, 249, 26,
			13, 0, 0, 0, 8, 0, 7, 10, 45, 77,
			254, 26, 8, 0, 45, 109, 255, 26, 9, 0,
			45, 141, 128, 27, 10, 0, 10, 45, 77, 129,
			27, 11, 0, 45, 109, 130, 27, 12, 0, 45,
			141, 131, 27, 13, 0, 0, 0, 8, 0, 7,
			44, 77, 134, 27, 2, 0, 44, 77, 135, 27,
			3, 0, 0, 0, 8, 0, 7, 10, 45, 77,
			140, 27, 8, 0, 45, 109, 141, 27, 9, 0,
			45, 141, 142, 27, 10, 0, 10, 45, 77, 143,
			27, 11, 0, 45, 109, 144, 27, 12, 0, 45,
			141, 145, 27, 13, 0, 0, 7, 9, 0, 0,
			40, 141, 146, 27, 4, 0, 8, 0, 7, 44,
			77, 149, 27, 2, 0, 44, 77, 150, 27, 3,
			0, 0, 7, 40, 77, 151, 27, 4, 0, 8,
			0, 7, 10, 45, 77, 156, 27, 8, 0, 45,
			109, 157, 27, 9, 0, 45, 141, 158, 27, 10,
			0, 10, 45, 77, 159, 27, 11, 0, 45, 109,
			160, 27, 12, 0, 45, 141, 161, 27, 13, 0,
			0, 0, 8, 0, 7, 44, 77, 164, 27, 2,
			0, 44, 77, 165, 27, 3, 0, 0, 0, 8,
			0, 7, 10, 45, 77, 170, 27, 8, 0, 45,
			109, 171, 27, 9, 0, 45, 141, 172, 27, 10,
			0, 10, 45, 77, 173, 27, 11, 0, 45, 109,
			174, 27, 12, 0, 45, 141, 175, 27, 13, 0,
			0, 0, 8, 0, 7, 44, 77, 178, 27, 2,
			0, 44, 77, 179, 27, 3, 0, 0, 0, 2,
			4, 0, 8, 0, 7, 0, 9, 42, 77, 180,
			27, 11, 42, 109, 181, 27, 12, 42, 141, 182,
			27, 13, 0, 0, 8, 0, 7, 0, 9, 42,
			77, 183, 27, 11, 42, 109, 184, 27, 12, 42,
			141, 185, 27, 13, 0, 0, 8, 0, 7, 10,
			45, 77, 190, 27, 8, 0, 45, 109, 191, 27,
			9, 0, 45, 141, 192, 27, 10, 0, 10, 45,
			77, 193, 27, 11, 0, 45, 109, 194, 27, 12,
			0, 45, 141, 195, 27, 13, 0, 0, 0, 8,
			0, 7, 10, 45, 77, 200, 27, 8, 0, 45,
			109, 201, 27, 9, 0, 45, 141, 202, 27, 10,
			0, 10, 45, 77, 203, 27, 11, 0, 45, 109,
			204, 27, 12, 0, 45, 141, 205, 27, 13, 0,
			0, 0, 8, 0, 7, 10, 45, 77, 210, 27,
			8, 0, 45, 109, 211, 27, 9, 0, 45, 141,
			212, 27, 10, 0, 10, 45, 77, 213, 27, 11,
			0, 45, 109, 214, 27, 12, 0, 45, 141, 215,
			27, 13, 0, 0, 0, 8, 0, 7, 44, 77,
			218, 27, 2, 0, 44, 77, 219, 27, 3, 0,
			0, 0, 8, 0, 7, 10, 45, 77, 224, 27,
			8, 0, 45, 109, 225, 27, 9, 0, 45, 141,
			226, 27, 10, 0, 10, 45, 77, 227, 27, 11,
			0, 45, 109, 228, 27, 12, 0, 45, 141, 229,
			27, 13, 0, 0, 0, 8, 0, 7, 44, 77,
			232, 27, 2, 0, 44, 77, 233, 27, 3, 0,
			0, 0, 8, 0, 7, 10, 45, 77, 238, 27,
			8, 0, 45, 109, 239, 27, 9, 0, 45, 141,
			240, 27, 10, 0, 10, 45, 77, 241, 27, 11,
			0, 45, 109, 242, 27, 12, 0, 45, 141, 243,
			27, 13, 0, 0, 0, 8, 0, 7, 44, 77,
			246, 27, 2, 0, 44, 77, 247, 27, 3, 0,
			0, 0, 8, 0, 7, 10, 45, 77, 252, 27,
			8, 0, 45, 109, 253, 27, 9, 0, 45, 141,
			254, 27, 10, 0, 10, 45, 77, 255, 27, 11,
			0, 45, 109, 128, 28, 12, 0, 45, 141, 129,
			28, 13, 0, 0, 0, 8, 0, 7, 44, 77,
			132, 28, 2, 0, 44, 77, 133, 28, 3, 0,
			0, 0, 2, 4, 0, 8, 0, 7, 9, 53,
			77, 134, 28, 8, 53, 109, 135, 28, 9, 53,
			141, 136, 28, 10, 9, 53, 77, 137, 28, 11,
			53, 109, 138, 28, 12, 53, 141, 139, 28, 13,
			0, 0, 0, 6, 4, 3, 6, 4, 4, 8,
			0, 7, 10, 0, 0, 56, 141, 157, 28, 10,
			1, 10, 0, 0, 56, 141, 158, 28, 13, 1,
			0, 0, 0, 8, 0, 7, 10, 0, 0, 56,
			141, 161, 28, 10, 1, 10, 0, 0, 56, 141,
			162, 28, 13, 1, 0, 0, 8, 0, 7, 44,
			77, 164, 28, 2, 1, 44, 77, 165, 28, 3,
			1, 0, 0, 8, 0, 7, 10, 0, 0, 56,
			141, 167, 28, 10, 1, 10, 0, 0, 56, 141,
			168, 28, 13, 1, 0, 0, 8, 0, 7, 44,
			77, 170, 28, 2, 1, 44, 77, 171, 28, 3,
			1, 0, 0, 0, 8, 0, 7, 9, 41, 77,
			175, 28, 4, 41, 109, 176, 28, 5, 41, 141,
			177, 28, 6, 0, 0, 0, 2, 12, 0, 8,
			0, 9, 33, 77, 183, 28, 4, 33, 109, 184,
			28, 5, 33, 141, 185, 28, 6, 0, 0, 8,
			0, 9, 33, 77, 189, 28, 4, 33, 109, 190,
			28, 5, 33, 141, 191, 28, 6, 0, 0, 8,
			0, 9, 33, 77, 195, 28, 4, 33, 109, 196,
			28, 5, 33, 141, 197, 28, 6, 0, 0, 8,
			0, 9, 33, 77, 201, 28, 4, 33, 109, 202,
			28, 5, 33, 141, 203, 28, 6, 0, 0, 2,
			32, 0, 1, 128, 2, 8, 0, 7, 0, 9,
			0, 60, 109, 131, 29, 12, 60, 141, 132, 29,
			13, 0, 0, 8, 0, 7, 0, 9, 0, 60,
			109, 134, 29, 12, 60, 141, 135, 29, 13, 0,
			0, 0, 8, 0, 7, 9, 47, 77, 138, 29,
			8, 47, 109, 139, 29, 9, 47, 141, 140, 29,
			10, 9, 47, 77, 141, 29, 11, 47, 109, 142,
			29, 12, 47, 141, 143, 29, 13, 0, 0, 8,
			0, 7, 9, 60, 77, 146, 29, 8, 60, 109,
			147, 29, 9, 60, 141, 148, 29, 10, 0, 0,
			0, 8, 0, 7, 0, 9, 60, 77, 151, 29,
			11, 60, 109, 152, 29, 12, 60, 141, 153, 29,
			13, 0, 0, 1, 8, 7, 10, 61, 77, 188,
			35, 16, 61, 109, 189, 35, 17, 61, 141, 190,
			35, 18, 0, 7, 10, 61, 77, 158, 29, 8,
			61, 109, 159, 29, 9, 61, 141, 160, 29, 10,
			0, 0, 0, 8, 0, 7, 0, 10, 61, 77,
			164, 29, 11, 61, 109, 165, 29, 12, 61, 141,
			166, 29, 13, 0, 0, 8, 7, 49, 77, 191,
			35, 1, 0, 7, 49, 77, 169, 29, 2, 0,
			0, 0, 8, 0, 7, 0, 49, 77, 172, 29,
			3, 0, 0, 2, 3, 0, 8, 0, 9, 46,
			77, 186, 29, 4, 46, 109, 187, 29, 5, 46,
			141, 188, 29, 6, 0, 0, 2, 4, 0, 8,
			0, 9, 15, 77, 193, 29, 0, 0, 0, 0,
			0, 0, 8, 0, 9, 15, 77, 199, 29, 1,
			1, 0, 0, 0, 0, 8, 0, 9, 15, 77,
			205, 29, 2, 3, 0, 0, 0, 0, 8, 0,
			9, 11, 77, 211, 29, 2, 2, 0, 0, 0,
			0, 8, 0, 7, 9, 0, 48, 109, 109, 77,
			214, 29, 4, 48, 141, 141, 77, 215, 29, 4,
			9, 0, 48, 109, 109, 77, 216, 29, 4, 48,
			141, 141, 77, 217, 29, 4, 0, 0, 8, 0,
			7, 9, 0, 72, 77, 109, 219, 29, 4, 72,
			77, 141, 220, 29, 4, 9, 0, 72, 77, 109,
			221, 29, 4, 72, 77, 141, 222, 29, 4, 0,
			0, 8, 0, 7, 9, 0, 0, 48, 141, 141,
			109, 223, 29, 5, 9, 0, 0, 48, 141, 141,
			109, 224, 29, 5, 0, 0, 8, 0, 7, 9,
			0, 0, 72, 109, 141, 225, 29, 5, 9, 0,
			0, 72, 109, 141, 226, 29, 5, 0, 0, 0,
			8, 0, 7, 10, 73, 77, 77, 229, 29, 3,
			73, 77, 109, 230, 29, 4, 73, 109, 141, 231,
			29, 5, 0, 0, 0, 8, 0, 7, 9, 24,
			77, 232, 29, 8, 24, 109, 233, 29, 9, 24,
			141, 234, 29, 10, 9, 24, 77, 235, 29, 11,
			24, 109, 236, 29, 12, 24, 141, 237, 29, 13,
			0, 0, 8, 0, 7, 9, 24, 77, 238, 29,
			8, 24, 109, 239, 29, 9, 24, 141, 240, 29,
			10, 9, 24, 77, 241, 29, 11, 24, 109, 242,
			29, 12, 24, 141, 243, 29, 13, 0, 0, 8,
			0, 9, 31, 77, 248, 29, 0, 0, 0, 0,
			0, 0, 8, 0, 7, 9, 35, 77, 252, 29,
			2, 0, 0, 0, 0, 0, 8, 0, 9, 31,
			77, 129, 30, 2, 3, 0, 0, 0, 0, 8,
			0, 7, 9, 0, 47, 109, 131, 30, 9, 47,
			141, 132, 30, 10, 9, 0, 47, 109, 133, 30,
			12, 47, 141, 134, 30, 13, 0, 0, 0, 8,
			0, 7, 9, 47, 77, 135, 30, 8, 47, 109,
			136, 30, 9, 47, 141, 137, 30, 10, 9, 47,
			77, 138, 30, 11, 47, 109, 139, 30, 12, 47,
			141, 140, 30, 13, 0, 0, 8, 7, 10, 61,
			77, 156, 35, 16, 61, 109, 157, 35, 17, 61,
			141, 158, 35, 18, 0, 7, 10, 61, 77, 141,
			30, 8, 61, 109, 142, 30, 9, 61, 141, 143,
			30, 10, 10, 61, 77, 144, 30, 11, 61, 109,
			145, 30, 12, 61, 141, 146, 30, 13, 0, 0,
			8, 7, 49, 77, 159, 35, 1, 0, 7, 49,
			77, 147, 30, 2, 49, 77, 148, 30, 3, 0,
			0, 2, 16, 0, 8, 0, 7, 9, 0, 48,
			109, 109, 77, 158, 30, 4, 48, 141, 141, 77,
			159, 30, 4, 9, 0, 48, 109, 109, 77, 160,
			30, 4, 48, 141, 141, 77, 161, 30, 4, 0,
			0, 8, 0, 7, 9, 0, 72, 77, 109, 163,
			30, 4, 72, 77, 141, 164, 30, 4, 9, 0,
			72, 77, 109, 165, 30, 4, 72, 77, 141, 166,
			30, 4, 0, 0, 8, 0, 7, 9, 0, 0,
			48, 141, 141, 109, 167, 30, 5, 9, 0, 0,
			48, 141, 141, 109, 168, 30, 5, 0, 0, 8,
			0, 7, 9, 0, 0, 72, 109, 141, 169, 30,
			5, 9, 0, 0, 72, 109, 141, 170, 30, 5,
			0, 0, 1, 8, 0, 7, 9, 23, 77, 171,
			30, 4, 23, 109, 172, 30, 5, 23, 141, 173,
			30, 6, 9, 23, 77, 174, 30, 4, 23, 109,
			175, 30, 5, 23, 141, 176, 30, 6, 0, 0,
			8, 0, 7, 9, 23, 77, 177, 30, 4, 23,
			109, 178, 30, 5, 23, 141, 179, 30, 6, 9,
			23, 77, 180, 30, 4, 23, 109, 181, 30, 5,
			23, 141, 182, 30, 6, 0, 0, 1, 8, 0,
			7, 9, 46, 77, 191, 30, 4, 46, 109, 192,
			30, 5, 46, 141, 193, 30, 6, 0, 0, 0,
			8, 0, 7, 9, 0, 47, 109, 194, 30, 9,
			47, 141, 195, 30, 10, 9, 0, 47, 109, 196,
			30, 12, 47, 141, 197, 30, 13, 0, 0, 8,
			0, 9, 35, 77, 201, 30, 4, 35, 109, 202,
			30, 5, 35, 141, 203, 30, 6, 0, 0, 2,
			11, 0, 8, 0, 7, 10, 50, 77, 219, 30,
			8, 50, 109, 220, 30, 9, 50, 141, 221, 30,
			10, 10, 50, 77, 222, 30, 11, 50, 109, 223,
			30, 12, 50, 141, 224, 30, 13, 0, 0, 8,
			0, 7, 49, 77, 225, 30, 2, 49, 77, 226,
			30, 3, 0, 0, 1, 8, 0, 7, 10, 50,
			77, 227, 30, 8, 50, 109, 228, 30, 9, 50,
			141, 229, 30, 10, 10, 50, 77, 230, 30, 11,
			50, 109, 231, 30, 12, 50, 141, 232, 30, 13,
			0, 0, 8, 0, 7, 49, 77, 233, 30, 2,
			49, 77, 234, 30, 3, 0, 0, 8, 7, 10,
			61, 77, 184, 35, 16, 61, 109, 185, 35, 17,
			61, 141, 186, 35, 18, 0, 7, 10, 61, 77,
			235, 30, 8, 61, 109, 236, 30, 9, 61, 141,
			237, 30, 10, 10, 61, 77, 238, 30, 11, 61,
			109, 239, 30, 12, 61, 141, 240, 30, 13, 0,
			0, 8, 7, 49, 77, 187, 35, 1, 0, 7,
			49, 77, 241, 30, 2, 49, 77, 242, 30, 3,
			0, 0, 2, 14, 0, 8, 7, 9, 26, 77,
			148, 35, 16, 26, 109, 149, 35, 17, 26, 141,
			150, 35, 18, 0, 7, 9, 26, 77, 143, 31,
			8, 26, 109, 144, 31, 9, 26, 141, 145, 31,
			10, 9, 26, 77, 146, 31, 11, 26, 109, 147,
			31, 12, 26, 141, 148, 31, 13, 0, 0, 8,
			7, 25, 77, 151, 35, 1, 0, 7, 25, 77,
			149, 31, 2, 25, 77, 150, 31, 3, 0, 0,
			2, 8, 0, 8, 0, 7, 0, 9, 46, 77,
			175, 31, 4, 46, 109, 176, 31, 5, 46, 141,
			177, 31, 6, 0, 0, 8, 0, 7, 9, 47,
			77, 178, 31, 8, 47, 109, 179, 31, 9, 47,
			141, 180, 31, 10, 9, 47, 77, 181, 31, 11,
			47, 109, 182, 31, 12, 47, 141, 183, 31, 13,
			0, 0, 8, 0, 7, 0, 9, 46, 77, 184,
			31, 4, 46, 109, 185, 31, 5, 46, 141, 186,
			31, 6, 0, 0, 8, 0, 7, 9, 47, 77,
			187, 31, 8, 47, 109, 188, 31, 9, 47, 141,
			189, 31, 10, 9, 47, 77, 190, 31, 11, 47,
			109, 191, 31, 12, 47, 141, 192, 31, 13, 0,
			0, 2, 78, 0, 8, 7, 10, 22, 77, 231,
			33, 16, 22, 109, 232, 33, 17, 22, 141, 233,
			33, 18, 0, 0, 7, 21, 77, 234, 33, 1,
			0, 0, 2, 11, 0, 8, 0, 7, 0, 9,
			47, 77, 221, 31, 11, 47, 109, 222, 31, 12,
			47, 141, 223, 31, 13, 0, 0, 8, 0, 7,
			0, 9, 47, 77, 227, 31, 11, 47, 109, 228,
			31, 12, 47, 141, 229, 31, 13, 0, 0, 2,
			48, 0, 1, 128, 2, 2, 16, 0, 8, 0,
			0, 7, 5, 41, 77, 170, 35, 0, 52, 77,
			168, 35, 1, 0, 0, 8, 0, 0, 7, 5,
			68, 77, 171, 35, 71, 77, 169, 35, 1, 0,
			0, 0, 2, 11, 0, 8, 7, 44, 77, 153,
			34, 2, 0, 0, 7, 10, 57, 77, 77, 138,
			34, 8, 0, 57, 77, 109, 139, 34, 9, 0,
			57, 109, 141, 140, 34, 10, 0, 0, 0, 0,
			2, 12, 0, 8, 0, 0, 30, 77, 151, 34,
			2, 3, 0, 0, 8, 0, 0, 14, 77, 172,
			34, 1, 1, 0, 8, 0, 0, 14, 77, 146,
			34, 1, 0, 0, 8, 7, 66, 77, 208, 35,
			1, 0, 0, 0, 0, 8, 7, 66, 77, 235,
			33, 1, 0, 0, 0, 0, 2, 33, 0, 8,
			7, 10, 56, 77, 200, 35, 16, 0, 56, 109,
			201, 35, 17, 0, 56, 141, 202, 35, 18, 0,
			0, 0, 7, 44, 77, 203, 35, 1, 0, 0,
			0, 2, 6, 0, 8, 7, 10, 45, 77, 227,
			33, 16, 0, 45, 109, 228, 33, 17, 0, 45,
			141, 229, 33, 18, 0, 0, 0, 7, 44, 77,
			230, 33, 1, 0, 0, 0, 8, 7, 10, 45,
			77, 176, 35, 16, 0, 45, 109, 177, 35, 17,
			0, 45, 141, 178, 35, 18, 0, 0, 0, 7,
			44, 77, 179, 35, 1, 0, 0, 0, 8, 7,
			10, 57, 77, 77, 245, 33, 14, 1, 57, 109,
			77, 246, 33, 15, 1, 57, 141, 77, 247, 33,
			16, 1, 0, 7, 0, 10, 57, 77, 77, 239,
			33, 11, 0, 57, 77, 109, 240, 33, 12, 0,
			57, 77, 141, 241, 33, 13, 0, 7, 44, 77,
			145, 34, 1, 1, 0, 7, 0, 44, 77, 144,
			34, 3, 0, 8, 7, 10, 57, 77, 77, 236,
			33, 8, 0, 57, 77, 109, 237, 33, 9, 0,
			57, 109, 141, 238, 33, 10, 0, 10, 57, 77,
			77, 141, 34, 11, 0, 57, 77, 109, 142, 34,
			12, 0, 57, 77, 141, 143, 34, 13, 0, 7,
			10, 57, 77, 77, 242, 33, 15, 0, 57, 109,
			77, 243, 33, 16, 0, 57, 141, 109, 244, 33,
			17, 0, 0, 7, 10, 57, 77, 77, 154, 34,
			15, 1, 57, 109, 77, 155, 34, 16, 1, 57,
			141, 109, 156, 34, 17, 1, 0, 0, 8, 7,
			10, 45, 77, 204, 35, 16, 0, 45, 109, 205,
			35, 17, 0, 45, 141, 206, 35, 18, 0, 0,
			0, 7, 44, 77, 207, 35, 1, 0, 0, 0,
			8, 7, 10, 45, 77, 164, 35, 16, 1, 45,
			109, 165, 35, 17, 1, 45, 141, 166, 35, 18,
			1, 0, 0, 7, 44, 77, 167, 35, 1, 1,
			0, 0, 8, 7, 10, 45, 77, 190, 34, 16,
			0, 45, 109, 191, 34, 17, 0, 45, 141, 192,
			34, 18, 0, 0, 0, 7, 44, 77, 193, 34,
			1, 0, 0, 0, 8, 7, 10, 45, 77, 160,
			35, 16, 1, 45, 109, 161, 35, 17, 1, 45,
			141, 162, 35, 18, 1, 0, 0, 7, 44, 77,
			163, 35, 1, 1, 0, 0, 2, 14, 0, 8,
			0, 9, 67, 172, 35, 1, 1, 0, 0, 0,
			0, 2, 9, 0, 8, 7, 10, 57, 77, 77,
			160, 34, 15, 1, 57, 109, 77, 161, 34, 16,
			1, 57, 141, 109, 162, 34, 17, 1, 0, 7,
			10, 57, 77, 77, 163, 34, 14, 1, 57, 109,
			77, 164, 34, 15, 1, 57, 141, 77, 165, 34,
			16, 1, 0, 14, 77, 174, 34, 1, 1, 0,
			8, 7, 10, 57, 77, 77, 254, 33, 15, 0,
			57, 109, 77, 255, 33, 16, 0, 57, 141, 109,
			128, 34, 17, 0, 0, 7, 10, 57, 77, 77,
			129, 34, 14, 0, 57, 109, 77, 130, 34, 15,
			0, 57, 141, 77, 131, 34, 16, 0, 0, 14,
			77, 149, 34, 1, 0, 0, 8, 0, 7, 10,
			57, 77, 77, 157, 34, 14, 1, 57, 109, 77,
			158, 34, 15, 1, 57, 141, 77, 159, 34, 16,
			1, 0, 0, 7, 10, 57, 77, 77, 176, 34,
			8, 0, 57, 77, 109, 177, 34, 9, 0, 57,
			109, 141, 178, 34, 10, 0, 10, 57, 77, 77,
			179, 34, 11, 0, 57, 77, 109, 180, 34, 12,
			0, 57, 77, 141, 181, 34, 13, 0, 8, 0,
			7, 10, 57, 77, 77, 251, 33, 14, 0, 57,
			109, 77, 252, 33, 15, 0, 57, 141, 77, 253,
			33, 16, 0, 0, 30, 77, 182, 34, 2, 3,
			0, 8, 7, 10, 56, 77, 166, 34, 16, 1,
			56, 109, 167, 34, 17, 1, 56, 141, 168, 34,
			18, 1, 0, 7, 10, 56, 77, 169, 34, 16,
			1, 56, 109, 170, 34, 17, 1, 56, 141, 171,
			34, 18, 1, 0, 0, 0, 8, 7, 10, 56,
			77, 132, 34, 16, 0, 56, 109, 133, 34, 17,
			0, 56, 141, 134, 34, 18, 0, 0, 7, 10,
			56, 77, 135, 34, 16, 0, 56, 109, 136, 34,
			17, 0, 56, 141, 137, 34, 18, 0, 0, 7,
			10, 56, 77, 187, 34, 16, 0, 56, 109, 188,
			34, 17, 0, 56, 141, 189, 34, 18, 0, 0,
			7, 10, 56, 77, 184, 34, 16, 0, 56, 109,
			185, 34, 17, 0, 56, 141, 186, 34, 18, 0,
			0, 8, 0, 9, 12, 174, 35, 1, 1, 0,
			0, 0, 0, 2, 129, 1, 0, 1, 128, 2,
			2, 19, 0, 8, 7, 44, 77, 148, 34, 1,
			1, 0, 7, 10, 57, 77, 77, 248, 33, 15,
			1, 57, 109, 77, 249, 33, 16, 1, 57, 141,
			109, 250, 33, 17, 1, 0, 0, 0, 2, 24,
			0, 8, 0, 7, 10, 45, 77, 196, 35, 16,
			0, 45, 109, 197, 35, 17, 0, 45, 141, 198,
			35, 18, 0, 0, 0, 0, 8, 0, 7, 44,
			77, 199, 35, 1, 0, 0, 0, 0, 2, 20,
			0, 8, 0, 7, 10, 56, 77, 152, 35, 16,
			1, 56, 109, 153, 35, 17, 1, 56, 141, 154,
			35, 18, 1, 0, 0, 0, 8, 0, 7, 44,
			77, 155, 35, 1, 1, 0, 0, 0, 2, 8,
			0, 8, 0, 7, 9, 53, 77, 180, 35, 16,
			53, 109, 181, 35, 17, 53, 141, 182, 35, 18,
			0, 0, 0, 8, 0, 7, 41, 77, 183, 35,
			1, 0, 0, 0, 8, 0, 7, 9, 53, 77,
			192, 35, 16, 53, 109, 193, 35, 17, 53, 141,
			194, 35, 18, 0, 0, 0, 8, 0, 7, 41,
			77, 195, 35, 1, 0, 0, 0, 2, 6, 0,
			8, 0, 0, 7, 10, 76, 77, 197, 34, 8,
			76, 109, 198, 34, 9, 76, 141, 199, 34, 10,
			0, 7, 10, 76, 77, 194, 34, 8, 76, 109,
			195, 34, 9, 76, 141, 196, 34, 10, 0, 8,
			0, 0, 7, 75, 77, 201, 34, 2, 0, 7,
			75, 77, 200, 34, 2, 0, 2, 62, 0, 8,
			0, 7, 10, 45, 77, 210, 34, 16, 0, 45,
			109, 211, 34, 17, 0, 45, 141, 212, 34, 18,
			0, 0, 0, 0, 8, 0, 7, 10, 45, 77,
			219, 34, 16, 0, 45, 109, 220, 34, 17, 0,
			45, 141, 221, 34, 18, 0, 0, 0, 0, 8,
			0, 7, 10, 45, 77, 228, 34, 16, 0, 45,
			109, 229, 34, 17, 0, 45, 141, 230, 34, 18,
			0, 0, 0, 0, 8, 0, 7, 44, 77, 246,
			34, 1, 0, 0, 0, 0, 8, 0, 7, 10,
			45, 77, 252, 34, 16, 0, 45, 109, 253, 34,
			17, 0, 45, 141, 254, 34, 18, 0, 0, 0,
			0, 8, 0, 7, 44, 77, 142, 35, 1, 0,
			0, 0, 0, 8, 0, 7, 10, 45, 77, 237,
			34, 16, 0, 45, 109, 238, 34, 17, 0, 45,
			141, 239, 34, 18, 0, 0, 0, 0, 8, 0,
			7, 44, 77, 249, 34, 1, 0, 0, 0, 0,
			8, 0, 7, 10, 45, 77, 133, 35, 16, 0,
			45, 109, 134, 35, 17, 0, 45, 141, 135, 35,
			18, 0, 0, 0, 0, 8, 0, 7, 44, 77,
			145, 35, 1, 0, 0, 0, 0, 2, 6, 0,
			8, 0, 7, 10, 45, 77, 213, 34, 16, 0,
			45, 109, 214, 34, 17, 0, 45, 141, 215, 34,
			18, 0, 0, 0, 0, 8, 0, 7, 10, 45,
			77, 222, 34, 16, 0, 45, 109, 223, 34, 17,
			0, 45, 141, 224, 34, 18, 0, 0, 0, 0,
			8, 0, 7, 10, 45, 77, 231, 34, 16, 0,
			45, 109, 232, 34, 17, 0, 45, 141, 233, 34,
			18, 0, 0, 0, 0, 8, 0, 7, 44, 77,
			247, 34, 1, 0, 0, 0, 0, 8, 0, 7,
			10, 45, 77, 255, 34, 16, 0, 45, 109, 128,
			35, 17, 0, 45, 141, 129, 35, 18, 0, 0,
			0, 0, 8, 0, 7, 44, 77, 143, 35, 1,
			0, 0, 0, 0, 8, 0, 7, 10, 45, 77,
			240, 34, 16, 0, 45, 109, 241, 34, 17, 0,
			45, 141, 242, 34, 18, 0, 0, 0, 0, 8,
			0, 7, 44, 77, 250, 34, 1, 0, 0, 0,
			0, 8, 0, 7, 10, 45, 77, 136, 35, 16,
			0, 45, 109, 137, 35, 17, 0, 45, 141, 138,
			35, 18, 0, 0, 0, 0, 8, 0, 7, 44,
			77, 146, 35, 1, 0, 0, 0, 0, 2, 6,
			0, 8, 0, 7, 10, 45, 77, 216, 34, 16,
			0, 45, 109, 217, 34, 17, 0, 45, 141, 218,
			34, 18, 0, 0, 0, 0, 8, 0, 7, 10,
			45, 77, 225, 34, 16, 0, 45, 109, 226, 34,
			17, 0, 45, 141, 227, 34, 18, 0, 0, 0,
			0, 8, 0, 7, 10, 45, 77, 234, 34, 16,
			0, 45, 109, 235, 34, 17, 0, 45, 141, 236,
			34, 18, 0, 0, 0, 0, 8, 0, 7, 44,
			77, 248, 34, 1, 0, 0, 0, 0, 8, 0,
			7, 10, 45, 77, 130, 35, 16, 0, 45, 109,
			131, 35, 17, 0, 45, 141, 132, 35, 18, 0,
			0, 0, 0, 8, 0, 7, 44, 77, 144, 35,
			1, 0, 0, 0, 0, 8, 0, 7, 10, 45,
			77, 243, 34, 16, 0, 45, 109, 244, 34, 17,
			0, 45, 141, 245, 34, 18, 0, 0, 0, 0,
			8, 0, 7, 44, 77, 251, 34, 1, 0, 0,
			0, 0, 8, 0, 7, 10, 45, 77, 139, 35,
			16, 0, 45, 109, 140, 35, 17, 0, 45, 141,
			141, 35, 18, 0, 0, 0, 0, 8, 0, 7,
			44, 77, 147, 35, 1, 0, 0, 0, 0, 2,
			22, 0, 8, 0, 0, 7, 10, 76, 77, 205,
			34, 8, 76, 109, 206, 34, 9, 76, 141, 207,
			34, 10, 0, 7, 10, 76, 77, 202, 34, 8,
			76, 109, 203, 34, 9, 76, 141, 204, 34, 10,
			0, 8, 0, 0, 7, 75, 77, 209, 34, 2,
			0, 7, 75, 77, 208, 34, 2, 0, 2, 40,
			0, 1, 128, 2, 2, 16, 0, 8, 7, 9,
			52, 77, 128, 7, 4, 52, 109, 129, 7, 5,
			52, 141, 130, 7, 6, 0, 7, 0, 9, 52,
			77, 134, 7, 4, 52, 109, 135, 7, 5, 52,
			141, 136, 7, 6, 7, 5, 41, 77, 140, 7,
			0, 52, 77, 141, 7, 2, 0, 7, 0, 5,
			41, 77, 145, 7, 0, 52, 77, 146, 7, 3,
			8, 7, 9, 69, 77, 150, 7, 4, 69, 109,
			151, 7, 5, 69, 141, 152, 7, 6, 0, 7,
			0, 9, 69, 77, 156, 7, 4, 69, 109, 157,
			7, 5, 69, 141, 158, 7, 6, 7, 5, 68,
			77, 162, 7, 71, 77, 163, 7, 2, 0, 0,
			7, 0, 5, 68, 77, 167, 7, 71, 77, 168,
			7, 3, 0, 8, 7, 9, 34, 77, 173, 7,
			174, 7, 3, 0, 0, 0, 7, 0, 9, 32,
			77, 177, 7, 3, 0, 0, 7, 9, 52, 77,
			181, 7, 4, 52, 109, 182, 7, 5, 52, 141,
			183, 7, 6, 0, 7, 0, 9, 52, 77, 187,
			7, 3, 52, 109, 188, 7, 5, 52, 141, 189,
			7, 6, 8, 7, 9, 29, 77, 192, 7, 3,
			0, 0, 0, 7, 0, 9, 29, 77, 195, 7,
			3, 0, 0, 0, 0, 8, 7, 9, 42, 77,
			199, 7, 8, 42, 109, 200, 7, 9, 42, 141,
			201, 7, 10, 0, 7, 0, 9, 42, 77, 205,
			7, 11, 42, 109, 206, 7, 12, 42, 141, 207,
			7, 13, 0, 0, 8, 7, 9, 42, 77, 211,
			7, 8, 42, 109, 212, 7, 9, 42, 141, 213,
			7, 10, 0, 7, 0, 9, 42, 77, 217, 7,
			11, 42, 109, 218, 7, 12, 42, 141, 219, 7,
			13, 0, 0, 8, 7, 9, 34, 77, 222, 7,
			225, 7, 3, 0, 0, 0, 7, 0, 9, 32,
			77, 228, 7, 3, 0, 0, 7, 9, 52, 77,
			232, 7, 4, 52, 109, 233, 7, 5, 52, 141,
			234, 7, 6, 0, 0, 8, 7, 9, 29, 77,
			237, 7, 3, 0, 0, 0, 7, 0, 9, 29,
			77, 240, 7, 3, 0, 0, 0, 0, 2, 16,
			0, 8, 7, 9, 52, 77, 176, 8, 4, 52,
			109, 177, 8, 5, 52, 141, 178, 8, 6, 0,
			7, 0, 9, 52, 77, 182, 8, 4, 52, 109,
			183, 8, 5, 52, 141, 184, 8, 6, 0, 0,
			8, 7, 9, 69, 77, 188, 8, 4, 69, 109,
			189, 8, 5, 69, 141, 190, 8, 6, 0, 7,
			0, 9, 69, 77, 194, 8, 4, 69, 109, 195,
			8, 5, 69, 141, 196, 8, 6, 0, 0, 8,
			0, 0, 30, 77, 203, 8, 2, 3, 30, 77,
			209, 8, 2, 3, 8, 7, 9, 29, 77, 214,
			8, 4, 29, 109, 215, 8, 5, 29, 141, 216,
			8, 6, 0, 7, 0, 9, 29, 77, 220, 8,
			4, 29, 109, 221, 8, 5, 29, 141, 222, 8,
			6, 0, 0, 8, 0, 0, 14, 77, 231, 8,
			2, 1, 14, 77, 237, 8, 3, 1, 8, 0,
			0, 14, 77, 245, 8, 2, 0, 14, 77, 251,
			8, 3, 0, 8, 7, 66, 77, 255, 8, 2,
			0, 7, 0, 66, 77, 130, 9, 3, 0, 0,
			8, 7, 66, 77, 135, 9, 2, 0, 7, 0,
			66, 77, 136, 9, 3, 0, 0, 2, 33, 0,
			8, 7, 10, 56, 77, 239, 9, 8, 0, 56,
			109, 240, 9, 9, 0, 56, 141, 241, 9, 10,
			0, 0, 7, 0, 10, 56, 77, 245, 9, 11,
			0, 56, 109, 246, 9, 12, 0, 56, 141, 247,
			9, 13, 0, 7, 44, 77, 250, 9, 2, 0,
			0, 7, 0, 44, 77, 253, 9, 3, 0, 1,
			8, 7, 9, 42, 77, 139, 10, 8, 42, 109,
			140, 10, 9, 42, 141, 141, 10, 10, 0, 7,
			0, 9, 42, 77, 145, 10, 11, 42, 109, 146,
			10, 12, 42, 141, 147, 10, 13, 0, 0, 8,
			7, 9, 42, 77, 151, 10, 8, 42, 109, 152,
			10, 9, 42, 141, 153, 10, 10, 0, 7, 0,
			9, 42, 77, 157, 10, 11, 42, 109, 158, 10,
			12, 42, 141, 159, 10, 13, 0, 0, 8, 7,
			9, 42, 77, 163, 10, 8, 42, 109, 164, 10,
			9, 42, 141, 165, 10, 10, 0, 7, 0, 9,
			42, 77, 169, 10, 11, 42, 109, 170, 10, 12,
			42, 141, 171, 10, 13, 0, 0, 8, 7, 9,
			42, 77, 175, 10, 8, 42, 109, 176, 10, 9,
			42, 141, 177, 10, 10, 0, 7, 0, 9, 42,
			77, 181, 10, 11, 42, 109, 182, 10, 12, 42,
			141, 183, 10, 13, 0, 0, 8, 7, 10, 45,
			77, 187, 10, 8, 0, 45, 109, 188, 10, 9,
			0, 45, 141, 189, 10, 10, 0, 0, 7, 0,
			10, 45, 77, 193, 10, 11, 0, 45, 109, 194,
			10, 12, 0, 45, 141, 195, 10, 13, 0, 7,
			44, 77, 198, 10, 2, 0, 0, 7, 0, 44,
			77, 201, 10, 3, 0, 8, 7, 10, 45, 77,
			205, 10, 8, 0, 45, 109, 206, 10, 9, 0,
			45, 141, 207, 10, 10, 0, 0, 7, 0, 10,
			45, 77, 211, 10, 11, 0, 45, 109, 212, 10,
			12, 0, 45, 141, 213, 10, 13, 0, 7, 44,
			77, 216, 10, 2, 0, 0, 7, 0, 44, 77,
			219, 10, 3, 0, 8, 7, 10, 57, 77, 77,
			223, 10, 7, 1, 57, 109, 77, 224, 10, 8,
			1, 57, 141, 109, 225, 10, 9, 1, 0, 7,
			0, 10, 57, 77, 77, 229, 10, 11, 0, 57,
			77, 109, 230, 10, 12, 0, 57, 109, 141, 231,
			10, 13, 0, 7, 44, 77, 234, 10, 2, 1,
			0, 7, 0, 44, 77, 237, 10, 3, 0, 8,
			7, 10, 56, 77, 241, 10, 8, 0, 56, 109,
			242, 10, 9, 0, 56, 141, 243, 10, 10, 0,
			10, 57, 77, 77, 244, 10, 11, 0, 57, 77,
			109, 245, 10, 12, 0, 57, 109, 141, 246, 10,
			13, 0, 7, 10, 56, 77, 250, 10, 8, 0,
			56, 109, 251, 10, 9, 0, 56, 141, 252, 10,
			10, 0, 0, 7, 10, 56, 77, 128, 11, 8,
			1, 56, 109, 129, 11, 9, 1, 56, 141, 130,
			11, 10, 1, 0, 0, 8, 7, 10, 45, 77,
			134, 11, 8, 0, 45, 109, 135, 11, 9, 0,
			45, 141, 136, 11, 10, 0, 0, 7, 0, 10,
			45, 77, 140, 11, 11, 0, 45, 109, 141, 11,
			12, 0, 45, 141, 142, 11, 13, 0, 7, 44,
			77, 145, 11, 2, 0, 0, 7, 0, 44, 77,
			148, 11, 3, 0, 8, 7, 10, 45, 77, 152,
			11, 8, 1, 45, 109, 153, 11, 9, 1, 45,
			141, 154, 11, 10, 1, 0, 7, 0, 10, 45,
			77, 158, 11, 11, 1, 45, 109, 159, 11, 12,
			1, 45, 141, 160, 11, 13, 1, 7, 44, 77,
			163, 11, 2, 1, 0, 7, 0, 44, 77, 166,
			11, 3, 1, 8, 7, 10, 45, 77, 170, 11,
			8, 0, 45, 109, 171, 11, 9, 0, 45, 141,
			172, 11, 10, 0, 0, 7, 0, 10, 45, 77,
			176, 11, 11, 0, 45, 109, 177, 11, 12, 0,
			45, 141, 178, 11, 13, 0, 7, 44, 77, 181,
			11, 2, 0, 0, 7, 0, 44, 77, 184, 11,
			3, 0, 8, 7, 10, 45, 77, 188, 11, 8,
			1, 45, 109, 189, 11, 9, 1, 45, 141, 190,
			11, 10, 1, 0, 7, 0, 10, 45, 77, 194,
			11, 11, 1, 45, 109, 195, 11, 12, 1, 45,
			141, 196, 11, 13, 1, 7, 44, 77, 199, 11,
			2, 1, 0, 7, 0, 44, 77, 202, 11, 3,
			1, 8, 0, 9, 41, 77, 207, 11, 4, 41,
			109, 208, 11, 5, 41, 141, 209, 11, 6, 0,
			0, 8, 0, 9, 41, 77, 214, 11, 4, 41,
			109, 215, 11, 5, 41, 141, 216, 11, 6, 0,
			0, 8, 0, 7, 9, 42, 77, 221, 11, 8,
			42, 109, 222, 11, 9, 42, 141, 223, 11, 10,
			0, 0, 0, 8, 0, 9, 41, 77, 228, 11,
			4, 41, 109, 229, 11, 5, 41, 141, 230, 11,
			6, 0, 0, 8, 0, 9, 19, 77, 235, 11,
			4, 19, 109, 236, 11, 5, 19, 141, 237, 11,
			6, 0, 0, 8, 0, 9, 19, 77, 242, 11,
			4, 19, 109, 243, 11, 5, 19, 141, 244, 11,
			6, 0, 0, 8, 0, 7, 9, 20, 77, 249,
			11, 8, 20, 109, 250, 11, 9, 20, 141, 251,
			11, 10, 0, 0, 0, 8, 0, 9, 41, 77,
			128, 12, 4, 41, 109, 129, 12, 5, 41, 141,
			130, 12, 6, 0, 0, 8, 0, 9, 41, 77,
			135, 12, 4, 41, 109, 136, 12, 5, 41, 141,
			137, 12, 6, 0, 0, 8, 0, 9, 41, 77,
			142, 12, 4, 41, 109, 143, 12, 5, 41, 141,
			144, 12, 6, 0, 0, 8, 0, 7, 9, 42,
			77, 149, 12, 8, 42, 109, 150, 12, 9, 42,
			141, 151, 12, 10, 0, 0, 0, 8, 0, 7,
			9, 42, 77, 156, 12, 8, 42, 109, 157, 12,
			9, 42, 141, 158, 12, 10, 0, 0, 0, 8,
			0, 7, 0, 9, 42, 77, 162, 12, 11, 42,
			109, 163, 12, 12, 42, 141, 164, 12, 13, 0,
			0, 8, 0, 7, 0, 9, 42, 77, 168, 12,
			11, 42, 109, 169, 12, 12, 42, 141, 170, 12,
			13, 0, 0, 8, 0, 9, 67, 177, 12, 2,
			3, 0, 0, 0, 0, 8, 0, 7, 9, 52,
			77, 183, 12, 4, 52, 109, 184, 12, 5, 52,
			141, 185, 12, 6, 9, 52, 77, 186, 12, 4,
			52, 109, 187, 12, 5, 52, 141, 188, 12, 6,
			7, 9, 52, 77, 192, 12, 4, 52, 109, 193,
			12, 5, 52, 141, 194, 12, 6, 9, 52, 77,
			195, 12, 4, 52, 109, 196, 12, 5, 52, 141,
			197, 12, 6, 7, 9, 52, 77, 198, 12, 4,
			52, 109, 199, 12, 5, 52, 141, 200, 12, 6,
			9, 52, 77, 201, 12, 4, 52, 109, 202, 12,
			5, 52, 141, 203, 12, 6, 8, 0, 7, 9,
			60, 77, 208, 12, 8, 60, 109, 209, 12, 9,
			60, 141, 210, 12, 10, 0, 9, 59, 77, 214,
			12, 4, 59, 109, 215, 12, 5, 59, 141, 216,
			12, 6, 9, 59, 77, 220, 12, 4, 59, 109,
			221, 12, 5, 59, 141, 222, 12, 6, 6, 4,
			0, 6, 4, 1, 6, 4, 2, 8, 0, 9,
			19, 77, 182, 13, 4, 19, 109, 183, 13, 5,
			19, 141, 184, 13, 6, 0, 0, 8, 0, 9,
			19, 77, 189, 13, 4, 19, 109, 190, 13, 5,
			19, 141, 191, 13, 6, 0, 0, 8, 0, 7,
			9, 20, 77, 196, 13, 8, 20, 109, 197, 13,
			9, 20, 141, 198, 13, 10, 0, 0, 0, 0,
			8, 7, 10, 57, 77, 77, 204, 13, 8, 1,
			57, 109, 109, 205, 13, 9, 1, 57, 141, 141,
			206, 13, 10, 1, 10, 57, 77, 77, 207, 13,
			11, 1, 57, 77, 109, 208, 13, 12, 1, 57,
			109, 141, 209, 13, 13, 1, 7, 10, 57, 77,
			77, 211, 13, 7, 1, 57, 109, 77, 212, 13,
			8, 1, 57, 141, 109, 213, 13, 9, 1, 10,
			57, 77, 77, 214, 13, 11, 1, 57, 109, 109,
			215, 13, 12, 1, 57, 141, 141, 216, 13, 13,
			1, 14, 77, 217, 13, 2, 1, 14, 77, 220,
			13, 3, 1, 8, 7, 10, 57, 77, 77, 224,
			13, 8, 0, 57, 109, 109, 225, 13, 9, 0,
			57, 141, 141, 226, 13, 10, 0, 10, 57, 77,
			77, 227, 13, 11, 0, 57, 77, 109, 228, 13,
			12, 0, 57, 109, 141, 229, 13, 13, 0, 7,
			10, 57, 77, 77, 231, 13, 7, 0, 57, 109,
			77, 232, 13, 8, 0, 57, 141, 109, 233, 13,
			9, 0, 10, 57, 77, 77, 234, 13, 11, 0,
			57, 109, 109, 235, 13, 12, 0, 57, 141, 141,
			236, 13, 13, 0, 14, 77, 237, 13, 2, 0,
			14, 77, 240, 13, 3, 0, 8, 0, 7, 10,
			57, 77, 77, 242, 13, 7, 1, 57, 109, 77,
			243, 13, 8, 1, 57, 141, 109, 244, 13, 9,
			1, 10, 57, 77, 77, 245, 13, 11, 1, 57,
			109, 109, 246, 13, 12, 1, 57, 141, 141, 247,
			13, 13, 1, 7, 10, 57, 77, 77, 248, 13,
			7, 0, 57, 109, 77, 249, 13, 8, 0, 57,
			141, 109, 250, 13, 9, 0, 10, 57, 77, 77,
			251, 13, 11, 0, 57, 109, 109, 252, 13, 12,
			0, 57, 141, 141, 253, 13, 13, 0, 7, 10,
			57, 77, 77, 254, 13, 8, 0, 57, 109, 109,
			255, 13, 9, 0, 57, 141, 141, 128, 14, 10,
			0, 10, 57, 77, 77, 129, 14, 11, 0, 57,
			77, 109, 130, 14, 12, 0, 57, 109, 141, 131,
			14, 13, 0, 8, 0, 7, 10, 57, 77, 77,
			132, 14, 7, 0, 57, 109, 77, 133, 14, 8,
			0, 57, 141, 109, 134, 14, 9, 0, 10, 57,
			77, 77, 135, 14, 11, 0, 57, 109, 109, 136,
			14, 12, 0, 57, 141, 141, 137, 14, 13, 0,
			30, 77, 138, 14, 2, 3, 30, 77, 140, 14,
			2, 3, 1, 8, 0, 9, 12, 160, 14, 2,
			3, 0, 0, 7, 0, 9, 65, 77, 164, 14,
			3, 0, 0, 0, 8, 0, 7, 9, 69, 77,
			169, 14, 4, 69, 109, 170, 14, 5, 69, 141,
			171, 14, 6, 9, 69, 77, 172, 14, 4, 69,
			109, 173, 14, 5, 69, 141, 174, 14, 6, 7,
			9, 69, 77, 178, 14, 4, 69, 109, 179, 14,
			5, 69, 141, 180, 14, 6, 9, 69, 77, 181,
			14, 4, 69, 109, 182, 14, 5, 69, 141, 183,
			14, 6, 7, 9, 69, 77, 184, 14, 4, 69,
			109, 185, 14, 5, 69, 141, 186, 14, 6, 9,
			69, 77, 187, 14, 4, 69, 109, 188, 14, 5,
			69, 141, 189, 14, 6, 2, 66, 0, 8, 7,
			10, 22, 77, 223, 16, 8, 22, 109, 224, 16,
			9, 22, 141, 225, 16, 10, 0, 7, 0, 10,
			22, 77, 229, 16, 11, 22, 109, 230, 16, 12,
			22, 141, 231, 16, 13, 7, 21, 77, 234, 16,
			2, 0, 7, 0, 21, 77, 237, 16, 3, 0,
			8, 0, 7, 9, 31, 77, 246, 16, 1, 1,
			0, 0, 9, 31, 77, 246, 16, 1, 1, 0,
			0, 0, 0, 8, 0, 7, 9, 5, 13, 77,
			254, 16, 0, 0, 0, 9, 5, 13, 77, 254,
			16, 0, 0, 0, 0, 0, 8, 7, 9, 47,
			77, 131, 17, 8, 47, 109, 132, 17, 9, 47,
			141, 133, 17, 10, 0, 7, 0, 9, 47, 77,
			137, 17, 11, 47, 109, 138, 17, 12, 47, 141,
			139, 17, 13, 0, 0, 2, 10, 0, 8, 0,
			9, 43, 77, 77, 77, 173, 17, 4, 43, 109,
			109, 77, 174, 17, 4, 43, 141, 141, 77, 175,
			17, 4, 0, 0, 8, 0, 7, 9, 43, 77,
			77, 77, 180, 17, 4, 43, 109, 109, 77, 181,
			17, 4, 43, 141, 141, 77, 182, 17, 4, 0,
			0, 0, 8, 0, 7, 0, 9, 43, 77, 77,
			77, 187, 17, 4, 43, 109, 109, 77, 188, 17,
			4, 43, 141, 141, 77, 189, 17, 4, 0, 0,
			8, 0, 7, 0, 9, 42, 77, 194, 17, 11,
			42, 109, 195, 17, 12, 42, 141, 196, 17, 13,
			0, 0, 8, 0, 9, 41, 77, 201, 17, 4,
			41, 109, 202, 17, 5, 41, 141, 203, 17, 6,
			0, 0, 8, 0, 7, 0, 9, 74, 77, 206,
			17, 3, 0, 0, 0, 0, 0, 8, 0, 9,
			41, 77, 221, 17, 4, 41, 109, 222, 17, 5,
			41, 141, 223, 17, 6, 0, 0, 8, 0, 9,
			41, 77, 228, 17, 4, 41, 109, 229, 17, 5,
			41, 141, 230, 17, 6, 0, 0, 8, 0, 9,
			41, 77, 235, 17, 4, 41, 109, 236, 17, 5,
			41, 141, 237, 17, 6, 0, 0, 8, 0, 7,
			9, 42, 77, 242, 17, 8, 42, 109, 243, 17,
			9, 42, 141, 244, 17, 10, 9, 42, 77, 245,
			17, 11, 42, 109, 246, 17, 12, 42, 141, 247,
			17, 13, 0, 0, 8, 0, 9, 41, 77, 252,
			17, 4, 41, 109, 253, 17, 5, 41, 141, 254,
			17, 6, 0, 0, 8, 0, 9, 41, 77, 131,
			18, 4, 41, 109, 132, 18, 5, 41, 141, 133,
			18, 6, 0, 0, 8, 0, 9, 41, 77, 138,
			18, 4, 41, 109, 139, 18, 5, 41, 141, 140,
			18, 6, 0, 0, 8, 0, 7, 9, 42, 77,
			145, 18, 8, 42, 109, 146, 18, 9, 42, 141,
			147, 18, 10, 9, 42, 77, 148, 18, 11, 42,
			109, 149, 18, 12, 42, 141, 150, 18, 13, 0,
			0, 8, 0, 9, 41, 77, 155, 18, 4, 41,
			109, 156, 18, 5, 41, 141, 157, 18, 6, 0,
			0, 8, 0, 9, 43, 77, 77, 77, 162, 18,
			4, 43, 109, 109, 77, 163, 18, 4, 43, 141,
			141, 77, 164, 18, 4, 0, 0, 8, 0, 7,
			9, 43, 77, 77, 77, 169, 18, 4, 43, 109,
			109, 77, 170, 18, 4, 43, 141, 141, 77, 171,
			18, 4, 9, 43, 77, 77, 77, 172, 18, 4,
			43, 109, 109, 77, 173, 18, 4, 43, 141, 141,
			77, 174, 18, 4, 0, 0, 8, 0, 9, 41,
			77, 179, 18, 4, 41, 109, 180, 18, 5, 41,
			141, 181, 18, 6, 0, 0, 8, 0, 9, 41,
			77, 186, 18, 4, 41, 109, 187, 18, 5, 41,
			141, 188, 18, 6, 0, 0, 8, 0, 9, 41,
			77, 193, 18, 4, 41, 109, 194, 18, 5, 41,
			141, 195, 18, 6, 0, 0, 8, 0, 7, 0,
			10, 57, 77, 77, 199, 18, 11, 1, 57, 77,
			109, 200, 18, 12, 1, 57, 109, 141, 201, 18,
			13, 1, 7, 10, 57, 77, 77, 205, 18, 7,
			0, 57, 109, 77, 206, 18, 8, 0, 57, 141,
			109, 207, 18, 9, 0, 10, 57, 77, 77, 208,
			18, 11, 0, 57, 109, 109, 209, 18, 12, 0,
			57, 141, 141, 210, 18, 13, 0, 7, 0, 10,
			57, 77, 77, 214, 18, 11, 0, 57, 77, 109,
			215, 18, 12, 0, 57, 109, 141, 216, 18, 13,
			0, 8, 0, 7, 9, 29, 77, 221, 18, 4,
			29, 109, 222, 18, 5, 29, 141, 223, 18, 6,
			0, 0, 0, 8, 0, 9, 41, 77, 228, 18,
			4, 41, 109, 229, 18, 5, 41, 141, 230, 18,
			6, 0, 0, 8, 0, 9, 41, 77, 235, 18,
			4, 41, 109, 236, 18, 5, 41, 141, 237, 18,
			6, 0, 0, 8, 0, 9, 41, 77, 242, 18,
			4, 41, 109, 243, 18, 5, 41, 141, 244, 18,
			6, 0, 0, 8, 0, 7, 9, 42, 77, 249,
			18, 8, 42, 109, 250, 18, 9, 42, 141, 251,
			18, 10, 9, 42, 77, 252, 18, 11, 42, 109,
			253, 18, 12, 42, 141, 254, 18, 13, 0, 0,
			8, 0, 9, 41, 77, 131, 19, 4, 41, 109,
			132, 19, 5, 41, 141, 133, 19, 6, 0, 0,
			8, 0, 9, 41, 77, 138, 19, 4, 41, 109,
			139, 19, 5, 41, 141, 140, 19, 6, 0, 0,
			8, 0, 9, 41, 77, 145, 19, 4, 41, 109,
			146, 19, 5, 41, 141, 147, 19, 6, 0, 0,
			8, 0, 7, 9, 42, 77, 152, 19, 8, 42,
			109, 153, 19, 9, 42, 141, 154, 19, 10, 9,
			42, 77, 155, 19, 11, 42, 109, 156, 19, 12,
			42, 141, 157, 19, 13, 0, 0, 0, 8, 0,
			9, 43, 77, 77, 77, 165, 19, 4, 43, 109,
			109, 77, 166, 19, 4, 43, 141, 141, 77, 167,
			19, 4, 0, 0, 8, 0, 7, 9, 43, 77,
			77, 77, 172, 19, 4, 43, 109, 109, 77, 173,
			19, 4, 43, 141, 141, 77, 174, 19, 4, 0,
			0, 0, 8, 0, 7, 0, 9, 43, 77, 77,
			77, 179, 19, 4, 43, 109, 109, 77, 180, 19,
			4, 43, 141, 141, 77, 181, 19, 4, 0, 0,
			8, 0, 7, 0, 9, 42, 77, 186, 19, 11,
			42, 109, 187, 19, 12, 42, 141, 188, 19, 13,
			0, 0, 8, 0, 9, 41, 77, 193, 19, 4,
			41, 109, 194, 19, 5, 41, 141, 195, 19, 6,
			0, 0, 8, 0, 9, 33, 77, 200, 19, 4,
			33, 109, 201, 19, 5, 33, 141, 202, 19, 6,
			0, 0, 0, 8, 0, 9, 41, 77, 210, 19,
			4, 41, 109, 211, 19, 5, 41, 141, 212, 19,
			6, 0, 0, 8, 0, 9, 41, 77, 217, 19,
			4, 41, 109, 218, 19, 5, 41, 141, 219, 19,
			6, 0, 0, 8, 0, 7, 9, 42, 77, 224,
			19, 8, 42, 109, 225, 19, 9, 42, 141, 226,
			19, 10, 0, 0, 0, 8, 0, 7, 0, 9,
			42, 77, 231, 19, 11, 42, 109, 232, 19, 12,
			42, 141, 233, 19, 13, 0, 0, 8, 0, 9,
			41, 77, 238, 19, 4, 41, 109, 239, 19, 5,
			41, 141, 240, 19, 6, 0, 0, 8, 0, 9,
			41, 77, 245, 19, 4, 41, 109, 246, 19, 5,
			41, 141, 247, 19, 6, 0, 0, 8, 0, 7,
			9, 42, 77, 252, 19, 8, 42, 109, 253, 19,
			9, 42, 141, 254, 19, 10, 0, 0, 0, 0
		};
	}
}


using System;
using Iced.Intel.DecoderInternal;

internal static class OpCodeHandlersTables_Legacy
{
	internal static readonly OpCodeHandler[] Handlers_MAP0;

	private const int MaxIdNames = 82;

	private const uint Handlers_MAP0Index = 81u;

	static OpCodeHandlersTables_Legacy()
	{
		LegacyOpCodeHandlerReader handlerReader = new LegacyOpCodeHandlerReader();
		TableDeserializer tableDeserializer = new TableDeserializer(handlerReader, 82, GetSerializedTables());
		tableDeserializer.Deserialize();
		Handlers_MAP0 = tableDeserializer.GetTable(81u);
	}

	private static ReadOnlySpan<byte> GetSerializedTables()
	{
		return new byte[6336]
		{
			1, 8, 115, 238, 3, 115, 239, 3, 115, 240,
			3, 115, 241, 3, 115, 242, 3, 115, 243, 3,
			115, 244, 3, 115, 245, 3, 1, 8, 174, 246,
			3, 174, 247, 3, 174, 248, 3, 174, 249, 3,
			174, 250, 3, 174, 251, 3, 174, 252, 3, 174,
			253, 3, 1, 8, 115, 254, 3, 2, 115, 255,
			3, 115, 128, 4, 116, 129, 4, 115, 131, 4,
			117, 132, 4, 134, 4, 115, 136, 4, 1, 64,
			5, 8, 175, 138, 4, 5, 8, 174, 139, 4,
			164, 140, 4, 5, 6, 2, 200, 2, 164, 171,
			33, 128, 128, 64, 5, 8, 175, 141, 4, 164,
			142, 4, 164, 143, 4, 200, 2, 164, 172, 33,
			128, 128, 64, 2, 164, 144, 4, 164, 145, 4,
			200, 2, 164, 173, 33, 128, 128, 64, 200, 2,
			164, 174, 33, 128, 128, 64, 164, 146, 4, 164,
			147, 4, 164, 148, 4, 164, 149, 4, 164, 150,
			4, 164, 151, 4, 164, 152, 4, 2, 164, 153,
			4, 164, 154, 4, 164, 155, 4, 164, 156, 4,
			164, 157, 4, 164, 158, 4, 164, 159, 4, 164,
			160, 4, 164, 161, 4, 164, 162, 4, 164, 163,
			4, 164, 164, 4, 164, 165, 4, 164, 166, 4,
			164, 167, 4, 164, 168, 4, 1, 8, 115, 169,
			4, 115, 170, 4, 115, 171, 4, 115, 172, 4,
			115, 173, 4, 115, 174, 4, 115, 175, 4, 115,
			176, 4, 1, 64, 5, 8, 174, 177, 4, 5,
			8, 174, 178, 4, 5, 8, 174, 179, 4, 5,
			8, 174, 180, 4, 5, 9, 2, 164, 181, 4,
			5, 22, 2, 1, 8, 115, 182, 4, 115, 183,
			4, 115, 184, 4, 115, 185, 4, 2, 115, 186,
			4, 2, 115, 187, 4, 1, 64, 5, 8, 174,
			188, 4, 5, 8, 174, 189, 4, 5, 8, 174,
			190, 4, 5, 8, 174, 191, 4, 164, 192, 4,
			164, 194, 4, 164, 196, 4, 164, 198, 4, 164,
			200, 4, 0, 10, 2, 164, 202, 4, 64, 2,
			4, 5, 8, 174, 203, 4, 5, 8, 174, 204,
			4, 5, 4, 2, 200, 2, 164, 175, 33, 128,
			128, 64, 5, 3, 2, 1, 8, 115, 205, 4,
			115, 206, 4, 115, 207, 4, 115, 208, 4, 115,
			209, 4, 115, 210, 4, 115, 211, 4, 115, 212,
			4, 1, 8, 176, 213, 4, 176, 214, 4, 174,
			215, 4, 174, 216, 4, 176, 217, 4, 176, 218,
			4, 176, 219, 4, 176, 220, 4, 1, 8, 115,
			221, 4, 115, 222, 4, 115, 223, 4, 115, 224,
			4, 116, 225, 4, 2, 117, 227, 4, 229, 4,
			115, 231, 4, 1, 64, 5, 8, 175, 233, 4,
			5, 8, 174, 234, 4, 5, 8, 175, 235, 4,
			5, 8, 175, 236, 4, 5, 8, 174, 237, 4,
			5, 8, 174, 238, 4, 5, 12, 2, 200, 2,
			164, 176, 33, 128, 128, 64, 5, 3, 2, 1,
			8, 115, 239, 4, 115, 240, 4, 115, 241, 4,
			115, 242, 4, 115, 243, 4, 115, 244, 4, 115,
			245, 4, 115, 246, 4, 1, 64, 5, 8, 176,
			247, 4, 5, 8, 176, 248, 4, 5, 8, 174,
			249, 4, 200, 2, 164, 177, 33, 128, 128, 64,
			164, 250, 4, 200, 2, 164, 178, 33, 128, 128,
			64, 2, 200, 2, 164, 179, 33, 128, 128, 64,
			200, 2, 164, 180, 33, 128, 128, 64, 200, 2,
			164, 181, 33, 128, 128, 64, 2, 5, 8, 176,
			251, 4, 5, 8, 176, 252, 4, 5, 8, 176,
			253, 4, 5, 8, 176, 254, 4, 1, 8, 115,
			255, 4, 115, 128, 5, 115, 129, 5, 115, 130,
			5, 115, 131, 5, 115, 132, 5, 115, 133, 5,
			115, 134, 5, 1, 64, 5, 8, 175, 135, 5,
			5, 8, 174, 136, 5, 5, 8, 175, 137, 5,
			5, 8, 175, 138, 5, 145, 139, 5, 21, 0,
			10, 2, 145, 140, 33, 21, 64, 2, 0, 10,
			2, 145, 141, 33, 21, 64, 2, 5, 5, 2,
			5, 8, 174, 143, 5, 5, 8, 174, 144, 5,
			5, 4, 2, 200, 2, 164, 182, 33, 128, 128,
			64, 5, 3, 2, 1, 8, 46, 207, 1, 11,
			46, 208, 1, 11, 46, 209, 1, 11, 46, 210,
			1, 11, 46, 211, 1, 11, 46, 212, 1, 11,
			46, 213, 1, 11, 45, 214, 1, 1, 8, 66,
			215, 1, 11, 66, 218, 1, 11, 66, 221, 1,
			11, 66, 224, 1, 11, 66, 227, 1, 11, 66,
			230, 1, 11, 66, 233, 1, 11, 65, 236, 1,
			1, 8, 46, 239, 1, 11, 46, 240, 1, 11,
			46, 241, 1, 11, 46, 242, 1, 11, 46, 243,
			1, 11, 46, 244, 1, 11, 46, 245, 1, 11,
			45, 246, 1, 1, 8, 62, 247, 1, 11, 62,
			250, 1, 11, 62, 253, 1, 11, 62, 128, 2,
			11, 62, 131, 2, 11, 62, 134, 2, 11, 62,
			137, 2, 11, 61, 140, 2, 1, 8, 133, 168,
			2, 5, 7, 2, 1, 8, 45, 231, 2, 45,
			232, 2, 45, 233, 2, 45, 234, 2, 45, 235,
			2, 45, 236, 2, 45, 237, 2, 45, 238, 2,
			1, 8, 63, 239, 2, 63, 242, 2, 63, 245,
			2, 63, 248, 2, 63, 251, 2, 63, 254, 2,
			63, 129, 3, 63, 132, 3, 1, 8, 47, 170,
			3, 47, 171, 3, 47, 172, 3, 47, 173, 3,
			47, 174, 3, 47, 175, 3, 47, 176, 3, 47,
			177, 3, 1, 8, 71, 178, 3, 71, 181, 3,
			71, 184, 3, 71, 187, 3, 71, 190, 3, 71,
			193, 3, 71, 196, 3, 71, 199, 3, 1, 8,
			42, 202, 3, 42, 203, 3, 42, 204, 3, 42,
			205, 3, 42, 206, 3, 42, 207, 3, 42, 208,
			3, 42, 209, 3, 1, 8, 53, 210, 3, 53,
			213, 3, 53, 216, 3, 53, 219, 3, 53, 222,
			3, 53, 225, 3, 53, 228, 3, 53, 231, 3,
			1, 8, 45, 199, 5, 45, 200, 5, 41, 201,
			5, 11, 41, 202, 5, 11, 40, 203, 5, 40,
			204, 5, 40, 205, 5, 40, 206, 5, 1, 8,
			65, 207, 5, 65, 210, 5, 52, 213, 5, 11,
			52, 216, 5, 11, 50, 219, 5, 50, 222, 5,
			50, 225, 5, 50, 228, 5, 1, 8, 41, 237,
			5, 11, 41, 238, 5, 11, 5, 6, 2, 1,
			8, 52, 239, 5, 11, 52, 242, 5, 11, 72,
			245, 5, 49, 248, 5, 72, 251, 5, 49, 254,
			5, 133, 129, 6, 2, 1, 8, 73, 132, 6,
			73, 135, 6, 74, 138, 6, 74, 141, 6, 74,
			144, 6, 74, 147, 6, 12, 17, 2, 2, 2,
			1, 2, 73, 222, 33, 1, 51, 150, 6, 17,
			2, 2, 2, 1, 2, 73, 222, 33, 128, 32,
			2, 1, 8, 9, 2, 120, 152, 6, 9, 2,
			120, 155, 6, 9, 2, 120, 158, 6, 9, 2,
			120, 161, 6, 73, 164, 6, 17, 2, 2, 110,
			167, 6, 2, 73, 168, 6, 110, 171, 6, 1,
			64, 20, 164, 172, 6, 3, 3, 3, 20, 164,
			173, 6, 3, 3, 3, 20, 164, 174, 6, 3,
			3, 3, 20, 164, 175, 6, 3, 3, 3, 20,
			164, 176, 6, 3, 3, 3, 20, 164, 177, 6,
			3, 3, 3, 5, 2, 6, 20, 171, 178, 6,
			3, 3, 3, 20, 164, 181, 6, 3, 3, 3,
			20, 164, 182, 6, 3, 0, 3, 164, 225, 33,
			0, 3, 164, 226, 33, 20, 164, 183, 6, 3,
			3, 3, 20, 3, 164, 183, 33, 3, 3, 20,
			3, 0, 3, 164, 184, 33, 3, 3, 20, 3,
			0, 3, 164, 185, 33, 3, 3, 20, 164, 184,
			6, 0, 3, 164, 186, 33, 3, 3, 20, 164,
			185, 6, 3, 3, 3, 20, 164, 186, 6, 3,
			3, 3, 5, 2, 6, 20, 164, 187, 6, 3,
			3, 3, 20, 164, 188, 6, 3, 3, 3, 20,
			164, 189, 6, 3, 3, 3, 20, 164, 190, 6,
			3, 3, 3, 171, 191, 6, 20, 164, 194, 6,
			164, 194, 6, 164, 254, 32, 164, 201, 33, 171,
			195, 6, 171, 198, 6, 164, 201, 6, 164, 202,
			6, 164, 203, 6, 171, 204, 6, 5, 8, 6,
			17, 165, 241, 32, 2, 165, 207, 6, 165, 242,
			32, 17, 2, 2, 2, 165, 243, 32, 17, 2,
			2, 165, 208, 6, 2, 6, 20, 3, 3, 0,
			3, 164, 202, 33, 3, 20, 3, 3, 0, 3,
			164, 203, 33, 3, 20, 164, 209, 6, 3, 0,
			3, 164, 204, 33, 3, 20, 164, 210, 6, 3,
			0, 3, 164, 205, 33, 3, 5, 8, 6, 1,
			2, 164, 211, 6, 164, 212, 6, 20, 171, 213,
			6, 3, 164, 216, 6, 3, 20, 164, 217, 6,
			3, 3, 3, 171, 218, 6, 164, 221, 6, 20,
			171, 244, 32, 3, 0, 3, 164, 235, 32, 0,
			3, 164, 236, 32, 20, 164, 247, 32, 3, 0,
			3, 164, 237, 32, 171, 238, 32, 1, 8, 19,
			142, 33, 3, 5, 7, 2, 1, 8, 19, 143,
			33, 3, 5, 7, 2, 1, 8, 9, 2, 19,
			149, 33, 2, 5, 7, 2, 1, 8, 9, 2,
			19, 150, 33, 2, 5, 7, 2, 1, 8, 9,
			2, 19, 151, 33, 2, 5, 7, 2, 1, 8,
			9, 2, 19, 152, 33, 2, 5, 7, 2, 1,
			8, 9, 18, 2, 2, 214, 166, 15, 2, 0,
			2, 9, 18, 2, 2, 171, 169, 15, 2, 0,
			2, 9, 18, 2, 2, 171, 172, 15, 2, 0,
			2, 9, 18, 2, 2, 171, 222, 37, 2, 0,
			2, 9, 18, 2, 2, 171, 216, 37, 2, 0,
			2, 9, 18, 2, 2, 171, 216, 33, 2, 0,
			2, 9, 18, 2, 2, 171, 210, 37, 2, 0,
			2, 9, 18, 2, 2, 171, 213, 37, 2, 0,
			2, 1, 8, 9, 171, 177, 15, 2, 9, 18,
			2, 2, 171, 180, 15, 2, 0, 2, 9, 18,
			2, 2, 171, 183, 15, 2, 0, 2, 9, 18,
			2, 2, 171, 186, 15, 2, 0, 2, 9, 18,
			2, 2, 171, 189, 15, 2, 0, 2, 9, 18,
			2, 2, 171, 192, 15, 2, 0, 2, 9, 18,
			2, 2, 171, 219, 33, 2, 0, 2, 9, 18,
			2, 2, 171, 219, 37, 2, 0, 2, 1, 8,
			5, 4, 2, 63, 183, 16, 64, 186, 16, 11,
			64, 189, 16, 11, 64, 192, 16, 11, 1, 8,
			2, 113, 140, 17, 11, 8, 2, 17, 112, 142,
			17, 2, 2, 2, 17, 112, 144, 17, 2, 2,
			2, 17, 9, 2, 68, 146, 17, 2, 2, 2,
			2, 21, 161, 151, 17, 110, 148, 17, 161, 151,
			17, 110, 149, 17, 1, 2, 204, 206, 33, 110,
			150, 17, 2, 2, 5, 21, 161, 155, 17, 110,
			154, 17, 161, 155, 17, 2, 162, 158, 17, 2,
			2, 2, 5, 1, 8, 46, 145, 3, 6, 5,
			7, 2, 1, 64, 5, 56, 6, 101, 146, 3,
			5, 7, 6, 1, 8, 66, 147, 3, 6, 5,
			7, 2, 1, 64, 5, 56, 6, 108, 150, 3,
			151, 3, 5, 7, 6, 1, 8, 4, 17, 124,
			223, 12, 159, 224, 12, 2, 2, 2, 17, 124,
			230, 12, 159, 231, 12, 2, 2, 2, 17, 124,
			237, 12, 159, 238, 12, 2, 2, 2, 1, 8,
			4, 17, 124, 128, 13, 159, 129, 13, 2, 2,
			2, 17, 124, 135, 13, 159, 136, 13, 2, 2,
			2, 17, 124, 145, 13, 159, 146, 13, 2, 2,
			2, 1, 8, 4, 17, 124, 152, 13, 159, 153,
			13, 2, 2, 17, 2, 159, 159, 13, 2, 2,
			4, 17, 124, 165, 13, 159, 166, 13, 2, 2,
			17, 2, 159, 172, 13, 2, 2, 1, 8, 17,
			111, 216, 15, 2, 1, 2, 9, 68, 218, 15,
			1, 2, 2, 17, 111, 220, 15, 2, 1, 2,
			9, 68, 222, 15, 1, 2, 2, 17, 110, 224,
			15, 2, 1, 2, 9, 68, 225, 15, 1, 2,
			2, 17, 110, 228, 15, 2, 1, 2, 9, 68,
			229, 15, 1, 2, 2, 17, 111, 232, 15, 2,
			68, 234, 15, 7, 2, 17, 111, 236, 15, 2,
			2, 2, 17, 111, 240, 15, 110, 242, 15, 110,
			245, 15, 2, 17, 110, 251, 15, 110, 252, 15,
			2, 2, 1, 64, 5, 40, 6, 17, 165, 253,
			15, 2, 68, 238, 15, 1, 2, 17, 165, 254,
			15, 2, 68, 238, 15, 1, 2, 17, 165, 255,
			15, 2, 68, 238, 15, 1, 2, 17, 165, 128,
			16, 2, 68, 238, 15, 1, 2, 17, 165, 129,
			16, 2, 68, 238, 15, 1, 2, 17, 165, 130,
			16, 2, 68, 238, 15, 1, 2, 17, 165, 131,
			16, 2, 68, 238, 15, 1, 2, 17, 165, 132,
			16, 2, 68, 238, 15, 1, 2, 17, 165, 133,
			16, 68, 243, 15, 1, 172, 246, 15, 68, 249,
			15, 1, 17, 165, 134, 16, 68, 243, 15, 1,
			172, 246, 15, 68, 249, 15, 1, 17, 165, 135,
			16, 68, 243, 15, 1, 172, 246, 15, 68, 249,
			15, 1, 17, 165, 136, 16, 68, 243, 15, 1,
			172, 246, 15, 68, 249, 15, 1, 17, 165, 137,
			16, 68, 243, 15, 1, 172, 246, 15, 68, 249,
			15, 1, 17, 165, 138, 16, 68, 243, 15, 1,
			172, 246, 15, 68, 249, 15, 1, 17, 165, 139,
			16, 68, 243, 15, 1, 172, 246, 15, 68, 249,
			15, 1, 17, 165, 140, 16, 68, 243, 15, 1,
			172, 246, 15, 68, 249, 15, 1, 17, 165, 141,
			16, 12, 2, 165, 149, 16, 128, 1, 2, 2,
			17, 165, 142, 16, 2, 2, 2, 17, 165, 143,
			16, 2, 2, 2, 17, 165, 144, 16, 2, 2,
			2, 17, 165, 145, 16, 2, 2, 2, 17, 165,
			146, 16, 2, 2, 2, 17, 165, 147, 16, 2,
			2, 2, 17, 165, 148, 16, 2, 2, 2, 0,
			55, 240, 6, 0, 55, 241, 7, 0, 55, 244,
			7, 0, 55, 247, 7, 0, 55, 250, 7, 0,
			55, 253, 7, 0, 55, 128, 8, 0, 55, 131,
			8, 0, 55, 134, 8, 1, 8, 110, 243, 6,
			110, 244, 6, 110, 245, 6, 110, 248, 32, 110,
			249, 32, 110, 250, 32, 110, 251, 32, 110, 252,
			32, 0, 9, 7, 53, 14, 8, 62, 1, 8,
			110, 137, 8, 110, 138, 8, 110, 139, 8, 110,
			140, 8, 5, 4, 7, 54, 0, 158, 7, 54,
			9, 7, 54, 14, 8, 64, 1, 8, 18, 110,
			155, 8, 7, 58, 7, 58, 7, 58, 0, 5,
			7, 7, 58, 0, 158, 7, 58, 9, 7, 58,
			14, 8, 66, 1, 8, 5, 8, 7, 60, 0,
			17, 7, 60, 7, 60, 9, 68, 156, 8, 1,
			7, 60, 7, 60, 1, 64, 5, 8, 6, 5,
			8, 7, 69, 5, 42, 6, 17, 7, 60, 7,
			60, 165, 158, 8, 7, 60, 17, 7, 60, 7,
			60, 165, 159, 8, 7, 60, 5, 4, 6, 0,
			158, 7, 60, 9, 15, 8, 68, 8, 70, 7,
			60, 1, 8, 50, 160, 8, 5, 7, 7, 61,
			0, 158, 7, 61, 14, 8, 72, 1, 8, 160,
			210, 13, 5, 7, 2, 1, 8, 9, 2, 110,
			187, 33, 9, 2, 110, 188, 33, 9, 2, 110,
			189, 33, 9, 2, 110, 190, 33, 5, 4, 2,
			1, 8, 5, 8, 2, 1, 64, 20, 3, 3,
			100, 207, 33, 3, 5, 63, 6, 1, 128, 2,
			17, 129, 130, 20, 183, 131, 20, 2, 2, 17,
			129, 137, 20, 183, 138, 20, 2, 2, 17, 129,
			141, 20, 183, 142, 20, 2, 2, 17, 129, 145,
			20, 183, 146, 20, 2, 2, 17, 129, 149, 20,
			183, 150, 20, 2, 2, 17, 129, 156, 20, 183,
			157, 20, 2, 2, 17, 129, 160, 20, 183, 161,
			20, 2, 2, 17, 129, 164, 20, 183, 165, 20,
			2, 2, 17, 129, 168, 20, 183, 169, 20, 2,
			2, 17, 129, 172, 20, 183, 173, 20, 2, 2,
			17, 129, 176, 20, 183, 177, 20, 2, 2, 17,
			129, 180, 20, 183, 181, 20, 2, 2, 5, 4,
			2, 17, 2, 183, 201, 20, 2, 2, 5, 3,
			2, 17, 2, 183, 228, 20, 2, 2, 17, 2,
			183, 238, 20, 2, 2, 2, 17, 2, 183, 253,
			20, 2, 2, 5, 4, 2, 17, 129, 145, 21,
			183, 146, 21, 2, 2, 17, 129, 152, 21, 183,
			153, 21, 2, 2, 17, 129, 159, 21, 183, 160,
			21, 2, 2, 2, 17, 2, 183, 169, 21, 2,
			2, 17, 2, 183, 178, 21, 2, 2, 17, 2,
			183, 187, 21, 2, 2, 17, 2, 183, 196, 21,
			2, 2, 17, 2, 183, 205, 21, 2, 2, 17,
			2, 183, 214, 21, 2, 2, 4, 17, 2, 183,
			247, 21, 2, 2, 17, 2, 183, 131, 22, 2,
			2, 17, 2, 179, 143, 22, 2, 2, 17, 2,
			183, 152, 22, 2, 2, 5, 4, 2, 17, 2,
			183, 174, 22, 2, 2, 17, 2, 183, 183, 22,
			2, 2, 17, 2, 183, 192, 22, 2, 2, 17,
			2, 183, 201, 22, 2, 2, 17, 2, 183, 210,
			22, 2, 2, 17, 2, 183, 219, 22, 2, 2,
			2, 17, 2, 183, 233, 22, 2, 2, 17, 2,
			183, 239, 22, 2, 2, 17, 2, 183, 251, 22,
			2, 2, 17, 2, 183, 138, 23, 2, 2, 17,
			2, 183, 147, 23, 2, 2, 17, 2, 183, 156,
			23, 2, 2, 17, 2, 183, 162, 23, 2, 2,
			17, 2, 183, 171, 23, 2, 2, 17, 2, 183,
			177, 23, 2, 2, 17, 2, 183, 186, 23, 2,
			2, 17, 2, 183, 195, 23, 2, 2, 5, 62,
			2, 17, 2, 9, 2, 79, 166, 25, 0, 1,
			2, 2, 17, 2, 9, 2, 79, 168, 25, 0,
			1, 2, 2, 17, 2, 9, 2, 79, 170, 25,
			0, 1, 2, 2, 5, 69, 2, 17, 183, 156,
			28, 2, 2, 2, 17, 183, 159, 28, 2, 2,
			2, 17, 183, 160, 28, 2, 2, 2, 17, 183,
			163, 28, 2, 2, 2, 17, 183, 166, 28, 2,
			2, 2, 17, 183, 169, 28, 2, 2, 2, 2,
			17, 2, 183, 172, 28, 2, 2, 5, 8, 2,
			17, 2, 2, 14, 8, 75, 2, 4, 17, 2,
			183, 178, 28, 2, 2, 17, 2, 183, 180, 28,
			184, 191, 33, 192, 33, 2, 17, 2, 183, 186,
			28, 9, 2, 183, 193, 33, 2, 17, 2, 183,
			192, 28, 9, 2, 183, 194, 33, 2, 17, 2,
			183, 198, 28, 9, 2, 183, 195, 33, 2, 5,
			16, 2, 18, 94, 204, 28, 94, 204, 28, 2,
			78, 207, 28, 28, 18, 122, 209, 28, 122, 209,
			28, 2, 76, 212, 28, 28, 5, 3, 2, 17,
			2, 9, 2, 60, 225, 28, 2, 2, 17, 9,
			2, 60, 231, 28, 85, 233, 28, 85, 235, 28,
			2, 2, 17, 2, 90, 247, 28, 90, 250, 28,
			90, 253, 28, 17, 9, 2, 60, 128, 29, 2,
			2, 2, 17, 2, 2, 9, 205, 196, 33, 2,
			2, 17, 2, 2, 9, 205, 197, 33, 2, 2,
			5, 4, 2, 1, 128, 2, 5, 8, 2, 17,
			2, 185, 155, 29, 2, 2, 17, 2, 185, 161,
			29, 2, 2, 17, 2, 185, 167, 29, 2, 2,
			17, 2, 185, 170, 29, 2, 2, 17, 2, 185,
			173, 29, 2, 2, 17, 2, 185, 176, 29, 2,
			2, 17, 2, 185, 179, 29, 2, 2, 17, 130,
			182, 29, 185, 183, 29, 2, 2, 5, 4, 2,
			17, 2, 99, 189, 29, 2, 2, 17, 2, 99,
			195, 29, 2, 2, 17, 2, 99, 201, 29, 2,
			2, 17, 2, 48, 207, 29, 2, 2, 5, 8,
			2, 17, 2, 187, 244, 29, 2, 2, 17, 2,
			185, 250, 29, 2, 2, 17, 2, 187, 253, 29,
			2, 2, 5, 29, 2, 17, 2, 185, 183, 30,
			2, 2, 17, 2, 185, 186, 30, 2, 2, 17,
			2, 185, 188, 30, 2, 2, 2, 17, 2, 185,
			198, 30, 2, 2, 5, 27, 2, 17, 2, 186,
			131, 31, 2, 2, 17, 2, 186, 135, 31, 2,
			2, 17, 2, 185, 139, 31, 2, 2, 17, 2,
			185, 141, 31, 2, 2, 5, 104, 2, 17, 185,
			217, 31, 2, 2, 2, 2, 17, 2, 185, 218,
			31, 2, 2, 17, 2, 185, 224, 31, 2, 2,
			5, 15, 2, 17, 2, 185, 230, 31, 2, 2,
			5, 16, 2, 15, 8, 76, 8, 77, 5, 15,
			2, 1, 128, 2, 14, 8, 31, 15, 8, 32,
			8, 33, 87, 222, 6, 87, 225, 6, 0, 10,
			2, 164, 228, 6, 128, 2, 2, 0, 10, 164,
			230, 6, 164, 229, 6, 128, 2, 164, 230, 6,
			164, 231, 6, 0, 10, 167, 233, 6, 233, 6,
			234, 6, 164, 232, 6, 128, 4, 167, 233, 6,
			233, 6, 234, 6, 164, 235, 6, 189, 0, 10,
			2, 164, 238, 6, 128, 8, 2, 164, 239, 6,
			2, 158, 7, 53, 7, 63, 10, 164, 246, 6,
			164, 209, 35, 128, 128, 2, 10, 22, 164, 210,
			35, 128, 128, 2, 0, 10, 17, 183, 253, 6,
			183, 131, 7, 183, 137, 7, 183, 142, 7, 43,
			247, 6, 8, 17, 183, 253, 6, 183, 131, 7,
			183, 137, 7, 183, 142, 7, 0, 10, 17, 190,
			147, 7, 190, 153, 7, 190, 159, 7, 190, 164,
			7, 56, 248, 6, 8, 17, 190, 147, 7, 190,
			153, 7, 190, 159, 7, 190, 164, 7, 0, 10,
			17, 184, 169, 7, 170, 7, 179, 175, 7, 183,
			178, 7, 183, 184, 7, 75, 250, 6, 8, 17,
			184, 169, 7, 170, 7, 179, 175, 7, 183, 178,
			7, 183, 184, 7, 0, 10, 17, 121, 190, 7,
			121, 193, 7, 2, 2, 81, 251, 6, 8, 17,
			121, 190, 7, 121, 193, 7, 2, 2, 17, 183,
			196, 7, 183, 202, 7, 2, 2, 17, 183, 208,
			7, 183, 214, 7, 2, 2, 17, 184, 220, 7,
			223, 7, 179, 226, 7, 183, 229, 7, 2, 17,
			121, 235, 7, 121, 238, 7, 2, 2, 7, 65,
			7, 55, 158, 7, 56, 12, 7, 56, 17, 9,
			7, 56, 31, 141, 8, 29, 142, 8, 30, 144,
			8, 1, 30, 146, 8, 1, 128, 128, 32, 158,
			7, 57, 12, 7, 57, 17, 9, 7, 57, 118,
			148, 8, 32, 149, 8, 9, 7, 57, 30, 151,
			8, 0, 30, 153, 8, 1, 128, 128, 32, 7,
			67, 7, 59, 7, 71, 7, 73, 141, 163, 8,
			185, 141, 165, 8, 201, 35, 167, 8, 185, 35,
			169, 8, 201, 0, 10, 2, 142, 171, 8, 233,
			128, 16, 2, 2, 0, 10, 2, 36, 172, 8,
			233, 128, 16, 2, 2, 17, 183, 173, 8, 183,
			179, 8, 2, 2, 17, 190, 185, 8, 190, 191,
			8, 2, 2, 17, 181, 197, 8, 181, 198, 8,
			178, 199, 8, 178, 205, 8, 17, 121, 211, 8,
			121, 217, 8, 121, 223, 8, 121, 224, 8, 17,
			132, 225, 8, 132, 226, 8, 98, 227, 8, 98,
			233, 8, 17, 132, 239, 8, 132, 240, 8, 98,
			241, 8, 98, 247, 8, 17, 183, 253, 8, 183,
			128, 9, 2, 2, 17, 183, 131, 9, 183, 132,
			9, 2, 2, 164, 137, 9, 164, 138, 9, 164,
			139, 9, 164, 140, 9, 164, 141, 9, 170, 142,
			9, 200, 2, 14, 8, 34, 128, 128, 64, 200,
			20, 199, 144, 9, 255, 32, 3, 3, 3, 14,
			8, 35, 128, 128, 64, 200, 13, 8, 78, 164,
			144, 33, 128, 128, 64, 200, 2, 164, 145, 33,
			128, 128, 128, 2, 201, 13, 8, 79, 164, 146,
			33, 128, 128, 128, 2, 164, 154, 33, 128, 128,
			64, 200, 2, 164, 155, 33, 128, 128, 64, 200,
			2, 164, 156, 33, 128, 128, 64, 200, 2, 164,
			157, 33, 128, 128, 64, 2, 200, 2, 164, 158,
			33, 128, 128, 128, 4, 80, 145, 9, 80, 148,
			9, 80, 151, 9, 80, 154, 9, 80, 157, 9,
			80, 160, 9, 80, 163, 9, 80, 166, 9, 80,
			169, 9, 80, 172, 9, 80, 175, 9, 80, 178,
			9, 80, 181, 9, 80, 184, 9, 80, 187, 9,
			80, 190, 9, 200, 17, 97, 224, 9, 97, 230,
			9, 2, 2, 129, 159, 33, 128, 128, 64, 200,
			17, 183, 236, 9, 183, 242, 9, 183, 248, 9,
			183, 251, 9, 129, 160, 33, 128, 128, 64, 200,
			17, 183, 254, 9, 2, 183, 129, 10, 2, 129,
			161, 33, 128, 128, 64, 17, 183, 131, 10, 2,
			183, 134, 10, 2, 200, 17, 183, 136, 10, 183,
			142, 10, 2, 2, 9, 2, 129, 162, 33, 128,
			128, 64, 200, 17, 183, 148, 10, 183, 154, 10,
			2, 2, 129, 163, 33, 128, 128, 64, 17, 183,
			160, 10, 183, 166, 10, 2, 2, 17, 183, 172,
			10, 183, 178, 10, 2, 2, 200, 17, 183, 184,
			10, 183, 190, 10, 183, 196, 10, 183, 199, 10,
			9, 2, 129, 164, 33, 128, 128, 64, 200, 17,
			183, 202, 10, 183, 208, 10, 183, 214, 10, 183,
			217, 10, 129, 165, 33, 128, 128, 64, 200, 17,
			183, 220, 10, 183, 226, 10, 183, 232, 10, 183,
			235, 10, 9, 2, 129, 166, 33, 128, 128, 64,
			200, 17, 183, 238, 10, 183, 247, 10, 183, 253,
			10, 2, 9, 2, 129, 167, 33, 128, 128, 64,
			200, 17, 183, 131, 11, 183, 137, 11, 183, 143,
			11, 183, 146, 11, 9, 2, 129, 168, 33, 128,
			128, 64, 200, 17, 183, 149, 11, 183, 155, 11,
			183, 161, 11, 183, 164, 11, 129, 169, 33, 128,
			128, 64, 200, 17, 183, 167, 11, 183, 173, 11,
			183, 179, 11, 183, 182, 11, 9, 2, 129, 170,
			33, 128, 128, 64, 17, 183, 185, 11, 183, 191,
			11, 183, 197, 11, 183, 200, 11, 17, 129, 203,
			11, 183, 204, 11, 2, 2, 17, 129, 210, 11,
			183, 211, 11, 2, 2, 17, 129, 217, 11, 183,
			218, 11, 2, 2, 17, 129, 224, 11, 183, 225,
			11, 2, 2, 17, 129, 231, 11, 183, 232, 11,
			2, 2, 17, 129, 238, 11, 183, 239, 11, 2,
			2, 17, 129, 245, 11, 183, 246, 11, 2, 2,
			17, 129, 252, 11, 183, 253, 11, 2, 2, 17,
			129, 131, 12, 183, 132, 12, 2, 2, 17, 129,
			138, 12, 183, 139, 12, 2, 2, 17, 129, 145,
			12, 183, 146, 12, 2, 2, 17, 129, 152, 12,
			183, 153, 12, 2, 2, 17, 2, 183, 159, 12,
			2, 2, 17, 2, 183, 165, 12, 2, 2, 17,
			127, 171, 12, 188, 173, 12, 2, 2, 17, 129,
			179, 12, 183, 180, 12, 183, 189, 12, 2, 17,
			130, 204, 12, 185, 205, 12, 185, 211, 12, 185,
			217, 12, 14, 8, 48, 14, 8, 49, 14, 8,
			50, 17, 129, 178, 13, 183, 179, 13, 2, 2,
			17, 129, 185, 13, 183, 186, 13, 2, 2, 17,
			129, 192, 13, 183, 193, 13, 2, 2, 20, 164,
			199, 13, 3, 3, 3, 200, 17, 54, 202, 13,
			14, 8, 74, 2, 182, 219, 13, 202, 147, 33,
			128, 128, 64, 200, 17, 79, 222, 13, 1, 1,
			9, 184, 230, 13, 0, 2, 2, 9, 184, 239,
			13, 0, 2, 203, 148, 33, 128, 128, 64, 200,
			2, 14, 8, 36, 128, 128, 64, 200, 2, 14,
			8, 37, 128, 128, 64, 200, 17, 2, 183, 142,
			14, 2, 183, 145, 14, 14, 8, 38, 128, 128,
			64, 200, 17, 2, 183, 148, 14, 2, 183, 151,
			14, 14, 8, 39, 128, 128, 64, 200, 17, 67,
			154, 14, 70, 156, 14, 183, 162, 14, 2, 164,
			153, 33, 128, 128, 128, 1, 17, 140, 165, 14,
			190, 166, 14, 190, 175, 14, 2, 109, 190, 14,
			109, 193, 14, 109, 196, 14, 109, 199, 14, 109,
			202, 14, 109, 205, 14, 109, 208, 14, 109, 211,
			14, 109, 214, 14, 109, 217, 14, 109, 220, 14,
			109, 223, 14, 109, 226, 14, 109, 229, 14, 109,
			232, 14, 109, 235, 14, 40, 238, 14, 40, 239,
			14, 40, 240, 14, 40, 241, 14, 40, 242, 14,
			40, 243, 14, 40, 244, 14, 40, 245, 14, 40,
			246, 14, 40, 247, 14, 40, 248, 14, 40, 249,
			14, 40, 250, 14, 40, 251, 14, 40, 252, 14,
			40, 253, 14, 136, 150, 15, 75, 136, 153, 15,
			75, 164, 156, 15, 55, 157, 15, 59, 160, 15,
			58, 163, 15, 0, 11, 14, 8, 40, 81, 175,
			15, 16, 43, 197, 15, 32, 14, 8, 40, 0,
			11, 14, 8, 41, 56, 195, 15, 16, 56, 198,
			15, 32, 14, 8, 41, 136, 200, 15, 76, 136,
			203, 15, 76, 164, 206, 15, 57, 207, 15, 11,
			59, 210, 15, 58, 213, 15, 15, 8, 51, 8,
			52, 80, 150, 16, 44, 153, 16, 11, 57, 154,
			16, 11, 93, 157, 16, 57, 160, 16, 11, 93,
			163, 16, 93, 166, 16, 77, 169, 16, 88, 172,
			16, 10, 18, 2, 2, 80, 177, 16, 2, 28,
			0, 107, 175, 16, 18, 2, 2, 80, 177, 16,
			2, 28, 128, 32, 80, 180, 16, 14, 8, 42,
			57, 195, 16, 11, 10, 18, 80, 198, 16, 80,
			198, 16, 80, 201, 16, 80, 198, 16, 20, 80,
			198, 16, 128, 128, 4, 10, 18, 80, 204, 16,
			80, 204, 16, 80, 207, 16, 80, 204, 16, 20,
			80, 204, 16, 128, 128, 8, 77, 210, 16, 88,
			213, 16, 44, 216, 16, 11, 57, 217, 16, 11,
			17, 185, 220, 16, 185, 226, 16, 185, 232, 16,
			185, 235, 16, 17, 123, 238, 16, 2, 2, 2,
			17, 128, 240, 16, 187, 242, 16, 2, 2, 17,
			96, 248, 16, 9, 83, 250, 16, 2, 2, 2,
			17, 185, 128, 17, 185, 134, 17, 2, 2, 14,
			8, 43, 173, 160, 17, 0, 173, 160, 17, 1,
			173, 160, 17, 2, 173, 160, 17, 3, 173, 160,
			17, 4, 173, 160, 17, 5, 173, 160, 17, 6,
			173, 160, 17, 7, 17, 2, 183, 163, 17, 2,
			183, 166, 17, 17, 129, 169, 17, 183, 170, 17,
			2, 2, 17, 129, 176, 17, 183, 177, 17, 2,
			2, 17, 129, 183, 17, 183, 184, 17, 2, 2,
			17, 129, 190, 17, 183, 191, 17, 2, 2, 17,
			129, 197, 17, 183, 198, 17, 2, 2, 17, 2,
			190, 204, 17, 180, 207, 17, 131, 208, 17, 17,
			95, 209, 17, 97, 211, 17, 2, 2, 17, 129,
			217, 17, 183, 218, 17, 2, 2, 17, 129, 224,
			17, 183, 225, 17, 2, 2, 17, 129, 231, 17,
			183, 232, 17, 2, 2, 17, 129, 238, 17, 183,
			239, 17, 2, 2, 17, 129, 248, 17, 183, 249,
			17, 2, 2, 17, 129, 255, 17, 183, 128, 18,
			2, 2, 17, 129, 134, 18, 183, 135, 18, 2,
			2, 17, 129, 141, 18, 183, 142, 18, 2, 2,
			17, 129, 151, 18, 183, 152, 18, 2, 2, 17,
			129, 158, 18, 183, 159, 18, 2, 2, 17, 129,
			165, 18, 183, 166, 18, 2, 2, 17, 129, 175,
			18, 183, 176, 18, 2, 2, 17, 129, 182, 18,
			183, 183, 18, 2, 2, 17, 129, 189, 18, 183,
			190, 18, 2, 2, 17, 2, 183, 196, 18, 183,
			202, 18, 183, 211, 18, 17, 119, 217, 18, 121,
			218, 18, 2, 2, 17, 129, 224, 18, 183, 225,
			18, 2, 2, 17, 129, 231, 18, 183, 232, 18,
			2, 2, 17, 129, 238, 18, 183, 239, 18, 2,
			2, 17, 129, 245, 18, 183, 246, 18, 2, 2,
			17, 129, 255, 18, 183, 128, 19, 2, 2, 17,
			129, 134, 19, 183, 135, 19, 2, 2, 17, 129,
			141, 19, 183, 142, 19, 2, 2, 17, 129, 148,
			19, 183, 149, 19, 2, 2, 17, 2, 2, 2,
			179, 158, 19, 17, 129, 161, 19, 183, 162, 19,
			2, 2, 17, 129, 168, 19, 183, 169, 19, 2,
			2, 17, 129, 175, 19, 183, 176, 19, 2, 2,
			17, 129, 182, 19, 183, 183, 19, 2, 2, 17,
			129, 189, 19, 183, 190, 19, 2, 2, 17, 129,
			196, 19, 183, 197, 19, 2, 2, 17, 143, 203,
			19, 144, 204, 19, 2, 2, 17, 129, 206, 19,
			183, 207, 19, 2, 2, 17, 129, 213, 19, 183,
			214, 19, 2, 2, 17, 129, 220, 19, 183, 221,
			19, 2, 2, 17, 129, 227, 19, 183, 228, 19,
			2, 2, 17, 129, 234, 19, 183, 235, 19, 2,
			2, 17, 129, 241, 19, 183, 242, 19, 2, 2,
			17, 129, 248, 19, 183, 249, 19, 2, 2, 10,
			80, 255, 19, 164, 253, 32, 2, 1, 128, 2,
			44, 5, 11, 57, 6, 11, 75, 9, 80, 10,
			155, 13, 1, 147, 14, 0, 137, 17, 71, 2,
			0, 137, 19, 71, 2, 44, 21, 11, 57, 22,
			11, 75, 25, 80, 26, 155, 29, 1, 147, 30,
			0, 137, 33, 72, 2, 13, 8, 80, 44, 36,
			11, 57, 37, 11, 75, 40, 80, 41, 155, 44,
			1, 147, 45, 0, 137, 48, 73, 2, 0, 137,
			50, 73, 2, 44, 52, 11, 57, 53, 11, 75,
			56, 80, 57, 155, 60, 1, 147, 61, 0, 137,
			64, 74, 2, 0, 137, 66, 74, 2, 44, 68,
			11, 57, 69, 11, 75, 72, 80, 73, 155, 76,
			1, 147, 77, 206, 71, 0, 164, 80, 2, 44,
			81, 11, 57, 82, 11, 75, 85, 80, 86, 155,
			89, 1, 147, 90, 206, 72, 0, 164, 93, 2,
			44, 94, 11, 57, 95, 11, 75, 98, 80, 99,
			155, 102, 1, 147, 103, 206, 73, 0, 164, 106,
			2, 43, 107, 55, 108, 75, 111, 80, 112, 155,
			115, 1, 147, 116, 206, 74, 0, 164, 119, 2,
			213, 173, 120, 0, 0, 213, 173, 120, 1, 1,
			213, 173, 120, 2, 2, 213, 173, 120, 3, 3,
			213, 173, 120, 4, 4, 213, 173, 120, 5, 5,
			213, 173, 120, 6, 6, 213, 173, 120, 7, 7,
			213, 173, 122, 0, 8, 213, 173, 122, 1, 9,
			213, 173, 122, 2, 10, 213, 173, 122, 3, 11,
			213, 173, 122, 4, 12, 213, 173, 122, 5, 13,
			213, 173, 122, 6, 14, 213, 173, 122, 7, 15,
			139, 0, 124, 139, 1, 124, 139, 2, 124, 139,
			3, 124, 139, 4, 124, 139, 5, 124, 139, 6,
			124, 139, 7, 124, 139, 0, 127, 139, 1, 127,
			139, 2, 127, 139, 3, 127, 139, 4, 127, 139,
			5, 127, 139, 6, 127, 139, 7, 127, 0, 167,
			130, 1, 131, 1, 131, 1, 2, 0, 167, 132,
			1, 133, 1, 133, 1, 2, 23, 91, 134, 1,
			0, 163, 136, 1, 86, 138, 1, 207, 75, 207,
			76, 208, 209, 135, 141, 1, 84, 144, 1, 134,
			147, 1, 82, 150, 1, 194, 153, 1, 23, 197,
			154, 1, 150, 156, 1, 23, 152, 157, 1, 105,
			159, 1, 105, 162, 1, 105, 165, 1, 105, 168,
			1, 105, 171, 1, 105, 174, 1, 105, 177, 1,
			105, 180, 1, 105, 183, 1, 105, 186, 1, 105,
			189, 1, 105, 192, 1, 105, 195, 1, 105, 198,
			1, 105, 201, 1, 105, 204, 1, 14, 8, 16,
			14, 8, 17, 0, 14, 8, 18, 2, 14, 8,
			19, 43, 143, 2, 55, 144, 2, 44, 147, 2,
			15, 57, 148, 2, 15, 44, 151, 2, 6, 57,
			152, 2, 6, 75, 155, 2, 80, 156, 2, 69,
			159, 2, 89, 162, 2, 177, 165, 2, 26, 14,
			8, 20, 192, 0, 192, 1, 192, 2, 192, 3,
			192, 4, 192, 5, 192, 6, 192, 7, 166, 178,
			2, 166, 181, 2, 0, 28, 184, 2, 2, 164,
			186, 2, 138, 187, 2, 138, 190, 2, 0, 164,
			193, 2, 10, 164, 193, 2, 2, 128, 128, 16,
			0, 164, 194, 2, 10, 164, 194, 2, 2, 128,
			128, 16, 148, 195, 2, 1, 149, 196, 2, 125,
			199, 2, 1, 126, 200, 2, 195, 203, 2, 198,
			204, 2, 191, 207, 2, 193, 208, 2, 155, 211,
			2, 1, 147, 212, 2, 194, 215, 2, 1, 196,
			216, 2, 150, 219, 2, 1, 151, 220, 2, 153,
			223, 2, 1, 154, 224, 2, 156, 0, 156, 1,
			156, 2, 156, 3, 156, 4, 156, 5, 156, 6,
			156, 7, 157, 0, 157, 1, 157, 2, 157, 3,
			157, 4, 157, 5, 157, 6, 157, 7, 14, 8,
			21, 14, 8, 22, 33, 135, 3, 34, 138, 3,
			25, 92, 141, 3, 24, 92, 143, 3, 15, 8,
			44, 8, 45, 15, 8, 46, 8, 47, 104, 152,
			3, 169, 155, 3, 168, 158, 3, 166, 161, 3,
			164, 164, 3, 100, 165, 3, 0, 164, 166, 3,
			2, 166, 167, 3, 14, 8, 23, 14, 8, 24,
			14, 8, 25, 14, 8, 26, 0, 100, 234, 3,
			2, 0, 100, 235, 3, 2, 0, 164, 236, 3,
			2, 114, 237, 3, 16, 8, 0, 8, 1, 15,
			8, 2, 8, 3, 15, 8, 4, 8, 5, 15,
			8, 6, 8, 7, 16, 8, 8, 8, 9, 15,
			8, 10, 8, 11, 15, 8, 12, 8, 13, 15,
			8, 14, 8, 15, 106, 145, 5, 147, 5, 150,
			5, 146, 5, 148, 5, 149, 5, 151, 5, 106,
			152, 5, 154, 5, 157, 5, 153, 5, 155, 5,
			156, 5, 158, 5, 106, 159, 5, 161, 5, 164,
			5, 160, 5, 162, 5, 163, 5, 165, 5, 106,
			166, 5, 168, 5, 171, 5, 167, 5, 169, 5,
			170, 5, 172, 5, 155, 173, 5, 1, 146, 174,
			5, 102, 176, 5, 1, 103, 177, 5, 109, 179,
			5, 109, 182, 5, 0, 28, 185, 5, 2, 105,
			187, 5, 27, 190, 5, 39, 191, 5, 37, 193,
			5, 38, 194, 5, 210, 164, 196, 5, 211, 212,
			164, 197, 5, 164, 198, 5, 14, 8, 27, 14,
			8, 28, 164, 231, 5, 164, 232, 5, 164, 233,
			5, 164, 234, 5, 164, 235, 5, 164, 236, 5,
			14, 8, 29, 14, 8, 30
		};
	}
}


using System;
using Iced.Intel.DecoderInternal;

internal static class OpCodeHandlersTables_VEX
{
	internal static readonly OpCodeHandler[] Handlers_0F;

	internal static readonly OpCodeHandler[] Handlers_0F38;

	internal static readonly OpCodeHandler[] Handlers_0F3A;

	private const int MaxIdNames = 16;

	private const uint Handlers_MAP0Index = 14u;

	private const uint Handlers_0FIndex = 15u;

	private const uint Handlers_0F38Index = 12u;

	private const uint Handlers_0F3AIndex = 13u;

	static OpCodeHandlersTables_VEX()
	{
		VexOpCodeHandlerReader handlerReader = new VexOpCodeHandlerReader();
		TableDeserializer tableDeserializer = new TableDeserializer(handlerReader, 16, GetSerializedTables());
		tableDeserializer.Deserialize();
		Handlers_0F = tableDeserializer.GetTable(15u);
		Handlers_0F38 = tableDeserializer.GetTable(12u);
		Handlers_0F3A = tableDeserializer.GetTable(13u);
	}

	private static ReadOnlySpan<byte> GetSerializedTables()
	{
		return new byte[6181]
		{
			1, 8, 11, 14, 71, 0, 4, 0, 29, 213,
			35, 128, 128, 128, 8, 0, 0, 0, 0, 11,
			14, 71, 0, 4, 0, 29, 214, 35, 128, 128,
			128, 8, 0, 0, 0, 0, 11, 14, 71, 0,
			4, 0, 29, 215, 35, 128, 128, 128, 8, 0,
			0, 0, 0, 11, 14, 71, 0, 4, 0, 29,
			216, 35, 128, 128, 128, 8, 0, 0, 0, 0,
			11, 14, 71, 0, 4, 0, 29, 217, 35, 128,
			128, 128, 8, 0, 0, 0, 0, 11, 14, 71,
			0, 4, 0, 29, 218, 35, 128, 128, 128, 8,
			0, 0, 0, 0, 11, 14, 71, 0, 4, 0,
			29, 219, 35, 128, 128, 128, 8, 0, 0, 0,
			0, 11, 14, 71, 0, 4, 0, 29, 220, 35,
			128, 128, 128, 8, 0, 0, 0, 0, 1, 8,
			1, 11, 0, 14, 26, 77, 225, 12, 26, 109,
			226, 12, 0, 0, 0, 11, 0, 14, 26, 77,
			232, 12, 26, 109, 233, 12, 0, 0, 0, 11,
			0, 14, 26, 77, 239, 12, 26, 109, 240, 12,
			0, 0, 0, 1, 8, 1, 11, 0, 14, 26,
			77, 130, 13, 26, 109, 131, 13, 0, 0, 0,
			11, 0, 14, 26, 77, 137, 13, 26, 109, 138,
			13, 0, 0, 0, 11, 0, 14, 26, 77, 147,
			13, 26, 109, 148, 13, 0, 0, 0, 1, 8,
			1, 11, 0, 14, 26, 77, 154, 13, 26, 109,
			155, 13, 0, 0, 11, 0, 14, 26, 77, 160,
			13, 26, 109, 161, 13, 0, 0, 1, 11, 0,
			14, 26, 77, 167, 13, 26, 109, 168, 13, 0,
			0, 11, 0, 14, 26, 77, 173, 13, 26, 109,
			174, 13, 0, 0, 1, 8, 1, 11, 14, 29,
			227, 15, 0, 0, 0, 0, 11, 14, 29, 231,
			15, 0, 0, 0, 0, 1, 11, 0, 0, 14,
			71, 0, 4, 0, 7, 75, 238, 35, 0, 128,
			128, 128, 8, 0, 14, 71, 0, 4, 0, 7,
			75, 240, 35, 0, 128, 128, 128, 8, 0, 11,
			0, 0, 14, 71, 0, 4, 0, 29, 242, 35,
			128, 128, 128, 8, 0, 14, 71, 0, 4, 0,
			29, 243, 35, 128, 128, 128, 8, 0, 1, 8,
			0, 11, 14, 28, 217, 28, 0, 0, 0, 0,
			11, 14, 28, 219, 28, 0, 0, 0, 0, 11,
			14, 28, 221, 28, 0, 0, 0, 0, 2, 4,
			0, 1, 8, 7, 0, 29, 128, 33, 2, 7,
			0, 1, 64, 35, 129, 33, 2, 63, 70, 1,
			8, 7, 0, 29, 130, 33, 2, 7, 0, 1,
			64, 2, 64, 70, 1, 8, 2, 8, 0, 1,
			64, 66, 131, 33, 2, 7, 70, 66, 131, 33,
			2, 7, 70, 66, 131, 33, 2, 7, 70, 66,
			131, 33, 2, 7, 70, 66, 131, 33, 2, 7,
			70, 66, 131, 33, 2, 7, 70, 66, 131, 33,
			2, 7, 70, 66, 131, 33, 2, 7, 70, 1,
			128, 2, 11, 0, 14, 41, 77, 132, 20, 41,
			109, 133, 20, 0, 0, 11, 0, 14, 41, 77,
			139, 20, 41, 109, 140, 20, 0, 0, 11, 0,
			14, 41, 77, 143, 20, 41, 109, 144, 20, 0,
			0, 11, 0, 14, 41, 77, 147, 20, 41, 109,
			148, 20, 0, 0, 11, 0, 14, 41, 77, 151,
			20, 41, 109, 152, 20, 0, 0, 11, 0, 14,
			41, 77, 158, 20, 41, 109, 159, 20, 0, 0,
			11, 0, 14, 41, 77, 162, 20, 41, 109, 163,
			20, 0, 0, 11, 0, 14, 41, 77, 166, 20,
			41, 109, 167, 20, 0, 0, 11, 0, 14, 41,
			77, 170, 20, 41, 109, 171, 20, 0, 0, 11,
			0, 14, 41, 77, 174, 20, 41, 109, 175, 20,
			0, 0, 11, 0, 14, 41, 77, 178, 20, 41,
			109, 179, 20, 0, 0, 11, 0, 14, 41, 77,
			182, 20, 41, 109, 183, 20, 0, 0, 11, 0,
			9, 14, 41, 77, 187, 20, 41, 109, 188, 20,
			0, 0, 0, 11, 0, 9, 14, 41, 77, 192,
			20, 41, 109, 193, 20, 0, 0, 0, 11, 0,
			9, 14, 54, 77, 197, 20, 54, 109, 198, 20,
			0, 0, 0, 11, 0, 9, 14, 54, 77, 199,
			20, 54, 109, 200, 20, 0, 0, 0, 2, 3,
			0, 11, 0, 9, 14, 55, 77, 77, 220, 20,
			55, 109, 77, 221, 20, 0, 0, 0, 1, 11,
			0, 9, 14, 0, 41, 109, 248, 20, 0, 0,
			0, 11, 0, 14, 54, 77, 254, 20, 54, 109,
			255, 20, 0, 0, 11, 0, 9, 14, 7, 55,
			77, 77, 198, 33, 55, 77, 77, 128, 21, 7,
			55, 109, 77, 199, 33, 55, 109, 77, 129, 21,
			0, 0, 0, 11, 0, 9, 14, 0, 7, 55,
			109, 77, 200, 33, 55, 109, 77, 133, 21, 0,
			0, 0, 11, 0, 9, 14, 0, 53, 109, 138,
			21, 0, 0, 0, 0, 11, 0, 14, 54, 77,
			147, 21, 54, 109, 148, 21, 0, 0, 11, 0,
			14, 54, 77, 154, 21, 54, 109, 155, 21, 0,
			0, 11, 0, 14, 54, 77, 161, 21, 54, 109,
			162, 21, 0, 0, 0, 11, 0, 14, 55, 77,
			77, 170, 21, 55, 109, 77, 171, 21, 0, 0,
			11, 0, 14, 55, 77, 77, 179, 21, 55, 109,
			77, 180, 21, 0, 0, 11, 0, 14, 55, 77,
			77, 188, 21, 55, 109, 77, 189, 21, 0, 0,
			11, 0, 14, 55, 77, 77, 197, 21, 55, 109,
			77, 198, 21, 0, 0, 11, 0, 14, 55, 77,
			77, 206, 21, 55, 109, 77, 207, 21, 0, 0,
			11, 0, 14, 55, 77, 77, 215, 21, 55, 109,
			77, 216, 21, 0, 0, 1, 11, 0, 14, 41,
			77, 248, 21, 41, 109, 249, 21, 0, 0, 11,
			0, 14, 41, 77, 132, 22, 41, 109, 133, 22,
			0, 0, 11, 0, 14, 53, 77, 144, 22, 53,
			109, 145, 22, 0, 0, 11, 0, 14, 41, 77,
			153, 22, 41, 109, 154, 22, 0, 0, 11, 0,
			9, 14, 40, 77, 158, 22, 40, 109, 159, 22,
			0, 0, 0, 11, 0, 9, 14, 40, 77, 166,
			22, 40, 109, 167, 22, 0, 0, 0, 11, 0,
			9, 14, 30, 77, 170, 22, 30, 109, 171, 22,
			0, 0, 0, 11, 0, 9, 14, 30, 77, 172,
			22, 30, 109, 173, 22, 0, 0, 0, 11, 0,
			14, 55, 77, 77, 175, 22, 55, 109, 77, 176,
			22, 0, 0, 11, 0, 14, 55, 77, 77, 184,
			22, 55, 109, 77, 185, 22, 0, 0, 11, 0,
			14, 55, 77, 77, 193, 22, 55, 109, 77, 194,
			22, 0, 0, 11, 0, 14, 55, 77, 77, 202,
			22, 55, 109, 77, 203, 22, 0, 0, 11, 0,
			14, 55, 77, 77, 211, 22, 55, 109, 77, 212,
			22, 0, 0, 11, 0, 14, 55, 77, 77, 220,
			22, 55, 109, 77, 221, 22, 0, 0, 11, 0,
			9, 14, 0, 41, 109, 228, 22, 0, 0, 0,
			11, 0, 14, 41, 77, 234, 22, 41, 109, 235,
			22, 0, 0, 11, 0, 14, 41, 77, 240, 22,
			41, 109, 241, 22, 0, 0, 11, 0, 14, 41,
			77, 252, 22, 41, 109, 253, 22, 0, 0, 11,
			0, 14, 41, 77, 139, 23, 41, 109, 140, 23,
			0, 0, 11, 0, 14, 41, 77, 148, 23, 41,
			109, 149, 23, 0, 0, 11, 0, 14, 41, 77,
			157, 23, 41, 109, 158, 23, 0, 0, 11, 0,
			14, 41, 77, 163, 23, 41, 109, 164, 23, 0,
			0, 11, 0, 14, 41, 77, 172, 23, 41, 109,
			173, 23, 0, 0, 11, 0, 14, 41, 77, 178,
			23, 41, 109, 179, 23, 0, 0, 11, 0, 14,
			41, 77, 187, 23, 41, 109, 188, 23, 0, 0,
			11, 0, 14, 54, 77, 196, 23, 0, 0, 0,
			2, 3, 0, 11, 0, 9, 14, 41, 77, 211,
			23, 41, 109, 212, 23, 14, 41, 77, 213, 23,
			41, 109, 214, 23, 0, 0, 11, 0, 9, 14,
			41, 77, 221, 23, 41, 109, 222, 23, 0, 0,
			0, 11, 0, 9, 14, 41, 77, 229, 23, 41,
			109, 230, 23, 14, 41, 77, 231, 23, 41, 109,
			232, 23, 0, 0, 0, 69, 0, 11, 9, 14,
			68, 6, 6, 6, 7, 0, 0, 9, 14, 68,
			6, 8, 6, 9, 0, 0, 0, 9, 14, 68,
			6, 10, 6, 11, 0, 0, 0, 69, 0, 11,
			0, 9, 14, 7, 0, 64, 132, 33, 0, 0,
			9, 14, 7, 0, 65, 133, 33, 0, 0, 9,
			14, 7, 0, 64, 134, 33, 0, 0, 2, 4,
			0, 11, 0, 9, 14, 41, 77, 208, 33, 41,
			109, 209, 33, 0, 0, 0, 11, 0, 9, 14,
			41, 77, 210, 33, 41, 109, 211, 33, 0, 0,
			0, 11, 0, 9, 14, 41, 77, 212, 33, 41,
			109, 213, 33, 0, 0, 0, 11, 0, 9, 14,
			41, 77, 214, 33, 41, 109, 215, 33, 0, 0,
			0, 2, 4, 0, 11, 0, 9, 14, 55, 77,
			77, 156, 24, 55, 109, 77, 157, 24, 0, 0,
			0, 11, 0, 9, 14, 55, 77, 77, 161, 24,
			55, 109, 77, 162, 24, 0, 0, 0, 11, 0,
			9, 14, 0, 53, 109, 169, 24, 0, 0, 0,
			0, 69, 0, 11, 0, 0, 9, 14, 7, 67,
			135, 33, 0, 0, 0, 0, 0, 69, 0, 11,
			9, 14, 7, 67, 136, 33, 0, 0, 0, 9,
			14, 7, 67, 137, 33, 0, 0, 0, 9, 14,
			7, 67, 138, 33, 0, 0, 0, 9, 14, 7,
			67, 139, 33, 0, 0, 0, 2, 25, 0, 11,
			0, 9, 14, 55, 77, 77, 254, 24, 55, 109,
			77, 255, 24, 0, 0, 0, 11, 0, 9, 14,
			55, 77, 77, 131, 25, 55, 109, 77, 132, 25,
			0, 0, 0, 2, 18, 0, 11, 0, 9, 14,
			40, 77, 199, 25, 40, 109, 200, 25, 14, 40,
			77, 201, 25, 40, 109, 202, 25, 0, 0, 0,
			11, 0, 9, 14, 30, 77, 209, 25, 30, 109,
			210, 25, 14, 30, 77, 211, 25, 30, 109, 212,
			25, 0, 0, 0, 11, 0, 9, 14, 60, 77,
			77, 77, 216, 25, 60, 109, 109, 109, 217, 25,
			14, 60, 77, 77, 77, 218, 25, 60, 109, 77,
			109, 219, 25, 0, 0, 11, 0, 9, 14, 60,
			77, 77, 77, 226, 25, 60, 77, 109, 77, 227,
			25, 14, 60, 77, 77, 77, 228, 25, 60, 109,
			109, 109, 229, 25, 0, 0, 11, 0, 9, 14,
			60, 77, 77, 77, 236, 25, 60, 109, 109, 109,
			237, 25, 14, 60, 77, 77, 77, 238, 25, 60,
			109, 77, 109, 239, 25, 0, 0, 11, 0, 9,
			14, 60, 77, 77, 77, 246, 25, 60, 77, 109,
			77, 247, 25, 14, 60, 77, 77, 77, 248, 25,
			60, 109, 109, 109, 249, 25, 0, 0, 1, 11,
			0, 9, 14, 41, 77, 128, 26, 41, 109, 129,
			26, 14, 41, 77, 130, 26, 41, 109, 131, 26,
			0, 0, 11, 0, 9, 14, 41, 77, 138, 26,
			41, 109, 139, 26, 14, 41, 77, 140, 26, 41,
			109, 141, 26, 0, 0, 11, 0, 9, 14, 41,
			77, 148, 26, 41, 109, 149, 26, 14, 41, 77,
			150, 26, 41, 109, 151, 26, 0, 0, 11, 0,
			9, 41, 77, 158, 26, 41, 77, 159, 26, 0,
			0, 11, 0, 9, 14, 41, 77, 162, 26, 41,
			109, 163, 26, 14, 41, 77, 164, 26, 41, 109,
			165, 26, 0, 0, 11, 0, 9, 41, 77, 173,
			26, 41, 77, 174, 26, 0, 0, 11, 0, 9,
			14, 41, 77, 178, 26, 41, 109, 179, 26, 14,
			41, 77, 180, 26, 41, 109, 181, 26, 0, 0,
			11, 0, 9, 41, 77, 188, 26, 41, 77, 189,
			26, 0, 0, 11, 0, 9, 14, 41, 77, 192,
			26, 41, 109, 193, 26, 14, 41, 77, 194, 26,
			41, 109, 195, 26, 0, 0, 11, 0, 9, 41,
			77, 202, 26, 41, 77, 203, 26, 0, 0, 2,
			6, 0, 11, 0, 9, 14, 41, 77, 230, 26,
			41, 109, 231, 26, 14, 41, 77, 232, 26, 41,
			109, 233, 26, 0, 0, 11, 0, 9, 14, 41,
			77, 240, 26, 41, 109, 241, 26, 14, 41, 77,
			242, 26, 41, 109, 243, 26, 0, 0, 11, 0,
			9, 14, 41, 77, 250, 26, 41, 109, 251, 26,
			14, 41, 77, 252, 26, 41, 109, 253, 26, 0,
			0, 11, 0, 9, 41, 77, 132, 27, 41, 77,
			133, 27, 0, 0, 11, 0, 9, 14, 41, 77,
			136, 27, 41, 109, 137, 27, 14, 41, 77, 138,
			27, 41, 109, 139, 27, 0, 0, 11, 0, 9,
			41, 77, 147, 27, 41, 77, 148, 27, 0, 0,
			11, 0, 9, 14, 41, 77, 152, 27, 41, 109,
			153, 27, 14, 41, 77, 154, 27, 41, 109, 155,
			27, 0, 0, 11, 0, 9, 41, 77, 162, 27,
			41, 77, 163, 27, 0, 0, 11, 0, 9, 14,
			41, 77, 166, 27, 41, 109, 167, 27, 14, 41,
			77, 168, 27, 41, 109, 169, 27, 0, 0, 11,
			0, 9, 41, 77, 176, 27, 41, 77, 177, 27,
			0, 0, 2, 6, 0, 11, 0, 9, 14, 41,
			77, 186, 27, 41, 109, 187, 27, 14, 41, 77,
			188, 27, 41, 109, 189, 27, 0, 0, 11, 0,
			9, 14, 41, 77, 196, 27, 41, 109, 197, 27,
			14, 41, 77, 198, 27, 41, 109, 199, 27, 0,
			0, 11, 0, 9, 14, 41, 77, 206, 27, 41,
			109, 207, 27, 14, 41, 77, 208, 27, 41, 109,
			209, 27, 0, 0, 11, 0, 9, 41, 77, 216,
			27, 41, 77, 217, 27, 0, 0, 11, 0, 9,
			14, 41, 77, 220, 27, 41, 109, 221, 27, 14,
			41, 77, 222, 27, 41, 109, 223, 27, 0, 0,
			11, 0, 9, 41, 77, 230, 27, 41, 77, 231,
			27, 0, 0, 11, 0, 9, 14, 41, 77, 234,
			27, 41, 109, 235, 27, 14, 41, 77, 236, 27,
			41, 109, 237, 27, 0, 0, 11, 0, 9, 41,
			77, 244, 27, 41, 77, 245, 27, 0, 0, 11,
			0, 9, 14, 41, 77, 248, 27, 41, 109, 249,
			27, 14, 41, 77, 250, 27, 41, 109, 251, 27,
			0, 0, 11, 0, 9, 41, 77, 130, 28, 41,
			77, 131, 28, 0, 0, 2, 15, 0, 11, 0,
			9, 14, 41, 77, 173, 28, 41, 109, 174, 28,
			0, 0, 0, 2, 11, 0, 11, 0, 14, 54,
			77, 179, 28, 0, 0, 0, 11, 0, 14, 41,
			77, 181, 28, 41, 109, 182, 28, 0, 0, 11,
			0, 14, 41, 77, 187, 28, 41, 109, 188, 28,
			0, 0, 11, 0, 14, 41, 77, 193, 28, 41,
			109, 194, 28, 0, 0, 11, 0, 14, 41, 77,
			199, 28, 41, 109, 200, 28, 0, 0, 2, 16,
			0, 11, 0, 0, 14, 71, 0, 4, 0, 74,
			252, 35, 128, 128, 128, 8, 0, 14, 71, 0,
			4, 0, 74, 254, 35, 128, 128, 128, 8, 0,
			11, 0, 0, 0, 14, 71, 0, 4, 0, 74,
			128, 36, 128, 128, 128, 8, 0, 11, 14, 22,
			215, 28, 0, 0, 0, 0, 8, 6, 5, 0,
			11, 14, 18, 223, 28, 0, 0, 14, 22, 227,
			28, 0, 14, 22, 229, 28, 0, 11, 0, 0,
			0, 14, 22, 237, 28, 0, 11, 14, 18, 239,
			28, 0, 14, 18, 241, 28, 0, 14, 18, 243,
			28, 0, 14, 18, 245, 28, 0, 2, 8, 0,
			1, 128, 2, 11, 0, 9, 0, 14, 0, 57,
			109, 130, 29, 0, 0, 11, 0, 9, 0, 14,
			0, 57, 109, 133, 29, 0, 0, 11, 0, 9,
			14, 44, 77, 136, 29, 44, 109, 137, 29, 0,
			0, 0, 0, 11, 0, 9, 14, 57, 77, 144,
			29, 57, 109, 145, 29, 0, 0, 0, 11, 0,
			9, 14, 57, 77, 149, 29, 57, 109, 150, 29,
			0, 0, 0, 11, 0, 9, 14, 0, 44, 109,
			154, 29, 0, 0, 0, 0, 11, 0, 14, 57,
			77, 156, 29, 57, 109, 157, 29, 0, 0, 11,
			0, 14, 57, 77, 162, 29, 57, 109, 163, 29,
			0, 0, 11, 0, 44, 77, 168, 29, 0, 0,
			11, 0, 44, 77, 171, 29, 0, 0, 11, 0,
			14, 44, 77, 174, 29, 44, 109, 175, 29, 0,
			0, 11, 0, 14, 44, 77, 177, 29, 44, 109,
			178, 29, 0, 0, 11, 0, 14, 44, 77, 180,
			29, 44, 109, 181, 29, 0, 0, 11, 0, 14,
			44, 77, 184, 29, 44, 109, 185, 29, 0, 0,
			2, 4, 0, 11, 0, 14, 25, 77, 191, 29,
			0, 0, 0, 11, 0, 14, 25, 77, 197, 29,
			0, 0, 0, 11, 0, 14, 25, 77, 203, 29,
			0, 0, 0, 11, 0, 14, 15, 77, 209, 29,
			0, 0, 0, 11, 0, 9, 14, 0, 45, 109,
			109, 77, 213, 29, 0, 0, 0, 11, 0, 9,
			14, 0, 63, 77, 109, 218, 29, 0, 0, 0,
			2, 3, 0, 11, 0, 9, 14, 63, 77, 77,
			227, 29, 63, 77, 109, 228, 29, 0, 0, 0,
			1, 11, 0, 14, 37, 77, 246, 29, 0, 0,
			0, 11, 0, 14, 44, 77, 251, 29, 0, 0,
			0, 11, 0, 14, 37, 77, 255, 29, 0, 0,
			0, 2, 13, 0, 11, 0, 14, 9, 51, 149,
			30, 51, 150, 30, 0, 0, 0, 11, 0, 14,
			9, 51, 151, 30, 51, 152, 30, 0, 0, 0,
			11, 0, 14, 9, 51, 153, 30, 51, 154, 30,
			0, 0, 0, 11, 0, 14, 9, 51, 155, 30,
			51, 156, 30, 0, 0, 0, 2, 4, 0, 11,
			0, 9, 14, 0, 45, 109, 109, 77, 157, 30,
			0, 0, 0, 11, 0, 9, 14, 0, 63, 77,
			109, 162, 30, 0, 0, 0, 2, 4, 0, 11,
			0, 14, 9, 71, 0, 4, 0, 73, 130, 36,
			53, 128, 128, 128, 8, 0, 0, 0, 0, 0,
			11, 0, 14, 44, 77, 184, 30, 44, 109, 185,
			30, 0, 0, 11, 0, 14, 44, 77, 187, 30,
			0, 0, 0, 11, 0, 14, 44, 77, 189, 30,
			44, 109, 190, 30, 0, 0, 0, 11, 0, 14,
			44, 77, 199, 30, 44, 109, 200, 30, 0, 0,
			0, 11, 0, 9, 14, 0, 44, 109, 204, 30,
			0, 0, 0, 0, 11, 0, 9, 14, 47, 77,
			205, 30, 47, 109, 206, 30, 14, 39, 77, 207,
			30, 39, 109, 208, 30, 0, 0, 11, 0, 9,
			14, 47, 77, 209, 30, 47, 109, 210, 30, 14,
			39, 77, 211, 30, 39, 109, 212, 30, 0, 0,
			11, 0, 9, 14, 46, 77, 213, 30, 46, 109,
			214, 30, 0, 0, 0, 11, 0, 9, 14, 46,
			77, 215, 30, 46, 109, 216, 30, 0, 0, 0,
			11, 0, 9, 14, 46, 77, 217, 30, 46, 109,
			218, 30, 0, 0, 0, 2, 15, 0, 11, 0,
			9, 14, 46, 77, 243, 30, 46, 109, 244, 30,
			14, 38, 77, 245, 30, 38, 109, 246, 30, 0,
			0, 11, 0, 9, 14, 46, 77, 247, 30, 46,
			109, 248, 30, 14, 38, 77, 249, 30, 38, 109,
			250, 30, 0, 0, 11, 0, 9, 14, 46, 77,
			251, 30, 46, 109, 252, 30, 14, 38, 77, 253,
			30, 38, 109, 254, 30, 0, 0, 11, 0, 9,
			14, 46, 77, 255, 30, 46, 109, 128, 31, 14,
			38, 77, 129, 31, 38, 109, 130, 31, 0, 0,
			11, 0, 14, 58, 77, 133, 31, 0, 0, 0,
			11, 0, 14, 58, 77, 137, 31, 0, 0, 0,
			11, 0, 14, 57, 77, 140, 31, 0, 0, 0,
			11, 0, 14, 57, 77, 142, 31, 0, 0, 0,
			2, 4, 0, 11, 0, 9, 14, 46, 77, 151,
			31, 46, 109, 152, 31, 14, 38, 77, 153, 31,
			38, 109, 154, 31, 0, 0, 11, 0, 9, 14,
			46, 77, 155, 31, 46, 109, 156, 31, 14, 38,
			77, 157, 31, 38, 109, 158, 31, 0, 0, 11,
			0, 9, 46, 77, 159, 31, 38, 77, 160, 31,
			0, 0, 11, 0, 9, 46, 77, 161, 31, 38,
			77, 162, 31, 0, 0, 11, 0, 9, 14, 46,
			77, 163, 31, 46, 109, 164, 31, 14, 38, 77,
			165, 31, 38, 109, 166, 31, 0, 0, 11, 0,
			9, 14, 46, 77, 167, 31, 46, 109, 168, 31,
			14, 38, 77, 169, 31, 38, 109, 170, 31, 0,
			0, 11, 0, 9, 46, 77, 171, 31, 38, 77,
			172, 31, 0, 0, 11, 0, 9, 46, 77, 173,
			31, 38, 77, 174, 31, 0, 0, 2, 8, 0,
			11, 0, 9, 14, 46, 77, 193, 31, 46, 109,
			194, 31, 14, 38, 77, 195, 31, 38, 109, 196,
			31, 0, 0, 11, 0, 9, 14, 46, 77, 197,
			31, 46, 109, 198, 31, 14, 38, 77, 199, 31,
			38, 109, 200, 31, 0, 0, 11, 0, 9, 46,
			77, 201, 31, 38, 77, 202, 31, 0, 0, 11,
			0, 9, 46, 77, 203, 31, 38, 77, 204, 31,
			0, 0, 11, 0, 9, 14, 46, 77, 205, 31,
			46, 109, 206, 31, 14, 38, 77, 207, 31, 38,
			109, 208, 31, 0, 0, 11, 0, 9, 14, 46,
			77, 209, 31, 46, 109, 210, 31, 14, 38, 77,
			211, 31, 38, 109, 212, 31, 0, 0, 11, 0,
			9, 46, 77, 213, 31, 38, 77, 214, 31, 0,
			0, 11, 0, 9, 46, 77, 215, 31, 38, 77,
			216, 31, 0, 0, 2, 78, 0, 11, 0, 9,
			0, 14, 44, 77, 219, 31, 44, 109, 220, 31,
			0, 0, 11, 0, 9, 0, 14, 44, 77, 225,
			31, 44, 109, 226, 31, 0, 0, 2, 15, 0,
			11, 0, 14, 57, 77, 231, 31, 0, 0, 0,
			2, 16, 0, 11, 0, 0, 0, 14, 19, 232,
			31, 0, 2, 15, 0, 1, 128, 2, 2, 116,
			0, 11, 14, 9, 71, 0, 4, 0, 76, 211,
			35, 128, 128, 128, 8, 0, 0, 0, 0, 0,
			11, 14, 9, 71, 0, 4, 0, 76, 212, 35,
			128, 128, 128, 8, 0, 0, 0, 0, 0, 2,
			138, 1, 0, 1, 128, 2, 2, 16, 0, 11,
			14, 54, 77, 254, 6, 54, 109, 255, 6, 14,
			54, 77, 132, 7, 54, 109, 133, 7, 7, 41,
			77, 138, 7, 53, 77, 139, 7, 7, 41, 77,
			143, 7, 53, 77, 144, 7, 11, 14, 62, 77,
			148, 7, 62, 109, 149, 7, 14, 62, 77, 154,
			7, 62, 109, 155, 7, 7, 61, 77, 160, 7,
			32, 77, 161, 7, 7, 61, 77, 165, 7, 32,
			77, 166, 7, 11, 14, 42, 77, 171, 7, 172,
			7, 0, 14, 40, 77, 176, 7, 0, 14, 54,
			77, 179, 7, 54, 109, 180, 7, 14, 54, 77,
			185, 7, 54, 109, 186, 7, 11, 14, 32, 77,
			191, 7, 0, 14, 32, 77, 194, 7, 0, 0,
			0, 11, 14, 41, 77, 197, 7, 41, 109, 198,
			7, 14, 41, 77, 203, 7, 41, 109, 204, 7,
			0, 0, 11, 14, 41, 77, 209, 7, 41, 109,
			210, 7, 14, 41, 77, 215, 7, 41, 109, 216,
			7, 0, 0, 11, 14, 42, 77, 221, 7, 224,
			7, 0, 14, 40, 77, 227, 7, 0, 14, 54,
			77, 230, 7, 54, 109, 231, 7, 0, 11, 14,
			32, 77, 236, 7, 0, 14, 32, 77, 239, 7,
			0, 0, 0, 8, 6, 0, 2, 15, 0, 11,
			14, 54, 77, 174, 8, 54, 109, 175, 8, 14,
			54, 77, 180, 8, 54, 109, 181, 8, 0, 0,
			11, 14, 62, 77, 186, 8, 62, 109, 187, 8,
			14, 62, 77, 192, 8, 62, 109, 193, 8, 0,
			0, 11, 0, 0, 36, 77, 201, 8, 36, 77,
			207, 8, 11, 14, 32, 77, 212, 8, 32, 109,
			213, 8, 14, 32, 77, 218, 8, 32, 109, 219,
			8, 0, 0, 11, 0, 0, 24, 77, 229, 8,
			24, 77, 235, 8, 11, 0, 0, 24, 77, 243,
			8, 24, 77, 249, 8, 11, 54, 77, 254, 8,
			54, 77, 129, 9, 0, 0, 11, 54, 77, 133,
			9, 54, 77, 134, 9, 0, 0, 2, 17, 0,
			11, 14, 9, 71, 0, 4, 0, 50, 221, 35,
			128, 128, 128, 8, 0, 9, 48, 193, 9, 48,
			194, 9, 14, 0, 9, 48, 195, 9, 48, 196,
			9, 0, 0, 11, 14, 9, 71, 0, 4, 0,
			50, 222, 35, 128, 128, 128, 8, 0, 9, 48,
			197, 9, 48, 198, 9, 14, 0, 9, 48, 199,
			9, 48, 200, 9, 0, 0, 11, 14, 9, 71,
			0, 4, 0, 50, 223, 35, 128, 128, 128, 8,
			0, 0, 0, 0, 0, 11, 14, 9, 71, 50,
			201, 9, 4, 0, 50, 224, 35, 128, 128, 128,
			8, 50, 202, 9, 0, 14, 9, 50, 203, 9,
			50, 204, 9, 0, 0, 0, 11, 14, 9, 71,
			0, 4, 0, 50, 225, 35, 128, 128, 128, 8,
			0, 9, 48, 205, 9, 48, 206, 9, 14, 0,
			9, 48, 207, 9, 48, 208, 9, 0, 0, 11,
			14, 9, 71, 0, 4, 0, 50, 226, 35, 128,
			128, 128, 8, 0, 9, 48, 209, 9, 48, 210,
			9, 14, 0, 9, 48, 211, 9, 48, 212, 9,
			0, 0, 11, 14, 9, 71, 0, 4, 0, 50,
			227, 35, 128, 128, 128, 8, 0, 9, 48, 213,
			9, 48, 214, 9, 14, 0, 9, 48, 215, 9,
			48, 216, 9, 0, 0, 11, 14, 9, 71, 0,
			4, 0, 50, 228, 35, 128, 128, 128, 8, 0,
			0, 0, 0, 0, 11, 14, 9, 71, 0, 4,
			0, 50, 229, 35, 128, 128, 128, 8, 0, 0,
			0, 0, 0, 11, 14, 0, 9, 48, 217, 9,
			48, 218, 9, 14, 0, 9, 48, 219, 9, 48,
			220, 9, 0, 0, 11, 14, 0, 9, 48, 221,
			9, 48, 222, 9, 14, 0, 9, 48, 223, 9,
			0, 0, 0, 2, 4, 0, 11, 14, 23, 77,
			226, 9, 23, 109, 228, 9, 14, 23, 77, 232,
			9, 23, 109, 234, 9, 0, 0, 11, 14, 54,
			77, 237, 9, 54, 109, 238, 9, 14, 54, 77,
			243, 9, 54, 109, 244, 9, 41, 77, 249, 9,
			41, 77, 252, 9, 11, 14, 54, 77, 255, 9,
			54, 109, 128, 10, 0, 41, 77, 130, 10, 0,
			11, 14, 54, 77, 132, 10, 54, 109, 133, 10,
			0, 41, 77, 135, 10, 0, 11, 14, 41, 77,
			137, 10, 41, 109, 138, 10, 14, 41, 77, 143,
			10, 41, 109, 144, 10, 0, 0, 11, 14, 41,
			77, 149, 10, 41, 109, 150, 10, 14, 41, 77,
			155, 10, 41, 109, 156, 10, 0, 0, 11, 14,
			41, 77, 161, 10, 41, 109, 162, 10, 14, 41,
			77, 167, 10, 41, 109, 168, 10, 0, 0, 11,
			14, 41, 77, 173, 10, 41, 109, 174, 10, 14,
			41, 77, 179, 10, 41, 109, 180, 10, 0, 0,
			11, 14, 41, 77, 185, 10, 41, 109, 186, 10,
			14, 41, 77, 191, 10, 41, 109, 192, 10, 41,
			77, 197, 10, 41, 77, 200, 10, 11, 14, 41,
			77, 203, 10, 41, 109, 204, 10, 14, 41, 77,
			209, 10, 41, 109, 210, 10, 41, 77, 215, 10,
			41, 77, 218, 10, 11, 14, 54, 77, 221, 10,
			55, 109, 77, 222, 10, 14, 54, 77, 227, 10,
			55, 77, 109, 228, 10, 41, 77, 233, 10, 41,
			77, 236, 10, 11, 14, 54, 77, 239, 10, 54,
			109, 240, 10, 14, 54, 77, 248, 10, 54, 109,
			249, 10, 14, 54, 77, 254, 10, 54, 109, 255,
			10, 0, 11, 14, 41, 77, 132, 11, 41, 109,
			133, 11, 14, 41, 77, 138, 11, 41, 109, 139,
			11, 41, 77, 144, 11, 41, 77, 147, 11, 11,
			14, 41, 77, 150, 11, 41, 109, 151, 11, 14,
			41, 77, 156, 11, 41, 109, 157, 11, 41, 77,
			162, 11, 41, 77, 165, 11, 11, 14, 41, 77,
			168, 11, 41, 109, 169, 11, 14, 41, 77, 174,
			11, 41, 109, 175, 11, 41, 77, 180, 11, 41,
			77, 183, 11, 11, 14, 41, 77, 186, 11, 41,
			109, 187, 11, 14, 41, 77, 192, 11, 41, 109,
			193, 11, 41, 77, 198, 11, 41, 77, 201, 11,
			11, 0, 14, 41, 77, 205, 11, 41, 109, 206,
			11, 0, 0, 11, 0, 14, 41, 77, 212, 11,
			41, 109, 213, 11, 0, 0, 11, 0, 14, 41,
			77, 219, 11, 41, 109, 220, 11, 0, 0, 11,
			0, 14, 41, 77, 226, 11, 41, 109, 227, 11,
			0, 0, 11, 0, 14, 41, 77, 233, 11, 41,
			109, 234, 11, 0, 0, 11, 0, 14, 41, 77,
			240, 11, 41, 109, 241, 11, 0, 0, 11, 0,
			14, 41, 77, 247, 11, 41, 109, 248, 11, 0,
			0, 11, 0, 14, 41, 77, 254, 11, 41, 109,
			255, 11, 0, 0, 11, 0, 14, 41, 77, 133,
			12, 41, 109, 134, 12, 0, 0, 11, 0, 14,
			41, 77, 140, 12, 41, 109, 141, 12, 0, 0,
			11, 0, 14, 41, 77, 147, 12, 41, 109, 148,
			12, 0, 0, 11, 0, 14, 41, 77, 154, 12,
			41, 109, 155, 12, 0, 0, 11, 0, 14, 41,
			77, 160, 12, 41, 109, 161, 12, 0, 0, 11,
			0, 14, 41, 77, 166, 12, 41, 109, 167, 12,
			0, 0, 11, 0, 14, 59, 175, 12, 0, 0,
			0, 11, 0, 14, 54, 77, 181, 12, 54, 109,
			182, 12, 14, 54, 77, 190, 12, 54, 109, 191,
			12, 0, 11, 0, 14, 57, 77, 206, 12, 57,
			109, 207, 12, 14, 57, 77, 212, 12, 57, 109,
			213, 12, 14, 57, 77, 218, 12, 57, 109, 219,
			12, 8, 6, 1, 8, 6, 2, 8, 6, 3,
			11, 0, 14, 41, 77, 180, 13, 41, 109, 181,
			13, 0, 0, 11, 0, 14, 41, 77, 187, 13,
			41, 109, 188, 13, 0, 0, 11, 0, 14, 41,
			77, 194, 13, 41, 109, 195, 13, 0, 0, 12,
			13, 35, 200, 13, 35, 201, 13, 3, 3, 3,
			2, 4, 0, 11, 0, 14, 41, 77, 143, 14,
			41, 109, 144, 14, 0, 14, 41, 77, 146, 14,
			41, 109, 147, 14, 11, 0, 14, 41, 77, 149,
			14, 41, 109, 150, 14, 0, 14, 41, 77, 152,
			14, 41, 109, 153, 14, 11, 0, 14, 16, 158,
			14, 0, 14, 54, 77, 163, 14, 0, 0, 11,
			0, 14, 62, 77, 167, 14, 62, 109, 168, 14,
			14, 62, 77, 176, 14, 62, 109, 177, 14, 0,
			2, 4, 0, 11, 14, 9, 71, 0, 4, 0,
			77, 230, 35, 128, 128, 128, 8, 0, 0, 0,
			0, 0, 11, 14, 9, 71, 0, 4, 0, 77,
			231, 35, 128, 128, 128, 8, 0, 0, 0, 0,
			0, 2, 10, 0, 11, 14, 9, 71, 52, 254,
			14, 4, 0, 50, 232, 35, 128, 128, 128, 8,
			52, 255, 14, 0, 14, 9, 52, 128, 15, 52,
			129, 15, 0, 0, 0, 11, 14, 9, 31, 130,
			15, 31, 131, 15, 0, 14, 9, 31, 132, 15,
			31, 133, 15, 0, 0, 0, 11, 14, 9, 71,
			49, 134, 15, 37, 4, 0, 49, 233, 35, 37,
			128, 128, 128, 8, 0, 0, 14, 9, 49, 135,
			15, 37, 0, 0, 0, 14, 9, 49, 136, 15,
			37, 4, 49, 136, 15, 37, 49, 137, 15, 53,
			0, 11, 14, 9, 71, 17, 138, 15, 37, 4,
			0, 17, 234, 35, 37, 128, 128, 128, 8, 0,
			0, 14, 9, 17, 139, 15, 37, 0, 0, 0,
			14, 9, 17, 140, 15, 37, 4, 17, 140, 15,
			37, 17, 141, 15, 53, 0, 0, 11, 14, 9,
			71, 0, 4, 0, 72, 235, 35, 128, 128, 128,
			8, 0, 0, 0, 0, 0, 0, 11, 14, 9,
			71, 0, 4, 0, 72, 236, 35, 128, 128, 128,
			8, 0, 0, 0, 0, 0, 11, 14, 9, 71,
			50, 142, 15, 4, 0, 50, 237, 35, 128, 128,
			128, 8, 50, 143, 15, 0, 14, 9, 50, 144,
			15, 50, 145, 15, 0, 0, 0, 11, 14, 9,
			50, 146, 15, 50, 147, 15, 0, 14, 9, 50,
			148, 15, 50, 149, 15, 0, 0, 0, 2, 20,
			0, 8, 6, 4, 2, 9, 0, 11, 0, 0,
			14, 71, 0, 4, 0, 7, 74, 244, 35, 0,
			128, 128, 128, 8, 0, 0, 2, 3, 0, 11,
			0, 0, 14, 71, 0, 4, 0, 7, 74, 246,
			35, 0, 128, 128, 128, 8, 0, 14, 71, 0,
			4, 0, 7, 74, 248, 35, 0, 128, 128, 128,
			8, 0, 11, 0, 0, 14, 71, 0, 4, 0,
			7, 74, 250, 35, 0, 128, 128, 128, 8, 0,
			0, 2, 4, 0, 11, 14, 44, 77, 221, 16,
			44, 109, 222, 16, 14, 44, 77, 227, 16, 44,
			109, 228, 16, 44, 77, 233, 16, 44, 77, 236,
			16, 0, 11, 0, 14, 37, 77, 244, 16, 0,
			0, 0, 11, 0, 14, 21, 77, 252, 16, 0,
			0, 0, 11, 14, 44, 77, 129, 17, 44, 109,
			130, 17, 14, 44, 77, 135, 17, 44, 109, 136,
			17, 0, 0, 2, 9, 0, 11, 0, 14, 41,
			77, 164, 17, 41, 109, 165, 17, 0, 14, 41,
			77, 167, 17, 41, 109, 168, 17, 11, 0, 14,
			43, 77, 77, 77, 171, 17, 43, 109, 109, 77,
			172, 17, 0, 0, 11, 0, 14, 43, 77, 77,
			77, 178, 17, 43, 109, 109, 77, 179, 17, 0,
			0, 11, 0, 14, 43, 77, 77, 77, 185, 17,
			43, 109, 109, 77, 186, 17, 0, 0, 11, 0,
			14, 41, 77, 192, 17, 41, 109, 193, 17, 0,
			0, 11, 0, 14, 41, 77, 199, 17, 41, 109,
			200, 17, 0, 0, 11, 0, 14, 62, 77, 205,
			17, 0, 0, 0, 11, 0, 14, 23, 77, 213,
			17, 23, 109, 215, 17, 0, 0, 11, 0, 14,
			41, 77, 219, 17, 41, 109, 220, 17, 0, 0,
			11, 0, 14, 41, 77, 226, 17, 41, 109, 227,
			17, 0, 0, 11, 0, 14, 41, 77, 233, 17,
			41, 109, 234, 17, 0, 0, 11, 0, 14, 41,
			77, 240, 17, 41, 109, 241, 17, 0, 0, 11,
			0, 14, 41, 77, 250, 17, 41, 109, 251, 17,
			0, 0, 11, 0, 14, 41, 77, 129, 18, 41,
			109, 130, 18, 0, 0, 11, 0, 14, 41, 77,
			136, 18, 41, 109, 137, 18, 0, 0, 11, 0,
			14, 41, 77, 143, 18, 41, 109, 144, 18, 0,
			0, 11, 0, 14, 41, 77, 153, 18, 41, 109,
			154, 18, 0, 0, 11, 0, 14, 43, 77, 77,
			77, 160, 18, 43, 109, 109, 77, 161, 18, 0,
			0, 11, 0, 14, 43, 77, 77, 77, 167, 18,
			43, 109, 109, 77, 168, 18, 0, 0, 11, 0,
			14, 41, 77, 177, 18, 41, 109, 178, 18, 0,
			0, 11, 0, 14, 41, 77, 184, 18, 41, 109,
			185, 18, 0, 0, 11, 0, 14, 41, 77, 191,
			18, 41, 109, 192, 18, 0, 0, 11, 0, 14,
			54, 77, 197, 18, 55, 77, 109, 198, 18, 14,
			54, 77, 203, 18, 55, 109, 77, 204, 18, 14,
			54, 77, 212, 18, 55, 77, 109, 213, 18, 11,
			0, 14, 32, 77, 219, 18, 32, 109, 220, 18,
			0, 0, 11, 0, 14, 41, 77, 226, 18, 41,
			109, 227, 18, 0, 0, 11, 0, 14, 41, 77,
			233, 18, 41, 109, 234, 18, 0, 0, 11, 0,
			14, 41, 77, 240, 18, 41, 109, 241, 18, 0,
			0, 11, 0, 14, 41, 77, 247, 18, 41, 109,
			248, 18, 0, 0, 11, 0, 14, 41, 77, 129,
			19, 41, 109, 130, 19, 0, 0, 11, 0, 14,
			41, 77, 136, 19, 41, 109, 137, 19, 0, 0,
			11, 0, 14, 41, 77, 143, 19, 41, 109, 144,
			19, 0, 0, 11, 0, 14, 41, 77, 150, 19,
			41, 109, 151, 19, 0, 0, 11, 0, 0, 0,
			14, 53, 77, 159, 19, 53, 109, 160, 19, 11,
			0, 14, 43, 77, 77, 77, 163, 19, 43, 109,
			109, 77, 164, 19, 0, 0, 11, 0, 14, 43,
			77, 77, 77, 170, 19, 43, 109, 109, 77, 171,
			19, 0, 0, 11, 0, 14, 43, 77, 77, 77,
			177, 19, 43, 109, 109, 77, 178, 19, 0, 0,
			11, 0, 14, 41, 77, 184, 19, 41, 109, 185,
			19, 0, 0, 11, 0, 14, 41, 77, 191, 19,
			41, 109, 192, 19, 0, 0, 11, 0, 14, 41,
			77, 198, 19, 41, 109, 199, 19, 0, 0, 11,
			0, 14, 33, 77, 205, 19, 0, 0, 0, 11,
			0, 14, 41, 77, 208, 19, 41, 109, 209, 19,
			0, 0, 11, 0, 14, 41, 77, 215, 19, 41,
			109, 216, 19, 0, 0, 11, 0, 14, 41, 77,
			222, 19, 41, 109, 223, 19, 0, 0, 11, 0,
			14, 41, 77, 229, 19, 41, 109, 230, 19, 0,
			0, 11, 0, 14, 41, 77, 236, 19, 41, 109,
			237, 19, 0, 0, 11, 0, 14, 41, 77, 243,
			19, 41, 109, 244, 19, 0, 0, 11, 0, 14,
			41, 77, 250, 19, 41, 109, 251, 19, 0, 0,
			0
		};
	}
}


using System;
using Iced.Intel.DecoderInternal;

internal static class OpCodeHandlersTables_XOP
{
	internal static readonly OpCodeHandler[] Handlers_MAP8;

	internal static readonly OpCodeHandler[] Handlers_MAP9;

	internal static readonly OpCodeHandler[] Handlers_MAP10;

	private const int MaxIdNames = 7;

	private const uint Handlers_MAP8Index = 4u;

	private const uint Handlers_MAP9Index = 5u;

	private const uint Handlers_MAP10Index = 6u;

	static OpCodeHandlersTables_XOP()
	{
		VexOpCodeHandlerReader handlerReader = new VexOpCodeHandlerReader();
		TableDeserializer tableDeserializer = new TableDeserializer(handlerReader, 7, GetSerializedTables());
		tableDeserializer.Deserialize();
		Handlers_MAP8 = tableDeserializer.GetTable(4u);
		Handlers_MAP9 = tableDeserializer.GetTable(5u);
		Handlers_MAP10 = tableDeserializer.GetTable(6u);
	}

	private static ReadOnlySpan<byte> GetSerializedTables()
	{
		return new byte[768]
		{
			1, 8, 0, 10, 14, 28, 136, 32, 0, 10,
			14, 28, 138, 32, 0, 10, 14, 28, 140, 32,
			0, 10, 14, 28, 142, 32, 0, 10, 14, 28,
			144, 32, 0, 10, 14, 28, 146, 32, 0, 10,
			14, 28, 148, 32, 0, 1, 8, 0, 10, 14,
			28, 150, 32, 0, 2, 4, 0, 10, 14, 28,
			152, 32, 0, 0, 1, 8, 10, 14, 34, 154,
			32, 0, 10, 14, 34, 156, 32, 0, 2, 6,
			0, 1, 8, 10, 14, 27, 205, 32, 0, 10,
			14, 27, 207, 32, 0, 2, 6, 0, 1, 128,
			2, 2, 133, 1, 0, 10, 14, 9, 46, 77,
			234, 31, 0, 0, 10, 14, 9, 46, 77, 235,
			31, 0, 0, 10, 14, 9, 46, 77, 236, 31,
			0, 0, 2, 6, 0, 10, 14, 9, 46, 77,
			237, 31, 0, 0, 10, 14, 9, 46, 77, 238,
			31, 0, 0, 2, 5, 0, 10, 14, 9, 46,
			77, 239, 31, 0, 0, 10, 14, 9, 46, 77,
			240, 31, 0, 0, 10, 14, 9, 46, 77, 241,
			31, 0, 0, 2, 6, 0, 10, 14, 9, 46,
			77, 242, 31, 0, 0, 10, 14, 9, 46, 77,
			243, 31, 0, 0, 1, 10, 9, 14, 46, 77,
			244, 31, 46, 109, 245, 31, 14, 38, 77, 246,
			31, 38, 109, 247, 31, 10, 9, 14, 46, 77,
			248, 31, 0, 14, 38, 77, 249, 31, 0, 1,
			10, 14, 9, 46, 77, 250, 31, 0, 0, 2,
			15, 0, 10, 14, 9, 46, 77, 251, 31, 0,
			0, 2, 9, 0, 10, 14, 9, 57, 77, 252,
			31, 0, 0, 10, 14, 9, 57, 77, 253, 31,
			0, 0, 10, 14, 9, 57, 77, 254, 31, 0,
			0, 10, 14, 9, 57, 77, 255, 31, 0, 0,
			2, 8, 0, 10, 14, 9, 44, 77, 128, 32,
			0, 0, 10, 14, 9, 44, 77, 129, 32, 0,
			0, 10, 14, 9, 44, 77, 130, 32, 0, 0,
			10, 14, 9, 44, 77, 131, 32, 0, 0, 2,
			28, 0, 10, 14, 9, 44, 77, 132, 32, 0,
			0, 10, 14, 9, 44, 77, 133, 32, 0, 0,
			10, 14, 9, 44, 77, 134, 32, 0, 0, 10,
			14, 9, 44, 77, 135, 32, 0, 0, 2, 16,
			0, 1, 128, 2, 0, 8, 6, 0, 8, 6,
			1, 2, 15, 0, 8, 6, 2, 2, 109, 0,
			10, 14, 9, 54, 77, 158, 32, 0, 9, 54,
			109, 159, 32, 0, 10, 14, 9, 54, 77, 160,
			32, 0, 9, 54, 109, 161, 32, 0, 10, 14,
			9, 54, 77, 162, 32, 0, 0, 10, 14, 9,
			54, 77, 163, 32, 0, 0, 2, 12, 0, 10,
			14, 9, 56, 77, 164, 32, 41, 77, 165, 32,
			0, 10, 14, 9, 56, 77, 166, 32, 41, 77,
			167, 32, 0, 10, 14, 9, 56, 77, 168, 32,
			41, 77, 169, 32, 0, 10, 14, 9, 56, 77,
			170, 32, 41, 77, 171, 32, 0, 10, 14, 9,
			56, 77, 172, 32, 41, 77, 173, 32, 0, 10,
			14, 9, 56, 77, 174, 32, 41, 77, 175, 32,
			0, 10, 14, 9, 56, 77, 176, 32, 41, 77,
			177, 32, 0, 10, 14, 9, 56, 77, 178, 32,
			41, 77, 179, 32, 0, 10, 14, 9, 56, 77,
			180, 32, 41, 77, 181, 32, 0, 10, 14, 9,
			56, 77, 182, 32, 41, 77, 183, 32, 0, 10,
			14, 9, 56, 77, 184, 32, 41, 77, 185, 32,
			0, 10, 14, 9, 56, 77, 186, 32, 41, 77,
			187, 32, 0, 2, 37, 0, 10, 14, 9, 54,
			77, 188, 32, 0, 0, 10, 14, 9, 54, 77,
			189, 32, 0, 0, 10, 14, 9, 54, 77, 190,
			32, 0, 0, 1, 10, 14, 9, 54, 77, 191,
			32, 0, 0, 10, 14, 9, 54, 77, 192, 32,
			0, 0, 2, 3, 0, 10, 14, 9, 54, 77,
			193, 32, 0, 0, 2, 5, 0, 10, 14, 9,
			54, 77, 194, 32, 0, 0, 10, 14, 9, 54,
			77, 195, 32, 0, 0, 10, 14, 9, 54, 77,
			196, 32, 0, 0, 1, 10, 14, 9, 54, 77,
			197, 32, 0, 0, 10, 14, 9, 54, 77, 198,
			32, 0, 0, 2, 3, 0, 10, 14, 9, 54,
			77, 199, 32, 0, 0, 2, 5, 0, 10, 14,
			9, 54, 77, 200, 32, 0, 0, 10, 14, 9,
			54, 77, 201, 32, 0, 0, 10, 14, 9, 54,
			77, 202, 32, 0, 0, 2, 28, 0, 1, 128,
			2, 2, 16, 0, 10, 14, 20, 203, 32, 0,
			0, 8, 6, 3, 2, 237, 1, 0
		};
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_D3NOW : OpCodeHandlerModRM
{
	internal static readonly Code[] CodeValues = CreateCodeValues();

	private readonly Code[] codeValues = CodeValues;

	private static Code[] CreateCodeValues()
	{
		Code[] array = new Code[256];
		array[191] = Code.D3NOW_Pavgusb_mm_mmm64;
		array[187] = Code.D3NOW_Pswapd_mm_mmm64;
		array[183] = Code.D3NOW_Pmulhrw_mm_mmm64;
		array[182] = Code.D3NOW_Pfrcpit2_mm_mmm64;
		array[180] = Code.D3NOW_Pfmul_mm_mmm64;
		array[176] = Code.D3NOW_Pfcmpeq_mm_mmm64;
		array[174] = Code.D3NOW_Pfacc_mm_mmm64;
		array[170] = Code.D3NOW_Pfsubr_mm_mmm64;
		array[167] = Code.D3NOW_Pfrsqit1_mm_mmm64;
		array[166] = Code.D3NOW_Pfrcpit1_mm_mmm64;
		array[164] = Code.D3NOW_Pfmax_mm_mmm64;
		array[160] = Code.D3NOW_Pfcmpgt_mm_mmm64;
		array[158] = Code.D3NOW_Pfadd_mm_mmm64;
		array[154] = Code.D3NOW_Pfsub_mm_mmm64;
		array[151] = Code.D3NOW_Pfrsqrt_mm_mmm64;
		array[150] = Code.D3NOW_Pfrcp_mm_mmm64;
		array[148] = Code.D3NOW_Pfmin_mm_mmm64;
		array[144] = Code.D3NOW_Pfcmpge_mm_mmm64;
		array[142] = Code.D3NOW_Pfpnacc_mm_mmm64;
		array[138] = Code.D3NOW_Pfnacc_mm_mmm64;
		array[135] = Code.D3NOW_Pfrsqrtv_mm_mmm64;
		array[134] = Code.D3NOW_Pfrcpv_mm_mmm64;
		array[29] = Code.D3NOW_Pf2id_mm_mmm64;
		array[28] = Code.D3NOW_Pf2iw_mm_mmm64;
		array[13] = Code.D3NOW_Pi2fd_mm_mmm64;
		array[12] = Code.D3NOW_Pi2fw_mm_mmm64;
		return array;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		Code code = codeValues[decoder.ReadByte()];
		if ((uint)(code - 4181) <= 1u && ((decoder.options & DecoderOptions.Cyrix) == 0 || decoder.Bitness == 64))
		{
			code = Code.INVALID;
		}
		instruction.InternalSetCodeNoCheck(code);
		if (code == Code.INVALID)
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VectorLength_EVEX : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_VectorLength_EVEX(OpCodeHandler handler128, OpCodeHandler handler256, OpCodeHandler handler512)
	{
		handlers = new OpCodeHandler[4]
		{
			handler128 ?? throw new ArgumentNullException("handler128"),
			handler256 ?? throw new ArgumentNullException("handler256"),
			handler512 ?? throw new ArgumentNullException("handler512"),
			OpCodeHandler_Invalid.Instance
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		handlers[decoder.state.vectorLength].Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VectorLength_EVEX_er : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_VectorLength_EVEX_er(OpCodeHandler handler128, OpCodeHandler handler256, OpCodeHandler handler512)
	{
		handlers = new OpCodeHandler[4]
		{
			handler128 ?? throw new ArgumentNullException("handler128"),
			handler256 ?? throw new ArgumentNullException("handler256"),
			handler512 ?? throw new ArgumentNullException("handler512"),
			OpCodeHandler_Invalid.Instance
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		int num = (int)decoder.state.vectorLength;
		if (decoder.state.mod == 3 && (decoder.state.zs.flags & StateFlags.b) != 0)
		{
			num = 2;
		}
		handlers[num].Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_V_H_Ev_er : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeW0;

	private readonly Code codeW1;

	private readonly TupleType tupleTypeW0;

	private readonly TupleType tupleTypeW1;

	public OpCodeHandler_EVEX_V_H_Ev_er(Register baseReg, Code codeW0, Code codeW1, TupleType tupleTypeW0, TupleType tupleTypeW1)
	{
		this.baseReg = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
		this.tupleTypeW0 = tupleTypeW0;
		this.tupleTypeW1 = tupleTypeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		TupleType tupleType;
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			tupleType = tupleTypeW1;
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			tupleType = tupleTypeW0;
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalRoundingControl = decoder.state.vectorLength + 1;
			}
			return;
		}
		if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_V_H_Ev_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeW0;

	private readonly Code codeW1;

	private readonly TupleType tupleTypeW0;

	private readonly TupleType tupleTypeW1;

	public OpCodeHandler_EVEX_V_H_Ev_Ib(Register baseReg, Code codeW0, Code codeW1, TupleType tupleTypeW0, TupleType tupleTypeW1)
	{
		this.baseReg = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
		this.tupleTypeW0 = tupleTypeW0;
		this.tupleTypeW1 = tupleTypeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
			{
				decoder.ReadOpMem(ref instruction, tupleTypeW1);
			}
			else
			{
				decoder.ReadOpMem(ref instruction, tupleTypeW0);
			}
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_Ed_V_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	private readonly TupleType tupleType32;

	private readonly TupleType tupleType64;

	public OpCodeHandler_EVEX_Ed_V_Ib(Register baseReg, Code code32, Code code64, TupleType tupleType32, TupleType tupleType64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
		this.tupleType32 = tupleType32;
		this.tupleType64 = tupleType64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
			{
				decoder.ReadOpMem(ref instruction, tupleType64);
			}
			else
			{
				decoder.ReadOpMem(ref instruction, tupleType32);
			}
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkHW_er : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool onlySAE;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkHW_er(Register baseReg, Code code, TupleType tupleType, bool onlySAE, bool canBroadcast)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.onlySAE = onlySAE;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (onlySAE)
				{
					instruction.InternalSetSuppressAllExceptions();
				}
				else
				{
					instruction.InternalRoundingControl = decoder.state.vectorLength + 1;
				}
			}
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			if (canBroadcast)
			{
				instruction.InternalSetIsBroadcast();
			}
			else if (decoder.invalidCheckMask != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkHW_er_ur : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkHW_er_ur(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		int num = (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX);
		instruction.Op0Register = num + baseReg;
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			int num2 = (int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX);
			instruction.Op2Register = num2 + baseReg;
			if (decoder.invalidCheckMask != 0 && (num == (int)decoder.state.vvvv || num == num2))
			{
				decoder.SetInvalidInstruction();
			}
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalRoundingControl = decoder.state.vectorLength + 1;
			}
			return;
		}
		if (decoder.invalidCheckMask != 0 && num == (int)decoder.state.vvvv)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			if (canBroadcast)
			{
				instruction.InternalSetIsBroadcast();
			}
			else if (decoder.invalidCheckMask != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkW_er : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool onlySAE;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkW_er(Register baseReg, Code code, TupleType tupleType, bool onlySAE)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.onlySAE = onlySAE;
		canBroadcast = true;
	}

	public OpCodeHandler_EVEX_VkW_er(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool onlySAE)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
		this.tupleType = tupleType;
		this.onlySAE = onlySAE;
		canBroadcast = true;
	}

	public OpCodeHandler_EVEX_VkW_er(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool onlySAE, bool canBroadcast)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
		this.tupleType = tupleType;
		this.onlySAE = onlySAE;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (onlySAE)
				{
					instruction.InternalSetSuppressAllExceptions();
				}
				else
				{
					instruction.InternalRoundingControl = decoder.state.vectorLength + 1;
				}
			}
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			if (canBroadcast)
			{
				instruction.InternalSetIsBroadcast();
			}
			else if (decoder.invalidCheckMask != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkWIb_er : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VkWIb_er(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalSetSuppressAllExceptions();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalSetIsBroadcast();
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkW : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkW(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public OpCodeHandler_EVEX_VkW(Register baseReg1, Register baseReg2, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			if (canBroadcast)
			{
				instruction.InternalSetIsBroadcast();
			}
			else if (decoder.invalidCheckMask != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_WkV : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly uint disallowZeroingMasking;

	public OpCodeHandler_EVEX_WkV(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		disallowZeroingMasking = 0u;
	}

	public OpCodeHandler_EVEX_WkV(Register baseReg, Code code, TupleType tupleType, bool allowZeroingMasking)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		disallowZeroingMasking = ((!allowZeroingMasking) ? uint.MaxValue : 0u);
	}

	public OpCodeHandler_EVEX_WkV(Register baseReg1, Register baseReg2, Code code, TupleType tupleType)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
		this.tupleType = tupleType;
		disallowZeroingMasking = 0u;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.b) | decoder.state.vvvv_invalidCheck) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg2);
		if (((uint)(decoder.state.zs.flags & StateFlags.z) & disallowZeroingMasking & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg1);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		if (((uint)(decoder.state.zs.flags & StateFlags.z) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkM : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VkM(Register baseReg, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.b) | decoder.state.vvvv_invalidCheck) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_WkVIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_WkVIb(Register baseReg1, Register baseReg2, Code code, TupleType tupleType)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.b) | decoder.state.vvvv_invalidCheck) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg1);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			if (((uint)(decoder.state.zs.flags & StateFlags.z) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg2);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_HkWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_HkWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)decoder.state.vvvv + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_HWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_HWIb(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op0Register = (Register)((int)decoder.state.vvvv + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_WkVIb_er : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_WkVIb_er(Register baseReg1, Register baseReg2, Code code, TupleType tupleType)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg1);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalSetSuppressAllExceptions();
			}
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			if (((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg2);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VW_er : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VW_er(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalSetSuppressAllExceptions();
			}
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VW : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VW(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction, tupleType);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_WV : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_WV(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg2);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction, tupleType);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VM : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VM(Register baseReg, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VK : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_EVEX_VK(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 173);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_KR : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_EVEX_KR(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa | decoder.state.zs.extraRegisterBase | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_KkHWIb_sae : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_KkHWIb_sae(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.zs.extraRegisterBase | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalSetSuppressAllExceptions();
			}
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkHW : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Register baseReg3;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkHW(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public OpCodeHandler_EVEX_VkHW(Register baseReg1, Register baseReg2, Register baseReg3, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.baseReg3 = baseReg3;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg3);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			if (canBroadcast)
			{
				instruction.InternalSetIsBroadcast();
			}
			else if (decoder.invalidCheckMask != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkHM : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VkHM(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkHWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Register baseReg3;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkHWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public OpCodeHandler_EVEX_VkHWIb(Register baseReg1, Register baseReg2, Register baseReg3, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.baseReg3 = baseReg3;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg3);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkHWIb_er : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Register baseReg3;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_VkHWIb_er(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg3);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				instruction.InternalSetSuppressAllExceptions();
			}
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_KkHW : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_KkHW(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.zs.extraRegisterBase | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			if (canBroadcast)
			{
				instruction.InternalSetIsBroadcast();
			}
			else if (decoder.invalidCheckMask != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_KP1HW : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_KP1HW(Register baseReg, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.aaa | decoder.state.zs.extraRegisterBase | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		if ((decoder.state.zs.flags & StateFlags.b) != 0)
		{
			instruction.InternalSetIsBroadcast();
		}
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_KkHWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_KkHWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.zs.extraRegisterBase | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_WkHV : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_EVEX_WkHV(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
		if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		instruction.Op2Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VHWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VHWIb(Register baseReg, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VHW : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Register baseReg3;

	private readonly Code codeR;

	private readonly Code codeM;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VHW(Register baseReg, Code codeR, Code codeM, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		this.codeR = codeR;
		this.codeM = codeM;
		this.tupleType = tupleType;
	}

	public OpCodeHandler_EVEX_VHW(Register baseReg, Code code, TupleType tupleType)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		codeR = code;
		codeM = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			instruction.InternalSetCodeNoCheck(codeR);
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg3);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeM);
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction, tupleType);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VHM : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VHM(Register baseReg, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_Gv_W_er : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeW0;

	private readonly Code codeW1;

	private readonly TupleType tupleType;

	private readonly bool onlySAE;

	public OpCodeHandler_EVEX_Gv_W_er(Register baseReg, Code codeW0, Code codeW1, TupleType tupleType, bool onlySAE)
	{
		this.baseReg = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
		this.tupleType = tupleType;
		this.onlySAE = onlySAE;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.vvvv_invalidCheck | decoder.state.aaa | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (onlySAE)
				{
					instruction.InternalSetSuppressAllExceptions();
				}
				else
				{
					instruction.InternalRoundingControl = decoder.state.vectorLength + 1;
				}
			}
		}
		else
		{
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction, tupleType);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VX_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly TupleType tupleTypeW0;

	private readonly TupleType tupleTypeW1;

	public OpCodeHandler_EVEX_VX_Ev(Code code32, Code code64, TupleType tupleTypeW0, TupleType tupleTypeW1)
	{
		this.code32 = code32;
		this.code64 = code64;
		this.tupleTypeW0 = tupleTypeW0;
		this.tupleTypeW1 = tupleTypeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		TupleType tupleType;
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			tupleType = tupleTypeW1;
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			tupleType = tupleTypeW0;
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_Ev_VX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly TupleType tupleTypeW0;

	private readonly TupleType tupleTypeW1;

	public OpCodeHandler_EVEX_Ev_VX(Code code32, Code code64, TupleType tupleTypeW0, TupleType tupleTypeW1)
	{
		this.code32 = code32;
		this.code64 = code64;
		this.tupleTypeW0 = tupleTypeW0;
		this.tupleTypeW1 = tupleTypeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX + 77);
		TupleType tupleType;
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			tupleType = tupleTypeW1;
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			tupleType = tupleTypeW0;
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_Ev_VX_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_EVEX_Ev_VX_Ib(Register baseReg, Code code32, Code code64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_MV : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_MV(Register baseReg, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VkEv_REXW : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_EVEX_VkEv_REXW(Register baseReg, Code code32)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		code64 = Code.INVALID;
	}

	public OpCodeHandler_EVEX_VkEv_REXW(Register baseReg, Code code32, Code code64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.b) | decoder.state.vvvv_invalidCheck) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_Vk_VSIB : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Register vsibBase;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_Vk_VSIB(Register baseReg, Register vsibBase, Code code, TupleType tupleType)
	{
		this.baseReg = baseReg;
		this.vsibBase = vsibBase;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && (((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | (decoder.state.vvvv_invalidCheck & 0xF)) != 0 || decoder.state.aaa == 0))
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		int num = (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX);
		instruction.Op0Register = num + baseReg;
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem_VSIB(ref instruction, vsibBase, tupleType);
		if (decoder.invalidCheckMask != 0 && num == (int)((uint)(instruction.MemoryIndex - 77) % 32u))
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VSIB_k1_VX : OpCodeHandlerModRM
{
	private readonly Register vsibIndex;

	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VSIB_k1_VX(Register vsibIndex, Register baseReg, Code code, TupleType tupleType)
	{
		this.vsibIndex = vsibIndex;
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && (((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | (decoder.state.vvvv_invalidCheck & 0xF)) != 0 || decoder.state.aaa == 0))
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem_VSIB(ref instruction, vsibIndex, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_VSIB_k1 : OpCodeHandlerModRM
{
	private readonly Register vsibIndex;

	private readonly Code code;

	private readonly TupleType tupleType;

	public OpCodeHandler_EVEX_VSIB_k1(Register vsibIndex, Code code, TupleType tupleType)
	{
		this.vsibIndex = vsibIndex;
		this.code = code;
		this.tupleType = tupleType;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && (((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | (decoder.state.vvvv_invalidCheck & 0xF)) != 0 || decoder.state.aaa == 0))
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem_VSIB(ref instruction, vsibIndex, tupleType);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_GvM_VX_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	private readonly TupleType tupleType32;

	private readonly TupleType tupleType64;

	public OpCodeHandler_EVEX_GvM_VX_Ib(Register baseReg, Code code32, Code code64, TupleType tupleType32, TupleType tupleType64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
		this.tupleType32 = tupleType32;
		this.tupleType64 = tupleType64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & (StateFlags.b | StateFlags.z)) | decoder.state.vvvv_invalidCheck | decoder.state.aaa) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
			{
				decoder.ReadOpMem(ref instruction, tupleType64);
			}
			else
			{
				decoder.ReadOpMem(ref instruction, tupleType32);
			}
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase + decoder.state.extraRegisterBaseEVEX) + (int)baseReg);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX_KkWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	private readonly TupleType tupleType;

	private readonly bool canBroadcast;

	public OpCodeHandler_EVEX_KkWIb(Register baseReg, Code code, TupleType tupleType, bool canBroadcast)
	{
		this.baseReg = baseReg;
		this.code = code;
		this.tupleType = tupleType;
		this.canBroadcast = canBroadcast;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((((uint)(decoder.state.zs.flags & StateFlags.z) | decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase | decoder.state.extraRegisterBaseEVEX) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.extraBaseRegisterBaseEVEX) + (int)baseReg);
			if (((uint)(decoder.state.zs.flags & StateFlags.b) & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			if ((decoder.state.zs.flags & StateFlags.b) != 0)
			{
				if (canBroadcast)
				{
					instruction.InternalSetIsBroadcast();
				}
				else if (decoder.invalidCheckMask != 0)
				{
					decoder.SetInvalidInstruction();
				}
			}
			decoder.ReadOpMem(ref instruction, tupleType);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_ST_STi : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_ST_STi(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = Register.ST0;
		instruction.Op1Register = (Register)(217 + decoder.state.rm);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_STi_ST : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_STi_ST(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(217 + decoder.state.rm);
		instruction.Op1Register = Register.ST0;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_STi : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_STi(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(217 + decoder.state.rm);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Mf : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Mf(Code code)
	{
		code16 = code;
		code32 = code;
	}

	public OpCodeHandler_Mf(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;

internal struct Code3
{
	public unsafe fixed ushort codes[3];

	public unsafe Code3(Code code16, Code code32, Code code64)
	{
		codes[0] = (ushort)code16;
		codes[1] = (ushort)code32;
		codes[2] = (ushort)code64;
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX2 : OpCodeHandlerModRM
{
	private readonly OpCodeHandler handlerMem;

	public OpCodeHandler_VEX2(OpCodeHandler handlerMem)
	{
		this.handlerMem = handlerMem ?? throw new ArgumentNullException("handlerMem");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			decoder.VEX2(ref instruction);
		}
		else if (decoder.state.mod == 3)
		{
			decoder.VEX2(ref instruction);
		}
		else
		{
			handlerMem.Decode(decoder, ref instruction);
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX3 : OpCodeHandlerModRM
{
	private readonly OpCodeHandler handlerMem;

	public OpCodeHandler_VEX3(OpCodeHandler handlerMem)
	{
		this.handlerMem = handlerMem ?? throw new ArgumentNullException("handlerMem");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			decoder.VEX3(ref instruction);
		}
		else if (decoder.state.mod == 3)
		{
			decoder.VEX3(ref instruction);
		}
		else
		{
			handlerMem.Decode(decoder, ref instruction);
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_XOP : OpCodeHandlerModRM
{
	private readonly OpCodeHandler handler_reg0;

	public OpCodeHandler_XOP(OpCodeHandler handler_reg0)
	{
		this.handler_reg0 = handler_reg0 ?? throw new ArgumentNullException("handler_reg0");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.modrm & 0x1F) < 8)
		{
			handler_reg0.Decode(decoder, ref instruction);
		}
		else
		{
			decoder.XOP(ref instruction);
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_EVEX : OpCodeHandlerModRM
{
	private readonly OpCodeHandler handlerMem;

	public OpCodeHandler_EVEX(OpCodeHandler handlerMem)
	{
		this.handlerMem = handlerMem ?? throw new ArgumentNullException("handlerMem");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			decoder.EVEX_MVEX(ref instruction);
		}
		else if (decoder.state.mod == 3)
		{
			decoder.EVEX_MVEX(ref instruction);
		}
		else
		{
			handlerMem.Decode(decoder, ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PrefixEsCsSsDs : OpCodeHandler
{
	private readonly Register seg;

	public OpCodeHandler_PrefixEsCsSsDs(Register seg)
	{
		this.seg = seg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (!decoder.is64bMode || decoder.state.zs.segmentPrio <= 0)
		{
			instruction.SegmentPrefix = seg;
		}
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PrefixFsGs : OpCodeHandler
{
	private readonly Register seg;

	public OpCodeHandler_PrefixFsGs(Register seg)
	{
		this.seg = seg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.SegmentPrefix = seg;
		decoder.state.zs.segmentPrio = 1;
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Prefix66 : OpCodeHandler
{
	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.state.zs.flags |= StateFlags.Has66;
		decoder.state.operandSize = decoder.defaultInvertedOperandSize;
		if (decoder.state.zs.mandatoryPrefix == MandatoryPrefixByte.None)
		{
			decoder.state.zs.mandatoryPrefix = MandatoryPrefixByte.P66;
		}
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Prefix67 : OpCodeHandler
{
	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.state.addressSize = decoder.defaultInvertedAddressSize;
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PrefixF0 : OpCodeHandler
{
	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetHasLockPrefix();
		decoder.state.zs.flags |= StateFlags.Lock;
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PrefixF2 : OpCodeHandler
{
	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetHasRepnePrefix();
		decoder.state.zs.mandatoryPrefix = MandatoryPrefixByte.PF2;
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PrefixF3 : OpCodeHandler
{
	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetHasRepePrefix();
		decoder.state.zs.mandatoryPrefix = MandatoryPrefixByte.PF3;
		decoder.ResetRexPrefixState();
		decoder.CallOpCodeHandlerXXTable(ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PrefixREX : OpCodeHandler
{
	private readonly OpCodeHandler handler;

	private readonly uint rex;

	public OpCodeHandler_PrefixREX(OpCodeHandler handler, uint rex)
	{
		this.handler = handler ?? throw new InvalidOperationException();
		this.rex = rex;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if ((rex & 8) != 0)
			{
				decoder.state.operandSize = OpSize.Size64;
				decoder.state.zs.flags |= StateFlags.HasRex | StateFlags.W;
			}
			else
			{
				decoder.state.zs.flags |= StateFlags.HasRex;
				decoder.state.zs.flags &= ~StateFlags.W;
				if ((decoder.state.zs.flags & StateFlags.Has66) == 0)
				{
					decoder.state.operandSize = OpSize.Size32;
				}
				else
				{
					decoder.state.operandSize = OpSize.Size16;
				}
			}
			decoder.state.zs.extraRegisterBase = (rex << 1) & 8;
			decoder.state.zs.extraIndexRegisterBase = (rex << 2) & 8;
			decoder.state.zs.extraBaseRegisterBase = (rex << 3) & 8;
			decoder.CallOpCodeHandlerXXTable(ref instruction);
		}
		else
		{
			handler.Decode(decoder, ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_Reg(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = reg;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RegIb : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_RegIb(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = reg;
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_IbReg : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_IbReg(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = reg;
		instruction.Op0Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_AL_DX : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_AL_DX(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = Register.AL;
		instruction.Op1Register = Register.DX;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_DX_AL : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_DX_AL(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = Register.DX;
		instruction.Op1Register = Register.AL;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ib : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_Ib(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ib3 : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Ib3(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MandatoryPrefix : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_MandatoryPrefix(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
	{
		handlers = new OpCodeHandler[4]
		{
			handler ?? throw new ArgumentNullException("handler"),
			handler66 ?? throw new ArgumentNullException("handler66"),
			handlerF3 ?? throw new ArgumentNullException("handlerF3"),
			handlerF2 ?? throw new ArgumentNullException("handlerF2")
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.ClearMandatoryPrefix(ref instruction);
		handlers[(uint)decoder.state.zs.mandatoryPrefix].Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MandatoryPrefix3 : OpCodeHandlerModRM
{
	private readonly struct Info
	{
		public readonly OpCodeHandler handler;

		public readonly bool mandatoryPrefix;

		public Info(OpCodeHandler handler, bool mandatoryPrefix)
		{
			this.handler = handler;
			this.mandatoryPrefix = mandatoryPrefix;
		}
	}

	private readonly Info[] handlers_reg;

	private readonly Info[] handlers_mem;

	public OpCodeHandler_MandatoryPrefix3(OpCodeHandler handler_reg, OpCodeHandler handler_mem, OpCodeHandler handler66_reg, OpCodeHandler handler66_mem, OpCodeHandler handlerF3_reg, OpCodeHandler handlerF3_mem, OpCodeHandler handlerF2_reg, OpCodeHandler handlerF2_mem, LegacyHandlerFlags flags)
	{
		handlers_reg = new Info[4]
		{
			new Info(handler_reg ?? throw new ArgumentNullException("handler_reg"), (flags & LegacyHandlerFlags.HandlerReg) == 0),
			new Info(handler66_reg ?? throw new ArgumentNullException("handler66_reg"), (flags & LegacyHandlerFlags.Handler66Reg) == 0),
			new Info(handlerF3_reg ?? throw new ArgumentNullException("handlerF3_reg"), (flags & LegacyHandlerFlags.HandlerF3Reg) == 0),
			new Info(handlerF2_reg ?? throw new ArgumentNullException("handlerF2_reg"), (flags & LegacyHandlerFlags.HandlerF2Reg) == 0)
		};
		handlers_mem = new Info[4]
		{
			new Info(handler_mem ?? throw new ArgumentNullException("handler_mem"), (flags & LegacyHandlerFlags.HandlerMem) == 0),
			new Info(handler66_mem ?? throw new ArgumentNullException("handler66_mem"), (flags & LegacyHandlerFlags.Handler66Mem) == 0),
			new Info(handlerF3_mem ?? throw new ArgumentNullException("handlerF3_mem"), (flags & LegacyHandlerFlags.HandlerF3Mem) == 0),
			new Info(handlerF2_mem ?? throw new ArgumentNullException("handlerF2_mem"), (flags & LegacyHandlerFlags.HandlerF2Mem) == 0)
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Info info = ((decoder.state.mod == 3) ? handlers_reg : handlers_mem)[(uint)decoder.state.zs.mandatoryPrefix];
		if (info.mandatoryPrefix)
		{
			decoder.ClearMandatoryPrefix(ref instruction);
		}
		info.handler.Decode(decoder, ref instruction);
	}
}


private readonly struct Info
{
	public readonly OpCodeHandler handler;

	public readonly bool mandatoryPrefix;

	public Info(OpCodeHandler handler, bool mandatoryPrefix)
	{
		this.handler = handler;
		this.mandatoryPrefix = mandatoryPrefix;
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MandatoryPrefix4 : OpCodeHandler
{
	private readonly OpCodeHandler handlerNP;

	private readonly OpCodeHandler handler66;

	private readonly OpCodeHandler handlerF3;

	private readonly OpCodeHandler handlerF2;

	private readonly uint flags;

	public OpCodeHandler_MandatoryPrefix4(OpCodeHandler handlerNP, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2, uint flags)
	{
		this.handlerNP = handlerNP ?? throw new ArgumentNullException("handlerNP");
		this.handler66 = handler66 ?? throw new ArgumentNullException("handler66");
		this.handlerF3 = handlerF3 ?? throw new ArgumentNullException("handlerF3");
		this.handlerF2 = handlerF2 ?? throw new ArgumentNullException("handlerF2");
		this.flags = flags;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		OpCodeHandler opCodeHandler;
		switch (decoder.state.zs.mandatoryPrefix)
		{
		case MandatoryPrefixByte.None:
			opCodeHandler = handlerNP;
			break;
		case MandatoryPrefixByte.P66:
			opCodeHandler = handler66;
			break;
		case MandatoryPrefixByte.PF3:
			if ((flags & 4) != 0)
			{
				decoder.ClearMandatoryPrefixF3(ref instruction);
			}
			opCodeHandler = handlerF3;
			break;
		case MandatoryPrefixByte.PF2:
			if ((flags & 8) != 0)
			{
				decoder.ClearMandatoryPrefixF2(ref instruction);
			}
			opCodeHandler = handlerF2;
			break;
		default:
			throw new InvalidOperationException();
		}
		if (opCodeHandler.HasModRM && (flags & 0x10) != 0)
		{
			decoder.ReadModRM();
		}
		opCodeHandler.Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MandatoryPrefix_NoModRM : OpCodeHandler
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_MandatoryPrefix_NoModRM(OpCodeHandler handler, OpCodeHandler handler66, OpCodeHandler handlerF3, OpCodeHandler handlerF2)
	{
		handlers = new OpCodeHandler[4]
		{
			handler ?? throw new ArgumentNullException("handler"),
			handler66 ?? throw new ArgumentNullException("handler66"),
			handlerF3 ?? throw new ArgumentNullException("handlerF3"),
			handlerF2 ?? throw new ArgumentNullException("handlerF2")
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.ClearMandatoryPrefix(ref instruction);
		handlers[(uint)decoder.state.zs.mandatoryPrefix].Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_NIb : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_NIb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reservednop : OpCodeHandlerModRM
{
	private readonly OpCodeHandler reservedNopHandler;

	private readonly OpCodeHandler otherHandler;

	public OpCodeHandler_Reservednop(OpCodeHandler reservedNopHandler, OpCodeHandler otherHandler)
	{
		this.reservedNopHandler = reservedNopHandler ?? throw new ArgumentNullException("reservedNopHandler");
		this.otherHandler = otherHandler ?? throw new ArgumentNullException("otherHandler");
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		(((decoder.options & DecoderOptions.ForceReservedNop) != 0) ? reservedNopHandler : otherHandler).Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Iz : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Ev_Iz(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public OpCodeHandler_Ev_Iz(Code code16, Code code32, Code code64, HandlerFlags flags)
	{
		codes = new Code3(code16, code32, code64);
		this.flags = flags;
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod < 3)
		{
			decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		else
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
		if ((int)num == 1)
		{
			instruction.Op1Kind = OpKind.Immediate32;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else if ((int)num == 2)
		{
			instruction.Op1Kind = OpKind.Immediate32to64;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else
		{
			instruction.Op1Kind = OpKind.Immediate16;
			instruction.InternalImmediate16 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Ib : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Ev_Ib(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public OpCodeHandler_Ev_Ib(Code code16, Code code32, Code code64, HandlerFlags flags)
	{
		codes = new Code3(code16, code32, code64);
		this.flags = flags;
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
		else
		{
			decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		if ((int)num == 1)
		{
			instruction.Op1Kind = OpKind.Immediate8to32;
		}
		else if ((int)num == 2)
		{
			instruction.Op1Kind = OpKind.Immediate8to64;
		}
		else
		{
			instruction.Op1Kind = OpKind.Immediate8to16;
		}
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Ib2 : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Ev_Ib2(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public OpCodeHandler_Ev_Ib2(Code code16, Code code32, Code code64, HandlerFlags flags)
	{
		codes = new Code3(code16, code32, code64);
		this.flags = flags;
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
		else
		{
			decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_1 : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Ev_1(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = 1u;
		decoder.state.zs.flags |= StateFlags.NoImm;
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_CL : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Ev_CL(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = Register.CL;
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Ev(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public OpCodeHandler_Ev(Code code16, Code code32, Code code64, HandlerFlags flags)
	{
		codes = new Code3(code16, code32, code64);
		this.flags = flags;
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Rv : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Rv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Rv_32_64 : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Rv_32_64(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Rq : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Rq(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_REXW : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly uint flags;

	private readonly uint disallowReg;

	private readonly uint disallowMem;

	public OpCodeHandler_Ev_REXW(Code code32, Code code64, uint flags)
	{
		this.code32 = code32;
		this.code64 = code64;
		this.flags = flags;
		disallowReg = (((flags & 1) == 0) ? uint.MaxValue : 0u);
		disallowMem = (((flags & 2) == 0) ? uint.MaxValue : 0u);
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		if ((((flags & 4) | (uint)(decoder.state.zs.flags & StateFlags.Has66)) & decoder.invalidCheckMask) == 32772)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.state.mod == 3)
		{
			if ((decoder.state.zs.flags & StateFlags.W) != 0)
			{
				instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
			}
			else
			{
				instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
			}
			if ((disallowReg & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			if ((disallowMem & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Evj : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Evj(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
			if (decoder.state.mod < 3)
			{
				instruction.Op0Kind = OpKind.Memory;
				decoder.ReadOpMem(ref instruction);
			}
			else if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
			}
			else
			{
				instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 21);
			}
		}
		else
		{
			if (decoder.state.operandSize == OpSize.Size32)
			{
				instruction.InternalSetCodeNoCheck(code32);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
			if (decoder.state.mod < 3)
			{
				instruction.Op0Kind = OpKind.Memory;
				decoder.ReadOpMem(ref instruction);
			}
			else if (decoder.state.operandSize == OpSize.Size32)
			{
				instruction.Op0Register = (Register)(decoder.state.rm + 37);
			}
			else
			{
				instruction.Op0Register = (Register)(decoder.state.rm + 21);
			}
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ep : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ep(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize == OpSize.Size64 && (decoder.options & DecoderOptions.AMD) == 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else if (decoder.state.operandSize == OpSize.Size16)
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Evw : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Evw(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ew : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Ew(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ms : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ms(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Ev(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod < 3)
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		else
		{
			instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gd_Rd : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Gd_Rd(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_M_as : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_M_as(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.addressSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gdq_Ev : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gdq_Ev(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if ((int)num != 2)
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		else
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev3 : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Ev3(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev2 : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Ev2(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			uint num2 = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if (decoder.state.operandSize != 0)
			{
				instruction.Op1Register = (Register)(num2 + 37);
			}
			else
			{
				instruction.Op1Register = (Register)(num2 + 21);
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_R_C : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly Register baseReg;

	public OpCodeHandler_R_C(Code code32, Code code64, Register baseReg)
	{
		this.code32 = code32;
		this.code64 = code64;
		this.baseReg = baseReg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
		}
		uint num = decoder.state.zs.extraRegisterBase;
		if (baseReg == Register.CR0 && instruction.HasLockPrefix && (decoder.options & DecoderOptions.AMD) != 0)
		{
			if ((num & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			num = 8u;
			instruction.InternalClearHasLockPrefix();
			decoder.state.zs.flags &= ~StateFlags.Lock;
		}
		int num2 = (int)(decoder.state.reg + num);
		if (decoder.invalidCheckMask != 0)
		{
			if (baseReg == Register.CR0)
			{
				if (num2 == 1 || (num2 != 8 && num2 >= 5))
				{
					decoder.SetInvalidInstruction();
				}
			}
			else if (baseReg == Register.DR0 && num2 > 7)
			{
				decoder.SetInvalidInstruction();
			}
		}
		instruction.Op1Register = num2 + baseReg;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_C_R : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly Register baseReg;

	public OpCodeHandler_C_R(Code code32, Code code64, Register baseReg)
	{
		this.code32 = code32;
		this.code64 = code64;
		this.baseReg = baseReg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
		}
		uint num = decoder.state.zs.extraRegisterBase;
		if (baseReg == Register.CR0 && instruction.HasLockPrefix && (decoder.options & DecoderOptions.AMD) != 0)
		{
			if ((num & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			num = 8u;
			instruction.InternalClearHasLockPrefix();
			decoder.state.zs.flags &= ~StateFlags.Lock;
		}
		int num2 = (int)(decoder.state.reg + num);
		if (decoder.invalidCheckMask != 0)
		{
			if (baseReg == Register.CR0)
			{
				if (num2 == 1 || (num2 != 8 && num2 >= 5))
				{
					decoder.SetInvalidInstruction();
				}
			}
			else if (baseReg == Register.DR0 && num2 > 7)
			{
				decoder.SetInvalidInstruction();
			}
		}
		instruction.Op0Register = num2 + baseReg;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Jb : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Jb(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.state.zs.flags |= StateFlags.BranchImm8;
		if (decoder.is64bMode)
		{
			if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = (ulong)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer64();
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
				instruction.Op0Kind = OpKind.NearBranch16;
				instruction.InternalNearBranch16 = (ushort)((uint)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer32());
			}
		}
		else if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Kind = OpKind.NearBranch32;
			instruction.NearBranch32 = (uint)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Kind = OpKind.NearBranch16;
			instruction.InternalNearBranch16 = (ushort)((uint)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer32());
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Jx : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Jx(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.state.zs.flags |= StateFlags.Xbegin;
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize == OpSize.Size32)
			{
				instruction.InternalSetCodeNoCheck(code32);
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = (ulong)(int)decoder.ReadUInt32() + decoder.GetCurrentInstructionPointer64();
			}
			else if (decoder.state.operandSize == OpSize.Size64)
			{
				instruction.InternalSetCodeNoCheck(code64);
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = (ulong)(int)decoder.ReadUInt32() + decoder.GetCurrentInstructionPointer64();
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = (ulong)(short)decoder.ReadUInt16() + decoder.GetCurrentInstructionPointer64();
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Kind = OpKind.NearBranch32;
			instruction.NearBranch32 = decoder.ReadUInt32() + decoder.GetCurrentInstructionPointer32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Kind = OpKind.NearBranch32;
			instruction.NearBranch32 = (uint)(short)decoder.ReadUInt16() + decoder.GetCurrentInstructionPointer32();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Jz : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Jz(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = (ulong)(int)decoder.ReadUInt32() + decoder.GetCurrentInstructionPointer64();
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
				instruction.Op0Kind = OpKind.NearBranch16;
				instruction.InternalNearBranch16 = (ushort)(decoder.ReadUInt16() + decoder.GetCurrentInstructionPointer32());
			}
		}
		else if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Kind = OpKind.NearBranch32;
			instruction.NearBranch32 = decoder.ReadUInt32() + decoder.GetCurrentInstructionPointer32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Kind = OpKind.NearBranch16;
			instruction.InternalNearBranch16 = (ushort)(decoder.ReadUInt16() + decoder.GetCurrentInstructionPointer32());
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Jb2 : OpCodeHandler
{
	private readonly Code code16_16;

	private readonly Code code16_32;

	private readonly Code code16_64;

	private readonly Code code32_16;

	private readonly Code code32_32;

	private readonly Code code64_32;

	private readonly Code code64_64;

	public OpCodeHandler_Jb2(Code code16_16, Code code16_32, Code code16_64, Code code32_16, Code code32_32, Code code64_32, Code code64_64)
	{
		this.code16_16 = code16_16;
		this.code16_32 = code16_32;
		this.code16_64 = code16_64;
		this.code32_16 = code32_16;
		this.code32_32 = code32_32;
		this.code64_32 = code64_32;
		this.code64_64 = code64_64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.state.zs.flags |= StateFlags.BranchImm8;
		if (decoder.is64bMode)
		{
			if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				if (decoder.state.addressSize == OpSize.Size64)
				{
					instruction.InternalSetCodeNoCheck(code64_64);
				}
				else
				{
					instruction.InternalSetCodeNoCheck(code64_32);
				}
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = (ulong)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer64();
			}
			else
			{
				if (decoder.state.addressSize == OpSize.Size64)
				{
					instruction.InternalSetCodeNoCheck(code16_64);
				}
				else
				{
					instruction.InternalSetCodeNoCheck(code16_32);
				}
				instruction.Op0Kind = OpKind.NearBranch16;
				instruction.InternalNearBranch16 = (ushort)((uint)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer32());
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			if (decoder.state.addressSize == OpSize.Size32)
			{
				instruction.InternalSetCodeNoCheck(code32_32);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code32_16);
			}
			instruction.Op0Kind = OpKind.NearBranch32;
			instruction.NearBranch32 = (uint)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer32();
		}
		else
		{
			if (decoder.state.addressSize == OpSize.Size32)
			{
				instruction.InternalSetCodeNoCheck(code16_32);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16_16);
			}
			instruction.Op0Kind = OpKind.NearBranch16;
			instruction.InternalNearBranch16 = (ushort)((uint)(sbyte)decoder.ReadByte() + decoder.GetCurrentInstructionPointer32());
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Jdisp : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Jdisp(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Kind = OpKind.NearBranch32;
			instruction.NearBranch32 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Kind = OpKind.NearBranch16;
			instruction.InternalNearBranch16 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PushOpSizeReg : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	private readonly Register reg;

	public OpCodeHandler_PushOpSizeReg(Code code16, Code code32, Code code64, Register reg)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		instruction.Op0Register = reg;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PushEv : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_PushEv(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		if (decoder.state.mod == 3)
		{
			uint num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if (decoder.is64bMode)
			{
				if (decoder.state.operandSize != 0)
				{
					instruction.Op0Register = (Register)(num + 53);
				}
				else
				{
					instruction.Op0Register = (Register)(num + 21);
				}
			}
			else if (decoder.state.operandSize == OpSize.Size32)
			{
				instruction.Op0Register = (Register)(num + 37);
			}
			else
			{
				instruction.Op0Register = (Register)(num + 21);
			}
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Gv : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Ev_Gv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public OpCodeHandler_Ev_Gv(Code code16, Code code32, Code code64, HandlerFlags flags)
	{
		codes = new Code3(code16, code32, code64);
		this.flags = flags;
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Gv_32_64 : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ev_Gv_32_64(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Gv_Ib : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Ev_Gv_Ib(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Gv_CL : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Ev_Gv_CL(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op2Register = Register.CL;
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Mp : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_Mp(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize == OpSize.Size64 && (decoder.options & DecoderOptions.AMD) == 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else if (decoder.state.operandSize == OpSize.Size16)
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 21);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Eb : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Eb(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			uint num2 = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num2 >= 4)
			{
				num2 += 4;
			}
			instruction.Op1Register = (Register)(num2 + 1);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ew : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Ew(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 21);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PushSimple2 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_PushSimple2(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple2 : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Simple2(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple2Iw : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Simple2Iw(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Kind = OpKind.Immediate16;
		instruction.InternalImmediate16 = decoder.ReadUInt16();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple3 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Simple3(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple5 : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Simple5(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.addressSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple5_a32 : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Simple5_a32(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.addressSize != OpSize.Size32 && decoder.invalidCheckMask != 0)
		{
			decoder.SetInvalidInstruction();
		}
		nuint num = (nuint)decoder.state.addressSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple5_ModRM_as : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Simple5_ModRM_as(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.addressSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Simple4 : OpCodeHandler
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Simple4(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PushSimpleReg : OpCodeHandler
{
	private readonly int index;

	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_PushSimpleReg(int index, Code code16, Code code32, Code code64)
	{
		this.index = index;
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
				instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 53);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
				instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 21);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 37);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 21);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_SimpleReg : OpCodeHandler
{
	private readonly Code code;

	private readonly int index;

	public OpCodeHandler_SimpleReg(Code code, int index)
	{
		this.code = code;
		this.index = index;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		int operandSize = (int)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck(operandSize + code);
		instruction.Op0Register = (Register)(operandSize * 16 + index + (int)decoder.state.zs.extraBaseRegisterBase + 21);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Xchg_Reg_rAX : OpCodeHandler
{
	private readonly int index;

	private readonly Code[] codes;

	private static readonly Code[] s_codes = new Code[48]
	{
		Code.Nopw,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Xchg_r16_AX,
		Code.Nopd,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Xchg_r32_EAX,
		Code.Nopq,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX,
		Code.Xchg_r64_RAX
	};

	public OpCodeHandler_Xchg_Reg_rAX(int index)
	{
		this.index = index;
		codes = s_codes;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (index == 0 && decoder.state.zs.mandatoryPrefix == MandatoryPrefixByte.PF3 && (decoder.options & DecoderOptions.NoPause) == 0)
		{
			decoder.ClearMandatoryPrefixF3(ref instruction);
			instruction.InternalSetCodeNoCheck(Code.Pause);
			return;
		}
		int operandSize = (int)decoder.state.operandSize;
		int num = index + (int)decoder.state.zs.extraBaseRegisterBase;
		instruction.InternalSetCodeNoCheck(codes[operandSize * 16 + num]);
		if (num != 0)
		{
			Register op0Register = (Register)(operandSize * 16 + num + 21);
			instruction.Op0Register = op0Register;
			instruction.Op1Register = (Register)(operandSize * 16 + 21);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Iz : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Reg_Iz(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = Register.EAX;
			instruction.Op1Kind = OpKind.Immediate32;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else if (decoder.state.operandSize == OpSize.Size64)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = Register.RAX;
			instruction.Op1Kind = OpKind.Immediate32to64;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = Register.AX;
			instruction.Op1Kind = OpKind.Immediate16;
			instruction.InternalImmediate16 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RegIb3 : OpCodeHandler
{
	private readonly int index;

	private readonly Register[] withRexPrefix;

	private static readonly Register[] s_withRexPrefix = new Register[16]
	{
		Register.AL,
		Register.CL,
		Register.DL,
		Register.BL,
		Register.SPL,
		Register.BPL,
		Register.SIL,
		Register.DIL,
		Register.R8L,
		Register.R9L,
		Register.R10L,
		Register.R11L,
		Register.R12L,
		Register.R13L,
		Register.R14L,
		Register.R15L
	};

	public OpCodeHandler_RegIb3(int index)
	{
		this.index = index;
		withRexPrefix = s_withRexPrefix;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register op0Register = (((decoder.state.zs.flags & StateFlags.HasRex) == 0) ? ((Register)(index + 1)) : withRexPrefix[index + (int)decoder.state.zs.extraBaseRegisterBase]);
		instruction.InternalSetCodeNoCheck(Code.Mov_r8_imm8);
		instruction.Op0Register = op0Register;
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RegIz2 : OpCodeHandler
{
	private readonly int index;

	public OpCodeHandler_RegIz2(int index)
	{
		this.index = index;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(Code.Mov_r32_imm32);
			instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 37);
			instruction.Op1Kind = OpKind.Immediate32;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else if (decoder.state.operandSize == OpSize.Size64)
		{
			instruction.InternalSetCodeNoCheck(Code.Mov_r64_imm64);
			instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 53);
			instruction.Op1Kind = OpKind.Immediate64;
			instruction.InternalImmediate64_lo = decoder.ReadUInt32();
			instruction.InternalImmediate64_hi = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(Code.Mov_r16_imm16);
			instruction.Op0Register = (Register)(index + (int)decoder.state.zs.extraBaseRegisterBase + 21);
			instruction.Op1Kind = OpKind.Immediate16;
			instruction.InternalImmediate16 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PushIb2 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_PushIb2(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
				instruction.Op0Kind = OpKind.Immediate8to64;
				instruction.InternalImmediate8 = decoder.ReadByte();
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
				instruction.Op0Kind = OpKind.Immediate8to16;
				instruction.InternalImmediate8 = decoder.ReadByte();
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Kind = OpKind.Immediate8to32;
			instruction.InternalImmediate8 = decoder.ReadByte();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Kind = OpKind.Immediate8to16;
			instruction.InternalImmediate8 = decoder.ReadByte();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_PushIz : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_PushIz(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
				instruction.Op0Kind = OpKind.Immediate32to64;
				instruction.Immediate32 = decoder.ReadUInt32();
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
				instruction.Op0Kind = OpKind.Immediate16;
				instruction.InternalImmediate16 = decoder.ReadUInt16();
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Kind = OpKind.Immediate32;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Kind = OpKind.Immediate16;
			instruction.InternalImmediate16 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ma : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Gv_Ma(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 21);
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RvMw_Gw : OpCodeHandlerModRM
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_RvMw_Gw(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
			register = Register.EAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 21);
			register = Register.AX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev_Ib : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Ev_Ib(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		if ((int)num == 1)
		{
			instruction.Op2Kind = OpKind.Immediate8to32;
			instruction.InternalImmediate8 = decoder.ReadByte();
		}
		else if ((int)num == 2)
		{
			instruction.Op2Kind = OpKind.Immediate8to64;
			instruction.InternalImmediate8 = decoder.ReadByte();
		}
		else
		{
			instruction.Op2Kind = OpKind.Immediate8to16;
			instruction.InternalImmediate8 = decoder.ReadByte();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev_Ib_REX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_Ev_Ib_REX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev_32_64 : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly uint disallowReg;

	private readonly uint disallowMem;

	public OpCodeHandler_Gv_Ev_32_64(Code code32, Code code64, bool allowReg, bool allowMem)
	{
		this.code32 = code32;
		this.code64 = code64;
		disallowMem = ((!allowMem) ? uint.MaxValue : 0u);
		disallowReg = ((!allowReg) ? uint.MaxValue : 0u);
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			if ((disallowReg & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
			return;
		}
		if ((disallowMem & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev_Iz : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Ev_Iz(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		if ((int)num == 1)
		{
			instruction.Op2Kind = OpKind.Immediate32;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else if ((int)num == 2)
		{
			instruction.Op2Kind = OpKind.Immediate32to64;
			instruction.Immediate32 = decoder.ReadUInt32();
		}
		else
		{
			instruction.Op2Kind = OpKind.Immediate16;
			instruction.InternalImmediate16 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Yb_Reg : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_Yb_Reg(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = reg;
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Yv_Reg : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Yv_Reg(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = (Register)(((int)num << 4) + 21);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Yv_Reg2 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Yv_Reg2(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = Register.DX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op1Register = Register.DX;
		}
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Xb : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_Reg_Xb(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = reg;
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op1Kind = OpKind.MemorySegRSI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op1Kind = OpKind.MemorySegESI;
		}
		else
		{
			instruction.Op1Kind = OpKind.MemorySegSI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Xv : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Reg_Xv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + 21);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op1Kind = OpKind.MemorySegRSI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op1Kind = OpKind.MemorySegESI;
		}
		else
		{
			instruction.Op1Kind = OpKind.MemorySegSI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Xv2 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Reg_Xv2(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = Register.DX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = Register.DX;
		}
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op1Kind = OpKind.MemorySegRSI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op1Kind = OpKind.MemorySegESI;
		}
		else
		{
			instruction.Op1Kind = OpKind.MemorySegSI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Yb : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_Reg_Yb(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = reg;
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op1Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op1Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op1Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Yv : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Reg_Yv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + 21);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op1Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op1Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op1Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Yb_Xb : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_Yb_Xb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemoryESRDI;
			instruction.Op1Kind = OpKind.MemorySegRSI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemoryESEDI;
			instruction.Op1Kind = OpKind.MemorySegESI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemoryESDI;
			instruction.Op1Kind = OpKind.MemorySegSI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Yv_Xv : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Yv_Xv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemoryESRDI;
			instruction.Op1Kind = OpKind.MemorySegRSI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemoryESEDI;
			instruction.Op1Kind = OpKind.MemorySegESI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemoryESDI;
			instruction.Op1Kind = OpKind.MemorySegSI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Xb_Yb : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_Xb_Yb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemorySegRSI;
			instruction.Op1Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemorySegESI;
			instruction.Op1Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemorySegSI;
			instruction.Op1Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Xv_Yv : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Xv_Yv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemorySegRSI;
			instruction.Op1Kind = OpKind.MemoryESRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemorySegESI;
			instruction.Op1Kind = OpKind.MemoryESEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemorySegSI;
			instruction.Op1Kind = OpKind.MemoryESDI;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Sw : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Ev_Sw(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Register = decoder.ReadOpSegReg();
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_M_Sw : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_M_Sw(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = decoder.ReadOpSegReg();
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_M : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_M(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod < 3)
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Sw_Ev : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Sw_Ev(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		Register register = decoder.ReadOpSegReg();
		if (decoder.invalidCheckMask != 0 && register == Register.CS)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op0Register = register;
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + 21);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Sw_M : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Sw_M(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = decoder.ReadOpSegReg();
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ap : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Ap(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		if (decoder.state.operandSize != 0)
		{
			instruction.Op0Kind = OpKind.FarBranch32;
			instruction.FarBranch32 = decoder.ReadUInt32();
		}
		else
		{
			instruction.Op0Kind = OpKind.FarBranch16;
			instruction.InternalFarBranch16 = decoder.ReadUInt16();
		}
		instruction.InternalFarBranchSelector = decoder.ReadUInt16();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Ob : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_Reg_Ob(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = reg;
		decoder.displIndex = decoder.state.zs.instructionLength;
		instruction.Op1Kind = OpKind.Memory;
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.InternalSetMemoryDisplSize(4u);
			decoder.state.zs.flags |= StateFlags.Addr64;
			instruction.MemoryDisplacement64 = decoder.ReadUInt64();
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.InternalSetMemoryDisplSize(3u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetMemoryDisplSize(2u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ob_Reg : OpCodeHandler
{
	private readonly Code code;

	private readonly Register reg;

	public OpCodeHandler_Ob_Reg(Code code, Register reg)
	{
		this.code = code;
		this.reg = reg;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		decoder.displIndex = decoder.state.zs.instructionLength;
		instruction.Op0Kind = OpKind.Memory;
		instruction.Op1Register = reg;
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.InternalSetMemoryDisplSize(4u);
			decoder.state.zs.flags |= StateFlags.Addr64;
			instruction.MemoryDisplacement64 = decoder.ReadUInt64();
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.InternalSetMemoryDisplSize(3u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetMemoryDisplSize(2u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Ov : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Reg_Ov(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.displIndex = decoder.state.zs.instructionLength;
		instruction.Op1Kind = OpKind.Memory;
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + 21);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.InternalSetMemoryDisplSize(4u);
			decoder.state.zs.flags |= StateFlags.Addr64;
			instruction.MemoryDisplacement64 = decoder.ReadUInt64();
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.InternalSetMemoryDisplSize(3u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetMemoryDisplSize(2u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ov_Reg : OpCodeHandler
{
	private readonly Code3 codes;

	public OpCodeHandler_Ov_Reg(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.displIndex = decoder.state.zs.instructionLength;
		instruction.Op0Kind = OpKind.Memory;
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = (Register)(((int)num << 4) + 21);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.InternalSetMemoryDisplSize(4u);
			decoder.state.zs.flags |= StateFlags.Addr64;
			instruction.MemoryDisplacement64 = decoder.ReadUInt64();
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.InternalSetMemoryDisplSize(3u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt32();
		}
		else
		{
			instruction.InternalSetMemoryDisplSize(2u);
			instruction.MemoryDisplacement64 = decoder.ReadUInt16();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_BranchIw : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_BranchIw(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
		instruction.Op0Kind = OpKind.Immediate16;
		instruction.InternalImmediate16 = decoder.ReadUInt16();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_BranchSimple : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_BranchSimple(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.is64bMode)
		{
			if ((decoder.options & DecoderOptions.AMD) == 0 || decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Iw_Ib : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Iw_Ib(Code code16, Code code32, Code code64)
	{
		this.code16 = code16;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op0Kind = OpKind.Immediate16;
		instruction.InternalImmediate16 = decoder.ReadUInt16();
		instruction.Op1Kind = OpKind.Immediate8_2nd;
		instruction.InternalImmediate8_2nd = decoder.ReadByte();
		if (decoder.is64bMode)
		{
			if (decoder.state.operandSize != 0)
			{
				instruction.InternalSetCodeNoCheck(code64);
			}
			else
			{
				instruction.InternalSetCodeNoCheck(code16);
			}
		}
		else if (decoder.state.operandSize == OpSize.Size32)
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Reg_Ib2 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_Reg_Ib2(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = Register.EAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = Register.AX;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_IbReg2 : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_IbReg2(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op0Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = Register.EAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op1Register = Register.AX;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_eAX_DX : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_eAX_DX(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Register = Register.DX;
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = Register.EAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op0Register = Register.AX;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_DX_eAX : OpCodeHandler
{
	private readonly Code code16;

	private readonly Code code32;

	public OpCodeHandler_DX_eAX(Code code16, Code code32)
	{
		this.code16 = code16;
		this.code32 = code32;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op0Register = Register.DX;
		if (decoder.state.operandSize != 0)
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = Register.EAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code16);
			instruction.Op1Register = Register.AX;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Eb_Ib : OpCodeHandlerModRM
{
	private readonly Code code;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Eb_Ib(Code code)
	{
		this.code = code;
	}

	public OpCodeHandler_Eb_Ib(Code code, HandlerFlags flags)
	{
		this.code = code;
		this.flags = flags;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod < 3)
		{
			decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		else
		{
			uint num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op0Register = (Register)(num + 1);
		}
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Eb_1 : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Eb_1(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = 1u;
		decoder.state.zs.flags |= StateFlags.NoImm;
		if (decoder.state.mod == 3)
		{
			uint num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op0Register = (Register)(num + 1);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Eb_CL : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Eb_CL(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = Register.CL;
		if (decoder.state.mod == 3)
		{
			uint num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op0Register = (Register)(num + 1);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Eb : OpCodeHandlerModRM
{
	private readonly Code code;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Eb(Code code)
	{
		this.code = code;
	}

	public OpCodeHandler_Eb(Code code, HandlerFlags flags)
	{
		this.code = code;
		this.flags = flags;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			uint num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op0Register = (Register)(num + 1);
		}
		else
		{
			decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Eb_Gb : OpCodeHandlerModRM
{
	private readonly Code code;

	private readonly HandlerFlags flags;

	public OpCodeHandler_Eb_Gb(Code code)
	{
		this.code = code;
	}

	public OpCodeHandler_Eb_Gb(Code code, HandlerFlags flags)
	{
		this.code = code;
		this.flags = flags;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		uint num = decoder.state.reg + decoder.state.zs.extraRegisterBase;
		if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
		{
			num += 4;
		}
		instruction.Op1Register = (Register)(num + 1);
		if (decoder.state.mod == 3)
		{
			num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op0Register = (Register)(num + 1);
		}
		else
		{
			decoder.state.zs.flags |= (StateFlags)((uint)(flags & HandlerFlags.Lock) << 10);
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gb_Eb : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Gb_Eb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		uint num = decoder.state.reg + decoder.state.zs.extraRegisterBase;
		if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
		{
			num += 4;
		}
		instruction.Op0Register = (Register)(num + 1);
		if (decoder.state.mod == 3)
		{
			num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op1Register = (Register)(num + 1);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_M : OpCodeHandlerModRM
{
	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_M(Code codeW0, Code codeW1)
	{
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public OpCodeHandler_M(Code codeW0)
	{
		this.codeW0 = codeW0;
		codeW1 = codeW0;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
		}
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_M_REXW : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly HandlerFlags flags32;

	private readonly HandlerFlags flags64;

	public OpCodeHandler_M_REXW(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public OpCodeHandler_M_REXW(Code code32, Code code64, HandlerFlags flags32, HandlerFlags flags64)
	{
		this.code32 = code32;
		this.code64 = code64;
		this.flags32 = flags32;
		this.flags64 = flags64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		HandlerFlags handlerFlags = (((decoder.state.zs.flags & StateFlags.W) != 0) ? flags64 : flags32);
		if ((handlerFlags & (HandlerFlags.Xacquire | HandlerFlags.Xrelease)) != 0)
		{
			decoder.SetXacquireXrelease(ref instruction);
		}
		decoder.state.zs.flags |= (StateFlags)((uint)(handlerFlags & HandlerFlags.Lock) << 10);
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MemBx : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_MemBx(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.InternalMemoryIndex = Register.AL;
		instruction.Op0Kind = OpKind.Memory;
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.InternalMemoryBase = Register.RBX;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.InternalMemoryBase = Register.EBX;
		}
		else
		{
			instruction.InternalMemoryBase = Register.BX;
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VW : OpCodeHandlerModRM
{
	private readonly Code codeR;

	private readonly Code codeM;

	public OpCodeHandler_VW(Code codeR, Code codeM)
	{
		this.codeR = codeR;
		this.codeM = codeM;
	}

	public OpCodeHandler_VW(Code code)
	{
		codeR = code;
		codeM = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.InternalSetCodeNoCheck(codeR);
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeM);
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_WV : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_WV(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod < 3)
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		else
		{
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_rDI_VX_RX : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_rDI_VX_RX(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemorySegRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemorySegEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemorySegDI;
		}
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_rDI_P_N : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_rDI_P_N(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemorySegRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemorySegEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemorySegDI;
		}
		instruction.Op1Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VM : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VM(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MV : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_MV(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VQ : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VQ(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_P_Q : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_P_Q(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Q_P : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_Q_P(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(decoder.state.rm + 225);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MP : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_MP(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_P_Q_Ib : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_P_Q_Ib(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_P_W : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_P_W(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_P_R : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_P_R(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_P_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_P_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_P_Ev_Ib : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_P_Ev_Ib(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + 225);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_P : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ev_P(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Register = (Register)(decoder.state.reg + 225);
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_W : OpCodeHandlerModRM
{
	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_Gv_W(Code codeW0, Code codeW1)
	{
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_V_Ev : OpCodeHandlerModRM
{
	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_V_Ev(Code codeW0, Code codeW1)
	{
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (decoder.state.operandSize != OpSize.Size64)
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			register = Register.EAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			register = Register.RAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VWIb : OpCodeHandlerModRM
{
	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_VWIb(Code code)
	{
		codeW0 = code;
		codeW1 = code;
	}

	public OpCodeHandler_VWIb(Code codeW0, Code codeW1)
	{
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
		}
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VRIbIb : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VRIbIb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
		instruction.Op3Kind = OpKind.Immediate8_2nd;
		instruction.InternalImmediate8_2nd = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RIbIb : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_RIbIb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
		instruction.Op2Kind = OpKind.Immediate8_2nd;
		instruction.InternalImmediate8_2nd = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_RIb : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_RIb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ed_V_Ib : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ed_V_Ib(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VX_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VX_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_VX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ev_VX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VX_E_Ib : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VX_E_Ib(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_RX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_RX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 77);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_B_MIB : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_B_MIB(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.reg > 3 || (decoder.state.zs.extraRegisterBase & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 181);
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem_MPX(ref instruction);
		if (decoder.invalidCheckMask != 0 && instruction.MemoryBase == Register.RIP)
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_MIB_B : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_MIB_B(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.reg > 3 || (decoder.state.zs.extraRegisterBase & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + 181);
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem_MPX(ref instruction);
		if (decoder.invalidCheckMask != 0 && instruction.MemoryBase == Register.RIP)
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_B_BM : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_B_BM(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.reg > 3 || (decoder.state.zs.extraRegisterBase & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		instruction.Op0Register = (Register)(decoder.state.reg + 181);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 181);
			if (decoder.state.rm > 3 || (decoder.state.zs.extraBaseRegisterBase & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem_MPX(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_BM_B : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_BM_B(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.reg > 3 || (decoder.state.zs.extraRegisterBase & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		instruction.Op1Register = (Register)(decoder.state.reg + 181);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)(decoder.state.rm + 181);
			if (decoder.state.rm > 3 || (decoder.state.zs.extraBaseRegisterBase & decoder.invalidCheckMask) != 0)
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem_MPX(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_B_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	private readonly uint ripRelMask;

	public OpCodeHandler_B_Ev(Code code32, Code code64, bool supportsRipRel)
	{
		this.code32 = code32;
		this.code64 = code64;
		ripRelMask = ((!supportsRipRel) ? uint.MaxValue : 0u);
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.state.reg > 3 || (decoder.state.zs.extraRegisterBase & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (decoder.is64bMode)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + 181);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem_MPX(ref instruction);
		if ((ripRelMask & decoder.invalidCheckMask) != 0 && instruction.MemoryBase == Register.RIP)
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Mv_Gv_REXW : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Mv_Gv_REXW(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_N_Ib_REX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_N_Ib_REX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_N : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_N(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
		}
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VN : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VN(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 225);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Mv : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Gv_Mv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op0Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Mv_Gv : OpCodeHandlerModRM
{
	private readonly Code3 codes;

	public OpCodeHandler_Mv_Gv(Code code16, Code code32, Code code64)
	{
		codes = new Code3(code16, code32, code64);
	}

	public unsafe override void Decode(Decoder decoder, ref Instruction instruction)
	{
		nuint num = (nuint)decoder.state.operandSize;
		instruction.InternalSetCodeNoCheck((Code)codes.codes[num]);
		instruction.Op1Register = (Register)(((int)num << 4) + (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + 21);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Eb_REX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_Eb_REX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			uint num = decoder.state.rm + decoder.state.zs.extraBaseRegisterBase;
			if ((decoder.state.zs.flags & StateFlags.HasRex) != 0 && num >= 4)
			{
				num += 4;
			}
			instruction.Op1Register = (Register)(num + 1);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Gv_Ev_REX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Gv_Ev_REX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			if ((decoder.state.zs.flags & StateFlags.W) != 0)
			{
				instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
			}
			else
			{
				instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
			}
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Ev_Gv_REX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_Ev_Gv_REX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_GvM_VX_Ib : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_GvM_VX_Ib(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		Register register;
		if ((decoder.state.zs.flags & StateFlags.W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_Wbinvd : OpCodeHandler
{
	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.options & DecoderOptions.NoWbnoinvd) != 0 || decoder.state.zs.mandatoryPrefix != MandatoryPrefixByte.PF3)
		{
			instruction.InternalSetCodeNoCheck(Code.Wbinvd);
			return;
		}
		decoder.ClearMandatoryPrefixF3(ref instruction);
		instruction.InternalSetCodeNoCheck(Code.Wbnoinvd);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VectorLength_VEX : OpCodeHandlerModRM
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_VectorLength_VEX(OpCodeHandler handler128, OpCodeHandler handler256)
	{
		handlers = new OpCodeHandler[4]
		{
			handler128 ?? throw new ArgumentNullException("handler128"),
			handler256 ?? throw new ArgumentNullException("handler256"),
			OpCodeHandler_Invalid.Instance,
			OpCodeHandler_Invalid.Instance
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		handlers[decoder.state.vectorLength].Decode(decoder, ref instruction);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VectorLength_NoModRM_VEX : OpCodeHandler
{
	private readonly OpCodeHandler[] handlers;

	public OpCodeHandler_VectorLength_NoModRM_VEX(OpCodeHandler handler128, OpCodeHandler handler256)
	{
		handlers = new OpCodeHandler[4]
		{
			handler128 ?? throw new ArgumentNullException("handler128"),
			handler256 ?? throw new ArgumentNullException("handler256"),
			OpCodeHandler_Invalid.Instance,
			OpCodeHandler_Invalid.Instance
		};
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		handlers[decoder.state.vectorLength].Decode(decoder, ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Simple : OpCodeHandler
{
	private readonly Code code;

	public OpCodeHandler_VEX_Simple(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHEv : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_VEX_VHEv(Register baseReg, Code codeW0, Code codeW1)
	{
		this.baseReg = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHEvIb : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_VEX_VHEvIb(Register baseReg, Code codeW0, Code codeW1)
	{
		this.baseReg = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VW : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	public OpCodeHandler_VEX_VW(Register baseReg, Code code)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
	}

	public OpCodeHandler_VEX_VW(Register baseReg1, Register baseReg2, Code code)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg2);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VX_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_VX_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Ev_VX : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Ev_VX(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op1Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 77);
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_WV : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	public OpCodeHandler_VEX_WV(Register baseReg, Code code)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg2);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VM : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VM(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_MV : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_MV(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_M : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_M(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_RdRq : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_RdRq(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
		}
		if (decoder.state.mod != 3)
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_rDI_VX_RX : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_rDI_VX_RX(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.addressSize == OpSize.Size64)
		{
			instruction.Op0Kind = OpKind.MemorySegRDI;
		}
		else if (decoder.state.addressSize == OpSize.Size32)
		{
			instruction.Op0Kind = OpKind.MemorySegEDI;
		}
		else
		{
			instruction.Op0Kind = OpKind.MemorySegDI;
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_VEX_VWIb(Register baseReg, Code code)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		codeW0 = code;
		codeW1 = code;
	}

	public OpCodeHandler_VEX_VWIb(Register baseReg, Code codeW0, Code codeW1)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg1);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg2);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_WVIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Code code;

	public OpCodeHandler_VEX_WVIb(Register baseReg1, Register baseReg2, Code code)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg1);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg2);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Ed_V_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Ed_V_Ib(Register baseReg, Code code32, Code code64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHW : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Register baseReg3;

	private readonly Code codeR;

	private readonly Code codeM;

	public OpCodeHandler_VEX_VHW(Register baseReg, Code codeR, Code codeM)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		this.codeR = codeR;
		this.codeM = codeM;
	}

	public OpCodeHandler_VEX_VHW(Register baseReg, Code code)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		codeR = code;
		codeM = code;
	}

	public OpCodeHandler_VEX_VHW(Register baseReg1, Register baseReg2, Register baseReg3, Code code)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.baseReg3 = baseReg3;
		codeR = code;
		codeM = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			instruction.InternalSetCodeNoCheck(codeR);
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg3);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeM);
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VWH : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VWH(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op2Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_WHV : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeR;

	public OpCodeHandler_VEX_WHV(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		codeR = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(codeR);
		instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		instruction.Op2Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHM : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VHM(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_MHV : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_MHV(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		instruction.Op2Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHWIb : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register baseReg2;

	private readonly Register baseReg3;

	private readonly Code code;

	public OpCodeHandler_VEX_VHWIb(Register baseReg, Code code)
	{
		baseReg1 = baseReg;
		baseReg2 = baseReg;
		baseReg3 = baseReg;
		this.code = code;
	}

	public OpCodeHandler_VEX_VHWIb(Register baseReg1, Register baseReg2, Register baseReg3, Code code)
	{
		this.baseReg1 = baseReg1;
		this.baseReg2 = baseReg2;
		this.baseReg3 = baseReg3;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg1);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg2);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg3);
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op3Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_HRIb : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_HRIb(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHWIs4 : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VHWIs4(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op3Register = (Register)((int)((decoder.ReadByte() >> 4) & decoder.reg15Mask) + (int)baseReg);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHIs4W : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VHIs4W(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op3Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			instruction.Op3Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Register = (Register)((int)((decoder.ReadByte() >> 4) & decoder.reg15Mask) + (int)baseReg);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHWIs5 : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VHWIs5(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			instruction.Op2Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		uint num = decoder.ReadByte();
		instruction.Op3Register = (Register)((int)((num >> 4) & decoder.reg15Mask) + (int)baseReg);
		instruction.InternalImmediate8 = num & 0xF;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VHIs5W : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code;

	public OpCodeHandler_VEX_VHIs5W(Register baseReg, Code code)
	{
		this.baseReg = baseReg;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)baseReg);
		if (decoder.state.mod == 3)
		{
			instruction.Op3Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			instruction.Op3Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		uint num = decoder.ReadByte();
		instruction.Op2Register = (Register)((int)((num >> 4) & decoder.reg15Mask) + (int)baseReg);
		instruction.InternalImmediate8 = num & 0xF;
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VK_HK_RK : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VK_HK_RK(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && (decoder.state.vvvv > 7 || decoder.state.zs.extraRegisterBase != 0))
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		instruction.Op1Register = (Register)((decoder.state.vvvv & 7) + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)(decoder.state.rm + 173);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VK_RK : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VK_RK(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 173);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VK_RK_Ib : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VK_RK_Ib(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 173);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VK_WK : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VK_WK(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 173);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_M_VK : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_M_VK(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VK_R : OpCodeHandlerModRM
{
	private readonly Code code;

	private readonly Register gpr;

	public OpCodeHandler_VEX_VK_R(Code code, Register gpr)
	{
		this.code = code;
		this.gpr = gpr;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)gpr);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_G_VK : OpCodeHandlerModRM
{
	private readonly Code code;

	private readonly Register gpr;

	public OpCodeHandler_VEX_G_VK(Code code, Register gpr)
	{
		this.code = code;
		this.gpr = gpr;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)gpr);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 173);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_W : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code codeW0;

	private readonly Code codeW1;

	public OpCodeHandler_VEX_Gv_W(Register baseReg, Code codeW0, Code codeW1)
	{
		this.baseReg = baseReg;
		this.codeW0 = codeW0;
		this.codeW1 = codeW1;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(codeW1);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(codeW0);
			instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_RX : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_RX(Register baseReg, Code code32, Code code64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_GPR_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_GPR_Ib(Register baseReg, Code code32, Code code64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)baseReg);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VX_VSIB_HX : OpCodeHandlerModRM
{
	private readonly Register baseReg1;

	private readonly Register vsibIndex;

	private readonly Register baseReg3;

	private readonly Code code;

	public OpCodeHandler_VEX_VX_VSIB_HX(Register baseReg1, Register vsibIndex, Register baseReg3, Code code)
	{
		this.baseReg1 = baseReg1;
		this.vsibIndex = vsibIndex;
		this.baseReg3 = baseReg3;
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		instruction.InternalSetCodeNoCheck(code);
		int num = (int)(decoder.state.reg + decoder.state.zs.extraRegisterBase);
		instruction.Op0Register = num + baseReg1;
		instruction.Op2Register = (Register)((int)decoder.state.vvvv + (int)baseReg3);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem_VSIB(ref instruction, vsibIndex, TupleType.N1);
		if (decoder.invalidCheckMask != 0)
		{
			uint num2 = (uint)(instruction.MemoryIndex - 77) % 32u;
			if (num == (int)num2 || decoder.state.vvvv == num2 || num == (int)decoder.state.vvvv)
			{
				decoder.SetInvalidInstruction();
			}
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_Gv_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_Gv_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		instruction.Op1Register = (Register)((int)decoder.state.vvvv + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op2Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_Ev_Gv : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_Ev_Gv(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		instruction.Op2Register = (Register)((int)decoder.state.vvvv + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Hv_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Hv_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)decoder.state.vvvv + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Hv_Ed_Id : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Hv_Ed_Id(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			instruction.Op0Register = (Register)(decoder.state.vvvv + 53);
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			instruction.Op0Register = (Register)(decoder.state.vvvv + 37);
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase + 37);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate32;
		instruction.Immediate32 = decoder.ReadUInt32();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_GvM_VX_Ib : OpCodeHandlerModRM
{
	private readonly Register baseReg;

	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_GvM_VX_Ib(Register baseReg, Code code32, Code code64)
	{
		this.baseReg = baseReg;
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op0Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op1Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)baseReg);
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_Ev_Ib : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_Ev_Ib(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_Ev_Id : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_Ev_Id(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
		}
		else
		{
			instruction.Op1Kind = OpKind.Memory;
			decoder.ReadOpMem(ref instruction);
		}
		instruction.Op2Kind = OpKind.Immediate32;
		instruction.Immediate32 = decoder.ReadUInt32();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VT_SIBMEM : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VT_SIBMEM(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 241);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMemSib(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_SIBMEM_VT : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_SIBMEM_VT(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Register = (Register)(decoder.state.reg + 241);
		if (decoder.state.mod == 3)
		{
			decoder.SetInvalidInstruction();
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMemSib(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VT : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VT(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 241);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VT_RT_HT : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_VT_RT_HT(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && (decoder.state.vvvv > 7 || decoder.state.zs.extraRegisterBase != 0))
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 241);
		instruction.Op2Register = (Register)((decoder.state.vvvv & 7) + 241);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)(decoder.state.rm + 241);
			if (decoder.invalidCheckMask != 0 && (decoder.state.zs.extraBaseRegisterBase != 0 || decoder.state.reg == decoder.state.vvvv || decoder.state.reg == decoder.state.rm || decoder.state.rm == decoder.state.vvvv))
			{
				decoder.SetInvalidInstruction();
			}
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gq_HK_RK : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_Gq_HK_RK(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && decoder.state.vvvv > 7)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + decoder.state.zs.extraRegisterBase + 53);
		instruction.Op1Register = (Register)((decoder.state.vvvv & 7) + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op2Register = (Register)(decoder.state.rm + 173);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_VK_R_Ib : OpCodeHandlerModRM
{
	private readonly Code code;

	private readonly Register gpr;

	public OpCodeHandler_VEX_VK_R_Ib(Code code, Register gpr)
	{
		this.code = code;
		this.gpr = gpr;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (((decoder.state.vvvv_invalidCheck | decoder.state.zs.extraRegisterBase) & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op0Register = (Register)(decoder.state.reg + 173);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)gpr);
		}
		else
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op2Kind = OpKind.Immediate8;
		instruction.InternalImmediate8 = decoder.ReadByte();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_K_Jb : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_K_Jb(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		decoder.state.zs.flags |= StateFlags.BranchImm8;
		if (decoder.invalidCheckMask != 0 && decoder.state.vvvv > 7)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op0Register = (Register)((decoder.state.vvvv & 7) + 173);
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Kind = OpKind.NearBranch64;
		instruction.NearBranch64 = (ulong)(sbyte)decoder.state.modrm + decoder.GetCurrentInstructionPointer64();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_K_Jz : OpCodeHandlerModRM
{
	private readonly Code code;

	public OpCodeHandler_VEX_K_Jz(Code code)
	{
		this.code = code;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if (decoder.invalidCheckMask != 0 && decoder.state.vvvv > 7)
		{
			decoder.SetInvalidInstruction();
		}
		instruction.Op0Register = (Register)((decoder.state.vvvv & 7) + 173);
		instruction.InternalSetCodeNoCheck(code);
		instruction.Op1Kind = OpKind.NearBranch64;
		uint num = decoder.state.modrm | (decoder.ReadByte() << 8) | (decoder.ReadByte() << 16) | (decoder.ReadByte() << 24);
		instruction.NearBranch64 = (ulong)(int)num + decoder.GetCurrentInstructionPointer64();
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Gv_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Gv_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		instruction.Op0Register = (Register)((int)(decoder.state.reg + decoder.state.zs.extraRegisterBase) + (int)register);
		if (decoder.state.mod == 3)
		{
			instruction.Op1Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op1Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class OpCodeHandler_VEX_Ev : OpCodeHandlerModRM
{
	private readonly Code code32;

	private readonly Code code64;

	public OpCodeHandler_VEX_Ev(Code code32, Code code64)
	{
		this.code32 = code32;
		this.code64 = code64;
	}

	public override void Decode(Decoder decoder, ref Instruction instruction)
	{
		if ((decoder.state.vvvv_invalidCheck & decoder.invalidCheckMask) != 0)
		{
			decoder.SetInvalidInstruction();
		}
		Register register;
		if (((uint)decoder.state.zs.flags & decoder.is64bMode_and_W) != 0)
		{
			instruction.InternalSetCodeNoCheck(code64);
			register = Register.RAX;
		}
		else
		{
			instruction.InternalSetCodeNoCheck(code32);
			register = Register.EAX;
		}
		if (decoder.state.mod == 3)
		{
			instruction.Op0Register = (Register)((int)(decoder.state.rm + decoder.state.zs.extraBaseRegisterBase) + (int)register);
			return;
		}
		instruction.Op0Kind = OpKind.Memory;
		decoder.ReadOpMem(ref instruction);
	}
}


internal enum SerializedDataKind : byte
{
	HandlerReference,
	ArrayReference
}


using Iced.Intel.DecoderInternal;

internal abstract class OpCodeHandlerReader
{
	public abstract int ReadHandlers(ref TableDeserializer deserializer, OpCodeHandler?[] result, int resultIndex);
}


using Iced.Intel.DecoderInternal;

internal readonly struct HandlerInfo
{
	public readonly OpCodeHandler? handler;

	public readonly OpCodeHandler?[]? handlers;

	public HandlerInfo(OpCodeHandler handler)
	{
		this.handler = handler;
		handlers = null;
	}

	public HandlerInfo(OpCodeHandler?[] handlers)
	{
		handler = null;
		this.handlers = handlers;
	}
}


using System;
using System.Collections.Generic;
using Iced.Intel;
using Iced.Intel.DecoderInternal;
using Iced.Intel.Internal;

internal ref struct TableDeserializer
{
	private DataReader reader;

	private readonly OpCodeHandlerReader handlerReader;

	private readonly List<HandlerInfo> idToHandler;

	private readonly OpCodeHandler[] handlerArray;

	public TableDeserializer(OpCodeHandlerReader handlerReader, int maxIds, ReadOnlySpan<byte> data)
	{
		this.handlerReader = handlerReader;
		reader = new DataReader(data);
		idToHandler = new List<HandlerInfo>(maxIds);
		handlerArray = new OpCodeHandler[1];
	}

	public void Deserialize()
	{
		while (reader.CanRead)
		{
			switch ((SerializedDataKind)reader.ReadByte())
			{
			case SerializedDataKind.HandlerReference:
				idToHandler.Add(new HandlerInfo(ReadHandler()));
				break;
			case SerializedDataKind.ArrayReference:
				idToHandler.Add(new HandlerInfo(ReadHandlers((int)reader.ReadCompressedUInt32())));
				break;
			default:
				throw new InvalidOperationException();
			}
		}
		if (reader.CanRead)
		{
			throw new InvalidOperationException();
		}
	}

	public LegacyOpCodeHandlerKind ReadLegacyOpCodeHandlerKind()
	{
		return (LegacyOpCodeHandlerKind)reader.ReadByte();
	}

	public VexOpCodeHandlerKind ReadVexOpCodeHandlerKind()
	{
		return (VexOpCodeHandlerKind)reader.ReadByte();
	}

	public EvexOpCodeHandlerKind ReadEvexOpCodeHandlerKind()
	{
		return (EvexOpCodeHandlerKind)reader.ReadByte();
	}

	public Code ReadCode()
	{
		return (Code)reader.ReadCompressedUInt32();
	}

	public Register ReadRegister()
	{
		return (Register)reader.ReadByte();
	}

	public DecoderOptions ReadDecoderOptions()
	{
		return (DecoderOptions)reader.ReadCompressedUInt32();
	}

	public HandlerFlags ReadHandlerFlags()
	{
		return (HandlerFlags)reader.ReadCompressedUInt32();
	}

	public LegacyHandlerFlags ReadLegacyHandlerFlags()
	{
		return (LegacyHandlerFlags)reader.ReadCompressedUInt32();
	}

	public TupleType ReadTupleType()
	{
		return (TupleType)reader.ReadByte();
	}

	public bool ReadBoolean()
	{
		return reader.ReadByte() != 0;
	}

	public int ReadInt32()
	{
		return (int)reader.ReadCompressedUInt32();
	}

	public OpCodeHandler ReadHandler()
	{
		return ReadHandlerOrNull() ?? throw new InvalidOperationException();
	}

	public OpCodeHandler? ReadHandlerOrNull()
	{
		if (handlerReader.ReadHandlers(ref this, handlerArray, 0) != 1)
		{
			throw new InvalidOperationException();
		}
		return handlerArray[0];
	}

	public OpCodeHandler?[] ReadHandlers(int count)
	{
		OpCodeHandler[] array = new OpCodeHandler[count];
		int num;
		for (int i = 0; i < array.Length; i += num)
		{
			num = handlerReader.ReadHandlers(ref this, array, i);
			if (num <= 0 || (uint)(i + num) > (uint)array.Length)
			{
				throw new InvalidOperationException();
			}
		}
		return array;
	}

	public OpCodeHandler ReadHandlerReference()
	{
		uint index = reader.ReadByte();
		return idToHandler[(int)index].handler ?? throw new InvalidOperationException();
	}

	public OpCodeHandler[] ReadArrayReference(uint kind)
	{
		if (reader.ReadByte() != kind)
		{
			throw new InvalidOperationException();
		}
		return GetTable(reader.ReadByte());
	}

	public OpCodeHandler[] GetTable(uint index)
	{
		return idToHandler[(int)index].handlers ?? throw new InvalidOperationException();
	}
}


internal enum VexOpCodeHandlerKind : byte
{
	Invalid,
	Invalid2,
	Dup,
	Invalid_NoModRM,
	Bitness_DontReadModRM,
	HandlerReference,
	ArrayReference,
	RM,
	Group,
	W,
	MandatoryPrefix2_1,
	MandatoryPrefix2_4,
	MandatoryPrefix2_NoModRM,
	VectorLength_NoModRM,
	VectorLength,
	Ed_V_Ib,
	Ev_VX,
	G_VK,
	Gv_Ev_Gv,
	Gv_Ev_Ib,
	Gv_Ev_Id,
	Gv_GPR_Ib,
	Gv_Gv_Ev,
	Gv_RX,
	Gv_W,
	GvM_VX_Ib,
	HRIb,
	Hv_Ed_Id,
	Hv_Ev,
	M,
	MHV,
	M_VK,
	MV,
	rDI_VX_RX,
	RdRq,
	Simple,
	VHEv,
	VHEvIb,
	VHIs4W,
	VHIs5W,
	VHM,
	VHW_2,
	VHW_3,
	VHW_4,
	VHWIb_2,
	VHWIb_4,
	VHWIs4,
	VHWIs5,
	VK_HK_RK,
	VK_R,
	VK_RK,
	VK_RK_Ib,
	VK_WK,
	VM,
	VW_2,
	VW_3,
	VWH,
	VWIb_2,
	VWIb_3,
	VX_Ev,
	VX_VSIB_HX,
	WHV,
	WV,
	WVIb,
	VT_SIBMEM,
	SIBMEM_VT,
	VT,
	VT_RT_HT,
	Group8x64,
	Bitness,
	Null,
	Options_DontReadModRM,
	Gq_HK_RK,
	VK_R_Ib,
	Gv_Ev,
	Ev,
	K_Jb,
	K_Jz
}


using System;
using Iced.Intel;
using Iced.Intel.DecoderInternal;

internal sealed class VexOpCodeHandlerReader : OpCodeHandlerReader
{
	public override int ReadHandlers(ref TableDeserializer deserializer, OpCodeHandler?[] result, int resultIndex)
	{
		ref OpCodeHandler reference = ref result[resultIndex];
		switch (deserializer.ReadVexOpCodeHandlerKind())
		{
		case VexOpCodeHandlerKind.Invalid:
			reference = OpCodeHandler_Invalid.Instance;
			return 1;
		case VexOpCodeHandlerKind.Invalid2:
			result[resultIndex] = OpCodeHandler_Invalid.Instance;
			result[resultIndex + 1] = OpCodeHandler_Invalid.Instance;
			return 2;
		case VexOpCodeHandlerKind.Dup:
		{
			int num = deserializer.ReadInt32();
			OpCodeHandler opCodeHandler = deserializer.ReadHandlerOrNull();
			for (int i = 0; i < num; i++)
			{
				result[resultIndex + i] = opCodeHandler;
			}
			return num;
		}
		case VexOpCodeHandlerKind.Null:
			reference = null;
			return 1;
		case VexOpCodeHandlerKind.Invalid_NoModRM:
			reference = OpCodeHandler_Invalid_NoModRM.Instance;
			return 1;
		case VexOpCodeHandlerKind.Bitness:
			reference = new OpCodeHandler_Bitness(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.Bitness_DontReadModRM:
			reference = new OpCodeHandler_Bitness_DontReadModRM(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.HandlerReference:
			reference = deserializer.ReadHandlerReference();
			return 1;
		case VexOpCodeHandlerKind.ArrayReference:
			throw new InvalidOperationException();
		case VexOpCodeHandlerKind.RM:
			reference = new OpCodeHandler_RM(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.Group:
			reference = new OpCodeHandler_Group(deserializer.ReadArrayReference(6u));
			return 1;
		case VexOpCodeHandlerKind.Group8x64:
			reference = new OpCodeHandler_Group8x64(deserializer.ReadArrayReference(6u), deserializer.ReadArrayReference(6u));
			return 1;
		case VexOpCodeHandlerKind.W:
			reference = new OpCodeHandler_W(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.MandatoryPrefix2_1:
			reference = new OpCodeHandler_MandatoryPrefix2(deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.MandatoryPrefix2_4:
			reference = new OpCodeHandler_MandatoryPrefix2(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.MandatoryPrefix2_NoModRM:
			reference = new OpCodeHandler_MandatoryPrefix2_NoModRM(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.VectorLength_NoModRM:
			reference = new OpCodeHandler_VectorLength_NoModRM_VEX(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.VectorLength:
			reference = new OpCodeHandler_VectorLength_VEX(deserializer.ReadHandler(), deserializer.ReadHandler());
			return 1;
		case VexOpCodeHandlerKind.Ed_V_Ib:
		{
			Code code;
			reference = new OpCodeHandler_VEX_Ed_V_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Ev_VX:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Ev_VX(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.G_VK:
			reference = new OpCodeHandler_VEX_G_VK(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case VexOpCodeHandlerKind.Gv_Ev_Gv:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Gv_Ev_Gv(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Gv_Ev_Ib:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Gv_Ev_Ib(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Gv_Ev_Id:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Gv_Ev_Id(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Gv_GPR_Ib:
		{
			Code code;
			reference = new OpCodeHandler_VEX_Gv_GPR_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Gv_Gv_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Gv_Gv_Ev(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Gv_RX:
		{
			Code code;
			reference = new OpCodeHandler_VEX_Gv_RX(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Gv_W:
		{
			Code code;
			reference = new OpCodeHandler_VEX_Gv_W(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.GvM_VX_Ib:
		{
			Code code;
			reference = new OpCodeHandler_VEX_GvM_VX_Ib(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.HRIb:
			reference = new OpCodeHandler_VEX_HRIb(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.Hv_Ed_Id:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Hv_Ed_Id(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Hv_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Hv_Ev(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.M:
			reference = new OpCodeHandler_VEX_M(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.MHV:
			reference = new OpCodeHandler_VEX_MHV(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.M_VK:
			reference = new OpCodeHandler_VEX_M_VK(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.MV:
			reference = new OpCodeHandler_VEX_MV(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.rDI_VX_RX:
			reference = new OpCodeHandler_VEX_rDI_VX_RX(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.RdRq:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_RdRq(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Simple:
			reference = new OpCodeHandler_VEX_Simple(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHEv:
		{
			Code code;
			reference = new OpCodeHandler_VEX_VHEv(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.VHEvIb:
		{
			Code code;
			reference = new OpCodeHandler_VEX_VHEvIb(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.VHIs4W:
			reference = new OpCodeHandler_VEX_VHIs4W(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHIs5W:
			reference = new OpCodeHandler_VEX_VHIs5W(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHM:
			reference = new OpCodeHandler_VEX_VHM(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHW_2:
			reference = new OpCodeHandler_VEX_VHW(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHW_3:
			reference = new OpCodeHandler_VEX_VHW(deserializer.ReadRegister(), deserializer.ReadCode(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHW_4:
			reference = new OpCodeHandler_VEX_VHW(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHWIb_2:
			reference = new OpCodeHandler_VEX_VHWIb(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHWIb_4:
			reference = new OpCodeHandler_VEX_VHWIb(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHWIs4:
			reference = new OpCodeHandler_VEX_VHWIs4(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VHWIs5:
			reference = new OpCodeHandler_VEX_VHWIs5(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VK_HK_RK:
			reference = new OpCodeHandler_VEX_VK_HK_RK(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VK_R:
			reference = new OpCodeHandler_VEX_VK_R(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case VexOpCodeHandlerKind.VK_RK:
			reference = new OpCodeHandler_VEX_VK_RK(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VK_RK_Ib:
			reference = new OpCodeHandler_VEX_VK_RK_Ib(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VK_WK:
			reference = new OpCodeHandler_VEX_VK_WK(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VM:
			reference = new OpCodeHandler_VEX_VM(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VW_2:
			reference = new OpCodeHandler_VEX_VW(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VW_3:
			reference = new OpCodeHandler_VEX_VW(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VWH:
			reference = new OpCodeHandler_VEX_VWH(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VWIb_2:
			reference = new OpCodeHandler_VEX_VWIb(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VWIb_3:
		{
			Code code;
			reference = new OpCodeHandler_VEX_VWIb(deserializer.ReadRegister(), code = deserializer.ReadCode(), code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.VX_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_VX_Ev(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.VX_VSIB_HX:
			reference = new OpCodeHandler_VEX_VX_VSIB_HX(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.WHV:
			reference = new OpCodeHandler_VEX_WHV(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.WV:
			reference = new OpCodeHandler_VEX_WV(deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.WVIb:
			reference = new OpCodeHandler_VEX_WVIb(deserializer.ReadRegister(), deserializer.ReadRegister(), deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VT_SIBMEM:
			reference = new OpCodeHandler_VEX_VT_SIBMEM(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.SIBMEM_VT:
			reference = new OpCodeHandler_VEX_SIBMEM_VT(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VT:
			reference = new OpCodeHandler_VEX_VT(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VT_RT_HT:
			reference = new OpCodeHandler_VEX_VT_RT_HT(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.Options_DontReadModRM:
			reference = new OpCodeHandler_Options_DontReadModRM(deserializer.ReadHandler(), deserializer.ReadHandler(), deserializer.ReadDecoderOptions());
			return 1;
		case VexOpCodeHandlerKind.Gq_HK_RK:
			reference = new OpCodeHandler_VEX_Gq_HK_RK(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.VK_R_Ib:
			reference = new OpCodeHandler_VEX_VK_R_Ib(deserializer.ReadCode(), deserializer.ReadRegister());
			return 1;
		case VexOpCodeHandlerKind.Gv_Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Gv_Ev(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.Ev:
		{
			Code code = deserializer.ReadCode();
			reference = new OpCodeHandler_VEX_Ev(code, code + 1);
			return 1;
		}
		case VexOpCodeHandlerKind.K_Jb:
			reference = new OpCodeHandler_VEX_K_Jb(deserializer.ReadCode());
			return 1;
		case VexOpCodeHandlerKind.K_Jz:
			reference = new OpCodeHandler_VEX_K_Jz(deserializer.ReadCode());
			return 1;
		default:
			throw new InvalidOperationException();
		}
	}
}


using System;
using System.Collections.Generic;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class Block
{
	public readonly CodeWriterImpl CodeWriter;

	public readonly ulong RIP;

	public readonly List<RelocInfo>? relocInfos;

	private Instr[] instructions;

	private readonly List<BlockData> dataList;

	private readonly ulong alignment;

	private readonly List<BlockData> validData;

	private ulong validDataAddress;

	private ulong validDataAddressAligned;

	public Instr[] Instructions => instructions;

	public bool CanAddRelocInfos => relocInfos != null;

	public Block(BlockEncoder blockEncoder, CodeWriter codeWriter, ulong rip, List<RelocInfo>? relocInfos)
	{
		CodeWriter = new CodeWriterImpl(codeWriter);
		RIP = rip;
		this.relocInfos = relocInfos;
		instructions = Array2.Empty<Instr>();
		dataList = new List<BlockData>();
		alignment = (uint)blockEncoder.Bitness / 8u;
		validData = new List<BlockData>();
	}

	internal void SetInstructions(Instr[] instructions)
	{
		this.instructions = instructions;
	}

	public BlockData AllocPointerLocation()
	{
		BlockData blockData = new BlockData
		{
			IsValid = true
		};
		dataList.Add(blockData);
		return blockData;
	}

	public void InitializeData()
	{
		ulong num;
		if (Instructions.Length != 0)
		{
			Instr instr = Instructions[Instructions.Length - 1];
			num = instr.IP + instr.Size;
		}
		else
		{
			num = RIP;
		}
		validDataAddress = num;
		ulong num2 = (validDataAddressAligned = (num + alignment - 1) & ~(alignment - 1));
		foreach (BlockData data in dataList)
		{
			if (data.IsValid)
			{
				data.__dont_use_address = num2;
				data.__dont_use_address_initd = true;
				validData.Add(data);
				num2 += alignment;
			}
		}
	}

	public void WriteData()
	{
		if (validData.Count == 0)
		{
			return;
		}
		CodeWriterImpl codeWriter = CodeWriter;
		int num = (int)(validDataAddressAligned - validDataAddress);
		for (int i = 0; i < num; i++)
		{
			codeWriter.WriteByte(204);
		}
		List<RelocInfo> list = relocInfos;
		if ((int)alignment == 8)
		{
			foreach (BlockData validDatum in validData)
			{
				list?.Add(new RelocInfo(RelocKind.Offset64, validDatum.Address));
				uint num2 = (uint)validDatum.Data;
				codeWriter.WriteByte((byte)num2);
				codeWriter.WriteByte((byte)(num2 >> 8));
				codeWriter.WriteByte((byte)(num2 >> 16));
				codeWriter.WriteByte((byte)(num2 >> 24));
				num2 = (uint)(validDatum.Data >> 32);
				codeWriter.WriteByte((byte)num2);
				codeWriter.WriteByte((byte)(num2 >> 8));
				codeWriter.WriteByte((byte)(num2 >> 16));
				codeWriter.WriteByte((byte)(num2 >> 24));
			}
			return;
		}
		throw new InvalidOperationException();
	}

	public void AddRelocInfo(RelocInfo relocInfo)
	{
		relocInfos?.Add(relocInfo);
	}
}


using Iced.Intel;

internal sealed class BlockData
{
	internal ulong __dont_use_address;

	internal bool __dont_use_address_initd;

	public bool IsValid;

	public ulong Data;

	public ulong Address
	{
		get
		{
			if (!IsValid)
			{
				ThrowHelper.ThrowInvalidOperationException();
			}
			if (!__dont_use_address_initd)
			{
				ThrowHelper.ThrowInvalidOperationException();
			}
			return __dont_use_address;
		}
	}
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class CallInstr : Instr
{
	private readonly byte bitness;

	private Instruction instruction;

	private TargetInstr targetInstr;

	private readonly byte origInstructionSize;

	private BlockData pointerData;

	private bool useOrigInstruction;

	public CallInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		bitness = (byte)blockEncoder.Bitness;
		this.instruction = instruction;
		Instruction instruction2 = instruction;
		instruction2.NearBranch64 = 0uL;
		origInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		if (!blockEncoder.FixBranches)
		{
			Size = origInstructionSize;
			useOrigInstruction = true;
		}
		else if (blockEncoder.Bitness == 64)
		{
			Size = Math.Max(origInstructionSize, 6u);
		}
		else
		{
			Size = origInstructionSize;
		}
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
		targetInstr = blockEncoder.GetTarget(instruction.NearBranchTarget);
	}

	public override bool Optimize(ulong gained)
	{
		return TryOptimize(gained);
	}

	private bool TryOptimize(ulong gained)
	{
		if (Done || useOrigInstruction)
		{
			Done = true;
			return false;
		}
		bool flag = bitness != 64 || targetInstr.IsInBlock(Block);
		if (!flag)
		{
			ulong address = targetInstr.GetAddress();
			ulong num = IP + origInstructionSize;
			long diff = (long)(address - num);
			diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
			flag = int.MinValue <= diff && diff <= int.MaxValue;
		}
		if (flag)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			Size = origInstructionSize;
			useOrigInstruction = true;
			Done = true;
			return true;
		}
		if (pointerData == null)
		{
			pointerData = Block.AllocPointerLocation();
		}
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		uint size;
		if (useOrigInstruction)
		{
			isOriginalInstruction = true;
			instruction.NearBranch64 = targetInstr.GetAddress();
			if (!encoder.TryEncode(in instruction, IP, out size, out string errorMessage))
			{
				constantOffsets = default(ConstantOffsets);
				return Instr.CreateErrorMessage(errorMessage, in instruction);
			}
			constantOffsets = encoder.GetConstantOffsets();
			return null;
		}
		isOriginalInstruction = false;
		constantOffsets = default(ConstantOffsets);
		pointerData.Data = targetInstr.GetAddress();
		string text = EncodeBranchToPointerData(encoder, isCall: true, IP, pointerData, out size, Size);
		if (text != null)
		{
			return Instr.CreateErrorMessage(text, in instruction);
		}
		return null;
	}
}


using Iced.Intel;

internal sealed class CodeWriterImpl : CodeWriter
{
	public uint BytesWritten;

	private readonly CodeWriter codeWriter;

	public CodeWriterImpl(CodeWriter codeWriter)
	{
		if (codeWriter == null)
		{
			ThrowHelper.ThrowArgumentNullException_codeWriter();
		}
		this.codeWriter = codeWriter;
	}

	public override void WriteByte(byte value)
	{
		BytesWritten++;
		codeWriter.WriteByte(value);
	}
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal abstract class Instr
{
	public readonly Block Block;

	public uint Size;

	public ulong IP;

	public readonly ulong OrigIP;

	public bool Done;

	protected const uint CallOrJmpPointerDataInstructionSize64 = 6u;

	protected Instr(Block block, ulong origIp)
	{
		OrigIP = origIp;
		Block = block;
	}

	public abstract void Initialize(BlockEncoder blockEncoder);

	public abstract bool Optimize(ulong gained);

	public abstract string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction);

	protected static string CreateErrorMessage(string errorMessage, in Instruction instruction)
	{
		return $"{errorMessage} : 0x{instruction.IP:X} {instruction.ToString()}";
	}

	public static Instr Create(BlockEncoder blockEncoder, Block block, in Instruction instruction)
	{
		switch (instruction.Code)
		{
		case Code.Jo_rel8_16:
		case Code.Jo_rel8_32:
		case Code.Jo_rel8_64:
		case Code.Jno_rel8_16:
		case Code.Jno_rel8_32:
		case Code.Jno_rel8_64:
		case Code.Jb_rel8_16:
		case Code.Jb_rel8_32:
		case Code.Jb_rel8_64:
		case Code.Jae_rel8_16:
		case Code.Jae_rel8_32:
		case Code.Jae_rel8_64:
		case Code.Je_rel8_16:
		case Code.Je_rel8_32:
		case Code.Je_rel8_64:
		case Code.Jne_rel8_16:
		case Code.Jne_rel8_32:
		case Code.Jne_rel8_64:
		case Code.Jbe_rel8_16:
		case Code.Jbe_rel8_32:
		case Code.Jbe_rel8_64:
		case Code.Ja_rel8_16:
		case Code.Ja_rel8_32:
		case Code.Ja_rel8_64:
		case Code.Js_rel8_16:
		case Code.Js_rel8_32:
		case Code.Js_rel8_64:
		case Code.Jns_rel8_16:
		case Code.Jns_rel8_32:
		case Code.Jns_rel8_64:
		case Code.Jp_rel8_16:
		case Code.Jp_rel8_32:
		case Code.Jp_rel8_64:
		case Code.Jnp_rel8_16:
		case Code.Jnp_rel8_32:
		case Code.Jnp_rel8_64:
		case Code.Jl_rel8_16:
		case Code.Jl_rel8_32:
		case Code.Jl_rel8_64:
		case Code.Jge_rel8_16:
		case Code.Jge_rel8_32:
		case Code.Jge_rel8_64:
		case Code.Jle_rel8_16:
		case Code.Jle_rel8_32:
		case Code.Jle_rel8_64:
		case Code.Jg_rel8_16:
		case Code.Jg_rel8_32:
		case Code.Jg_rel8_64:
		case Code.Jo_rel16:
		case Code.Jo_rel32_32:
		case Code.Jo_rel32_64:
		case Code.Jno_rel16:
		case Code.Jno_rel32_32:
		case Code.Jno_rel32_64:
		case Code.Jb_rel16:
		case Code.Jb_rel32_32:
		case Code.Jb_rel32_64:
		case Code.Jae_rel16:
		case Code.Jae_rel32_32:
		case Code.Jae_rel32_64:
		case Code.Je_rel16:
		case Code.Je_rel32_32:
		case Code.Je_rel32_64:
		case Code.Jne_rel16:
		case Code.Jne_rel32_32:
		case Code.Jne_rel32_64:
		case Code.Jbe_rel16:
		case Code.Jbe_rel32_32:
		case Code.Jbe_rel32_64:
		case Code.Ja_rel16:
		case Code.Ja_rel32_32:
		case Code.Ja_rel32_64:
		case Code.Js_rel16:
		case Code.Js_rel32_32:
		case Code.Js_rel32_64:
		case Code.Jns_rel16:
		case Code.Jns_rel32_32:
		case Code.Jns_rel32_64:
		case Code.Jp_rel16:
		case Code.Jp_rel32_32:
		case Code.Jp_rel32_64:
		case Code.Jnp_rel16:
		case Code.Jnp_rel32_32:
		case Code.Jnp_rel32_64:
		case Code.Jl_rel16:
		case Code.Jl_rel32_32:
		case Code.Jl_rel32_64:
		case Code.Jge_rel16:
		case Code.Jge_rel32_32:
		case Code.Jge_rel32_64:
		case Code.Jle_rel16:
		case Code.Jle_rel32_32:
		case Code.Jle_rel32_64:
		case Code.Jg_rel16:
		case Code.Jg_rel32_32:
		case Code.Jg_rel32_64:
		case Code.VEX_KNC_Jkzd_kr_rel8_64:
		case Code.VEX_KNC_Jknzd_kr_rel8_64:
		case Code.VEX_KNC_Jkzd_kr_rel32_64:
		case Code.VEX_KNC_Jknzd_kr_rel32_64:
			return new JccInstr(blockEncoder, block, in instruction);
		case Code.Loopne_rel8_16_CX:
		case Code.Loopne_rel8_32_CX:
		case Code.Loopne_rel8_16_ECX:
		case Code.Loopne_rel8_32_ECX:
		case Code.Loopne_rel8_64_ECX:
		case Code.Loopne_rel8_16_RCX:
		case Code.Loopne_rel8_64_RCX:
		case Code.Loope_rel8_16_CX:
		case Code.Loope_rel8_32_CX:
		case Code.Loope_rel8_16_ECX:
		case Code.Loope_rel8_32_ECX:
		case Code.Loope_rel8_64_ECX:
		case Code.Loope_rel8_16_RCX:
		case Code.Loope_rel8_64_RCX:
		case Code.Loop_rel8_16_CX:
		case Code.Loop_rel8_32_CX:
		case Code.Loop_rel8_16_ECX:
		case Code.Loop_rel8_32_ECX:
		case Code.Loop_rel8_64_ECX:
		case Code.Loop_rel8_16_RCX:
		case Code.Loop_rel8_64_RCX:
		case Code.Jcxz_rel8_16:
		case Code.Jcxz_rel8_32:
		case Code.Jecxz_rel8_16:
		case Code.Jecxz_rel8_32:
		case Code.Jecxz_rel8_64:
		case Code.Jrcxz_rel8_16:
		case Code.Jrcxz_rel8_64:
			return new SimpleBranchInstr(blockEncoder, block, in instruction);
		case Code.Call_rel16:
		case Code.Call_rel32_32:
		case Code.Call_rel32_64:
			return new CallInstr(blockEncoder, block, in instruction);
		case Code.Jmp_rel16:
		case Code.Jmp_rel32_32:
		case Code.Jmp_rel32_64:
		case Code.Jmp_rel8_16:
		case Code.Jmp_rel8_32:
		case Code.Jmp_rel8_64:
			return new JmpInstr(blockEncoder, block, in instruction);
		case Code.Xbegin_rel16:
		case Code.Xbegin_rel32:
			return new XbeginInstr(blockEncoder, block, in instruction);
		default:
			if (blockEncoder.Bitness == 64)
			{
				int opCount = instruction.OpCount;
				for (int i = 0; i < opCount; i++)
				{
					if (instruction.GetOpKind(i) == OpKind.Memory)
					{
						if (!instruction.IsIPRelativeMemoryOperand)
						{
							break;
						}
						return new IpRelMemOpInstr(blockEncoder, block, in instruction);
					}
				}
			}
			return new SimpleInstr(blockEncoder, block, in instruction);
		}
	}

	protected string? EncodeBranchToPointerData(Encoder encoder, bool isCall, ulong ip, BlockData pointerData, out uint size, uint minSize)
	{
		if (minSize > int.MaxValue)
		{
			throw new ArgumentOutOfRangeException("minSize");
		}
		Instruction instruction = default(Instruction);
		instruction.Op0Kind = OpKind.Memory;
		instruction.MemoryDisplSize = encoder.Bitness / 8;
		if (encoder.Bitness == 64)
		{
			instruction.InternalSetCodeNoCheck(isCall ? Code.Call_rm64 : Code.Jmp_rm64);
			instruction.MemoryBase = Register.RIP;
			ulong num = ip + 6;
			long num2 = (long)(pointerData.Address - num);
			if (int.MinValue > num2 || num2 > int.MaxValue)
			{
				size = 0u;
				return "Block is too big";
			}
			instruction.MemoryDisplacement64 = pointerData.Address;
			RelocKind relocKind = RelocKind.Offset64;
			if (!encoder.TryEncode(in instruction, ip, out size, out string errorMessage))
			{
				return errorMessage;
			}
			if (Block.CanAddRelocInfos && relocKind != 0)
			{
				ConstantOffsets constantOffsets = encoder.GetConstantOffsets();
				if (!constantOffsets.HasDisplacement)
				{
					return "Internal error: no displ";
				}
				Block.AddRelocInfo(new RelocInfo(relocKind, IP + constantOffsets.DisplacementOffset));
			}
			while (size < minSize)
			{
				size++;
				Block.CodeWriter.WriteByte(144);
			}
			return null;
		}
		throw new InvalidOperationException();
	}

	protected static long CorrectDiff(bool inBlock, long diff, ulong gained)
	{
		if (inBlock && diff >= 0)
		{
			return diff - (long)gained;
		}
		return diff;
	}
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class IpRelMemOpInstr : Instr
{
	private enum InstrKind : byte
	{
		Unchanged,
		Rip,
		Eip,
		Long,
		Uninitialized
	}

	private Instruction instruction;

	private InstrKind instrKind;

	private readonly byte eipInstructionSize;

	private readonly byte ripInstructionSize;

	private TargetInstr targetInstr;

	public IpRelMemOpInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		this.instruction = instruction;
		instrKind = InstrKind.Uninitialized;
		Instruction instruction2 = instruction;
		instruction2.MemoryBase = Register.RIP;
		instruction2.MemoryDisplacement64 = 0uL;
		ripInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, instruction2.IPRelativeMemoryAddress);
		instruction2.MemoryBase = Register.EIP;
		eipInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, instruction2.IPRelativeMemoryAddress);
		Size = eipInstructionSize;
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
		targetInstr = blockEncoder.GetTarget(instruction.IPRelativeMemoryAddress);
	}

	public override bool Optimize(ulong gained)
	{
		return TryOptimize(gained);
	}

	private bool TryOptimize(ulong gained)
	{
		if (instrKind == InstrKind.Unchanged || instrKind == InstrKind.Rip || instrKind == InstrKind.Eip)
		{
			Done = true;
			return false;
		}
		bool flag = targetInstr.IsInBlock(Block);
		ulong address = targetInstr.GetAddress();
		if (!flag)
		{
			ulong num = IP + ripInstructionSize;
			long diff = (long)(address - num);
			diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
			flag = int.MinValue <= diff && diff <= int.MaxValue;
		}
		if (flag)
		{
			Size = ripInstructionSize;
			instrKind = InstrKind.Rip;
			Done = true;
			return true;
		}
		if (address <= uint.MaxValue)
		{
			Size = eipInstructionSize;
			instrKind = InstrKind.Eip;
			Done = true;
			return true;
		}
		instrKind = InstrKind.Long;
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		switch (instrKind)
		{
		case InstrKind.Unchanged:
		case InstrKind.Rip:
		case InstrKind.Eip:
		{
			isOriginalInstruction = true;
			if (instrKind == InstrKind.Rip)
			{
				instruction.MemoryBase = Register.RIP;
			}
			else if (instrKind == InstrKind.Eip)
			{
				instruction.MemoryBase = Register.EIP;
			}
			ulong address = targetInstr.GetAddress();
			instruction.MemoryDisplacement64 = address;
			encoder.TryEncode(in instruction, IP, out uint _, out string errorMessage);
			if (instruction.IPRelativeMemoryAddress != ((instruction.MemoryBase == Register.EIP) ? ((uint)address) : address))
			{
				errorMessage = "Invalid IP relative address";
			}
			if (errorMessage != null)
			{
				constantOffsets = default(ConstantOffsets);
				return Instr.CreateErrorMessage(errorMessage, in instruction);
			}
			constantOffsets = encoder.GetConstantOffsets();
			return null;
		}
		case InstrKind.Long:
			isOriginalInstruction = false;
			constantOffsets = default(ConstantOffsets);
			return "IP relative memory operand is too far away and isn't currently supported. Try to allocate memory close to the original instruction (+/-2GB).";
		default:
			throw new InvalidOperationException();
		}
	}
}


private enum InstrKind : byte
{
	Unchanged,
	Rip,
	Eip,
	Long,
	Uninitialized
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class JccInstr : Instr
{
	private enum InstrKind : byte
	{
		Unchanged,
		Short,
		Near,
		Long,
		Uninitialized
	}

	private Instruction instruction;

	private TargetInstr targetInstr;

	private BlockData pointerData;

	private InstrKind instrKind;

	private readonly byte shortInstructionSize;

	private readonly byte nearInstructionSize;

	private readonly byte longInstructionSize64;

	private static uint GetLongInstructionSize64(in Instruction instruction)
	{
		return 8u;
	}

	public JccInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		this.instruction = instruction;
		instrKind = InstrKind.Uninitialized;
		longInstructionSize64 = (byte)GetLongInstructionSize64(in instruction);
		Instruction instruction2;
		if (!blockEncoder.FixBranches)
		{
			instrKind = InstrKind.Unchanged;
			instruction2 = instruction;
			instruction2.NearBranch64 = 0uL;
			Size = blockEncoder.GetInstructionSize(in instruction2, 0uL);
			return;
		}
		instruction2 = instruction;
		instruction2.InternalSetCodeNoCheck(instruction.Code.ToShortBranch());
		instruction2.NearBranch64 = 0uL;
		shortInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		instruction2 = instruction;
		instruction2.InternalSetCodeNoCheck(instruction.Code.ToNearBranch());
		instruction2.NearBranch64 = 0uL;
		nearInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		if (blockEncoder.Bitness == 64)
		{
			Size = Math.Max(nearInstructionSize, longInstructionSize64);
		}
		else
		{
			Size = nearInstructionSize;
		}
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
		targetInstr = blockEncoder.GetTarget(instruction.NearBranchTarget);
	}

	public override bool Optimize(ulong gained)
	{
		return TryOptimize(gained);
	}

	private bool TryOptimize(ulong gained)
	{
		if (instrKind == InstrKind.Unchanged || instrKind == InstrKind.Short)
		{
			Done = true;
			return false;
		}
		ulong address = targetInstr.GetAddress();
		ulong num = IP + shortInstructionSize;
		long diff = (long)(address - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (-128 <= diff && diff <= 127)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			instrKind = InstrKind.Short;
			Size = shortInstructionSize;
			Done = true;
			return true;
		}
		ulong address2 = targetInstr.GetAddress();
		num = IP + nearInstructionSize;
		diff = (long)(address2 - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (int.MinValue <= diff && diff <= int.MaxValue)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			if (diff < -1920 || diff > 1905)
			{
				Done = true;
			}
			instrKind = InstrKind.Near;
			Size = nearInstructionSize;
			return true;
		}
		if (pointerData == null)
		{
			pointerData = Block.AllocPointerLocation();
		}
		instrKind = InstrKind.Long;
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		uint encodedLength2;
		string errorMessage;
		switch (instrKind)
		{
		case InstrKind.Unchanged:
		case InstrKind.Short:
		case InstrKind.Near:
			isOriginalInstruction = true;
			if (instrKind != 0)
			{
				if (instrKind == InstrKind.Short)
				{
					this.instruction.InternalSetCodeNoCheck(this.instruction.Code.ToShortBranch());
				}
				else
				{
					this.instruction.InternalSetCodeNoCheck(this.instruction.Code.ToNearBranch());
				}
			}
			this.instruction.NearBranch64 = targetInstr.GetAddress();
			if (!encoder.TryEncode(in this.instruction, IP, out encodedLength2, out errorMessage))
			{
				constantOffsets = default(ConstantOffsets);
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			constantOffsets = encoder.GetConstantOffsets();
			return null;
		case InstrKind.Long:
		{
			isOriginalInstruction = false;
			constantOffsets = default(ConstantOffsets);
			pointerData.Data = targetInstr.GetAddress();
			Instruction instruction = default(Instruction);
			instruction.InternalSetCodeNoCheck(ShortBrToNativeBr(this.instruction.Code.NegateConditionCode().ToShortBranch(), encoder.Bitness));
			if (this.instruction.OpCount == 1)
			{
				instruction.Op0Kind = OpKind.NearBranch64;
				instruction.NearBranch64 = IP + longInstructionSize64;
				if (!encoder.TryEncode(in instruction, IP, out uint encodedLength, out errorMessage))
				{
					return Instr.CreateErrorMessage(errorMessage, in this.instruction);
				}
				errorMessage = EncodeBranchToPointerData(encoder, isCall: false, IP + encodedLength, pointerData, out encodedLength2, Size - encodedLength);
				if (errorMessage != null)
				{
					return Instr.CreateErrorMessage(errorMessage, in this.instruction);
				}
				return null;
			}
			throw new InvalidOperationException();
		}
		default:
			throw new InvalidOperationException();
		}
	}

	private static Code ShortBrToNativeBr(Code code, int bitness)
	{
		Code code2;
		Code code3;
		Code code4;
		switch (code)
		{
		case Code.Jo_rel8_16:
		case Code.Jo_rel8_32:
		case Code.Jo_rel8_64:
			code2 = Code.Jo_rel8_16;
			code3 = Code.Jo_rel8_32;
			code4 = Code.Jo_rel8_64;
			break;
		case Code.Jno_rel8_16:
		case Code.Jno_rel8_32:
		case Code.Jno_rel8_64:
			code2 = Code.Jno_rel8_16;
			code3 = Code.Jno_rel8_32;
			code4 = Code.Jno_rel8_64;
			break;
		case Code.Jb_rel8_16:
		case Code.Jb_rel8_32:
		case Code.Jb_rel8_64:
			code2 = Code.Jb_rel8_16;
			code3 = Code.Jb_rel8_32;
			code4 = Code.Jb_rel8_64;
			break;
		case Code.Jae_rel8_16:
		case Code.Jae_rel8_32:
		case Code.Jae_rel8_64:
			code2 = Code.Jae_rel8_16;
			code3 = Code.Jae_rel8_32;
			code4 = Code.Jae_rel8_64;
			break;
		case Code.Je_rel8_16:
		case Code.Je_rel8_32:
		case Code.Je_rel8_64:
			code2 = Code.Je_rel8_16;
			code3 = Code.Je_rel8_32;
			code4 = Code.Je_rel8_64;
			break;
		case Code.Jne_rel8_16:
		case Code.Jne_rel8_32:
		case Code.Jne_rel8_64:
			code2 = Code.Jne_rel8_16;
			code3 = Code.Jne_rel8_32;
			code4 = Code.Jne_rel8_64;
			break;
		case Code.Jbe_rel8_16:
		case Code.Jbe_rel8_32:
		case Code.Jbe_rel8_64:
			code2 = Code.Jbe_rel8_16;
			code3 = Code.Jbe_rel8_32;
			code4 = Code.Jbe_rel8_64;
			break;
		case Code.Ja_rel8_16:
		case Code.Ja_rel8_32:
		case Code.Ja_rel8_64:
			code2 = Code.Ja_rel8_16;
			code3 = Code.Ja_rel8_32;
			code4 = Code.Ja_rel8_64;
			break;
		case Code.Js_rel8_16:
		case Code.Js_rel8_32:
		case Code.Js_rel8_64:
			code2 = Code.Js_rel8_16;
			code3 = Code.Js_rel8_32;
			code4 = Code.Js_rel8_64;
			break;
		case Code.Jns_rel8_16:
		case Code.Jns_rel8_32:
		case Code.Jns_rel8_64:
			code2 = Code.Jns_rel8_16;
			code3 = Code.Jns_rel8_32;
			code4 = Code.Jns_rel8_64;
			break;
		case Code.Jp_rel8_16:
		case Code.Jp_rel8_32:
		case Code.Jp_rel8_64:
			code2 = Code.Jp_rel8_16;
			code3 = Code.Jp_rel8_32;
			code4 = Code.Jp_rel8_64;
			break;
		case Code.Jnp_rel8_16:
		case Code.Jnp_rel8_32:
		case Code.Jnp_rel8_64:
			code2 = Code.Jnp_rel8_16;
			code3 = Code.Jnp_rel8_32;
			code4 = Code.Jnp_rel8_64;
			break;
		case Code.Jl_rel8_16:
		case Code.Jl_rel8_32:
		case Code.Jl_rel8_64:
			code2 = Code.Jl_rel8_16;
			code3 = Code.Jl_rel8_32;
			code4 = Code.Jl_rel8_64;
			break;
		case Code.Jge_rel8_16:
		case Code.Jge_rel8_32:
		case Code.Jge_rel8_64:
			code2 = Code.Jge_rel8_16;
			code3 = Code.Jge_rel8_32;
			code4 = Code.Jge_rel8_64;
			break;
		case Code.Jle_rel8_16:
		case Code.Jle_rel8_32:
		case Code.Jle_rel8_64:
			code2 = Code.Jle_rel8_16;
			code3 = Code.Jle_rel8_32;
			code4 = Code.Jle_rel8_64;
			break;
		case Code.Jg_rel8_16:
		case Code.Jg_rel8_32:
		case Code.Jg_rel8_64:
			code2 = Code.Jg_rel8_16;
			code3 = Code.Jg_rel8_32;
			code4 = Code.Jg_rel8_64;
			break;
		default:
			throw new ArgumentOutOfRangeException("code");
		}
		return bitness switch
		{
			16 => code2, 
			32 => code3, 
			64 => code4, 
			_ => throw new ArgumentOutOfRangeException("bitness"), 
		};
	}
}


private enum InstrKind : byte
{
	Unchanged,
	Short,
	Near,
	Long,
	Uninitialized
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class JmpInstr : Instr
{
	private enum InstrKind : byte
	{
		Unchanged,
		Short,
		Near,
		Long,
		Uninitialized
	}

	private Instruction instruction;

	private TargetInstr targetInstr;

	private BlockData pointerData;

	private InstrKind instrKind;

	private readonly byte shortInstructionSize;

	private readonly byte nearInstructionSize;

	public JmpInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		this.instruction = instruction;
		instrKind = InstrKind.Uninitialized;
		Instruction instruction2;
		if (!blockEncoder.FixBranches)
		{
			instrKind = InstrKind.Unchanged;
			instruction2 = instruction;
			instruction2.NearBranch64 = 0uL;
			Size = blockEncoder.GetInstructionSize(in instruction2, 0uL);
			return;
		}
		instruction2 = instruction;
		instruction2.InternalSetCodeNoCheck(instruction.Code.ToShortBranch());
		instruction2.NearBranch64 = 0uL;
		shortInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		instruction2 = instruction;
		instruction2.InternalSetCodeNoCheck(instruction.Code.ToNearBranch());
		instruction2.NearBranch64 = 0uL;
		nearInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		if (blockEncoder.Bitness == 64)
		{
			Size = Math.Max(nearInstructionSize, 6u);
		}
		else
		{
			Size = nearInstructionSize;
		}
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
		targetInstr = blockEncoder.GetTarget(instruction.NearBranchTarget);
	}

	public override bool Optimize(ulong gained)
	{
		return TryOptimize(gained);
	}

	private bool TryOptimize(ulong gained)
	{
		if (instrKind == InstrKind.Unchanged || instrKind == InstrKind.Short)
		{
			Done = true;
			return false;
		}
		ulong address = targetInstr.GetAddress();
		ulong num = IP + shortInstructionSize;
		long diff = (long)(address - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (-128 <= diff && diff <= 127)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			instrKind = InstrKind.Short;
			Size = shortInstructionSize;
			Done = true;
			return true;
		}
		ulong address2 = targetInstr.GetAddress();
		num = IP + nearInstructionSize;
		diff = (long)(address2 - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (int.MinValue <= diff && diff <= int.MaxValue)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			if (diff < -1920 || diff > 1905)
			{
				Done = true;
			}
			instrKind = InstrKind.Near;
			Size = nearInstructionSize;
			return true;
		}
		if (pointerData == null)
		{
			pointerData = Block.AllocPointerLocation();
		}
		instrKind = InstrKind.Long;
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		uint encodedLength;
		switch (instrKind)
		{
		case InstrKind.Unchanged:
		case InstrKind.Short:
		case InstrKind.Near:
		{
			isOriginalInstruction = true;
			if (instrKind != 0)
			{
				if (instrKind == InstrKind.Short)
				{
					instruction.InternalSetCodeNoCheck(instruction.Code.ToShortBranch());
				}
				else
				{
					instruction.InternalSetCodeNoCheck(instruction.Code.ToNearBranch());
				}
			}
			instruction.NearBranch64 = targetInstr.GetAddress();
			if (!encoder.TryEncode(in instruction, IP, out encodedLength, out string text))
			{
				constantOffsets = default(ConstantOffsets);
				return Instr.CreateErrorMessage(text, in instruction);
			}
			constantOffsets = encoder.GetConstantOffsets();
			return null;
		}
		case InstrKind.Long:
		{
			isOriginalInstruction = false;
			constantOffsets = default(ConstantOffsets);
			pointerData.Data = targetInstr.GetAddress();
			string text = EncodeBranchToPointerData(encoder, isCall: false, IP, pointerData, out encodedLength, Size);
			if (text != null)
			{
				return Instr.CreateErrorMessage(text, in instruction);
			}
			return null;
		}
		default:
			throw new InvalidOperationException();
		}
	}
}


private enum InstrKind : byte
{
	Unchanged,
	Short,
	Near,
	Long,
	Uninitialized
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class SimpleBranchInstr : Instr
{
	private enum InstrKind : byte
	{
		Unchanged,
		Short,
		Near,
		Long,
		Uninitialized
	}

	private Instruction instruction;

	private TargetInstr targetInstr;

	private BlockData pointerData;

	private InstrKind instrKind;

	private readonly byte shortInstructionSize;

	private readonly byte nearInstructionSize;

	private readonly byte longInstructionSize;

	private readonly byte nativeInstructionSize;

	private readonly Code nativeCode;

	public SimpleBranchInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		this.instruction = instruction;
		instrKind = InstrKind.Uninitialized;
		Instruction instruction2;
		if (!blockEncoder.FixBranches)
		{
			instrKind = InstrKind.Unchanged;
			instruction2 = instruction;
			instruction2.NearBranch64 = 0uL;
			Size = blockEncoder.GetInstructionSize(in instruction2, 0uL);
			return;
		}
		instruction2 = instruction;
		instruction2.NearBranch64 = 0uL;
		shortInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		nativeCode = ToNativeBranchCode(instruction.Code, blockEncoder.Bitness);
		if (nativeCode == instruction.Code)
		{
			nativeInstructionSize = shortInstructionSize;
		}
		else
		{
			instruction2 = instruction;
			instruction2.InternalSetCodeNoCheck(nativeCode);
			instruction2.NearBranch64 = 0uL;
			nativeInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		}
		int num;
		switch (blockEncoder.Bitness)
		{
		case 16:
			num = nativeInstructionSize + 2 + 3;
			break;
		case 32:
		case 64:
			num = nativeInstructionSize + 2 + 5;
			break;
		default:
			throw new InvalidOperationException();
		}
		nearInstructionSize = (byte)num;
		if (blockEncoder.Bitness == 64)
		{
			longInstructionSize = (byte)((ulong)(nativeInstructionSize + 2) + 6uL);
			Size = Math.Max(Math.Max(shortInstructionSize, nearInstructionSize), longInstructionSize);
		}
		else
		{
			Size = Math.Max(shortInstructionSize, nearInstructionSize);
		}
	}

	private static Code ToNativeBranchCode(Code code, int bitness)
	{
		Code code2;
		Code code3;
		Code code4;
		switch (code)
		{
		case Code.Loopne_rel8_16_CX:
		case Code.Loopne_rel8_32_CX:
			code2 = Code.Loopne_rel8_16_CX;
			code3 = Code.Loopne_rel8_32_CX;
			code4 = Code.INVALID;
			break;
		case Code.Loopne_rel8_16_ECX:
		case Code.Loopne_rel8_32_ECX:
		case Code.Loopne_rel8_64_ECX:
			code2 = Code.Loopne_rel8_16_ECX;
			code3 = Code.Loopne_rel8_32_ECX;
			code4 = Code.Loopne_rel8_64_ECX;
			break;
		case Code.Loopne_rel8_16_RCX:
		case Code.Loopne_rel8_64_RCX:
			code2 = Code.Loopne_rel8_16_RCX;
			code3 = Code.INVALID;
			code4 = Code.Loopne_rel8_64_RCX;
			break;
		case Code.Loope_rel8_16_CX:
		case Code.Loope_rel8_32_CX:
			code2 = Code.Loope_rel8_16_CX;
			code3 = Code.Loope_rel8_32_CX;
			code4 = Code.INVALID;
			break;
		case Code.Loope_rel8_16_ECX:
		case Code.Loope_rel8_32_ECX:
		case Code.Loope_rel8_64_ECX:
			code2 = Code.Loope_rel8_16_ECX;
			code3 = Code.Loope_rel8_32_ECX;
			code4 = Code.Loope_rel8_64_ECX;
			break;
		case Code.Loope_rel8_16_RCX:
		case Code.Loope_rel8_64_RCX:
			code2 = Code.Loope_rel8_16_RCX;
			code3 = Code.INVALID;
			code4 = Code.Loope_rel8_64_RCX;
			break;
		case Code.Loop_rel8_16_CX:
		case Code.Loop_rel8_32_CX:
			code2 = Code.Loop_rel8_16_CX;
			code3 = Code.Loop_rel8_32_CX;
			code4 = Code.INVALID;
			break;
		case Code.Loop_rel8_16_ECX:
		case Code.Loop_rel8_32_ECX:
		case Code.Loop_rel8_64_ECX:
			code2 = Code.Loop_rel8_16_ECX;
			code3 = Code.Loop_rel8_32_ECX;
			code4 = Code.Loop_rel8_64_ECX;
			break;
		case Code.Loop_rel8_16_RCX:
		case Code.Loop_rel8_64_RCX:
			code2 = Code.Loop_rel8_16_RCX;
			code3 = Code.INVALID;
			code4 = Code.Loop_rel8_64_RCX;
			break;
		case Code.Jcxz_rel8_16:
		case Code.Jcxz_rel8_32:
			code2 = Code.Jcxz_rel8_16;
			code3 = Code.Jcxz_rel8_32;
			code4 = Code.INVALID;
			break;
		case Code.Jecxz_rel8_16:
		case Code.Jecxz_rel8_32:
		case Code.Jecxz_rel8_64:
			code2 = Code.Jecxz_rel8_16;
			code3 = Code.Jecxz_rel8_32;
			code4 = Code.Jecxz_rel8_64;
			break;
		case Code.Jrcxz_rel8_16:
		case Code.Jrcxz_rel8_64:
			code2 = Code.Jrcxz_rel8_16;
			code3 = Code.INVALID;
			code4 = Code.Jrcxz_rel8_64;
			break;
		default:
			throw new ArgumentOutOfRangeException("code");
		}
		return bitness switch
		{
			16 => code2, 
			32 => code3, 
			64 => code4, 
			_ => throw new ArgumentOutOfRangeException("bitness"), 
		};
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
		targetInstr = blockEncoder.GetTarget(instruction.NearBranchTarget);
	}

	public override bool Optimize(ulong gained)
	{
		return TryOptimize(gained);
	}

	private bool TryOptimize(ulong gained)
	{
		if (instrKind == InstrKind.Unchanged || instrKind == InstrKind.Short)
		{
			Done = true;
			return false;
		}
		ulong address = targetInstr.GetAddress();
		ulong num = IP + shortInstructionSize;
		long diff = (long)(address - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (-128 <= diff && diff <= 127)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			instrKind = InstrKind.Short;
			Size = shortInstructionSize;
			Done = true;
			return true;
		}
		ulong address2 = targetInstr.GetAddress();
		num = IP + nearInstructionSize;
		diff = (long)(address2 - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (int.MinValue <= diff && diff <= int.MaxValue)
		{
			if (pointerData != null)
			{
				pointerData.IsValid = false;
			}
			if (diff < -1920 || diff > 1905)
			{
				Done = true;
			}
			instrKind = InstrKind.Near;
			Size = nearInstructionSize;
			return true;
		}
		if (pointerData == null)
		{
			pointerData = Block.AllocPointerLocation();
		}
		instrKind = InstrKind.Long;
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		uint encodedLength2;
		uint encodedLength;
		string errorMessage;
		switch (instrKind)
		{
		case InstrKind.Unchanged:
		case InstrKind.Short:
			isOriginalInstruction = true;
			this.instruction.NearBranch64 = targetInstr.GetAddress();
			if (!encoder.TryEncode(in this.instruction, IP, out encodedLength2, out errorMessage))
			{
				constantOffsets = default(ConstantOffsets);
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			constantOffsets = encoder.GetConstantOffsets();
			return null;
		case InstrKind.Near:
		{
			isOriginalInstruction = false;
			constantOffsets = default(ConstantOffsets);
			Instruction instruction = this.instruction;
			instruction.InternalSetCodeNoCheck(nativeCode);
			instruction.NearBranch64 = IP + nativeInstructionSize + 2;
			if (!encoder.TryEncode(in instruction, IP, out uint num, out errorMessage))
			{
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			instruction = default(Instruction);
			instruction.NearBranch64 = IP + nearInstructionSize;
			Code code;
			switch (encoder.Bitness)
			{
			case 16:
				instruction.InternalSetCodeNoCheck(Code.Jmp_rel8_16);
				code = Code.Jmp_rel16;
				instruction.Op0Kind = OpKind.NearBranch16;
				break;
			case 32:
				instruction.InternalSetCodeNoCheck(Code.Jmp_rel8_32);
				code = Code.Jmp_rel32_32;
				instruction.Op0Kind = OpKind.NearBranch32;
				break;
			case 64:
				instruction.InternalSetCodeNoCheck(Code.Jmp_rel8_64);
				code = Code.Jmp_rel32_64;
				instruction.Op0Kind = OpKind.NearBranch64;
				break;
			default:
				throw new InvalidOperationException();
			}
			if (!encoder.TryEncode(in instruction, IP + num, out encodedLength, out errorMessage))
			{
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			num += encodedLength;
			instruction.InternalSetCodeNoCheck(code);
			instruction.NearBranch64 = targetInstr.GetAddress();
			encoder.TryEncode(in instruction, IP + num, out encodedLength, out errorMessage);
			if (errorMessage != null)
			{
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			return null;
		}
		case InstrKind.Long:
		{
			isOriginalInstruction = false;
			constantOffsets = default(ConstantOffsets);
			pointerData.Data = targetInstr.GetAddress();
			Instruction instruction = this.instruction;
			instruction.InternalSetCodeNoCheck(nativeCode);
			instruction.NearBranch64 = IP + nativeInstructionSize + 2;
			if (!encoder.TryEncode(in instruction, IP, out encodedLength, out errorMessage))
			{
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			uint num = encodedLength;
			instruction = default(Instruction);
			instruction.NearBranch64 = IP + longInstructionSize;
			switch (encoder.Bitness)
			{
			case 16:
				instruction.InternalSetCodeNoCheck(Code.Jmp_rel8_16);
				instruction.Op0Kind = OpKind.NearBranch16;
				break;
			case 32:
				instruction.InternalSetCodeNoCheck(Code.Jmp_rel8_32);
				instruction.Op0Kind = OpKind.NearBranch32;
				break;
			case 64:
				instruction.InternalSetCodeNoCheck(Code.Jmp_rel8_64);
				instruction.Op0Kind = OpKind.NearBranch64;
				break;
			default:
				throw new InvalidOperationException();
			}
			if (!encoder.TryEncode(in instruction, IP + num, out encodedLength, out errorMessage))
			{
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			num += encodedLength;
			errorMessage = EncodeBranchToPointerData(encoder, isCall: false, IP + num, pointerData, out encodedLength2, Size - num);
			if (errorMessage != null)
			{
				return Instr.CreateErrorMessage(errorMessage, in this.instruction);
			}
			return null;
		}
		default:
			throw new InvalidOperationException();
		}
	}
}


private enum InstrKind : byte
{
	Unchanged,
	Short,
	Near,
	Long,
	Uninitialized
}


using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class SimpleInstr : Instr
{
	private Instruction instruction;

	public SimpleInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		Done = true;
		this.instruction = instruction;
		Size = blockEncoder.GetInstructionSize(in instruction, instruction.IP);
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
	}

	public override bool Optimize(ulong gained)
	{
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		isOriginalInstruction = true;
		if (!encoder.TryEncode(in instruction, IP, out uint _, out string errorMessage))
		{
			constantOffsets = default(ConstantOffsets);
			return Instr.CreateErrorMessage(errorMessage, in instruction);
		}
		constantOffsets = encoder.GetConstantOffsets();
		return null;
	}
}


using Iced.Intel.BlockEncoderInternal;

internal readonly struct TargetInstr
{
	private readonly Instr instruction;

	private readonly ulong address;

	public TargetInstr(Instr instruction)
	{
		this.instruction = instruction;
		address = 0uL;
	}

	public TargetInstr(ulong address)
	{
		instruction = null;
		this.address = address;
	}

	public bool IsInBlock(Block block)
	{
		return instruction?.Block == block;
	}

	public ulong GetAddress()
	{
		return instruction?.IP ?? address;
	}
}


using System;
using Iced.Intel;
using Iced.Intel.BlockEncoderInternal;

internal sealed class XbeginInstr : Instr
{
	private enum InstrKind : byte
	{
		Unchanged,
		Rel16,
		Rel32,
		Uninitialized
	}

	private Instruction instruction;

	private TargetInstr targetInstr;

	private InstrKind instrKind;

	private readonly byte shortInstructionSize;

	private readonly byte nearInstructionSize;

	public XbeginInstr(BlockEncoder blockEncoder, Block block, in Instruction instruction)
		: base(block, instruction.IP)
	{
		this.instruction = instruction;
		instrKind = InstrKind.Uninitialized;
		Instruction instruction2;
		if (!blockEncoder.FixBranches)
		{
			instrKind = InstrKind.Unchanged;
			instruction2 = instruction;
			instruction2.NearBranch64 = 0uL;
			Size = blockEncoder.GetInstructionSize(in instruction2, 0uL);
			return;
		}
		instruction2 = instruction;
		instruction2.InternalSetCodeNoCheck(Code.Xbegin_rel16);
		instruction2.NearBranch64 = 0uL;
		shortInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		instruction2 = instruction;
		instruction2.InternalSetCodeNoCheck(Code.Xbegin_rel32);
		instruction2.NearBranch64 = 0uL;
		nearInstructionSize = (byte)blockEncoder.GetInstructionSize(in instruction2, 0uL);
		Size = nearInstructionSize;
	}

	public override void Initialize(BlockEncoder blockEncoder)
	{
		targetInstr = blockEncoder.GetTarget(instruction.NearBranchTarget);
	}

	public override bool Optimize(ulong gained)
	{
		return TryOptimize(gained);
	}

	private bool TryOptimize(ulong gained)
	{
		if (instrKind == InstrKind.Unchanged || instrKind == InstrKind.Rel16)
		{
			Done = true;
			return false;
		}
		ulong address = targetInstr.GetAddress();
		ulong num = IP + shortInstructionSize;
		long diff = (long)(address - num);
		diff = Instr.CorrectDiff(targetInstr.IsInBlock(Block), diff, gained);
		if (-32768 <= diff && diff <= 32767)
		{
			instrKind = InstrKind.Rel16;
			Size = shortInstructionSize;
			return true;
		}
		instrKind = InstrKind.Rel32;
		Size = nearInstructionSize;
		return false;
	}

	public override string? TryEncode(Encoder encoder, out ConstantOffsets constantOffsets, out bool isOriginalInstruction)
	{
		switch (instrKind)
		{
		case InstrKind.Unchanged:
		case InstrKind.Rel16:
		case InstrKind.Rel32:
		{
			isOriginalInstruction = true;
			if (instrKind != 0)
			{
				if (instrKind == InstrKind.Rel16)
				{
					instruction.InternalSetCodeNoCheck(Code.Xbegin_rel16);
				}
				else
				{
					instruction.InternalSetCodeNoCheck(Code.Xbegin_rel32);
				}
			}
			instruction.NearBranch64 = targetInstr.GetAddress();
			if (!encoder.TryEncode(in instruction, IP, out uint _, out string errorMessage))
			{
				constantOffsets = default(ConstantOffsets);
				return Instr.CreateErrorMessage(errorMessage, in instruction);
			}
			constantOffsets = encoder.GetConstantOffsets();
			return null;
		}
		default:
			throw new InvalidOperationException();
		}
	}
}


private enum InstrKind : byte
{
	Unchanged,
	Rel16,
	Rel32,
	Uninitialized
}


using System;

internal static class Array2
{
	private static class EmptyClass<T>
	{
		public static readonly T[] Empty = new T[0];
	}

	public static T[] Empty<T>()
	{
		return EmptyClass<T>.Empty;
	}
}


private static class EmptyClass<T>
{
	public static readonly T[] Empty = new T[0];
}


using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

internal static class string2
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool IsNullOrEmpty([<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>NotNullWhen(false)] string? value)
	{
		return string.IsNullOrEmpty(value);
	}
}


using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

internal static class Debug2
{
	[Conditional("DEBUG")]
	public static void Assert([<b2ffb5d6-6a81-4f20-8e75-7064682f7f7c>DoesNotReturnIf(false)] bool condition)
	{
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class NonVersionableAttribute : Attribute
{
}


using System;
using System.Runtime.CompilerServices;

internal static class ILHelpers
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T TailCallDelegatePtr<T>(IntPtr source)
	{
		//IL_0001: Ignored invalid 'tail' prefix
		return ((delegate*<T>)source)();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static T TailCallFunc<T>(Func<T> func)
	{
		return func();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T? UnboxAnyUnsafe<T>(ref object? box)
	{
		if (default(T) == null)
		{
			return ref Unsafe.As<object?, T?>(ref box);
		}
		return ref (T)box;
	}
}


using System;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;

internal static class Unsafe
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static T Read<T>(void* source)
	{
		return Unsafe.Read<T>(source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static T ReadUnaligned<T>(void* source)
	{
		return Unsafe.ReadUnaligned<T>(source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static T ReadUnaligned<T>(ref byte source)
	{
		return Unsafe.ReadUnaligned<T>(ref source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void Write<T>(void* destination, T value)
	{
		Unsafe.Write(destination, value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void WriteUnaligned<T>(void* destination, T value)
	{
		Unsafe.WriteUnaligned(destination, value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void WriteUnaligned<T>(ref byte destination, T value)
	{
		Unsafe.WriteUnaligned(ref destination, value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void Copy<T>(void* destination, ref T source)
	{
		Unsafe.Write(destination, source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void Copy<T>(ref T destination, void* source)
	{
		destination = Unsafe.Read<T>(source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void* AsPointer<T>(ref T value)
	{
		return Unsafe.AsPointer(ref value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void SkipInit<T>(out T value)
	{
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static int SizeOf<T>()
	{
		return Unsafe.SizeOf<T>();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void CopyBlock(void* destination, void* source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlock(destination, source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void CopyBlock(ref byte destination, ref byte source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlock(ref destination, ref source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void CopyBlockUnaligned(void* destination, void* source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlockUnaligned(destination, source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void CopyBlockUnaligned(ref byte destination, ref byte source, uint byteCount)
	{
		// IL cpblk instruction
		Unsafe.CopyBlockUnaligned(ref destination, ref source, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void InitBlock(void* startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlock(startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void InitBlock(ref byte startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlock(ref startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void InitBlockUnaligned(void* startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlockUnaligned(startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount)
	{
		// IL initblk instruction
		Unsafe.InitBlockUnaligned(ref startAddress, value, byteCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static T As<T>(object o) where T : class
	{
		return (T)o;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static ref T AsRef<T>(void* source)
	{
		return ref *(T*)source;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T AsRef<T>(in T source)
	{
		return ref source;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref TTo As<TFrom, TTo>(ref TFrom source)
	{
		return ref Unsafe.As<TFrom, TTo>(ref source);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Unbox<T>(object box) where T : struct
	{
		return ref (T)box;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Add<T>(ref T source, int elementOffset)
	{
		return ref Unsafe.Add(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void* Add<T>(void* source, int elementOffset)
	{
		return (byte*)source + (nint)elementOffset * (nint)Unsafe.SizeOf<T>();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Add<T>(ref T source, IntPtr elementOffset)
	{
		return ref Unsafe.Add(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T Add<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint elementOffset)
	{
		return ref Unsafe.Add(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T AddByteOffset<T>(ref T source, IntPtr byteOffset)
	{
		return ref Unsafe.AddByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T AddByteOffset<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint byteOffset)
	{
		return ref Unsafe.AddByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Subtract<T>(ref T source, int elementOffset)
	{
		return ref Unsafe.Subtract(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static void* Subtract<T>(void* source, int elementOffset)
	{
		return (byte*)source - (nint)elementOffset * (nint)Unsafe.SizeOf<T>();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T Subtract<T>(ref T source, IntPtr elementOffset)
	{
		return ref Unsafe.Subtract(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T Subtract<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint elementOffset)
	{
		return ref Unsafe.Subtract(ref source, elementOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static ref T SubtractByteOffset<T>(ref T source, IntPtr byteOffset)
	{
		return ref Unsafe.SubtractByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ref T SubtractByteOffset<T>(ref T source, [System.Runtime.Versioning.NonVersionable] nuint byteOffset)
	{
		return ref Unsafe.SubtractByteOffset(ref source, byteOffset);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static IntPtr ByteOffset<T>(ref T origin, ref T target)
	{
		return Unsafe.ByteOffset(target: ref target, origin: ref origin);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static bool AreSame<T>(ref T left, ref T right)
	{
		return Unsafe.AreSame(ref left, ref right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static bool IsAddressGreaterThan<T>(ref T left, ref T right)
	{
		return Unsafe.IsAddressGreaterThan(ref left, ref right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public static bool IsAddressLessThan<T>(ref T left, ref T right)
	{
		return Unsafe.IsAddressLessThan(ref left, ref right);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static bool IsNullRef<T>(ref T source)
	{
		return Unsafe.AsPointer(ref source) == null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[System.Runtime.Versioning.NonVersionable]
	public unsafe static ref T NullRef<T>()
	{
		return ref *(T*)null;
	}
}


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Globalization;
using System.Reflection;
using MonoMod;
using MonoMod.Utils;

internal static class Switches
{
	private delegate bool TryGetSwitchFunc(string @switch, out bool isEnabled);

	private static readonly ConcurrentDictionary<string, object?> switchValues;

	private const string Prefix = "MONOMOD_";

	public const string RunningOnWine = "RunningOnWine";

	public const string DebugClr = "DebugClr";

	public const string JitPath = "JitPath";

	public const string LogRecordHoles = "LogRecordHoles";

	public const string LogInMemory = "LogInMemory";

	public const string LogSpam = "LogSpam";

	public const string LogReplayQueueLength = "LogReplayQueueLength";

	public const string LogToFile = "LogToFile";

	public const string LogToFileFilter = "LogToFileFilter";

	public const string DMDType = "DMDType";

	public const string DMDDebug = "DMDDebug";

	public const string DMDDumpTo = "DMDDumpTo";

	private static readonly Type? tAppContext;

	private static readonly Func<string, object?> dGetData;

	private static readonly MethodInfo? miTryGetSwitch;

	private static readonly TryGetSwitchFunc? dTryGetSwitch;

	static Switches()
	{
		switchValues = new ConcurrentDictionary<string, object>();
		tAppContext = typeof(AppDomain).Assembly.GetType("System.AppContext");
		dGetData = MakeGetDataDelegate();
		miTryGetSwitch = tAppContext?.GetMethod("TryGetSwitch", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
		{
			typeof(string),
			typeof(bool).MakeByRefType()
		}, null);
		dTryGetSwitch = miTryGetSwitch?.TryCreateDelegate<TryGetSwitchFunc>();
		foreach (DictionaryEntry environmentVariable in Environment.GetEnvironmentVariables())
		{
			string text = (string)environmentVariable.Key;
			if (text.StartsWith("MONOMOD_", StringComparison.Ordinal) && environmentVariable.Value != null)
			{
				string key = text.Substring("MONOMOD_".Length);
				switchValues.TryAdd(key, BestEffortParseEnvVar((string)environmentVariable.Value));
			}
		}
	}

	private static object? BestEffortParseEnvVar(string value)
	{
		if (value.Length == 0)
		{
			return null;
		}
		if (int.TryParse(value, NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture, out var result))
		{
			return result;
		}
		if (long.TryParse(value, NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture, out var result2))
		{
			return result2;
		}
		if (int.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out result))
		{
			return result;
		}
		if (long.TryParse(value, NumberStyles.Integer, CultureInfo.InvariantCulture, out result2))
		{
			return result2;
		}
		bool flag;
		switch (value[0])
		{
		case 'F':
		case 'N':
		case 'T':
		case 'Y':
		case 'f':
		case 'n':
		case 't':
		case 'y':
			flag = true;
			break;
		default:
			flag = false;
			break;
		}
		if (flag)
		{
			if (bool.TryParse(value, out var result3))
			{
				return result3;
			}
			if (value.Equals("yes", StringComparison.OrdinalIgnoreCase) || value.Equals("y", StringComparison.OrdinalIgnoreCase))
			{
				return true;
			}
			if (value.Equals("no", StringComparison.OrdinalIgnoreCase) || value.Equals("n", StringComparison.OrdinalIgnoreCase))
			{
				return false;
			}
		}
		return value;
	}

	public static void SetSwitchValue(string @switch, object? value)
	{
		switchValues[@switch] = value;
	}

	public static void ClearSwitchValue(string @switch)
	{
		switchValues.TryRemove(@switch, out object _);
	}

	private static Func<string, object?> MakeGetDataDelegate()
	{
		Func<string, object> func = (tAppContext?.GetMethod("GetData", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[1] { typeof(string) }, null))?.TryCreateDelegate<Func<string, object>>();
		if (func != null)
		{
			try
			{
				func("MonoMod.LogToFile");
			}
			catch
			{
				func = null;
			}
		}
		if (func == null)
		{
			func = AppDomain.CurrentDomain.GetData;
		}
		return func;
	}

	public static bool TryGetSwitchValue(string @switch, out object? value)
	{
		if (switchValues.TryGetValue(@switch, out value))
		{
			return true;
		}
		if (dGetData != null || dTryGetSwitch != null)
		{
			string text = "MonoMod." + @switch;
			object obj = dGetData?.Invoke(text);
			if (obj != null)
			{
				value = obj;
				return true;
			}
			TryGetSwitchFunc tryGetSwitchFunc = dTryGetSwitch;
			if (tryGetSwitchFunc != null && tryGetSwitchFunc(text, out var isEnabled))
			{
				value = isEnabled;
				return true;
			}
		}
		value = null;
		return false;
	}

	public static bool TryGetSwitchEnabled(string @switch, out bool isEnabled)
	{
		if (switchValues.TryGetValue(@switch, out object value) && value != null && TryProcessBoolData(value, out isEnabled))
		{
			return true;
		}
		if (dGetData != null || dTryGetSwitch != null)
		{
			string text = "MonoMod." + @switch;
			TryGetSwitchFunc tryGetSwitchFunc = dTryGetSwitch;
			if (tryGetSwitchFunc != null && tryGetSwitchFunc(text, out isEnabled))
			{
				return true;
			}
			object obj = dGetData?.Invoke(text);
			if (obj != null && TryProcessBoolData(obj, out isEnabled))
			{
				return true;
			}
		}
		isEnabled = false;
		return false;
	}

	private static bool TryProcessBoolData(object data, out bool boolVal)
	{
		if (!(data is bool flag))
		{
			if (!(data is int num))
			{
				if (!(data is long num2))
				{
					IConvertible convertible;
					if (!(data is string value))
					{
						convertible = data as IConvertible;
						if (convertible == null)
						{
							boolVal = false;
							return false;
						}
					}
					else
					{
						if (bool.TryParse(value, out boolVal))
						{
							return true;
						}
						convertible = (IConvertible)data;
					}
					IConvertible convertible2 = convertible;
					boolVal = convertible2.ToBoolean(CultureInfo.CurrentCulture);
					return true;
				}
				long num3 = num2;
				boolVal = num3 != 0;
				return true;
			}
			int num4 = num;
			boolVal = num4 != 0;
			return true;
		}
		bool flag2 = flag;
		boolVal = flag2;
		return true;
	}
}


private delegate bool TryGetSwitchFunc(string @switch, out bool isEnabled);


using System;
using System.Runtime.CompilerServices;
using MonoMod;
using MonoMod.Logs;

internal static class MMDbgLog
{
	[InterpolatedStringHandler]
	internal ref struct DebugLogSpamStringHandler
	{
		internal DebugLogInterpolatedStringHandler handler;

		public DebugLogSpamStringHandler(int literalLen, int formattedCount, out bool isEnabled)
		{
			handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Spam, out isEnabled);
		}

		public override string ToString()
		{
			return handler.ToString();
		}

		public string ToStringAndClear()
		{
			return handler.ToStringAndClear();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLiteral(string s)
		{
			handler.AppendLiteral(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value)
		{
			handler.AppendFormatted(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment)
		{
			handler.AppendFormatted(value, alignment);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, string? format)
		{
			handler.AppendFormatted(value, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment, string? format)
		{
			handler.AppendFormatted(value, alignment, format);
		}
	}

	[InterpolatedStringHandler]
	internal ref struct DebugLogTraceStringHandler
	{
		internal DebugLogInterpolatedStringHandler handler;

		public DebugLogTraceStringHandler(int literalLen, int formattedCount, out bool isEnabled)
		{
			handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Trace, out isEnabled);
		}

		public override string ToString()
		{
			return handler.ToString();
		}

		public string ToStringAndClear()
		{
			return handler.ToStringAndClear();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLiteral(string s)
		{
			handler.AppendLiteral(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value)
		{
			handler.AppendFormatted(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment)
		{
			handler.AppendFormatted(value, alignment);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, string? format)
		{
			handler.AppendFormatted(value, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment, string? format)
		{
			handler.AppendFormatted(value, alignment, format);
		}
	}

	[InterpolatedStringHandler]
	internal ref struct DebugLogInfoStringHandler
	{
		internal DebugLogInterpolatedStringHandler handler;

		public DebugLogInfoStringHandler(int literalLen, int formattedCount, out bool isEnabled)
		{
			handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Info, out isEnabled);
		}

		public override string ToString()
		{
			return handler.ToString();
		}

		public string ToStringAndClear()
		{
			return handler.ToStringAndClear();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLiteral(string s)
		{
			handler.AppendLiteral(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value)
		{
			handler.AppendFormatted(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment)
		{
			handler.AppendFormatted(value, alignment);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, string? format)
		{
			handler.AppendFormatted(value, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment, string? format)
		{
			handler.AppendFormatted(value, alignment, format);
		}
	}

	[InterpolatedStringHandler]
	internal ref struct DebugLogWarningStringHandler
	{
		internal DebugLogInterpolatedStringHandler handler;

		public DebugLogWarningStringHandler(int literalLen, int formattedCount, out bool isEnabled)
		{
			handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Warning, out isEnabled);
		}

		public override string ToString()
		{
			return handler.ToString();
		}

		public string ToStringAndClear()
		{
			return handler.ToStringAndClear();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLiteral(string s)
		{
			handler.AppendLiteral(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value)
		{
			handler.AppendFormatted(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment)
		{
			handler.AppendFormatted(value, alignment);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, string? format)
		{
			handler.AppendFormatted(value, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment, string? format)
		{
			handler.AppendFormatted(value, alignment, format);
		}
	}

	[InterpolatedStringHandler]
	internal ref struct DebugLogErrorStringHandler
	{
		internal DebugLogInterpolatedStringHandler handler;

		public DebugLogErrorStringHandler(int literalLen, int formattedCount, out bool isEnabled)
		{
			handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Error, out isEnabled);
		}

		public override string ToString()
		{
			return handler.ToString();
		}

		public string ToStringAndClear()
		{
			return handler.ToStringAndClear();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendLiteral(string s)
		{
			handler.AppendLiteral(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(string? s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s)
		{
			handler.AppendFormatted(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
		{
			handler.AppendFormatted(s, alignment, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value)
		{
			handler.AppendFormatted(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment)
		{
			handler.AppendFormatted(value, alignment);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, string? format)
		{
			handler.AppendFormatted(value, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void AppendFormatted<T>(T value, int alignment, string? format)
		{
			handler.AppendFormatted(value, alignment, format);
		}
	}

	public static bool IsWritingLog => DebugLog.IsWritingLog;

	[ModuleInitializer]
	internal static void LogVersion()
	{
		Info("Version 25.0.4");
	}

	public static void Log(LogLevel level, string message)
	{
		DebugLog.Log("MonoMod.Utils", level, message);
	}

	public static void Log(LogLevel level, [InterpolatedStringHandlerArgument("level")] ref DebugLogInterpolatedStringHandler message)
	{
		DebugLog.Log("MonoMod.Utils", level, ref message);
	}

	public static void Spam(string message)
	{
		Log(LogLevel.Spam, message);
	}

	public static void Spam(ref DebugLogSpamStringHandler message)
	{
		Log(LogLevel.Spam, ref message.handler);
	}

	public static void Trace(string message)
	{
		Log(LogLevel.Trace, message);
	}

	public static void Trace(ref DebugLogTraceStringHandler message)
	{
		Log(LogLevel.Trace, ref message.handler);
	}

	public static void Info(string message)
	{
		Log(LogLevel.Info, message);
	}

	public static void Info(ref DebugLogInfoStringHandler message)
	{
		Log(LogLevel.Info, ref message.handler);
	}

	public static void Warning(string message)
	{
		Log(LogLevel.Warning, message);
	}

	public static void Warning(ref DebugLogWarningStringHandler message)
	{
		Log(LogLevel.Warning, ref message.handler);
	}

	public static void Error(string message)
	{
		Log(LogLevel.Error, message);
	}

	public static void Error(ref DebugLogErrorStringHandler message)
	{
		Log(LogLevel.Error, ref message.handler);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogSpamStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogSpamStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Spam, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogTraceStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogTraceStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Trace, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogInfoStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogInfoStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Info, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogWarningStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogWarningStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Warning, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogErrorStringHandler
{
	internal DebugLogInterpolatedStringHandler handler;

	public DebugLogErrorStringHandler(int literalLen, int formattedCount, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, LogLevel.Error, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using Mono.Cecil;

internal static class MultiTargetShims
{
	public static TypeReference GetConstraintType(this GenericParameterConstraint constraint)
	{
		return constraint.ConstraintType;
	}
}


using System;

[AttributeUsage(AttributeTargets.Class)]
internal sealed class EmitILOverloadsAttribute : Attribute
{
	public EmitILOverloadsAttribute(string filename, string kind)
	{
	}
}


internal static class ILOverloadKind
{
	public const string Cursor = "ILCursor";

	public const string Matcher = "ILMatcher";
}


using System;

[AttributeUsage(AttributeTargets.Class)]
internal sealed class ModExportNameAttribute : Attribute
{
	public string Name { get; }

	public ModExportNameAttribute(string name)
	{
		Name = name;
	}
}


using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Field)]
internal sealed class ModImportNameAttribute : Attribute
{
	public string Name { get; }

	public ModImportNameAttribute(string name)
	{
		Name = name;
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using MonoMod.ModInterop;
using MonoMod.Utils;

internal static class ModInteropManager
{
	private static HashSet<Type> Registered = new HashSet<Type>();

	private static Dictionary<string, List<MethodInfo>> Methods = new Dictionary<string, List<MethodInfo>>();

	private static List<FieldInfo> Fields = new List<FieldInfo>();

	public static void ModInterop(this Type type)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		if (Registered.Contains(type))
		{
			return;
		}
		Registered.Add(type);
		string name = type.Assembly.GetName().Name;
		object[] customAttributes = type.GetCustomAttributes(typeof(ModExportNameAttribute), inherit: false);
		for (int i = 0; i < customAttributes.Length; i++)
		{
			name = ((ModExportNameAttribute)customAttributes[i]).Name;
		}
		FieldInfo[] fields = type.GetFields(BindingFlags.Static | BindingFlags.Public);
		foreach (FieldInfo fieldInfo in fields)
		{
			if (typeof(Delegate).IsAssignableFrom(fieldInfo.FieldType))
			{
				Fields.Add(fieldInfo);
			}
		}
		MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public);
		foreach (MethodInfo method in methods)
		{
			method.RegisterModExport();
			method.RegisterModExport(name);
		}
		foreach (FieldInfo field in Fields)
		{
			if (!Methods.TryGetValue(field.GetModImportName(), out List<MethodInfo> value))
			{
				field.SetValue(null, null);
				continue;
			}
			bool flag = false;
			foreach (MethodInfo item in value)
			{
				try
				{
					field.SetValue(null, Delegate.CreateDelegate(field.FieldType, null, item));
					flag = true;
				}
				catch
				{
					continue;
				}
				break;
			}
			if (!flag)
			{
				field.SetValue(null, null);
			}
		}
	}

	public static void RegisterModExport(this MethodInfo method, string? prefix = null)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (!method.IsPublic || !method.IsStatic)
		{
			throw new MemberAccessException("Utility must be public static");
		}
		string text = method.Name;
		if (!string.IsNullOrEmpty(prefix))
		{
			text = prefix + "." + text;
		}
		if (!Methods.TryGetValue(text, out List<MethodInfo> value))
		{
			value = (Methods[text] = new List<MethodInfo>());
		}
		if (!value.Contains(method))
		{
			value.Add(method);
		}
	}

	private static string GetModImportName(this FieldInfo field)
	{
		object[] customAttributes = field.GetCustomAttributes(typeof(ModImportNameAttribute), inherit: false);
		int num = 0;
		if (num < customAttributes.Length)
		{
			return ((ModImportNameAttribute)customAttributes[num]).Name;
		}
		if ((object)field.DeclaringType != null)
		{
			customAttributes = field.DeclaringType.GetCustomAttributes(typeof(ModImportNameAttribute), inherit: false);
			num = 0;
			if (num < customAttributes.Length)
			{
				return ((ModImportNameAttribute)customAttributes[num]).Name + "." + field.Name;
			}
		}
		return field.Name;
	}
}


using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using MonoMod.Logs;
using MonoMod.Utils;

internal static class DebugFormatter
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool CanDebugFormat<T>(in T value, out object? extraData)
	{
		extraData = null;
		if (typeof(T) == typeof(Type))
		{
			return true;
		}
		if (typeof(T) == typeof(MethodBase))
		{
			return true;
		}
		if (typeof(T) == typeof(MethodInfo))
		{
			return true;
		}
		if (typeof(T) == typeof(ConstructorInfo))
		{
			return true;
		}
		if (typeof(T) == typeof(FieldInfo))
		{
			return true;
		}
		if (typeof(T) == typeof(PropertyInfo))
		{
			return true;
		}
		if (typeof(T) == typeof(Exception))
		{
			return true;
		}
		if (typeof(T) == typeof(IDebugFormattable))
		{
			return true;
		}
		T val = value;
		if ((val is Type || val is MethodBase || val is FieldInfo || val is PropertyInfo) ? true : false)
		{
			return true;
		}
		if (value is Exception ex)
		{
			extraData = ex.ToString();
			return true;
		}
		if (value is IDebugFormattable)
		{
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool TryFormatInto<T>(in T value, object? extraData, Span<char> into, out int wrote)
	{
		if (default(T) == null && value == null)
		{
			wrote = 0;
			return true;
		}
		if (typeof(T) == typeof(Type))
		{
			return TryFormatType(Transmute<Type>(in value), into, out wrote);
		}
		if (typeof(T) == typeof(MethodInfo))
		{
			return TryFormatMethodInfo(Transmute<MethodInfo>(in value), into, out wrote);
		}
		if (typeof(T) == typeof(ConstructorInfo))
		{
			return TryFormatMethodBase(Transmute<ConstructorInfo>(in value), into, out wrote);
		}
		if (typeof(T) == typeof(FieldInfo))
		{
			return TryFormatFieldInfo(Transmute<FieldInfo>(in value), into, out wrote);
		}
		if (typeof(T) == typeof(PropertyInfo))
		{
			return TryFormatPropertyInfo(Transmute<PropertyInfo>(in value), into, out wrote);
		}
		if (typeof(T) == typeof(Exception))
		{
			return TryFormatException(Transmute<Exception>(in value), Unsafe.As<string>(extraData), into, out wrote);
		}
		if (typeof(T) == typeof(IDebugFormattable))
		{
			return Transmute<IDebugFormattable>(in value).TryFormatInto(into, out wrote);
		}
		if (value is Type type)
		{
			return TryFormatType(type, into, out wrote);
		}
		if (value is MethodInfo method)
		{
			return TryFormatMethodInfo(method, into, out wrote);
		}
		if (value is ConstructorInfo method2)
		{
			return TryFormatMethodBase(method2, into, out wrote);
		}
		if (value is MethodBase method3)
		{
			return TryFormatMethodBase(method3, into, out wrote);
		}
		if (value is FieldInfo field)
		{
			return TryFormatFieldInfo(field, into, out wrote);
		}
		if (value is PropertyInfo prop)
		{
			return TryFormatPropertyInfo(prop, into, out wrote);
		}
		if (value is Exception e)
		{
			return TryFormatException(e, Unsafe.As<string>(extraData), into, out wrote);
		}
		if (value is IDebugFormattable)
		{
			return ((IDebugFormattable)(object)value).TryFormatInto(into, out wrote);
		}
		bool flag = false;
		bool isEnabled;
		AssertionInterpolatedStringHandler message = new AssertionInterpolatedStringHandler(48, 1, flag, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Called TryFormatInto with value of unknown type ");
			message.AppendFormatted(value.GetType());
		}
		Helpers.Assert(flag, ref message, "false");
		wrote = 0;
		return false;
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		static ref TOut Transmute<TOut>(in T val)
		{
			return ref Unsafe.As<T, TOut>(ref Unsafe.AsRef(in val));
		}
	}

	private static bool TryFormatException(Exception e, string? eStr, Span<char> into, out int wrote)
	{
		wrote = 0;
		if (eStr == null)
		{
			eStr = e.ToString();
		}
		string newLine = Environment.NewLine;
		if (into.Slice(wrote).Length < eStr.Length)
		{
			return false;
		}
		MemoryExtensions.AsSpan(eStr).CopyTo(into.Slice(wrote));
		wrote += eStr.Length;
		FormatIntoInterpolatedStringHandler handler;
		bool enabled;
		int wrote2;
		if (e is ReflectionTypeLoadException ex)
		{
			for (int i = 0; i < 4 && i < ex.Types.Length; i++)
			{
				Span<char> span = into.Slice(wrote);
				Span<char> into2 = span;
				handler = new FormatIntoInterpolatedStringHandler(56, 3, span, out enabled);
				if (enabled && handler.AppendFormatted(newLine) && handler.AppendLiteral("System.Reflection.ReflectionTypeLoadException.Types[") && handler.AppendFormatted(i) && handler.AppendLiteral("] = "))
				{
					handler.AppendFormatted(ex.Types[i]);
				}
				else
					_ = 0;
				if (!Into(into2, out wrote2, ref handler))
				{
					return false;
				}
				wrote += wrote2;
			}
			if (ex.Types.Length >= 4)
			{
				Span<char> span = into.Slice(wrote);
				Span<char> into3 = span;
				handler = new FormatIntoInterpolatedStringHandler(62, 1, span, out enabled);
				if (enabled && handler.AppendFormatted(newLine))
				{
					handler.AppendLiteral("System.Reflection.ReflectionTypeLoadException.Types[...] = ...");
				}
				else
					_ = 0;
				if (!Into(into3, out wrote2, ref handler))
				{
					return false;
				}
				wrote += wrote2;
			}
			if (ex.LoaderExceptions.Length != 0)
			{
				if (into.Slice(wrote).Length < newLine.Length + "System.Reflection.ReflectionTypeLoadException.LoaderExceptions = [".Length)
				{
					return false;
				}
				MemoryExtensions.AsSpan(newLine).CopyTo(into.Slice(wrote));
				wrote += newLine.Length;
				MemoryExtensions.AsSpan("System.Reflection.ReflectionTypeLoadException.LoaderExceptions = [").CopyTo(into.Slice(wrote));
				wrote += "System.Reflection.ReflectionTypeLoadException.LoaderExceptions = [".Length;
				for (int j = 0; j < ex.LoaderExceptions.Length; j++)
				{
					Exception ex2 = ex.LoaderExceptions[j];
					if (ex2 != null)
					{
						if (into.Slice(wrote).Length < newLine.Length)
						{
							return false;
						}
						MemoryExtensions.AsSpan(newLine).CopyTo(into.Slice(wrote));
						wrote += newLine.Length;
						if (!TryFormatException(ex2, null, into.Slice(wrote), out wrote2))
						{
							return false;
						}
						wrote += wrote2;
					}
				}
				if (into.Slice(wrote).Length < newLine.Length + 1)
				{
					return false;
				}
				MemoryExtensions.AsSpan(newLine).CopyTo(into.Slice(wrote));
				wrote += newLine.Length;
				into[wrote++] = ']';
			}
		}
		if (e is TypeLoadException ex3)
		{
			Span<char> span = into.Slice(wrote);
			Span<char> into4 = span;
			handler = new FormatIntoInterpolatedStringHandler(36, 2, span, out enabled);
			if (enabled && handler.AppendFormatted(newLine) && handler.AppendLiteral("System.TypeLoadException.TypeName = "))
			{
				handler.AppendFormatted(ex3.TypeName);
			}
			else
				_ = 0;
			if (!Into(into4, out wrote2, ref handler))
			{
				return false;
			}
			wrote += wrote2;
		}
		if (e is BadImageFormatException ex4)
		{
			Span<char> span = into.Slice(wrote);
			Span<char> into5 = span;
			handler = new FormatIntoInterpolatedStringHandler(42, 2, span, out enabled);
			if (enabled && handler.AppendFormatted(newLine) && handler.AppendLiteral("System.BadImageFormatException.FileName = "))
			{
				handler.AppendFormatted(ex4.FileName);
			}
			else
				_ = 0;
			if (!Into(into5, out wrote2, ref handler))
			{
				return false;
			}
			wrote += wrote2;
		}
		return true;
	}

	private static bool TryFormatType(Type type, Span<char> into, out int wrote)
	{
		wrote = 0;
		string fullName = type.FullName;
		if (fullName == null)
		{
			return true;
		}
		if (into.Length < fullName.Length)
		{
			return false;
		}
		MemoryExtensions.AsSpan(fullName).CopyTo(into);
		wrote = fullName.Length;
		return true;
	}

	private static bool TryFormatMethodInfo(MethodInfo method, Span<char> into, out int wrote)
	{
		Type returnType = method.ReturnType;
		wrote = 0;
		if (!TryFormatType(returnType, into.Slice(wrote), out var wrote2))
		{
			return false;
		}
		wrote += wrote2;
		if (into.Slice(wrote).Length < 1)
		{
			return false;
		}
		into[wrote++] = ' ';
		if (!TryFormatMethodBase(method, into.Slice(wrote), out wrote2))
		{
			return false;
		}
		wrote += wrote2;
		return true;
	}

	private static bool TryFormatMemberInfoName(MemberInfo member, Span<char> into, out int wrote)
	{
		wrote = 0;
		Type declaringType = member.DeclaringType;
		if ((object)declaringType != null)
		{
			if (!TryFormatType(declaringType, into.Slice(wrote), out var wrote2))
			{
				return false;
			}
			wrote += wrote2;
			if (into.Slice(wrote).Length < 1)
			{
				return false;
			}
			into[wrote++] = ':';
		}
		string name = member.Name;
		if (into.Slice(wrote).Length < name.Length)
		{
			return false;
		}
		MemoryExtensions.AsSpan(name).CopyTo(into.Slice(wrote));
		wrote += name.Length;
		return true;
	}

	private static bool TryFormatMethodBase(MethodBase method, Span<char> into, out int wrote)
	{
		wrote = 0;
		if (!TryFormatMemberInfoName(method, into.Slice(wrote), out var wrote2))
		{
			return false;
		}
		wrote += wrote2;
		if (method.IsGenericMethod)
		{
			if (into.Slice(wrote).Length < 1)
			{
				return false;
			}
			into[wrote++] = '<';
			Type[] genericArguments = method.GetGenericArguments();
			for (int i = 0; i < genericArguments.Length; i++)
			{
				if (i != 0)
				{
					if (into.Slice(wrote).Length < 2)
					{
						return false;
					}
					into[wrote++] = ',';
					into[wrote++] = ' ';
				}
				if (!TryFormatType(genericArguments[i], into.Slice(wrote), out wrote2))
				{
					return false;
				}
				wrote += wrote2;
			}
			if (into.Slice(wrote).Length < 1)
			{
				return false;
			}
			into[wrote++] = '>';
		}
		ParameterInfo[] parameters = method.GetParameters();
		if (into.Slice(wrote).Length < 1)
		{
			return false;
		}
		into[wrote++] = '(';
		for (int j = 0; j < parameters.Length; j++)
		{
			if (j != 0)
			{
				if (into.Slice(wrote).Length < 2)
				{
					return false;
				}
				into[wrote++] = ',';
				into[wrote++] = ' ';
			}
			if (!TryFormatType(parameters[j].ParameterType, into.Slice(wrote), out wrote2))
			{
				return false;
			}
			wrote += wrote2;
		}
		if (into.Slice(wrote).Length < 1)
		{
			return false;
		}
		into[wrote++] = ')';
		return true;
	}

	private static bool TryFormatFieldInfo(FieldInfo field, Span<char> into, out int wrote)
	{
		wrote = 0;
		if (!TryFormatType(field.FieldType, into.Slice(wrote), out var wrote2))
		{
			return false;
		}
		wrote += wrote2;
		if (into.Slice(wrote).Length < 1)
		{
			return false;
		}
		into[wrote++] = ' ';
		if (!TryFormatMemberInfoName(field, into.Slice(wrote), out wrote2))
		{
			return false;
		}
		wrote += wrote2;
		return true;
	}

	private static bool TryFormatPropertyInfo(PropertyInfo prop, Span<char> into, out int wrote)
	{
		wrote = 0;
		if (!TryFormatType(prop.PropertyType, into.Slice(wrote), out var wrote2))
		{
			return false;
		}
		wrote += wrote2;
		if (into.Slice(wrote).Length < 1)
		{
			return false;
		}
		into[wrote++] = ' ';
		if (!TryFormatMemberInfoName(prop, into.Slice(wrote), out wrote2))
		{
			return false;
		}
		wrote += wrote2;
		bool canRead = prop.CanRead;
		bool canWrite = prop.CanWrite;
		int num = 5 + (canRead ? 4 : 0) + (canWrite ? 4 : 0) + ((canRead && canWrite) ? 1 : 0);
		if (into.Slice(wrote).Length < num)
		{
			return false;
		}
		MemoryExtensions.AsSpan(" { ").CopyTo(into.Slice(wrote));
		wrote += 3;
		if (canRead)
		{
			MemoryExtensions.AsSpan("get;").CopyTo(into.Slice(wrote));
			wrote += 4;
		}
		if (canRead && canWrite)
		{
			into[wrote++] = ' ';
		}
		if (canWrite)
		{
			MemoryExtensions.AsSpan("set;").CopyTo(into.Slice(wrote));
			wrote += 4;
		}
		MemoryExtensions.AsSpan(" }").CopyTo(into.Slice(wrote));
		wrote += 2;
		return true;
	}

	public static string Format(ref FormatInterpolatedStringHandler handler)
	{
		return handler.ToStringAndClear();
	}

	public static bool Into(Span<char> into, out int wrote, [InterpolatedStringHandlerArgument("into")] ref FormatIntoInterpolatedStringHandler handler)
	{
		wrote = handler.pos;
		return !handler.incomplete;
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct FormatInterpolatedStringHandler
{
	private DebugLogInterpolatedStringHandler handler;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public FormatInterpolatedStringHandler(int literalLen, int formattedCount)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, enabled: true, recordHoles: false, out var _);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


internal readonly record struct MessageHole
{
	public int Start { get; }

	public int End { get; }

	public object? Value { get; }

	public bool IsValueUnrepresentable { get; }

	public MessageHole(int start, int end)
	{
		Value = null;
		IsValueUnrepresentable = true;
		Start = start;
		End = end;
	}

	public MessageHole(int start, int end, object? value)
	{
		Value = value;
		IsValueUnrepresentable = false;
		Start = start;
		End = end;
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using MonoMod;
using MonoMod.Logs;
using MonoMod.Utils;

internal sealed class DebugLog
{
	public delegate void OnLogMessage(string source, DateTime time, LogLevel level, string message);

	public delegate void OnLogMessageDetailed(string source, DateTime time, LogLevel level, string formattedMessage, ReadOnlyMemory<MessageHole> holes);

	private sealed class LogMessage
	{
		public string Source { get; private set; }

		public DateTime Time { get; private set; }

		public LogLevel Level { get; private set; }

		public string FormattedMessage { get; private set; }

		public ReadOnlyMemory<MessageHole> FormatHoles { get; private set; }

		public LogMessage(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory<MessageHole> holes)
		{
			Source = source;
			Time = time;
			Level = level;
			FormattedMessage = formatted;
			FormatHoles = holes;
		}

		public void Clear()
		{
			Source = "";
			Time = default(DateTime);
			Level = LogLevel.Spam;
			FormattedMessage = "";
			FormatHoles = default(ReadOnlyMemory<MessageHole>);
		}

		public void Init(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory<MessageHole> holes)
		{
			Source = source;
			Time = time;
			Level = level;
			FormattedMessage = formatted;
			FormatHoles = holes;
		}

		public void ReportTo(OnLogMessage del)
		{
			try
			{
				del(Source, Time, Level, FormattedMessage);
			}
			catch (Exception ex)
			{
				Debugger.Log(int.MaxValue, "MonoMod.DebugLog", "Exception caught while reporting to message handler");
				Debugger.Log(int.MaxValue, "MonoMod.DebugLog", ex.ToString());
			}
		}

		public void ReportTo(OnLogMessageDetailed del)
		{
			try
			{
				del(Source, Time, Level, FormattedMessage, FormatHoles);
			}
			catch (Exception ex)
			{
				Debugger.Log(int.MaxValue, "MonoMod.DebugLog", "Exception caught while reporting to message handler");
				Debugger.Log(int.MaxValue, "MonoMod.DebugLog", ex.ToString());
			}
		}
	}

	private sealed class LevelSubscriptions
	{
		public LogLevelFilter ActiveLevels;

		public LogLevelFilter DetailLevels;

		public readonly OnLogMessage?[] SimpleRegs;

		public readonly OnLogMessageDetailed?[] DetailedRegs;

		private const LogLevelFilter ValidFilter = LogLevelFilter.Spam | LogLevelFilter.Trace | LogLevelFilter.Info | LogLevelFilter.Warning | LogLevelFilter.Error | LogLevelFilter.Assert;

		public static readonly LevelSubscriptions None = new LevelSubscriptions();

		private LevelSubscriptions(LogLevelFilter active, LogLevelFilter detail, OnLogMessage?[] simple, OnLogMessageDetailed?[] detailed)
		{
			ActiveLevels = active | detail;
			DetailLevels = detail;
			SimpleRegs = simple;
			DetailedRegs = detailed;
		}

		private LevelSubscriptions()
		{
			ActiveLevels = LogLevelFilter.None;
			DetailLevels = LogLevelFilter.None;
			SimpleRegs = new OnLogMessage[6];
			DetailedRegs = new OnLogMessageDetailed[SimpleRegs.Length];
		}

		private LevelSubscriptions Clone(bool changingDetail)
		{
			OnLogMessage[] array = SimpleRegs;
			OnLogMessageDetailed[] array2 = DetailedRegs;
			if (!changingDetail)
			{
				array = new OnLogMessage[SimpleRegs.Length];
				Array.Copy(SimpleRegs, array, array.Length);
			}
			else
			{
				array2 = new OnLogMessageDetailed[DetailedRegs.Length];
				Array.Copy(DetailedRegs, array2, array2.Length);
			}
			return new LevelSubscriptions(ActiveLevels, DetailLevels, array, array2);
		}

		private void FixFilters()
		{
			ActiveLevels &= LogLevelFilter.Spam | LogLevelFilter.Trace | LogLevelFilter.Info | LogLevelFilter.Warning | LogLevelFilter.Error | LogLevelFilter.Assert;
			DetailLevels &= LogLevelFilter.Spam | LogLevelFilter.Trace | LogLevelFilter.Info | LogLevelFilter.Warning | LogLevelFilter.Error | LogLevelFilter.Assert;
		}

		public LevelSubscriptions AddSimple(LogLevelFilter filter, OnLogMessage del)
		{
			LevelSubscriptions levelSubscriptions = Clone(changingDetail: false);
			levelSubscriptions.ActiveLevels |= filter;
			for (int i = 0; i < levelSubscriptions.SimpleRegs.Length; i++)
			{
				if (((uint)filter & (uint)(1 << i)) != 0)
				{
					Helpers.EventAdd(ref levelSubscriptions.SimpleRegs[i], del);
				}
			}
			levelSubscriptions.FixFilters();
			return levelSubscriptions;
		}

		public LevelSubscriptions RemoveSimple(LogLevelFilter filter, OnLogMessage del)
		{
			LevelSubscriptions levelSubscriptions = Clone(changingDetail: false);
			for (int i = 0; i < levelSubscriptions.SimpleRegs.Length; i++)
			{
				if (((uint)filter & (uint)(1 << i)) != 0 && Helpers.EventRemove(ref levelSubscriptions.SimpleRegs[i], del) == null)
				{
					levelSubscriptions.ActiveLevels &= (LogLevelFilter)(~(1 << i));
				}
			}
			levelSubscriptions.ActiveLevels |= levelSubscriptions.DetailLevels;
			levelSubscriptions.FixFilters();
			return levelSubscriptions;
		}

		public LevelSubscriptions AddDetailed(LogLevelFilter filter, OnLogMessageDetailed del)
		{
			LevelSubscriptions levelSubscriptions = Clone(changingDetail: true);
			levelSubscriptions.DetailLevels |= filter;
			for (int i = 0; i < levelSubscriptions.DetailedRegs.Length; i++)
			{
				if (((uint)filter & (uint)(1 << i)) != 0)
				{
					Helpers.EventAdd(ref levelSubscriptions.DetailedRegs[i], del);
				}
			}
			levelSubscriptions.ActiveLevels |= levelSubscriptions.DetailLevels;
			levelSubscriptions.FixFilters();
			return levelSubscriptions;
		}

		public LevelSubscriptions RemoveDetailed(LogLevelFilter filter, OnLogMessageDetailed del)
		{
			LevelSubscriptions levelSubscriptions = Clone(changingDetail: true);
			for (int i = 0; i < levelSubscriptions.DetailedRegs.Length; i++)
			{
				if (((uint)filter & (uint)(1 << i)) != 0 && Helpers.EventRemove(ref levelSubscriptions.DetailedRegs[i], del) == null)
				{
					levelSubscriptions.DetailLevels &= (LogLevelFilter)(~(1 << i));
				}
			}
			levelSubscriptions.ActiveLevels |= levelSubscriptions.DetailLevels;
			levelSubscriptions.FixFilters();
			return levelSubscriptions;
		}
	}

	private sealed class LogSubscriptionSimple : IDisposable
	{
		private readonly DebugLog log;

		private readonly OnLogMessage del;

		private readonly LogLevelFilter filter;

		public LogSubscriptionSimple(DebugLog log, OnLogMessage del, LogLevelFilter filter)
		{
			this.log = log;
			this.del = del;
			this.filter = filter;
		}

		public void Dispose()
		{
			LevelSubscriptions subscriptions;
			LevelSubscriptions value;
			do
			{
				subscriptions = log.subscriptions;
				value = subscriptions.RemoveSimple(filter, del);
			}
			while (Interlocked.CompareExchange(ref log.subscriptions, value, subscriptions) != subscriptions);
		}
	}

	private sealed class LogSubscriptionDetailed : IDisposable
	{
		private readonly DebugLog log;

		private readonly OnLogMessageDetailed del;

		private readonly LogLevelFilter filter;

		public LogSubscriptionDetailed(DebugLog log, OnLogMessageDetailed del, LogLevelFilter filter)
		{
			this.log = log;
			this.del = del;
			this.filter = filter;
		}

		public void Dispose()
		{
			LevelSubscriptions subscriptions;
			LevelSubscriptions value;
			do
			{
				subscriptions = log.subscriptions;
				value = subscriptions.RemoveDetailed(filter, del);
			}
			while (Interlocked.CompareExchange(ref log.subscriptions, value, subscriptions) != subscriptions);
		}
	}

	internal static readonly DebugLog Instance = new DebugLog();

	private static readonly ConcurrentBag<WeakReference<LogMessage>> weakRefCache = new ConcurrentBag<WeakReference<LogMessage>>();

	private static readonly ConcurrentBag<WeakReference<LogMessage>> messageObjectCache = new ConcurrentBag<WeakReference<LogMessage>>();

	private static readonly char[] listEnvSeparator = new char[3] { ' ', ';', ',' };

	private readonly bool recordHoles;

	private readonly int replayQueueLength;

	private readonly ConcurrentQueue<LogMessage>? replayQueue;

	private LogLevelFilter globalFilter = LogLevelFilter.DefaultFilter;

	private static byte[]? memlog;

	private static int memlogPos;

	private LevelSubscriptions subscriptions = LevelSubscriptions.None;

	private static readonly ConcurrentDictionary<OnLogMessage, IDisposable> simpleRegDict = new ConcurrentDictionary<OnLogMessage, IDisposable>();

	public static bool IsFinalizing
	{
		get
		{
			if (!Environment.HasShutdownStarted)
			{
				return AppDomain.CurrentDomain.IsFinalizingForUnload();
			}
			return true;
		}
	}

	public static bool IsWritingLog => Instance.ShouldLog;

	internal bool AlwaysLog
	{
		get
		{
			if (replayQueue == null)
			{
				return Debugger.IsAttached;
			}
			return true;
		}
	}

	internal bool ShouldLog
	{
		get
		{
			if (subscriptions.ActiveLevels == LogLevelFilter.None)
			{
				return AlwaysLog;
			}
			return true;
		}
	}

	internal bool RecordHoles
	{
		get
		{
			if (!recordHoles)
			{
				return subscriptions.DetailLevels != LogLevelFilter.None;
			}
			return true;
		}
	}

	public static event OnLogMessage OnLog
	{
		add
		{
			IDisposable res = Subscribe(Instance.globalFilter, value);
			simpleRegDict.AddOrUpdate(value, res, delegate(OnLogMessage _, IDisposable d)
			{
				d.Dispose();
				return res;
			});
		}
		remove
		{
			if (simpleRegDict.TryRemove(value, out IDisposable value2))
			{
				value2.Dispose();
			}
		}
	}

	private LogMessage MakeMessage(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory<MessageHole> holes)
	{
		try
		{
			if (replayQueue == null && !IsFinalizing)
			{
				WeakReference<LogMessage> result;
				while (messageObjectCache.TryTake(out result))
				{
					if (result.TryGetTarget(out var target))
					{
						target.Init(source, time, level, formatted, holes);
						weakRefCache.Add(result);
						return target;
					}
					weakRefCache.Add(result);
				}
			}
		}
		catch
		{
		}
		return new LogMessage(source, time, level, formatted, holes);
	}

	private void ReturnMessage(LogMessage message)
	{
		message.Clear();
		try
		{
			if (replayQueue == null && !IsFinalizing)
			{
				if (weakRefCache.TryTake(out WeakReference<LogMessage> result))
				{
					result.SetTarget(message);
					messageObjectCache.Add(result);
				}
				else
				{
					messageObjectCache.Add(new WeakReference<LogMessage>(message));
				}
			}
		}
		catch
		{
		}
	}

	private void PostMessage(LogMessage message)
	{
		if (Debugger.IsAttached)
		{
			try
			{
				LogLevel level = message.Level;
				string source = message.Source;
				FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(6, 3);
				handler.AppendLiteral("[");
				handler.AppendFormatted(message.Source);
				handler.AppendLiteral("] ");
				handler.AppendFormatted(message.Level.FastToString());
				handler.AppendLiteral(": ");
				handler.AppendFormatted(message.FormattedMessage);
				handler.AppendLiteral("\n");
				Debugger.Log((int)level, source, DebugFormatter.Format(ref handler));
			}
			catch
			{
			}
		}
		try
		{
			LevelSubscriptions levelSubscriptions = subscriptions;
			int level2 = (int)message.Level;
			OnLogMessage onLogMessage = levelSubscriptions.SimpleRegs[level2];
			if (onLogMessage != null)
			{
				message.ReportTo(onLogMessage);
			}
			OnLogMessageDetailed onLogMessageDetailed = levelSubscriptions.DetailedRegs[level2];
			if (onLogMessageDetailed != null)
			{
				message.ReportTo(onLogMessageDetailed);
			}
			if (IsFinalizing)
			{
				return;
			}
			ConcurrentQueue<LogMessage> concurrentQueue = replayQueue;
			if (concurrentQueue != null)
			{
				concurrentQueue.Enqueue(message);
				LogMessage result;
				while (concurrentQueue.Count > replayQueueLength && concurrentQueue.TryDequeue(out result))
				{
				}
			}
			else
			{
				ReturnMessage(message);
			}
		}
		catch
		{
		}
	}

	internal bool ShouldLogLevel(LogLevel level)
	{
		if (((uint)(1 << (int)level) & (uint)subscriptions.ActiveLevels) == 0)
		{
			if (((uint)(1 << (int)level) & (uint)globalFilter) != 0)
			{
				return AlwaysLog;
			}
			return false;
		}
		return true;
	}

	internal bool ShouldLevelRecordHoles(LogLevel level)
	{
		if (!recordHoles)
		{
			return ((uint)(1 << (int)level) & (uint)subscriptions.DetailLevels) != 0;
		}
		return true;
	}

	public void Write(string source, DateTime time, LogLevel level, string message)
	{
		if (ShouldLogLevel(level))
		{
			PostMessage(MakeMessage(source, time, level, message, default(ReadOnlyMemory<MessageHole>)));
		}
	}

	public void Write(string source, DateTime time, LogLevel level, [InterpolatedStringHandlerArgument("level")] ref DebugLogInterpolatedStringHandler message)
	{
		if (message.enabled && ShouldLogLevel(level))
		{
			ReadOnlyMemory<MessageHole> holes;
			string formatted = message.ToStringAndClear(out holes);
			PostMessage(MakeMessage(source, time, level, formatted, holes));
		}
	}

	internal void LogCore(string source, LogLevel level, string message)
	{
		if (ShouldLogLevel(level))
		{
			Write(source, DateTime.UtcNow, level, message);
		}
	}

	internal void LogCore(string source, LogLevel level, [InterpolatedStringHandlerArgument("level")] ref DebugLogInterpolatedStringHandler message)
	{
		if (message.enabled && ShouldLogLevel(level))
		{
			Write(source, DateTime.UtcNow, level, ref message);
		}
	}

	public static void Log(string source, LogLevel level, string message)
	{
		DebugLog instance = Instance;
		if (instance.ShouldLogLevel(level))
		{
			instance.Write(source, DateTime.UtcNow, level, message);
		}
	}

	public static void Log(string source, LogLevel level, [InterpolatedStringHandlerArgument("level")] ref DebugLogInterpolatedStringHandler message)
	{
		DebugLog instance = Instance;
		if (message.enabled && instance.ShouldLogLevel(level))
		{
			instance.Write(source, DateTime.UtcNow, level, ref message);
		}
	}

	private static string[]? GetListEnvVar(string text)
	{
		string text2 = text.Trim();
		if (string.IsNullOrEmpty(text2))
		{
			return null;
		}
		string[] array = text2.Split(listEnvSeparator, StringSplitOptions.RemoveEmptyEntries);
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = array[i].Trim();
		}
		return array;
	}

	private DebugLog()
	{
		recordHoles = Switches.TryGetSwitchEnabled("LogRecordHoles", out var isEnabled) && isEnabled;
		replayQueueLength = 0;
		if (Switches.TryGetSwitchValue("LogReplayQueueLength", out object value))
		{
			replayQueueLength = (value as int?).GetValueOrDefault();
		}
		if (Switches.TryGetSwitchEnabled("LogSpam", out isEnabled) && isEnabled)
		{
			globalFilter |= LogLevelFilter.Spam;
		}
		if (replayQueueLength > 0)
		{
			replayQueue = new ConcurrentQueue<LogMessage>();
		}
		string text = (Switches.TryGetSwitchValue("LogToFile", out value) ? (value as string) : null);
		string[] sourceFilter = null;
		if (Switches.TryGetSwitchValue("LogToFileFilter", out value))
		{
			sourceFilter = ((value is string[] array) ? array : ((!(value is string text2)) ? null : GetListEnvVar(text2)));
		}
		if (text != null)
		{
			TryInitializeLogToFile(text, sourceFilter, globalFilter);
		}
		if (Switches.TryGetSwitchEnabled("LogInMemory", out isEnabled) && isEnabled)
		{
			TryInitializeMemoryLog(globalFilter);
		}
	}

	private void TryInitializeLogToFile(string file, string[]? sourceFilter, LogLevelFilter filter)
	{
		try
		{
			StringComparer comparer = StringComparerEx.FromComparison(StringComparison.OrdinalIgnoreCase);
			if (sourceFilter != null)
			{
				Array.Sort(sourceFilter, (IComparer<string>?)comparer);
			}
			object sync = new object();
			TextWriter writer;
			if (file == "-")
			{
				writer = Console.Out;
			}
			else
			{
				FileStream stream = new FileStream(file, FileMode.Create, FileAccess.Write, FileShare.Write);
				writer = new StreamWriter(stream, Encoding.UTF8)
				{
					AutoFlush = true
				};
			}
			SubscribeCore(filter, delegate(string source, DateTime time, LogLevel level, string msg)
			{
				if (sourceFilter != null && MemoryExtensions.AsSpan(sourceFilter).BinarySearch(source, comparer) < 0)
				{
					return;
				}
				DateTime value = time.ToLocalTime();
				string value2 = $"[{source}]({value}) {level.FastToString()}: {msg}";
				lock (sync)
				{
					writer.WriteLine(value2);
				}
			});
		}
		catch (Exception value3)
		{
			LogLevel logLevel = LogLevel.Error;
			LogLevel level2 = logLevel;
			bool isEnabled;
			DebugLogInterpolatedStringHandler message = new DebugLogInterpolatedStringHandler(61, 1, logLevel, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Exception while trying to initialize writing logs to a file: ");
				message.AppendFormatted(value3);
			}
			Instance.LogCore("DebugLog", level2, ref message);
		}
	}

	private void TryInitializeMemoryLog(LogLevelFilter filter)
	{
		try
		{
			memlogPos = 0;
			memlog = new byte[4096];
			object sync = new object();
			_ = Encoding.UTF8;
			SubscribeCore(filter, delegate(string source, DateTime time, LogLevel level, string msg)
			{
				byte value = (byte)level;
				long ticks = time.Ticks;
				if (source.Length > 255)
				{
					source = source.Substring(0, 255);
				}
				byte b = (byte)source.Length;
				int length = msg.Length;
				int num = 14 + b * 2 + length * 2;
				lock (sync)
				{
					if (memlog.Length - memlogPos < num)
					{
						int num2 = memlog.Length * 4;
						while (num2 - memlogPos < num)
						{
							num2 *= 4;
						}
						Array.Resize(ref memlog, num2);
					}
					ref byte reference = ref MemoryMarshal.GetReference(MemoryExtensions.AsSpan(memlog).Slice(memlogPos));
					int num3 = 0;
					Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num3), value);
					num3++;
					Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num3), ticks);
					num3 += 8;
					Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num3), b);
					num3++;
					Unsafe.CopyBlock(ref Unsafe.Add(ref reference, num3), ref Unsafe.As<char, byte>(ref MemoryMarshal.GetReference(MemoryExtensions.AsSpan(source))), (uint)(b * 2));
					num3 += b * 2;
					Unsafe.WriteUnaligned(ref Unsafe.Add(ref reference, num3), length);
					num3 += 4;
					Unsafe.CopyBlock(ref Unsafe.Add(ref reference, num3), ref Unsafe.As<char, byte>(ref MemoryMarshal.GetReference(MemoryExtensions.AsSpan(msg))), (uint)(length * 2));
					num3 += length * 2;
					memlogPos += num3;
				}
			});
		}
		catch (Exception value2)
		{
			LogLevel logLevel = LogLevel.Error;
			LogLevel level2 = logLevel;
			bool isEnabled;
			DebugLogInterpolatedStringHandler message = new DebugLogInterpolatedStringHandler(45, 1, logLevel, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Exception while initializing the memory log: ");
				message.AppendFormatted(value2);
			}
			Instance.LogCore("DebugLog", level2, ref message);
		}
	}

	private void MaybeReplayTo(LogLevelFilter filter, OnLogMessage del)
	{
		if (replayQueue == null || filter == LogLevelFilter.None)
		{
			return;
		}
		LogMessage[] array = replayQueue.ToArray();
		foreach (LogMessage logMessage in array)
		{
			if (((uint)(1 << (int)logMessage.Level) & (uint)filter) != 0)
			{
				logMessage.ReportTo(del);
			}
		}
	}

	private void MaybeReplayTo(LogLevelFilter filter, OnLogMessageDetailed del)
	{
		if (replayQueue == null || filter == LogLevelFilter.None)
		{
			return;
		}
		LogMessage[] array = replayQueue.ToArray();
		foreach (LogMessage logMessage in array)
		{
			if (((uint)(1 << (int)logMessage.Level) & (uint)filter) != 0)
			{
				logMessage.ReportTo(del);
			}
		}
	}

	public static IDisposable Subscribe(LogLevelFilter filter, OnLogMessage value)
	{
		return Instance.SubscribeCore(filter, value);
	}

	private IDisposable SubscribeCore(LogLevelFilter filter, OnLogMessage value)
	{
		LevelSubscriptions levelSubscriptions;
		LevelSubscriptions value2;
		do
		{
			levelSubscriptions = subscriptions;
			value2 = levelSubscriptions.AddSimple(filter, value);
		}
		while (Interlocked.CompareExchange(ref subscriptions, value2, levelSubscriptions) != levelSubscriptions);
		MaybeReplayTo(filter, value);
		return new LogSubscriptionSimple(this, value, filter);
	}

	public static IDisposable Subscribe(LogLevelFilter filter, OnLogMessageDetailed value)
	{
		return Instance.SubscribeCore(filter, value);
	}

	private IDisposable SubscribeCore(LogLevelFilter filter, OnLogMessageDetailed value)
	{
		LevelSubscriptions levelSubscriptions;
		LevelSubscriptions value2;
		do
		{
			levelSubscriptions = subscriptions;
			value2 = levelSubscriptions.AddDetailed(filter, value);
		}
		while (Interlocked.CompareExchange(ref subscriptions, value2, levelSubscriptions) != levelSubscriptions);
		MaybeReplayTo(filter, value);
		return new LogSubscriptionDetailed(this, value, filter);
	}
}


using System;

public delegate void OnLogMessage(string source, DateTime time, LogLevel level, string message);


using System;

public delegate void OnLogMessageDetailed(string source, DateTime time, LogLevel level, string formattedMessage, ReadOnlyMemory<MessageHole> holes);


using System;
using System.Diagnostics;

private sealed class LogMessage
{
	public string Source { get; private set; }

	public DateTime Time { get; private set; }

	public LogLevel Level { get; private set; }

	public string FormattedMessage { get; private set; }

	public ReadOnlyMemory<MessageHole> FormatHoles { get; private set; }

	public LogMessage(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory<MessageHole> holes)
	{
		Source = source;
		Time = time;
		Level = level;
		FormattedMessage = formatted;
		FormatHoles = holes;
	}

	public void Clear()
	{
		Source = "";
		Time = default(DateTime);
		Level = LogLevel.Spam;
		FormattedMessage = "";
		FormatHoles = default(ReadOnlyMemory<MessageHole>);
	}

	public void Init(string source, DateTime time, LogLevel level, string formatted, ReadOnlyMemory<MessageHole> holes)
	{
		Source = source;
		Time = time;
		Level = level;
		FormattedMessage = formatted;
		FormatHoles = holes;
	}

	public void ReportTo(OnLogMessage del)
	{
		try
		{
			del(Source, Time, Level, FormattedMessage);
		}
		catch (Exception ex)
		{
			Debugger.Log(int.MaxValue, "MonoMod.DebugLog", "Exception caught while reporting to message handler");
			Debugger.Log(int.MaxValue, "MonoMod.DebugLog", ex.ToString());
		}
	}

	public void ReportTo(OnLogMessageDetailed del)
	{
		try
		{
			del(Source, Time, Level, FormattedMessage, FormatHoles);
		}
		catch (Exception ex)
		{
			Debugger.Log(int.MaxValue, "MonoMod.DebugLog", "Exception caught while reporting to message handler");
			Debugger.Log(int.MaxValue, "MonoMod.DebugLog", ex.ToString());
		}
	}
}


using System;
using MonoMod.Utils;

private sealed class LevelSubscriptions
{
	public LogLevelFilter ActiveLevels;

	public LogLevelFilter DetailLevels;

	public readonly OnLogMessage?[] SimpleRegs;

	public readonly OnLogMessageDetailed?[] DetailedRegs;

	private const LogLevelFilter ValidFilter = LogLevelFilter.Spam | LogLevelFilter.Trace | LogLevelFilter.Info | LogLevelFilter.Warning | LogLevelFilter.Error | LogLevelFilter.Assert;

	public static readonly LevelSubscriptions None = new LevelSubscriptions();

	private LevelSubscriptions(LogLevelFilter active, LogLevelFilter detail, OnLogMessage?[] simple, OnLogMessageDetailed?[] detailed)
	{
		ActiveLevels = active | detail;
		DetailLevels = detail;
		SimpleRegs = simple;
		DetailedRegs = detailed;
	}

	private LevelSubscriptions()
	{
		ActiveLevels = LogLevelFilter.None;
		DetailLevels = LogLevelFilter.None;
		SimpleRegs = new OnLogMessage[6];
		DetailedRegs = new OnLogMessageDetailed[SimpleRegs.Length];
	}

	private LevelSubscriptions Clone(bool changingDetail)
	{
		OnLogMessage[] array = SimpleRegs;
		OnLogMessageDetailed[] array2 = DetailedRegs;
		if (!changingDetail)
		{
			array = new OnLogMessage[SimpleRegs.Length];
			Array.Copy(SimpleRegs, array, array.Length);
		}
		else
		{
			array2 = new OnLogMessageDetailed[DetailedRegs.Length];
			Array.Copy(DetailedRegs, array2, array2.Length);
		}
		return new LevelSubscriptions(ActiveLevels, DetailLevels, array, array2);
	}

	private void FixFilters()
	{
		ActiveLevels &= LogLevelFilter.Spam | LogLevelFilter.Trace | LogLevelFilter.Info | LogLevelFilter.Warning | LogLevelFilter.Error | LogLevelFilter.Assert;
		DetailLevels &= LogLevelFilter.Spam | LogLevelFilter.Trace | LogLevelFilter.Info | LogLevelFilter.Warning | LogLevelFilter.Error | LogLevelFilter.Assert;
	}

	public LevelSubscriptions AddSimple(LogLevelFilter filter, OnLogMessage del)
	{
		LevelSubscriptions levelSubscriptions = Clone(changingDetail: false);
		levelSubscriptions.ActiveLevels |= filter;
		for (int i = 0; i < levelSubscriptions.SimpleRegs.Length; i++)
		{
			if (((uint)filter & (uint)(1 << i)) != 0)
			{
				Helpers.EventAdd(ref levelSubscriptions.SimpleRegs[i], del);
			}
		}
		levelSubscriptions.FixFilters();
		return levelSubscriptions;
	}

	public LevelSubscriptions RemoveSimple(LogLevelFilter filter, OnLogMessage del)
	{
		LevelSubscriptions levelSubscriptions = Clone(changingDetail: false);
		for (int i = 0; i < levelSubscriptions.SimpleRegs.Length; i++)
		{
			if (((uint)filter & (uint)(1 << i)) != 0 && Helpers.EventRemove(ref levelSubscriptions.SimpleRegs[i], del) == null)
			{
				levelSubscriptions.ActiveLevels &= (LogLevelFilter)(~(1 << i));
			}
		}
		levelSubscriptions.ActiveLevels |= levelSubscriptions.DetailLevels;
		levelSubscriptions.FixFilters();
		return levelSubscriptions;
	}

	public LevelSubscriptions AddDetailed(LogLevelFilter filter, OnLogMessageDetailed del)
	{
		LevelSubscriptions levelSubscriptions = Clone(changingDetail: true);
		levelSubscriptions.DetailLevels |= filter;
		for (int i = 0; i < levelSubscriptions.DetailedRegs.Length; i++)
		{
			if (((uint)filter & (uint)(1 << i)) != 0)
			{
				Helpers.EventAdd(ref levelSubscriptions.DetailedRegs[i], del);
			}
		}
		levelSubscriptions.ActiveLevels |= levelSubscriptions.DetailLevels;
		levelSubscriptions.FixFilters();
		return levelSubscriptions;
	}

	public LevelSubscriptions RemoveDetailed(LogLevelFilter filter, OnLogMessageDetailed del)
	{
		LevelSubscriptions levelSubscriptions = Clone(changingDetail: true);
		for (int i = 0; i < levelSubscriptions.DetailedRegs.Length; i++)
		{
			if (((uint)filter & (uint)(1 << i)) != 0 && Helpers.EventRemove(ref levelSubscriptions.DetailedRegs[i], del) == null)
			{
				levelSubscriptions.DetailLevels &= (LogLevelFilter)(~(1 << i));
			}
		}
		levelSubscriptions.ActiveLevels |= levelSubscriptions.DetailLevels;
		levelSubscriptions.FixFilters();
		return levelSubscriptions;
	}
}


using System;
using System.Threading;

private sealed class LogSubscriptionSimple : IDisposable
{
	private readonly DebugLog log;

	private readonly OnLogMessage del;

	private readonly LogLevelFilter filter;

	public LogSubscriptionSimple(DebugLog log, OnLogMessage del, LogLevelFilter filter)
	{
		this.log = log;
		this.del = del;
		this.filter = filter;
	}

	public void Dispose()
	{
		LevelSubscriptions subscriptions;
		LevelSubscriptions value;
		do
		{
			subscriptions = log.subscriptions;
			value = subscriptions.RemoveSimple(filter, del);
		}
		while (Interlocked.CompareExchange(ref log.subscriptions, value, subscriptions) != subscriptions);
	}
}


using System;
using System.Threading;

private sealed class LogSubscriptionDetailed : IDisposable
{
	private readonly DebugLog log;

	private readonly OnLogMessageDetailed del;

	private readonly LogLevelFilter filter;

	public LogSubscriptionDetailed(DebugLog log, OnLogMessageDetailed del, LogLevelFilter filter)
	{
		this.log = log;
		this.del = del;
		this.filter = filter;
	}

	public void Dispose()
	{
		LevelSubscriptions subscriptions;
		LevelSubscriptions value;
		do
		{
			subscriptions = log.subscriptions;
			value = subscriptions.RemoveDetailed(filter, del);
		}
		while (Interlocked.CompareExchange(ref log.subscriptions, value, subscriptions) != subscriptions);
	}
}


using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct DebugLogInterpolatedStringHandler
{
	private const int GuessedLengthPerHole = 11;

	private const int MinimumArrayPoolLength = 256;

	private char[]? _arrayToReturnToPool;

	private Span<char> _chars;

	private int _pos;

	private int holeBegin;

	private int holePos;

	private Memory<MessageHole> holes;

	internal readonly bool enabled;

	internal ReadOnlySpan<char> Text => _chars.Slice(0, _pos);

	public DebugLogInterpolatedStringHandler(int literalLength, int formattedCount, bool enabled, bool recordHoles, out bool isEnabled)
	{
		_pos = (holeBegin = (holePos = 0));
		this.enabled = (isEnabled = enabled);
		if (enabled)
		{
			_chars = (_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(GetDefaultLength(literalLength, formattedCount)));
			if (recordHoles)
			{
				holes = new MessageHole[formattedCount];
			}
			else
			{
				holes = default(Memory<MessageHole>);
			}
		}
		else
		{
			_chars = (_arrayToReturnToPool = null);
			holes = default(Memory<MessageHole>);
		}
	}

	public DebugLogInterpolatedStringHandler(int literalLength, int formattedCount, out bool isEnabled)
	{
		DebugLog instance = DebugLog.Instance;
		_pos = (holeBegin = (holePos = 0));
		if (instance.ShouldLog)
		{
			enabled = (isEnabled = true);
			_chars = (_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(GetDefaultLength(literalLength, formattedCount)));
			if (instance.RecordHoles)
			{
				holes = new MessageHole[formattedCount];
			}
			else
			{
				holes = default(Memory<MessageHole>);
			}
		}
		else
		{
			enabled = (isEnabled = false);
			_chars = (_arrayToReturnToPool = null);
			holes = default(Memory<MessageHole>);
		}
	}

	public DebugLogInterpolatedStringHandler(int literalLength, int formattedCount, LogLevel level, out bool isEnabled)
	{
		DebugLog instance = DebugLog.Instance;
		_pos = (holeBegin = (holePos = 0));
		if (instance.ShouldLogLevel(level))
		{
			enabled = (isEnabled = true);
			_chars = (_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(GetDefaultLength(literalLength, formattedCount)));
			if (instance.ShouldLevelRecordHoles(level))
			{
				holes = new MessageHole[formattedCount];
			}
			else
			{
				holes = default(Memory<MessageHole>);
			}
		}
		else
		{
			enabled = (isEnabled = false);
			_chars = (_arrayToReturnToPool = null);
			holes = default(Memory<MessageHole>);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static int GetDefaultLength(int literalLength, int formattedCount)
	{
		return Math.Max(256, literalLength + formattedCount * 11);
	}

	public override string ToString()
	{
		return Text.ToString();
	}

	public string ToStringAndClear()
	{
		string result = Text.ToString();
		Clear();
		return result;
	}

	internal string ToStringAndClear(out ReadOnlyMemory<MessageHole> holes)
	{
		holes = this.holes;
		return ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal void Clear()
	{
		char[] arrayToReturnToPool = _arrayToReturnToPool;
		this = default(DebugLogInterpolatedStringHandler);
		if (arrayToReturnToPool != null)
		{
			ArrayPool<char>.Shared.Return(arrayToReturnToPool);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string value)
	{
		if (value.Length == 1)
		{
			Span<char> chars = _chars;
			int pos = _pos;
			if ((uint)pos < (uint)chars.Length)
			{
				chars[pos] = value[0];
				_pos = pos + 1;
			}
			else
			{
				GrowThenCopyString(value);
			}
		}
		else if (value.Length == 2)
		{
			Span<char> chars2 = _chars;
			int pos2 = _pos;
			if ((uint)pos2 < chars2.Length - 1)
			{
				MemoryExtensions.AsSpan(value).CopyTo(chars2.Slice(pos2));
				_pos = pos2 + 2;
			}
			else
			{
				GrowThenCopyString(value);
			}
		}
		else
		{
			AppendStringDirect(value);
		}
	}

	private void AppendStringDirect(string value)
	{
		if (MemoryExtensions.AsSpan(value).TryCopyTo(_chars.Slice(_pos)))
		{
			_pos += value.Length;
		}
		else
		{
			GrowThenCopyString(value);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void BeginHole()
	{
		holeBegin = _pos;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void EndHole(object? obj, bool reprd)
	{
		EndHole(in obj, reprd);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void EndHole<T>(in T obj, bool reprd)
	{
		if (!holes.IsEmpty)
		{
			holes.Span[holePos++] = (reprd ? new MessageHole(holeBegin, _pos, obj) : new MessageHole(holeBegin, _pos));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? value)
	{
		BeginHole();
		if (value != null && MemoryExtensions.AsSpan(value).TryCopyTo(_chars.Slice(_pos)))
		{
			_pos += value.Length;
		}
		else
		{
			AppendFormattedSlow(value);
		}
		EndHole(in value, reprd: true);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void AppendFormattedSlow(string? value)
	{
		if (value != null)
		{
			EnsureCapacityForAdditionalChars(value.Length);
			MemoryExtensions.AsSpan(value).CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? value, int alignment = 0, string? format = null)
	{
		this.AppendFormatted<string>(value, alignment, format);
	}

	public void AppendFormatted(ReadOnlySpan<char> value)
	{
		BeginHole();
		if (value.TryCopyTo(_chars.Slice(_pos)))
		{
			_pos += value.Length;
		}
		else
		{
			GrowThenCopySpan(value);
		}
		EndHole(null, reprd: false);
	}

	public void AppendFormatted(ReadOnlySpan<char> value, int alignment = 0, string? format = null)
	{
		bool flag = false;
		if (alignment < 0)
		{
			flag = true;
			alignment = -alignment;
		}
		int num = alignment - value.Length;
		if (num <= 0)
		{
			AppendFormatted(value);
			return;
		}
		BeginHole();
		EnsureCapacityForAdditionalChars(value.Length + num);
		if (flag)
		{
			value.CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
			_chars.Slice(_pos, num).Fill(' ');
			_pos += num;
		}
		else
		{
			_chars.Slice(_pos, num).Fill(' ');
			_pos += num;
			value.CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
		}
		EndHole(null, reprd: false);
	}

	public void AppendFormatted<T>(T value)
	{
		if (typeof(T) == typeof(IntPtr))
		{
			AppendFormatted(Unsafe.As<T, IntPtr>(ref value));
			return;
		}
		if (typeof(T) == typeof(UIntPtr))
		{
			AppendFormatted(Unsafe.As<T, UIntPtr>(ref value));
			return;
		}
		BeginHole();
		if (DebugFormatter.CanDebugFormat(in value, out object extraData))
		{
			int wrote;
			while (!DebugFormatter.TryFormatInto(in value, extraData, _chars.Slice(_pos), out wrote))
			{
				Grow();
			}
			_pos += wrote;
			return;
		}
		string text = ((!(value is IFormattable)) ? value?.ToString() : ((IFormattable)(object)value).ToString(null, null));
		if (text != null)
		{
			AppendStringDirect(text);
		}
		EndHole(in value, reprd: true);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(IntPtr value)
	{
		if (IntPtr.Size == 4)
		{
			AppendFormatted((int)value);
		}
		else
		{
			AppendFormatted((long)value);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(IntPtr value, string? format)
	{
		if (IntPtr.Size == 4)
		{
			AppendFormatted((int)value, format);
		}
		else
		{
			AppendFormatted((long)value, format);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(UIntPtr value)
	{
		if (UIntPtr.Size == 4)
		{
			AppendFormatted((uint)value);
		}
		else
		{
			AppendFormatted((ulong)value);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void AppendFormatted(UIntPtr value, string? format)
	{
		if (UIntPtr.Size == 4)
		{
			AppendFormatted((uint)value, format);
		}
		else
		{
			AppendFormatted((ulong)value, format);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		int pos = _pos;
		AppendFormatted(value);
		if (alignment != 0)
		{
			AppendOrInsertAlignmentIfNeeded(pos, alignment);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		if (typeof(T) == typeof(IntPtr))
		{
			AppendFormatted(Unsafe.As<T, IntPtr>(ref value), format);
			return;
		}
		if (typeof(T) == typeof(UIntPtr))
		{
			AppendFormatted(Unsafe.As<T, UIntPtr>(ref value), format);
			return;
		}
		BeginHole();
		if (DebugFormatter.CanDebugFormat(in value, out object extraData))
		{
			int wrote;
			while (!DebugFormatter.TryFormatInto(in value, extraData, _chars.Slice(_pos), out wrote))
			{
				Grow();
			}
			_pos += wrote;
			return;
		}
		string text = ((!(value is IFormattable)) ? value?.ToString() : ((IFormattable)(object)value).ToString(format, null));
		if (text != null)
		{
			AppendStringDirect(text);
		}
		EndHole(in value, reprd: true);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		int pos = _pos;
		AppendFormatted(value, format);
		if (alignment != 0)
		{
			AppendOrInsertAlignmentIfNeeded(pos, alignment);
		}
	}

	private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)
	{
		int num = _pos - startingPos;
		bool flag = false;
		if (alignment < 0)
		{
			flag = true;
			alignment = -alignment;
		}
		int num2 = alignment - num;
		if (num2 > 0)
		{
			EnsureCapacityForAdditionalChars(num2);
			if (flag)
			{
				_chars.Slice(_pos, num2).Fill(' ');
			}
			else
			{
				_chars.Slice(startingPos, num).CopyTo(_chars.Slice(startingPos + num2));
				_chars.Slice(startingPos, num2).Fill(' ');
			}
			_pos += num2;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void EnsureCapacityForAdditionalChars(int additionalChars)
	{
		if (_chars.Length - _pos < additionalChars)
		{
			Grow(additionalChars);
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void GrowThenCopyString(string value)
	{
		Grow(value.Length);
		MemoryExtensions.AsSpan(value).CopyTo(_chars.Slice(_pos));
		_pos += value.Length;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void GrowThenCopySpan(ReadOnlySpan<char> value)
	{
		Grow(value.Length);
		value.CopyTo(_chars.Slice(_pos));
		_pos += value.Length;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void Grow(int additionalChars)
	{
		GrowCore((uint)(_pos + additionalChars));
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private void Grow()
	{
		GrowCore((uint)(_chars.Length + 1));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void GrowCore(uint requiredMinCapacity)
	{
		int minimumLength = (int)MathEx.Clamp(Math.Max(requiredMinCapacity, Math.Min((uint)(_chars.Length * 2), uint.MaxValue)), 256u, 2147483647u);
		char[] array = ArrayPool<char>.Shared.Rent(minimumLength);
		_chars.Slice(0, _pos).CopyTo(array);
		char[] arrayToReturnToPool = _arrayToReturnToPool;
		_chars = (_arrayToReturnToPool = array);
		if (arrayToReturnToPool != null)
		{
			ArrayPool<char>.Shared.Return(arrayToReturnToPool);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct FormatIntoInterpolatedStringHandler
{
	private readonly Span<char> _chars;

	internal int pos;

	internal bool incomplete;

	public FormatIntoInterpolatedStringHandler(int literalLen, int numHoles, Span<char> into, out bool enabled)
	{
		_chars = into;
		pos = 0;
		if (into.Length < literalLen)
		{
			incomplete = true;
			enabled = false;
		}
		else
		{
			incomplete = false;
			enabled = true;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool AppendLiteral(string value)
	{
		if (value.Length == 1)
		{
			Span<char> chars = _chars;
			int num = pos;
			if ((uint)num < (uint)chars.Length)
			{
				chars[num] = value[0];
				pos = num + 1;
				return true;
			}
			incomplete = true;
			return false;
		}
		if (value.Length == 2)
		{
			Span<char> chars2 = _chars;
			int num2 = pos;
			if ((uint)num2 < chars2.Length - 1)
			{
				MemoryExtensions.AsSpan(value).CopyTo(chars2.Slice(num2));
				pos = num2 + 2;
				return true;
			}
			incomplete = true;
			return false;
		}
		return AppendStringDirect(value);
	}

	private bool AppendStringDirect(string value)
	{
		if (MemoryExtensions.AsSpan(value).TryCopyTo(_chars.Slice(pos)))
		{
			pos += value.Length;
			return true;
		}
		incomplete = true;
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool AppendFormatted(string? value)
	{
		if (value == null)
		{
			return true;
		}
		if (MemoryExtensions.AsSpan(value).TryCopyTo(_chars.Slice(pos)))
		{
			pos += value.Length;
			return true;
		}
		incomplete = true;
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool AppendFormatted(string? value, int alignment = 0, string? format = null)
	{
		return this.AppendFormatted<string>(value, alignment, format);
	}

	public bool AppendFormatted(ReadOnlySpan<char> value)
	{
		if (value.TryCopyTo(_chars.Slice(pos)))
		{
			pos += value.Length;
			return true;
		}
		incomplete = true;
		return false;
	}

	public bool AppendFormatted(ReadOnlySpan<char> value, int alignment = 0, string? format = null)
	{
		bool flag = false;
		if (alignment < 0)
		{
			flag = true;
			alignment = -alignment;
		}
		int num = alignment - value.Length;
		if (num <= 0)
		{
			return AppendFormatted(value);
		}
		if (_chars.Slice(pos).Length < value.Length + num)
		{
			incomplete = true;
			return false;
		}
		if (flag)
		{
			value.CopyTo(_chars.Slice(pos));
			pos += value.Length;
			_chars.Slice(pos, num).Fill(' ');
			pos += num;
		}
		else
		{
			_chars.Slice(pos, num).Fill(' ');
			pos += num;
			value.CopyTo(_chars.Slice(pos));
			pos += value.Length;
		}
		return true;
	}

	public bool AppendFormatted<T>(T value)
	{
		if (typeof(T) == typeof(IntPtr))
		{
			return AppendFormatted(Unsafe.As<T, IntPtr>(ref value));
		}
		if (typeof(T) == typeof(UIntPtr))
		{
			return AppendFormatted(Unsafe.As<T, UIntPtr>(ref value));
		}
		if (DebugFormatter.CanDebugFormat(in value, out object extraData))
		{
			if (!DebugFormatter.TryFormatInto(in value, extraData, _chars.Slice(pos), out var wrote))
			{
				incomplete = true;
				return false;
			}
			pos += wrote;
			return true;
		}
		string text = ((!(value is IFormattable)) ? value?.ToString() : ((IFormattable)(object)value).ToString(null, null));
		if (text != null)
		{
			return AppendStringDirect(text);
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool AppendFormatted(IntPtr value)
	{
		if (IntPtr.Size == 4)
		{
			return AppendFormatted((int)value);
		}
		return AppendFormatted((long)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool AppendFormatted(IntPtr value, string? format)
	{
		if (IntPtr.Size == 4)
		{
			return AppendFormatted((int)value, format);
		}
		return AppendFormatted((long)value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool AppendFormatted(UIntPtr value)
	{
		if (UIntPtr.Size == 4)
		{
			return AppendFormatted((uint)value);
		}
		return AppendFormatted((ulong)value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool AppendFormatted(UIntPtr value, string? format)
	{
		if (UIntPtr.Size == 4)
		{
			return AppendFormatted((uint)value, format);
		}
		return AppendFormatted((ulong)value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool AppendFormatted<T>(T value, int alignment)
	{
		int startingPos = pos;
		if (!AppendFormatted(value))
		{
			return false;
		}
		if (alignment != 0)
		{
			return AppendOrInsertAlignmentIfNeeded(startingPos, alignment);
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool AppendFormatted<T>(T value, string? format)
	{
		if (typeof(T) == typeof(IntPtr))
		{
			return AppendFormatted(Unsafe.As<T, IntPtr>(ref value), format);
		}
		if (typeof(T) == typeof(UIntPtr))
		{
			return AppendFormatted(Unsafe.As<T, UIntPtr>(ref value), format);
		}
		if (DebugFormatter.CanDebugFormat(in value, out object extraData))
		{
			if (!DebugFormatter.TryFormatInto(in value, extraData, _chars.Slice(pos), out var wrote))
			{
				incomplete = true;
				return false;
			}
			pos += wrote;
			return true;
		}
		string text = ((!(value is IFormattable)) ? value?.ToString() : ((IFormattable)(object)value).ToString(format, null));
		if (text != null)
		{
			return AppendStringDirect(text);
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool AppendFormatted<T>(T value, int alignment, string? format)
	{
		int startingPos = pos;
		if (!AppendFormatted(value, format))
		{
			return false;
		}
		if (alignment != 0)
		{
			return AppendOrInsertAlignmentIfNeeded(startingPos, alignment);
		}
		return true;
	}

	private bool AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)
	{
		int num = pos - startingPos;
		bool flag = false;
		if (alignment < 0)
		{
			flag = true;
			alignment = -alignment;
		}
		int num2 = alignment - num;
		if (num2 > 0)
		{
			if (_chars.Slice(pos).Length < num2)
			{
				incomplete = true;
				return false;
			}
			if (flag)
			{
				_chars.Slice(pos, num2).Fill(' ');
			}
			else
			{
				_chars.Slice(startingPos, num).CopyTo(_chars.Slice(startingPos + num2));
				_chars.Slice(startingPos, num2).Fill(' ');
			}
			pos += num2;
		}
		return true;
	}
}


using System;

internal interface IDebugFormattable
{
	bool TryFormatInto(Span<char> span, out int wrote);
}


internal enum LogLevel
{
	Spam,
	Trace,
	Info,
	Warning,
	Error,
	Assert
}


using System;

[Flags]
internal enum LogLevelFilter
{
	None = 0,
	Spam = 1,
	Trace = 2,
	Info = 4,
	Warning = 8,
	Error = 0x10,
	Assert = 0x20,
	DefaultFilter = -2
}


using System;
using MonoMod.Logs;

internal static class LogLevelExtensions
{
	public const LogLevel MaxLevel = LogLevel.Assert;

	public static string FastToString(this LogLevel level, IFormatProvider? provider = null)
	{
		switch (level)
		{
		case LogLevel.Spam:
			return "Spam";
		case LogLevel.Trace:
			return "Trace";
		case LogLevel.Info:
			return "Info";
		case LogLevel.Warning:
			return "Warning";
		case LogLevel.Error:
			return "Error";
		case LogLevel.Assert:
			return "Assert";
		default:
		{
			int num = (int)level;
			return num.ToString(provider);
		}
		}
	}
}


using System;

[AttributeUsage(AttributeTargets.Method)]
internal sealed class GetFastDelegateInvokersArrayAttribute : Attribute
{
	public int MaxParams { get; }

	public GetFastDelegateInvokersArrayAttribute(int maxParams)
	{
		MaxParams = maxParams;
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using Mono.Cecil.Cil;
using MonoMod.Cil;
using MonoMod.Utils;

internal static class FastDelegateInvokers
{
	private delegate void VoidVal1<T0>(T0 _0);

	private delegate TResult TypeVal1<TResult, T0>(T0 _0);

	private delegate void VoidRef1<T0>(ref T0 _0);

	private delegate TResult TypeRef1<TResult, T0>(ref T0 _0);

	private delegate void VoidVal2<T0, T1>(T0 _0, T1 _1);

	private delegate TResult TypeVal2<TResult, T0, T1>(T0 _0, T1 _1);

	private delegate void VoidRef2<T0, T1>(ref T0 _0, T1 _1);

	private delegate TResult TypeRef2<TResult, T0, T1>(ref T0 _0, T1 _1);

	private delegate void VoidVal3<T0, T1, T2>(T0 _0, T1 _1, T2 _2);

	private delegate TResult TypeVal3<TResult, T0, T1, T2>(T0 _0, T1 _1, T2 _2);

	private delegate void VoidRef3<T0, T1, T2>(ref T0 _0, T1 _1, T2 _2);

	private delegate TResult TypeRef3<TResult, T0, T1, T2>(ref T0 _0, T1 _1, T2 _2);

	private delegate void VoidVal4<T0, T1, T2, T3>(T0 _0, T1 _1, T2 _2, T3 _3);

	private delegate TResult TypeVal4<TResult, T0, T1, T2, T3>(T0 _0, T1 _1, T2 _2, T3 _3);

	private delegate void VoidRef4<T0, T1, T2, T3>(ref T0 _0, T1 _1, T2 _2, T3 _3);

	private delegate TResult TypeRef4<TResult, T0, T1, T2, T3>(ref T0 _0, T1 _1, T2 _2, T3 _3);

	private delegate void VoidVal5<T0, T1, T2, T3, T4>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);

	private delegate TResult TypeVal5<TResult, T0, T1, T2, T3, T4>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);

	private delegate void VoidRef5<T0, T1, T2, T3, T4>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);

	private delegate TResult TypeRef5<TResult, T0, T1, T2, T3, T4>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);

	private delegate void VoidVal6<T0, T1, T2, T3, T4, T5>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);

	private delegate TResult TypeVal6<TResult, T0, T1, T2, T3, T4, T5>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);

	private delegate void VoidRef6<T0, T1, T2, T3, T4, T5>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);

	private delegate TResult TypeRef6<TResult, T0, T1, T2, T3, T4, T5>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);

	private delegate void VoidVal7<T0, T1, T2, T3, T4, T5, T6>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);

	private delegate TResult TypeVal7<TResult, T0, T1, T2, T3, T4, T5, T6>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);

	private delegate void VoidRef7<T0, T1, T2, T3, T4, T5, T6>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);

	private delegate TResult TypeRef7<TResult, T0, T1, T2, T3, T4, T5, T6>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);

	private delegate void VoidVal8<T0, T1, T2, T3, T4, T5, T6, T7>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);

	private delegate TResult TypeVal8<TResult, T0, T1, T2, T3, T4, T5, T6, T7>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);

	private delegate void VoidRef8<T0, T1, T2, T3, T4, T5, T6, T7>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);

	private delegate TResult TypeRef8<TResult, T0, T1, T2, T3, T4, T5, T6, T7>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);

	private delegate void VoidVal9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);

	private delegate TResult TypeVal9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);

	private delegate void VoidRef9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);

	private delegate TResult TypeRef9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);

	private delegate void VoidVal10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);

	private delegate TResult TypeVal10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);

	private delegate void VoidRef10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);

	private delegate TResult TypeRef10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);

	private delegate void VoidVal11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);

	private delegate TResult TypeVal11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);

	private delegate void VoidRef11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);

	private delegate TResult TypeRef11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);

	private delegate void VoidVal12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);

	private delegate TResult TypeVal12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);

	private delegate void VoidRef12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);

	private delegate TResult TypeRef12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);

	private delegate void VoidVal13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);

	private delegate TResult TypeVal13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);

	private delegate void VoidRef13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);

	private delegate TResult TypeRef13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);

	private delegate void VoidVal14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);

	private delegate TResult TypeVal14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);

	private delegate void VoidRef14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);

	private delegate TResult TypeRef14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);

	private delegate void VoidVal15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);

	private delegate TResult TypeVal15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);

	private delegate void VoidRef15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);

	private delegate TResult TypeRef15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);

	private delegate void VoidVal16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);

	private delegate TResult TypeVal16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);

	private delegate void VoidRef16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);

	private delegate TResult TypeRef16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);

	private static readonly (MethodInfo, Type)[] invokers = GetInvokers();

	private const int MaxFastInvokerParams = 16;

	private static readonly ConditionalWeakTable<Type, Tuple<MethodInfo?, Type>> invokerCache = new ConditionalWeakTable<Type, Tuple<MethodInfo, Type>>();

	[GetFastDelegateInvokersArray(16)]
	private static (MethodInfo, Type)[] GetInvokers()
	{
		return new(MethodInfo, Type)[64]
		{
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal1", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal1<>)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal1", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal1<, >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef1", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef1<>)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef1", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef1<, >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal2", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal2<, >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal2", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal2<, , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef2", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef2<, >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef2", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef2<, , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal3", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal3<, , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal3", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal3<, , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef3", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef3<, , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef3", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef3<, , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal4", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal4<, , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal4", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal4<, , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef4", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef4<, , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef4", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef4<, , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal5", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal5<, , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal5", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal5<, , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef5", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef5<, , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef5", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef5<, , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal6", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal6<, , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal6", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal6<, , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef6", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef6<, , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef6", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef6<, , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal7", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal7<, , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal7", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal7<, , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef7", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef7<, , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef7", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef7<, , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal8", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal8<, , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal8", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal8<, , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef8", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef8<, , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef8", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef8<, , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal9", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal9<, , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal9", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal9<, , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef9", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef9<, , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef9", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef9<, , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal10", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal10<, , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal10", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal10<, , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef10", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef10<, , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef10", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef10<, , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal11", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal11<, , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal11", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal11<, , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef11", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef11<, , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef11", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef11<, , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal12", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal12<, , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal12", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal12<, , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef12", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef12<, , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef12", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef12<, , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal13", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal13<, , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal13", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal13<, , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef13", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef13<, , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef13", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef13<, , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal14", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal14<, , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal14", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal14<, , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef14", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef14<, , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef14", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef14<, , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal15", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal15<, , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal15", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal15<, , , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef15", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef15<, , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef15", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef15<, , , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidVal16", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidVal16<, , , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeVal16", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeVal16<, , , , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeVoidRef16", BindingFlags.Static | BindingFlags.NonPublic), typeof(VoidRef16<, , , , , , , , , , , , , , , >)),
			(typeof(FastDelegateInvokers).GetMethod("InvokeTypeRef16", BindingFlags.Static | BindingFlags.NonPublic), typeof(TypeRef16<, , , , , , , , , , , , , , , , >))
		};
	}

	private static (MethodInfo Invoker, Type Delegate)? TryGetInvokerForSig(MethodSignature sig)
	{
		if (sig.ParameterCount == 0)
		{
			return null;
		}
		if (sig.ParameterCount > 16)
		{
			return null;
		}
		if (sig.ReturnType.IsByRef || sig.ReturnType.IsByRefLike())
		{
			return null;
		}
		if (sig.FirstParameter.IsByRefLike())
		{
			return null;
		}
		if (sig.Parameters.Skip(1).Any((Type t) => t.IsByRef || t.IsByRefLike()))
		{
			return null;
		}
		int num = 0;
		num |= ((sig.ReturnType != typeof(void)) ? 1 : 0);
		num |= (sig.FirstParameter.IsByRef ? 2 : 0);
		num |= sig.ParameterCount - 1 << 2;
		(MethodInfo, Type) tuple = invokers[num];
		MethodInfo item = tuple.Item1;
		Type item2 = tuple.Item2;
		Type[] array = new Type[sig.ParameterCount + (num & 1)];
		int num2 = 0;
		if ((num & 1) != 0)
		{
			array[num2++] = sig.ReturnType;
		}
		foreach (Type parameter in sig.Parameters)
		{
			Type type = parameter;
			if (type.IsByRef)
			{
				type = type.GetElementType();
			}
			array[num2++] = type;
		}
		Helpers.Assert(num2 == array.Length, null, "i == typeParams.Length");
		return (item.MakeGenericMethod(array), item2.MakeGenericType(array));
	}

	public static (MethodInfo Invoker, Type Delegate)? GetDelegateInvoker(Type delegateType)
	{
		Helpers.ThrowIfArgumentNull(delegateType, "delegateType");
		if (!typeof(Delegate).IsAssignableFrom(delegateType))
		{
			throw new ArgumentException("Argument not a delegate type", "delegateType");
		}
		Tuple<MethodInfo, Type> value = invokerCache.GetValue(delegateType, delegate(Type delegateType)
		{
			MethodInfo method = delegateType.GetMethod("Invoke");
			MethodSignature methodSignature = MethodSignature.ForMethod(method, ignoreThis: true);
			if (methodSignature.ParameterCount == 0)
			{
				return new Tuple<MethodInfo, Type>(null, delegateType);
			}
			(MethodInfo, Type)? tuple = TryGetInvokerForSig(methodSignature);
			if (tuple.HasValue)
			{
				(MethodInfo, Type) valueOrDefault = tuple.GetValueOrDefault();
				return new Tuple<MethodInfo, Type>(valueOrDefault.Item1, valueOrDefault.Item2);
			}
			Type[] array = new Type[methodSignature.ParameterCount + 1];
			int num = 0;
			foreach (Type parameter in methodSignature.Parameters)
			{
				array[num++] = parameter;
			}
			array[methodSignature.ParameterCount] = delegateType;
			using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition("MMIL:Invoke<" + method.DeclaringType?.FullName + ">", method.ReturnType, array);
			ILProcessor iLProcessor = dynamicMethodDefinition.GetILProcessor();
			iLProcessor.Emit(OpCodes.Ldarg, methodSignature.ParameterCount);
			for (num = 0; num < methodSignature.ParameterCount; num++)
			{
				iLProcessor.Emit(OpCodes.Ldarg, num);
			}
			iLProcessor.Emit(OpCodes.Callvirt, method);
			iLProcessor.Emit(OpCodes.Ret);
			return new Tuple<MethodInfo, Type>(dynamicMethodDefinition.Generate(), delegateType);
		});
		if ((object)value.Item1 == null)
		{
			return null;
		}
		return (value.Item1, value.Item2);
	}

	private static void InvokeVoidVal1<T0>(T0 _0, VoidVal1<T0> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0);
	}

	private static TResult InvokeTypeVal1<TResult, T0>(T0 _0, TypeVal1<TResult, T0> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0);
	}

	private static void InvokeVoidRef1<T0>(ref T0 _0, VoidRef1<T0> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0);
	}

	private static TResult InvokeTypeRef1<TResult, T0>(ref T0 _0, TypeRef1<TResult, T0> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0);
	}

	private static void InvokeVoidVal2<T0, T1>(T0 _0, T1 _1, VoidVal2<T0, T1> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1);
	}

	private static TResult InvokeTypeVal2<TResult, T0, T1>(T0 _0, T1 _1, TypeVal2<TResult, T0, T1> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1);
	}

	private static void InvokeVoidRef2<T0, T1>(ref T0 _0, T1 _1, VoidRef2<T0, T1> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1);
	}

	private static TResult InvokeTypeRef2<TResult, T0, T1>(ref T0 _0, T1 _1, TypeRef2<TResult, T0, T1> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1);
	}

	private static void InvokeVoidVal3<T0, T1, T2>(T0 _0, T1 _1, T2 _2, VoidVal3<T0, T1, T2> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2);
	}

	private static TResult InvokeTypeVal3<TResult, T0, T1, T2>(T0 _0, T1 _1, T2 _2, TypeVal3<TResult, T0, T1, T2> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2);
	}

	private static void InvokeVoidRef3<T0, T1, T2>(ref T0 _0, T1 _1, T2 _2, VoidRef3<T0, T1, T2> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2);
	}

	private static TResult InvokeTypeRef3<TResult, T0, T1, T2>(ref T0 _0, T1 _1, T2 _2, TypeRef3<TResult, T0, T1, T2> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2);
	}

	private static void InvokeVoidVal4<T0, T1, T2, T3>(T0 _0, T1 _1, T2 _2, T3 _3, VoidVal4<T0, T1, T2, T3> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3);
	}

	private static TResult InvokeTypeVal4<TResult, T0, T1, T2, T3>(T0 _0, T1 _1, T2 _2, T3 _3, TypeVal4<TResult, T0, T1, T2, T3> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3);
	}

	private static void InvokeVoidRef4<T0, T1, T2, T3>(ref T0 _0, T1 _1, T2 _2, T3 _3, VoidRef4<T0, T1, T2, T3> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3);
	}

	private static TResult InvokeTypeRef4<TResult, T0, T1, T2, T3>(ref T0 _0, T1 _1, T2 _2, T3 _3, TypeRef4<TResult, T0, T1, T2, T3> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3);
	}

	private static void InvokeVoidVal5<T0, T1, T2, T3, T4>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, VoidVal5<T0, T1, T2, T3, T4> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4);
	}

	private static TResult InvokeTypeVal5<TResult, T0, T1, T2, T3, T4>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, TypeVal5<TResult, T0, T1, T2, T3, T4> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4);
	}

	private static void InvokeVoidRef5<T0, T1, T2, T3, T4>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, VoidRef5<T0, T1, T2, T3, T4> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4);
	}

	private static TResult InvokeTypeRef5<TResult, T0, T1, T2, T3, T4>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, TypeRef5<TResult, T0, T1, T2, T3, T4> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4);
	}

	private static void InvokeVoidVal6<T0, T1, T2, T3, T4, T5>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, VoidVal6<T0, T1, T2, T3, T4, T5> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5);
	}

	private static TResult InvokeTypeVal6<TResult, T0, T1, T2, T3, T4, T5>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, TypeVal6<TResult, T0, T1, T2, T3, T4, T5> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5);
	}

	private static void InvokeVoidRef6<T0, T1, T2, T3, T4, T5>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, VoidRef6<T0, T1, T2, T3, T4, T5> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5);
	}

	private static TResult InvokeTypeRef6<TResult, T0, T1, T2, T3, T4, T5>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, TypeRef6<TResult, T0, T1, T2, T3, T4, T5> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5);
	}

	private static void InvokeVoidVal7<T0, T1, T2, T3, T4, T5, T6>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, VoidVal7<T0, T1, T2, T3, T4, T5, T6> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6);
	}

	private static TResult InvokeTypeVal7<TResult, T0, T1, T2, T3, T4, T5, T6>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, TypeVal7<TResult, T0, T1, T2, T3, T4, T5, T6> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6);
	}

	private static void InvokeVoidRef7<T0, T1, T2, T3, T4, T5, T6>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, VoidRef7<T0, T1, T2, T3, T4, T5, T6> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6);
	}

	private static TResult InvokeTypeRef7<TResult, T0, T1, T2, T3, T4, T5, T6>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, TypeRef7<TResult, T0, T1, T2, T3, T4, T5, T6> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6);
	}

	private static void InvokeVoidVal8<T0, T1, T2, T3, T4, T5, T6, T7>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, VoidVal8<T0, T1, T2, T3, T4, T5, T6, T7> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7);
	}

	private static TResult InvokeTypeVal8<TResult, T0, T1, T2, T3, T4, T5, T6, T7>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, TypeVal8<TResult, T0, T1, T2, T3, T4, T5, T6, T7> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7);
	}

	private static void InvokeVoidRef8<T0, T1, T2, T3, T4, T5, T6, T7>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, VoidRef8<T0, T1, T2, T3, T4, T5, T6, T7> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7);
	}

	private static TResult InvokeTypeRef8<TResult, T0, T1, T2, T3, T4, T5, T6, T7>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, TypeRef8<TResult, T0, T1, T2, T3, T4, T5, T6, T7> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7);
	}

	private static void InvokeVoidVal9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, VoidVal9<T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8);
	}

	private static TResult InvokeTypeVal9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, TypeVal9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8);
	}

	private static void InvokeVoidRef9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, VoidRef9<T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8);
	}

	private static TResult InvokeTypeRef9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, TypeRef9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8);
	}

	private static void InvokeVoidVal10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, VoidVal10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9);
	}

	private static TResult InvokeTypeVal10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, TypeVal10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9);
	}

	private static void InvokeVoidRef10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, VoidRef10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9);
	}

	private static TResult InvokeTypeRef10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, TypeRef10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9);
	}

	private static void InvokeVoidVal11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, VoidVal11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10);
	}

	private static TResult InvokeTypeVal11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, TypeVal11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10);
	}

	private static void InvokeVoidRef11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, VoidRef11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10);
	}

	private static TResult InvokeTypeRef11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, TypeRef11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10);
	}

	private static void InvokeVoidVal12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, VoidVal12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11);
	}

	private static TResult InvokeTypeVal12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, TypeVal12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11);
	}

	private static void InvokeVoidRef12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, VoidRef12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11);
	}

	private static TResult InvokeTypeRef12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, TypeRef12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11);
	}

	private static void InvokeVoidVal13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, VoidVal13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12);
	}

	private static TResult InvokeTypeVal13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, TypeVal13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12);
	}

	private static void InvokeVoidRef13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, VoidRef13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12);
	}

	private static TResult InvokeTypeRef13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, TypeRef13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12);
	}

	private static void InvokeVoidVal14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, VoidVal14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13);
	}

	private static TResult InvokeTypeVal14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, TypeVal14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13);
	}

	private static void InvokeVoidRef14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, VoidRef14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13);
	}

	private static TResult InvokeTypeRef14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, TypeRef14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13);
	}

	private static void InvokeVoidVal15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, VoidVal15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14);
	}

	private static TResult InvokeTypeVal15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, TypeVal15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14);
	}

	private static void InvokeVoidRef15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, VoidRef15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14);
	}

	private static TResult InvokeTypeRef15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, TypeRef15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14);
	}

	private static void InvokeVoidVal16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, VoidVal16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
	{
		Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15);
	}

	private static TResult InvokeTypeVal16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, TypeVal16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
	{
		return Helpers.ThrowIfNull(del, "del")(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15);
	}

	private static void InvokeVoidRef16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, VoidRef16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
	{
		Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15);
	}

	private static TResult InvokeTypeRef16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15, TypeRef16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> del)
	{
		return Helpers.ThrowIfNull(del, "del")(ref _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15);
	}
}


private delegate void VoidVal1<T0>(T0 _0);


private delegate TResult TypeVal1<TResult, T0>(T0 _0);


private delegate void VoidRef1<T0>(ref T0 _0);


private delegate TResult TypeRef1<TResult, T0>(ref T0 _0);


private delegate void VoidVal2<T0, T1>(T0 _0, T1 _1);


private delegate TResult TypeVal2<TResult, T0, T1>(T0 _0, T1 _1);


private delegate void VoidRef2<T0, T1>(ref T0 _0, T1 _1);


private delegate TResult TypeRef2<TResult, T0, T1>(ref T0 _0, T1 _1);


private delegate void VoidVal3<T0, T1, T2>(T0 _0, T1 _1, T2 _2);


private delegate TResult TypeVal3<TResult, T0, T1, T2>(T0 _0, T1 _1, T2 _2);


private delegate void VoidRef3<T0, T1, T2>(ref T0 _0, T1 _1, T2 _2);


private delegate TResult TypeRef3<TResult, T0, T1, T2>(ref T0 _0, T1 _1, T2 _2);


private delegate void VoidVal4<T0, T1, T2, T3>(T0 _0, T1 _1, T2 _2, T3 _3);


private delegate TResult TypeVal4<TResult, T0, T1, T2, T3>(T0 _0, T1 _1, T2 _2, T3 _3);


private delegate void VoidRef4<T0, T1, T2, T3>(ref T0 _0, T1 _1, T2 _2, T3 _3);


private delegate TResult TypeRef4<TResult, T0, T1, T2, T3>(ref T0 _0, T1 _1, T2 _2, T3 _3);


private delegate void VoidVal5<T0, T1, T2, T3, T4>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);


private delegate TResult TypeVal5<TResult, T0, T1, T2, T3, T4>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);


private delegate void VoidRef5<T0, T1, T2, T3, T4>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);


private delegate TResult TypeRef5<TResult, T0, T1, T2, T3, T4>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4);


private delegate void VoidVal6<T0, T1, T2, T3, T4, T5>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);


private delegate TResult TypeVal6<TResult, T0, T1, T2, T3, T4, T5>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);


private delegate void VoidRef6<T0, T1, T2, T3, T4, T5>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);


private delegate TResult TypeRef6<TResult, T0, T1, T2, T3, T4, T5>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5);


private delegate void VoidVal7<T0, T1, T2, T3, T4, T5, T6>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);


private delegate TResult TypeVal7<TResult, T0, T1, T2, T3, T4, T5, T6>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);


private delegate void VoidRef7<T0, T1, T2, T3, T4, T5, T6>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);


private delegate TResult TypeRef7<TResult, T0, T1, T2, T3, T4, T5, T6>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6);


private delegate void VoidVal8<T0, T1, T2, T3, T4, T5, T6, T7>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);


private delegate TResult TypeVal8<TResult, T0, T1, T2, T3, T4, T5, T6, T7>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);


private delegate void VoidRef8<T0, T1, T2, T3, T4, T5, T6, T7>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);


private delegate TResult TypeRef8<TResult, T0, T1, T2, T3, T4, T5, T6, T7>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7);


private delegate void VoidVal9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);


private delegate TResult TypeVal9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);


private delegate void VoidRef9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);


private delegate TResult TypeRef9<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8);


private delegate void VoidVal10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);


private delegate TResult TypeVal10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);


private delegate void VoidRef10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);


private delegate TResult TypeRef10<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9);


private delegate void VoidVal11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);


private delegate TResult TypeVal11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);


private delegate void VoidRef11<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);


private delegate TResult TypeRef11<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10);


private delegate void VoidVal12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);


private delegate TResult TypeVal12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);


private delegate void VoidRef12<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);


private delegate TResult TypeRef12<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11);


private delegate void VoidVal13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);


private delegate TResult TypeVal13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);


private delegate void VoidRef13<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);


private delegate TResult TypeRef13<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12);


private delegate void VoidVal14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);


private delegate TResult TypeVal14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);


private delegate void VoidRef14<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);


private delegate TResult TypeRef14<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13);


private delegate void VoidVal15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);


private delegate TResult TypeVal15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);


private delegate void VoidRef15<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);


private delegate TResult TypeRef15<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14);


private delegate void VoidVal16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);


private delegate TResult TypeVal16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);


private delegate void VoidRef16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);


private delegate TResult TypeRef16<TResult, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(ref T0 _0, T1 _1, T2 _2, T3 _3, T4 _4, T5 _5, T6 _6, T7 _7, T8 _8, T9 _9, T10 _10, T11 _11, T12 _12, T13 _13, T14 _14, T15 _15);


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;
using MonoMod.Cil;
using MonoMod.Utils;

internal class ILContext : IDisposable
{
	public delegate void Manipulator(ILContext il);

	internal List<ILLabel> _Labels = new List<ILLabel>();

	private bool disposedValue;

	private readonly List<DataScope<DynamicReferenceCell>> managedObjectRefs = new List<DataScope<DynamicReferenceCell>>();

	public MethodDefinition Method { get; private set; }

	public ILProcessor IL { get; private set; }

	public Mono.Cecil.Cil.MethodBody Body => Method.Body;

	public ModuleDefinition Module => Method.Module;

	public Mono.Collections.Generic.Collection<Instruction> Instrs => Body.Instructions;

	public System.Collections.ObjectModel.ReadOnlyCollection<ILLabel> Labels => _Labels.AsReadOnly();

	public bool IsReadOnly => IL == null;

	public event Action? OnDispose;

	public ILContext(MethodDefinition method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		Method = method;
		IL = method.Body.GetILProcessor();
	}

	public void Invoke(Manipulator manip)
	{
		Helpers.ThrowIfArgumentNull(manip, "manip");
		if (IsReadOnly)
		{
			throw new InvalidOperationException();
		}
		foreach (Instruction instr in Instrs)
		{
			if (instr.Operand is Instruction target)
			{
				instr.Operand = new ILLabel(this, target);
			}
			else if (instr.Operand is Instruction[] source)
			{
				instr.Operand = source.Select((Instruction t) => new ILLabel(this, t)).ToArray();
			}
		}
		manip(this);
		if (IsReadOnly)
		{
			return;
		}
		foreach (Instruction instr2 in Instrs)
		{
			if (instr2.Operand is ILLabel iLLabel)
			{
				instr2.Operand = iLLabel.Target;
			}
			else if (instr2.Operand is ILLabel[] source2)
			{
				instr2.Operand = source2.Select((ILLabel l) => l.Target).ToArray();
			}
		}
		Method.FixShortLongOps();
	}

	public void MakeReadOnly()
	{
		Method = null;
		IL = null;
		_Labels.Clear();
		_Labels.Capacity = 0;
	}

	[Obsolete("Use new ILCursor(il).Goto(index)")]
	public ILCursor At(int index)
	{
		return new ILCursor(this).Goto(index);
	}

	[Obsolete("Use new ILCursor(il).Goto(index)")]
	public ILCursor At(ILLabel label)
	{
		return new ILCursor(this).GotoLabel(label);
	}

	[Obsolete("Use new ILCursor(il).Goto(index)")]
	public ILCursor At(Instruction instr)
	{
		return new ILCursor(this).Goto(instr);
	}

	public FieldReference Import(FieldInfo field)
	{
		return Module.ImportReference(field);
	}

	public MethodReference Import(MethodBase method)
	{
		return Module.ImportReference(method);
	}

	public TypeReference Import(Type type)
	{
		return Module.ImportReference(type);
	}

	public ILLabel DefineLabel()
	{
		return new ILLabel(this);
	}

	public ILLabel DefineLabel(Instruction target)
	{
		return new ILLabel(this, target);
	}

	public int IndexOf(Instruction? instr)
	{
		if (instr == null)
		{
			return Instrs.Count;
		}
		int num = Instrs.IndexOf(instr);
		if (num != -1)
		{
			return num;
		}
		return Instrs.Count;
	}

	public IEnumerable<ILLabel> GetIncomingLabels(Instruction? instr)
	{
		return _Labels.Where((ILLabel l) => l.Target == instr);
	}

	public int AddReference<T>(in T? value)
	{
		int count = managedObjectRefs.Count;
		DynamicReferenceCell cellRef;
		DataScope<DynamicReferenceCell> item = DynamicReferenceManager.AllocReference(in value, out cellRef);
		managedObjectRefs.Add(item);
		return count;
	}

	public T? GetReference<T>(int id)
	{
		if (id < 0 || id >= managedObjectRefs.Count)
		{
			throw new ArgumentOutOfRangeException("id");
		}
		return DynamicReferenceManager.GetValue<T>(managedObjectRefs[id].Data);
	}

	public void SetReference<T>(int id, in T? value)
	{
		if (id < 0 || id >= managedObjectRefs.Count)
		{
			throw new ArgumentOutOfRangeException("id");
		}
		DynamicReferenceManager.SetValue(managedObjectRefs[id].Data, in value);
	}

	public DynamicReferenceCell GetReferenceCell(int id)
	{
		if (id < 0 || id >= managedObjectRefs.Count)
		{
			throw new ArgumentOutOfRangeException("id");
		}
		return managedObjectRefs[id].Data;
	}

	public override string ToString()
	{
		if (Method == null)
		{
			return "// ILContext: READONLY";
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"// ILContext: {Method}");
		foreach (Instruction instr in Instrs)
		{
			ToString(stringBuilder, instr);
		}
		return stringBuilder.ToString();
	}

	internal static StringBuilder ToString(StringBuilder builder, Instruction? instr)
	{
		if (instr == null)
		{
			return builder;
		}
		object operand = instr.Operand;
		if (operand is ILLabel iLLabel)
		{
			instr.Operand = iLLabel.Target;
		}
		else if (operand is ILLabel[] source)
		{
			instr.Operand = source.Select((ILLabel l) => l.Target).ToArray();
		}
		builder.AppendLine(instr.ToString());
		instr.Operand = operand;
		return builder;
	}

	protected virtual void Dispose(bool disposing)
	{
		if (disposedValue)
		{
			return;
		}
		this.OnDispose?.Invoke();
		this.OnDispose = null;
		foreach (DataScope<DynamicReferenceCell> managedObjectRef in managedObjectRefs)
		{
			managedObjectRef.Dispose();
		}
		managedObjectRefs.Clear();
		managedObjectRefs.Capacity = 0;
		MakeReadOnly();
		disposedValue = true;
	}

	~ILContext()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}


public delegate void Manipulator(ILContext il);


internal enum MoveType
{
	Before,
	AfterLabel,
	After
}


internal enum SearchTarget
{
	None,
	Next,
	Prev
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;
using MonoMod.Cil;
using MonoMod.SourceGen.Attributes;
using MonoMod.Utils;

[EmitILOverloads("ILOpcodes.txt", "ILCursor")]
internal sealed class ILCursor
{
	private Instruction? _next;

	private ILLabel[]? _afterLabels;

	private bool _afterHandlerStarts;

	private bool _afterHandlerEnds;

	private SearchTarget _searchTarget;

	public ILContext Context { get; }

	public Instruction? Next
	{
		get
		{
			return _next;
		}
		set
		{
			Goto(value);
		}
	}

	public Instruction Prev
	{
		get
		{
			if (Next != null)
			{
				return Next.Previous;
			}
			return Instrs[Instrs.Count - 1];
		}
		set
		{
			Goto(value, MoveType.After);
		}
	}

	public Instruction Previous
	{
		get
		{
			return Prev;
		}
		set
		{
			Prev = value;
		}
	}

	public int Index
	{
		get
		{
			return Context.IndexOf(Next);
		}
		set
		{
			Goto(value);
		}
	}

	public SearchTarget SearchTarget
	{
		get
		{
			return _searchTarget;
		}
		set
		{
			if ((value == SearchTarget.Next && Next == null) || (value == SearchTarget.Prev && Prev == null))
			{
				value = SearchTarget.None;
			}
			_searchTarget = value;
		}
	}

	public IEnumerable<ILLabel> IncomingLabels => Context.GetIncomingLabels(Next);

	public MethodDefinition Method => Context.Method;

	public ILProcessor IL => Context.IL;

	public Mono.Cecil.Cil.MethodBody Body => Context.Body;

	public ModuleDefinition Module => Context.Module;

	public Collection<Instruction> Instrs => Context.Instrs;

	public ILCursor(ILContext context)
	{
		Context = context;
		Index = 0;
	}

	public ILCursor(ILCursor c)
	{
		Helpers.ThrowIfArgumentNull(c, "c");
		Context = c.Context;
		_next = c._next;
		_searchTarget = c._searchTarget;
		_afterLabels = c._afterLabels;
		_afterHandlerStarts = c._afterHandlerStarts;
		_afterHandlerEnds = c._afterHandlerEnds;
	}

	public ILCursor Clone()
	{
		return new ILCursor(this);
	}

	public bool IsBefore(Instruction instr)
	{
		return Index <= Context.IndexOf(instr);
	}

	public bool IsAfter(Instruction instr)
	{
		return Index > Context.IndexOf(instr);
	}

	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"// ILCursor: {Method}, {Index}, {SearchTarget}");
		ILContext.ToString(stringBuilder, Prev);
		ILContext.ToString(stringBuilder, Next);
		return stringBuilder.ToString();
	}

	public ILCursor Goto(Instruction? insn, MoveType moveType = MoveType.Before, bool setTarget = false)
	{
		if (moveType == MoveType.After)
		{
			_next = insn?.Next;
		}
		else
		{
			_next = insn;
		}
		if (setTarget)
		{
			_searchTarget = ((moveType != MoveType.After) ? SearchTarget.Next : SearchTarget.Prev);
		}
		else
		{
			_searchTarget = SearchTarget.None;
		}
		if (moveType == MoveType.AfterLabel)
		{
			MoveAfterLabels();
		}
		else
		{
			MoveBeforeLabels();
		}
		return this;
	}

	public ILCursor MoveAfterLabels()
	{
		MoveAfterLabels(intoEHRanges: true);
		return this;
	}

	public ILCursor MoveAfterLabels(bool intoEHRanges)
	{
		_afterLabels = IncomingLabels.ToArray();
		_afterHandlerStarts = intoEHRanges;
		_afterHandlerEnds = true;
		return this;
	}

	public ILCursor MoveBeforeLabels()
	{
		_afterLabels = null;
		_afterHandlerStarts = false;
		_afterHandlerEnds = false;
		return this;
	}

	public ILCursor Goto(int index, MoveType moveType = MoveType.Before, bool setTarget = false)
	{
		if (index < 0)
		{
			index += Instrs.Count;
		}
		return Goto((index == Instrs.Count) ? null : Instrs[index], moveType, setTarget);
	}

	public ILCursor GotoLabel(ILLabel label, MoveType moveType = MoveType.AfterLabel, bool setTarget = false)
	{
		return Goto(Helpers.ThrowIfNull(label, "label").Target, moveType, setTarget);
	}

	public ILCursor GotoNext(MoveType moveType = MoveType.Before, params Func<Instruction, bool>[] predicates)
	{
		if (!TryGotoNext(moveType, predicates))
		{
			throw new KeyNotFoundException();
		}
		return this;
	}

	public bool TryGotoNext(MoveType moveType = MoveType.Before, params Func<Instruction, bool>[] predicates)
	{
		Helpers.ThrowIfArgumentNull(predicates, "predicates");
		Collection<Instruction> instrs = Instrs;
		int i = Index;
		if (SearchTarget == SearchTarget.Next)
		{
			i++;
		}
		for (; i + predicates.Length <= instrs.Count; i++)
		{
			int num = 0;
			while (true)
			{
				if (num < predicates.Length)
				{
					Func<Instruction, bool> obj = predicates[num];
					if (obj != null && !obj(instrs[i + num]))
					{
						break;
					}
					num++;
					continue;
				}
				Goto((moveType == MoveType.After) ? (i + predicates.Length - 1) : i, moveType, setTarget: true);
				return true;
			}
		}
		return false;
	}

	public ILCursor GotoPrev(MoveType moveType = MoveType.Before, params Func<Instruction, bool>[] predicates)
	{
		if (!TryGotoPrev(moveType, predicates))
		{
			throw new KeyNotFoundException();
		}
		return this;
	}

	public bool TryGotoPrev(MoveType moveType = MoveType.Before, params Func<Instruction, bool>[] predicates)
	{
		Helpers.ThrowIfArgumentNull(predicates, "predicates");
		Collection<Instruction> instrs = Instrs;
		int num = Index - 1;
		if (SearchTarget == SearchTarget.Prev)
		{
			num--;
		}
		for (num = Math.Min(num, instrs.Count - predicates.Length); num >= 0; num--)
		{
			int num2 = 0;
			while (true)
			{
				if (num2 < predicates.Length)
				{
					Func<Instruction, bool> obj = predicates[num2];
					if (obj != null && !obj(instrs[num + num2]))
					{
						break;
					}
					num2++;
					continue;
				}
				Goto((moveType == MoveType.After) ? (num + predicates.Length - 1) : num, moveType, setTarget: true);
				return true;
			}
		}
		return false;
	}

	public ILCursor GotoNext(params Func<Instruction, bool>[] predicates)
	{
		return GotoNext(MoveType.Before, predicates);
	}

	public bool TryGotoNext(params Func<Instruction, bool>[] predicates)
	{
		return TryGotoNext(MoveType.Before, predicates);
	}

	public ILCursor GotoPrev(params Func<Instruction, bool>[] predicates)
	{
		return GotoPrev(MoveType.Before, predicates);
	}

	public bool TryGotoPrev(params Func<Instruction, bool>[] predicates)
	{
		return TryGotoPrev(MoveType.Before, predicates);
	}

	public void FindNext(out ILCursor[] cursors, params Func<Instruction, bool>[] predicates)
	{
		if (!TryFindNext(out cursors, predicates))
		{
			throw new KeyNotFoundException();
		}
	}

	public bool TryFindNext(out ILCursor[] cursors, params Func<Instruction, bool>[] predicates)
	{
		Helpers.ThrowIfArgumentNull(predicates, "predicates");
		cursors = new ILCursor[predicates.Length];
		ILCursor iLCursor = this;
		for (int i = 0; i < predicates.Length; i++)
		{
			iLCursor = iLCursor.Clone();
			if (!iLCursor.TryGotoNext(predicates[i]))
			{
				return false;
			}
			cursors[i] = iLCursor;
		}
		return true;
	}

	public void FindPrev(out ILCursor[] cursors, params Func<Instruction, bool>[] predicates)
	{
		if (!TryFindPrev(out cursors, predicates))
		{
			throw new KeyNotFoundException();
		}
	}

	public bool TryFindPrev(out ILCursor[] cursors, params Func<Instruction, bool>[] predicates)
	{
		Helpers.ThrowIfArgumentNull(predicates, "predicates");
		cursors = new ILCursor[predicates.Length];
		ILCursor iLCursor = this;
		for (int num = predicates.Length - 1; num >= 0; num--)
		{
			iLCursor = iLCursor.Clone();
			if (!iLCursor.TryGotoPrev(predicates[num]))
			{
				return false;
			}
			cursors[num] = iLCursor;
		}
		return true;
	}

	public void MarkLabel(ILLabel? label)
	{
		if (label == null)
		{
			label = new ILLabel(Context);
		}
		label.Target = Next;
		if (_afterLabels != null)
		{
			Array.Resize(ref _afterLabels, _afterLabels.Length + 1);
			_afterLabels[_afterLabels.Length - 1] = label;
		}
		else
		{
			_afterLabels = new ILLabel[1] { label };
		}
	}

	public ILLabel MarkLabel(Instruction inst)
	{
		ILLabel iLLabel = Context.DefineLabel();
		if (inst == Next)
		{
			MarkLabel(iLLabel);
			return iLLabel;
		}
		iLLabel.Target = inst;
		return iLLabel;
	}

	public ILLabel MarkLabel()
	{
		ILLabel iLLabel = DefineLabel();
		MarkLabel(iLLabel);
		return iLLabel;
	}

	public ILLabel DefineLabel()
	{
		return Context.DefineLabel();
	}

	private ILCursor _Insert(Instruction instr)
	{
		if (_afterLabels != null)
		{
			ILLabel[] afterLabels = _afterLabels;
			for (int i = 0; i < afterLabels.Length; i++)
			{
				afterLabels[i].Target = instr;
			}
		}
		if (_afterHandlerStarts)
		{
			foreach (ExceptionHandler exceptionHandler in Body.ExceptionHandlers)
			{
				if (exceptionHandler.TryStart == Next)
				{
					exceptionHandler.TryStart = instr;
				}
				if (exceptionHandler.HandlerStart == Next)
				{
					exceptionHandler.HandlerStart = instr;
				}
				if (exceptionHandler.FilterStart == Next)
				{
					exceptionHandler.FilterStart = instr;
				}
			}
		}
		if (_afterHandlerEnds)
		{
			foreach (ExceptionHandler exceptionHandler2 in Body.ExceptionHandlers)
			{
				if (exceptionHandler2.TryEnd == Next)
				{
					exceptionHandler2.TryEnd = instr;
				}
				if (exceptionHandler2.HandlerEnd == Next)
				{
					exceptionHandler2.HandlerEnd = instr;
				}
			}
		}
		Instrs.Insert(Index, instr);
		Goto(instr, MoveType.After);
		return this;
	}

	public ILCursor Remove()
	{
		return RemoveRange(1);
	}

	public ILCursor RemoveRange(int num)
	{
		int index = Index;
		Instruction instruction = ((index + num < Instrs.Count) ? Instrs[index + num] : null);
		foreach (ILLabel incomingLabel in IncomingLabels)
		{
			incomingLabel.Target = instruction;
		}
		foreach (ExceptionHandler exceptionHandler in Body.ExceptionHandlers)
		{
			if (exceptionHandler.TryStart == Next)
			{
				exceptionHandler.TryStart = instruction;
			}
			if (exceptionHandler.TryEnd == Next)
			{
				exceptionHandler.TryEnd = instruction;
			}
			if (exceptionHandler.HandlerStart == Next)
			{
				exceptionHandler.HandlerStart = instruction;
			}
			if (exceptionHandler.FilterStart == Next)
			{
				exceptionHandler.FilterStart = instruction;
			}
			if (exceptionHandler.HandlerEnd == Next)
			{
				exceptionHandler.HandlerEnd = instruction;
			}
		}
		while (num-- > 0)
		{
			Instrs.RemoveAt(index);
		}
		_searchTarget = SearchTarget.None;
		_next = instruction;
		return this;
	}

	public ILCursor Emit(OpCode opcode, ParameterDefinition parameter)
	{
		return _Insert(IL.Create(opcode, parameter));
	}

	public ILCursor Emit(OpCode opcode, VariableDefinition variable)
	{
		return _Insert(IL.Create(opcode, variable));
	}

	public ILCursor Emit(OpCode opcode, Instruction[] targets)
	{
		return _Insert(IL.Create(opcode, targets));
	}

	public ILCursor Emit(OpCode opcode, Instruction target)
	{
		return _Insert(IL.Create(opcode, target));
	}

	public ILCursor Emit(OpCode opcode, double value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, float value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, long value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, sbyte value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, byte value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, string value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, FieldReference field)
	{
		return _Insert(IL.Create(opcode, field));
	}

	public ILCursor Emit(OpCode opcode, CallSite site)
	{
		return _Insert(IL.Create(opcode, site));
	}

	public ILCursor Emit(OpCode opcode, TypeReference type)
	{
		return _Insert(IL.Create(opcode, type));
	}

	public ILCursor Emit(OpCode opcode)
	{
		return _Insert(IL.Create(opcode));
	}

	public ILCursor Emit(OpCode opcode, int value)
	{
		return _Insert(IL.Create(opcode, value));
	}

	public ILCursor Emit(OpCode opcode, MethodReference method)
	{
		return _Insert(IL.Create(opcode, method));
	}

	public ILCursor Emit(OpCode opcode, FieldInfo field)
	{
		return _Insert(IL.Create(opcode, field));
	}

	public ILCursor Emit(OpCode opcode, MethodBase method)
	{
		return _Insert(IL.Create(opcode, method));
	}

	public ILCursor Emit(OpCode opcode, Type type)
	{
		return _Insert(IL.Create(opcode, type));
	}

	public ILCursor Emit(OpCode opcode, object operand)
	{
		return _Insert(IL.Create(opcode, operand));
	}

	public ILCursor Emit<T>(OpCode opcode, string memberName)
	{
		return _Insert(IL.Create(opcode, typeof(T).GetMember(memberName, (BindingFlags)(-1)).First()));
	}

	public int AddReference<T>(in T t)
	{
		return Context.AddReference(in t);
	}

	public void EmitGetReference<T>(int id)
	{
		this.EmitLoadTypedReference(Context.GetReferenceCell(id), typeof(T));
	}

	public int EmitReference<T>(in T? t)
	{
		int num = AddReference(in t);
		this.EmitLoadTypedReferenceUnsafe(Context.GetReferenceCell(num), typeof(T));
		return num;
	}

	public int EmitDelegate<T>(T cb) where T : Delegate
	{
		Helpers.ThrowIfArgumentNull(cb, "cb");
		if (cb.GetInvocationList().Length == 1 && cb.Target == null)
		{
			Emit(OpCodes.Call, cb.Method);
			return -1;
		}
		(MethodInfo, Type)? delegateInvoker = FastDelegateInvokers.GetDelegateInvoker(typeof(T));
		int result;
		if (delegateInvoker.HasValue)
		{
			(MethodInfo, Type) valueOrDefault = delegateInvoker.GetValueOrDefault();
			result = EmitReference<Delegate>(cb.CastDelegate(valueOrDefault.Item2));
			AddReference(in valueOrDefault.Item1);
			Emit(OpCodes.Call, valueOrDefault.Item1);
		}
		else
		{
			result = EmitReference(in cb);
			MethodInfo method = typeof(T).GetMethod("Invoke");
			Emit(OpCodes.Callvirt, method);
		}
		return result;
	}

	public ILCursor EmitAdd()
	{
		return _Insert(IL.Create(OpCodes.Add));
	}

	public ILCursor EmitAddOvf()
	{
		return _Insert(IL.Create(OpCodes.Add_Ovf));
	}

	public ILCursor EmitAddOvfUn()
	{
		return _Insert(IL.Create(OpCodes.Add_Ovf_Un));
	}

	public ILCursor EmitAnd()
	{
		return _Insert(IL.Create(OpCodes.And));
	}

	public ILCursor EmitArglist()
	{
		return _Insert(IL.Create(OpCodes.Arglist));
	}

	public ILCursor EmitBeq(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Beq, operand));
	}

	public ILCursor EmitBeq(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Beq, MarkLabel(operand)));
	}

	public ILCursor EmitBge(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Bge, operand));
	}

	public ILCursor EmitBge(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Bge, MarkLabel(operand)));
	}

	public ILCursor EmitBgeUn(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Bge_Un, operand));
	}

	public ILCursor EmitBgeUn(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Bge_Un, MarkLabel(operand)));
	}

	public ILCursor EmitBgt(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Bgt, operand));
	}

	public ILCursor EmitBgt(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Bgt, MarkLabel(operand)));
	}

	public ILCursor EmitBgtUn(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Bgt_Un, operand));
	}

	public ILCursor EmitBgtUn(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Bgt_Un, MarkLabel(operand)));
	}

	public ILCursor EmitBle(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Ble, operand));
	}

	public ILCursor EmitBle(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Ble, MarkLabel(operand)));
	}

	public ILCursor EmitBleUn(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Ble_Un, operand));
	}

	public ILCursor EmitBleUn(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Ble_Un, MarkLabel(operand)));
	}

	public ILCursor EmitBlt(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Blt, operand));
	}

	public ILCursor EmitBlt(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Blt, MarkLabel(operand)));
	}

	public ILCursor EmitBltUn(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Blt_Un, operand));
	}

	public ILCursor EmitBltUn(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Blt_Un, MarkLabel(operand)));
	}

	public ILCursor EmitBneUn(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Bne_Un, operand));
	}

	public ILCursor EmitBneUn(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Bne_Un, MarkLabel(operand)));
	}

	public ILCursor EmitBox(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Box, operand));
	}

	public ILCursor EmitBox(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Box, Context.Import(operand)));
	}

	public ILCursor EmitBr(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Br, operand));
	}

	public ILCursor EmitBr(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Br, MarkLabel(operand)));
	}

	public ILCursor EmitBreak()
	{
		return _Insert(IL.Create(OpCodes.Break));
	}

	public ILCursor EmitBrfalse(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Brfalse, operand));
	}

	public ILCursor EmitBrfalse(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Brfalse, MarkLabel(operand)));
	}

	public ILCursor EmitBrtrue(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Brtrue, operand));
	}

	public ILCursor EmitBrtrue(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Brtrue, MarkLabel(operand)));
	}

	public ILCursor EmitCall(MethodReference operand)
	{
		return _Insert(IL.Create(OpCodes.Call, operand));
	}

	public ILCursor EmitCall(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Call, Context.Import(operand)));
	}

	public ILCursor EmitCalli(IMethodSignature operand)
	{
		return _Insert(IL.Create(OpCodes.Calli, operand));
	}

	public ILCursor EmitCallvirt(MethodReference operand)
	{
		return _Insert(IL.Create(OpCodes.Callvirt, operand));
	}

	public ILCursor EmitCallvirt(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Callvirt, Context.Import(operand)));
	}

	public ILCursor EmitCastclass(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Castclass, operand));
	}

	public ILCursor EmitCastclass(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Castclass, Context.Import(operand)));
	}

	public ILCursor EmitCeq()
	{
		return _Insert(IL.Create(OpCodes.Ceq));
	}

	public ILCursor EmitCgt()
	{
		return _Insert(IL.Create(OpCodes.Cgt));
	}

	public ILCursor EmitCgtUn()
	{
		return _Insert(IL.Create(OpCodes.Cgt_Un));
	}

	public ILCursor EmitCkfinite()
	{
		return _Insert(IL.Create(OpCodes.Ckfinite));
	}

	public ILCursor EmitClt()
	{
		return _Insert(IL.Create(OpCodes.Clt));
	}

	public ILCursor EmitCltUn()
	{
		return _Insert(IL.Create(OpCodes.Clt_Un));
	}

	public ILCursor EmitConstrained(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Constrained, operand));
	}

	public ILCursor EmitConstrained(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Constrained, Context.Import(operand)));
	}

	public ILCursor EmitConvI()
	{
		return _Insert(IL.Create(OpCodes.Conv_I));
	}

	public ILCursor EmitConvI1()
	{
		return _Insert(IL.Create(OpCodes.Conv_I1));
	}

	public ILCursor EmitConvI2()
	{
		return _Insert(IL.Create(OpCodes.Conv_I2));
	}

	public ILCursor EmitConvI4()
	{
		return _Insert(IL.Create(OpCodes.Conv_I4));
	}

	public ILCursor EmitConvI8()
	{
		return _Insert(IL.Create(OpCodes.Conv_I8));
	}

	public ILCursor EmitConvOvfI()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I));
	}

	public ILCursor EmitConvOvfIUn()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I_Un));
	}

	public ILCursor EmitConvOvfI1()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I1));
	}

	public ILCursor EmitConvOvfI1Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I1_Un));
	}

	public ILCursor EmitConvOvfI2()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I2));
	}

	public ILCursor EmitConvOvfI2Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I2_Un));
	}

	public ILCursor EmitConvOvfI4()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I4));
	}

	public ILCursor EmitConvOvfI4Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I4_Un));
	}

	public ILCursor EmitConvOvfI8()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I8));
	}

	public ILCursor EmitConvOvfI8Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_I8_Un));
	}

	public ILCursor EmitConvOvfU()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U));
	}

	public ILCursor EmitConvOvfUUn()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U_Un));
	}

	public ILCursor EmitConvOvfU1()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U1));
	}

	public ILCursor EmitConvOvfU1Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U1_Un));
	}

	public ILCursor EmitConvOvfU2()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U2));
	}

	public ILCursor EmitConvOvfU2Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U2_Un));
	}

	public ILCursor EmitConvOvfU4()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U4));
	}

	public ILCursor EmitConvOvfU4Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U4_Un));
	}

	public ILCursor EmitConvOvfU8()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U8));
	}

	public ILCursor EmitConvOvfU8Un()
	{
		return _Insert(IL.Create(OpCodes.Conv_Ovf_U8_Un));
	}

	public ILCursor EmitConvRUn()
	{
		return _Insert(IL.Create(OpCodes.Conv_R_Un));
	}

	public ILCursor EmitConvR4()
	{
		return _Insert(IL.Create(OpCodes.Conv_R4));
	}

	public ILCursor EmitConvR8()
	{
		return _Insert(IL.Create(OpCodes.Conv_R8));
	}

	public ILCursor EmitConvU()
	{
		return _Insert(IL.Create(OpCodes.Conv_U));
	}

	public ILCursor EmitConvU1()
	{
		return _Insert(IL.Create(OpCodes.Conv_U1));
	}

	public ILCursor EmitConvU2()
	{
		return _Insert(IL.Create(OpCodes.Conv_U2));
	}

	public ILCursor EmitConvU4()
	{
		return _Insert(IL.Create(OpCodes.Conv_U4));
	}

	public ILCursor EmitConvU8()
	{
		return _Insert(IL.Create(OpCodes.Conv_U8));
	}

	public ILCursor EmitCpblk()
	{
		return _Insert(IL.Create(OpCodes.Cpblk));
	}

	public ILCursor EmitCpobj(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Cpobj, operand));
	}

	public ILCursor EmitCpobj(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Cpobj, Context.Import(operand)));
	}

	public ILCursor EmitDiv()
	{
		return _Insert(IL.Create(OpCodes.Div));
	}

	public ILCursor EmitDivUn()
	{
		return _Insert(IL.Create(OpCodes.Div_Un));
	}

	public ILCursor EmitDup()
	{
		return _Insert(IL.Create(OpCodes.Dup));
	}

	public ILCursor EmitEndfilter()
	{
		return _Insert(IL.Create(OpCodes.Endfilter));
	}

	public ILCursor EmitEndfinally()
	{
		return _Insert(IL.Create(OpCodes.Endfinally));
	}

	public ILCursor EmitInitblk()
	{
		return _Insert(IL.Create(OpCodes.Initblk));
	}

	public ILCursor EmitInitobj(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Initobj, operand));
	}

	public ILCursor EmitInitobj(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Initobj, Context.Import(operand)));
	}

	public ILCursor EmitIsinst(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Isinst, operand));
	}

	public ILCursor EmitIsinst(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Isinst, Context.Import(operand)));
	}

	public ILCursor EmitJmp(MethodReference operand)
	{
		return _Insert(IL.Create(OpCodes.Jmp, operand));
	}

	public ILCursor EmitJmp(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Jmp, Context.Import(operand)));
	}

	public ILCursor EmitLdarg0()
	{
		return _Insert(IL.Create(OpCodes.Ldarg_0));
	}

	public ILCursor EmitLdarg1()
	{
		return _Insert(IL.Create(OpCodes.Ldarg_1));
	}

	public ILCursor EmitLdarg2()
	{
		return _Insert(IL.Create(OpCodes.Ldarg_2));
	}

	public ILCursor EmitLdarg3()
	{
		return _Insert(IL.Create(OpCodes.Ldarg_3));
	}

	public ILCursor EmitLdarg(int operand)
	{
		return _Insert(IL.Create(OpCodes.Ldarg, operand));
	}

	public ILCursor EmitLdarg(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Ldarg, (int)operand));
	}

	public ILCursor EmitLdarg(ParameterReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldarg, operand));
	}

	public ILCursor EmitLdarga(int operand)
	{
		return _Insert(IL.Create(OpCodes.Ldarga, operand));
	}

	public ILCursor EmitLdarga(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Ldarga, (int)operand));
	}

	public ILCursor EmitLdarga(ParameterReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldarga, operand));
	}

	public ILCursor EmitLdcI4(int operand)
	{
		return _Insert(IL.Create(OpCodes.Ldc_I4, operand));
	}

	public ILCursor EmitLdcI4(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Ldc_I4, (int)operand));
	}

	public ILCursor EmitLdcI8(long operand)
	{
		return _Insert(IL.Create(OpCodes.Ldc_I8, operand));
	}

	public ILCursor EmitLdcI8(ulong operand)
	{
		return _Insert(IL.Create(OpCodes.Ldc_I8, (long)operand));
	}

	public ILCursor EmitLdcR4(float operand)
	{
		return _Insert(IL.Create(OpCodes.Ldc_R4, operand));
	}

	public ILCursor EmitLdcR8(double operand)
	{
		return _Insert(IL.Create(OpCodes.Ldc_R8, operand));
	}

	public ILCursor EmitLdelemAny(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldelem_Any, operand));
	}

	public ILCursor EmitLdelemAny(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Ldelem_Any, Context.Import(operand)));
	}

	public ILCursor EmitLdelemI()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_I));
	}

	public ILCursor EmitLdelemI1()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_I1));
	}

	public ILCursor EmitLdelemI2()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_I2));
	}

	public ILCursor EmitLdelemI4()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_I4));
	}

	public ILCursor EmitLdelemI8()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_I8));
	}

	public ILCursor EmitLdelemR4()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_R4));
	}

	public ILCursor EmitLdelemR8()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_R8));
	}

	public ILCursor EmitLdelemRef()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_Ref));
	}

	public ILCursor EmitLdelemU1()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_U1));
	}

	public ILCursor EmitLdelemU2()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_U2));
	}

	public ILCursor EmitLdelemU4()
	{
		return _Insert(IL.Create(OpCodes.Ldelem_U4));
	}

	public ILCursor EmitLdelema(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldelema, operand));
	}

	public ILCursor EmitLdelema(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Ldelema, Context.Import(operand)));
	}

	public ILCursor EmitLdfld(FieldReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldfld, operand));
	}

	public ILCursor EmitLdfld(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Ldfld, Context.Import(operand)));
	}

	public ILCursor EmitLdflda(FieldReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldflda, operand));
	}

	public ILCursor EmitLdflda(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Ldflda, Context.Import(operand)));
	}

	public ILCursor EmitLdftn(MethodReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldftn, operand));
	}

	public ILCursor EmitLdftn(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Ldftn, Context.Import(operand)));
	}

	public ILCursor EmitLdindI()
	{
		return _Insert(IL.Create(OpCodes.Ldind_I));
	}

	public ILCursor EmitLdindI1()
	{
		return _Insert(IL.Create(OpCodes.Ldind_I1));
	}

	public ILCursor EmitLdindI2()
	{
		return _Insert(IL.Create(OpCodes.Ldind_I2));
	}

	public ILCursor EmitLdindI4()
	{
		return _Insert(IL.Create(OpCodes.Ldind_I4));
	}

	public ILCursor EmitLdindI8()
	{
		return _Insert(IL.Create(OpCodes.Ldind_I8));
	}

	public ILCursor EmitLdindR4()
	{
		return _Insert(IL.Create(OpCodes.Ldind_R4));
	}

	public ILCursor EmitLdindR8()
	{
		return _Insert(IL.Create(OpCodes.Ldind_R8));
	}

	public ILCursor EmitLdindRef()
	{
		return _Insert(IL.Create(OpCodes.Ldind_Ref));
	}

	public ILCursor EmitLdindU1()
	{
		return _Insert(IL.Create(OpCodes.Ldind_U1));
	}

	public ILCursor EmitLdindU2()
	{
		return _Insert(IL.Create(OpCodes.Ldind_U2));
	}

	public ILCursor EmitLdindU4()
	{
		return _Insert(IL.Create(OpCodes.Ldind_U4));
	}

	public ILCursor EmitLdlen()
	{
		return _Insert(IL.Create(OpCodes.Ldlen));
	}

	public ILCursor EmitLdloc0()
	{
		return _Insert(IL.Create(OpCodes.Ldloc_0));
	}

	public ILCursor EmitLdloc1()
	{
		return _Insert(IL.Create(OpCodes.Ldloc_1));
	}

	public ILCursor EmitLdloc2()
	{
		return _Insert(IL.Create(OpCodes.Ldloc_2));
	}

	public ILCursor EmitLdloc3()
	{
		return _Insert(IL.Create(OpCodes.Ldloc_3));
	}

	public ILCursor EmitLdloc(int operand)
	{
		return _Insert(IL.Create(OpCodes.Ldloc, operand));
	}

	public ILCursor EmitLdloc(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Ldloc, (int)operand));
	}

	public ILCursor EmitLdloc(VariableReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldloc, operand));
	}

	public ILCursor EmitLdloca(int operand)
	{
		return _Insert(IL.Create(OpCodes.Ldloca, operand));
	}

	public ILCursor EmitLdloca(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Ldloca, (int)operand));
	}

	public ILCursor EmitLdloca(VariableReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldloca, operand));
	}

	public ILCursor EmitLdnull()
	{
		return _Insert(IL.Create(OpCodes.Ldnull));
	}

	public ILCursor EmitLdobj(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldobj, operand));
	}

	public ILCursor EmitLdobj(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Ldobj, Context.Import(operand)));
	}

	public ILCursor EmitLdsfld(FieldReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldsfld, operand));
	}

	public ILCursor EmitLdsfld(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Ldsfld, Context.Import(operand)));
	}

	public ILCursor EmitLdsflda(FieldReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldsflda, operand));
	}

	public ILCursor EmitLdsflda(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Ldsflda, Context.Import(operand)));
	}

	public ILCursor EmitLdstr(string operand)
	{
		return _Insert(IL.Create(OpCodes.Ldstr, operand));
	}

	public ILCursor EmitLdtoken(IMetadataTokenProvider operand)
	{
		return _Insert(IL.Create(OpCodes.Ldtoken, operand));
	}

	public ILCursor EmitLdtoken(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Ldtoken, Context.Import(operand)));
	}

	public ILCursor EmitLdtoken(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Ldtoken, Context.Import(operand)));
	}

	public ILCursor EmitLdtoken(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Ldtoken, Context.Import(operand)));
	}

	public ILCursor EmitLdvirtftn(MethodReference operand)
	{
		return _Insert(IL.Create(OpCodes.Ldvirtftn, operand));
	}

	public ILCursor EmitLdvirtftn(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Ldvirtftn, Context.Import(operand)));
	}

	public ILCursor EmitLeave(ILLabel operand)
	{
		return _Insert(IL.Create(OpCodes.Leave, operand));
	}

	public ILCursor EmitLeave(Instruction operand)
	{
		return _Insert(IL.Create(OpCodes.Leave, MarkLabel(operand)));
	}

	public ILCursor EmitLocalloc()
	{
		return _Insert(IL.Create(OpCodes.Localloc));
	}

	public ILCursor EmitMkrefany(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Mkrefany, operand));
	}

	public ILCursor EmitMkrefany(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Mkrefany, Context.Import(operand)));
	}

	public ILCursor EmitMul()
	{
		return _Insert(IL.Create(OpCodes.Mul));
	}

	public ILCursor EmitMulOvf()
	{
		return _Insert(IL.Create(OpCodes.Mul_Ovf));
	}

	public ILCursor EmitMulOvfUn()
	{
		return _Insert(IL.Create(OpCodes.Mul_Ovf_Un));
	}

	public ILCursor EmitNeg()
	{
		return _Insert(IL.Create(OpCodes.Neg));
	}

	public ILCursor EmitNewarr(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Newarr, operand));
	}

	public ILCursor EmitNewarr(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Newarr, Context.Import(operand)));
	}

	public ILCursor EmitNewobj(MethodReference operand)
	{
		return _Insert(IL.Create(OpCodes.Newobj, operand));
	}

	public ILCursor EmitNewobj(MethodBase operand)
	{
		return _Insert(IL.Create(OpCodes.Newobj, Context.Import(operand)));
	}

	public ILCursor EmitNop()
	{
		return _Insert(IL.Create(OpCodes.Nop));
	}

	public ILCursor EmitNot()
	{
		return _Insert(IL.Create(OpCodes.Not));
	}

	public ILCursor EmitOr()
	{
		return _Insert(IL.Create(OpCodes.Or));
	}

	public ILCursor EmitPop()
	{
		return _Insert(IL.Create(OpCodes.Pop));
	}

	public ILCursor EmitReadonly()
	{
		return _Insert(IL.Create(OpCodes.Readonly));
	}

	public ILCursor EmitRefanytype()
	{
		return _Insert(IL.Create(OpCodes.Refanytype));
	}

	public ILCursor EmitRefanyval(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Refanyval, operand));
	}

	public ILCursor EmitRefanyval(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Refanyval, Context.Import(operand)));
	}

	public ILCursor EmitRem()
	{
		return _Insert(IL.Create(OpCodes.Rem));
	}

	public ILCursor EmitRemUn()
	{
		return _Insert(IL.Create(OpCodes.Rem_Un));
	}

	public ILCursor EmitRet()
	{
		return _Insert(IL.Create(OpCodes.Ret));
	}

	public ILCursor EmitRethrow()
	{
		return _Insert(IL.Create(OpCodes.Rethrow));
	}

	public ILCursor EmitShl()
	{
		return _Insert(IL.Create(OpCodes.Shl));
	}

	public ILCursor EmitShr()
	{
		return _Insert(IL.Create(OpCodes.Shr));
	}

	public ILCursor EmitShrUn()
	{
		return _Insert(IL.Create(OpCodes.Shr_Un));
	}

	public ILCursor EmitSizeof(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Sizeof, operand));
	}

	public ILCursor EmitSizeof(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Sizeof, Context.Import(operand)));
	}

	public ILCursor EmitStarg(int operand)
	{
		return _Insert(IL.Create(OpCodes.Starg, operand));
	}

	public ILCursor EmitStarg(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Starg, (int)operand));
	}

	public ILCursor EmitStarg(ParameterReference operand)
	{
		return _Insert(IL.Create(OpCodes.Starg, operand));
	}

	public ILCursor EmitStelemAny(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Stelem_Any, operand));
	}

	public ILCursor EmitStelemAny(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Stelem_Any, Context.Import(operand)));
	}

	public ILCursor EmitStelemI()
	{
		return _Insert(IL.Create(OpCodes.Stelem_I));
	}

	public ILCursor EmitStelemI1()
	{
		return _Insert(IL.Create(OpCodes.Stelem_I1));
	}

	public ILCursor EmitStelemI2()
	{
		return _Insert(IL.Create(OpCodes.Stelem_I2));
	}

	public ILCursor EmitStelemI4()
	{
		return _Insert(IL.Create(OpCodes.Stelem_I4));
	}

	public ILCursor EmitStelemI8()
	{
		return _Insert(IL.Create(OpCodes.Stelem_I8));
	}

	public ILCursor EmitStelemR4()
	{
		return _Insert(IL.Create(OpCodes.Stelem_R4));
	}

	public ILCursor EmitStelemR8()
	{
		return _Insert(IL.Create(OpCodes.Stelem_R8));
	}

	public ILCursor EmitStelemRef()
	{
		return _Insert(IL.Create(OpCodes.Stelem_Ref));
	}

	public ILCursor EmitStfld(FieldReference operand)
	{
		return _Insert(IL.Create(OpCodes.Stfld, operand));
	}

	public ILCursor EmitStfld(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Stfld, Context.Import(operand)));
	}

	public ILCursor EmitStindI()
	{
		return _Insert(IL.Create(OpCodes.Stind_I));
	}

	public ILCursor EmitStindI1()
	{
		return _Insert(IL.Create(OpCodes.Stind_I1));
	}

	public ILCursor EmitStindI2()
	{
		return _Insert(IL.Create(OpCodes.Stind_I2));
	}

	public ILCursor EmitStindI4()
	{
		return _Insert(IL.Create(OpCodes.Stind_I4));
	}

	public ILCursor EmitStindI8()
	{
		return _Insert(IL.Create(OpCodes.Stind_I8));
	}

	public ILCursor EmitStindR4()
	{
		return _Insert(IL.Create(OpCodes.Stind_R4));
	}

	public ILCursor EmitStindR8()
	{
		return _Insert(IL.Create(OpCodes.Stind_R8));
	}

	public ILCursor EmitStindRef()
	{
		return _Insert(IL.Create(OpCodes.Stind_Ref));
	}

	public ILCursor EmitStloc0()
	{
		return _Insert(IL.Create(OpCodes.Stloc_0));
	}

	public ILCursor EmitStloc1()
	{
		return _Insert(IL.Create(OpCodes.Stloc_1));
	}

	public ILCursor EmitStloc2()
	{
		return _Insert(IL.Create(OpCodes.Stloc_2));
	}

	public ILCursor EmitStloc3()
	{
		return _Insert(IL.Create(OpCodes.Stloc_3));
	}

	public ILCursor EmitStloc(int operand)
	{
		return _Insert(IL.Create(OpCodes.Stloc, operand));
	}

	public ILCursor EmitStloc(uint operand)
	{
		return _Insert(IL.Create(OpCodes.Stloc, (int)operand));
	}

	public ILCursor EmitStloc(VariableReference operand)
	{
		return _Insert(IL.Create(OpCodes.Stloc, operand));
	}

	public ILCursor EmitStobj(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Stobj, operand));
	}

	public ILCursor EmitStobj(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Stobj, Context.Import(operand)));
	}

	public ILCursor EmitStsfld(FieldReference operand)
	{
		return _Insert(IL.Create(OpCodes.Stsfld, operand));
	}

	public ILCursor EmitStsfld(FieldInfo operand)
	{
		return _Insert(IL.Create(OpCodes.Stsfld, Context.Import(operand)));
	}

	public ILCursor EmitSub()
	{
		return _Insert(IL.Create(OpCodes.Sub));
	}

	public ILCursor EmitSubOvf()
	{
		return _Insert(IL.Create(OpCodes.Sub_Ovf));
	}

	public ILCursor EmitSubOvfUn()
	{
		return _Insert(IL.Create(OpCodes.Sub_Ovf_Un));
	}

	public ILCursor EmitSwitch(ILLabel[] operand)
	{
		return _Insert(IL.Create(OpCodes.Switch, operand));
	}

	public ILCursor EmitSwitch(Instruction[] operand)
	{
		return _Insert(IL.Create(OpCodes.Switch, operand.Select(MarkLabel).ToArray()));
	}

	public ILCursor EmitTail()
	{
		return _Insert(IL.Create(OpCodes.Tail));
	}

	public ILCursor EmitThrow()
	{
		return _Insert(IL.Create(OpCodes.Throw));
	}

	public ILCursor EmitUnaligned(byte operand)
	{
		return _Insert(IL.Create(OpCodes.Unaligned, operand));
	}

	public ILCursor EmitUnbox(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Unbox, operand));
	}

	public ILCursor EmitUnbox(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Unbox, Context.Import(operand)));
	}

	public ILCursor EmitUnboxAny(TypeReference operand)
	{
		return _Insert(IL.Create(OpCodes.Unbox_Any, operand));
	}

	public ILCursor EmitUnboxAny(Type operand)
	{
		return _Insert(IL.Create(OpCodes.Unbox_Any, Context.Import(operand)));
	}

	public ILCursor EmitVolatile()
	{
		return _Insert(IL.Create(OpCodes.Volatile));
	}

	public ILCursor EmitXor()
	{
		return _Insert(IL.Create(OpCodes.Xor));
	}
}


using System.Collections.Generic;
using System.Linq;
using Mono.Cecil.Cil;
using MonoMod.Cil;

internal sealed class ILLabel
{
	private readonly ILContext Context;

	public Instruction? Target { get; set; }

	public IEnumerable<Instruction> Branches => Context.Instrs.Where((Instruction i) => i.Operand == this);

	internal ILLabel(ILContext context)
	{
		Context = context;
		Context._Labels.Add(this);
	}

	internal ILLabel(ILContext context, Instruction? target)
		: this(context)
	{
		Target = target;
	}
}


