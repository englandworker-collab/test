using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod.Cil;
using MonoMod.SourceGen.Attributes;
using MonoMod.Utils;

[EmitILOverloads("ILOpcodes.txt", "ILMatcher")]
internal static class ILPatternMatchingExt
{
	private sealed class ParameterRefEqualityComparer : IEqualityComparer<ParameterReference>
	{
		public static readonly ParameterRefEqualityComparer Instance = new ParameterRefEqualityComparer();

		public bool Equals(ParameterReference? x, ParameterReference? y)
		{
			if (x == null)
			{
				return y == null;
			}
			if (y == null)
			{
				return false;
			}
			return IsEquivalent(x.ParameterType, y.ParameterType);
		}

		public int GetHashCode([DisallowNull] ParameterReference obj)
		{
			return obj.ParameterType.GetHashCode();
		}
	}

	private static bool IsEquivalent(int l, int r)
	{
		return l == r;
	}

	private static bool IsEquivalent(int l, uint r)
	{
		return l == (int)r;
	}

	private static bool IsEquivalent(long l, long r)
	{
		return l == r;
	}

	private static bool IsEquivalent(long l, ulong r)
	{
		return l == (long)r;
	}

	private static bool IsEquivalent(float l, float r)
	{
		return l == r;
	}

	private static bool IsEquivalent(double l, double r)
	{
		return l == r;
	}

	private static bool IsEquivalent(string l, string r)
	{
		return l == r;
	}

	private static bool IsEquivalent(ILLabel l, ILLabel r)
	{
		return l == r;
	}

	private static bool IsEquivalent(ILLabel l, Instruction r)
	{
		return IsEquivalent(l.Target, r);
	}

	private static bool IsEquivalent(Instruction? l, Instruction? r)
	{
		return l == r;
	}

	private static bool IsEquivalent(TypeReference l, TypeReference r)
	{
		return l == r;
	}

	private static bool IsEquivalent(TypeReference l, Type r)
	{
		return l.Is(r);
	}

	private static bool IsEquivalent(MethodReference l, MethodReference r)
	{
		return l == r;
	}

	private static bool IsEquivalent(MethodReference l, MethodBase r)
	{
		return l.Is(r);
	}

	private static bool IsEquivalent(MethodReference l, Type type, string name)
	{
		if (l.DeclaringType.Is(type))
		{
			return l.Name == name;
		}
		return false;
	}

	private static bool IsEquivalent(FieldReference l, FieldReference r)
	{
		return l == r;
	}

	private static bool IsEquivalent(FieldReference l, FieldInfo r)
	{
		return l.Is(r);
	}

	private static bool IsEquivalent(FieldReference l, Type type, string name)
	{
		if (l.DeclaringType.Is(type))
		{
			return l.Name == name;
		}
		return false;
	}

	private static bool IsEquivalent(ILLabel[] l, ILLabel[] r)
	{
		if (l != r)
		{
			return l.SequenceEqual(r);
		}
		return true;
	}

	private static bool IsEquivalent(ILLabel[] l, Instruction[] r)
	{
		if (l.Length != r.Length)
		{
			return false;
		}
		for (int i = 0; i < l.Length; i++)
		{
			if (!IsEquivalent(l[i].Target, r[i]))
			{
				return false;
			}
		}
		return true;
	}

	private static bool IsEquivalent(IMethodSignature l, IMethodSignature r)
	{
		if (l != r)
		{
			if (l.CallingConvention == r.CallingConvention && l.HasThis == r.HasThis && l.ExplicitThis == r.ExplicitThis && IsEquivalent(l.ReturnType, r.ReturnType))
			{
				return CastParamsToRef(l).SequenceEqual(CastParamsToRef(r), ParameterRefEqualityComparer.Instance);
			}
			return false;
		}
		return true;
	}

	private static IEnumerable<ParameterReference> CastParamsToRef(IMethodSignature sig)
	{
		return sig.Parameters;
	}

	private static bool IsEquivalent(IMetadataTokenProvider l, IMetadataTokenProvider r)
	{
		if (l != r)
		{
			return l.MetadataToken == r.MetadataToken;
		}
		return true;
	}

	private static bool IsEquivalent(IMetadataTokenProvider l, Type r)
	{
		if (!(l is TypeReference l2))
		{
			return false;
		}
		return IsEquivalent(l2, r);
	}

	private static bool IsEquivalent(IMetadataTokenProvider l, FieldInfo r)
	{
		if (!(l is FieldReference l2))
		{
			return false;
		}
		return IsEquivalent(l2, r);
	}

	private static bool IsEquivalent(IMetadataTokenProvider l, MethodBase r)
	{
		if (!(l is MethodReference l2))
		{
			return false;
		}
		return IsEquivalent(l2, r);
	}

	public static bool Match(this Instruction instr, OpCode opcode)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == opcode;
	}

	public static bool Match<T>(this Instruction instr, OpCode opcode, T value)
	{
		if (instr.Match<T>(opcode, out var value2))
		{
			return value2?.Equals(value) ?? (value == null);
		}
		return false;
	}

	public static bool Match<T>(this Instruction instr, OpCode opcode, [MaybeNullWhen(false)] out T value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == opcode)
		{
			value = (T)instr.Operand;
			return true;
		}
		value = default(T);
		return false;
	}

	[Obsolete("Leftover from legacy MonoMod, use MatchLeave instead")]
	public static bool MatchLeaveS(this Instruction instr, ILLabel value)
	{
		if (instr.MatchLeaveS(out ILLabel value2))
		{
			return value2 == value;
		}
		return false;
	}

	[Obsolete("Leftover from legacy MonoMod, use MatchLeave instead")]
	public static bool MatchLeaveS(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Leave_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdarg(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Ldarg || instr.OpCode == OpCodes.Ldarg_S)
		{
			value = ((ParameterReference)instr.Operand).Index;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldarg_0)
		{
			value = 0;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldarg_1)
		{
			value = 1;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldarg_2)
		{
			value = 2;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldarg_3)
		{
			value = 3;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchStarg(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Starg || instr.OpCode == OpCodes.Starg_S)
		{
			value = ((ParameterReference)instr.Operand).Index;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchLdarga(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Ldarga || instr.OpCode == OpCodes.Ldarga_S)
		{
			value = ((ParameterReference)instr.Operand).Index;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchLdloc(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Ldloc || instr.OpCode == OpCodes.Ldloc_S)
		{
			value = ((VariableReference)instr.Operand).Index;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldloc_0)
		{
			value = 0;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldloc_1)
		{
			value = 1;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldloc_2)
		{
			value = 2;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldloc_3)
		{
			value = 3;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchStloc(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Stloc || instr.OpCode == OpCodes.Stloc_S)
		{
			value = ((VariableReference)instr.Operand).Index;
			return true;
		}
		if (instr.OpCode == OpCodes.Stloc_0)
		{
			value = 0;
			return true;
		}
		if (instr.OpCode == OpCodes.Stloc_1)
		{
			value = 1;
			return true;
		}
		if (instr.OpCode == OpCodes.Stloc_2)
		{
			value = 2;
			return true;
		}
		if (instr.OpCode == OpCodes.Stloc_3)
		{
			value = 3;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchLdloca(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Ldloca || instr.OpCode == OpCodes.Ldloca_S)
		{
			value = ((VariableReference)instr.Operand).Index;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchLdcI4(this Instruction instr, out int value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Ldc_I4)
		{
			value = (int)instr.Operand;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_S)
		{
			value = (sbyte)instr.Operand;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_0)
		{
			value = 0;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_1)
		{
			value = 1;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_2)
		{
			value = 2;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_3)
		{
			value = 3;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_4)
		{
			value = 4;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_5)
		{
			value = 5;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_6)
		{
			value = 6;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_7)
		{
			value = 7;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_8)
		{
			value = 8;
			return true;
		}
		if (instr.OpCode == OpCodes.Ldc_I4_M1)
		{
			value = -1;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchCallOrCallvirt(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		if (instr.OpCode == OpCodes.Call || instr.OpCode == OpCodes.Callvirt)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchNewobj(this Instruction instr, Type type)
	{
		if (instr.MatchNewobj(out MethodReference value))
		{
			return value.DeclaringType.Is(type);
		}
		return false;
	}

	public static bool MatchNewobj<T>(this Instruction instr)
	{
		return instr.MatchNewobj(typeof(T));
	}

	public static bool MatchNewobj(this Instruction instr, string typeFullName)
	{
		if (instr.MatchNewobj(out MethodReference value))
		{
			return value.DeclaringType.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchAdd(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Add;
	}

	public static bool MatchAddOvf(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Add_Ovf;
	}

	public static bool MatchAddOvfUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Add_Ovf_Un;
	}

	public static bool MatchAnd(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.And;
	}

	public static bool MatchArglist(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Arglist;
	}

	public static bool MatchBeq(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Beq || instr.OpCode == OpCodes.Beq_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBeq(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBeq(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBeq(this Instruction instr, Instruction value)
	{
		if (instr.MatchBeq(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBge(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Bge || instr.OpCode == OpCodes.Bge_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBge(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBge(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBge(this Instruction instr, Instruction value)
	{
		if (instr.MatchBge(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBgeUn(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Bge_Un || instr.OpCode == OpCodes.Bge_Un_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBgeUn(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBgeUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBgeUn(this Instruction instr, Instruction value)
	{
		if (instr.MatchBgeUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBgt(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Bgt || instr.OpCode == OpCodes.Bgt_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBgt(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBgt(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBgt(this Instruction instr, Instruction value)
	{
		if (instr.MatchBgt(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBgtUn(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Bgt_Un || instr.OpCode == OpCodes.Bgt_Un_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBgtUn(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBgtUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBgtUn(this Instruction instr, Instruction value)
	{
		if (instr.MatchBgtUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBle(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ble || instr.OpCode == OpCodes.Ble_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBle(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBle(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBle(this Instruction instr, Instruction value)
	{
		if (instr.MatchBle(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBleUn(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ble_Un || instr.OpCode == OpCodes.Ble_Un_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBleUn(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBleUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBleUn(this Instruction instr, Instruction value)
	{
		if (instr.MatchBleUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBlt(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Blt || instr.OpCode == OpCodes.Blt_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBlt(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBlt(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBlt(this Instruction instr, Instruction value)
	{
		if (instr.MatchBlt(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBltUn(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Blt_Un || instr.OpCode == OpCodes.Blt_Un_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBltUn(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBltUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBltUn(this Instruction instr, Instruction value)
	{
		if (instr.MatchBltUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBneUn(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Bne_Un || instr.OpCode == OpCodes.Bne_Un_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBneUn(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBneUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBneUn(this Instruction instr, Instruction value)
	{
		if (instr.MatchBneUn(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBox(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Box)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBox(this Instruction instr, TypeReference value)
	{
		if (instr.MatchBox(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBox(this Instruction instr, Type value)
	{
		if (instr.MatchBox(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBox<T>(this Instruction instr)
	{
		return instr.MatchBox(typeof(T));
	}

	public static bool MatchBox(this Instruction instr, string typeFullName)
	{
		if (instr.MatchBox(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchBr(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Br || instr.OpCode == OpCodes.Br_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBr(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBr(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBr(this Instruction instr, Instruction value)
	{
		if (instr.MatchBr(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBreak(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Break;
	}

	public static bool MatchBrfalse(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Brfalse || instr.OpCode == OpCodes.Brfalse_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBrfalse(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBrfalse(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBrfalse(this Instruction instr, Instruction value)
	{
		if (instr.MatchBrfalse(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBrtrue(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Brtrue || instr.OpCode == OpCodes.Brtrue_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchBrtrue(this Instruction instr, ILLabel value)
	{
		if (instr.MatchBrtrue(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchBrtrue(this Instruction instr, Instruction value)
	{
		if (instr.MatchBrtrue(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCall(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Call)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchCall(this Instruction instr, MethodReference value)
	{
		if (instr.MatchCall(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCall(this Instruction instr, MethodBase value)
	{
		if (instr.MatchCall(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCall(this Instruction instr, Type type, string name)
	{
		if (instr.MatchCall(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchCall<T>(this Instruction instr, string name)
	{
		return instr.MatchCall(typeof(T), name);
	}

	public static bool MatchCall(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchCall(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchCalli(this Instruction instr, [MaybeNullWhen(false)] out IMethodSignature value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Calli)
		{
			value = (IMethodSignature)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchCalli(this Instruction instr, IMethodSignature value)
	{
		if (instr.MatchCalli(out IMethodSignature value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCallvirt(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Callvirt)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchCallvirt(this Instruction instr, MethodReference value)
	{
		if (instr.MatchCallvirt(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCallvirt(this Instruction instr, MethodBase value)
	{
		if (instr.MatchCallvirt(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCallvirt(this Instruction instr, Type type, string name)
	{
		if (instr.MatchCallvirt(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchCallvirt<T>(this Instruction instr, string name)
	{
		return instr.MatchCallvirt(typeof(T), name);
	}

	public static bool MatchCallvirt(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchCallvirt(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchCallOrCallvirt(this Instruction instr, MethodReference value)
	{
		if (instr.MatchCallOrCallvirt(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCallOrCallvirt(this Instruction instr, MethodBase value)
	{
		if (instr.MatchCallOrCallvirt(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCallOrCallvirt(this Instruction instr, Type type, string name)
	{
		if (instr.MatchCallOrCallvirt(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchCallOrCallvirt<T>(this Instruction instr, string name)
	{
		return instr.MatchCallOrCallvirt(typeof(T), name);
	}

	public static bool MatchCallOrCallvirt(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchCallOrCallvirt(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchCastclass(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Castclass)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchCastclass(this Instruction instr, TypeReference value)
	{
		if (instr.MatchCastclass(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCastclass(this Instruction instr, Type value)
	{
		if (instr.MatchCastclass(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCastclass<T>(this Instruction instr)
	{
		return instr.MatchCastclass(typeof(T));
	}

	public static bool MatchCastclass(this Instruction instr, string typeFullName)
	{
		if (instr.MatchCastclass(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchCeq(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ceq;
	}

	public static bool MatchCgt(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Cgt;
	}

	public static bool MatchCgtUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Cgt_Un;
	}

	public static bool MatchCkfinite(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ckfinite;
	}

	public static bool MatchClt(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Clt;
	}

	public static bool MatchCltUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Clt_Un;
	}

	public static bool MatchConstrained(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Constrained)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchConstrained(this Instruction instr, TypeReference value)
	{
		if (instr.MatchConstrained(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchConstrained(this Instruction instr, Type value)
	{
		if (instr.MatchConstrained(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchConstrained<T>(this Instruction instr)
	{
		return instr.MatchConstrained(typeof(T));
	}

	public static bool MatchConstrained(this Instruction instr, string typeFullName)
	{
		if (instr.MatchConstrained(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchConvI(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_I;
	}

	public static bool MatchConvI1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_I1;
	}

	public static bool MatchConvI2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_I2;
	}

	public static bool MatchConvI4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_I4;
	}

	public static bool MatchConvI8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_I8;
	}

	public static bool MatchConvOvfI(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I;
	}

	public static bool MatchConvOvfIUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I_Un;
	}

	public static bool MatchConvOvfI1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I1;
	}

	public static bool MatchConvOvfI1Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I1_Un;
	}

	public static bool MatchConvOvfI2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I2;
	}

	public static bool MatchConvOvfI2Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I2_Un;
	}

	public static bool MatchConvOvfI4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I4;
	}

	public static bool MatchConvOvfI4Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I4_Un;
	}

	public static bool MatchConvOvfI8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I8;
	}

	public static bool MatchConvOvfI8Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_I8_Un;
	}

	public static bool MatchConvOvfU(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U;
	}

	public static bool MatchConvOvfUUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U_Un;
	}

	public static bool MatchConvOvfU1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U1;
	}

	public static bool MatchConvOvfU1Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U1_Un;
	}

	public static bool MatchConvOvfU2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U2;
	}

	public static bool MatchConvOvfU2Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U2_Un;
	}

	public static bool MatchConvOvfU4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U4;
	}

	public static bool MatchConvOvfU4Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U4_Un;
	}

	public static bool MatchConvOvfU8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U8;
	}

	public static bool MatchConvOvfU8Un(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_Ovf_U8_Un;
	}

	public static bool MatchConvRUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_R_Un;
	}

	public static bool MatchConvR4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_R4;
	}

	public static bool MatchConvR8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_R8;
	}

	public static bool MatchConvU(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_U;
	}

	public static bool MatchConvU1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_U1;
	}

	public static bool MatchConvU2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_U2;
	}

	public static bool MatchConvU4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_U4;
	}

	public static bool MatchConvU8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Conv_U8;
	}

	public static bool MatchCpblk(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Cpblk;
	}

	public static bool MatchCpobj(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Cpobj)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchCpobj(this Instruction instr, TypeReference value)
	{
		if (instr.MatchCpobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCpobj(this Instruction instr, Type value)
	{
		if (instr.MatchCpobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchCpobj<T>(this Instruction instr)
	{
		return instr.MatchCpobj(typeof(T));
	}

	public static bool MatchCpobj(this Instruction instr, string typeFullName)
	{
		if (instr.MatchCpobj(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchDiv(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Div;
	}

	public static bool MatchDivUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Div_Un;
	}

	public static bool MatchDup(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Dup;
	}

	public static bool MatchEndfilter(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Endfilter;
	}

	public static bool MatchEndfinally(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Endfinally;
	}

	public static bool MatchInitblk(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Initblk;
	}

	public static bool MatchInitobj(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Initobj)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchInitobj(this Instruction instr, TypeReference value)
	{
		if (instr.MatchInitobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchInitobj(this Instruction instr, Type value)
	{
		if (instr.MatchInitobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchInitobj<T>(this Instruction instr)
	{
		return instr.MatchInitobj(typeof(T));
	}

	public static bool MatchInitobj(this Instruction instr, string typeFullName)
	{
		if (instr.MatchInitobj(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchIsinst(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Isinst)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchIsinst(this Instruction instr, TypeReference value)
	{
		if (instr.MatchIsinst(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchIsinst(this Instruction instr, Type value)
	{
		if (instr.MatchIsinst(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchIsinst<T>(this Instruction instr)
	{
		return instr.MatchIsinst(typeof(T));
	}

	public static bool MatchIsinst(this Instruction instr, string typeFullName)
	{
		if (instr.MatchIsinst(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchJmp(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Jmp)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchJmp(this Instruction instr, MethodReference value)
	{
		if (instr.MatchJmp(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchJmp(this Instruction instr, MethodBase value)
	{
		if (instr.MatchJmp(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchJmp(this Instruction instr, Type type, string name)
	{
		if (instr.MatchJmp(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchJmp<T>(this Instruction instr, string name)
	{
		return instr.MatchJmp(typeof(T), name);
	}

	public static bool MatchJmp(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchJmp(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLdarg0(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldarg_0;
	}

	public static bool MatchLdarg1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldarg_1;
	}

	public static bool MatchLdarg2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldarg_2;
	}

	public static bool MatchLdarg3(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldarg_3;
	}

	public static bool MatchLdarg(this Instruction instr, int value)
	{
		if (instr.MatchLdarg(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdarg(this Instruction instr, uint value)
	{
		if (instr.MatchLdarg(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdarga(this Instruction instr, int value)
	{
		if (instr.MatchLdarga(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdarga(this Instruction instr, uint value)
	{
		if (instr.MatchLdarga(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdcI4(this Instruction instr, int value)
	{
		if (instr.MatchLdcI4(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdcI4(this Instruction instr, uint value)
	{
		if (instr.MatchLdcI4(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdcI8(this Instruction instr, [MaybeNullWhen(false)] out long value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldc_I8)
		{
			value = (long)instr.Operand;
			return true;
		}
		value = 0L;
		return false;
	}

	public static bool MatchLdcI8(this Instruction instr, long value)
	{
		if (instr.MatchLdcI8(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdcI8(this Instruction instr, ulong value)
	{
		if (instr.MatchLdcI8(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdcR4(this Instruction instr, [MaybeNullWhen(false)] out float value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldc_R4)
		{
			value = (float)instr.Operand;
			return true;
		}
		value = 0f;
		return false;
	}

	public static bool MatchLdcR4(this Instruction instr, float value)
	{
		if (instr.MatchLdcR4(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdcR8(this Instruction instr, [MaybeNullWhen(false)] out double value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldc_R8)
		{
			value = (double)instr.Operand;
			return true;
		}
		value = 0.0;
		return false;
	}

	public static bool MatchLdcR8(this Instruction instr, double value)
	{
		if (instr.MatchLdcR8(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdelemAny(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_Any)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdelemAny(this Instruction instr, TypeReference value)
	{
		if (instr.MatchLdelemAny(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdelemAny(this Instruction instr, Type value)
	{
		if (instr.MatchLdelemAny(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdelemAny<T>(this Instruction instr)
	{
		return instr.MatchLdelemAny(typeof(T));
	}

	public static bool MatchLdelemAny(this Instruction instr, string typeFullName)
	{
		if (instr.MatchLdelemAny(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchLdelemI(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_I;
	}

	public static bool MatchLdelemI1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_I1;
	}

	public static bool MatchLdelemI2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_I2;
	}

	public static bool MatchLdelemI4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_I4;
	}

	public static bool MatchLdelemI8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_I8;
	}

	public static bool MatchLdelemR4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_R4;
	}

	public static bool MatchLdelemR8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_R8;
	}

	public static bool MatchLdelemRef(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_Ref;
	}

	public static bool MatchLdelemU1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_U1;
	}

	public static bool MatchLdelemU2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_U2;
	}

	public static bool MatchLdelemU4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelem_U4;
	}

	public static bool MatchLdelema(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldelema)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdelema(this Instruction instr, TypeReference value)
	{
		if (instr.MatchLdelema(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdelema(this Instruction instr, Type value)
	{
		if (instr.MatchLdelema(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdelema<T>(this Instruction instr)
	{
		return instr.MatchLdelema(typeof(T));
	}

	public static bool MatchLdelema(this Instruction instr, string typeFullName)
	{
		if (instr.MatchLdelema(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchLdfld(this Instruction instr, [MaybeNullWhen(false)] out FieldReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldfld)
		{
			value = (FieldReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdfld(this Instruction instr, FieldReference value)
	{
		if (instr.MatchLdfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdfld(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchLdfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdfld(this Instruction instr, Type type, string name)
	{
		if (instr.MatchLdfld(out FieldReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchLdfld<T>(this Instruction instr, string name)
	{
		return instr.MatchLdfld(typeof(T), name);
	}

	public static bool MatchLdfld(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchLdfld(out FieldReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLdflda(this Instruction instr, [MaybeNullWhen(false)] out FieldReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldflda)
		{
			value = (FieldReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdflda(this Instruction instr, FieldReference value)
	{
		if (instr.MatchLdflda(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdflda(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchLdflda(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdflda(this Instruction instr, Type type, string name)
	{
		if (instr.MatchLdflda(out FieldReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchLdflda<T>(this Instruction instr, string name)
	{
		return instr.MatchLdflda(typeof(T), name);
	}

	public static bool MatchLdflda(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchLdflda(out FieldReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLdftn(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldftn)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdftn(this Instruction instr, MethodReference value)
	{
		if (instr.MatchLdftn(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdftn(this Instruction instr, MethodBase value)
	{
		if (instr.MatchLdftn(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdftn(this Instruction instr, Type type, string name)
	{
		if (instr.MatchLdftn(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchLdftn<T>(this Instruction instr, string name)
	{
		return instr.MatchLdftn(typeof(T), name);
	}

	public static bool MatchLdftn(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchLdftn(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLdindI(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_I;
	}

	public static bool MatchLdindI1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_I1;
	}

	public static bool MatchLdindI2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_I2;
	}

	public static bool MatchLdindI4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_I4;
	}

	public static bool MatchLdindI8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_I8;
	}

	public static bool MatchLdindR4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_R4;
	}

	public static bool MatchLdindR8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_R8;
	}

	public static bool MatchLdindRef(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_Ref;
	}

	public static bool MatchLdindU1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_U1;
	}

	public static bool MatchLdindU2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_U2;
	}

	public static bool MatchLdindU4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldind_U4;
	}

	public static bool MatchLdlen(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldlen;
	}

	public static bool MatchLdloc0(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldloc_0;
	}

	public static bool MatchLdloc1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldloc_1;
	}

	public static bool MatchLdloc2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldloc_2;
	}

	public static bool MatchLdloc3(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldloc_3;
	}

	public static bool MatchLdloc(this Instruction instr, int value)
	{
		if (instr.MatchLdloc(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdloc(this Instruction instr, uint value)
	{
		if (instr.MatchLdloc(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdloca(this Instruction instr, int value)
	{
		if (instr.MatchLdloca(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdloca(this Instruction instr, uint value)
	{
		if (instr.MatchLdloca(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdnull(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldnull;
	}

	public static bool MatchLdobj(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldobj)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdobj(this Instruction instr, TypeReference value)
	{
		if (instr.MatchLdobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdobj(this Instruction instr, Type value)
	{
		if (instr.MatchLdobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdobj<T>(this Instruction instr)
	{
		return instr.MatchLdobj(typeof(T));
	}

	public static bool MatchLdobj(this Instruction instr, string typeFullName)
	{
		if (instr.MatchLdobj(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchLdsfld(this Instruction instr, [MaybeNullWhen(false)] out FieldReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldsfld)
		{
			value = (FieldReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdsfld(this Instruction instr, FieldReference value)
	{
		if (instr.MatchLdsfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdsfld(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchLdsfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdsfld(this Instruction instr, Type type, string name)
	{
		if (instr.MatchLdsfld(out FieldReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchLdsfld<T>(this Instruction instr, string name)
	{
		return instr.MatchLdsfld(typeof(T), name);
	}

	public static bool MatchLdsfld(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchLdsfld(out FieldReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLdsflda(this Instruction instr, [MaybeNullWhen(false)] out FieldReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldsflda)
		{
			value = (FieldReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdsflda(this Instruction instr, FieldReference value)
	{
		if (instr.MatchLdsflda(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdsflda(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchLdsflda(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdsflda(this Instruction instr, Type type, string name)
	{
		if (instr.MatchLdsflda(out FieldReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchLdsflda<T>(this Instruction instr, string name)
	{
		return instr.MatchLdsflda(typeof(T), name);
	}

	public static bool MatchLdsflda(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchLdsflda(out FieldReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLdstr(this Instruction instr, [MaybeNullWhen(false)] out string value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldstr)
		{
			value = (string)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdstr(this Instruction instr, string value)
	{
		if (instr.MatchLdstr(out string value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdtoken(this Instruction instr, [MaybeNullWhen(false)] out IMetadataTokenProvider value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldtoken)
		{
			value = (IMetadataTokenProvider)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdtoken(this Instruction instr, IMetadataTokenProvider value)
	{
		if (instr.MatchLdtoken(out IMetadataTokenProvider value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdtoken(this Instruction instr, Type value)
	{
		if (instr.MatchLdtoken(out IMetadataTokenProvider value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdtoken<T>(this Instruction instr)
	{
		return instr.MatchLdtoken(typeof(T));
	}

	public static bool MatchLdtoken(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchLdtoken(out IMetadataTokenProvider value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdtoken(this Instruction instr, MethodBase value)
	{
		if (instr.MatchLdtoken(out IMetadataTokenProvider value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdvirtftn(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ldvirtftn)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLdvirtftn(this Instruction instr, MethodReference value)
	{
		if (instr.MatchLdvirtftn(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdvirtftn(this Instruction instr, MethodBase value)
	{
		if (instr.MatchLdvirtftn(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLdvirtftn(this Instruction instr, Type type, string name)
	{
		if (instr.MatchLdvirtftn(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchLdvirtftn<T>(this Instruction instr, string name)
	{
		return instr.MatchLdvirtftn(typeof(T), name);
	}

	public static bool MatchLdvirtftn(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchLdvirtftn(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchLeave(this Instruction instr, [MaybeNullWhen(false)] out ILLabel value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Leave || instr.OpCode == OpCodes.Leave_S)
		{
			value = (ILLabel)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchLeave(this Instruction instr, ILLabel value)
	{
		if (instr.MatchLeave(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLeave(this Instruction instr, Instruction value)
	{
		if (instr.MatchLeave(out ILLabel value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchLocalloc(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Localloc;
	}

	public static bool MatchMkrefany(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Mkrefany)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchMkrefany(this Instruction instr, TypeReference value)
	{
		if (instr.MatchMkrefany(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchMkrefany(this Instruction instr, Type value)
	{
		if (instr.MatchMkrefany(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchMkrefany<T>(this Instruction instr)
	{
		return instr.MatchMkrefany(typeof(T));
	}

	public static bool MatchMkrefany(this Instruction instr, string typeFullName)
	{
		if (instr.MatchMkrefany(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchMul(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Mul;
	}

	public static bool MatchMulOvf(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Mul_Ovf;
	}

	public static bool MatchMulOvfUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Mul_Ovf_Un;
	}

	public static bool MatchNeg(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Neg;
	}

	public static bool MatchNewarr(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Newarr)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchNewarr(this Instruction instr, TypeReference value)
	{
		if (instr.MatchNewarr(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchNewarr(this Instruction instr, Type value)
	{
		if (instr.MatchNewarr(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchNewarr<T>(this Instruction instr)
	{
		return instr.MatchNewarr(typeof(T));
	}

	public static bool MatchNewarr(this Instruction instr, string typeFullName)
	{
		if (instr.MatchNewarr(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchNewobj(this Instruction instr, [MaybeNullWhen(false)] out MethodReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Newobj)
		{
			value = (MethodReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchNewobj(this Instruction instr, MethodReference value)
	{
		if (instr.MatchNewobj(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchNewobj(this Instruction instr, MethodBase value)
	{
		if (instr.MatchNewobj(out MethodReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchNewobj(this Instruction instr, Type type, string name)
	{
		if (instr.MatchNewobj(out MethodReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchNewobj<T>(this Instruction instr, string name)
	{
		return instr.MatchNewobj(typeof(T), name);
	}

	public static bool MatchNewobj(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchNewobj(out MethodReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchNop(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Nop;
	}

	public static bool MatchNot(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Not;
	}

	public static bool MatchOr(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Or;
	}

	public static bool MatchPop(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Pop;
	}

	public static bool MatchReadonly(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Readonly;
	}

	public static bool MatchRefanytype(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Refanytype;
	}

	public static bool MatchRefanyval(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Refanyval)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchRefanyval(this Instruction instr, TypeReference value)
	{
		if (instr.MatchRefanyval(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchRefanyval(this Instruction instr, Type value)
	{
		if (instr.MatchRefanyval(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchRefanyval<T>(this Instruction instr)
	{
		return instr.MatchRefanyval(typeof(T));
	}

	public static bool MatchRefanyval(this Instruction instr, string typeFullName)
	{
		if (instr.MatchRefanyval(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchRem(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Rem;
	}

	public static bool MatchRemUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Rem_Un;
	}

	public static bool MatchRet(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Ret;
	}

	public static bool MatchRethrow(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Rethrow;
	}

	public static bool MatchShl(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Shl;
	}

	public static bool MatchShr(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Shr;
	}

	public static bool MatchShrUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Shr_Un;
	}

	public static bool MatchSizeof(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Sizeof)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchSizeof(this Instruction instr, TypeReference value)
	{
		if (instr.MatchSizeof(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchSizeof(this Instruction instr, Type value)
	{
		if (instr.MatchSizeof(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchSizeof<T>(this Instruction instr)
	{
		return instr.MatchSizeof(typeof(T));
	}

	public static bool MatchSizeof(this Instruction instr, string typeFullName)
	{
		if (instr.MatchSizeof(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchStarg(this Instruction instr, int value)
	{
		if (instr.MatchStarg(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStarg(this Instruction instr, uint value)
	{
		if (instr.MatchStarg(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStelemAny(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_Any)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchStelemAny(this Instruction instr, TypeReference value)
	{
		if (instr.MatchStelemAny(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStelemAny(this Instruction instr, Type value)
	{
		if (instr.MatchStelemAny(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStelemAny<T>(this Instruction instr)
	{
		return instr.MatchStelemAny(typeof(T));
	}

	public static bool MatchStelemAny(this Instruction instr, string typeFullName)
	{
		if (instr.MatchStelemAny(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchStelemI(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_I;
	}

	public static bool MatchStelemI1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_I1;
	}

	public static bool MatchStelemI2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_I2;
	}

	public static bool MatchStelemI4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_I4;
	}

	public static bool MatchStelemI8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_I8;
	}

	public static bool MatchStelemR4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_R4;
	}

	public static bool MatchStelemR8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_R8;
	}

	public static bool MatchStelemRef(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stelem_Ref;
	}

	public static bool MatchStfld(this Instruction instr, [MaybeNullWhen(false)] out FieldReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stfld)
		{
			value = (FieldReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchStfld(this Instruction instr, FieldReference value)
	{
		if (instr.MatchStfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStfld(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchStfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStfld(this Instruction instr, Type type, string name)
	{
		if (instr.MatchStfld(out FieldReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchStfld<T>(this Instruction instr, string name)
	{
		return instr.MatchStfld(typeof(T), name);
	}

	public static bool MatchStfld(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchStfld(out FieldReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchStindI(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_I;
	}

	public static bool MatchStindI1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_I1;
	}

	public static bool MatchStindI2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_I2;
	}

	public static bool MatchStindI4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_I4;
	}

	public static bool MatchStindI8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_I8;
	}

	public static bool MatchStindR4(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_R4;
	}

	public static bool MatchStindR8(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_R8;
	}

	public static bool MatchStindRef(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stind_Ref;
	}

	public static bool MatchStloc0(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stloc_0;
	}

	public static bool MatchStloc1(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stloc_1;
	}

	public static bool MatchStloc2(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stloc_2;
	}

	public static bool MatchStloc3(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stloc_3;
	}

	public static bool MatchStloc(this Instruction instr, int value)
	{
		if (instr.MatchStloc(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStloc(this Instruction instr, uint value)
	{
		if (instr.MatchStloc(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStobj(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stobj)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchStobj(this Instruction instr, TypeReference value)
	{
		if (instr.MatchStobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStobj(this Instruction instr, Type value)
	{
		if (instr.MatchStobj(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStobj<T>(this Instruction instr)
	{
		return instr.MatchStobj(typeof(T));
	}

	public static bool MatchStobj(this Instruction instr, string typeFullName)
	{
		if (instr.MatchStobj(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchStsfld(this Instruction instr, [MaybeNullWhen(false)] out FieldReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Stsfld)
		{
			value = (FieldReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchStsfld(this Instruction instr, FieldReference value)
	{
		if (instr.MatchStsfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStsfld(this Instruction instr, FieldInfo value)
	{
		if (instr.MatchStsfld(out FieldReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchStsfld(this Instruction instr, Type type, string name)
	{
		if (instr.MatchStsfld(out FieldReference value))
		{
			return IsEquivalent(value, type, name);
		}
		return false;
	}

	public static bool MatchStsfld<T>(this Instruction instr, string name)
	{
		return instr.MatchStsfld(typeof(T), name);
	}

	public static bool MatchStsfld(this Instruction instr, string typeFullName, string name)
	{
		if (instr.MatchStsfld(out FieldReference value))
		{
			return value.Is(typeFullName, name);
		}
		return false;
	}

	public static bool MatchSub(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Sub;
	}

	public static bool MatchSubOvf(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Sub_Ovf;
	}

	public static bool MatchSubOvfUn(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Sub_Ovf_Un;
	}

	public static bool MatchSwitch(this Instruction instr, [MaybeNullWhen(false)] out ILLabel[] value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Switch)
		{
			value = (ILLabel[])instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchSwitch(this Instruction instr, ILLabel[] value)
	{
		if (instr.MatchSwitch(out ILLabel[] value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchSwitch(this Instruction instr, Instruction[] value)
	{
		if (instr.MatchSwitch(out ILLabel[] value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchTail(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Tail;
	}

	public static bool MatchThrow(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Throw;
	}

	public static bool MatchUnaligned(this Instruction instr, [MaybeNullWhen(false)] out byte value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Unaligned)
		{
			value = (byte)instr.Operand;
			return true;
		}
		value = 0;
		return false;
	}

	public static bool MatchUnaligned(this Instruction instr, byte value)
	{
		if (instr.MatchUnaligned(out var value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchUnbox(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Unbox)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchUnbox(this Instruction instr, TypeReference value)
	{
		if (instr.MatchUnbox(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchUnbox(this Instruction instr, Type value)
	{
		if (instr.MatchUnbox(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchUnbox<T>(this Instruction instr)
	{
		return instr.MatchUnbox(typeof(T));
	}

	public static bool MatchUnbox(this Instruction instr, string typeFullName)
	{
		if (instr.MatchUnbox(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchUnboxAny(this Instruction instr, [MaybeNullWhen(false)] out TypeReference value)
	{
		if (Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Unbox_Any)
		{
			value = (TypeReference)instr.Operand;
			return true;
		}
		value = null;
		return false;
	}

	public static bool MatchUnboxAny(this Instruction instr, TypeReference value)
	{
		if (instr.MatchUnboxAny(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchUnboxAny(this Instruction instr, Type value)
	{
		if (instr.MatchUnboxAny(out TypeReference value2))
		{
			return IsEquivalent(value2, value);
		}
		return false;
	}

	public static bool MatchUnboxAny<T>(this Instruction instr)
	{
		return instr.MatchUnboxAny(typeof(T));
	}

	public static bool MatchUnboxAny(this Instruction instr, string typeFullName)
	{
		if (instr.MatchUnboxAny(out TypeReference value))
		{
			return value.Is(typeFullName);
		}
		return false;
	}

	public static bool MatchVolatile(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Volatile;
	}

	public static bool MatchXor(this Instruction instr)
	{
		return Helpers.ThrowIfNull(instr, "instr").OpCode == OpCodes.Xor;
	}
}


using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Mono.Cecil;

private sealed class ParameterRefEqualityComparer : IEqualityComparer<ParameterReference>
{
	public static readonly ParameterRefEqualityComparer Instance = new ParameterRefEqualityComparer();

	public bool Equals(ParameterReference? x, ParameterReference? y)
	{
		if (x == null)
		{
			return y == null;
		}
		if (y == null)
		{
			return false;
		}
		return IsEquivalent(x.ParameterType, y.ParameterType);
	}

	public int GetHashCode([DisallowNull] ParameterReference obj)
	{
		return obj.ParameterType.GetHashCode();
	}
}


internal enum ArchitectureKind
{
	Unknown,
	Bits64,
	x86,
	x86_64,
	Arm,
	Arm64
}


using System;

internal sealed class AssertionFailedException : Exception
{
	private const string AssertFailed = "Assertion failed! ";

	public string Expression { get; } = "";

	public new string Message { get; }

	public AssertionFailedException()
	{
		Message = "";
	}

	public AssertionFailedException(string? message)
		: base("Assertion failed! " + message)
	{
		Message = message ?? "";
	}

	public AssertionFailedException(string? message, Exception innerException)
		: base("Assertion failed! " + message, innerException)
	{
		Message = message ?? "";
	}

	public AssertionFailedException(string? message, string expression)
		: base("Assertion failed! " + expression + " " + message)
	{
		Message = message ?? "";
		Expression = expression;
	}
}


internal abstract class ScopeHandlerBase
{
	public abstract void EndScope(object? data);
}


using System;
using MonoMod.Utils;

internal readonly struct DataScope : IDisposable
{
	private readonly ScopeHandlerBase? handler;

	private readonly object? data;

	public object? Data => data;

	public DataScope(ScopeHandlerBase handler, object? data)
	{
		this.handler = handler;
		this.data = data;
	}

	public void Dispose()
	{
		if (handler != null)
		{
			handler.EndScope(data);
		}
	}
}


using MonoMod.Utils;

internal abstract class ScopeHandlerBase<T> : ScopeHandlerBase
{
	public sealed override void EndScope(object? data)
	{
		EndScope((T)data);
	}

	public abstract void EndScope(T data);
}


using System;
using MonoMod.Utils;

internal readonly struct DataScope<T> : IDisposable
{
	private readonly ScopeHandlerBase<T>? handler;

	private readonly T data;

	public T Data => data;

	public DataScope(ScopeHandlerBase<T> handler, T data)
	{
		this.handler = handler;
		this.data = data;
	}

	public void Dispose()
	{
		if (handler != null)
		{
			handler.EndScope(data);
		}
	}
}


using System.Reflection;
using MonoMod.Utils;

internal interface IDMDGenerator
{
	MethodInfo Generate(DynamicMethodDefinition dmd, object? context);
}


using System.Reflection;
using System.Reflection.Emit;
using MonoMod.Utils;

internal abstract class DMDGenerator<TSelf> : IDMDGenerator where TSelf : DMDGenerator<TSelf>, new()
{
	private static TSelf? Instance;

	protected abstract MethodInfo GenerateCore(DynamicMethodDefinition dmd, object? context);

	MethodInfo IDMDGenerator.Generate(DynamicMethodDefinition dmd, object? context)
	{
		return Postbuild(GenerateCore(dmd, context));
	}

	public static MethodInfo Generate(DynamicMethodDefinition dmd, object? context = null)
	{
		return Postbuild((Instance ?? (Instance = new TSelf())).GenerateCore(dmd, context));
	}

	internal static MethodInfo Postbuild(MethodInfo mi)
	{
		if (PlatformDetection.Runtime == RuntimeKind.Mono && !(mi is DynamicMethod) && mi.DeclaringType != null)
		{
			Module module = mi.Module;
			if ((object)module == null)
			{
				return mi;
			}
			Assembly assembly = module.Assembly;
			if ((object)assembly.GetType() == null)
			{
				return mi;
			}
			assembly.SetMonoCorlibInternal(value: true);
		}
		return mi;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod;
using MonoMod.Utils;

internal sealed class DMDCecilGenerator : DMDGenerator<DMDCecilGenerator>
{
	protected override MethodInfo GenerateCore(DynamicMethodDefinition dmd, object? context)
	{
		MethodDefinition def = dmd.Definition ?? throw new InvalidOperationException();
		TypeDefinition typeDefinition = context as TypeDefinition;
		bool flag = false;
		ModuleDefinition module = typeDefinition?.Module;
		HashSet<string> hashSet = null;
		try
		{
			if (typeDefinition == null || module == null)
			{
				flag = true;
				string dumpName = dmd.GetDumpName("Cecil");
				module = ModuleDefinition.CreateModule(dumpName, new ModuleParameters
				{
					Kind = ModuleKind.Dll,
					ReflectionImporterProvider = MMReflectionImporter.ProviderNoDefault
				});
				hashSet = new HashSet<string>();
				module.Assembly.CustomAttributes.Add(new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_UnverifiableCodeAttribute)));
				if (dmd.Debug)
				{
					CustomAttribute customAttribute = new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_DebuggableAttribute));
					customAttribute.ConstructorArguments.Add(new CustomAttributeArgument(module.ImportReference(typeof(DebuggableAttribute.DebuggingModes)), DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations));
					module.Assembly.CustomAttributes.Add(customAttribute);
				}
				typeDefinition = new TypeDefinition("", $"DMD<{dmd.OriginalMethod?.Name?.Replace('.', '_')}>?{GetHashCode()}", Mono.Cecil.TypeAttributes.Public | Mono.Cecil.TypeAttributes.Abstract | Mono.Cecil.TypeAttributes.Sealed)
				{
					BaseType = module.TypeSystem.Object
				};
				module.Types.Add(typeDefinition);
			}
			MethodDefinition clone = null;
			new TypeReference("System.Runtime.CompilerServices", "IsVolatile", module, module.TypeSystem.CoreLibrary);
			Relinker relinker = delegate(IMetadataTokenProvider mtp, IGenericParameterProvider? ctx)
			{
				if (mtp == def)
				{
					return clone;
				}
				return (mtp is MethodReference methodReference && methodReference.FullName == def.FullName && methodReference.DeclaringType.FullName == def.DeclaringType.FullName && methodReference.DeclaringType.Scope.Name == def.DeclaringType.Scope.Name) ? clone : module.ImportReference(mtp);
			};
			clone = new MethodDefinition(dmd.Name ?? ("_" + def.Name.Replace('.', '_')), def.Attributes, module.TypeSystem.Void)
			{
				MethodReturnType = def.MethodReturnType,
				Attributes = (Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Static | Mono.Cecil.MethodAttributes.HideBySig),
				ImplAttributes = Mono.Cecil.MethodImplAttributes.IL,
				DeclaringType = typeDefinition,
				NoInlining = true
			};
			foreach (ParameterDefinition parameter in def.Parameters)
			{
				clone.Parameters.Add(parameter.Clone().Relink(relinker, clone));
			}
			clone.ReturnType = def.ReturnType.Relink(relinker, clone);
			typeDefinition.Methods.Add(clone);
			clone.HasThis = def.HasThis;
			Mono.Cecil.Cil.MethodBody methodBody2 = (clone.Body = def.Body.Clone(clone));
			Mono.Cecil.Cil.MethodBody methodBody3 = methodBody2;
			foreach (VariableDefinition variable in clone.Body.Variables)
			{
				variable.VariableType = variable.VariableType.Relink(relinker, clone);
			}
			foreach (ExceptionHandler exceptionHandler in clone.Body.ExceptionHandlers)
			{
				if (exceptionHandler.CatchType != null)
				{
					exceptionHandler.CatchType = exceptionHandler.CatchType.Relink(relinker, clone);
				}
			}
			for (int i = 0; i < methodBody3.Instructions.Count; i++)
			{
				Instruction instruction = methodBody3.Instructions[i];
				object obj = instruction.Operand;
				if (obj is ParameterDefinition parameterDefinition)
				{
					obj = clone.Parameters[parameterDefinition.Index];
				}
				else if (obj is IMetadataTokenProvider mtp2)
				{
					obj = mtp2.Relink(relinker, clone);
				}
				_ = obj is DynamicMethodReference;
				if (hashSet != null && obj is MemberReference memberReference)
				{
					IMetadataScope metadataScope = (memberReference as TypeReference)?.Scope ?? memberReference.DeclaringType.Scope;
					if (!hashSet.Contains(metadataScope.Name))
					{
						CustomAttribute item = new CustomAttribute(module.ImportReference(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute))
						{
							ConstructorArguments = 
							{
								new CustomAttributeArgument(module.ImportReference(typeof(DebuggableAttribute.DebuggingModes)), metadataScope.Name)
							}
						};
						module.Assembly.CustomAttributes.Add(item);
						hashSet.Add(metadataScope.Name);
					}
				}
				instruction.Operand = obj;
			}
			clone.HasThis = false;
			if (def.HasThis)
			{
				TypeReference typeReference = def.DeclaringType;
				if (typeReference.IsValueType)
				{
					typeReference = new ByReferenceType(typeReference);
				}
				clone.Parameters.Insert(0, new ParameterDefinition("<>_this", Mono.Cecil.ParameterAttributes.None, typeReference.Relink(relinker, clone)));
			}
			object value;
			string text = (Switches.TryGetSwitchValue("DMDDumpTo", out value) ? (value as string) : null);
			if (!string.IsNullOrEmpty(text))
			{
				string fullPath = Path.GetFullPath(text);
				string path = module.Name + ".dll";
				string path2 = Path.Combine(fullPath, path);
				fullPath = Path.GetDirectoryName(path2);
				if (!string.IsNullOrEmpty(fullPath) && !Directory.Exists(fullPath))
				{
					Directory.CreateDirectory(fullPath);
				}
				if (File.Exists(path2))
				{
					File.Delete(path2);
				}
				using Stream stream = File.OpenWrite(path2);
				module.Write(stream);
			}
			return ReflectionHelper.Load(module).GetType(System.StringExtensions.Replace(typeDefinition.FullName, "+", "\\+", StringComparison.Ordinal), throwOnError: false, ignoreCase: false).GetMethod(clone.Name, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic) ?? throw new InvalidOperationException("Could not find generated method");
		}
		finally
		{
			if (flag)
			{
				module.Dispose();
			}
			module = null;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.SymbolStore;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod.Utils;
using MonoMod.Utils.Cil;

internal static class _DMDEmit
{
	private static readonly MethodInfo m_MethodBase_InvokeSimple;

	private static readonly Dictionary<short, System.Reflection.Emit.OpCode> _ReflOpCodes;

	private static readonly Dictionary<short, Mono.Cecil.Cil.OpCode> _CecilOpCodes;

	private static readonly MethodInfo? _ILGen_make_room;

	private static readonly MethodInfo? _ILGen_emit_int;

	private static readonly MethodInfo? _ILGen_ll_emit;

	private static readonly MethodInfo? _ILGen_EnsureCapacity;

	private static readonly MethodInfo? _ILGen_PutInteger4;

	private static readonly MethodInfo? _ILGen_InternalEmit;

	private static readonly MethodInfo? _ILGen_UpdateStackSize;

	private static readonly FieldInfo? f_DynILGen_m_scope;

	private static readonly FieldInfo? f_DynScope_m_tokens;

	private static readonly Type?[] CorElementTypes;

	private static MethodBuilder _CreateMethodProxy(MethodBuilder context, MethodInfo target)
	{
		TypeBuilder obj = (TypeBuilder)context.DeclaringType;
		string name = $".dmdproxy<{target.Name.Replace('.', '_')}>?{target.GetHashCode()}";
		Type[] array = (from param in target.GetParameters()
			select param.ParameterType).ToArray();
		MethodBuilder methodBuilder = obj.DefineMethod(name, System.Reflection.MethodAttributes.Private | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.HideBySig, CallingConventions.Standard, target.ReturnType, array);
		ILGenerator iLGenerator = methodBuilder.GetILGenerator();
		iLGenerator.EmitNewTypedReference(target, out var _);
		iLGenerator.Emit(System.Reflection.Emit.OpCodes.Ldnull);
		iLGenerator.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, array.Length);
		iLGenerator.Emit(System.Reflection.Emit.OpCodes.Newarr, typeof(object));
		for (int i = 0; i < array.Length; i++)
		{
			iLGenerator.Emit(System.Reflection.Emit.OpCodes.Dup);
			iLGenerator.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, i);
			iLGenerator.Emit(System.Reflection.Emit.OpCodes.Ldarg, i);
			Type type = array[i];
			if (type.IsByRef)
			{
				type = type.GetElementType() ?? type;
			}
			if (type.IsValueType)
			{
				iLGenerator.Emit(System.Reflection.Emit.OpCodes.Box, type);
			}
			iLGenerator.Emit(System.Reflection.Emit.OpCodes.Stelem_Ref);
		}
		iLGenerator.Emit(System.Reflection.Emit.OpCodes.Callvirt, m_MethodBase_InvokeSimple);
		if (target.ReturnType == typeof(void))
		{
			iLGenerator.Emit(System.Reflection.Emit.OpCodes.Pop);
		}
		else if (target.ReturnType.IsValueType)
		{
			iLGenerator.Emit(System.Reflection.Emit.OpCodes.Unbox_Any, target.ReturnType);
		}
		iLGenerator.Emit(System.Reflection.Emit.OpCodes.Ret);
		return methodBuilder;
	}

	static _DMDEmit()
	{
		m_MethodBase_InvokeSimple = typeof(MethodBase).GetMethod("Invoke", BindingFlags.Instance | BindingFlags.Public, null, new Type[2]
		{
			typeof(object),
			typeof(object[])
		}, null);
		_ReflOpCodes = new Dictionary<short, System.Reflection.Emit.OpCode>();
		_CecilOpCodes = new Dictionary<short, Mono.Cecil.Cil.OpCode>();
		_ILGen_make_room = typeof(ILGenerator).GetMethod("make_room", BindingFlags.Instance | BindingFlags.NonPublic);
		_ILGen_emit_int = typeof(ILGenerator).GetMethod("emit_int", BindingFlags.Instance | BindingFlags.NonPublic);
		_ILGen_ll_emit = typeof(ILGenerator).GetMethod("ll_emit", BindingFlags.Instance | BindingFlags.NonPublic);
		_ILGen_EnsureCapacity = typeof(ILGenerator).GetMethod("EnsureCapacity", BindingFlags.Instance | BindingFlags.NonPublic);
		_ILGen_PutInteger4 = typeof(ILGenerator).GetMethod("PutInteger4", BindingFlags.Instance | BindingFlags.NonPublic);
		_ILGen_InternalEmit = typeof(ILGenerator).GetMethod("InternalEmit", BindingFlags.Instance | BindingFlags.NonPublic);
		_ILGen_UpdateStackSize = typeof(ILGenerator).GetMethod("UpdateStackSize", BindingFlags.Instance | BindingFlags.NonPublic);
		f_DynILGen_m_scope = typeof(ILGenerator).Assembly.GetType("System.Reflection.Emit.DynamicILGenerator")?.GetField("m_scope", BindingFlags.Instance | BindingFlags.NonPublic);
		f_DynScope_m_tokens = typeof(ILGenerator).Assembly.GetType("System.Reflection.Emit.DynamicScope")?.GetField("m_tokens", BindingFlags.Instance | BindingFlags.NonPublic);
		CorElementTypes = new Type[14]
		{
			null,
			typeof(void),
			typeof(bool),
			typeof(char),
			typeof(sbyte),
			typeof(byte),
			typeof(short),
			typeof(ushort),
			typeof(int),
			typeof(uint),
			typeof(long),
			typeof(ulong),
			typeof(string),
			typeof(IntPtr)
		};
		FieldInfo[] fields = typeof(System.Reflection.Emit.OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public);
		for (int i = 0; i < fields.Length; i++)
		{
			System.Reflection.Emit.OpCode value = (System.Reflection.Emit.OpCode)fields[i].GetValue(null);
			_ReflOpCodes[value.Value] = value;
		}
		fields = typeof(Mono.Cecil.Cil.OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public);
		for (int i = 0; i < fields.Length; i++)
		{
			Mono.Cecil.Cil.OpCode value2 = (Mono.Cecil.Cil.OpCode)fields[i].GetValue(null);
			_CecilOpCodes[value2.Value] = value2;
		}
	}

	public static void Generate(DynamicMethodDefinition dmd, MethodBase _mb, ILGenerator il)
	{
		MethodDefinition methodDefinition = dmd.Definition ?? throw new InvalidOperationException();
		DynamicMethod dynamicMethod = _mb as DynamicMethod;
		MethodBuilder mb = _mb as MethodBuilder;
		ModuleBuilder moduleBuilder = mb?.Module as ModuleBuilder;
		AssemblyBuilder assemblyBuilder = (mb?.DeclaringType as TypeBuilder)?.Assembly as AssemblyBuilder;
		HashSet<Assembly> hashSet = null;
		if (mb != null)
		{
			hashSet = new HashSet<Assembly>();
		}
		MethodDebugInformation defInfo = (dmd.Debug ? methodDefinition.DebugInformation : null);
		if (dynamicMethod != null)
		{
			foreach (ParameterDefinition parameter in methodDefinition.Parameters)
			{
				dynamicMethod.DefineParameter(parameter.Index + 1, (System.Reflection.ParameterAttributes)parameter.Attributes, parameter.Name);
			}
		}
		if (mb != null)
		{
			foreach (ParameterDefinition parameter2 in methodDefinition.Parameters)
			{
				mb.DefineParameter(parameter2.Index + 1, (System.Reflection.ParameterAttributes)parameter2.Attributes, parameter2.Name);
			}
		}
		LocalBuilder[] array = methodDefinition.Body.Variables.Select(delegate(VariableDefinition var)
		{
			LocalBuilder localBuilder = il.DeclareLocal(var.VariableType.ResolveReflection(), var.IsPinned);
			if (mb != null && defInfo != null && defInfo.TryGetName(var, out var name))
			{
				localBuilder.SetLocalSymInfo(name);
			}
			return localBuilder;
		}).ToArray();
		Dictionary<Instruction, Label> labelMap = new Dictionary<Instruction, Label>();
		foreach (Instruction instruction in methodDefinition.Body.Instructions)
		{
			if (instruction.Operand is Instruction[] array2)
			{
				Instruction[] array3 = array2;
				foreach (Instruction key in array3)
				{
					if (!labelMap.ContainsKey(key))
					{
						labelMap[key] = il.DefineLabel();
					}
				}
			}
			else if (instruction.Operand is Instruction key2 && !labelMap.ContainsKey(key2))
			{
				labelMap[key2] = il.DefineLabel();
			}
		}
		Dictionary<Document, ISymbolDocumentWriter> dictionary = ((mb == null) ? null : new Dictionary<Document, ISymbolDocumentWriter>());
		int num = (methodDefinition.HasThis ? 1 : 0);
		_ = new object[2];
		bool flag = false;
		foreach (Instruction instruction2 in methodDefinition.Body.Instructions)
		{
			if (labelMap.TryGetValue(instruction2, out var value))
			{
				il.MarkLabel(value);
			}
			SequencePoint sequencePoint = defInfo?.GetSequencePoint(instruction2);
			if ((object)mb != null && sequencePoint != null && dictionary != null && (object)moduleBuilder != null)
			{
				if (!dictionary.TryGetValue(sequencePoint.Document, out var value2))
				{
					value2 = (dictionary[sequencePoint.Document] = moduleBuilder.DefineDocument(sequencePoint.Document.Url, sequencePoint.Document.LanguageGuid, sequencePoint.Document.LanguageVendorGuid, sequencePoint.Document.TypeGuid));
				}
				il.MarkSequencePoint(value2, sequencePoint.StartLine, sequencePoint.StartColumn, sequencePoint.EndLine, sequencePoint.EndColumn);
			}
			foreach (ExceptionHandler exceptionHandler in methodDefinition.Body.ExceptionHandlers)
			{
				if (flag && exceptionHandler.HandlerEnd == instruction2)
				{
					il.EndExceptionBlock();
				}
				if (exceptionHandler.TryStart == instruction2)
				{
					il.BeginExceptionBlock();
				}
				else if (exceptionHandler.FilterStart == instruction2)
				{
					il.BeginExceptFilterBlock();
				}
				else if (exceptionHandler.HandlerStart == instruction2)
				{
					switch (exceptionHandler.HandlerType)
					{
					case ExceptionHandlerType.Filter:
						il.BeginCatchBlock(null);
						break;
					case ExceptionHandlerType.Catch:
						il.BeginCatchBlock(exceptionHandler.CatchType.ResolveReflection());
						break;
					case ExceptionHandlerType.Finally:
						il.BeginFinallyBlock();
						break;
					case ExceptionHandlerType.Fault:
						il.BeginFaultBlock();
						break;
					}
				}
				if (exceptionHandler.HandlerStart != instruction2.Next)
				{
					continue;
				}
				switch (exceptionHandler.HandlerType)
				{
				case ExceptionHandlerType.Filter:
					if (!(instruction2.OpCode == Mono.Cecil.Cil.OpCodes.Endfilter))
					{
						break;
					}
					goto IL_08d3;
				case ExceptionHandlerType.Finally:
					if (!(instruction2.OpCode == Mono.Cecil.Cil.OpCodes.Endfinally))
					{
						break;
					}
					goto IL_08d3;
				}
			}
			if (instruction2.OpCode.OperandType == Mono.Cecil.Cil.OperandType.InlineNone)
			{
				il.Emit(_ReflOpCodes[instruction2.OpCode.Value]);
			}
			else
			{
				object obj = instruction2.Operand;
				if (obj is Instruction[] source)
				{
					obj = source.Select((Instruction target) => labelMap[target]).ToArray();
					instruction2.OpCode = instruction2.OpCode.ToLongOp();
				}
				else if (obj is Instruction key3)
				{
					obj = labelMap[key3];
					instruction2.OpCode = instruction2.OpCode.ToLongOp();
				}
				else if (obj is VariableDefinition variableDefinition)
				{
					obj = array[variableDefinition.Index];
				}
				else if (obj is ParameterDefinition parameterDefinition)
				{
					obj = parameterDefinition.Index + num;
				}
				else if (obj is MemberReference memberReference)
				{
					MemberInfo memberInfo = ((memberReference == methodDefinition) ? _mb : memberReference.ResolveReflection());
					obj = memberInfo;
					if (mb != null && memberInfo != null)
					{
						Module module = memberInfo.Module;
						if (module == null)
						{
							continue;
						}
						Assembly assembly = module.Assembly;
						if (assembly != null && hashSet != null && (object)assemblyBuilder != null && !hashSet.Contains(assembly))
						{
							assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute, new object[1] { assembly.GetName().Name }));
							hashSet.Add(assembly);
						}
					}
				}
				else if (obj is CallSite csite)
				{
					if (dynamicMethod != null)
					{
						_EmitCallSite(dynamicMethod, il, _ReflOpCodes[instruction2.OpCode.Value], csite);
						continue;
					}
					if ((object)mb == null)
					{
						throw new NotSupportedException();
					}
					obj = csite.ResolveReflection(mb.Module);
				}
				if (mb != null && obj is MethodBase methodBase && methodBase.DeclaringType == null)
				{
					if (!(instruction2.OpCode == Mono.Cecil.Cil.OpCodes.Call))
					{
						throw new NotSupportedException("Unsupported global method operand on opcode " + instruction2.OpCode.Name);
					}
					if (methodBase is MethodInfo methodInfo && methodInfo.IsDynamicMethod())
					{
						obj = _CreateMethodProxy(mb, methodInfo);
					}
					else
					{
						IntPtr ldftnPointer = methodBase.GetLdftnPointer();
						if (IntPtr.Size == 4)
						{
							il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, (int)ldftnPointer);
						}
						else
						{
							il.Emit(System.Reflection.Emit.OpCodes.Ldc_I8, (long)ldftnPointer);
						}
						il.Emit(System.Reflection.Emit.OpCodes.Conv_I);
						instruction2.OpCode = Mono.Cecil.Cil.OpCodes.Calli;
						obj = ((MethodReference)instruction2.Operand).ResolveReflectionSignature(mb.Module);
					}
				}
				if (obj == null)
				{
					throw new InvalidOperationException($"Unexpected null in {methodDefinition} @ {instruction2}");
				}
				il.DynEmit(_ReflOpCodes[instruction2.OpCode.Value], obj);
			}
			if (!flag)
			{
				foreach (ExceptionHandler exceptionHandler2 in methodDefinition.Body.ExceptionHandlers)
				{
					if (exceptionHandler2.HandlerEnd == instruction2.Next)
					{
						il.EndExceptionBlock();
					}
				}
			}
			flag = false;
			continue;
			IL_08d3:
			flag = true;
		}
	}

	public static void ResolveWithModifiers(TypeReference typeRef, out Type type, out Type[] typeModReq, out Type[] typeModOpt, List<Type>? modReq = null, List<Type>? modOpt = null)
	{
		if (modReq == null)
		{
			modReq = new List<Type>();
		}
		else
		{
			modReq.Clear();
		}
		if (modOpt == null)
		{
			modOpt = new List<Type>();
		}
		else
		{
			modOpt.Clear();
		}
		for (TypeReference typeReference = typeRef; typeReference is TypeSpecification typeSpecification; typeReference = typeSpecification.ElementType)
		{
			if (!(typeReference is RequiredModifierType requiredModifierType))
			{
				if (typeReference is OptionalModifierType optionalModifierType)
				{
					modOpt.Add(optionalModifierType.ModifierType.ResolveReflection());
				}
			}
			else
			{
				modReq.Add(requiredModifierType.ModifierType.ResolveReflection());
			}
		}
		type = typeRef.ResolveReflection();
		typeModReq = modReq.ToArray();
		typeModOpt = modOpt.ToArray();
	}

	internal static void _EmitCallSite(DynamicMethod dm, ILGenerator il, System.Reflection.Emit.OpCode opcode, CallSite csite)
	{
		List<object> _tokens = null;
		DynamicILInfo _info = null;
		if (PlatformDetection.Runtime == RuntimeKind.Mono)
		{
			_info = dm.GetDynamicILInfo();
		}
		else
		{
			_tokens = (List<object>)f_DynScope_m_tokens.GetValue(f_DynILGen_m_scope.GetValue(il));
		}
		byte[] signature = new byte[32];
		int currSig = 0;
		int num = -1;
		AddData((int)csite.CallingConvention);
		num = currSig++;
		List<Type> modReq = new List<Type>();
		List<Type> modOpt = new List<Type>();
		ResolveWithModifiers(csite.ReturnType, out Type type, out Type[] typeModReq, out Type[] typeModOpt, modReq, modOpt);
		AddArgument(type, typeModReq, typeModOpt);
		foreach (ParameterDefinition parameter in csite.Parameters)
		{
			if (parameter.ParameterType.IsSentinel)
			{
				AddElementType(65);
			}
			if (parameter.ParameterType.IsPinned)
			{
				AddElementType(69);
			}
			ResolveWithModifiers(parameter.ParameterType, out Type type2, out Type[] typeModReq2, out Type[] typeModOpt2, modReq, modOpt);
			AddArgument(type2, typeModReq2, typeModOpt2);
		}
		AddElementType(0);
		int num2 = currSig;
		int num3 = ((csite.Parameters.Count < 128) ? 1 : ((csite.Parameters.Count >= 16384) ? 4 : 2));
		byte[] array = new byte[currSig + num3 - 1];
		array[0] = signature[0];
		Buffer.BlockCopy(signature, num + 1, array, num + num3, num2 - (num + 1));
		signature = array;
		currSig = num;
		AddData(csite.Parameters.Count);
		currSig = num2 + (num3 - 1);
		if (signature.Length > currSig)
		{
			array = new byte[currSig];
			Array.Copy(signature, array, currSig);
			signature = array;
		}
		if (_ILGen_emit_int != null)
		{
			_ILGen_make_room.Invoke(il, new object[1] { 6 });
			_ILGen_ll_emit.Invoke(il, new object[1] { opcode });
			_ILGen_emit_int.Invoke(il, new object[1] { GetTokenForSig(signature) });
			return;
		}
		_ILGen_EnsureCapacity.Invoke(il, new object[1] { 7 });
		_ILGen_InternalEmit.Invoke(il, new object[1] { opcode });
		if (opcode.StackBehaviourPop == System.Reflection.Emit.StackBehaviour.Varpop)
		{
			_ILGen_UpdateStackSize.Invoke(il, new object[2]
			{
				opcode,
				-csite.Parameters.Count - 1
			});
		}
		_ILGen_PutInteger4.Invoke(il, new object[1] { GetTokenForSig(signature) });
		int _GetTokenForSig(byte[] v)
		{
			_tokens.Add(v);
			return (_tokens.Count - 1) | 0x11000000;
		}
		int _GetTokenForType(Type v)
		{
			_tokens.Add(v.TypeHandle);
			return (_tokens.Count - 1) | 0x2000000;
		}
		void AddArgument(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers)
		{
			if (optionalCustomModifiers != null)
			{
				Type[] array3 = optionalCustomModifiers;
				for (int i = 0; i < array3.Length; i++)
				{
					InternalAddTypeToken(GetTokenForType(array3[i]), 32);
				}
			}
			if (requiredCustomModifiers != null)
			{
				Type[] array3 = requiredCustomModifiers;
				for (int i = 0; i < array3.Length; i++)
				{
					InternalAddTypeToken(GetTokenForType(array3[i]), 31);
				}
			}
			AddOneArgTypeHelper(clsArgument);
		}
		void AddData(int data)
		{
			if (currSig + 4 > signature.Length)
			{
				signature = ExpandArray(signature);
			}
			if (data <= 127)
			{
				signature[currSig++] = (byte)(data & 0xFF);
			}
			else if (data <= 16383)
			{
				signature[currSig++] = (byte)((data >> 8) | 0x80);
				signature[currSig++] = (byte)(data & 0xFF);
			}
			else
			{
				if (data > 536870911)
				{
					throw new ArgumentException("Integer or token was too large to be encoded.");
				}
				signature[currSig++] = (byte)((data >> 24) | 0xC0);
				signature[currSig++] = (byte)((data >> 16) & 0xFF);
				signature[currSig++] = (byte)((data >> 8) & 0xFF);
				signature[currSig++] = (byte)(data & 0xFF);
			}
		}
		void AddElementType(byte cvt)
		{
			if (currSig + 1 > signature.Length)
			{
				signature = ExpandArray(signature);
			}
			signature[currSig++] = cvt;
		}
		void AddOneArgTypeHelper(Type clsArgument)
		{
			AddOneArgTypeHelperWorker(clsArgument, lastWasGenericInst: false);
		}
		void AddOneArgTypeHelperWorker(Type clsArgument, bool lastWasGenericInst)
		{
			if (clsArgument.IsGenericType && (!clsArgument.IsGenericTypeDefinition || !lastWasGenericInst))
			{
				AddElementType(21);
				AddOneArgTypeHelperWorker(clsArgument.GetGenericTypeDefinition(), lastWasGenericInst: true);
				Type[] genericArguments = clsArgument.GetGenericArguments();
				AddData(genericArguments.Length);
				Type[] array4 = genericArguments;
				for (int j = 0; j < array4.Length; j++)
				{
					AddOneArgTypeHelper(array4[j]);
				}
			}
			else if (clsArgument.IsByRef)
			{
				AddElementType(16);
				clsArgument = clsArgument.GetElementType() ?? clsArgument;
				AddOneArgTypeHelper(clsArgument);
			}
			else if (clsArgument.IsPointer)
			{
				AddElementType(15);
				AddOneArgTypeHelper(clsArgument.GetElementType() ?? clsArgument);
			}
			else if (clsArgument.IsArray)
			{
				AddElementType(20);
				AddOneArgTypeHelper(clsArgument.GetElementType() ?? clsArgument);
				int arrayRank = clsArgument.GetArrayRank();
				AddData(arrayRank);
				AddData(0);
				AddData(arrayRank);
				for (int k = 0; k < arrayRank; k++)
				{
					AddData(0);
				}
			}
			else
			{
				byte b = 0;
				for (int l = 0; l < CorElementTypes.Length; l++)
				{
					if (clsArgument == CorElementTypes[l])
					{
						b = (byte)l;
						break;
					}
				}
				if (b == 0)
				{
					b = (byte)((clsArgument == typeof(object)) ? 28 : ((!clsArgument.IsValueType) ? 18 : 17));
				}
				if (b <= 14 || b == 22 || b == 24 || b == 25 || b == 28)
				{
					AddElementType(b);
				}
				else if (clsArgument.IsValueType)
				{
					InternalAddTypeToken(GetTokenForType(clsArgument), 17);
				}
				else
				{
					InternalAddTypeToken(GetTokenForType(clsArgument), 18);
				}
			}
		}
		void AddToken(int token)
		{
			int num4 = token & 0xFFFFFF;
			int num5 = token & -16777216;
			if (num4 > 67108863)
			{
				throw new ArgumentException("Integer or token was too large to be encoded.");
			}
			num4 <<= 2;
			switch (num5)
			{
			case 16777216:
				num4 |= 1;
				break;
			case 452984832:
				num4 |= 2;
				break;
			}
			AddData(num4);
		}
		static byte[] ExpandArray(byte[] inArray, int requiredLength = -1)
		{
			if (requiredLength < inArray.Length)
			{
				requiredLength = inArray.Length * 2;
			}
			byte[] array2 = new byte[requiredLength];
			Buffer.BlockCopy(inArray, 0, array2, 0, inArray.Length);
			return array2;
		}
		int GetTokenForSig(byte[] v)
		{
			if (_info == null)
			{
				return _GetTokenForSig(v);
			}
			return _info.GetTokenFor(v);
		}
		int GetTokenForType(Type v)
		{
			if (_info == null)
			{
				return _GetTokenForType(v);
			}
			return _info.GetTokenFor(v.TypeHandle);
		}
		void InternalAddTypeToken(int clsToken, byte CorType)
		{
			AddElementType(CorType);
			AddToken(clsToken);
		}
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Mono.Cecil;
using MonoMod;
using MonoMod.Logs;
using MonoMod.Utils;

internal sealed class DMDEmitDynamicMethodGenerator : DMDGenerator<DMDEmitDynamicMethodGenerator>
{
	private static readonly FieldInfo _DynamicMethod_returnType = typeof(DynamicMethod).GetField("returnType", BindingFlags.Instance | BindingFlags.NonPublic) ?? typeof(DynamicMethod).GetField("_returnType", BindingFlags.Instance | BindingFlags.NonPublic) ?? typeof(DynamicMethod).GetField("m_returnType", BindingFlags.Instance | BindingFlags.NonPublic) ?? throw new InvalidOperationException("Cannot find returnType field on DynamicMethod");

	protected override MethodInfo GenerateCore(DynamicMethodDefinition dmd, object? context)
	{
		MethodBase originalMethod = dmd.OriginalMethod;
		MethodDefinition methodDefinition = dmd.Definition ?? throw new InvalidOperationException();
		Type[] array;
		if (originalMethod != null)
		{
			ParameterInfo[] parameters = originalMethod.GetParameters();
			int num = 0;
			if (!originalMethod.IsStatic)
			{
				num++;
				array = new Type[parameters.Length + 1];
				array[0] = originalMethod.GetThisParamType();
			}
			else
			{
				array = new Type[parameters.Length];
			}
			for (int i = 0; i < parameters.Length; i++)
			{
				array[i + num] = parameters[i].ParameterType;
			}
		}
		else
		{
			int num2 = 0;
			if (methodDefinition.HasThis)
			{
				num2++;
				array = new Type[methodDefinition.Parameters.Count + 1];
				Type type2 = methodDefinition.DeclaringType.ResolveReflection();
				if (type2.IsValueType)
				{
					type2 = type2.MakeByRefType();
				}
				array[0] = type2;
			}
			else
			{
				array = new Type[methodDefinition.Parameters.Count];
			}
			for (int j = 0; j < methodDefinition.Parameters.Count; j++)
			{
				array[j + num2] = methodDefinition.Parameters[j].ParameterType.ResolveReflection();
			}
		}
		string text = dmd.Name;
		if (text == null)
		{
			FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(5, 1);
			handler.AppendLiteral("DMD<");
			handler.AppendFormatted(((object)originalMethod) ?? ((object)methodDefinition.GetID(null, null, withType: true, simple: true)));
			handler.AppendLiteral(">");
			text = DebugFormatter.Format(ref handler);
		}
		string text2 = text;
		Type value = (originalMethod as MethodInfo)?.ReturnType ?? methodDefinition.ReturnType.ResolveReflection();
		bool isEnabled;
		MMDbgLog.DebugLogTraceStringHandler message = new MMDbgLog.DebugLogTraceStringHandler(22, 3, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("new DynamicMethod: ");
			message.AppendFormatted(value);
			message.AppendLiteral(" ");
			message.AppendFormatted(text2);
			message.AppendLiteral("(");
			message.AppendFormatted(string.Join(",", array.Select((Type type) => type?.ToString()).ToArray()));
			message.AppendLiteral(")");
		}
		MMDbgLog.Trace(ref message);
		if (originalMethod != null)
		{
			message = new MMDbgLog.DebugLogTraceStringHandler(6, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("orig: ");
				message.AppendFormatted(originalMethod);
			}
			MMDbgLog.Trace(ref message);
		}
		message = new MMDbgLog.DebugLogTraceStringHandler(9, 3, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("mdef: ");
			message.AppendFormatted(methodDefinition.ReturnType?.ToString() ?? "NULL");
			message.AppendLiteral(" ");
			message.AppendFormatted(text2);
			message.AppendLiteral("(");
			message.AppendFormatted(string.Join(",", methodDefinition.Parameters.Select((ParameterDefinition arg) => arg?.ParameterType?.ToString() ?? "NULL").ToArray()));
			message.AppendLiteral(")");
		}
		MMDbgLog.Trace(ref message);
		DynamicMethod dynamicMethod = new DynamicMethod(text2, typeof(void), array, originalMethod?.DeclaringType ?? typeof(DynamicMethodDefinition), skipVisibility: true);
		_DynamicMethod_returnType.SetValue(dynamicMethod, value);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		_DMDEmit.Generate(dmd, dynamicMethod, iLGenerator);
		return dynamicMethod;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using Mono.Cecil;
using MonoMod;
using MonoMod.Logs;
using MonoMod.Utils;

internal sealed class DMDEmitMethodBuilderGenerator : DMDGenerator<DMDEmitMethodBuilderGenerator>
{
	private static readonly bool _MBCanRunAndCollect = Enum.IsDefined(typeof(AssemblyBuilderAccess), "RunAndCollect");

	protected override MethodInfo GenerateCore(DynamicMethodDefinition dmd, object? context)
	{
		TypeBuilder typeBuilder = context as TypeBuilder;
		MethodBuilder methodBuilder = GenerateMethodBuilder(dmd, typeBuilder);
		typeBuilder = (TypeBuilder)methodBuilder.DeclaringType;
		Type type = typeBuilder.CreateType();
		if (!string.IsNullOrEmpty(Switches.TryGetSwitchValue("DMDDumpTo", out object value) ? (value as string) : null))
		{
			string fullyQualifiedName = methodBuilder.Module.FullyQualifiedName;
			string fileName = Path.GetFileName(fullyQualifiedName);
			string directoryName = Path.GetDirectoryName(fullyQualifiedName);
			if (!string.IsNullOrEmpty(directoryName) && !Directory.Exists(directoryName))
			{
				Directory.CreateDirectory(directoryName);
			}
			if (File.Exists(fullyQualifiedName))
			{
				File.Delete(fullyQualifiedName);
			}
			((AssemblyBuilder)typeBuilder.Assembly).Save(fileName);
		}
		return type.GetMethod(methodBuilder.Name, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
	}

	public static MethodBuilder GenerateMethodBuilder(DynamicMethodDefinition dmd, TypeBuilder? typeBuilder)
	{
		Helpers.ThrowIfArgumentNull(dmd, "dmd");
		MethodBase originalMethod = dmd.OriginalMethod;
		MethodDefinition definition = dmd.Definition;
		if (typeBuilder == null)
		{
			string text = (Switches.TryGetSwitchValue("DMDDumpTo", out object value) ? (value as string) : null);
			text = ((!string.IsNullOrEmpty(text)) ? Path.GetFullPath(text) : null);
			bool flag = string.IsNullOrEmpty(text) && _MBCanRunAndCollect;
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName
			{
				Name = dmd.GetDumpName("MethodBuilder")
			}, flag ? AssemblyBuilderAccess.RunAndCollect : ((AssemblyBuilderAccess)3), text);
			assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(DynamicMethodDefinition.c_UnverifiableCodeAttribute, new object[0]));
			if (dmd.Debug)
			{
				assemblyBuilder.SetCustomAttribute(new CustomAttributeBuilder(DynamicMethodDefinition.c_DebuggableAttribute, new object[1] { DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations }));
			}
			ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyBuilder.GetName().Name + ".dll", assemblyBuilder.GetName().Name + ".dll", dmd.Debug);
			FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(6, 2);
			handler.AppendLiteral("DMD<");
			handler.AppendFormatted(originalMethod);
			handler.AppendLiteral(">?");
			handler.AppendFormatted(dmd.GetHashCode());
			typeBuilder = moduleBuilder.DefineType(DebugFormatter.Format(ref handler), System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Abstract | System.Reflection.TypeAttributes.Sealed);
		}
		Type[] array;
		Type[][] array2;
		Type[][] array3;
		if (originalMethod != null)
		{
			ParameterInfo[] parameters = originalMethod.GetParameters();
			int num = 0;
			if (!originalMethod.IsStatic)
			{
				num++;
				array = new Type[parameters.Length + 1];
				array2 = new Type[parameters.Length + 1][];
				array3 = new Type[parameters.Length + 1][];
				array[0] = originalMethod.GetThisParamType();
				array2[0] = Type.EmptyTypes;
				array3[0] = Type.EmptyTypes;
			}
			else
			{
				array = new Type[parameters.Length];
				array2 = new Type[parameters.Length][];
				array3 = new Type[parameters.Length][];
			}
			for (int i = 0; i < parameters.Length; i++)
			{
				array[i + num] = parameters[i].ParameterType;
				array2[i + num] = parameters[i].GetRequiredCustomModifiers();
				array3[i + num] = parameters[i].GetOptionalCustomModifiers();
			}
		}
		else
		{
			int num2 = 0;
			if (definition.HasThis)
			{
				num2++;
				array = new Type[definition.Parameters.Count + 1];
				array2 = new Type[definition.Parameters.Count + 1][];
				array3 = new Type[definition.Parameters.Count + 1][];
				Type type = definition.DeclaringType.ResolveReflection();
				if (type.IsValueType)
				{
					type = type.MakeByRefType();
				}
				array[0] = type;
				array2[0] = Type.EmptyTypes;
				array3[0] = Type.EmptyTypes;
			}
			else
			{
				array = new Type[definition.Parameters.Count];
				array2 = new Type[definition.Parameters.Count][];
				array3 = new Type[definition.Parameters.Count][];
			}
			List<Type> modReq = new List<Type>();
			List<Type> modOpt = new List<Type>();
			for (int j = 0; j < definition.Parameters.Count; j++)
			{
				_DMDEmit.ResolveWithModifiers(definition.Parameters[j].ParameterType, out Type type2, out Type[] typeModReq, out Type[] typeModOpt, modReq, modOpt);
				array[j + num2] = type2;
				array2[j + num2] = typeModReq;
				array3[j + num2] = typeModOpt;
			}
		}
		_DMDEmit.ResolveWithModifiers(definition.ReturnType, out Type type3, out Type[] typeModReq2, out Type[] typeModOpt2);
		MethodBuilder methodBuilder = typeBuilder.DefineMethod(dmd.Name ?? (originalMethod?.Name ?? definition.Name).Replace('.', '_'), System.Reflection.MethodAttributes.Public | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.HideBySig, CallingConventions.Standard, type3, typeModReq2, typeModOpt2, array, array2, array3);
		ILGenerator iLGenerator = methodBuilder.GetILGenerator();
		_DMDEmit.Generate(dmd, methodBuilder, iLGenerator);
		return methodBuilder;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Dynamic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using MonoMod.Utils;

internal sealed class DynamicData : DynamicObject, IDisposable, IEnumerable<KeyValuePair<string, object?>>, IEnumerable
{
	private class _Cache_
	{
		public readonly Dictionary<string, Func<object?, object?>> Getters = new Dictionary<string, Func<object, object>>();

		public readonly Dictionary<string, Action<object?, object?>> Setters = new Dictionary<string, Action<object, object>>();

		public readonly Dictionary<string, Func<object?, object?[]?, object?>> Methods = new Dictionary<string, Func<object, object[], object>>();

		public _Cache_(Type? targetType)
		{
			bool flag = true;
			while (targetType != null && targetType != targetType.BaseType)
			{
				FieldInfo[] fields = targetType.GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (FieldInfo fieldInfo in fields)
				{
					string name = fieldInfo.Name;
					if (Getters.ContainsKey(name) || Setters.ContainsKey(name))
					{
						continue;
					}
					try
					{
						FastReflectionHelper.FastInvoker fastInvoker = fieldInfo.GetFastInvoker();
						Getters[name] = (object? obj) => fastInvoker(obj);
						Setters[name] = delegate(object? obj, object? value)
						{
							fastInvoker(obj, value);
						};
					}
					catch
					{
						Getters[name] = fieldInfo.GetValue;
						Setters[name] = fieldInfo.SetValue;
					}
				}
				PropertyInfo[] properties = targetType.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (PropertyInfo propertyInfo in properties)
				{
					string name2 = propertyInfo.Name;
					MethodInfo get = propertyInfo.GetGetMethod(nonPublic: true);
					if (get != null && !Getters.ContainsKey(name2))
					{
						try
						{
							FastReflectionHelper.FastInvoker fastInvoker2 = get.GetFastInvoker();
							Getters[name2] = (object? obj) => fastInvoker2(obj);
						}
						catch
						{
							Getters[name2] = (object? obj) => get.Invoke(obj, _NoArgs);
						}
					}
					MethodInfo set = propertyInfo.GetSetMethod(nonPublic: true);
					if (!(set != null) || Setters.ContainsKey(name2))
					{
						continue;
					}
					try
					{
						FastReflectionHelper.FastInvoker fastInvoker3 = set.GetFastInvoker();
						Setters[name2] = delegate(object? obj, object? value)
						{
							fastInvoker3(obj, value);
						};
					}
					catch
					{
						Setters[name2] = delegate(object? obj, object? value)
						{
							set.Invoke(obj, new object[1] { value });
						};
					}
				}
				Dictionary<string, MethodInfo> dictionary = new Dictionary<string, MethodInfo>();
				MethodInfo[] methods = targetType.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					string name3 = methodInfo.Name;
					if (flag || !Methods.ContainsKey(name3))
					{
						if (dictionary.ContainsKey(name3))
						{
							dictionary[name3] = null;
						}
						else
						{
							dictionary[name3] = methodInfo;
						}
					}
				}
				foreach (KeyValuePair<string, MethodInfo> item in dictionary)
				{
					if (item.Value == null || item.Value.IsGenericMethod)
					{
						continue;
					}
					try
					{
						FastReflectionHelper.FastInvoker cb = item.Value.GetFastInvoker();
						Methods[item.Key] = (object? target, object?[]? args) => cb(target, args);
					}
					catch
					{
						Methods[item.Key] = item.Value.Invoke;
					}
				}
				flag = false;
				targetType = targetType.BaseType;
			}
		}
	}

	private class _Data_
	{
		public readonly Dictionary<string, Func<object?, object?>> Getters = new Dictionary<string, Func<object, object>>();

		public readonly Dictionary<string, Action<object?, object?>> Setters = new Dictionary<string, Action<object, object>>();

		public readonly Dictionary<string, Func<object?, object?[]?, object?>> Methods = new Dictionary<string, Func<object, object[], object>>();

		public readonly Dictionary<string, object?> Data = new Dictionary<string, object>();

		public _Data_(Type type)
		{
			_ = type == null;
		}
	}

	private static readonly object?[] _NoArgs = ArrayEx.Empty<object>();

	private static readonly Dictionary<Type, _Cache_> _CacheMap = new Dictionary<Type, _Cache_>();

	private static readonly Dictionary<Type, _Data_> _DataStaticMap = new Dictionary<Type, _Data_>();

	private static readonly ConditionalWeakTable<object, _Data_> _DataMap = new ConditionalWeakTable<object, _Data_>();

	private static readonly ConditionalWeakTable<object, DynamicData> _DynamicDataMap = new ConditionalWeakTable<object, DynamicData>();

	private readonly WeakReference? Weak;

	private object? KeepAlive;

	private readonly _Cache_ _Cache;

	private readonly _Data_ _Data;

	public Dictionary<string, Func<object?, object?>> Getters => _Data.Getters;

	public Dictionary<string, Action<object?, object?>> Setters => _Data.Setters;

	public Dictionary<string, Func<object?, object?[]?, object?>> Methods => _Data.Methods;

	public Dictionary<string, object?> Data => _Data.Data;

	public bool IsAlive
	{
		get
		{
			if (Weak != null)
			{
				return Weak.SafeGetIsAlive();
			}
			return true;
		}
	}

	public object? Target => Weak?.SafeGetTarget();

	public Type TargetType { get; private set; }

	public static event Action<DynamicData, Type, object?>? OnInitialize;

	public DynamicData(Type type)
		: this(type, null, keepAlive: false)
	{
	}

	public DynamicData(object obj)
		: this(Helpers.ThrowIfNull(obj, "obj").GetType(), obj, keepAlive: true)
	{
	}

	public DynamicData(Type type, object? obj)
		: this(type, obj, keepAlive: true)
	{
	}

	public DynamicData(Type type, object? obj, bool keepAlive)
	{
		TargetType = type;
		lock (_CacheMap)
		{
			if (!_CacheMap.TryGetValue(type, out _Cache_ value))
			{
				value = new _Cache_(type);
				_CacheMap.Add(type, value);
			}
			_Cache = value;
		}
		if (obj != null)
		{
			lock (_DataMap)
			{
				if (!_DataMap.TryGetValue(obj, out _Data_ value2))
				{
					value2 = new _Data_(type);
					_DataMap.Add(obj, value2);
				}
				_Data = value2;
			}
			Weak = new WeakReference(obj);
			if (keepAlive)
			{
				KeepAlive = obj;
			}
		}
		else
		{
			lock (_DataStaticMap)
			{
				if (!_DataStaticMap.TryGetValue(type, out _Data_ value3))
				{
					value3 = new _Data_(type);
					_DataStaticMap.Add(type, value3);
				}
				_Data = value3;
			}
		}
		DynamicData.OnInitialize?.Invoke(this, type, obj);
	}

	public static DynamicData For(object obj)
	{
		lock (_DynamicDataMap)
		{
			if (!_DynamicDataMap.TryGetValue(obj, out DynamicData value))
			{
				value = new DynamicData(obj);
				_DynamicDataMap.Add(obj, value);
			}
			return value;
		}
	}

	public static Func<object, T?> New<T>(params object[] args) where T : notnull
	{
		T target = (T)Activator.CreateInstance(typeof(T), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
		return (object other) => Set(target, other);
	}

	public static Func<object, object?> New(Type type, params object[] args)
	{
		object target = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
		return (object other) => Set(target, other);
	}

	public static Func<object, dynamic> NewWrap<T>(params object[] args)
	{
		T target = (T)Activator.CreateInstance(typeof(T), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
		return (object other) => Wrap(target, other);
	}

	public static Func<object, dynamic> NewWrap(Type type, params object[] args)
	{
		object target = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
		return (object other) => Wrap(target, other);
	}

	public static dynamic Wrap(object target, object? other = null)
	{
		DynamicData dynamicData = new DynamicData(target);
		dynamicData.CopyFrom(other);
		return dynamicData;
	}

	public static T? Set<T>(T target, object? other = null) where T : notnull
	{
		return (T)Set((object)target, other);
	}

	public static object? Set(object target, object? other = null)
	{
		using DynamicData dynamicData = new DynamicData(target);
		dynamicData.CopyFrom(other);
		return dynamicData.Target;
	}

	public void RegisterProperty(string name, Func<object?, object?> getter, Action<object?, object?> setter)
	{
		Getters[name] = getter;
		Setters[name] = setter;
	}

	public void UnregisterProperty(string name)
	{
		Getters.Remove(name);
		Setters.Remove(name);
	}

	public void RegisterMethod(string name, Func<object?, object?[]?, object?> cb)
	{
		Methods[name] = cb;
	}

	public void UnregisterMethod(string name)
	{
		Methods.Remove(name);
	}

	public void CopyFrom(object? other)
	{
		if (other != null)
		{
			PropertyInfo[] properties = other.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public);
			foreach (PropertyInfo propertyInfo in properties)
			{
				Set(propertyInfo.Name, propertyInfo.GetValue(other, null));
			}
		}
	}

	public object? Get(string name)
	{
		TryGet(name, out object value);
		return value;
	}

	public bool TryGet(string name, out object? value)
	{
		object target = Target;
		if (_Data.Getters.TryGetValue(name, out Func<object, object> value2))
		{
			value = value2(target);
			return true;
		}
		if (_Cache.Getters.TryGetValue(name, out value2))
		{
			value = value2(target);
			return true;
		}
		if (_Data.Data.TryGetValue(name, out value))
		{
			return true;
		}
		return false;
	}

	public T? Get<T>(string name)
	{
		return (T)Get(name);
	}

	public bool TryGet<T>(string name, [MaybeNullWhen(false)] out T value)
	{
		object value2;
		bool result = TryGet(name, out value2);
		value = (T)value2;
		return result;
	}

	public void Set(string name, object? value)
	{
		object target = Target;
		if (_Data.Setters.TryGetValue(name, out Action<object, object> value2))
		{
			value2(target, value);
		}
		else if (_Cache.Setters.TryGetValue(name, out value2))
		{
			value2(target, value);
		}
		else
		{
			Data[name] = value;
		}
	}

	public void Add(KeyValuePair<string, object> kvp)
	{
		Set(kvp.Key, kvp.Value);
	}

	public void Add(string key, object value)
	{
		Set(key, value);
	}

	public object? Invoke(string name, params object[] args)
	{
		TryInvoke(name, args, out object result);
		return result;
	}

	public bool TryInvoke(string name, object?[]? args, out object? result)
	{
		if (_Data.Methods.TryGetValue(name, out Func<object, object[], object> value))
		{
			result = value(Target, args);
			return true;
		}
		if (_Cache.Methods.TryGetValue(name, out value))
		{
			result = value(Target, args);
			return true;
		}
		result = null;
		return false;
	}

	public T? Invoke<T>(string name, params object[] args)
	{
		return (T)Invoke(name, args);
	}

	public bool TryInvoke<T>(string name, object[] args, [MaybeNullWhen(false)] out T result)
	{
		object result2;
		bool result3 = TryInvoke(name, args, out result2);
		result = (T)result2;
		return result3;
	}

	private void Dispose(bool disposing)
	{
		KeepAlive = null;
	}

	~DynamicData()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}

	public override IEnumerable<string> GetDynamicMemberNames()
	{
		return _Data.Data.Keys.Union(_Data.Getters.Keys).Union(_Data.Setters.Keys).Union(_Data.Methods.Keys)
			.Union(_Cache.Getters.Keys)
			.Union(_Cache.Setters.Keys)
			.Union(_Cache.Methods.Keys);
	}

	public override bool TryConvert(ConvertBinder binder, out object? result)
	{
		Helpers.ThrowIfArgumentNull(binder, "binder");
		if (TargetType.IsCompatible(binder.Type) || TargetType.IsCompatible(binder.ReturnType) || binder.Type == typeof(object) || binder.ReturnType == typeof(object))
		{
			result = Target;
			return true;
		}
		if (typeof(DynamicData).IsCompatible(binder.Type) || typeof(DynamicData).IsCompatible(binder.ReturnType))
		{
			result = this;
			return true;
		}
		result = null;
		return false;
	}

	public override bool TryGetMember(GetMemberBinder binder, out object? result)
	{
		Helpers.ThrowIfArgumentNull(binder, "binder");
		if (Methods.ContainsKey(binder.Name))
		{
			result = null;
			return false;
		}
		result = Get(binder.Name);
		return true;
	}

	public override bool TrySetMember(SetMemberBinder binder, object? value)
	{
		Helpers.ThrowIfArgumentNull(binder, "binder");
		Set(binder.Name, value);
		return true;
	}

	public override bool TryInvokeMember(InvokeMemberBinder binder, object?[]? args, out object? result)
	{
		Helpers.ThrowIfArgumentNull(binder, "binder");
		return TryInvoke(binder.Name, args, out result);
	}

	public IEnumerator<KeyValuePair<string, object?>> GetEnumerator()
	{
		foreach (string item in _Data.Data.Keys.Union(_Data.Getters.Keys).Union(_Data.Setters.Keys).Union(_Cache.Getters.Keys)
			.Union(_Cache.Setters.Keys))
		{
			yield return new KeyValuePair<string, object>(item, Get(item));
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;

private class _Cache_
{
	public readonly Dictionary<string, Func<object?, object?>> Getters = new Dictionary<string, Func<object, object>>();

	public readonly Dictionary<string, Action<object?, object?>> Setters = new Dictionary<string, Action<object, object>>();

	public readonly Dictionary<string, Func<object?, object?[]?, object?>> Methods = new Dictionary<string, Func<object, object[], object>>();

	public _Cache_(Type? targetType)
	{
		bool flag = true;
		while (targetType != null && targetType != targetType.BaseType)
		{
			FieldInfo[] fields = targetType.GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (FieldInfo fieldInfo in fields)
			{
				string name = fieldInfo.Name;
				if (Getters.ContainsKey(name) || Setters.ContainsKey(name))
				{
					continue;
				}
				try
				{
					FastReflectionHelper.FastInvoker fastInvoker = fieldInfo.GetFastInvoker();
					Getters[name] = (object? obj) => fastInvoker(obj);
					Setters[name] = delegate(object? obj, object? value)
					{
						fastInvoker(obj, value);
					};
				}
				catch
				{
					Getters[name] = fieldInfo.GetValue;
					Setters[name] = fieldInfo.SetValue;
				}
			}
			PropertyInfo[] properties = targetType.GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (PropertyInfo propertyInfo in properties)
			{
				string name2 = propertyInfo.Name;
				MethodInfo get = propertyInfo.GetGetMethod(nonPublic: true);
				if (get != null && !Getters.ContainsKey(name2))
				{
					try
					{
						FastReflectionHelper.FastInvoker fastInvoker2 = get.GetFastInvoker();
						Getters[name2] = (object? obj) => fastInvoker2(obj);
					}
					catch
					{
						Getters[name2] = (object? obj) => get.Invoke(obj, _NoArgs);
					}
				}
				MethodInfo set = propertyInfo.GetSetMethod(nonPublic: true);
				if (!(set != null) || Setters.ContainsKey(name2))
				{
					continue;
				}
				try
				{
					FastReflectionHelper.FastInvoker fastInvoker3 = set.GetFastInvoker();
					Setters[name2] = delegate(object? obj, object? value)
					{
						fastInvoker3(obj, value);
					};
				}
				catch
				{
					Setters[name2] = delegate(object? obj, object? value)
					{
						set.Invoke(obj, new object[1] { value });
					};
				}
			}
			Dictionary<string, MethodInfo> dictionary = new Dictionary<string, MethodInfo>();
			MethodInfo[] methods = targetType.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MethodInfo methodInfo in methods)
			{
				string name3 = methodInfo.Name;
				if (flag || !Methods.ContainsKey(name3))
				{
					if (dictionary.ContainsKey(name3))
					{
						dictionary[name3] = null;
					}
					else
					{
						dictionary[name3] = methodInfo;
					}
				}
			}
			foreach (KeyValuePair<string, MethodInfo> item in dictionary)
			{
				if (item.Value == null || item.Value.IsGenericMethod)
				{
					continue;
				}
				try
				{
					FastReflectionHelper.FastInvoker cb = item.Value.GetFastInvoker();
					Methods[item.Key] = (object? target, object?[]? args) => cb(target, args);
				}
				catch
				{
					Methods[item.Key] = item.Value.Invoke;
				}
			}
			flag = false;
			targetType = targetType.BaseType;
		}
	}
}


using System;
using System.Collections.Generic;

private class _Data_
{
	public readonly Dictionary<string, Func<object?, object?>> Getters = new Dictionary<string, Func<object, object>>();

	public readonly Dictionary<string, Action<object?, object?>> Setters = new Dictionary<string, Action<object, object>>();

	public readonly Dictionary<string, Func<object?, object?[]?, object?>> Methods = new Dictionary<string, Func<object, object[], object>>();

	public readonly Dictionary<string, object?> Data = new Dictionary<string, object>();

	public _Data_(Type type)
	{
		_ = type == null;
	}
}


using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Security;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod;
using MonoMod.Utils;
using MonoMod.Utils.Cil;

internal sealed class DynamicMethodDefinition : IDisposable
{
	private enum TokenResolutionMode
	{
		Any,
		Type,
		Method,
		Field
	}

	private static Mono.Cecil.Cil.OpCode[] _CecilOpCodes1X;

	private static Mono.Cecil.Cil.OpCode[] _CecilOpCodes2X;

	internal static readonly bool _IsNewMonoSRE;

	internal static readonly bool _IsOldMonoSRE;

	private static bool _PreferCecil;

	internal static readonly ConstructorInfo c_DebuggableAttribute;

	internal static readonly ConstructorInfo c_UnverifiableCodeAttribute;

	internal static readonly ConstructorInfo c_IgnoresAccessChecksToAttribute;

	internal static readonly Type t__IDMDGenerator;

	internal static readonly ConcurrentDictionary<string, IDMDGenerator> _DMDGeneratorCache;

	private Guid GUID = Guid.NewGuid();

	private bool isDisposed;

	public static bool IsDynamicILAvailable => !_PreferCecil;

	public MethodBase? OriginalMethod { get; }

	public MethodDefinition Definition { get; }

	public ModuleDefinition Module { get; }

	public string? Name { get; }

	public bool Debug { get; init; }

	private static void _InitCopier()
	{
		_CecilOpCodes1X = new Mono.Cecil.Cil.OpCode[225];
		_CecilOpCodes2X = new Mono.Cecil.Cil.OpCode[31];
		FieldInfo[] fields = typeof(Mono.Cecil.Cil.OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public);
		for (int i = 0; i < fields.Length; i++)
		{
			Mono.Cecil.Cil.OpCode opCode = (Mono.Cecil.Cil.OpCode)fields[i].GetValue(null);
			if (opCode.OpCodeType != Mono.Cecil.Cil.OpCodeType.Nternal)
			{
				if (opCode.Size == 1)
				{
					_CecilOpCodes1X[opCode.Value] = opCode;
				}
				else
				{
					_CecilOpCodes2X[opCode.Value & 0xFF] = opCode;
				}
			}
		}
	}

	private static void _CopyMethodToDefinition(MethodBase from, MethodDefinition into)
	{
		Module moduleFrom = from.Module;
		System.Reflection.MethodBody methodBody = from.GetMethodBody() ?? throw new NotSupportedException("Body-less method");
		byte[] buffer = methodBody.GetILAsByteArray() ?? throw new InvalidOperationException();
		ModuleDefinition moduleTo = into.Module;
		Mono.Cecil.Cil.MethodBody bodyTo = into.Body;
		bodyTo.GetILProcessor();
		Type[] typeArguments = null;
		Type? declaringType = from.DeclaringType;
		if ((object)declaringType != null && declaringType.IsGenericType)
		{
			typeArguments = from.DeclaringType.GetGenericArguments();
		}
		Type[] methodArguments = null;
		if (from.IsGenericMethod)
		{
			methodArguments = from.GetGenericArguments();
		}
		foreach (LocalVariableInfo localVariable in methodBody.LocalVariables)
		{
			TypeReference typeReference = moduleTo.ImportReference(localVariable.LocalType);
			if (localVariable.IsPinned)
			{
				typeReference = new PinnedType(typeReference);
			}
			bodyTo.Variables.Add(new VariableDefinition(typeReference));
		}
		using (BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer)))
		{
			Instruction instruction = null;
			Instruction instruction2 = null;
			while (binaryReader.BaseStream.Position < binaryReader.BaseStream.Length)
			{
				int offset2 = (int)binaryReader.BaseStream.Position;
				instruction = Instruction.Create(Mono.Cecil.Cil.OpCodes.Nop);
				byte b = binaryReader.ReadByte();
				instruction.OpCode = ((b != 254) ? _CecilOpCodes1X[b] : _CecilOpCodes2X[binaryReader.ReadByte()]);
				instruction.Offset = offset2;
				if (instruction2 != null)
				{
					instruction2.Next = instruction;
				}
				instruction.Previous = instruction2;
				ReadOperand(binaryReader, instruction);
				bodyTo.Instructions.Add(instruction);
				instruction2 = instruction;
			}
		}
		foreach (Instruction instruction4 in bodyTo.Instructions)
		{
			switch (instruction4.OpCode.OperandType)
			{
			case Mono.Cecil.Cil.OperandType.InlineBrTarget:
			case Mono.Cecil.Cil.OperandType.ShortInlineBrTarget:
				instruction4.Operand = GetInstruction((int)instruction4.Operand);
				break;
			case Mono.Cecil.Cil.OperandType.InlineSwitch:
			{
				int[] array = (int[])instruction4.Operand;
				Instruction[] array2 = new Instruction[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array2[i] = GetInstruction(array[i]);
				}
				instruction4.Operand = array2;
				break;
			}
			}
		}
		foreach (ExceptionHandlingClause exceptionHandlingClause in methodBody.ExceptionHandlingClauses)
		{
			ExceptionHandler exceptionHandler = new ExceptionHandler((ExceptionHandlerType)exceptionHandlingClause.Flags);
			bodyTo.ExceptionHandlers.Add(exceptionHandler);
			exceptionHandler.TryStart = GetInstruction(exceptionHandlingClause.TryOffset);
			exceptionHandler.TryEnd = GetInstruction(exceptionHandlingClause.TryOffset + exceptionHandlingClause.TryLength);
			exceptionHandler.FilterStart = ((exceptionHandler.HandlerType != ExceptionHandlerType.Filter) ? null : GetInstruction(exceptionHandlingClause.FilterOffset));
			exceptionHandler.HandlerStart = GetInstruction(exceptionHandlingClause.HandlerOffset);
			exceptionHandler.HandlerEnd = GetInstruction(exceptionHandlingClause.HandlerOffset + exceptionHandlingClause.HandlerLength);
			exceptionHandler.CatchType = ((exceptionHandler.HandlerType != 0) ? null : ((exceptionHandlingClause.CatchType == null) ? null : moduleTo.ImportReference(exceptionHandlingClause.CatchType)));
		}
		Instruction? GetInstruction(int offset)
		{
			int num3 = bodyTo.Instructions.Count - 1;
			if (offset < 0 || offset > bodyTo.Instructions[num3].Offset)
			{
				return null;
			}
			int num4 = 0;
			int num5 = num3;
			while (num4 <= num5)
			{
				int num6 = num4 + (num5 - num4) / 2;
				Instruction instruction3 = bodyTo.Instructions[num6];
				if (offset == instruction3.Offset)
				{
					return instruction3;
				}
				if (offset < instruction3.Offset)
				{
					num5 = num6 - 1;
				}
				else
				{
					num4 = num6 + 1;
				}
			}
			return null;
		}
		void ReadOperand(BinaryReader reader, Instruction instr)
		{
			switch (instr.OpCode.OperandType)
			{
			case Mono.Cecil.Cil.OperandType.InlineNone:
				instr.Operand = null;
				break;
			case Mono.Cecil.Cil.OperandType.InlineSwitch:
			{
				int num = reader.ReadInt32();
				int num2 = (int)reader.BaseStream.Position + 4 * num;
				int[] array3 = new int[num];
				for (int j = 0; j < num; j++)
				{
					array3[j] = reader.ReadInt32() + num2;
				}
				instr.Operand = array3;
				break;
			}
			case Mono.Cecil.Cil.OperandType.ShortInlineBrTarget:
			{
				int num2 = reader.ReadSByte();
				instr.Operand = (int)reader.BaseStream.Position + num2;
				break;
			}
			case Mono.Cecil.Cil.OperandType.InlineBrTarget:
			{
				int num2 = reader.ReadInt32();
				instr.Operand = (int)reader.BaseStream.Position + num2;
				break;
			}
			case Mono.Cecil.Cil.OperandType.ShortInlineI:
				instr.Operand = ((instr.OpCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_S) ? ((object)reader.ReadSByte()) : ((object)reader.ReadByte()));
				break;
			case Mono.Cecil.Cil.OperandType.InlineI:
				instr.Operand = reader.ReadInt32();
				break;
			case Mono.Cecil.Cil.OperandType.ShortInlineR:
				instr.Operand = reader.ReadSingle();
				break;
			case Mono.Cecil.Cil.OperandType.InlineR:
				instr.Operand = reader.ReadDouble();
				break;
			case Mono.Cecil.Cil.OperandType.InlineI8:
				instr.Operand = reader.ReadInt64();
				break;
			case Mono.Cecil.Cil.OperandType.InlineSig:
				instr.Operand = moduleTo.ImportCallSite(moduleFrom, moduleFrom.ResolveSignature(reader.ReadInt32()));
				break;
			case Mono.Cecil.Cil.OperandType.InlineString:
				instr.Operand = moduleFrom.ResolveString(reader.ReadInt32());
				break;
			case Mono.Cecil.Cil.OperandType.InlineTok:
				instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Any);
				break;
			case Mono.Cecil.Cil.OperandType.InlineType:
				instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Type);
				break;
			case Mono.Cecil.Cil.OperandType.InlineMethod:
				instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Method);
				break;
			case Mono.Cecil.Cil.OperandType.InlineField:
				instr.Operand = ResolveTokenAs(reader.ReadInt32(), TokenResolutionMode.Field);
				break;
			case Mono.Cecil.Cil.OperandType.InlineVar:
			case Mono.Cecil.Cil.OperandType.ShortInlineVar:
			{
				int index = ((instr.OpCode.OperandType == Mono.Cecil.Cil.OperandType.ShortInlineVar) ? reader.ReadByte() : reader.ReadInt16());
				instr.Operand = bodyTo.Variables[index];
				break;
			}
			case Mono.Cecil.Cil.OperandType.InlineArg:
			case Mono.Cecil.Cil.OperandType.ShortInlineArg:
			{
				int index = ((instr.OpCode.OperandType == Mono.Cecil.Cil.OperandType.ShortInlineArg) ? reader.ReadByte() : reader.ReadInt16());
				instr.Operand = into.Parameters[index];
				break;
			}
			default:
				throw new NotSupportedException("Unsupported opcode $" + instr.OpCode.Name);
			}
		}
		MemberReference ResolveTokenAs(int token, TokenResolutionMode resolveMode)
		{
			try
			{
				switch (resolveMode)
				{
				case TokenResolutionMode.Type:
				{
					Type type2 = moduleFrom.ResolveType(token, typeArguments, methodArguments);
					type2.FixReflectionCacheAuto();
					return moduleTo.ImportReference(type2);
				}
				case TokenResolutionMode.Method:
				{
					MethodBase methodBase2 = moduleFrom.ResolveMethod(token, typeArguments, methodArguments);
					methodBase2?.GetRealDeclaringType()?.FixReflectionCacheAuto();
					return moduleTo.ImportReference(methodBase2);
				}
				case TokenResolutionMode.Field:
				{
					FieldInfo fieldInfo2 = moduleFrom.ResolveField(token, typeArguments, methodArguments);
					fieldInfo2?.GetRealDeclaringType()?.FixReflectionCacheAuto();
					return moduleTo.ImportReference(fieldInfo2);
				}
				case TokenResolutionMode.Any:
				{
					MemberInfo memberInfo = moduleFrom.ResolveMember(token, typeArguments, methodArguments);
					if (memberInfo is Type type)
					{
						type.FixReflectionCacheAuto();
						return moduleTo.ImportReference(type);
					}
					if (memberInfo is MethodBase methodBase)
					{
						methodBase.GetRealDeclaringType()?.FixReflectionCacheAuto();
						return moduleTo.ImportReference(methodBase);
					}
					if (!(memberInfo is FieldInfo fieldInfo))
					{
						throw new NotSupportedException($"Invalid resolved member type {memberInfo?.GetType()}");
					}
					fieldInfo.GetRealDeclaringType()?.FixReflectionCacheAuto();
					return moduleTo.ImportReference(fieldInfo);
				}
				default:
					throw new NotSupportedException($"Invalid TokenResolutionMode {resolveMode}");
				}
			}
			catch (MissingMemberException)
			{
				string location = moduleFrom.Assembly.Location;
				if (!File.Exists(location))
				{
					throw;
				}
				using AssemblyDefinition assemblyDefinition = AssemblyDefinition.ReadAssembly(location, new ReaderParameters
				{
					ReadingMode = ReadingMode.Deferred
				});
				MemberReference memberReference = (MemberReference)assemblyDefinition.Modules.First((ModuleDefinition m) => m.Name == moduleFrom.Name).LookupToken(token);
				return resolveMode switch
				{
					TokenResolutionMode.Type => (TypeReference)memberReference, 
					TokenResolutionMode.Method => (MethodReference)memberReference, 
					TokenResolutionMode.Field => (FieldReference)memberReference, 
					TokenResolutionMode.Any => memberReference, 
					_ => throw new NotSupportedException($"Invalid TokenResolutionMode {resolveMode}"), 
				};
			}
		}
	}

	static DynamicMethodDefinition()
	{
		_CecilOpCodes1X = null;
		_CecilOpCodes2X = null;
		_IsNewMonoSRE = PlatformDetection.Runtime == RuntimeKind.Mono && typeof(DynamicMethod).GetField("il_info", BindingFlags.Instance | BindingFlags.NonPublic) != null;
		_IsOldMonoSRE = PlatformDetection.Runtime == RuntimeKind.Mono && !_IsNewMonoSRE && typeof(DynamicMethod).GetField("ilgen", BindingFlags.Instance | BindingFlags.NonPublic) != null;
		_PreferCecil = (PlatformDetection.Runtime == RuntimeKind.Mono && !_IsNewMonoSRE && !_IsOldMonoSRE) || (PlatformDetection.Runtime != RuntimeKind.Mono && typeof(ILGenerator).Assembly.GetType("System.Reflection.Emit.DynamicILGenerator")?.GetField("m_scope", BindingFlags.Instance | BindingFlags.NonPublic) == null);
		c_DebuggableAttribute = typeof(DebuggableAttribute).GetConstructor(new Type[1] { typeof(DebuggableAttribute.DebuggingModes) });
		c_UnverifiableCodeAttribute = typeof(UnverifiableCodeAttribute).GetConstructor(ArrayEx.Empty<Type>());
		c_IgnoresAccessChecksToAttribute = typeof(IgnoresAccessChecksToAttribute).GetConstructor(new Type[1] { typeof(string) });
		t__IDMDGenerator = typeof(IDMDGenerator);
		_DMDGeneratorCache = new ConcurrentDictionary<string, IDMDGenerator>();
		_InitCopier();
	}

	private static bool GetDefaultDebugValue()
	{
		bool isEnabled;
		return Switches.TryGetSwitchEnabled("DMDDebug", out isEnabled) && isEnabled;
	}

	public DynamicMethodDefinition(MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		OriginalMethod = method;
		Debug = GetDefaultDebugValue();
		LoadFromMethod(method, out ModuleDefinition Module, out MethodDefinition def);
		this.Module = Module;
		Definition = def;
	}

	public DynamicMethodDefinition(string name, Type? returnType, Type[] parameterTypes)
	{
		Helpers.ThrowIfArgumentNull(name, "name");
		Helpers.ThrowIfArgumentNull(parameterTypes, "parameterTypes");
		Name = name;
		OriginalMethod = null;
		Debug = GetDefaultDebugValue();
		_CreateDynModule(name, returnType, parameterTypes, out ModuleDefinition Module, out MethodDefinition Definition);
		this.Module = Module;
		this.Definition = Definition;
	}

	[MemberNotNull("Definition")]
	public ILProcessor GetILProcessor()
	{
		if (Definition == null)
		{
			throw new InvalidOperationException();
		}
		return Definition.Body.GetILProcessor();
	}

	[MemberNotNull("Definition")]
	public ILGenerator GetILGenerator()
	{
		if (Definition == null)
		{
			throw new InvalidOperationException();
		}
		return new CecilILGenerator(Definition.Body.GetILProcessor()).GetProxy();
	}

	private void _CreateDynModule(string name, Type? returnType, Type[] parameterTypes, out ModuleDefinition Module, out MethodDefinition Definition)
	{
		ModuleDefinition moduleDefinition = (Module = ModuleDefinition.CreateModule($"DMD:DynModule<{name}>?{GetHashCode()}", new ModuleParameters
		{
			Kind = ModuleKind.Dll,
			ReflectionImporterProvider = MMReflectionImporter.ProviderNoDefault
		}));
		TypeDefinition typeDefinition = new TypeDefinition("", $"DMD<{name}>?{GetHashCode()}", Mono.Cecil.TypeAttributes.Public);
		moduleDefinition.Types.Add(typeDefinition);
		MethodDefinition methodDefinition = (Definition = new MethodDefinition(name, Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Static | Mono.Cecil.MethodAttributes.HideBySig, (returnType != null) ? moduleDefinition.ImportReference(returnType) : moduleDefinition.TypeSystem.Void));
		foreach (Type type in parameterTypes)
		{
			methodDefinition.Parameters.Add(new ParameterDefinition(moduleDefinition.ImportReference(type)));
		}
		typeDefinition.Methods.Add(methodDefinition);
	}

	private void LoadFromMethod(MethodBase orig, out ModuleDefinition Module, out MethodDefinition def)
	{
		ParameterInfo[] parameters = orig.GetParameters();
		int num = 0;
		Type[] array;
		if (!orig.IsStatic)
		{
			num++;
			array = new Type[parameters.Length + 1];
			array[0] = orig.GetThisParamType();
		}
		else
		{
			array = new Type[parameters.Length];
		}
		for (int i = 0; i < parameters.Length; i++)
		{
			array[i + num] = parameters[i].ParameterType;
		}
		_CreateDynModule(orig.GetID(null, null, withType: true, proxyMethod: false, simple: true), (orig as MethodInfo)?.ReturnType, array, out Module, out def);
		_CopyMethodToDefinition(orig, def);
		if (!orig.IsStatic)
		{
			def.Parameters[0].Name = "this";
		}
		for (int j = 0; j < parameters.Length; j++)
		{
			def.Parameters[j + num].Name = parameters[j].Name;
		}
	}

	public MethodInfo Generate()
	{
		return Generate(null);
	}

	public MethodInfo Generate(object? context)
	{
		object value;
		string text = (Switches.TryGetSwitchValue("DMDType", out value) ? (value as string) : null);
		if (text != null)
		{
			if (text.Equals("dynamicmethod", StringComparison.OrdinalIgnoreCase) || text.Equals("dm", StringComparison.OrdinalIgnoreCase))
			{
				return DMDGenerator<DMDEmitDynamicMethodGenerator>.Generate(this, context);
			}
			if (text.Equals("cecil", StringComparison.OrdinalIgnoreCase) || text.Equals("md", StringComparison.OrdinalIgnoreCase))
			{
				return DMDGenerator<DMDCecilGenerator>.Generate(this, context);
			}
			if (text.Equals("methodbuilder", StringComparison.OrdinalIgnoreCase) || text.Equals("mb", StringComparison.OrdinalIgnoreCase))
			{
				return DMDGenerator<DMDEmitMethodBuilderGenerator>.Generate(this, context);
			}
		}
		if (text != null)
		{
			Type type = ReflectionHelper.GetType(text);
			if (type != null)
			{
				if (!t__IDMDGenerator.IsCompatible(type))
				{
					throw new ArgumentException("Invalid DMDGenerator type: " + text);
				}
				return _DMDGeneratorCache.GetOrAdd(text, (string _) => (IDMDGenerator)Activator.CreateInstance(type)).Generate(this, context);
			}
		}
		if (_PreferCecil)
		{
			return DMDGenerator<DMDCecilGenerator>.Generate(this, context);
		}
		if (Debug)
		{
			return DMDGenerator<DMDEmitMethodBuilderGenerator>.Generate(this, context);
		}
		if (Definition.Body.ExceptionHandlers.Any((ExceptionHandler eh) => eh.HandlerType == ExceptionHandlerType.Fault || eh.HandlerType == ExceptionHandlerType.Filter))
		{
			return DMDGenerator<DMDEmitMethodBuilderGenerator>.Generate(this, context);
		}
		return DMDGenerator<DMDEmitDynamicMethodGenerator>.Generate(this, context);
	}

	public void Dispose()
	{
		if (!isDisposed)
		{
			isDisposed = true;
			Module?.Dispose();
		}
	}

	public string GetDumpName(string type)
	{
		return $"DMDASM.{GUID.GetHashCode():X8}{(string.IsNullOrEmpty(type) ? "" : ("." + type))}";
	}
}


private enum TokenResolutionMode
{
	Any,
	Type,
	Method,
	Field
}


using System.Reflection;
using Mono.Cecil;
using MonoMod.Utils;

internal class DynamicMethodReference : MethodReference
{
	public MethodInfo DynamicMethod { get; }

	public DynamicMethodReference(ModuleDefinition module, MethodInfo dm)
		: base("", Helpers.ThrowIfNull(module, "module").TypeSystem.Void)
	{
		DynamicMethod = dm;
	}
}


internal record struct DynamicReferenceCell
{
	public int Index { get; internal set; }

	public int Hash { get; internal set; }

	public DynamicReferenceCell(int idx, int hash)
	{
		Index = idx;
		Hash = hash;
	}
}


using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Threading;
using Mono.Cecil.Cil;
using MonoMod.Cil;
using MonoMod.Utils;

internal static class DynamicReferenceManager
{
	private abstract class Cell
	{
		public readonly nuint Type;

		protected Cell(nuint type)
		{
			Type = type;
		}
	}

	private class RefCell : Cell
	{
		public object? Value;

		public RefCell()
			: base(0u)
		{
		}
	}

	private abstract class ValueCellBase : Cell
	{
		public ValueCellBase()
			: base(1u)
		{
		}

		public abstract object? BoxValue();
	}

	private class ValueCell<T> : ValueCellBase
	{
		public T? Value;

		public override object? BoxValue()
		{
			return Value;
		}
	}

	private sealed class ScopeHandler : ScopeHandlerBase<DynamicReferenceCell>
	{
		public static readonly ScopeHandler Instance = new ScopeHandler();

		public override void EndScope(DynamicReferenceCell data)
		{
			bool lockTaken = false;
			try
			{
				writeLock.Enter(ref lockTaken);
				Cell[] cells = DynamicReferenceManager.cells;
				Cell cell = Volatile.Read(in cells[data.Index]);
				if (cell != null && cell.GetHashCode() == data.Hash)
				{
					Volatile.Write(ref cells[data.Index], null);
					firstEmptyCell = Math.Min(firstEmptyCell, data.Index);
				}
			}
			finally
			{
				if (lockTaken)
				{
					writeLock.Exit();
				}
			}
		}
	}

	private const nuint RefValueCell = 0u;

	private const nuint ValueTypeCell = 1u;

	private static SpinLock writeLock = new SpinLock(enableThreadOwnerTracking: false);

	private static volatile Cell?[] cells = new Cell[16];

	private static volatile int firstEmptyCell;

	private static readonly MethodInfo Self_GetValue_ii = typeof(DynamicReferenceManager).GetMethod("GetValue", BindingFlags.Static | BindingFlags.NonPublic, null, new Type[2]
	{
		typeof(int),
		typeof(int)
	}, null) ?? throw new InvalidOperationException("GetValue doesn't exist?!?!?!?");

	private static readonly MethodInfo Self_GetValueT_ii = typeof(DynamicReferenceManager).GetMethod("GetValueT", BindingFlags.Static | BindingFlags.NonPublic, null, new Type[2]
	{
		typeof(int),
		typeof(int)
	}, null) ?? throw new InvalidOperationException("GetValueT doesn't exist?!?!?!?");

	private static readonly MethodInfo Self_GetValueTUnsafe_ii = typeof(DynamicReferenceManager).GetMethod("GetValueTUnsafe", BindingFlags.Static | BindingFlags.NonPublic, null, new Type[2]
	{
		typeof(int),
		typeof(int)
	}, null) ?? throw new InvalidOperationException("GetValueTUnsafe doesn't exist?!?!?!?");

	private static DataScope<DynamicReferenceCell> AllocReferenceCore(Cell cell, out DynamicReferenceCell cellRef)
	{
		cellRef = default(DynamicReferenceCell);
		bool lockTaken = false;
		try
		{
			writeLock.Enter(ref lockTaken);
			Cell[] array = cells;
			int i = firstEmptyCell;
			if (i >= array.Length)
			{
				Cell[] destinationArray = new Cell[array.Length * 2];
				Array.Copy(array, destinationArray, array.Length);
				array = (cells = destinationArray);
			}
			int num = i++;
			for (; i < array.Length && array[i] != null; i++)
			{
			}
			firstEmptyCell = i;
			Volatile.Write(ref array[num], cell);
			cellRef = new DynamicReferenceCell(num, cell.GetHashCode());
		}
		finally
		{
			if (lockTaken)
			{
				writeLock.Exit();
			}
		}
		return new DataScope<DynamicReferenceCell>(ScopeHandler.Instance, cellRef);
	}

	private static DataScope<DynamicReferenceCell> AllocReferenceClass(object? value, out DynamicReferenceCell cellRef)
	{
		return AllocReferenceCore(new RefCell
		{
			Value = value
		}, out cellRef);
	}

	private static DataScope<DynamicReferenceCell> AllocReferenceStruct<T>(in T value, out DynamicReferenceCell cellRef)
	{
		return AllocReferenceCore(new ValueCell<T>
		{
			Value = value
		}, out cellRef);
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	public static DataScope<DynamicReferenceCell> AllocReference<T>(in T? value, out DynamicReferenceCell cellRef)
	{
		if (default(T) == null)
		{
			return AllocReferenceClass(Unsafe.As<T, object>(ref Unsafe.AsRef(in value)), out cellRef);
		}
		return AllocReferenceStruct(in value, out cellRef);
	}

	private static Cell GetCell(DynamicReferenceCell cellRef)
	{
		Cell cell = Volatile.Read(in cells[cellRef.Index]);
		if (cell == null || cell.GetHashCode() != cellRef.Hash)
		{
			throw new ArgumentException("Referenced cell no longer exists", "cellRef");
		}
		return cell;
	}

	public static object? GetValue(DynamicReferenceCell cellRef)
	{
		Cell cell = GetCell(cellRef);
		return (ulong)cell.Type switch
		{
			0uL => Unsafe.As<RefCell>(cell).Value, 
			1uL => Unsafe.As<ValueCellBase>(cell).BoxValue(), 
			_ => throw new InvalidOperationException("Cell is not of valid type"), 
		};
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	private static ref T? GetValueRef<T>(DynamicReferenceCell cellRef)
	{
		Cell cell = GetCell(cellRef);
		switch (cell.Type)
		{
		case 0uL:
		{
			Helpers.Assert(default(T) == null, null, "default(T) == null");
			RefCell refCell = Unsafe.As<RefCell>(cell);
			object value = refCell.Value;
			bool value2 = ((value == null || value is T) ? true : false);
			Helpers.Assert(value2, null, "c.Value is null or T");
			return ref Unsafe.As<object, T>(ref refCell.Value);
		}
		case 1uL:
			Helpers.Assert(default(T) != null, null, "default(T) != null");
			return ref ((ValueCell<T>)cell).Value;
		default:
			throw new InvalidOperationException("Cell is not of valid type");
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveOptimization)]
	private static ref T? GetValueRefUnsafe<T>(DynamicReferenceCell cellRef)
	{
		Cell cell = GetCell(cellRef);
		if (default(T) == null)
		{
			return ref Unsafe.As<object, T>(ref Unsafe.As<RefCell>(cell).Value);
		}
		return ref Unsafe.As<ValueCell<T>>(cell).Value;
	}

	public static T? GetValue<T>(DynamicReferenceCell cellRef)
	{
		return GetValueRef<T>(cellRef);
	}

	internal static object? GetValue(int index, int hash)
	{
		return GetValue(new DynamicReferenceCell(index, hash));
	}

	internal static T? GetValueT<T>(int index, int hash)
	{
		return GetValue<T>(new DynamicReferenceCell(index, hash));
	}

	internal static T? GetValueTUnsafe<T>(int index, int hash)
	{
		return GetValueRefUnsafe<T>(new DynamicReferenceCell(index, hash));
	}

	public static void SetValue<T>(DynamicReferenceCell cellRef, in T? value)
	{
		GetValueRef<T>(cellRef) = value;
	}

	public static void EmitLoadReference(this ILProcessor il, DynamicReferenceCell cellRef)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(Mono.Cecil.Cil.OpCodes.Call, il.Body.Method.Module.ImportReference(Self_GetValue_ii));
	}

	public static void EmitLoadReference(this ILCursor il, DynamicReferenceCell cellRef)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(Mono.Cecil.Cil.OpCodes.Call, il.Body.Method.Module.ImportReference(Self_GetValue_ii));
	}

	public static void EmitLoadReference(this ILGenerator il, DynamicReferenceCell cellRef)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(System.Reflection.Emit.OpCodes.Call, Self_GetValue_ii);
	}

	public static void EmitLoadTypedReference(this ILProcessor il, DynamicReferenceCell cellRef, Type type)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(Mono.Cecil.Cil.OpCodes.Call, il.Body.Method.Module.ImportReference(Self_GetValueT_ii.MakeGenericMethod(type)));
	}

	public static void EmitLoadTypedReference(this ILCursor il, DynamicReferenceCell cellRef, Type type)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(Mono.Cecil.Cil.OpCodes.Call, il.Body.Method.Module.ImportReference(Self_GetValueT_ii.MakeGenericMethod(type)));
	}

	public static void EmitLoadTypedReference(this ILGenerator il, DynamicReferenceCell cellRef, Type type)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(System.Reflection.Emit.OpCodes.Call, Self_GetValueT_ii.MakeGenericMethod(type));
	}

	internal static void EmitLoadTypedReferenceUnsafe(this ILProcessor il, DynamicReferenceCell cellRef, Type type)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(Mono.Cecil.Cil.OpCodes.Call, il.Body.Method.Module.ImportReference(Self_GetValueTUnsafe_ii.MakeGenericMethod(type)));
	}

	internal static void EmitLoadTypedReferenceUnsafe(this ILCursor il, DynamicReferenceCell cellRef, Type type)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(Mono.Cecil.Cil.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(Mono.Cecil.Cil.OpCodes.Call, il.Body.Method.Module.ImportReference(Self_GetValueTUnsafe_ii.MakeGenericMethod(type)));
	}

	internal static void EmitLoadTypedReferenceUnsafe(this ILGenerator il, DynamicReferenceCell cellRef, Type type)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, cellRef.Index);
		il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, cellRef.Hash);
		il.Emit(System.Reflection.Emit.OpCodes.Call, Self_GetValueTUnsafe_ii.MakeGenericMethod(type));
	}

	public static DataScope<DynamicReferenceCell> EmitNewReference(this ILProcessor il, object? value, out DynamicReferenceCell cellRef)
	{
		DataScope<DynamicReferenceCell> result = AllocReference(in value, out cellRef);
		il.EmitLoadReference(cellRef);
		return result;
	}

	public static DataScope<DynamicReferenceCell> EmitNewReference(this ILCursor il, object? value, out DynamicReferenceCell cellRef)
	{
		DataScope<DynamicReferenceCell> result = AllocReference(in value, out cellRef);
		il.EmitLoadReference(cellRef);
		return result;
	}

	public static DataScope<DynamicReferenceCell> EmitNewReference(this ILGenerator il, object? value, out DynamicReferenceCell cellRef)
	{
		DataScope<DynamicReferenceCell> result = AllocReference(in value, out cellRef);
		il.EmitLoadReference(cellRef);
		return result;
	}

	public static DataScope<DynamicReferenceCell> EmitNewTypedReference<T>(this ILProcessor il, T? value, out DynamicReferenceCell cellRef)
	{
		DataScope<DynamicReferenceCell> result = AllocReference(in value, out cellRef);
		il.EmitLoadTypedReferenceUnsafe(cellRef, typeof(T));
		return result;
	}

	public static DataScope<DynamicReferenceCell> EmitNewTypedReference<T>(this ILCursor il, T? value, out DynamicReferenceCell cellRef)
	{
		DataScope<DynamicReferenceCell> result = AllocReference(in value, out cellRef);
		il.EmitLoadTypedReferenceUnsafe(cellRef, typeof(T));
		return result;
	}

	public static DataScope<DynamicReferenceCell> EmitNewTypedReference<T>(this ILGenerator il, T? value, out DynamicReferenceCell cellRef)
	{
		DataScope<DynamicReferenceCell> result = AllocReference(in value, out cellRef);
		il.EmitLoadTypedReferenceUnsafe(cellRef, typeof(T));
		return result;
	}
}


private abstract class Cell
{
	public readonly nuint Type;

	protected Cell(nuint type)
	{
		Type = type;
	}
}


private class RefCell : Cell
{
	public object? Value;

	public RefCell()
		: base(0u)
	{
	}
}


private abstract class ValueCellBase : Cell
{
	public ValueCellBase()
		: base(1u)
	{
	}

	public abstract object? BoxValue();
}


private class ValueCell<T> : ValueCellBase
{
	public T? Value;

	public override object? BoxValue()
	{
		return Value;
	}
}


using System;
using System.Threading;

private sealed class ScopeHandler : ScopeHandlerBase<DynamicReferenceCell>
{
	public static readonly ScopeHandler Instance = new ScopeHandler();

	public override void EndScope(DynamicReferenceCell data)
	{
		bool lockTaken = false;
		try
		{
			writeLock.Enter(ref lockTaken);
			Cell[] cells = DynamicReferenceManager.cells;
			Cell cell = Volatile.Read(in cells[data.Index]);
			if (cell != null && cell.GetHashCode() == data.Hash)
			{
				Volatile.Write(ref cells[data.Index], null);
				firstEmptyCell = Math.Min(firstEmptyCell, data.Index);
			}
		}
		finally
		{
			if (lockTaken)
			{
				writeLock.Exit();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using MonoMod.Utils;

internal sealed class DynData<TTarget> : IDisposable where TTarget : class
{
	private class _Data_ : IDisposable
	{
		public readonly Dictionary<string, Func<TTarget, object?>> Getters = new Dictionary<string, Func<TTarget, object>>();

		public readonly Dictionary<string, Action<TTarget, object?>> Setters = new Dictionary<string, Action<TTarget, object>>();

		public readonly Dictionary<string, object?> Data = new Dictionary<string, object>();

		public readonly HashSet<string> Disposable = new HashSet<string>();

		~_Data_()
		{
			Dispose();
		}

		public void Dispose()
		{
			lock (Data)
			{
				if (Data.Count == 0)
				{
					return;
				}
				foreach (string item in Disposable)
				{
					if (Data.TryGetValue(item, out object value) && value is IDisposable disposable)
					{
						disposable.Dispose();
					}
				}
				Disposable.Clear();
				Data.Clear();
			}
			GC.SuppressFinalize(this);
		}
	}

	private static readonly _Data_ _DataStatic;

	private static readonly ConditionalWeakTable<object, _Data_> _DataMap;

	private static readonly Dictionary<string, Func<TTarget, object?>> _SpecialGetters;

	private static readonly Dictionary<string, Action<TTarget, object?>> _SpecialSetters;

	private readonly WeakReference? Weak;

	private TTarget? KeepAlive;

	private readonly _Data_ _Data;

	public Dictionary<string, Func<TTarget, object?>> Getters => _Data.Getters;

	public Dictionary<string, Action<TTarget, object?>> Setters => _Data.Setters;

	public Dictionary<string, object?> Data => _Data.Data;

	public bool IsAlive
	{
		get
		{
			if (Weak != null)
			{
				return Weak.SafeGetIsAlive();
			}
			return true;
		}
	}

	public TTarget Target => (TTarget)(Weak?.SafeGetTarget());

	public object? this[string name]
	{
		get
		{
			if (_SpecialGetters.TryGetValue(name, out Func<TTarget, object> value) || Getters.TryGetValue(name, out value))
			{
				return value(Target);
			}
			if (Data.TryGetValue(name, out object value2))
			{
				return value2;
			}
			return null;
		}
		set
		{
			if (_SpecialSetters.TryGetValue(name, out Action<TTarget, object> value2) || Setters.TryGetValue(name, out value2))
			{
				value2(Target, value);
				return;
			}
			object obj;
			if (_Data.Disposable.Contains(name) && (obj = this[name]) != null && obj is IDisposable disposable)
			{
				disposable.Dispose();
			}
			Data[name] = value;
		}
	}

	public static event Action<DynData<TTarget>, TTarget?>? OnInitialize;

	static DynData()
	{
		_DataStatic = new _Data_();
		_DataMap = new ConditionalWeakTable<object, _Data_>();
		_SpecialGetters = new Dictionary<string, Func<TTarget, object>>();
		_SpecialSetters = new Dictionary<string, Action<TTarget, object>>();
		FieldInfo[] fields = typeof(TTarget).GetFields(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (FieldInfo field in fields)
		{
			string name = field.Name;
			_SpecialGetters[name] = (TTarget obj) => field.GetValue(obj);
			_SpecialSetters[name] = delegate(TTarget obj, object? value)
			{
				field.SetValue(obj, value);
			};
		}
		PropertyInfo[] properties = typeof(TTarget).GetProperties(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (PropertyInfo propertyInfo in properties)
		{
			string name2 = propertyInfo.Name;
			MethodInfo get = propertyInfo.GetGetMethod(nonPublic: true);
			if (get != null)
			{
				_SpecialGetters[name2] = (TTarget obj) => get.Invoke(obj, ArrayEx.Empty<object>());
			}
			MethodInfo set = propertyInfo.GetSetMethod(nonPublic: true);
			if (set != null)
			{
				_SpecialSetters[name2] = delegate(TTarget obj, object? value)
				{
					set.Invoke(obj, new object[1] { value });
				};
			}
		}
	}

	public DynData()
		: this((TTarget?)null, keepAlive: false)
	{
	}

	public DynData(TTarget? obj)
		: this(obj, keepAlive: true)
	{
	}

	public DynData(TTarget? obj, bool keepAlive)
	{
		if (obj != null)
		{
			WeakReference weak = new WeakReference(obj);
			if (!_DataMap.TryGetValue(obj, out _Data_ value))
			{
				value = new _Data_();
				_DataMap.Add(obj, value);
			}
			_Data = value;
			Weak = weak;
			if (keepAlive)
			{
				KeepAlive = obj;
			}
		}
		else
		{
			_Data = _DataStatic;
		}
		DynData<TTarget>.OnInitialize?.Invoke(this, obj);
	}

	public T? Get<T>(string name)
	{
		return (T)this[name];
	}

	public void Set<T>(string name, T value)
	{
		this[name] = value;
	}

	public void RegisterProperty(string name, Func<TTarget, object?> getter, Action<TTarget, object?> setter)
	{
		Getters[name] = getter;
		Setters[name] = setter;
	}

	public void UnregisterProperty(string name)
	{
		Getters.Remove(name);
		Setters.Remove(name);
	}

	private void Dispose(bool disposing)
	{
		KeepAlive = null;
		if (disposing)
		{
			_Data.Dispose();
		}
	}

	~DynData()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		Dispose(disposing: true);
		GC.SuppressFinalize(this);
	}
}


using System;
using System.Collections.Generic;

private class _Data_ : IDisposable
{
	public readonly Dictionary<string, Func<TTarget, object?>> Getters = new Dictionary<string, Func<TTarget, object>>();

	public readonly Dictionary<string, Action<TTarget, object?>> Setters = new Dictionary<string, Action<TTarget, object>>();

	public readonly Dictionary<string, object?> Data = new Dictionary<string, object>();

	public readonly HashSet<string> Disposable = new HashSet<string>();

	~_Data_()
	{
		Dispose();
	}

	public void Dispose()
	{
		lock (Data)
		{
			if (Data.Count == 0)
			{
				return;
			}
			foreach (string item in Disposable)
			{
				if (Data.TryGetValue(item, out object value) && value is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}
			Disposable.Clear();
			Data.Clear();
		}
		GC.SuppressFinalize(this);
	}
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.InteropServices;
using MonoMod;
using MonoMod.Utils;
using MonoMod.Utils.Interop;

internal static class DynDll
{
	private abstract class BackendImpl
	{
		protected abstract bool TryOpenLibraryCore(string? name, Assembly assembly, out IntPtr handle);

		public abstract bool TryCloseLibrary(IntPtr handle);

		public abstract bool TryGetExport(IntPtr handle, string name, out IntPtr ptr);

		protected abstract void CheckAndThrowError();

		public virtual bool TryOpenLibrary(string? name, Assembly assembly, out IntPtr handle)
		{
			if (name != null)
			{
				foreach (string item in GetLibrarySearchOrder(name))
				{
					if (TryOpenLibraryCore(item, assembly, out handle))
					{
						return true;
					}
				}
				handle = IntPtr.Zero;
				return false;
			}
			return TryOpenLibraryCore(null, assembly, out handle);
		}

		protected virtual IEnumerable<string> GetLibrarySearchOrder(string name)
		{
			yield return name;
		}

		public virtual IntPtr OpenLibrary(string? name, Assembly assembly)
		{
			if (!TryOpenLibrary(name, assembly, out var handle))
			{
				CheckAndThrowError();
			}
			return handle;
		}

		public virtual void CloseLibrary(IntPtr handle)
		{
			if (!TryCloseLibrary(handle))
			{
				CheckAndThrowError();
			}
		}

		public virtual IntPtr GetExport(IntPtr handle, string name)
		{
			if (!TryGetExport(handle, name, out var ptr))
			{
				CheckAndThrowError();
			}
			return ptr;
		}
	}

	private sealed class WindowsBackend : BackendImpl
	{
		protected override void CheckAndThrowError()
		{
			uint lastError = Windows.GetLastError();
			if (lastError != 0)
			{
				throw new Win32Exception((int)lastError);
			}
		}

		protected unsafe override bool TryOpenLibraryCore(string? name, Assembly assembly, out IntPtr handle)
		{
			IntPtr intPtr;
			if (name == null)
			{
				intPtr = (handle = (nint)Windows.GetModuleHandleW(null));
			}
			else
			{
				fixed (char* lpLibFileName = name)
				{
					intPtr = (handle = (nint)Windows.LoadLibraryW((ushort*)lpLibFileName));
				}
			}
			return intPtr != IntPtr.Zero;
		}

		public unsafe override bool TryCloseLibrary(IntPtr handle)
		{
			return Windows.FreeLibrary(new Windows.HMODULE((void*)handle));
		}

		public unsafe override bool TryGetExport(IntPtr handle, string name, out IntPtr ptr)
		{
			byte[]? array = Unix.MarshalToUtf8(name);
			IntPtr intPtr;
			fixed (byte* lpProcName = array)
			{
				intPtr = (ptr = Windows.GetProcAddress(new Windows.HMODULE((void*)handle), (sbyte*)lpProcName));
			}
			Unix.FreeMarshalledArray(array);
			return intPtr != IntPtr.Zero;
		}

		protected override IEnumerable<string> GetLibrarySearchOrder(string name)
		{
			yield return name;
			if (!name.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) && !name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
			{
				yield return name + ".dll";
			}
		}
	}

	private abstract class LibdlBackend : BackendImpl
	{
		[ThreadStatic]
		private static IntPtr lastDlErrorReturn;

		protected LibdlBackend()
		{
			Unix.DlError();
		}

		[DoesNotReturn]
		private static void ThrowError(IntPtr dlerr)
		{
			throw new Win32Exception(Marshal.PtrToStringAnsi(dlerr));
		}

		protected override void CheckAndThrowError()
		{
			IntPtr intPtr = lastDlErrorReturn;
			IntPtr intPtr2;
			if (intPtr == IntPtr.Zero)
			{
				intPtr2 = Unix.DlError();
			}
			else
			{
				intPtr2 = intPtr;
				lastDlErrorReturn = IntPtr.Zero;
			}
			if (intPtr2 != IntPtr.Zero)
			{
				ThrowError(intPtr2);
			}
		}

		protected override bool TryOpenLibraryCore(string? name, Assembly assembly, out IntPtr handle)
		{
			Unix.DlopenFlags flags = (Unix.DlopenFlags)258;
			return (handle = Unix.DlOpen(name, flags)) != IntPtr.Zero;
		}

		public override bool TryCloseLibrary(IntPtr handle)
		{
			return Unix.DlClose(handle);
		}

		public override bool TryGetExport(IntPtr handle, string name, out IntPtr ptr)
		{
			Unix.DlError();
			ptr = Unix.DlSym(handle, name);
			return (lastDlErrorReturn = Unix.DlError()) == IntPtr.Zero;
		}

		public override IntPtr GetExport(IntPtr handle, string name)
		{
			Unix.DlError();
			IntPtr result = Unix.DlSym(handle, name);
			IntPtr intPtr = Unix.DlError();
			if (intPtr != IntPtr.Zero)
			{
				ThrowError(intPtr);
			}
			return result;
		}
	}

	private sealed class LinuxOSXBackend : LibdlBackend
	{
		private readonly bool isLinux;

		public LinuxOSXBackend(bool isLinux)
		{
			this.isLinux = isLinux;
		}

		protected override IEnumerable<string> GetLibrarySearchOrder(string name)
		{
			bool hasSlash = System.StringExtensions.Contains(name, '/', StringComparison.Ordinal);
			string suffix = ".dylib";
			if (isLinux)
			{
				if (name.EndsWith(".so", StringComparison.Ordinal) || System.StringExtensions.Contains(name, ".so.", StringComparison.Ordinal))
				{
					yield return name;
					if (!hasSlash)
					{
						yield return "lib" + name;
					}
					yield return name + ".so";
					if (!hasSlash)
					{
						yield return "lib" + name + ".so";
					}
					yield break;
				}
				suffix = ".so";
			}
			yield return name + suffix;
			if (!hasSlash)
			{
				yield return "lib" + name + suffix;
			}
			yield return name;
			if (!hasSlash)
			{
				yield return "lib" + name;
			}
			bool flag = isLinux;
			if (flag)
			{
				bool flag2 = ((name == "c" || name == "libc") ? true : false);
				flag = flag2;
			}
			if (!flag)
			{
				yield break;
			}
			foreach (string item in GetLibrarySearchOrder("c.so.6"))
			{
				yield return item;
			}
			foreach (string item2 in GetLibrarySearchOrder("glibc"))
			{
				yield return item2;
			}
			foreach (string item3 in GetLibrarySearchOrder("glibc.so.6"))
			{
				yield return item3;
			}
		}
	}

	private sealed class UnknownPosixBackend : LibdlBackend
	{
	}

	private static readonly BackendImpl Backend = CreateCrossplatBackend();

	private static BackendImpl CreateCrossplatBackend()
	{
		OSKind oS = PlatformDetection.OS;
		if (oS.Is(OSKind.Windows))
		{
			return new WindowsBackend();
		}
		if (oS.Is(OSKind.Linux) || oS.Is(OSKind.OSX))
		{
			return new LinuxOSXBackend(oS.Is(OSKind.Linux));
		}
		bool isEnabled;
		MMDbgLog.DebugLogWarningStringHandler message = new MMDbgLog.DebugLogWarningStringHandler(55, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Unknown OS ");
			message.AppendFormatted(oS);
			message.AppendLiteral(" when setting up DynDll; assuming posix-like");
		}
		MMDbgLog.Warning(ref message);
		return new UnknownPosixBackend();
	}

	public static IntPtr OpenLibrary(string? name)
	{
		return Backend.OpenLibrary(name, Assembly.GetCallingAssembly());
	}

	public static bool TryOpenLibrary(string? name, out IntPtr libraryPtr)
	{
		return Backend.TryOpenLibrary(name, Assembly.GetCallingAssembly(), out libraryPtr);
	}

	public static void CloseLibrary(IntPtr lib)
	{
		Backend.CloseLibrary(lib);
	}

	public static bool TryCloseLibrary(IntPtr lib)
	{
		return Backend.TryCloseLibrary(lib);
	}

	public static IntPtr GetExport(this IntPtr libraryPtr, string name)
	{
		return Backend.GetExport(libraryPtr, name);
	}

	public static bool TryGetExport(this IntPtr libraryPtr, string name, out IntPtr functionPtr)
	{
		return Backend.TryGetExport(libraryPtr, name, out functionPtr);
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;

private abstract class BackendImpl
{
	protected abstract bool TryOpenLibraryCore(string? name, Assembly assembly, out IntPtr handle);

	public abstract bool TryCloseLibrary(IntPtr handle);

	public abstract bool TryGetExport(IntPtr handle, string name, out IntPtr ptr);

	protected abstract void CheckAndThrowError();

	public virtual bool TryOpenLibrary(string? name, Assembly assembly, out IntPtr handle)
	{
		if (name != null)
		{
			foreach (string item in GetLibrarySearchOrder(name))
			{
				if (TryOpenLibraryCore(item, assembly, out handle))
				{
					return true;
				}
			}
			handle = IntPtr.Zero;
			return false;
		}
		return TryOpenLibraryCore(null, assembly, out handle);
	}

	protected virtual IEnumerable<string> GetLibrarySearchOrder(string name)
	{
		yield return name;
	}

	public virtual IntPtr OpenLibrary(string? name, Assembly assembly)
	{
		if (!TryOpenLibrary(name, assembly, out var handle))
		{
			CheckAndThrowError();
		}
		return handle;
	}

	public virtual void CloseLibrary(IntPtr handle)
	{
		if (!TryCloseLibrary(handle))
		{
			CheckAndThrowError();
		}
	}

	public virtual IntPtr GetExport(IntPtr handle, string name)
	{
		if (!TryGetExport(handle, name, out var ptr))
		{
			CheckAndThrowError();
		}
		return ptr;
	}
}


using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Reflection;
using MonoMod.Utils.Interop;

private sealed class WindowsBackend : BackendImpl
{
	protected override void CheckAndThrowError()
	{
		uint lastError = Windows.GetLastError();
		if (lastError != 0)
		{
			throw new Win32Exception((int)lastError);
		}
	}

	protected unsafe override bool TryOpenLibraryCore(string? name, Assembly assembly, out IntPtr handle)
	{
		IntPtr intPtr;
		if (name == null)
		{
			intPtr = (handle = (nint)Windows.GetModuleHandleW(null));
		}
		else
		{
			fixed (char* lpLibFileName = name)
			{
				intPtr = (handle = (nint)Windows.LoadLibraryW((ushort*)lpLibFileName));
			}
		}
		return intPtr != IntPtr.Zero;
	}

	public unsafe override bool TryCloseLibrary(IntPtr handle)
	{
		return Windows.FreeLibrary(new Windows.HMODULE((void*)handle));
	}

	public unsafe override bool TryGetExport(IntPtr handle, string name, out IntPtr ptr)
	{
		byte[]? array = Unix.MarshalToUtf8(name);
		IntPtr intPtr;
		fixed (byte* lpProcName = array)
		{
			intPtr = (ptr = Windows.GetProcAddress(new Windows.HMODULE((void*)handle), (sbyte*)lpProcName));
		}
		Unix.FreeMarshalledArray(array);
		return intPtr != IntPtr.Zero;
	}

	protected override IEnumerable<string> GetLibrarySearchOrder(string name)
	{
		yield return name;
		if (!name.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) && !name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
		{
			yield return name + ".dll";
		}
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Runtime.InteropServices;
using MonoMod.Utils.Interop;

private abstract class LibdlBackend : BackendImpl
{
	[ThreadStatic]
	private static IntPtr lastDlErrorReturn;

	protected LibdlBackend()
	{
		Unix.DlError();
	}

	[DoesNotReturn]
	private static void ThrowError(IntPtr dlerr)
	{
		throw new Win32Exception(Marshal.PtrToStringAnsi(dlerr));
	}

	protected override void CheckAndThrowError()
	{
		IntPtr intPtr = lastDlErrorReturn;
		IntPtr intPtr2;
		if (intPtr == IntPtr.Zero)
		{
			intPtr2 = Unix.DlError();
		}
		else
		{
			intPtr2 = intPtr;
			lastDlErrorReturn = IntPtr.Zero;
		}
		if (intPtr2 != IntPtr.Zero)
		{
			ThrowError(intPtr2);
		}
	}

	protected override bool TryOpenLibraryCore(string? name, Assembly assembly, out IntPtr handle)
	{
		Unix.DlopenFlags flags = (Unix.DlopenFlags)258;
		return (handle = Unix.DlOpen(name, flags)) != IntPtr.Zero;
	}

	public override bool TryCloseLibrary(IntPtr handle)
	{
		return Unix.DlClose(handle);
	}

	public override bool TryGetExport(IntPtr handle, string name, out IntPtr ptr)
	{
		Unix.DlError();
		ptr = Unix.DlSym(handle, name);
		return (lastDlErrorReturn = Unix.DlError()) == IntPtr.Zero;
	}

	public override IntPtr GetExport(IntPtr handle, string name)
	{
		Unix.DlError();
		IntPtr result = Unix.DlSym(handle, name);
		IntPtr intPtr = Unix.DlError();
		if (intPtr != IntPtr.Zero)
		{
			ThrowError(intPtr);
		}
		return result;
	}
}


using System;
using System.Collections.Generic;

private sealed class LinuxOSXBackend : LibdlBackend
{
	private readonly bool isLinux;

	public LinuxOSXBackend(bool isLinux)
	{
		this.isLinux = isLinux;
	}

	protected override IEnumerable<string> GetLibrarySearchOrder(string name)
	{
		bool hasSlash = System.StringExtensions.Contains(name, '/', StringComparison.Ordinal);
		string suffix = ".dylib";
		if (isLinux)
		{
			if (name.EndsWith(".so", StringComparison.Ordinal) || System.StringExtensions.Contains(name, ".so.", StringComparison.Ordinal))
			{
				yield return name;
				if (!hasSlash)
				{
					yield return "lib" + name;
				}
				yield return name + ".so";
				if (!hasSlash)
				{
					yield return "lib" + name + ".so";
				}
				yield break;
			}
			suffix = ".so";
		}
		yield return name + suffix;
		if (!hasSlash)
		{
			yield return "lib" + name + suffix;
		}
		yield return name;
		if (!hasSlash)
		{
			yield return "lib" + name;
		}
		bool flag = isLinux;
		if (flag)
		{
			bool flag2 = ((name == "c" || name == "libc") ? true : false);
			flag = flag2;
		}
		if (!flag)
		{
			yield break;
		}
		foreach (string item in GetLibrarySearchOrder("c.so.6"))
		{
			yield return item;
		}
		foreach (string item2 in GetLibrarySearchOrder("glibc"))
		{
			yield return item2;
		}
		foreach (string item3 in GetLibrarySearchOrder("glibc.so.6"))
		{
			yield return item3;
		}
	}
}


private sealed class UnknownPosixBackend : LibdlBackend
{
}


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Collections.Generic;
using MonoMod;
using MonoMod.Logs;
using MonoMod.Utils;

internal static class Extensions
{
	private static readonly Type t_Code = typeof(Code);

	private static readonly Type t_OpCodes = typeof(Mono.Cecil.Cil.OpCodes);

	private static readonly Dictionary<int, Mono.Cecil.Cil.OpCode> _ToLongOp = new Dictionary<int, Mono.Cecil.Cil.OpCode>();

	private static readonly Dictionary<int, Mono.Cecil.Cil.OpCode> _ToShortOp = new Dictionary<int, Mono.Cecil.Cil.OpCode>();

	private static readonly Dictionary<Type, FieldInfo> fmap_mono_assembly = new Dictionary<Type, FieldInfo>();

	private static readonly bool _MonoAssemblyNameHasArch = new AssemblyName("Dummy, ProcessorArchitecture=MSIL").ProcessorArchitecture == ProcessorArchitecture.MSIL;

	private static readonly Type? _RTDynamicMethod = typeof(DynamicMethod).GetNestedType("RTDynamicMethod", BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly Type t_ParamArrayAttribute = typeof(ParamArrayAttribute);

	private static readonly FieldInfo f_GenericParameter_position = typeof(GenericParameter).GetField("position", BindingFlags.Instance | BindingFlags.NonPublic) ?? throw new InvalidOperationException("No field 'position' on GenericParameter");

	private static readonly FieldInfo f_GenericParameter_type = typeof(GenericParameter).GetField("type", BindingFlags.Instance | BindingFlags.NonPublic) ?? throw new InvalidOperationException("No field 'type' on GenericParameter");

	private static readonly ConcurrentDictionary<Type, int> _GetManagedSizeCache = new ConcurrentDictionary<Type, int>(new KeyValuePair<Type, int>[1]
	{
		new KeyValuePair<Type, int>(typeof(void), 0)
	});

	private static MethodInfo? _GetManagedSizeHelper;

	private static readonly Dictionary<MethodBase, Func<IntPtr>> _GetLdftnPointerCache = new Dictionary<MethodBase, Func<IntPtr>>();

	private static readonly Type? RTDynamicMethod = typeof(DynamicMethod).GetNestedType("RTDynamicMethod", BindingFlags.NonPublic);

	private static readonly FieldInfo? RTDynamicMethod_m_owner = RTDynamicMethod?.GetField("m_owner", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly Type? t_StateMachineAttribute = typeof(object).Assembly.GetType("System.Runtime.CompilerServices.StateMachineAttribute");

	private static readonly PropertyInfo? p_StateMachineType = t_StateMachineAttribute?.GetProperty("StateMachineType");

	public static TypeDefinition? SafeResolve(this TypeReference? r)
	{
		try
		{
			return r?.Resolve();
		}
		catch
		{
			return null;
		}
	}

	public static FieldDefinition? SafeResolve(this FieldReference? r)
	{
		try
		{
			return r?.Resolve();
		}
		catch
		{
			return null;
		}
	}

	public static MethodDefinition? SafeResolve(this MethodReference? r)
	{
		try
		{
			return r?.Resolve();
		}
		catch
		{
			return null;
		}
	}

	public static PropertyDefinition? SafeResolve(this PropertyReference? r)
	{
		try
		{
			return r?.Resolve();
		}
		catch
		{
			return null;
		}
	}

	public static CustomAttribute? GetCustomAttribute(this Mono.Cecil.ICustomAttributeProvider cap, string attribute)
	{
		if (cap == null || !cap.HasCustomAttributes)
		{
			return null;
		}
		foreach (CustomAttribute customAttribute in cap.CustomAttributes)
		{
			if (customAttribute.AttributeType.FullName == attribute)
			{
				return customAttribute;
			}
		}
		return null;
	}

	public static bool HasCustomAttribute(this Mono.Cecil.ICustomAttributeProvider cap, string attribute)
	{
		return cap.GetCustomAttribute(attribute) != null;
	}

	public static int GetInt(this Instruction instr)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		Mono.Cecil.Cil.OpCode opCode = instr.OpCode;
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_M1)
		{
			return -1;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_0)
		{
			return 0;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_1)
		{
			return 1;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_2)
		{
			return 2;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_3)
		{
			return 3;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_4)
		{
			return 4;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_5)
		{
			return 5;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_6)
		{
			return 6;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_7)
		{
			return 7;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_8)
		{
			return 8;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_S)
		{
			return (sbyte)instr.Operand;
		}
		return (int)instr.Operand;
	}

	public static int? GetIntOrNull(this Instruction instr)
	{
		Helpers.ThrowIfArgumentNull(instr, "instr");
		Mono.Cecil.Cil.OpCode opCode = instr.OpCode;
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_M1)
		{
			return -1;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_0)
		{
			return 0;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_1)
		{
			return 1;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_2)
		{
			return 2;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_3)
		{
			return 3;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_4)
		{
			return 4;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_5)
		{
			return 5;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_6)
		{
			return 6;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_7)
		{
			return 7;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_8)
		{
			return 8;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_S)
		{
			return (sbyte)instr.Operand;
		}
		if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4)
		{
			return (int)instr.Operand;
		}
		return null;
	}

	public static bool IsBaseMethodCall(this Mono.Cecil.Cil.MethodBody body, MethodReference? called)
	{
		Helpers.ThrowIfArgumentNull(body, "body");
		MethodDefinition method = body.Method;
		if (called == null)
		{
			return false;
		}
		TypeReference typeReference;
		for (typeReference = called.DeclaringType; typeReference is TypeSpecification typeSpecification; typeReference = typeSpecification.ElementType)
		{
		}
		string patchFullName = typeReference.GetPatchFullName();
		bool flag = false;
		try
		{
			TypeDefinition typeDefinition = method.DeclaringType;
			while ((typeDefinition = typeDefinition.BaseType?.SafeResolve()) != null)
			{
				if (typeDefinition.GetPatchFullName() == patchFullName)
				{
					flag = true;
					break;
				}
			}
		}
		catch
		{
			flag = method.DeclaringType.GetPatchFullName() == patchFullName;
		}
		if (!flag)
		{
			return false;
		}
		return true;
	}

	public static bool IsCallvirt(this MethodReference method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (!method.HasThis)
		{
			return false;
		}
		if (method.DeclaringType.IsValueType)
		{
			return false;
		}
		return true;
	}

	public static bool IsStruct(this TypeReference type)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		if (!type.IsValueType)
		{
			return false;
		}
		if (type.IsPrimitive)
		{
			return false;
		}
		return true;
	}

	public static Mono.Cecil.Cil.OpCode ToLongOp(this Mono.Cecil.Cil.OpCode op)
	{
		string name = Enum.GetName(t_Code, op.Code);
		if (name == null || !name.EndsWith("_S", StringComparison.Ordinal))
		{
			return op;
		}
		lock (_ToLongOp)
		{
			if (_ToLongOp.TryGetValue((int)op.Code, out var value))
			{
				return value;
			}
			return _ToLongOp[(int)op.Code] = ((Mono.Cecil.Cil.OpCode?)t_OpCodes.GetField(name.Substring(0, name.Length - 2))?.GetValue(null)) ?? op;
		}
	}

	public static Mono.Cecil.Cil.OpCode ToShortOp(this Mono.Cecil.Cil.OpCode op)
	{
		string name = Enum.GetName(t_Code, op.Code);
		if (name == null || name.EndsWith("_S", StringComparison.Ordinal))
		{
			return op;
		}
		lock (_ToShortOp)
		{
			if (_ToShortOp.TryGetValue((int)op.Code, out var value))
			{
				return value;
			}
			return _ToShortOp[(int)op.Code] = ((Mono.Cecil.Cil.OpCode?)t_OpCodes.GetField(name + "_S")?.GetValue(null)) ?? op;
		}
	}

	public static void RecalculateILOffsets(this MethodDefinition method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (method.HasBody)
		{
			int num = 0;
			for (int i = 0; i < method.Body.Instructions.Count; i++)
			{
				Instruction instruction = method.Body.Instructions[i];
				instruction.Offset = num;
				num += instruction.GetSize();
			}
		}
	}

	public static void FixShortLongOps(this MethodDefinition method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (!method.HasBody)
		{
			return;
		}
		for (int i = 0; i < method.Body.Instructions.Count; i++)
		{
			Instruction instruction = method.Body.Instructions[i];
			if (instruction.Operand is Instruction)
			{
				instruction.OpCode = instruction.OpCode.ToLongOp();
			}
		}
		method.RecalculateILOffsets();
		bool flag;
		do
		{
			flag = false;
			for (int j = 0; j < method.Body.Instructions.Count; j++)
			{
				Instruction instruction2 = method.Body.Instructions[j];
				if (instruction2.Operand is Instruction instruction3)
				{
					int num = instruction3.Offset - (instruction2.Offset + instruction2.GetSize());
					if (num == (sbyte)num)
					{
						Mono.Cecil.Cil.OpCode opCode = instruction2.OpCode;
						instruction2.OpCode = instruction2.OpCode.ToShortOp();
						flag = opCode != instruction2.OpCode;
					}
				}
			}
		}
		while (flag);
	}

	public static bool Is(this MemberInfo? minfo, MemberReference? mref)
	{
		return mref.Is(minfo);
	}

	public static bool Is(this MemberReference? mref, MemberInfo? minfo)
	{
		if (mref == null)
		{
			return false;
		}
		if ((object)minfo == null)
		{
			return false;
		}
		TypeReference typeReference = mref.DeclaringType;
		if (typeReference?.FullName == "<Module>")
		{
			typeReference = null;
		}
		if (mref is GenericParameter genericParameter)
		{
			if (!(minfo is Type type))
			{
				return false;
			}
			if (!type.IsGenericParameter)
			{
				if (genericParameter.Owner is IGenericInstance genericInstance)
				{
					return genericInstance.GenericArguments[genericParameter.Position].Is(type);
				}
				return false;
			}
			return genericParameter.Position == type.GenericParameterPosition;
		}
		if (minfo.DeclaringType != null)
		{
			if (typeReference == null)
			{
				return false;
			}
			Type type2 = minfo.DeclaringType;
			if (minfo is Type && type2.IsGenericType && !type2.IsGenericTypeDefinition)
			{
				type2 = type2.GetGenericTypeDefinition();
			}
			if (!typeReference.Is(type2))
			{
				return false;
			}
		}
		else if (typeReference != null)
		{
			return false;
		}
		if (!(mref is TypeSpecification) && mref.Name != minfo.Name)
		{
			return false;
		}
		if (mref is TypeReference typeReference2)
		{
			if (!(minfo is Type type3))
			{
				return false;
			}
			if (type3.IsGenericParameter)
			{
				return false;
			}
			if (mref is GenericInstanceType genericInstanceType)
			{
				if (!type3.IsGenericType)
				{
					return false;
				}
				Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
				Type[] genericArguments2 = type3.GetGenericArguments();
				if (genericArguments.Count != genericArguments2.Length)
				{
					return false;
				}
				for (int i = 0; i < genericArguments.Count; i++)
				{
					if (!genericArguments[i].Is(genericArguments2[i]))
					{
						return false;
					}
				}
				return genericInstanceType.ElementType.Is(type3.GetGenericTypeDefinition());
			}
			if (typeReference2.HasGenericParameters)
			{
				if (!type3.IsGenericType)
				{
					return false;
				}
				Collection<GenericParameter> genericParameters = typeReference2.GenericParameters;
				Type[] genericArguments3 = type3.GetGenericArguments();
				if (genericParameters.Count != genericArguments3.Length)
				{
					return false;
				}
				for (int j = 0; j < genericParameters.Count; j++)
				{
					if (!genericParameters[j].Is(genericArguments3[j]))
					{
						return false;
					}
				}
			}
			else if (type3.IsGenericType)
			{
				return false;
			}
			if (mref is ArrayType arrayType)
			{
				if (!type3.IsArray)
				{
					return false;
				}
				if (arrayType.Dimensions.Count == type3.GetArrayRank())
				{
					return arrayType.ElementType.Is(type3.GetElementType());
				}
				return false;
			}
			if (mref is ByReferenceType byReferenceType)
			{
				if (!type3.IsByRef)
				{
					return false;
				}
				return byReferenceType.ElementType.Is(type3.GetElementType());
			}
			if (mref is PointerType pointerType)
			{
				if (!type3.IsPointer)
				{
					return false;
				}
				return pointerType.ElementType.Is(type3.GetElementType());
			}
			if (mref is TypeSpecification typeSpecification)
			{
				return typeSpecification.ElementType.Is(type3.HasElementType ? type3.GetElementType() : type3);
			}
			if (typeReference != null)
			{
				return mref.Name == type3.Name;
			}
			string fullName = mref.FullName;
			string? fullName2 = type3.FullName;
			return fullName == ((fullName2 != null) ? System.StringExtensions.Replace(fullName2, "+", "/", StringComparison.Ordinal) : null);
		}
		if (minfo is Type)
		{
			return false;
		}
		MethodReference methodRef = mref as MethodReference;
		if (methodRef != null)
		{
			if (!(minfo is MethodBase methodBase))
			{
				return false;
			}
			Collection<ParameterDefinition> parameters = methodRef.Parameters;
			ParameterInfo[] parameters2 = methodBase.GetParameters();
			if (parameters.Count != parameters2.Length)
			{
				return false;
			}
			if (mref is GenericInstanceMethod genericInstanceMethod)
			{
				if (!methodBase.IsGenericMethod)
				{
					return false;
				}
				Collection<TypeReference> genericArguments4 = genericInstanceMethod.GenericArguments;
				Type[] genericArguments5 = methodBase.GetGenericArguments();
				if (genericArguments4.Count != genericArguments5.Length)
				{
					return false;
				}
				for (int k = 0; k < genericArguments4.Count; k++)
				{
					if (!genericArguments4[k].Is(genericArguments5[k]))
					{
						return false;
					}
				}
				return genericInstanceMethod.ElementMethod.Is((methodBase as MethodInfo)?.GetGenericMethodDefinition() ?? methodBase);
			}
			if (methodRef.HasGenericParameters)
			{
				if (!methodBase.IsGenericMethod)
				{
					return false;
				}
				Collection<GenericParameter> genericParameters2 = methodRef.GenericParameters;
				Type[] genericArguments6 = methodBase.GetGenericArguments();
				if (genericParameters2.Count != genericArguments6.Length)
				{
					return false;
				}
				for (int l = 0; l < genericParameters2.Count; l++)
				{
					if (!genericParameters2[l].Is(genericArguments6[l]))
					{
						return false;
					}
				}
			}
			else if (methodBase.IsGenericMethod)
			{
				return false;
			}
			Relinker relinker = null;
			relinker = (IMetadataTokenProvider paramMemberRef, IGenericParameterProvider? ctx) => (!(paramMemberRef is TypeReference paramTypeRef2)) ? paramMemberRef : ResolveParameter(paramTypeRef2);
			if (!methodRef.ReturnType.Relink(relinker, null).Is((methodBase as MethodInfo)?.ReturnType ?? typeof(void)) && !methodRef.ReturnType.Is((methodBase as MethodInfo)?.ReturnType ?? typeof(void)))
			{
				return false;
			}
			for (int m = 0; m < parameters.Count; m++)
			{
				if (!parameters[m].ParameterType.Relink(relinker, null).Is(parameters2[m].ParameterType) && !parameters[m].ParameterType.Is(parameters2[m].ParameterType))
				{
					return false;
				}
			}
			return true;
		}
		if (minfo is MethodInfo)
		{
			return false;
		}
		if (mref is FieldReference != minfo is FieldInfo)
		{
			return false;
		}
		if (mref is PropertyReference != minfo is PropertyInfo)
		{
			return false;
		}
		if (mref is EventReference != minfo is EventInfo)
		{
			return false;
		}
		return true;
		TypeReference ResolveParameter(TypeReference paramTypeRef)
		{
			if (paramTypeRef is GenericParameter genericParameter2)
			{
				if (genericParameter2.Owner is MethodReference && methodRef is GenericInstanceMethod genericInstanceMethod2)
				{
					return genericInstanceMethod2.GenericArguments[genericParameter2.Position];
				}
				if (genericParameter2.Owner is TypeReference typeReference3 && methodRef.DeclaringType is GenericInstanceType genericInstanceType2 && typeReference3.FullName == genericInstanceType2.ElementType.FullName)
				{
					return genericInstanceType2.GenericArguments[genericParameter2.Position];
				}
				return paramTypeRef;
			}
			if (paramTypeRef == methodRef.DeclaringType.GetElementType())
			{
				return methodRef.DeclaringType;
			}
			return paramTypeRef;
		}
	}

	public static IMetadataTokenProvider ImportReference(this ModuleDefinition mod, IMetadataTokenProvider mtp)
	{
		Helpers.ThrowIfArgumentNull(mod, "mod");
		if (mtp is TypeReference type)
		{
			return mod.ImportReference(type);
		}
		if (mtp is FieldReference field)
		{
			return mod.ImportReference(field);
		}
		if (mtp is MethodReference method)
		{
			return mod.ImportReference(method);
		}
		return mtp;
	}

	public static void AddRange<T>(this Collection<T> list, IEnumerable<T> other)
	{
		Helpers.ThrowIfArgumentNull(list, "list");
		foreach (T item in Helpers.ThrowIfNull(other, "other"))
		{
			list.Add(item);
		}
	}

	public static void AddRange(this IDictionary dict, IDictionary other)
	{
		Helpers.ThrowIfArgumentNull(dict, "dict");
		foreach (DictionaryEntry item in Helpers.ThrowIfNull(other, "other"))
		{
			dict.Add(item.Key, item.Value);
		}
	}

	public static void AddRange<TKey, TValue>(this IDictionary<TKey, TValue> dict, IDictionary<TKey, TValue> other)
	{
		Helpers.ThrowIfArgumentNull(dict, "dict");
		foreach (KeyValuePair<TKey, TValue> item in Helpers.ThrowIfNull(other, "other"))
		{
			dict.Add(item.Key, item.Value);
		}
	}

	public static void AddRange<TKey, TValue>(this Dictionary<TKey, TValue> dict, Dictionary<TKey, TValue> other) where TKey : notnull
	{
		Helpers.ThrowIfArgumentNull(dict, "dict");
		foreach (KeyValuePair<TKey, TValue> item in Helpers.ThrowIfNull(other, "other"))
		{
			dict.Add(item.Key, item.Value);
		}
	}

	public static void InsertRange<T>(this Collection<T> list, int index, IEnumerable<T> other)
	{
		Helpers.ThrowIfArgumentNull(list, "list");
		foreach (T item in Helpers.ThrowIfNull(other, "other"))
		{
			list.Insert(index++, item);
		}
	}

	public static bool IsCompatible(this Type type, Type other)
	{
		if (!Helpers.ThrowIfNull(type, "type")._IsCompatible(Helpers.ThrowIfNull(other, "other")))
		{
			return other._IsCompatible(type);
		}
		return true;
	}

	private static bool _IsCompatible(this Type type, Type other)
	{
		if (type == other)
		{
			return true;
		}
		if (other.IsEnum && type == typeof(Enum))
		{
			return false;
		}
		if (other.IsValueType && type == typeof(ValueType))
		{
			return false;
		}
		if (type.IsAssignableFrom(other))
		{
			return true;
		}
		if (other.IsEnum && type.IsCompatible(Enum.GetUnderlyingType(other)))
		{
			return true;
		}
		if ((other.IsPointer || other.IsByRef) && type == typeof(IntPtr))
		{
			return true;
		}
		if (type.IsPointer && other.IsPointer)
		{
			return true;
		}
		if (type.IsByRef && other.IsPointer)
		{
			return true;
		}
		return false;
	}

	public static T GetDeclaredMember<T>(this T member) where T : MemberInfo
	{
		Helpers.ThrowIfArgumentNull(member, "member");
		if (member.DeclaringType == member.ReflectedType)
		{
			return member;
		}
		if ((object)member.DeclaringType != null)
		{
			int metadataToken = member.MetadataToken;
			MemberInfo[] members = member.DeclaringType.GetMembers((BindingFlags)(-1));
			foreach (MemberInfo memberInfo in members)
			{
				if (memberInfo.MetadataToken == metadataToken)
				{
					return (T)memberInfo;
				}
			}
		}
		return member;
	}

	public unsafe static void SetMonoCorlibInternal(this Assembly asm, bool value)
	{
		if (PlatformDetection.Runtime != RuntimeKind.Mono)
		{
			return;
		}
		Helpers.ThrowIfArgumentNull(asm, "asm");
		Type type = asm.GetType();
		if (type == null)
		{
			return;
		}
		FieldInfo value2;
		lock (fmap_mono_assembly)
		{
			if (!fmap_mono_assembly.TryGetValue(type, out value2))
			{
				value2 = type.GetField("_mono_assembly", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) ?? type.GetField("dynamic_assembly", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) ?? throw new InvalidOperationException("Could not find assembly field for Mono");
				fmap_mono_assembly[type] = value2;
			}
		}
		if (value2 == null)
		{
			return;
		}
		AssemblyName name = asm.GetName();
		lock (ReflectionHelper.AssemblyCache)
		{
			WeakReference value3 = new WeakReference(asm);
			ReflectionHelper.AssemblyCache[asm.GetRuntimeHashedFullName()] = value3;
			ReflectionHelper.AssemblyCache[name.FullName] = value3;
			if (name.Name != null)
			{
				ReflectionHelper.AssemblyCache[name.Name] = value3;
			}
		}
		long num = 0L;
		object value4 = value2.GetValue(asm);
		if (!(value4 is IntPtr intPtr))
		{
			if (value4 is UIntPtr uIntPtr)
			{
				num = (long)(ulong)uIntPtr;
			}
		}
		else
		{
			num = (long)intPtr;
		}
		int num2 = IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + IntPtr.Size + 20 + 4 + 4 + 4 + (_MonoAssemblyNameHasArch ? ((!ReflectionHelper.IsCoreBCL) ? ((IntPtr.Size == 4) ? 12 : 16) : ((IntPtr.Size == 4) ? 20 : 24)) : (ReflectionHelper.IsCoreBCL ? 16 : 8)) + IntPtr.Size + IntPtr.Size + 1 + 1 + 1;
		byte* ptr = (byte*)(num + num2);
		*ptr = (value ? ((byte)1) : ((byte)0));
	}

	public static bool IsDynamicMethod(this MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (_RTDynamicMethod != null)
		{
			if (!(method is DynamicMethod))
			{
				return method.GetType() == _RTDynamicMethod;
			}
			return true;
		}
		if (method is DynamicMethod)
		{
			return true;
		}
		if (method.MetadataToken != 0 || !method.IsStatic || !method.IsPublic || (method.Attributes & System.Reflection.MethodAttributes.PrivateScope) != 0)
		{
			return false;
		}
		if ((object)method.DeclaringType != null)
		{
			MethodInfo[] methods = method.DeclaringType.GetMethods(BindingFlags.Static | BindingFlags.Public);
			foreach (MethodInfo methodInfo in methods)
			{
				if (method == methodInfo)
				{
					return false;
				}
			}
		}
		return true;
	}

	public static object? SafeGetTarget(this WeakReference weak)
	{
		Helpers.ThrowIfArgumentNull(weak, "weak");
		try
		{
			return weak.Target;
		}
		catch (InvalidOperationException)
		{
			return null;
		}
	}

	public static bool SafeGetIsAlive(this WeakReference weak)
	{
		Helpers.ThrowIfArgumentNull(weak, "weak");
		try
		{
			return weak.IsAlive;
		}
		catch (InvalidOperationException)
		{
			return false;
		}
	}

	public static T CreateDelegate<T>(this MethodBase method) where T : Delegate
	{
		return (T)method.CreateDelegate(typeof(T), null);
	}

	public static T CreateDelegate<T>(this MethodBase method, object? target) where T : Delegate
	{
		return (T)method.CreateDelegate(typeof(T), target);
	}

	public static Delegate CreateDelegate(this MethodBase method, Type delegateType)
	{
		return method.CreateDelegate(delegateType, null);
	}

	public static Delegate CreateDelegate(this MethodBase method, Type delegateType, object? target)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		Helpers.ThrowIfArgumentNull(delegateType, "delegateType");
		if (!typeof(Delegate).IsAssignableFrom(delegateType))
		{
			throw new ArgumentException("Type argument must be a delegate type!");
		}
		if (method is DynamicMethod dynamicMethod)
		{
			return dynamicMethod.CreateDelegate(delegateType, target);
		}
		if (method is MethodInfo method2)
		{
			return Delegate.CreateDelegate(delegateType, target, method2);
		}
		RuntimeMethodHandle methodHandle = method.MethodHandle;
		RuntimeHelpers.PrepareMethod(methodHandle);
		IntPtr functionPointer = methodHandle.GetFunctionPointer();
		return (Delegate)Activator.CreateInstance(delegateType, target, functionPointer);
	}

	public static T? TryCreateDelegate<T>(this MethodInfo? mi) where T : Delegate
	{
		try
		{
			return ((object)mi != null) ? CreateDelegate<T>(mi) : null;
		}
		catch
		{
			return null;
		}
	}

	public static MethodDefinition? FindMethod(this TypeDefinition type, string id, bool simple = true)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		Helpers.ThrowIfArgumentNull(id, "id");
		if (simple && !System.StringExtensions.Contains(id, ' ', StringComparison.Ordinal))
		{
			foreach (MethodDefinition method in type.Methods)
			{
				if (method.GetID(null, null, withType: true, simple: true) == id)
				{
					return method;
				}
			}
			foreach (MethodDefinition method2 in type.Methods)
			{
				if (method2.GetID(null, null, withType: false, simple: true) == id)
				{
					return method2;
				}
			}
		}
		foreach (MethodDefinition method3 in type.Methods)
		{
			if (method3.GetID() == id)
			{
				return method3;
			}
		}
		foreach (MethodDefinition method4 in type.Methods)
		{
			if (method4.GetID(null, null, withType: false) == id)
			{
				return method4;
			}
		}
		return null;
	}

	public static MethodDefinition? FindMethodDeep(this TypeDefinition type, string id, bool simple = true)
	{
		MethodDefinition? methodDefinition = Helpers.ThrowIfNull(type, "type").FindMethod(id, simple);
		if (methodDefinition == null)
		{
			TypeReference baseType = type.BaseType;
			if (baseType == null)
			{
				return null;
			}
			TypeDefinition typeDefinition = baseType.Resolve();
			if (typeDefinition == null)
			{
				return null;
			}
			methodDefinition = typeDefinition.FindMethodDeep(id, simple);
		}
		return methodDefinition;
	}

	public static MethodInfo? FindMethod(this Type type, string id, bool simple = true)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		Helpers.ThrowIfArgumentNull(id, "id");
		MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		MethodInfo[] array;
		if (simple && !System.StringExtensions.Contains(id, ' ', StringComparison.Ordinal))
		{
			array = methods;
			foreach (MethodInfo methodInfo in array)
			{
				if (methodInfo.GetID(null, null, withType: true, proxyMethod: false, simple: true) == id)
				{
					return methodInfo;
				}
			}
			array = methods;
			foreach (MethodInfo methodInfo2 in array)
			{
				if (methodInfo2.GetID(null, null, withType: false, proxyMethod: false, simple: true) == id)
				{
					return methodInfo2;
				}
			}
		}
		array = methods;
		foreach (MethodInfo methodInfo3 in array)
		{
			if (methodInfo3.GetID() == id)
			{
				return methodInfo3;
			}
		}
		array = methods;
		foreach (MethodInfo methodInfo4 in array)
		{
			if (methodInfo4.GetID(null, null, withType: false) == id)
			{
				return methodInfo4;
			}
		}
		return null;
	}

	public static MethodInfo? FindMethodDeep(this Type type, string id, bool simple = true)
	{
		MethodInfo? methodInfo = type.FindMethod(id, simple);
		if ((object)methodInfo == null)
		{
			Type? baseType = type.BaseType;
			if ((object)baseType == null)
			{
				return null;
			}
			methodInfo = baseType.FindMethodDeep(id, simple);
		}
		return methodInfo;
	}

	public static PropertyDefinition? FindProperty(this TypeDefinition type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		foreach (PropertyDefinition property in type.Properties)
		{
			if (property.Name == name)
			{
				return property;
			}
		}
		return null;
	}

	public static PropertyDefinition? FindPropertyDeep(this TypeDefinition type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		PropertyDefinition? propertyDefinition = type.FindProperty(name);
		if (propertyDefinition == null)
		{
			TypeReference baseType = type.BaseType;
			if (baseType == null)
			{
				return null;
			}
			TypeDefinition typeDefinition = baseType.Resolve();
			if (typeDefinition == null)
			{
				return null;
			}
			propertyDefinition = typeDefinition.FindPropertyDeep(name);
		}
		return propertyDefinition;
	}

	public static FieldDefinition? FindField(this TypeDefinition type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		foreach (FieldDefinition field in type.Fields)
		{
			if (field.Name == name)
			{
				return field;
			}
		}
		return null;
	}

	public static FieldDefinition? FindFieldDeep(this TypeDefinition type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		FieldDefinition? fieldDefinition = type.FindField(name);
		if (fieldDefinition == null)
		{
			TypeReference baseType = type.BaseType;
			if (baseType == null)
			{
				return null;
			}
			TypeDefinition typeDefinition = baseType.Resolve();
			if (typeDefinition == null)
			{
				return null;
			}
			fieldDefinition = typeDefinition.FindFieldDeep(name);
		}
		return fieldDefinition;
	}

	public static EventDefinition? FindEvent(this TypeDefinition type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		foreach (EventDefinition @event in type.Events)
		{
			if (@event.Name == name)
			{
				return @event;
			}
		}
		return null;
	}

	public static EventDefinition? FindEventDeep(this TypeDefinition type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		EventDefinition? eventDefinition = type.FindEvent(name);
		if (eventDefinition == null)
		{
			TypeReference baseType = type.BaseType;
			if (baseType == null)
			{
				return null;
			}
			TypeDefinition typeDefinition = baseType.Resolve();
			if (typeDefinition == null)
			{
				return null;
			}
			eventDefinition = typeDefinition.FindEventDeep(name);
		}
		return eventDefinition;
	}

	public static string GetID(this MethodReference method, string? name = null, string? type = null, bool withType = true, bool simple = false)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		StringBuilder stringBuilder = new StringBuilder();
		if (simple)
		{
			if (withType && (type != null || method.DeclaringType != null))
			{
				stringBuilder.Append(type ?? method.DeclaringType.GetPatchFullName()).Append("::");
			}
			stringBuilder.Append(name ?? method.Name);
			return stringBuilder.ToString();
		}
		stringBuilder.Append(method.ReturnType.GetPatchFullName()).Append(' ');
		if (withType && (type != null || method.DeclaringType != null))
		{
			stringBuilder.Append(type ?? method.DeclaringType.GetPatchFullName()).Append("::");
		}
		stringBuilder.Append(name ?? method.Name);
		if (method is GenericInstanceMethod genericInstanceMethod && genericInstanceMethod.GenericArguments.Count != 0)
		{
			stringBuilder.Append('<');
			Collection<TypeReference> genericArguments = genericInstanceMethod.GenericArguments;
			for (int i = 0; i < genericArguments.Count; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(',');
				}
				stringBuilder.Append(genericArguments[i].GetPatchFullName());
			}
			stringBuilder.Append('>');
		}
		else if (method.GenericParameters.Count != 0)
		{
			stringBuilder.Append('<');
			Collection<GenericParameter> genericParameters = method.GenericParameters;
			for (int j = 0; j < genericParameters.Count; j++)
			{
				if (j > 0)
				{
					stringBuilder.Append(',');
				}
				stringBuilder.Append(genericParameters[j].Name);
			}
			stringBuilder.Append('>');
		}
		stringBuilder.Append('(');
		if (method.HasParameters)
		{
			Collection<ParameterDefinition> parameters = method.Parameters;
			for (int k = 0; k < parameters.Count; k++)
			{
				ParameterDefinition parameterDefinition = parameters[k];
				if (k > 0)
				{
					stringBuilder.Append(',');
				}
				if (parameterDefinition.ParameterType.IsSentinel)
				{
					stringBuilder.Append("...,");
				}
				stringBuilder.Append(parameterDefinition.ParameterType.GetPatchFullName());
			}
		}
		stringBuilder.Append(')');
		return stringBuilder.ToString();
	}

	public static string GetID(this Mono.Cecil.CallSite method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(method.ReturnType.GetPatchFullName()).Append(' ');
		stringBuilder.Append('(');
		if (method.HasParameters)
		{
			Collection<ParameterDefinition> parameters = method.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				ParameterDefinition parameterDefinition = parameters[i];
				if (i > 0)
				{
					stringBuilder.Append(',');
				}
				if (parameterDefinition.ParameterType.IsSentinel)
				{
					stringBuilder.Append("...,");
				}
				stringBuilder.Append(parameterDefinition.ParameterType.GetPatchFullName());
			}
		}
		stringBuilder.Append(')');
		return stringBuilder.ToString();
	}

	public static string GetID(this MethodBase method, string? name = null, string? type = null, bool withType = true, bool proxyMethod = false, bool simple = false)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		while (method is MethodInfo methodInfo && method.IsGenericMethod && !method.IsGenericMethodDefinition)
		{
			method = methodInfo.GetGenericMethodDefinition();
		}
		StringBuilder stringBuilder = new StringBuilder();
		if (simple)
		{
			if (withType && (type != null || method.DeclaringType != null))
			{
				stringBuilder.Append(type ?? method.DeclaringType.FullName).Append("::");
			}
			stringBuilder.Append(name ?? method.Name);
			return stringBuilder.ToString();
		}
		stringBuilder.Append((method as MethodInfo)?.ReturnType?.FullName ?? "System.Void").Append(' ');
		if (withType && (type != null || method.DeclaringType != null))
		{
			object obj = type;
			if (obj == null)
			{
				string? fullName = method.DeclaringType.FullName;
				obj = ((fullName != null) ? System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal) : null);
			}
			stringBuilder.Append((string?)obj).Append("::");
		}
		stringBuilder.Append(name ?? method.Name);
		if (method.ContainsGenericParameters)
		{
			stringBuilder.Append('<');
			Type[] genericArguments = method.GetGenericArguments();
			for (int i = 0; i < genericArguments.Length; i++)
			{
				if (i > 0)
				{
					stringBuilder.Append(',');
				}
				stringBuilder.Append(genericArguments[i].Name);
			}
			stringBuilder.Append('>');
		}
		stringBuilder.Append('(');
		ParameterInfo[] parameters = method.GetParameters();
		for (int j = (proxyMethod ? 1 : 0); j < parameters.Length; j++)
		{
			ParameterInfo parameterInfo = parameters[j];
			if (j > (proxyMethod ? 1 : 0))
			{
				stringBuilder.Append(',');
			}
			bool flag;
			try
			{
				flag = parameterInfo.GetCustomAttributes(t_ParamArrayAttribute, inherit: false).Length != 0;
			}
			catch (NotSupportedException)
			{
				flag = false;
			}
			if (flag)
			{
				stringBuilder.Append("...,");
			}
			stringBuilder.Append(parameterInfo.ParameterType.FullName);
		}
		stringBuilder.Append(')');
		return stringBuilder.ToString();
	}

	public static string GetPatchName(this MemberReference mr)
	{
		Helpers.ThrowIfArgumentNull(mr, "mr");
		Mono.Cecil.ICustomAttributeProvider obj = mr as Mono.Cecil.ICustomAttributeProvider;
		return ((obj != null) ? obj.GetPatchName() : null) ?? mr.Name;
	}

	public static string GetPatchFullName(this MemberReference mr)
	{
		Helpers.ThrowIfArgumentNull(mr, "mr");
		Mono.Cecil.ICustomAttributeProvider obj = mr as Mono.Cecil.ICustomAttributeProvider;
		return ((obj != null) ? obj.GetPatchFullName(mr) : null) ?? mr.FullName;
	}

	private static string GetPatchName(this Mono.Cecil.ICustomAttributeProvider cap)
	{
		Helpers.ThrowIfArgumentNull(cap, "cap");
		CustomAttribute customAttribute = cap.GetCustomAttribute("MonoMod.MonoModPatch");
		string text;
		if (customAttribute != null)
		{
			text = (string)customAttribute.ConstructorArguments[0].Value;
			int num = text.LastIndexOf('.');
			if (num != -1 && num != text.Length - 1)
			{
				text = text.Substring(num + 1);
			}
			return text;
		}
		text = ((MemberReference)cap).Name;
		if (!text.StartsWith("patch_", StringComparison.Ordinal))
		{
			return text;
		}
		return text.Substring(6);
	}

	private static string GetPatchFullName(this Mono.Cecil.ICustomAttributeProvider cap, MemberReference mr)
	{
		Helpers.ThrowIfArgumentNull(cap, "cap");
		Helpers.ThrowIfArgumentNull(mr, "mr");
		if (cap is TypeReference typeReference)
		{
			CustomAttribute customAttribute = cap.GetCustomAttribute("MonoMod.MonoModPatch");
			string text;
			if (customAttribute != null)
			{
				text = (string)customAttribute.ConstructorArguments[0].Value;
			}
			else
			{
				text = ((MemberReference)cap).Name;
				text = (text.StartsWith("patch_", StringComparison.Ordinal) ? text.Substring(6) : text);
			}
			if (text.StartsWith("global::", StringComparison.Ordinal))
			{
				text = text.Substring(8);
			}
			else if (!System.StringExtensions.Contains(text, '.', StringComparison.Ordinal) && !System.StringExtensions.Contains(text, '/', StringComparison.Ordinal))
			{
				if (!string.IsNullOrEmpty(typeReference.Namespace))
				{
					text = typeReference.Namespace + "." + text;
				}
				else if (typeReference.IsNested)
				{
					text = typeReference.DeclaringType.GetPatchFullName() + "/" + text;
				}
			}
			if (mr is TypeSpecification typeSpecification)
			{
				List<TypeSpecification> list = new List<TypeSpecification>();
				TypeSpecification typeSpecification2 = typeSpecification;
				do
				{
					list.Add(typeSpecification2);
				}
				while ((typeSpecification2 = typeSpecification2.ElementType as TypeSpecification) != null);
				StringBuilder stringBuilder = new StringBuilder(text.Length + list.Count * 4);
				stringBuilder.Append(text);
				for (int num = list.Count - 1; num > -1; num--)
				{
					typeSpecification2 = list[num];
					if (typeSpecification2.IsByReference)
					{
						stringBuilder.Append('&');
					}
					else if (typeSpecification2.IsPointer)
					{
						stringBuilder.Append('*');
					}
					else if (!typeSpecification2.IsPinned && !typeSpecification2.IsSentinel)
					{
						if (typeSpecification2.IsArray)
						{
							ArrayType arrayType = (ArrayType)typeSpecification2;
							if (arrayType.IsVector)
							{
								stringBuilder.Append("[]");
							}
							else
							{
								stringBuilder.Append('[');
								for (int i = 0; i < arrayType.Dimensions.Count; i++)
								{
									if (i > 0)
									{
										stringBuilder.Append(',');
									}
									stringBuilder.Append(arrayType.Dimensions[i].ToString());
								}
								stringBuilder.Append(']');
							}
						}
						else if (typeSpecification2.IsRequiredModifier)
						{
							stringBuilder.Append("modreq(").Append(((RequiredModifierType)typeSpecification2).ModifierType).Append(')');
						}
						else if (typeSpecification2.IsOptionalModifier)
						{
							stringBuilder.Append("modopt(").Append(((OptionalModifierType)typeSpecification2).ModifierType).Append(')');
						}
						else if (typeSpecification2.IsGenericInstance)
						{
							GenericInstanceType genericInstanceType = (GenericInstanceType)typeSpecification2;
							stringBuilder.Append('<');
							for (int j = 0; j < genericInstanceType.GenericArguments.Count; j++)
							{
								if (j > 0)
								{
									stringBuilder.Append(',');
								}
								stringBuilder.Append(genericInstanceType.GenericArguments[j].GetPatchFullName());
							}
							stringBuilder.Append('>');
						}
						else
						{
							if (!typeSpecification2.IsFunctionPointer)
							{
								throw new NotSupportedException($"MonoMod can't handle TypeSpecification: {typeReference.FullName} ({typeReference.GetType()})");
							}
							FunctionPointerType functionPointerType = (FunctionPointerType)typeSpecification2;
							stringBuilder.Append(' ').Append(functionPointerType.ReturnType.GetPatchFullName()).Append(" *(");
							if (functionPointerType.HasParameters)
							{
								for (int k = 0; k < functionPointerType.Parameters.Count; k++)
								{
									ParameterDefinition parameterDefinition = functionPointerType.Parameters[k];
									if (k > 0)
									{
										stringBuilder.Append(',');
									}
									if (parameterDefinition.ParameterType.IsSentinel)
									{
										stringBuilder.Append("...,");
									}
									stringBuilder.Append(parameterDefinition.ParameterType.FullName);
								}
							}
							stringBuilder.Append(')');
						}
					}
				}
				text = stringBuilder.ToString();
			}
			return text;
		}
		if (cap is FieldReference fieldReference)
		{
			return $"{fieldReference.FieldType.GetPatchFullName()} {fieldReference.DeclaringType.GetPatchFullName()}::{cap.GetPatchName()}";
		}
		if (cap is MethodReference)
		{
			throw new InvalidOperationException("GetPatchFullName not supported on MethodReferences - use GetID instead");
		}
		throw new InvalidOperationException($"GetPatchFullName not supported on type {cap.GetType()}");
	}

	[return: NotNullIfNotNull("o")]
	public static MethodDefinition? Clone(this MethodDefinition? o, MethodDefinition? c = null)
	{
		if (o == null)
		{
			return null;
		}
		if (c == null)
		{
			c = new MethodDefinition(o.Name, o.Attributes, o.ReturnType);
		}
		c.Name = o.Name;
		c.Attributes = o.Attributes;
		c.ReturnType = o.ReturnType;
		c.DeclaringType = o.DeclaringType;
		c.MetadataToken = c.MetadataToken;
		c.Body = o.Body?.Clone(c);
		c.Attributes = o.Attributes;
		c.ImplAttributes = o.ImplAttributes;
		c.PInvokeInfo = o.PInvokeInfo;
		c.IsPreserveSig = o.IsPreserveSig;
		c.IsPInvokeImpl = o.IsPInvokeImpl;
		foreach (GenericParameter genericParameter in o.GenericParameters)
		{
			c.GenericParameters.Add(genericParameter.Clone());
		}
		foreach (ParameterDefinition parameter in o.Parameters)
		{
			c.Parameters.Add(parameter.Clone());
		}
		foreach (CustomAttribute customAttribute in o.CustomAttributes)
		{
			c.CustomAttributes.Add(customAttribute.Clone());
		}
		foreach (MethodReference @override in o.Overrides)
		{
			c.Overrides.Add(@override);
		}
		if (c.Body != null)
		{
			foreach (Instruction instruction in c.Body.Instructions)
			{
				int index;
				if (instruction.Operand is GenericParameter item && (index = o.GenericParameters.IndexOf(item)) != -1)
				{
					instruction.Operand = c.GenericParameters[index];
				}
				else if (instruction.Operand is ParameterDefinition item2 && (index = o.Parameters.IndexOf(item2)) != -1)
				{
					instruction.Operand = c.Parameters[index];
				}
			}
		}
		return c;
	}

	[return: NotNullIfNotNull("bo")]
	public static Mono.Cecil.Cil.MethodBody? Clone(this Mono.Cecil.Cil.MethodBody? bo, MethodDefinition m)
	{
		Helpers.ThrowIfArgumentNull(m, "m");
		if (bo == null)
		{
			return null;
		}
		Mono.Cecil.Cil.MethodBody bc = new Mono.Cecil.Cil.MethodBody(m);
		bc.MaxStackSize = bo.MaxStackSize;
		bc.InitLocals = bo.InitLocals;
		bc.LocalVarToken = bo.LocalVarToken;
		bc.Instructions.AddRange(bo.Instructions.Select(delegate(Instruction o)
		{
			Instruction instruction = Instruction.Create(Mono.Cecil.Cil.OpCodes.Nop);
			instruction.OpCode = o.OpCode;
			instruction.Operand = o.Operand;
			instruction.Offset = o.Offset;
			return instruction;
		}));
		foreach (Instruction instruction2 in bc.Instructions)
		{
			if (instruction2.Operand is Instruction item)
			{
				instruction2.Operand = bc.Instructions[bo.Instructions.IndexOf(item)];
			}
			else if (instruction2.Operand is Instruction[] source)
			{
				instruction2.Operand = source.Select((Instruction i) => bc.Instructions[bo.Instructions.IndexOf(i)]).ToArray();
			}
		}
		bc.ExceptionHandlers.AddRange(bo.ExceptionHandlers.Select((ExceptionHandler o) => new ExceptionHandler(o.HandlerType)
		{
			TryStart = ((o.TryStart == null) ? null : bc.Instructions[bo.Instructions.IndexOf(o.TryStart)]),
			TryEnd = ((o.TryEnd == null) ? null : bc.Instructions[bo.Instructions.IndexOf(o.TryEnd)]),
			FilterStart = ((o.FilterStart == null) ? null : bc.Instructions[bo.Instructions.IndexOf(o.FilterStart)]),
			HandlerStart = ((o.HandlerStart == null) ? null : bc.Instructions[bo.Instructions.IndexOf(o.HandlerStart)]),
			HandlerEnd = ((o.HandlerEnd == null) ? null : bc.Instructions[bo.Instructions.IndexOf(o.HandlerEnd)]),
			CatchType = o.CatchType
		}));
		bc.Variables.AddRange(bo.Variables.Select((VariableDefinition o) => new VariableDefinition(o.VariableType)));
		m.CustomDebugInformations.AddRange(bo.Method.CustomDebugInformations.Select(delegate(CustomDebugInformation o)
		{
			if (o is AsyncMethodBodyDebugInformation asyncMethodBodyDebugInformation)
			{
				AsyncMethodBodyDebugInformation asyncMethodBodyDebugInformation2 = new AsyncMethodBodyDebugInformation();
				if (asyncMethodBodyDebugInformation.CatchHandler.Offset >= 0)
				{
					asyncMethodBodyDebugInformation2.CatchHandler = (asyncMethodBodyDebugInformation.CatchHandler.IsEndOfMethod ? default(InstructionOffset) : new InstructionOffset(ResolveInstrOff(asyncMethodBodyDebugInformation.CatchHandler.Offset)));
				}
				asyncMethodBodyDebugInformation2.Yields.AddRange(asyncMethodBodyDebugInformation.Yields.Select((InstructionOffset off) => (!off.IsEndOfMethod) ? new InstructionOffset(ResolveInstrOff(off.Offset)) : default(InstructionOffset)));
				asyncMethodBodyDebugInformation2.Resumes.AddRange(asyncMethodBodyDebugInformation.Resumes.Select((InstructionOffset off) => (!off.IsEndOfMethod) ? new InstructionOffset(ResolveInstrOff(off.Offset)) : default(InstructionOffset)));
				asyncMethodBodyDebugInformation2.ResumeMethods.AddRange(asyncMethodBodyDebugInformation.ResumeMethods);
				return asyncMethodBodyDebugInformation2;
			}
			if (o is StateMachineScopeDebugInformation stateMachineScopeDebugInformation)
			{
				StateMachineScopeDebugInformation stateMachineScopeDebugInformation2 = new StateMachineScopeDebugInformation();
				stateMachineScopeDebugInformation2.Scopes.AddRange(stateMachineScopeDebugInformation.Scopes.Select((StateMachineScope s) => new StateMachineScope(ResolveInstrOff(s.Start.Offset), s.End.IsEndOfMethod ? null : ResolveInstrOff(s.End.Offset))));
				return stateMachineScopeDebugInformation2;
			}
			return o;
		}));
		m.DebugInformation.SequencePoints.AddRange(bo.Method.DebugInformation.SequencePoints.Select((SequencePoint o) => new SequencePoint(ResolveInstrOff(o.Offset), o.Document)
		{
			StartLine = o.StartLine,
			StartColumn = o.StartColumn,
			EndLine = o.EndLine,
			EndColumn = o.EndColumn
		}));
		return bc;
		Instruction ResolveInstrOff(int off)
		{
			for (int j = 0; j < bo.Instructions.Count; j++)
			{
				if (bo.Instructions[j].Offset == off)
				{
					return bc.Instructions[j];
				}
			}
			throw new ArgumentException($"Invalid instruction offset {off}");
		}
	}

	public static GenericParameter Update(this GenericParameter param, int position, GenericParameterType type)
	{
		f_GenericParameter_position.SetValue(param, position);
		f_GenericParameter_type.SetValue(param, type);
		return param;
	}

	public static GenericParameter? ResolveGenericParameter(this IGenericParameterProvider provider, GenericParameter orig)
	{
		Helpers.ThrowIfArgumentNull(provider, "provider");
		Helpers.ThrowIfArgumentNull(orig, "orig");
		if (provider is GenericParameter genericParameter && genericParameter.Name == orig.Name)
		{
			return genericParameter;
		}
		foreach (GenericParameter genericParameter2 in provider.GenericParameters)
		{
			if (genericParameter2.Name == orig.Name)
			{
				return genericParameter2;
			}
		}
		int position = orig.Position;
		if (provider is MethodReference && orig.DeclaringMethod != null)
		{
			if (position < provider.GenericParameters.Count)
			{
				return provider.GenericParameters[position];
			}
			return orig.Clone().Update(position, GenericParameterType.Method);
		}
		if (provider is TypeReference && orig.DeclaringType != null)
		{
			if (position < provider.GenericParameters.Count)
			{
				return provider.GenericParameters[position];
			}
			return orig.Clone().Update(position, GenericParameterType.Type);
		}
		object obj = (provider as TypeSpecification)?.ElementType.ResolveGenericParameter(orig);
		if (obj == null)
		{
			MemberReference obj2 = provider as MemberReference;
			if (obj2 == null)
			{
				return null;
			}
			TypeReference declaringType = obj2.DeclaringType;
			if (declaringType == null)
			{
				return null;
			}
			obj = declaringType.ResolveGenericParameter(orig);
		}
		return (GenericParameter?)obj;
	}

	[return: NotNullIfNotNull("mtp")]
	public static IMetadataTokenProvider? Relink(this IMetadataTokenProvider? mtp, Relinker relinker, IGenericParameterProvider context)
	{
		if (!(mtp is TypeReference type))
		{
			if (!(mtp is GenericParameterConstraint constraint))
			{
				if (!(mtp is MethodReference method))
				{
					if (!(mtp is FieldReference field))
					{
						if (!(mtp is ParameterDefinition param))
						{
							if (!(mtp is Mono.Cecil.CallSite method2))
							{
								if (mtp == null)
								{
									return null;
								}
								throw new InvalidOperationException($"MonoMod can't handle metadata token providers of the type {mtp.GetType()}");
							}
							return method2.Relink(relinker, context);
						}
						return param.Relink(relinker, context);
					}
					return field.Relink(relinker, context);
				}
				return method.Relink(relinker, context);
			}
			return constraint.Relink(relinker, context);
		}
		return type.Relink(relinker, context);
	}

	[return: NotNullIfNotNull("type")]
	public static TypeReference? Relink(this TypeReference? type, Relinker relinker, IGenericParameterProvider? context)
	{
		if (type == null)
		{
			return null;
		}
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		if (type is TypeSpecification typeSpecification)
		{
			TypeReference type2 = typeSpecification.ElementType.Relink(relinker, context);
			if (type.IsSentinel)
			{
				return new SentinelType(type2);
			}
			if (type.IsByReference)
			{
				return new ByReferenceType(type2);
			}
			if (type.IsPointer)
			{
				return new PointerType(type2);
			}
			if (type.IsPinned)
			{
				return new PinnedType(type2);
			}
			if (type.IsArray)
			{
				ArrayType arrayType = new ArrayType(type2, ((ArrayType)type).Rank);
				for (int i = 0; i < arrayType.Rank; i++)
				{
					arrayType.Dimensions[i] = ((ArrayType)type).Dimensions[i];
				}
				return arrayType;
			}
			if (type.IsRequiredModifier)
			{
				return new RequiredModifierType(((RequiredModifierType)type).ModifierType.Relink(relinker, context), type2);
			}
			if (type.IsOptionalModifier)
			{
				return new OptionalModifierType(((OptionalModifierType)type).ModifierType.Relink(relinker, context), type2);
			}
			if (type.IsGenericInstance)
			{
				GenericInstanceType genericInstanceType = new GenericInstanceType(type2);
				{
					foreach (TypeReference genericArgument in ((GenericInstanceType)type).GenericArguments)
					{
						genericInstanceType.GenericArguments.Add(genericArgument?.Relink(relinker, context));
					}
					return genericInstanceType;
				}
			}
			if (type.IsFunctionPointer)
			{
				FunctionPointerType functionPointerType = (FunctionPointerType)type;
				functionPointerType.ReturnType = functionPointerType.ReturnType.Relink(relinker, context);
				for (int j = 0; j < functionPointerType.Parameters.Count; j++)
				{
					functionPointerType.Parameters[j].ParameterType = functionPointerType.Parameters[j].ParameterType.Relink(relinker, context);
				}
				return functionPointerType;
			}
			throw new NotSupportedException($"MonoMod can't handle TypeSpecification: {type.FullName} ({type.GetType()})");
		}
		if (type.IsGenericParameter && context != null)
		{
			GenericParameter genericParameter = context.ResolveGenericParameter((GenericParameter)type) ?? throw new RelinkTargetNotFoundException($"{"MonoMod relinker failed finding"} {type.FullName} (context: {context})", type, context);
			for (int k = 0; k < genericParameter.Constraints.Count; k++)
			{
				if (!MultiTargetShims.GetConstraintType(genericParameter.Constraints[k]).IsGenericInstance)
				{
					genericParameter.Constraints[k] = genericParameter.Constraints[k].Relink(relinker, context);
				}
			}
			return genericParameter;
		}
		return (TypeReference)relinker(type, context);
	}

	[return: NotNullIfNotNull("constraint")]
	public static GenericParameterConstraint? Relink(this GenericParameterConstraint? constraint, Relinker relinker, IGenericParameterProvider context)
	{
		if (constraint == null)
		{
			return null;
		}
		GenericParameterConstraint genericParameterConstraint = new GenericParameterConstraint(constraint.ConstraintType.Relink(relinker, context));
		foreach (CustomAttribute customAttribute in constraint.CustomAttributes)
		{
			genericParameterConstraint.CustomAttributes.Add(customAttribute.Relink(relinker, context));
		}
		return genericParameterConstraint;
	}

	public static IMetadataTokenProvider Relink(this MethodReference method, Relinker relinker, IGenericParameterProvider context)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		if (method.IsGenericInstance)
		{
			GenericInstanceMethod obj = (GenericInstanceMethod)method;
			GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod((MethodReference)obj.ElementMethod.Relink(relinker, context));
			foreach (TypeReference genericArgument in obj.GenericArguments)
			{
				genericInstanceMethod.GenericArguments.Add(genericArgument.Relink(relinker, context));
			}
			return (MethodReference)relinker(genericInstanceMethod, context);
		}
		MethodReference methodReference = new MethodReference(method.Name, method.ReturnType, method.DeclaringType.Relink(relinker, context));
		methodReference.CallingConvention = method.CallingConvention;
		methodReference.ExplicitThis = method.ExplicitThis;
		methodReference.HasThis = method.HasThis;
		foreach (GenericParameter genericParameter in method.GenericParameters)
		{
			methodReference.GenericParameters.Add(genericParameter.Relink(relinker, context));
		}
		methodReference.ReturnType = methodReference.ReturnType?.Relink(relinker, methodReference);
		foreach (ParameterDefinition parameter in method.Parameters)
		{
			parameter.ParameterType = parameter.ParameterType.Relink(relinker, method);
			methodReference.Parameters.Add(parameter);
		}
		return (MethodReference)relinker(methodReference, context);
	}

	public static Mono.Cecil.CallSite Relink(this Mono.Cecil.CallSite method, Relinker relinker, IGenericParameterProvider context)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		Mono.Cecil.CallSite callSite = new Mono.Cecil.CallSite(method.ReturnType);
		callSite.CallingConvention = method.CallingConvention;
		callSite.ExplicitThis = method.ExplicitThis;
		callSite.HasThis = method.HasThis;
		callSite.ReturnType = callSite.ReturnType?.Relink(relinker, context);
		foreach (ParameterDefinition parameter in method.Parameters)
		{
			parameter.ParameterType = parameter.ParameterType.Relink(relinker, context);
			callSite.Parameters.Add(parameter);
		}
		return (Mono.Cecil.CallSite)relinker(callSite, context);
	}

	public static IMetadataTokenProvider Relink(this FieldReference field, Relinker relinker, IGenericParameterProvider context)
	{
		Helpers.ThrowIfArgumentNull(field, "field");
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		TypeReference typeReference = field.DeclaringType.Relink(relinker, context);
		return relinker(new FieldReference(field.Name, field.FieldType.Relink(relinker, typeReference), typeReference), context);
	}

	public static ParameterDefinition Relink(this ParameterDefinition param, Relinker relinker, IGenericParameterProvider context)
	{
		Helpers.ThrowIfArgumentNull(param, "param");
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		param = (param.Method as MethodReference)?.Parameters[param.Index] ?? param;
		ParameterDefinition parameterDefinition = new ParameterDefinition(param.Name, param.Attributes, param.ParameterType.Relink(relinker, context))
		{
			IsIn = param.IsIn,
			IsLcid = param.IsLcid,
			IsOptional = param.IsOptional,
			IsOut = param.IsOut,
			IsReturnValue = param.IsReturnValue,
			MarshalInfo = param.MarshalInfo
		};
		if (param.HasConstant)
		{
			parameterDefinition.Constant = param.Constant;
		}
		return parameterDefinition;
	}

	public static ParameterDefinition Clone(this ParameterDefinition param)
	{
		Helpers.ThrowIfArgumentNull(param, "param");
		ParameterDefinition parameterDefinition = new ParameterDefinition(param.Name, param.Attributes, param.ParameterType)
		{
			IsIn = param.IsIn,
			IsLcid = param.IsLcid,
			IsOptional = param.IsOptional,
			IsOut = param.IsOut,
			IsReturnValue = param.IsReturnValue,
			MarshalInfo = param.MarshalInfo
		};
		if (param.HasConstant)
		{
			parameterDefinition.Constant = param.Constant;
		}
		foreach (CustomAttribute customAttribute in param.CustomAttributes)
		{
			parameterDefinition.CustomAttributes.Add(customAttribute.Clone());
		}
		return parameterDefinition;
	}

	public static CustomAttribute Relink(this CustomAttribute attrib, Relinker relinker, IGenericParameterProvider context)
	{
		Helpers.ThrowIfArgumentNull(attrib, "attrib");
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		CustomAttribute customAttribute = new CustomAttribute((MethodReference)attrib.Constructor.Relink(relinker, context));
		foreach (CustomAttributeArgument constructorArgument in attrib.ConstructorArguments)
		{
			customAttribute.ConstructorArguments.Add(new CustomAttributeArgument(constructorArgument.Type.Relink(relinker, context), constructorArgument.Value));
		}
		foreach (Mono.Cecil.CustomAttributeNamedArgument field in attrib.Fields)
		{
			customAttribute.Fields.Add(new Mono.Cecil.CustomAttributeNamedArgument(field.Name, new CustomAttributeArgument(field.Argument.Type.Relink(relinker, context), field.Argument.Value)));
		}
		foreach (Mono.Cecil.CustomAttributeNamedArgument property in attrib.Properties)
		{
			customAttribute.Properties.Add(new Mono.Cecil.CustomAttributeNamedArgument(property.Name, new CustomAttributeArgument(property.Argument.Type.Relink(relinker, context), property.Argument.Value)));
		}
		return customAttribute;
	}

	public static CustomAttribute Clone(this CustomAttribute attrib)
	{
		Helpers.ThrowIfArgumentNull(attrib, "attrib");
		CustomAttribute customAttribute = new CustomAttribute(attrib.Constructor);
		foreach (CustomAttributeArgument constructorArgument in attrib.ConstructorArguments)
		{
			customAttribute.ConstructorArguments.Add(new CustomAttributeArgument(constructorArgument.Type, constructorArgument.Value));
		}
		foreach (Mono.Cecil.CustomAttributeNamedArgument field in attrib.Fields)
		{
			customAttribute.Fields.Add(new Mono.Cecil.CustomAttributeNamedArgument(field.Name, new CustomAttributeArgument(field.Argument.Type, field.Argument.Value)));
		}
		foreach (Mono.Cecil.CustomAttributeNamedArgument property in attrib.Properties)
		{
			customAttribute.Properties.Add(new Mono.Cecil.CustomAttributeNamedArgument(property.Name, new CustomAttributeArgument(property.Argument.Type, property.Argument.Value)));
		}
		return customAttribute;
	}

	public static GenericParameter Relink(this GenericParameter param, Relinker relinker, IGenericParameterProvider context)
	{
		Helpers.ThrowIfArgumentNull(param, "param");
		Helpers.ThrowIfArgumentNull(relinker, "relinker");
		GenericParameter genericParameter = new GenericParameter(param.Name, param.Owner)
		{
			Attributes = param.Attributes
		}.Update(param.Position, param.Type);
		foreach (CustomAttribute customAttribute in param.CustomAttributes)
		{
			genericParameter.CustomAttributes.Add(customAttribute.Relink(relinker, context));
		}
		foreach (GenericParameterConstraint constraint in param.Constraints)
		{
			genericParameter.Constraints.Add(constraint.Relink(relinker, context));
		}
		return genericParameter;
	}

	public static GenericParameter Clone(this GenericParameter param)
	{
		Helpers.ThrowIfArgumentNull(param, "param");
		GenericParameter genericParameter = new GenericParameter(param.Name, param.Owner)
		{
			Attributes = param.Attributes
		}.Update(param.Position, param.Type);
		foreach (CustomAttribute customAttribute in param.CustomAttributes)
		{
			genericParameter.CustomAttributes.Add(customAttribute.Clone());
		}
		foreach (GenericParameterConstraint constraint in param.Constraints)
		{
			genericParameter.Constraints.Add(constraint);
		}
		return genericParameter;
	}

	public static int GetManagedSize(this Type t)
	{
		return _GetManagedSizeCache.GetOrAdd(Helpers.ThrowIfNull(t, "t"), ComputeManagedSize);
	}

	private static int ComputeManagedSize(Type t)
	{
		MethodInfo methodInfo = _GetManagedSizeHelper;
		if ((object)methodInfo == null)
		{
			methodInfo = (_GetManagedSizeHelper = typeof(Unsafe).GetMethod("SizeOf"));
		}
		return CreateDelegate<Func<int>>(methodInfo.MakeGenericMethod(t))();
	}

	public static Type GetThisParamType(this MethodBase method)
	{
		Type type = Helpers.ThrowIfNull(method, "method").DeclaringType;
		if (type.IsValueType)
		{
			type = type.MakeByRefType();
		}
		return type;
	}

	public static IntPtr GetLdftnPointer(this MethodBase m)
	{
		Helpers.ThrowIfArgumentNull(m, "m");
		if (_GetLdftnPointerCache.TryGetValue(m, out Func<IntPtr> value))
		{
			return value();
		}
		FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(17, 1);
		handler.AppendLiteral("GetLdftnPointer<");
		handler.AppendFormatted(m);
		handler.AppendLiteral(">");
		using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(DebugFormatter.Format(ref handler), typeof(IntPtr), Type.EmptyTypes);
		ILProcessor iLProcessor = dynamicMethodDefinition.GetILProcessor();
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldftn, dynamicMethodDefinition.Definition.Module.ImportReference(m));
		iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
		lock (_GetLdftnPointerCache)
		{
			Func<IntPtr> func2 = (_GetLdftnPointerCache[m] = CreateDelegate<Func<IntPtr>>(dynamicMethodDefinition.Generate()));
			return func2();
		}
	}

	public static string ToHexadecimalString(this byte[] data)
	{
		return System.StringExtensions.Replace(BitConverter.ToString(data), "-", string.Empty, StringComparison.Ordinal);
	}

	public static T? InvokePassing<T>(this MulticastDelegate md, T val, params object?[] args)
	{
		if ((object)md == null)
		{
			return val;
		}
		Helpers.ThrowIfArgumentNull(args, "args");
		object[] array = new object[args.Length + 1];
		array[0] = val;
		Array.Copy(args, 0, array, 1, args.Length);
		Delegate[] invocationList = md.GetInvocationList();
		for (int i = 0; i < invocationList.Length; i++)
		{
			array[0] = invocationList[i].DynamicInvoke(array);
		}
		return (T)array[0];
	}

	public static bool InvokeWhileTrue(this MulticastDelegate md, params object[] args)
	{
		if ((object)md == null)
		{
			return true;
		}
		Helpers.ThrowIfArgumentNull(args, "args");
		Delegate[] invocationList = md.GetInvocationList();
		for (int i = 0; i < invocationList.Length; i++)
		{
			if (!(bool)invocationList[i].DynamicInvoke(args))
			{
				return false;
			}
		}
		return true;
	}

	public static bool InvokeWhileFalse(this MulticastDelegate md, params object[] args)
	{
		if ((object)md == null)
		{
			return false;
		}
		Helpers.ThrowIfArgumentNull(args, "args");
		Delegate[] invocationList = md.GetInvocationList();
		for (int i = 0; i < invocationList.Length; i++)
		{
			if ((bool)invocationList[i].DynamicInvoke(args))
			{
				return true;
			}
		}
		return false;
	}

	public static T? InvokeWhileNull<T>(this MulticastDelegate? md, params object[] args) where T : class
	{
		if ((object)md == null)
		{
			return null;
		}
		Helpers.ThrowIfArgumentNull(args, "args");
		Delegate[] invocationList = md.GetInvocationList();
		for (int i = 0; i < invocationList.Length; i++)
		{
			T val = (T)invocationList[i].DynamicInvoke(args);
			if (val != null)
			{
				return val;
			}
		}
		return null;
	}

	public static string SpacedPascalCase(this string input)
	{
		Helpers.ThrowIfArgumentNull(input, "input");
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < input.Length; i++)
		{
			char c = input[i];
			if (i > 0 && char.IsUpper(c))
			{
				stringBuilder.Append(' ');
			}
			stringBuilder.Append(c);
		}
		return stringBuilder.ToString();
	}

	public static string ReadNullTerminatedString(this BinaryReader stream)
	{
		Helpers.ThrowIfArgumentNull(stream, "stream");
		string text = "";
		char c;
		while ((c = stream.ReadChar()) != 0)
		{
			text += c;
		}
		return text;
	}

	public static void WriteNullTerminatedString(this BinaryWriter stream, string text)
	{
		Helpers.ThrowIfArgumentNull(stream, "stream");
		Helpers.ThrowIfArgumentNull(text, "text");
		if (text != null)
		{
			foreach (char ch in text)
			{
				stream.Write(ch);
			}
		}
		stream.Write('\0');
	}

	private static MethodBase GetRealMethod(MethodBase method)
	{
		if ((object)RTDynamicMethod_m_owner != null && method.GetType() == RTDynamicMethod)
		{
			return (MethodBase)RTDynamicMethod_m_owner.GetValue(method);
		}
		return method;
	}

	public static T CastDelegate<T>(this Delegate source) where T : Delegate
	{
		return (T)Helpers.ThrowIfNull(source, "source").CastDelegate(typeof(T));
	}

	[return: NotNullIfNotNull("source")]
	public static Delegate? CastDelegate(this Delegate? source, Type type)
	{
		if ((object)source == null)
		{
			return null;
		}
		Helpers.ThrowIfArgumentNull(type, "type");
		if (type.IsAssignableFrom(source.GetType()))
		{
			return source;
		}
		Delegate[] invocationList = source.GetInvocationList();
		if (invocationList.Length == 1)
		{
			return GetRealMethod(invocationList[0].Method).CreateDelegate(type, invocationList[0].Target);
		}
		Delegate[] array = new Delegate[invocationList.Length];
		for (int i = 0; i < invocationList.Length; i++)
		{
			array[i] = GetRealMethod(invocationList[i].Method).CreateDelegate(type, invocationList[i].Target);
		}
		return Delegate.Combine(array);
	}

	public static bool TryCastDelegate<T>(this Delegate source, [MaybeNullWhen(false)] out T result) where T : Delegate
	{
		if ((object)source == null)
		{
			result = null;
			return false;
		}
		if (source is T val)
		{
			result = val;
			return true;
		}
		Delegate result2;
		bool result3 = source.TryCastDelegate(typeof(T), out result2);
		result = (T)result2;
		return result3;
	}

	public static bool TryCastDelegate(this Delegate source, Type type, [MaybeNullWhen(false)] out Delegate? result)
	{
		result = null;
		if ((object)source == null)
		{
			return false;
		}
		try
		{
			result = source.CastDelegate(type);
			return true;
		}
		catch (Exception value)
		{
			bool isEnabled;
			MMDbgLog.DebugLogWarningStringHandler message = new MMDbgLog.DebugLogWarningStringHandler(43, 3, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("Exception thrown in TryCastDelegate(");
				message.AppendFormatted(source.GetType());
				message.AppendLiteral(" -> ");
				message.AppendFormatted(type);
				message.AppendLiteral("): ");
				message.AppendFormatted(value);
			}
			MMDbgLog.Warning(ref message);
			return false;
		}
	}

	public static MethodInfo? GetStateMachineTarget(this MethodInfo method)
	{
		if ((object)p_StateMachineType == null || (object)t_StateMachineAttribute == null)
		{
			return null;
		}
		Helpers.ThrowIfArgumentNull(method, "method");
		object[] customAttributes = method.GetCustomAttributes(inherit: false);
		for (int i = 0; i < customAttributes.Length; i++)
		{
			Attribute attribute = (Attribute)customAttributes[i];
			if (t_StateMachineAttribute.IsCompatible(attribute.GetType()))
			{
				return (p_StateMachineType.GetValue(attribute, null) as Type)?.GetMethod("MoveNext", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			}
		}
		return null;
	}

	public static MethodBase GetActualGenericMethodDefinition(this MethodInfo method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		return (method.IsGenericMethod ? method.GetGenericMethodDefinition() : method).GetUnfilledMethodOnGenericType();
	}

	public static MethodBase GetUnfilledMethodOnGenericType(this MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (method.DeclaringType != null && method.DeclaringType.IsGenericType)
		{
			Type genericTypeDefinition = method.DeclaringType.GetGenericTypeDefinition();
			method = MethodBase.GetMethodFromHandle(method.MethodHandle, genericTypeDefinition.TypeHandle);
		}
		return method;
	}

	public static bool Is(this MemberReference member, string fullName)
	{
		Helpers.ThrowIfArgumentNull(fullName, "fullName");
		if (member == null)
		{
			return false;
		}
		return System.StringExtensions.Replace(member.FullName, "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal);
	}

	public static bool Is(this MemberReference member, string typeFullName, string name)
	{
		Helpers.ThrowIfArgumentNull(typeFullName, "typeFullName");
		Helpers.ThrowIfArgumentNull(name, "name");
		if (member == null)
		{
			return false;
		}
		if (System.StringExtensions.Replace(member.DeclaringType.FullName, "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(typeFullName, "+", "/", StringComparison.Ordinal))
		{
			return member.Name == name;
		}
		return false;
	}

	public static bool Is(this MemberReference member, Type type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		Helpers.ThrowIfArgumentNull(name, "name");
		if (member == null)
		{
			return false;
		}
		string text = System.StringExtensions.Replace(member.DeclaringType.FullName, "+", "/", StringComparison.Ordinal);
		string? fullName = type.FullName;
		if (text == ((fullName != null) ? System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal) : null))
		{
			return member.Name == name;
		}
		return false;
	}

	public static bool Is(this MethodReference method, string fullName)
	{
		Helpers.ThrowIfArgumentNull(fullName, "fullName");
		if (method == null)
		{
			return false;
		}
		if (System.StringExtensions.Contains(fullName, ' ', StringComparison.Ordinal))
		{
			if (System.StringExtensions.Replace(method.GetID(null, null, withType: true, simple: true), "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal))
			{
				return true;
			}
			if (System.StringExtensions.Replace(method.GetID(), "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal))
			{
				return true;
			}
		}
		return System.StringExtensions.Replace(method.FullName, "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal);
	}

	public static bool Is(this MethodReference method, string typeFullName, string name)
	{
		Helpers.ThrowIfArgumentNull(typeFullName, "typeFullName");
		Helpers.ThrowIfArgumentNull(name, "name");
		if (method == null)
		{
			return false;
		}
		if (System.StringExtensions.Contains(name, ' ', StringComparison.Ordinal) && System.StringExtensions.Replace(method.DeclaringType.FullName, "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(typeFullName, "+", "/", StringComparison.Ordinal) && System.StringExtensions.Replace(method.GetID(null, null, withType: false), "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(name, "+", "/", StringComparison.Ordinal))
		{
			return true;
		}
		if (System.StringExtensions.Replace(method.DeclaringType.FullName, "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(typeFullName, "+", "/", StringComparison.Ordinal))
		{
			return method.Name == name;
		}
		return false;
	}

	public static bool Is(this MethodReference method, Type type, string name)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		Helpers.ThrowIfArgumentNull(name, "name");
		if (method == null)
		{
			return false;
		}
		if (System.StringExtensions.Contains(name, ' ', StringComparison.Ordinal))
		{
			string text = System.StringExtensions.Replace(method.DeclaringType.FullName, "+", "/", StringComparison.Ordinal);
			string? fullName = type.FullName;
			if (text == ((fullName != null) ? System.StringExtensions.Replace(fullName, "+", "/", StringComparison.Ordinal) : null) && System.StringExtensions.Replace(method.GetID(null, null, withType: false), "+", "/", StringComparison.Ordinal) == System.StringExtensions.Replace(name, "+", "/", StringComparison.Ordinal))
			{
				return true;
			}
		}
		string text2 = System.StringExtensions.Replace(method.DeclaringType.FullName, "+", "/", StringComparison.Ordinal);
		string? fullName2 = type.FullName;
		if (text2 == ((fullName2 != null) ? System.StringExtensions.Replace(fullName2, "+", "/", StringComparison.Ordinal) : null))
		{
			return method.Name == name;
		}
		return false;
	}

	public static void ReplaceOperands(this ILProcessor il, object? from, object? to)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		foreach (Instruction instruction in il.Body.Instructions)
		{
			if (instruction.Operand?.Equals(from) ?? (from == null))
			{
				instruction.Operand = to;
			}
		}
	}

	public static FieldReference Import(this ILProcessor il, FieldInfo field)
	{
		return Helpers.ThrowIfNull(il, "il").Body.Method.Module.ImportReference(field);
	}

	public static MethodReference Import(this ILProcessor il, MethodBase method)
	{
		return Helpers.ThrowIfNull(il, "il").Body.Method.Module.ImportReference(method);
	}

	public static TypeReference Import(this ILProcessor il, Type type)
	{
		return Helpers.ThrowIfNull(il, "il").Body.Method.Module.ImportReference(type);
	}

	public static MemberReference Import(this ILProcessor il, MemberInfo member)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		Helpers.ThrowIfArgumentNull(member, "member");
		if (!(member is FieldInfo field))
		{
			if (!(member is MethodBase method))
			{
				if (member is Type type)
				{
					return il.Import(type);
				}
				throw new NotSupportedException("Unsupported member type " + member.GetType().FullName);
			}
			return il.Import(method);
		}
		return il.Import(field);
	}

	public static Instruction Create(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, FieldInfo field)
	{
		return Helpers.ThrowIfNull(il, "il").Create(opcode, il.Import(field));
	}

	public static Instruction Create(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		if (method is DynamicMethod)
		{
			return il.Create(opcode, (object)method);
		}
		return il.Create(opcode, il.Import(method));
	}

	public static Instruction Create(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, Type type)
	{
		return Helpers.ThrowIfNull(il, "il").Create(opcode, il.Import(type));
	}

	public static Instruction Create(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, object operand)
	{
		Instruction instruction = Helpers.ThrowIfNull(il, "il").Create(Mono.Cecil.Cil.OpCodes.Nop);
		instruction.OpCode = opcode;
		instruction.Operand = operand;
		return instruction;
	}

	public static Instruction Create(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, MemberInfo member)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		Helpers.ThrowIfArgumentNull(member, "member");
		if (!(member is FieldInfo field))
		{
			if (!(member is MethodBase method))
			{
				if (member is Type type)
				{
					return il.Create(opcode, type);
				}
				throw new NotSupportedException("Unsupported member type " + member.GetType().FullName);
			}
			return il.Create(opcode, method);
		}
		return il.Create(opcode, field);
	}

	public static void Emit(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, FieldInfo field)
	{
		Helpers.ThrowIfNull(il, "il").Emit(opcode, il.Import(field));
	}

	public static void Emit(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, MethodBase method)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		Helpers.ThrowIfArgumentNull(method, "method");
		if (method is DynamicMethod)
		{
			il.Emit(opcode, (object)method);
		}
		else
		{
			il.Emit(opcode, il.Import(method));
		}
	}

	public static void Emit(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, Type type)
	{
		Helpers.ThrowIfNull(il, "il").Emit(opcode, il.Import(type));
	}

	public static void Emit(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, MemberInfo member)
	{
		Helpers.ThrowIfArgumentNull(il, "il");
		Helpers.ThrowIfArgumentNull(member, "member");
		if (!(member is FieldInfo field))
		{
			if (!(member is MethodBase method))
			{
				if (!(member is Type type))
				{
					throw new NotSupportedException("Unsupported member type " + member.GetType().FullName);
				}
				il.Emit(opcode, type);
			}
			else
			{
				il.Emit(opcode, method);
			}
		}
		else
		{
			il.Emit(opcode, field);
		}
	}

	public static void Emit(this ILProcessor il, Mono.Cecil.Cil.OpCode opcode, object operand)
	{
		Helpers.ThrowIfNull(il, "il").Append(il.Create(opcode, operand));
	}
}


using Mono.Cecil;

internal delegate IMetadataTokenProvider Relinker(IMetadataTokenProvider mtp, IGenericParameterProvider? context);


internal sealed class WeakBox
{
	public object? Value;
}


using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using Mono.Cecil.Cil;
using MonoMod.Cil;
using MonoMod.Logs;
using MonoMod.Utils;

internal static class FastReflectionHelper
{
	public delegate object? FastInvoker(object? target, params object?[]? args);

	public delegate void FastStructInvoker(object? target, object? result, params object?[]? args);

	private static class TypedCache<T> where T : struct
	{
		[ThreadStatic]
		public static StrongBox<T?>? NullableStrongBox;
	}

	private enum ReturnTypeClass
	{
		Void,
		ValueType,
		Nullable,
		ReferenceType
	}

	private sealed class FSITuple
	{
		public readonly FastStructInvoker FSI;

		public readonly ReturnTypeClass RTC;

		public readonly Type ReturnType;

		public FSITuple(FastStructInvoker fsi, ReturnTypeClass rtc, Type rt)
		{
			FSI = fsi;
			RTC = rtc;
			ReturnType = rt;
		}
	}

	private static readonly Type[] FastStructInvokerArgs = new Type[3]
	{
		typeof(object),
		typeof(object),
		typeof(object[])
	};

	private static readonly MethodInfo S2FValueType = typeof(FastReflectionHelper).GetMethod("FastInvokerForStructInvokerVT", BindingFlags.Static | BindingFlags.NonPublic);

	private static readonly MethodInfo S2FNullable = typeof(FastReflectionHelper).GetMethod("FastInvokerForStructInvokerNullable", BindingFlags.Static | BindingFlags.NonPublic);

	[ThreadStatic]
	private static WeakBox? CachedWeakBox;

	private static readonly MethodInfo S2FClass = typeof(FastReflectionHelper).GetMethod("FastInvokerForStructInvokerClass", BindingFlags.Static | BindingFlags.NonPublic);

	private static readonly MethodInfo S2FVoid = typeof(FastReflectionHelper).GetMethod("FastInvokerForStructInvokerVoid", BindingFlags.Static | BindingFlags.NonPublic);

	private static ConditionalWeakTable<MemberInfo, FSITuple> fastStructInvokers = new ConditionalWeakTable<MemberInfo, FSITuple>();

	private static ConditionalWeakTable<FSITuple, FastInvoker> fastInvokers = new ConditionalWeakTable<FSITuple, FastInvoker>();

	private static readonly MethodInfo CheckArgsMethod = typeof(FastReflectionHelper).GetMethod("CheckArgs", BindingFlags.Static | BindingFlags.NonPublic);

	private const int TargetArgId = -1;

	private const int ResultArgId = -2;

	private static readonly MethodInfo BadArgExceptionMethod = typeof(FastReflectionHelper).GetMethod("BadArgException", BindingFlags.Static | BindingFlags.NonPublic);

	private static readonly FieldInfo WeakBoxValueField = typeof(WeakBox).GetField("Value");

	private static object? FastInvokerForStructInvokerVT<T>(FastStructInvoker invoker, object? target, params object?[]? args) where T : struct
	{
		object result = default(T);
		invoker(target, result, args);
		return result;
	}

	private static object? FastInvokerForStructInvokerNullable<T>(FastStructInvoker invoker, object? target, params object?[]? args) where T : struct
	{
		StrongBox<T?> strongBox = TypedCache<T>.NullableStrongBox ?? (TypedCache<T>.NullableStrongBox = new StrongBox<T?>(null));
		invoker(target, strongBox, args);
		return strongBox.Value;
	}

	private static object? FastInvokerForStructInvokerClass(FastStructInvoker invoker, object? target, params object?[]? args)
	{
		WeakBox weakBox = CachedWeakBox ?? (CachedWeakBox = new WeakBox());
		invoker(target, weakBox, args);
		return weakBox.Value;
	}

	private static object? FastInvokerForStructInvokerVoid(FastStructInvoker invoker, object? target, params object?[]? args)
	{
		invoker(target, null, args);
		return null;
	}

	private static FastInvoker CreateFastInvoker(FastStructInvoker fsi, ReturnTypeClass retTypeClass, Type returnType)
	{
		return retTypeClass switch
		{
			ReturnTypeClass.Void => Extensions.CreateDelegate<FastInvoker>(S2FVoid, fsi), 
			ReturnTypeClass.ValueType => Extensions.CreateDelegate<FastInvoker>(S2FValueType.MakeGenericMethod(returnType), fsi), 
			ReturnTypeClass.Nullable => Extensions.CreateDelegate<FastInvoker>(S2FNullable.MakeGenericMethod(Nullable.GetUnderlyingType(returnType)), fsi), 
			ReturnTypeClass.ReferenceType => Extensions.CreateDelegate<FastInvoker>(S2FClass, fsi), 
			_ => throw new NotImplementedException($"Invalid ReturnTypeClass {retTypeClass}"), 
		};
	}

	private static FSITuple GetFSITuple(MethodBase method)
	{
		ReturnTypeClass retTypeClass;
		Type retType;
		return fastStructInvokers.GetValue(method, (MemberInfo _) => new FSITuple(CreateMethodInvoker(method, out retTypeClass, out retType), retTypeClass, retType));
	}

	private static FSITuple GetFSITuple(FieldInfo field)
	{
		ReturnTypeClass retTypeClass;
		Type retType;
		return fastStructInvokers.GetValue(field, (MemberInfo _) => new FSITuple(CreateFieldInvoker(field, out retTypeClass, out retType), retTypeClass, retType));
	}

	private static FSITuple GetFSITuple(MemberInfo member)
	{
		if (!(member is MethodBase method))
		{
			if (member is FieldInfo field)
			{
				return GetFSITuple(field);
			}
			throw new NotSupportedException($"Member type {member.GetType()} is not supported");
		}
		return GetFSITuple(method);
	}

	private static FastInvoker GetFastInvoker(FSITuple tuple)
	{
		return fastInvokers.GetValue(tuple, (FSITuple t) => CreateFastInvoker(t.FSI, t.RTC, t.ReturnType));
	}

	public static FastStructInvoker GetFastStructInvoker(MethodBase method)
	{
		return GetFSITuple(method).FSI;
	}

	public static FastStructInvoker GetFastStructInvoker(FieldInfo field)
	{
		return GetFSITuple(field).FSI;
	}

	public static FastStructInvoker GetFastStructInvoker(MemberInfo member)
	{
		return GetFSITuple(member).FSI;
	}

	public static FastInvoker GetFastInvoker(this MethodBase method)
	{
		return GetFastInvoker(GetFSITuple(method));
	}

	public static FastInvoker GetFastInvoker(this FieldInfo field)
	{
		return GetFastInvoker(GetFSITuple(field));
	}

	public static FastInvoker GetFastInvoker(this MemberInfo member)
	{
		return GetFastInvoker(GetFSITuple(member));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void CheckArgs(bool isStatic, object? target, int retTypeClass, object? result, int expectLen, object?[]? args)
	{
		if (!isStatic)
		{
			Helpers.ThrowIfArgumentNull(target, "target");
		}
		if (retTypeClass != 0 && (uint)(retTypeClass - 1) <= 2u)
		{
			Helpers.ThrowIfArgumentNull(result, "result");
		}
		if (expectLen != 0)
		{
			Helpers.ThrowIfArgumentNull(args, "args");
			if (args.Length < expectLen)
			{
				ThrowArgumentOutOfRange();
			}
		}
		[MethodImpl(MethodImplOptions.NoInlining)]
		static void ThrowArgumentOutOfRange()
		{
			throw new ArgumentOutOfRangeException("args", "Argument array has too few arguments!");
		}
	}

	private static Exception BadArgException(int arg, RuntimeTypeHandle expectType, object? target, object? result, object?[] args)
	{
		Type typeFromHandle = Type.GetTypeFromHandle(expectType);
		Type type = arg switch
		{
			-1 => target?.GetType(), 
			-2 => result?.GetType(), 
			_ => args[arg]?.GetType(), 
		};
		FormatInterpolatedStringHandler handler;
		string text;
		switch (arg)
		{
		case -1:
			text = "target";
			break;
		case -2:
			text = "result";
			break;
		default:
			handler = new FormatInterpolatedStringHandler(6, 1);
			handler.AppendLiteral("args[");
			handler.AppendFormatted(arg);
			handler.AppendLiteral("]");
			text = DebugFormatter.Format(ref handler);
			break;
		}
		string paramName = text;
		if ((object)type == null)
		{
			return new ArgumentNullException(paramName);
		}
		switch (arg)
		{
		case -1:
			handler = new FormatInterpolatedStringHandler(48, 2);
			handler.AppendLiteral("Target object is the wrong type; expected ");
			handler.AppendFormatted(typeFromHandle);
			handler.AppendLiteral(", got ");
			handler.AppendFormatted(type);
			text = DebugFormatter.Format(ref handler);
			break;
		case -2:
			handler = new FormatInterpolatedStringHandler(48, 2);
			handler.AppendLiteral("Result object is the wrong type; expected ");
			handler.AppendFormatted(typeFromHandle);
			handler.AppendLiteral(", got ");
			handler.AppendFormatted(type);
			text = DebugFormatter.Format(ref handler);
			break;
		default:
			handler = new FormatInterpolatedStringHandler(44, 3);
			handler.AppendLiteral("Argument ");
			handler.AppendFormatted(arg);
			handler.AppendLiteral(" is the wrong type; expected ");
			handler.AppendFormatted(typeFromHandle);
			handler.AppendLiteral(", got ");
			handler.AppendFormatted(type);
			text = DebugFormatter.Format(ref handler);
			break;
		}
		return new ArgumentException(text, paramName);
	}

	private static ReturnTypeClass ClassifyType(Type returnType)
	{
		if (returnType == typeof(void))
		{
			return ReturnTypeClass.Void;
		}
		if (returnType.IsValueType)
		{
			if ((object)Nullable.GetUnderlyingType(returnType) != null)
			{
				return ReturnTypeClass.Nullable;
			}
			return ReturnTypeClass.ValueType;
		}
		return ReturnTypeClass.ReferenceType;
	}

	private static void EmitCheckArgs(ILCursor il, bool isStatic, ReturnTypeClass rtc, int expectParams)
	{
		il.Emit(OpCodes.Ldc_I4, isStatic ? 1 : 0);
		il.Emit(OpCodes.Ldarg_0);
		il.Emit(OpCodes.Ldc_I4, (int)rtc);
		il.Emit(OpCodes.Ldarg_1);
		il.Emit(OpCodes.Ldc_I4, expectParams);
		il.Emit(OpCodes.Ldarg_2);
		il.Emit(OpCodes.Call, CheckArgsMethod);
	}

	private static void EmitCheckType(ILCursor il, int argId, Type expectType, ILLabel badArgLbl)
	{
		ILLabel iLLabel = il.DefineLabel();
		bool isByRef = expectType.IsByRef;
		VariableDefinition variableDefinition = null;
		if (isByRef)
		{
			expectType = expectType.GetElementType() ?? expectType;
			ReturnTypeClass rtc = ClassifyType(expectType);
			if (!expectType.IsValueType)
			{
				variableDefinition = new VariableDefinition(il.Module.TypeSystem.Object);
				il.Context.Body.Variables.Add(variableDefinition);
				il.Emit(OpCodes.Stloc, variableDefinition);
				il.Emit(OpCodes.Ldloc, variableDefinition);
			}
			EmitCheckByref(il, rtc, expectType, badArgLbl, argId);
			if (expectType.IsValueType)
			{
				return;
			}
			if (variableDefinition != null)
			{
				il.Emit(OpCodes.Ldloc, variableDefinition);
			}
			EmitLoadByref(il, rtc, expectType);
			il.Emit(OpCodes.Ldind_Ref);
		}
		if (expectType != typeof(object))
		{
			il.Emit(OpCodes.Isinst, expectType);
		}
		il.Emit(OpCodes.Brtrue, iLLabel);
		il.Emit(OpCodes.Ldc_I4, argId);
		il.Emit(OpCodes.Ldtoken, expectType);
		il.Emit(OpCodes.Br, badArgLbl);
		il.MarkLabel(iLLabel);
	}

	private static void EmitCheckAllowNull(ILCursor il, int argId, Type expectType, ILLabel badArgLbl)
	{
		ILLabel iLLabel = il.DefineLabel();
		bool isByRef = expectType.IsByRef;
		VariableDefinition variableDefinition = null;
		if (isByRef)
		{
			expectType = expectType.GetElementType() ?? expectType;
			ReturnTypeClass rtc = ClassifyType(expectType);
			if (!expectType.IsValueType)
			{
				variableDefinition = new VariableDefinition(il.Module.TypeSystem.Object);
				il.Context.Body.Variables.Add(variableDefinition);
				il.Emit(OpCodes.Stloc, variableDefinition);
				il.Emit(OpCodes.Ldloc, variableDefinition);
			}
			EmitCheckByref(il, rtc, expectType, badArgLbl, argId);
			if (expectType.IsValueType)
			{
				return;
			}
			if (variableDefinition != null)
			{
				il.Emit(OpCodes.Ldloc, variableDefinition);
			}
			EmitLoadByref(il, rtc, expectType);
			il.Emit(OpCodes.Ldind_Ref);
		}
		if (expectType == typeof(object))
		{
			il.Emit(OpCodes.Pop);
			return;
		}
		if (!expectType.IsValueType || (object)Nullable.GetUnderlyingType(expectType) != null)
		{
			ILLabel iLLabel2 = il.DefineLabel();
			VariableDefinition variableDefinition2 = new VariableDefinition(il.Module.TypeSystem.Object);
			il.Context.Body.Variables.Add(variableDefinition2);
			il.Emit(OpCodes.Stloc, variableDefinition2);
			il.Emit(OpCodes.Ldloc, variableDefinition2);
			il.Emit(OpCodes.Brtrue, iLLabel2);
			il.Emit(OpCodes.Br, iLLabel);
			il.MarkLabel(iLLabel2);
			il.Emit(OpCodes.Ldloc, variableDefinition2);
		}
		if (!expectType.IsValueType || (!isByRef && expectType.IsValueType))
		{
			EmitCheckType(il, argId, expectType, badArgLbl);
		}
		il.MarkLabel(iLLabel);
	}

	private static void EmitBadArgCall(ILCursor il, ILLabel badArgLbl)
	{
		il.MarkLabel(badArgLbl);
		il.Emit(OpCodes.Ldarg_0);
		il.Emit(OpCodes.Ldarg_1);
		il.Emit(OpCodes.Ldarg_2);
		il.Emit(OpCodes.Call, BadArgExceptionMethod);
		il.Emit(OpCodes.Throw);
	}

	private static void EmitCheckByref(ILCursor il, ReturnTypeClass rtc, Type returnType, ILLabel badArgLbl, int argId = -2)
	{
		Type expectType;
		switch (rtc)
		{
		default:
			return;
		case ReturnTypeClass.ValueType:
			expectType = returnType;
			break;
		case ReturnTypeClass.Nullable:
			expectType = typeof(StrongBox<>).MakeGenericType(returnType);
			break;
		case ReturnTypeClass.ReferenceType:
			expectType = typeof(WeakBox);
			break;
		case ReturnTypeClass.Void:
			return;
		}
		EmitCheckType(il, argId, expectType, badArgLbl);
	}

	private static void EmitLoadByref(ILCursor il, ReturnTypeClass rtc, Type returnType)
	{
		switch (rtc)
		{
		case ReturnTypeClass.ValueType:
			il.Emit(OpCodes.Unbox, returnType);
			break;
		case ReturnTypeClass.Nullable:
		{
			FieldInfo field = typeof(StrongBox<>).MakeGenericType(returnType).GetField("Value");
			il.Emit(OpCodes.Ldflda, field);
			break;
		}
		case ReturnTypeClass.ReferenceType:
			il.Emit(OpCodes.Ldflda, WeakBoxValueField);
			break;
		case ReturnTypeClass.Void:
			break;
		}
	}

	private static void EmitLoadArgO(ILCursor il, int arg)
	{
		il.Emit(OpCodes.Ldarg_2);
		il.Emit(OpCodes.Ldc_I4, arg);
		il.Emit(OpCodes.Ldelem_Ref);
	}

	private static void EmitStoreByref(ILCursor il, ReturnTypeClass rtc, Type returnType)
	{
		if (rtc != 0)
		{
			if (returnType.IsValueType)
			{
				il.Emit(OpCodes.Stobj, returnType);
			}
			else
			{
				il.Emit(OpCodes.Stind_Ref);
			}
		}
	}

	private static FastStructInvoker CreateMethodInvoker(MethodBase method, out ReturnTypeClass retTypeClass, out Type retType)
	{
		if (!method.IsStatic)
		{
			Type? declaringType = method.DeclaringType;
			if ((object)declaringType != null && declaringType.IsByRefLike())
			{
				throw new ArgumentException("Cannot create reflection invoker for instance method on byref-like type", "method");
			}
		}
		Type returnType = ((method is MethodInfo methodInfo) ? methodInfo.ReturnType : method.DeclaringType);
		retType = returnType;
		if (returnType.IsByRef || returnType.IsByRefLike())
		{
			throw new ArgumentException("Cannot create reflection invoker for method with byref or byref-like return type", "method");
		}
		retTypeClass = ClassifyType(returnType);
		ReturnTypeClass typeClass = retTypeClass;
		ParameterInfo[] methParams = method.GetParameters();
		FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(22, 1);
		handler.AppendLiteral("MM:FastStructInvoker<");
		handler.AppendFormatted(method);
		handler.AppendLiteral(">");
		using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(DebugFormatter.Format(ref handler), null, FastStructInvokerArgs);
		using ILContext iLContext = new ILContext(dynamicMethodDefinition.Definition);
		iLContext.Invoke(delegate(ILContext ilc)
		{
			ILCursor iLCursor = new ILCursor(ilc);
			EmitCheckArgs(iLCursor, method.IsStatic || method is ConstructorInfo, typeClass, methParams.Length);
			ILLabel badArgLbl = iLCursor.DefineLabel();
			if (!method.IsStatic && !(method is ConstructorInfo))
			{
				Type declaringType2 = method.DeclaringType;
				Helpers.Assert((object)declaringType2 != null, null, "expectType is not null");
				iLCursor.Emit(OpCodes.Ldarg_0);
				EmitCheckType(iLCursor, -1, declaringType2, badArgLbl);
			}
			if (typeClass != 0)
			{
				iLCursor.Emit(OpCodes.Ldarg_1);
				EmitCheckByref(iLCursor, typeClass, returnType, badArgLbl);
			}
			for (int i = 0; i < methParams.Length; i++)
			{
				Type parameterType = methParams[i].ParameterType;
				if (parameterType.IsByRefLike())
				{
					throw new ArgumentException("Cannot create reflection invoker for method with byref-like argument types", "method");
				}
				EmitLoadArgO(iLCursor, i);
				EmitCheckAllowNull(iLCursor, i, parameterType, badArgLbl);
			}
			if (typeClass != 0)
			{
				iLCursor.Emit(OpCodes.Ldarg_1);
				EmitLoadByref(iLCursor, typeClass, returnType);
			}
			if (!method.IsStatic && !(method is ConstructorInfo))
			{
				Type declaringType3 = method.DeclaringType;
				Helpers.Assert((object)declaringType3 != null, null, "declType is not null");
				iLCursor.Emit(OpCodes.Ldarg_0);
				if (declaringType3.IsValueType)
				{
					iLCursor.Emit(OpCodes.Unbox, declaringType3);
				}
			}
			for (int j = 0; j < methParams.Length; j++)
			{
				iLCursor.DefineLabel();
				Type parameterType2 = methParams[j].ParameterType;
				Type type = (parameterType2.IsByRef ? (parameterType2.GetElementType() ?? parameterType2) : parameterType2);
				EmitLoadArgO(iLCursor, j);
				if (parameterType2.IsByRef)
				{
					EmitLoadByref(iLCursor, ClassifyType(type), type);
				}
				else if (parameterType2.IsValueType)
				{
					iLCursor.Emit(OpCodes.Unbox_Any, type);
				}
			}
			if (method is ConstructorInfo method2)
			{
				iLCursor.Emit(OpCodes.Newobj, method2);
			}
			else if (method.IsVirtual)
			{
				iLCursor.Emit(OpCodes.Callvirt, method);
			}
			else
			{
				iLCursor.Emit(OpCodes.Call, method);
			}
			EmitStoreByref(iLCursor, typeClass, returnType);
			iLCursor.Emit(OpCodes.Ret);
			EmitBadArgCall(iLCursor, badArgLbl);
		});
		return Extensions.CreateDelegate<FastStructInvoker>(dynamicMethodDefinition.Generate());
	}

	private static FastStructInvoker CreateFieldInvoker(FieldInfo field, out ReturnTypeClass retTypeClass, out Type retType)
	{
		if (!field.IsStatic)
		{
			Type? declaringType = field.DeclaringType;
			if ((object)declaringType != null && declaringType.IsByRefLike())
			{
				throw new ArgumentException("Cannot create reflection invoker for instance field on byref-like type", "field");
			}
		}
		Type returnType = field.FieldType;
		retType = returnType;
		retTypeClass = ClassifyType(returnType);
		ReturnTypeClass typeClass = retTypeClass;
		FormatInterpolatedStringHandler handler = new FormatInterpolatedStringHandler(22, 1);
		handler.AppendLiteral("MM:FastStructInvoker<");
		handler.AppendFormatted(field);
		handler.AppendLiteral(">");
		using DynamicMethodDefinition dynamicMethodDefinition = new DynamicMethodDefinition(DebugFormatter.Format(ref handler), null, FastStructInvokerArgs);
		using ILContext iLContext = new ILContext(dynamicMethodDefinition.Definition);
		iLContext.Invoke(delegate(ILContext ilc)
		{
			ILCursor iLCursor = new ILCursor(ilc);
			EmitCheckArgs(iLCursor, field.IsStatic, typeClass, 0);
			ILLabel badArgLbl = iLCursor.DefineLabel();
			if (!field.IsStatic)
			{
				Type declaringType2 = field.DeclaringType;
				iLCursor.Emit(OpCodes.Ldarg_0);
				EmitCheckType(iLCursor, -1, declaringType2, badArgLbl);
			}
			iLCursor.Emit(OpCodes.Ldarg_1);
			EmitCheckByref(iLCursor, typeClass, returnType, badArgLbl);
			ILLabel iLLabel = iLCursor.DefineLabel();
			iLCursor.Emit(OpCodes.Ldarg_2);
			iLCursor.Emit(OpCodes.Brfalse, iLLabel);
			iLCursor.Emit(OpCodes.Ldarg_2);
			iLCursor.Emit(OpCodes.Ldlen);
			iLCursor.Emit(OpCodes.Ldc_I4_1);
			iLCursor.Emit(OpCodes.Blt, iLLabel);
			EmitLoadArgO(iLCursor, 0);
			EmitCheckAllowNull(iLCursor, 0, field.FieldType, badArgLbl);
			iLCursor.Emit(OpCodes.Ldarg_1);
			EmitLoadByref(iLCursor, typeClass, returnType);
			if (!field.IsStatic)
			{
				Type declaringType3 = field.DeclaringType;
				Helpers.Assert((object)declaringType3 != null, null, "declType is not null");
				iLCursor.Emit(OpCodes.Ldarg_0);
				if (declaringType3.IsValueType)
				{
					iLCursor.Emit(OpCodes.Unbox, declaringType3);
				}
			}
			EmitLoadArgO(iLCursor, 0);
			iLCursor.Emit(OpCodes.Unbox_Any, field.FieldType);
			if (field.IsStatic)
			{
				iLCursor.Emit(OpCodes.Stsfld, field);
			}
			else
			{
				iLCursor.Emit(OpCodes.Stfld, field);
			}
			EmitLoadArgO(iLCursor, 0);
			iLCursor.Emit(OpCodes.Unbox_Any, field.FieldType);
			EmitStoreByref(iLCursor, typeClass, returnType);
			iLCursor.Emit(OpCodes.Ret);
			iLCursor.MarkLabel(iLLabel);
			iLCursor.Emit(OpCodes.Ldarg_1);
			EmitLoadByref(iLCursor, typeClass, returnType);
			if (!field.IsStatic)
			{
				Type declaringType4 = field.DeclaringType;
				Helpers.Assert((object)declaringType4 != null, null, "declType is not null");
				iLCursor.Emit(OpCodes.Ldarg_0);
				if (declaringType4.IsValueType)
				{
					iLCursor.Emit(OpCodes.Unbox, declaringType4);
				}
			}
			if (field.IsStatic)
			{
				iLCursor.Emit(OpCodes.Ldsfld, field);
			}
			else
			{
				iLCursor.Emit(OpCodes.Ldfld, field);
			}
			EmitStoreByref(iLCursor, typeClass, returnType);
			iLCursor.Emit(OpCodes.Ret);
			EmitBadArgCall(iLCursor, badArgLbl);
		});
		return Extensions.CreateDelegate<FastStructInvoker>(dynamicMethodDefinition.Generate());
	}
}


public delegate object? FastInvoker(object? target, params object?[]? args);


public delegate void FastStructInvoker(object? target, object? result, params object?[]? args);


using System;
using System.Runtime.CompilerServices;

private static class TypedCache<T> where T : struct
{
	[ThreadStatic]
	public static StrongBox<T?>? NullableStrongBox;
}


private enum ReturnTypeClass
{
	Void,
	ValueType,
	Nullable,
	ReferenceType
}


using System;

private sealed class FSITuple
{
	public readonly FastStructInvoker FSI;

	public readonly ReturnTypeClass RTC;

	public readonly Type ReturnType;

	public FSITuple(FastStructInvoker fsi, ReturnTypeClass rtc, Type rt)
	{
		FSI = fsi;
		RTC = rtc;
		ReturnType = rt;
	}
}


using System;
using System.Collections.Generic;
using System.Reflection;
using MonoMod.Utils;

internal class GenericMethodInstantiationComparer : IEqualityComparer<MethodBase>
{
	internal static Type? CannonicalFillType = typeof(object).Assembly.GetType("System.__Canon");

	private readonly IEqualityComparer<Type> genericTypeComparer;

	public GenericMethodInstantiationComparer()
		: this(new GenericTypeInstantiationComparer())
	{
	}

	public GenericMethodInstantiationComparer(IEqualityComparer<Type> typeComparer)
	{
		genericTypeComparer = typeComparer;
	}

	public bool Equals(MethodBase? x, MethodBase? y)
	{
		if ((object)x == null && (object)y == null)
		{
			return true;
		}
		if ((object)x == null || (object)y == null)
		{
			return false;
		}
		bool flag = (x.IsGenericMethod && !x.ContainsGenericParameters) || (x.DeclaringType?.IsGenericType ?? false);
		bool flag2 = (y.IsGenericMethod && !y.ContainsGenericParameters) || (y.DeclaringType?.IsGenericType ?? false);
		if (flag != flag2)
		{
			return false;
		}
		if (!flag)
		{
			return x.Equals(y);
		}
		if (!genericTypeComparer.Equals(x.DeclaringType, y.DeclaringType))
		{
			return false;
		}
		MethodBase methodBase = ((!(x is MethodInfo method)) ? x.GetUnfilledMethodOnGenericType() : method.GetActualGenericMethodDefinition());
		MethodBase methodBase2 = ((!(y is MethodInfo method2)) ? y.GetUnfilledMethodOnGenericType() : method2.GetActualGenericMethodDefinition());
		if (!methodBase.Equals(methodBase2))
		{
			return false;
		}
		if (methodBase.Name != methodBase2.Name)
		{
			return false;
		}
		ParameterInfo[] parameters = x.GetParameters();
		ParameterInfo[] parameters2 = y.GetParameters();
		if (parameters.Length != parameters2.Length)
		{
			return false;
		}
		ParameterInfo[] parameters3 = methodBase.GetParameters();
		for (int i = 0; i < parameters.Length; i++)
		{
			Type type = parameters[i].ParameterType;
			Type type2 = parameters2[i].ParameterType;
			if (parameters3[i].ParameterType.IsGenericParameter)
			{
				if (!type.IsValueType)
				{
					type = CannonicalFillType ?? typeof(object);
				}
				if (!type2.IsValueType)
				{
					type2 = CannonicalFillType ?? typeof(object);
				}
			}
			if (!genericTypeComparer.Equals(type, type2))
			{
				return false;
			}
		}
		return true;
	}

	public int GetHashCode(MethodBase obj)
	{
		Helpers.ThrowIfArgumentNull(obj, "obj");
		if (!obj.IsGenericMethod || obj.ContainsGenericParameters)
		{
			Type? declaringType = obj.DeclaringType;
			if ((object)declaringType == null || !declaringType.IsGenericType)
			{
				return obj.GetHashCode();
			}
		}
		int num = -559038737;
		if (obj.DeclaringType != null)
		{
			num ^= obj.DeclaringType.Assembly.GetHashCode();
			num ^= genericTypeComparer.GetHashCode(obj.DeclaringType);
		}
		num ^= System.StringExtensions.GetHashCode(obj.Name, StringComparison.Ordinal);
		ParameterInfo[] parameters = obj.GetParameters();
		int num2 = parameters.Length;
		num2 ^= num2 << 4;
		num2 ^= num2 << 8;
		num2 ^= num2 << 16;
		num ^= num2;
		if (obj.IsGenericMethod)
		{
			Type[] genericArguments = obj.GetGenericArguments();
			for (int i = 0; i < genericArguments.Length; i++)
			{
				int num3 = i % 32;
				Type type = genericArguments[i];
				int num4 = (type.IsValueType ? genericTypeComparer.GetHashCode(type) : (CannonicalFillType?.GetHashCode() ?? 1431655765));
				num4 = (num4 << num3) | (num4 >> 32 - num3);
				num ^= num4;
			}
		}
		MethodBase methodBase = ((!(obj is MethodInfo method)) ? obj.GetUnfilledMethodOnGenericType() : method.GetActualGenericMethodDefinition());
		ParameterInfo[] parameters2 = methodBase.GetParameters();
		for (int j = 0; j < parameters.Length; j++)
		{
			int num5 = j % 32;
			Type parameterType = parameters[j].ParameterType;
			int num6 = genericTypeComparer.GetHashCode(parameterType);
			if (parameters2[j].ParameterType.IsGenericParameter && !parameterType.IsValueType)
			{
				num6 = CannonicalFillType?.GetHashCode() ?? 1431655765;
			}
			num6 = (num6 >> num5) | (num6 << 32 - num5);
			num ^= num6;
		}
		return num;
	}
}


using System;
using System.Collections.Generic;
using MonoMod.Utils;

internal class GenericTypeInstantiationComparer : IEqualityComparer<Type>
{
	private static Type? CannonicalFillType = GenericMethodInstantiationComparer.CannonicalFillType;

	public bool Equals(Type? x, Type? y)
	{
		if ((object)x == null && (object)y == null)
		{
			return true;
		}
		if ((object)x == null || (object)y == null)
		{
			return false;
		}
		bool isGenericType = x.IsGenericType;
		bool isGenericType2 = y.IsGenericType;
		if (isGenericType != isGenericType2)
		{
			return false;
		}
		if (!isGenericType)
		{
			return x.Equals(y);
		}
		Type genericTypeDefinition = x.GetGenericTypeDefinition();
		Type genericTypeDefinition2 = y.GetGenericTypeDefinition();
		if (!genericTypeDefinition.Equals(genericTypeDefinition2))
		{
			return false;
		}
		Type[] genericArguments = x.GetGenericArguments();
		Type[] genericArguments2 = y.GetGenericArguments();
		if (genericArguments.Length != genericArguments2.Length)
		{
			return false;
		}
		for (int i = 0; i < genericArguments.Length; i++)
		{
			Type type = genericArguments[i];
			Type type2 = genericArguments2[i];
			if (!type.IsValueType)
			{
				type = CannonicalFillType ?? typeof(object);
			}
			if (!type2.IsValueType)
			{
				type2 = CannonicalFillType ?? typeof(object);
			}
			if (!Equals(type, type2))
			{
				return false;
			}
		}
		return true;
	}

	public int GetHashCode(Type obj)
	{
		Helpers.ThrowIfArgumentNull(obj, "obj");
		if (!obj.IsGenericType)
		{
			return obj.GetHashCode();
		}
		int num = -559038737;
		num ^= obj.Assembly.GetHashCode();
		num ^= (num << 16) | (num >> 16);
		if (obj.Namespace != null)
		{
			num ^= System.StringExtensions.GetHashCode(obj.Namespace, StringComparison.Ordinal);
		}
		num ^= System.StringExtensions.GetHashCode(obj.Name, StringComparison.Ordinal);
		Type[] genericArguments = obj.GetGenericArguments();
		for (int i = 0; i < genericArguments.Length; i++)
		{
			int num2 = i % 8 * 4;
			Type type = genericArguments[i];
			int num3 = (type.IsValueType ? GetHashCode(type) : (CannonicalFillType?.GetHashCode() ?? (-1717986919)));
			num ^= (num3 << num2) | (num3 >> 32 - num2);
		}
		return num;
	}
}


using System;
using System.Buffers;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;
using MonoMod;
using MonoMod.Logs;
using MonoMod.Utils;

internal static class Helpers
{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Swap<T>(ref T a, ref T b)
	{
		T val = a;
		a = b;
		b = val;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool Has<T>(this T value, T flag) where T : struct, Enum
	{
		if (Unsafe.SizeOf<T>() == 8)
		{
			long num = Unsafe.As<T, long>(ref flag);
			return (Unsafe.As<T, long>(ref value) & num) == num;
		}
		if (Unsafe.SizeOf<T>() == 4)
		{
			int num2 = Unsafe.As<T, int>(ref flag);
			return (Unsafe.As<T, int>(ref value) & num2) == num2;
		}
		if (Unsafe.SizeOf<T>() == 2)
		{
			short num3 = Unsafe.As<T, short>(ref flag);
			return (Unsafe.As<T, short>(ref value) & num3) == num3;
		}
		if (Unsafe.SizeOf<T>() == 1)
		{
			byte b = Unsafe.As<T, byte>(ref flag);
			return (Unsafe.As<T, byte>(ref value) & b) == b;
		}
		throw new InvalidOperationException("unknown enum size?");
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void ThrowIfArgumentNull<T>([NotNull] T? arg, [CallerArgumentExpression("arg")] string name = "")
	{
		if (arg == null)
		{
			ThrowArgumentNull(name);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static T ThrowIfNull<T>([NotNull] T? arg, [CallerArgumentExpression("arg")] string name = "")
	{
		if (arg == null)
		{
			ThrowArgumentNull(name);
		}
		return arg;
	}

	public static T EventAdd<T>(ref T? evt, T del) where T : Delegate
	{
		T val;
		T val2;
		do
		{
			val = evt;
			val2 = (T)Delegate.Combine(val, del);
		}
		while (Interlocked.CompareExchange(ref evt, val2, val) != val);
		return val2;
	}

	public static T? EventRemove<T>(ref T? evt, T del) where T : Delegate
	{
		T val;
		T val2;
		do
		{
			val = evt;
			val2 = (T)Delegate.Remove(val, del);
		}
		while (Interlocked.CompareExchange(ref evt, val2, val) != val);
		return val2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Assert([DoesNotReturnIf(false)] bool value, string? message = null, [CallerArgumentExpression("value")] string expr = "")
	{
		if (!value)
		{
			ThrowAssertionFailed(message, expr);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Conditional("DEBUG")]
	public static void DAssert([DoesNotReturnIf(false)] bool value, string? message = null, [CallerArgumentExpression("value")] string expr = "")
	{
		if (!value)
		{
			ThrowAssertionFailed(message, expr);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Assert([DoesNotReturnIf(false)] bool value, [InterpolatedStringHandlerArgument("value")] ref AssertionInterpolatedStringHandler message, [CallerArgumentExpression("value")] string expr = "")
	{
		if (!value)
		{
			ThrowAssertionFailed(ref message, expr);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[Conditional("DEBUG")]
	public static void DAssert([DoesNotReturnIf(false)] bool value, [InterpolatedStringHandlerArgument("value")] ref AssertionInterpolatedStringHandler message, [CallerArgumentExpression("value")] string expr = "")
	{
		if (!value)
		{
			ThrowAssertionFailed(ref message, expr);
		}
	}

	[DoesNotReturn]
	private static void ThrowArgumentNull(string argName)
	{
		throw new ArgumentNullException(argName);
	}

	[DoesNotReturn]
	private static void ThrowAssertionFailed(string? msg, string expr)
	{
		LogLevel logLevel = LogLevel.Assert;
		LogLevel level = logLevel;
		bool isEnabled;
		DebugLogInterpolatedStringHandler message = new DebugLogInterpolatedStringHandler(19, 2, logLevel, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Assertion failed! ");
			message.AppendFormatted(expr);
			message.AppendLiteral(" ");
			message.AppendFormatted(msg);
		}
		DebugLog.Log("MonoMod.Utils.Assert", level, ref message);
		throw new AssertionFailedException(msg, expr);
	}

	[DoesNotReturn]
	private static void ThrowAssertionFailed(ref AssertionInterpolatedStringHandler message, string expr)
	{
		string text = message.ToStringAndClear();
		LogLevel logLevel = LogLevel.Assert;
		LogLevel level = logLevel;
		bool isEnabled;
		DebugLogInterpolatedStringHandler message2 = new DebugLogInterpolatedStringHandler(19, 2, logLevel, out isEnabled);
		if (isEnabled)
		{
			message2.AppendLiteral("Assertion failed! ");
			message2.AppendFormatted(expr);
			message2.AppendLiteral(" ");
			message2.AppendFormatted(text);
		}
		DebugLog.Log("MonoMod.Utils.Assert", level, ref message2);
		throw new AssertionFailedException(text, expr);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T GetOrInit<T>(ref T? location, Func<T> init) where T : class
	{
		if (location != null)
		{
			return location;
		}
		return InitializeValue<T, Func<T>>(ref location, (delegate*<Func<T>, T>)(&ILHelpers.TailCallFunc), init);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T GetOrInitWithLock<T>(ref T? location, object @lock, Func<T> init) where T : class
	{
		if (location != null)
		{
			return location;
		}
		return InitializeValueWithLock<T, Func<T>>(ref location, @lock, (delegate*<Func<T>, T>)(&ILHelpers.TailCallFunc), init);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T GetOrInit<T>(ref T? location, delegate*<T> init) where T : class
	{
		if (location != null)
		{
			return location;
		}
		return InitializeValue(ref location, (delegate*<IntPtr, T>)(&ILHelpers.TailCallDelegatePtr<T>), (IntPtr)init);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T GetOrInitWithLock<T>(ref T? location, object @lock, delegate*<T> init) where T : class
	{
		if (location != null)
		{
			return location;
		}
		return InitializeValueWithLock(ref location, @lock, (delegate*<IntPtr, T>)(&ILHelpers.TailCallDelegatePtr<T>), (IntPtr)init);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T GetOrInit<T, TParam>(ref T? location, delegate*<TParam, T> init, TParam obj) where T : class
	{
		if (location != null)
		{
			return location;
		}
		return InitializeValue(ref location, init, obj);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe static T GetOrInitWithLock<T, TParam>(ref T? location, object @lock, delegate*<TParam, T> init, TParam obj) where T : class
	{
		if (location != null)
		{
			return location;
		}
		return InitializeValueWithLock(ref location, @lock, init, obj);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private unsafe static T InitializeValue<T, TParam>(ref T? location, delegate*<TParam, T> init, TParam obj) where T : class
	{
		Interlocked.CompareExchange(ref location, init(obj), null);
		return location;
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	private unsafe static T InitializeValueWithLock<T, TParam>(ref T? location, object @lock, delegate*<TParam, T> init, TParam obj) where T : class
	{
		lock (@lock)
		{
			if (location != null)
			{
				return location;
			}
			return location = init(obj);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool MaskedSequenceEqual(ReadOnlySpan<byte> first, ReadOnlySpan<byte> second, ReadOnlySpan<byte> mask)
	{
		if (mask.Length < first.Length || mask.Length < second.Length)
		{
			ThrowMaskTooShort();
		}
		if (first.Length == second.Length)
		{
			return MaskedSequenceEqualCore(ref MemoryMarshal.GetReference(first), ref MemoryMarshal.GetReference(second), ref MemoryMarshal.GetReference(mask), (nuint)first.Length);
		}
		return false;
	}

	[DoesNotReturn]
	private static void ThrowMaskTooShort()
	{
		throw new ArgumentException("Mask too short", "mask");
	}

	private unsafe static bool MaskedSequenceEqualCore(ref byte first, ref byte second, ref byte maskBytes, nuint length)
	{
		if (!Unsafe.AreSame(ref first, ref second))
		{
			nint num = 0;
			nint num2 = (nint)length;
			if ((nuint)num2 >= (nuint)sizeof(UIntPtr))
			{
				num2 -= sizeof(UIntPtr);
				while (true)
				{
					nuint num3;
					if ((nuint)num2 > (nuint)num)
					{
						num3 = Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref maskBytes, num));
						if (((nuint)(nint)(nuint)Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, num)) & num3) != ((nuint)(nint)(nuint)Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, num)) & num3))
						{
							break;
						}
						num += sizeof(UIntPtr);
						continue;
					}
					num3 = Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref maskBytes, num));
					return ((nuint)(nint)(nuint)Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref first, num2)) & num3) == ((nuint)(nint)(nuint)Unsafe.ReadUnaligned<UIntPtr>(ref Unsafe.AddByteOffset(ref second, num2)) & num3);
				}
				goto IL_00b9;
			}
			while ((nuint)num2 > (nuint)num)
			{
				byte b = Unsafe.AddByteOffset(ref maskBytes, num);
				if ((Unsafe.AddByteOffset(ref first, num) & b) == (Unsafe.AddByteOffset(ref second, num) & b))
				{
					num++;
					continue;
				}
				goto IL_00b9;
			}
		}
		return true;
		IL_00b9:
		return false;
	}

	public static byte[] ReadAllBytes(string path)
	{
		using FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 1);
		long length = fileStream.Length;
		if (length > int.MaxValue)
		{
			throw new IOException("File is too long (more than 2GB)");
		}
		if (length == 0L)
		{
			return ReadAllBytesUnknownLength(fileStream);
		}
		int num = 0;
		int num2 = (int)length;
		byte[] array = new byte[num2];
		while (num2 > 0)
		{
			int num3 = fileStream.Read(array, num, num2);
			if (num3 == 0)
			{
				throw new IOException("Unexpected end of stream");
			}
			num += num3;
			num2 -= num3;
		}
		return array;
	}

	private static byte[] ReadAllBytesUnknownLength(FileStream fs)
	{
		byte[] array = ArrayPool<byte>.Shared.Rent(256);
		try
		{
			int num = 0;
			while (true)
			{
				if (num == array.Length)
				{
					uint num2 = (uint)(array.Length * 2);
					if (num2 > ArrayEx.MaxLength)
					{
						num2 = (uint)Math.Max(ArrayEx.MaxLength, array.Length + 1);
					}
					byte[] array2 = ArrayPool<byte>.Shared.Rent((int)num2);
					Array.Copy(array, array2, array.Length);
					if (array != null)
					{
						ArrayPool<byte>.Shared.Return(array);
					}
					array = array2;
				}
				int num3 = fs.Read(array, num, array.Length - num);
				if (num3 == 0)
				{
					break;
				}
				num += num3;
			}
			return MemoryExtensions.AsSpan(array, 0, num).ToArray();
		}
		finally
		{
			if (array != null)
			{
				ArrayPool<byte>.Shared.Return(array);
			}
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using MonoMod.Logs;

[InterpolatedStringHandler]
internal ref struct AssertionInterpolatedStringHandler
{
	private DebugLogInterpolatedStringHandler handler;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public AssertionInterpolatedStringHandler(int literalLen, int formattedCount, bool assertValue, out bool isEnabled)
	{
		handler = new DebugLogInterpolatedStringHandler(literalLen, formattedCount, !assertValue, recordHoles: false, out isEnabled);
	}

	public override string ToString()
	{
		return handler.ToString();
	}

	public string ToStringAndClear()
	{
		return handler.ToStringAndClear();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendLiteral(string s)
	{
		handler.AppendLiteral(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(string? s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s)
	{
		handler.AppendFormatted(s);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted(ReadOnlySpan<char> s, int alignment = 0, string? format = null)
	{
		handler.AppendFormatted(s, alignment, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value)
	{
		handler.AppendFormatted(value);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment)
	{
		handler.AppendFormatted(value, alignment);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, string? format)
	{
		handler.AppendFormatted(value, format);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void AppendFormatted<T>(T value, int alignment, string? format)
	{
		handler.AppendFormatted(value, alignment, format);
	}
}


using Mono.Cecil;

internal interface ICallSiteGenerator
{
	CallSite ToCallSite(ModuleDefinition module);
}


using System;

internal sealed class LazyDisposable : IDisposable
{
	public event Action? OnDispose;

	public LazyDisposable()
	{
	}

	public LazyDisposable(Action a)
		: this()
	{
		OnDispose += a;
	}

	public void Dispose()
	{
		this.OnDispose?.Invoke();
	}
}


using System;

internal sealed class LazyDisposable<T> : IDisposable
{
	private T? Instance;

	public event Action<T>? OnDispose;

	public LazyDisposable(T instance)
	{
		Instance = instance;
	}

	public LazyDisposable(T instance, Action<T> a)
		: this(instance)
	{
		OnDispose += a;
	}

	public void Dispose()
	{
		this.OnDispose?.Invoke(Instance);
		Instance = default(T);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using MonoMod.Logs;
using MonoMod.Utils;

internal sealed class MethodSignature : IEquatable<MethodSignature>, IDebugFormattable
{
	private sealed class CompatableComparer : IEqualityComparer<Type>
	{
		public static readonly CompatableComparer Instance = new CompatableComparer();

		public bool Equals(Type? x, Type? y)
		{
			if ((object)x == y)
			{
				return true;
			}
			if ((object)x == null || (object)y == null)
			{
				return false;
			}
			return x.IsCompatible(y);
		}

		public int GetHashCode([DisallowNull] Type obj)
		{
			throw new NotSupportedException();
		}
	}

	private readonly Type[] parameters;

	private static readonly ConditionalWeakTable<MethodBase, MethodSignature> thisSigMap = new ConditionalWeakTable<MethodBase, MethodSignature>();

	private static readonly ConditionalWeakTable<MethodBase, MethodSignature> noThisSigMap = new ConditionalWeakTable<MethodBase, MethodSignature>();

	public Type ReturnType { get; }

	public int ParameterCount => parameters.Length;

	public IEnumerable<Type> Parameters => parameters;

	public Type? FirstParameter
	{
		get
		{
			if (parameters.Length < 1)
			{
				return null;
			}
			return parameters[0];
		}
	}

	public MethodSignature(Type returnType, Type[] parameters)
	{
		ReturnType = returnType;
		this.parameters = parameters;
	}

	public MethodSignature(Type returnType, IEnumerable<Type> parameters)
	{
		ReturnType = returnType;
		this.parameters = parameters.ToArray();
	}

	public MethodSignature(MethodBase method)
		: this(method, ignoreThis: false)
	{
	}

	public MethodSignature(MethodBase method, bool ignoreThis)
	{
		ReturnType = (method as MethodInfo)?.ReturnType ?? typeof(void);
		int num = ((!ignoreThis && !method.IsStatic) ? 1 : 0);
		ParameterInfo[] array = method.GetParameters();
		parameters = new Type[array.Length + num];
		for (int i = num; i < parameters.Length; i++)
		{
			parameters[i] = array[i - num].ParameterType;
		}
		if (!ignoreThis && !method.IsStatic)
		{
			parameters[0] = method.GetThisParamType();
		}
	}

	public static MethodSignature ForMethod(MethodBase method)
	{
		return ForMethod(method, ignoreThis: false);
	}

	public static MethodSignature ForMethod(MethodBase method, bool ignoreThis)
	{
		return (ignoreThis ? noThisSigMap : thisSigMap).GetValue(method, (MethodBase m) => new MethodSignature(m, ignoreThis));
	}

	public bool IsCompatibleWith(MethodSignature other)
	{
		Helpers.ThrowIfArgumentNull(other, "other");
		if (this == other)
		{
			return true;
		}
		if (ReturnType.IsCompatible(other.ReturnType))
		{
			return parameters.SequenceEqual(other.Parameters, CompatableComparer.Instance);
		}
		return false;
	}

	public DynamicMethodDefinition CreateDmd(string name)
	{
		return new DynamicMethodDefinition(name, ReturnType, parameters);
	}

	public override string ToString()
	{
		int literalLength = 2 + parameters.Length - 1;
		int formattedCount = 1 + parameters.Length;
		DefaultInterpolatedStringHandler defaultInterpolatedStringHandler = new DefaultInterpolatedStringHandler(literalLength, formattedCount);
		defaultInterpolatedStringHandler.AppendFormatted(ReturnType);
		defaultInterpolatedStringHandler.AppendLiteral(" (");
		for (int i = 0; i < parameters.Length; i++)
		{
			if (i != 0)
			{
				defaultInterpolatedStringHandler.AppendLiteral(", ");
			}
			defaultInterpolatedStringHandler.AppendFormatted(parameters[i]);
		}
		defaultInterpolatedStringHandler.AppendLiteral(")");
		return defaultInterpolatedStringHandler.ToStringAndClear();
	}

	bool IDebugFormattable.TryFormatInto(Span<char> span, out int wrote)
	{
		wrote = 0;
		Span<char> span2 = span;
		Span<char> into = span2;
		bool enabled;
		FormatIntoInterpolatedStringHandler handler = new FormatIntoInterpolatedStringHandler(2, 1, span2, out enabled);
		if (enabled && handler.AppendFormatted(ReturnType))
		{
			handler.AppendLiteral(" (");
		}
		else
			_ = 0;
		if (!DebugFormatter.Into(into, out var wrote2, ref handler))
		{
			return false;
		}
		wrote += wrote2;
		for (int i = 0; i < parameters.Length; i++)
		{
			if (i != 0)
			{
				if (!MemoryExtensions.AsSpan(", ").TryCopyTo(span.Slice(wrote)))
				{
					return false;
				}
				wrote += 2;
			}
			span2 = span;
			Span<char> into2 = span2;
			handler = new FormatIntoInterpolatedStringHandler(0, 1, span2, out enabled);
			if (enabled)
			{
				handler.AppendFormatted(parameters[i]);
			}
			else
				_ = 0;
			if (!DebugFormatter.Into(into2, out wrote2, ref handler))
			{
				return false;
			}
			wrote += wrote2;
		}
		if (span.Slice(wrote).Length < 1)
		{
			return false;
		}
		span[wrote++] = ')';
		return true;
	}

	public bool Equals(MethodSignature? other)
	{
		if (other == null)
		{
			return false;
		}
		if (this == other)
		{
			return true;
		}
		if (!ReturnType.Equals(other.ReturnType))
		{
			return false;
		}
		return Parameters.SequenceEqual(other.Parameters);
	}

	public override bool Equals(object? obj)
	{
		if (obj is MethodSignature other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		HashCode hashCode = default(HashCode);
		hashCode.Add(ReturnType);
		hashCode.Add(parameters.Length);
		Type[] array = parameters;
		foreach (Type value in array)
		{
			hashCode.Add(value);
		}
		return hashCode.ToHashCode();
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

private sealed class CompatableComparer : IEqualityComparer<Type>
{
	public static readonly CompatableComparer Instance = new CompatableComparer();

	public bool Equals(Type? x, Type? y)
	{
		if ((object)x == y)
		{
			return true;
		}
		if ((object)x == null || (object)y == null)
		{
			return false;
		}
		return x.IsCompatible(y);
	}

	public int GetHashCode([DisallowNull] Type obj)
	{
		throw new NotSupportedException();
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Mono.Cecil;
using MonoMod.Utils;

internal sealed class MMReflectionImporter : IReflectionImporter
{
	private class _Provider : IReflectionImporterProvider
	{
		public bool? UseDefault;

		public IReflectionImporter GetReflectionImporter(ModuleDefinition module)
		{
			Helpers.ThrowIfArgumentNull(module, "module");
			MMReflectionImporter mMReflectionImporter = new MMReflectionImporter(module);
			if (UseDefault.HasValue)
			{
				mMReflectionImporter.UseDefault = UseDefault.Value;
			}
			return mMReflectionImporter;
		}
	}

	private enum GenericImportKind
	{
		Open,
		Definition
	}

	public static readonly IReflectionImporterProvider Provider = new _Provider();

	public static readonly IReflectionImporterProvider ProviderNoDefault = new _Provider
	{
		UseDefault = false
	};

	private readonly ModuleDefinition Module;

	private readonly DefaultReflectionImporter Default;

	private readonly Dictionary<Assembly, AssemblyNameReference> CachedAsms = new Dictionary<Assembly, AssemblyNameReference>();

	private readonly Dictionary<Module, TypeReference> CachedModuleTypes = new Dictionary<Module, TypeReference>();

	private readonly Dictionary<Type, TypeReference> CachedTypes = new Dictionary<Type, TypeReference>();

	private readonly Dictionary<FieldInfo, FieldReference> CachedFields = new Dictionary<FieldInfo, FieldReference>();

	private readonly Dictionary<MethodBase, MethodReference> CachedMethods = new Dictionary<MethodBase, MethodReference>();

	private readonly Dictionary<Type, TypeReference> ElementTypes;

	public bool UseDefault { get; set; }

	public MMReflectionImporter(ModuleDefinition module)
	{
		Helpers.ThrowIfArgumentNull(module, "module");
		Module = module;
		Default = new DefaultReflectionImporter(module);
		ElementTypes = new Dictionary<Type, TypeReference>
		{
			{
				typeof(void),
				module.TypeSystem.Void
			},
			{
				typeof(bool),
				module.TypeSystem.Boolean
			},
			{
				typeof(char),
				module.TypeSystem.Char
			},
			{
				typeof(sbyte),
				module.TypeSystem.SByte
			},
			{
				typeof(byte),
				module.TypeSystem.Byte
			},
			{
				typeof(short),
				module.TypeSystem.Int16
			},
			{
				typeof(ushort),
				module.TypeSystem.UInt16
			},
			{
				typeof(int),
				module.TypeSystem.Int32
			},
			{
				typeof(uint),
				module.TypeSystem.UInt32
			},
			{
				typeof(long),
				module.TypeSystem.Int64
			},
			{
				typeof(ulong),
				module.TypeSystem.UInt64
			},
			{
				typeof(float),
				module.TypeSystem.Single
			},
			{
				typeof(double),
				module.TypeSystem.Double
			},
			{
				typeof(string),
				module.TypeSystem.String
			},
			{
				typeof(TypedReference),
				module.TypeSystem.TypedReference
			},
			{
				typeof(IntPtr),
				module.TypeSystem.IntPtr
			},
			{
				typeof(UIntPtr),
				module.TypeSystem.UIntPtr
			},
			{
				typeof(object),
				module.TypeSystem.Object
			}
		};
	}

	private bool TryGetCachedType(Type type, [MaybeNullWhen(false)] out TypeReference typeRef, GenericImportKind importKind)
	{
		if (importKind == GenericImportKind.Definition)
		{
			typeRef = null;
			return false;
		}
		return CachedTypes.TryGetValue(type, out typeRef);
	}

	private TypeReference SetCachedType(Type type, TypeReference typeRef, GenericImportKind importKind)
	{
		if (importKind == GenericImportKind.Definition)
		{
			return typeRef;
		}
		return CachedTypes[type] = typeRef;
	}

	[Obsolete("Please use the Assembly overload instead.")]
	public AssemblyNameReference ImportReference(AssemblyName reference)
	{
		Helpers.ThrowIfArgumentNull(reference, "reference");
		return Default.ImportReference(reference);
	}

	public AssemblyNameReference ImportReference(Assembly asm)
	{
		Helpers.ThrowIfArgumentNull(asm, "asm");
		if (CachedAsms.TryGetValue(asm, out AssemblyNameReference value))
		{
			return value;
		}
		value = Default.ImportReference(asm.GetName());
		value.ApplyRuntimeHash(asm);
		return CachedAsms[asm] = value;
	}

	public TypeReference ImportModuleType(Module module, IGenericParameterProvider? context)
	{
		Helpers.ThrowIfArgumentNull(module, "module");
		if (CachedModuleTypes.TryGetValue(module, out TypeReference value))
		{
			return value;
		}
		return CachedModuleTypes[module] = new TypeReference(string.Empty, "<Module>", Module, ImportReference(module.Assembly));
	}

	public TypeReference ImportReference(Type type, IGenericParameterProvider? context)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		return _ImportReference(type, context, (context == null) ? GenericImportKind.Definition : GenericImportKind.Open);
	}

	private static bool _IsGenericInstance(Type type, GenericImportKind importKind)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		if (!type.IsGenericType || type.IsGenericTypeDefinition)
		{
			if (type.IsGenericType && type.IsGenericTypeDefinition)
			{
				return importKind == GenericImportKind.Open;
			}
			return false;
		}
		return true;
	}

	private GenericInstanceType _ImportGenericInstance(Type type, IGenericParameterProvider? context, TypeReference typeRef)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		Helpers.ThrowIfArgumentNull(typeRef, "typeRef");
		GenericInstanceType genericInstanceType = new GenericInstanceType(typeRef);
		Type[] genericArguments = type.GetGenericArguments();
		foreach (Type type2 in genericArguments)
		{
			genericInstanceType.GenericArguments.Add(_ImportReference(type2, context));
		}
		return genericInstanceType;
	}

	private TypeReference _ImportReference(Type type, IGenericParameterProvider? context, GenericImportKind importKind = GenericImportKind.Open)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		if (TryGetCachedType(type, out TypeReference typeRef, importKind))
		{
			if (!_IsGenericInstance(type, importKind))
			{
				return typeRef;
			}
			return _ImportGenericInstance(type, context, typeRef);
		}
		if (UseDefault)
		{
			return SetCachedType(type, Default.ImportReference(type, context), importKind);
		}
		if (type.HasElementType)
		{
			if (type.IsByRef)
			{
				return SetCachedType(type, new ByReferenceType(_ImportReference(type.GetElementType(), context)), importKind);
			}
			if (type.IsPointer)
			{
				return SetCachedType(type, new PointerType(_ImportReference(type.GetElementType(), context)), importKind);
			}
			if (type.IsArray)
			{
				ArrayType arrayType = new ArrayType(_ImportReference(type.GetElementType(), context), type.GetArrayRank());
				if (type != type.GetElementType().MakeArrayType())
				{
					for (int i = 0; i < arrayType.Rank; i++)
					{
						arrayType.Dimensions[i] = new ArrayDimension(0, null);
					}
				}
				return CachedTypes[type] = arrayType;
			}
		}
		if (_IsGenericInstance(type, importKind))
		{
			return _ImportGenericInstance(type, context, _ImportReference(type.GetGenericTypeDefinition(), context, GenericImportKind.Definition));
		}
		if (type.IsGenericParameter)
		{
			return SetCachedType(type, ImportGenericParameter(type, context), importKind);
		}
		if (ElementTypes.TryGetValue(type, out typeRef))
		{
			return SetCachedType(type, typeRef, importKind);
		}
		typeRef = new TypeReference(string.Empty, type.Name, Module, ImportReference(type.Assembly), type.IsValueType);
		if (type.IsNested)
		{
			typeRef.DeclaringType = _ImportReference(type.DeclaringType, context, importKind);
		}
		else if (type.Namespace != null)
		{
			typeRef.Namespace = type.Namespace;
		}
		if (type.IsGenericType)
		{
			Type[] genericArguments = type.GetGenericArguments();
			foreach (Type type2 in genericArguments)
			{
				typeRef.GenericParameters.Add(new GenericParameter(type2.Name, typeRef));
			}
		}
		return SetCachedType(type, typeRef, importKind);
	}

	private static GenericParameter ImportGenericParameter(Type type, IGenericParameterProvider? context)
	{
		Helpers.ThrowIfArgumentNull(type, "type");
		if (context is MethodReference methodReference)
		{
			if (type.DeclaringMethod != null)
			{
				return methodReference.GenericParameters[type.GenericParameterPosition];
			}
			context = methodReference.DeclaringType;
		}
		Type minfo = type.DeclaringType ?? throw new InvalidOperationException();
		TypeReference typeReference = context as TypeReference;
		if (typeReference != null)
		{
			while (typeReference != null)
			{
				TypeReference elementType = typeReference.GetElementType();
				if (elementType.Is(minfo))
				{
					return elementType.GenericParameters[type.GenericParameterPosition];
				}
				if (typeReference.Is(minfo))
				{
					return typeReference.GenericParameters[type.GenericParameterPosition];
				}
				typeReference = typeReference.DeclaringType;
			}
		}
		throw new NotSupportedException();
	}

	public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider? context)
	{
		Helpers.ThrowIfArgumentNull(field, "field");
		if (CachedFields.TryGetValue(field, out FieldReference value))
		{
			return value;
		}
		if (UseDefault)
		{
			return CachedFields[field] = Default.ImportReference(field, context);
		}
		Type declaringType = field.DeclaringType;
		TypeReference typeReference = ((declaringType != null) ? ImportReference(declaringType, context) : ImportModuleType(field.Module, context));
		FieldInfo key = field;
		if (declaringType != null && declaringType.IsGenericType)
		{
			field = field.Module.ResolveField(field.MetadataToken);
		}
		TypeReference typeReference2 = _ImportReference(field.FieldType, typeReference);
		Type[] requiredCustomModifiers = field.GetRequiredCustomModifiers();
		Type[] optionalCustomModifiers = field.GetOptionalCustomModifiers();
		Type[] array = requiredCustomModifiers;
		foreach (Type type in array)
		{
			typeReference2 = new RequiredModifierType(_ImportReference(type, typeReference), typeReference2);
		}
		array = optionalCustomModifiers;
		foreach (Type type2 in array)
		{
			typeReference2 = new OptionalModifierType(_ImportReference(type2, typeReference), typeReference2);
		}
		return CachedFields[key] = new FieldReference(field.Name, typeReference2, typeReference);
	}

	public MethodReference ImportReference(MethodBase method, IGenericParameterProvider? context)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		return _ImportReference(method, context, (context == null) ? GenericImportKind.Definition : GenericImportKind.Open);
	}

	private MethodReference _ImportReference(MethodBase method, IGenericParameterProvider? context, GenericImportKind importKind)
	{
		Helpers.ThrowIfArgumentNull(method, "method");
		if (CachedMethods.TryGetValue(method, out MethodReference value) && importKind == GenericImportKind.Open)
		{
			return value;
		}
		if (method is MethodInfo methodInfo && methodInfo.IsDynamicMethod())
		{
			return new DynamicMethodReference(Module, methodInfo);
		}
		if (UseDefault)
		{
			return CachedMethods[method] = Default.ImportReference(method, context);
		}
		if ((method.IsGenericMethod && !method.IsGenericMethodDefinition) || (method.IsGenericMethod && method.IsGenericMethodDefinition && importKind == GenericImportKind.Open))
		{
			GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(_ImportReference(((MethodInfo)method).GetGenericMethodDefinition(), context, GenericImportKind.Definition));
			Type[] genericArguments = method.GetGenericArguments();
			foreach (Type type in genericArguments)
			{
				genericInstanceMethod.GenericArguments.Add(_ImportReference(type, context));
			}
			return CachedMethods[method] = genericInstanceMethod;
		}
		Type declaringType = method.DeclaringType;
		value = new MethodReference(method.Name, _ImportReference(typeof(void), context), (declaringType != null) ? _ImportReference(declaringType, context, GenericImportKind.Definition) : ImportModuleType(method.Module, context));
		value.HasThis = (method.CallingConvention & CallingConventions.HasThis) != 0;
		value.ExplicitThis = (method.CallingConvention & CallingConventions.ExplicitThis) != 0;
		if ((method.CallingConvention & CallingConventions.VarArgs) != 0)
		{
			value.CallingConvention = MethodCallingConvention.VarArg;
		}
		MethodBase key = method;
		if (declaringType != null && declaringType.IsGenericType)
		{
			method = method.Module.ResolveMethod(method.MetadataToken);
		}
		if (method.IsGenericMethodDefinition)
		{
			Type[] genericArguments = method.GetGenericArguments();
			foreach (Type type2 in genericArguments)
			{
				value.GenericParameters.Add(new GenericParameter(type2.Name, value));
			}
		}
		value.ReturnType = _ImportReference((method as MethodInfo)?.ReturnType ?? typeof(void), value);
		ParameterInfo[] parameters = method.GetParameters();
		foreach (ParameterInfo parameterInfo in parameters)
		{
			value.Parameters.Add(new ParameterDefinition(parameterInfo.Name, (Mono.Cecil.ParameterAttributes)parameterInfo.Attributes, _ImportReference(parameterInfo.ParameterType, value)));
		}
		return CachedMethods[key] = value;
	}
}


using Mono.Cecil;

private class _Provider : IReflectionImporterProvider
{
	public bool? UseDefault;

	public IReflectionImporter GetReflectionImporter(ModuleDefinition module)
	{
		Helpers.ThrowIfArgumentNull(module, "module");
		MMReflectionImporter mMReflectionImporter = new MMReflectionImporter(module);
		if (UseDefault.HasValue)
		{
			mMReflectionImporter.UseDefault = UseDefault.Value;
		}
		return mMReflectionImporter;
	}
}


private enum GenericImportKind
{
	Open,
	Definition
}


internal enum OSKind
{
	Unknown = 0,
	Posix = 1,
	Linux = 9,
	Android = 41,
	OSX = 5,
	IOS = 37,
	BSD = 17,
	Windows = 2,
	Wine = 34
}


using MonoMod.Utils;

internal static class OSKindExtensions
{
	public static bool Is(this OSKind operatingSystem, OSKind test)
	{
		return operatingSystem.Has(test);
	}

	public static OSKind GetKernel(this OSKind operatingSystem)
	{
		return operatingSystem & (OSKind)31;
	}

	public static int GetSubtypeId(this OSKind operatingSystem)
	{
		return (int)operatingSystem >> 5;
	}
}


using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using MonoMod;
using MonoMod.Utils;
using MonoMod.Utils.Interop;

internal static class PlatformDetection
{
	private static int platInitState;

	private static OSKind os;

	private static ArchitectureKind arch;

	private static int runtimeInitState;

	private static RuntimeKind runtime;

	private static Version? runtimeVersion;

	public static OSKind OS
	{
		get
		{
			EnsurePlatformInfoInitialized();
			return os;
		}
	}

	public static ArchitectureKind Architecture
	{
		get
		{
			EnsurePlatformInfoInitialized();
			return arch;
		}
	}

	public static RuntimeKind Runtime
	{
		get
		{
			EnsureRuntimeInitialized();
			return runtime;
		}
	}

	public static Version RuntimeVersion
	{
		get
		{
			EnsureRuntimeInitialized();
			return runtimeVersion;
		}
	}

	private static void EnsurePlatformInfoInitialized()
	{
		if (platInitState == 0)
		{
			(os, arch) = DetectPlatformInfo();
			Thread.MemoryBarrier();
			Interlocked.Exchange(ref platInitState, 1);
		}
	}

	private static (OSKind OS, ArchitectureKind Arch) DetectPlatformInfo()
	{
		OSKind oSKind = OSKind.Unknown;
		ArchitectureKind architectureKind = ArchitectureKind.Unknown;
		PropertyInfo property = typeof(Environment).GetProperty("Platform", BindingFlags.Static | BindingFlags.NonPublic);
		string self = ((!(property != null)) ? Environment.OSVersion.Platform.ToString() : property.GetValue(null, null)?.ToString())?.ToUpperInvariant() ?? "";
		if (System.StringExtensions.Contains(self, "WIN", StringComparison.Ordinal))
		{
			oSKind = OSKind.Windows;
		}
		else if (System.StringExtensions.Contains(self, "MAC", StringComparison.Ordinal) || System.StringExtensions.Contains(self, "OSX", StringComparison.Ordinal))
		{
			oSKind = OSKind.OSX;
		}
		else if (System.StringExtensions.Contains(self, "LIN", StringComparison.Ordinal))
		{
			oSKind = OSKind.Linux;
		}
		else if (System.StringExtensions.Contains(self, "BSD", StringComparison.Ordinal))
		{
			oSKind = OSKind.BSD;
		}
		else if (System.StringExtensions.Contains(self, "UNIX", StringComparison.Ordinal))
		{
			oSKind = OSKind.Posix;
		}
		if (oSKind == OSKind.Windows)
		{
			DetectInfoWindows(ref oSKind, ref architectureKind);
		}
		else if ((oSKind & OSKind.Posix) != 0)
		{
			DetectInfoPosix(ref oSKind, ref architectureKind);
		}
		if (oSKind != 0)
		{
			if (oSKind == OSKind.Linux && Directory.Exists("/data") && File.Exists("/system/build.prop"))
			{
				oSKind = OSKind.Android;
			}
			else if (oSKind == OSKind.Posix && Directory.Exists("/Applications") && Directory.Exists("/System") && Directory.Exists("/User") && !Directory.Exists("/Users"))
			{
				oSKind = OSKind.IOS;
			}
			else if (oSKind == OSKind.Windows && CheckWine())
			{
				oSKind = OSKind.Wine;
			}
		}
		bool isEnabled;
		MMDbgLog.DebugLogInfoStringHandler message = new MMDbgLog.DebugLogInfoStringHandler(16, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Platform info: ");
			message.AppendFormatted(oSKind);
			message.AppendLiteral(" ");
			message.AppendFormatted(architectureKind);
		}
		MMDbgLog.Info(ref message);
		return (OS: oSKind, Arch: architectureKind);
	}

	private unsafe static int PosixUname(OSKind os, byte* buf)
	{
		if (os != OSKind.OSX)
		{
			return Libc(buf);
		}
		return Osx(buf);
		unsafe static int Libc(byte* buf)
		{
			return Unix.Uname(buf);
		}
		unsafe static int Osx(byte* buf)
		{
			return OSX.Uname(buf);
		}
	}

	private unsafe static string GetCString(ReadOnlySpan<byte> buffer, out int nullByte)
	{
		fixed (byte* ptr = buffer)
		{
			return Marshal.PtrToStringAnsi((IntPtr)ptr, nullByte = buffer.IndexOf<byte>(0));
		}
	}

	private unsafe static void DetectInfoPosix(ref OSKind os, ref ArchitectureKind arch)
	{
		MMDbgLog.DebugLogErrorStringHandler message2;
		bool isEnabled;
		try
		{
			Span<byte> span = new byte[3078];
			fixed (byte* buf = span)
			{
				if (PosixUname(os, buf) < 0)
				{
					string message = new Win32Exception(Marshal.GetLastWin32Error()).Message;
					message2 = new MMDbgLog.DebugLogErrorStringHandler(24, 1, out isEnabled);
					if (isEnabled)
					{
						message2.AppendLiteral("uname() syscall failed! ");
						message2.AppendFormatted(message);
					}
					MMDbgLog.Error(ref message2);
					return;
				}
			}
			int nullByte;
			string text = GetCString(span, out nullByte).ToUpperInvariant();
			span = span.Slice(nullByte);
			MMDbgLog.DebugLogTraceStringHandler message3 = new MMDbgLog.DebugLogTraceStringHandler(22, 1, out isEnabled);
			if (isEnabled)
			{
				message3.AppendLiteral("uname() call returned ");
				message3.AppendFormatted(text);
			}
			MMDbgLog.Trace(ref message3);
			if (System.StringExtensions.Contains(text, "LINUX", StringComparison.Ordinal))
			{
				os = OSKind.Linux;
			}
			else if (System.StringExtensions.Contains(text, "DARWIN", StringComparison.Ordinal))
			{
				os = OSKind.OSX;
			}
			else if (System.StringExtensions.Contains(text, "BSD", StringComparison.Ordinal))
			{
				os = OSKind.BSD;
			}
			string text2;
			if (os == OSKind.Linux)
			{
				Span<Unix.LinuxAuxvEntry> span2 = MemoryMarshal.Cast<byte, Unix.LinuxAuxvEntry>(MemoryExtensions.AsSpan(Helpers.ReadAllBytes("/proc/self/auxv")));
				text2 = string.Empty;
				Span<Unix.LinuxAuxvEntry> span3 = span2;
				for (int i = 0; i < span3.Length; i++)
				{
					Unix.LinuxAuxvEntry linuxAuxvEntry = span3[i];
					if (linuxAuxvEntry.Key == 15)
					{
						text2 = Marshal.PtrToStringAnsi(linuxAuxvEntry.Value) ?? string.Empty;
						break;
					}
				}
				if (text2.Length == 0)
				{
					MMDbgLog.DebugLogWarningStringHandler message4 = new MMDbgLog.DebugLogWarningStringHandler(56, 1, out isEnabled);
					if (isEnabled)
					{
						message4.AppendLiteral("Auxv table did not inlcude useful AT_PLATFORM (0x");
						message4.AppendFormatted(15, "x");
						message4.AppendLiteral(") entry");
					}
					MMDbgLog.Warning(ref message4);
					span3 = span2;
					for (int i = 0; i < span3.Length; i++)
					{
						Unix.LinuxAuxvEntry linuxAuxvEntry2 = span3[i];
						message3 = new MMDbgLog.DebugLogTraceStringHandler(3, 2, out isEnabled);
						if (isEnabled)
						{
							message3.AppendFormatted(linuxAuxvEntry2.Key, "x16");
							message3.AppendLiteral(" = ");
							message3.AppendFormatted(linuxAuxvEntry2.Value, "x16");
						}
						MMDbgLog.Trace(ref message3);
					}
				}
				else
				{
					message3 = new MMDbgLog.DebugLogTraceStringHandler(43, 1, out isEnabled);
					if (isEnabled)
					{
						message3.AppendLiteral("Got architecture name ");
						message3.AppendFormatted(text2);
						message3.AppendLiteral(" from /proc/self/auxv");
					}
					MMDbgLog.Trace(ref message3);
				}
			}
			else
			{
				for (int j = 0; j < 4; j++)
				{
					if (j != 0)
					{
						nullByte = span.IndexOf<byte>(0);
						span = span.Slice(nullByte);
					}
					int k;
					for (k = 0; k < span.Length && span[k] == 0; k++)
					{
					}
					span = span.Slice(k);
				}
				text2 = GetCString(span, out var _);
				message3 = new MMDbgLog.DebugLogTraceStringHandler(35, 1, out isEnabled);
				if (isEnabled)
				{
					message3.AppendLiteral("Got architecture name ");
					message3.AppendFormatted(text2);
					message3.AppendLiteral(" from uname()");
				}
				MMDbgLog.Trace(ref message3);
			}
			text2 = text2.ToUpperInvariant();
			if (System.StringExtensions.Contains(text2, "X86_64", StringComparison.Ordinal))
			{
				arch = ArchitectureKind.x86_64;
			}
			else if (System.StringExtensions.Contains(text2, "AMD64", StringComparison.Ordinal))
			{
				arch = ArchitectureKind.x86_64;
			}
			else if (System.StringExtensions.Contains(text2, "X86", StringComparison.Ordinal))
			{
				arch = ArchitectureKind.x86;
			}
			else if (System.StringExtensions.Contains(text2, "AARCH64", StringComparison.Ordinal))
			{
				arch = ArchitectureKind.Arm64;
			}
			else if (System.StringExtensions.Contains(text2, "ARM64", StringComparison.Ordinal))
			{
				arch = ArchitectureKind.Arm64;
			}
			else if (System.StringExtensions.Contains(text2, "ARM", StringComparison.Ordinal))
			{
				arch = ArchitectureKind.Arm;
			}
			message3 = new MMDbgLog.DebugLogTraceStringHandler(37, 2, out isEnabled);
			if (isEnabled)
			{
				message3.AppendLiteral("uname() detected architecture info: ");
				message3.AppendFormatted(os);
				message3.AppendLiteral(" ");
				message3.AppendFormatted(arch);
			}
			MMDbgLog.Trace(ref message3);
		}
		catch (Exception value)
		{
			message2 = new MMDbgLog.DebugLogErrorStringHandler(49, 1, out isEnabled);
			if (isEnabled)
			{
				message2.AppendLiteral("Error trying to detect info on POSIX-like system ");
				message2.AppendFormatted(value);
			}
			MMDbgLog.Error(ref message2);
		}
	}

	private unsafe static void DetectInfoWindows(ref OSKind os, ref ArchitectureKind arch)
	{
		Windows.SYSTEM_INFO sYSTEM_INFO = default(Windows.SYSTEM_INFO);
		Windows.GetSystemInfo(&sYSTEM_INFO);
		ushort wProcessorArchitecture = sYSTEM_INFO.Anonymous.Anonymous.wProcessorArchitecture;
		arch = wProcessorArchitecture switch
		{
			9 => ArchitectureKind.x86_64, 
			6 => throw new PlatformNotSupportedException("You're running .NET on an Itanium device!?!?"), 
			0 => ArchitectureKind.x86, 
			5 => ArchitectureKind.Arm, 
			12 => ArchitectureKind.Arm64, 
			_ => throw new PlatformNotSupportedException($"Unknown Windows processor architecture {wProcessorArchitecture}"), 
		};
	}

	private unsafe static bool CheckWine()
	{
		if (Switches.TryGetSwitchEnabled("RunningOnWine", out var isEnabled))
		{
			return isEnabled;
		}
		string text = Environment.GetEnvironmentVariable("XL_WINEONLINUX")?.ToUpperInvariant();
		if (text == "TRUE")
		{
			return true;
		}
		if (text == "FALSE")
		{
			return false;
		}
		fixed (char* lpModuleName = "ntdll.dll")
		{
			Windows.HMODULE moduleHandleW = Windows.GetModuleHandleW((ushort*)lpModuleName);
			if (moduleHandleW != Windows.HMODULE.NULL && moduleHandleW != Windows.HMODULE.INVALID_VALUE)
			{
				fixed (byte* lpProcName = "wineGetVersion"u8)
				{
					if (Windows.GetProcAddress(moduleHandleW, (sbyte*)lpProcName) != IntPtr.Zero)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	[MemberNotNull("runtimeVersion")]
	private static void EnsureRuntimeInitialized()
	{
		if (runtimeInitState != 0)
		{
			if ((object)runtimeVersion == null)
			{
				throw new InvalidOperationException("Despite runtimeInitState being set, runtimeVersion was somehow null");
			}
		}
		else
		{
			(runtime, runtimeVersion) = DetermineRuntimeInfo();
			Thread.MemoryBarrier();
			Interlocked.Exchange(ref runtimeInitState, 1);
		}
	}

	private static (RuntimeKind Rt, Version Ver) DetermineRuntimeInfo()
	{
		Version version = null;
		bool flag = Type.GetType("Mono.Runtime") != null || Type.GetType("Mono.RuntimeStructs") != null;
		bool flag2 = typeof(object).Assembly.GetName().Name == "System.Private.CoreLib";
		RuntimeKind runtimeKind = (flag ? RuntimeKind.Mono : ((!flag2 || flag) ? RuntimeKind.Framework : RuntimeKind.CoreCLR));
		bool isEnabled;
		MMDbgLog.DebugLogTraceStringHandler message = new MMDbgLog.DebugLogTraceStringHandler(21, 2, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("IsMono: ");
			message.AppendFormatted(flag);
			message.AppendLiteral(", IsCoreBcl: ");
			message.AppendFormatted(flag2);
		}
		MMDbgLog.Trace(ref message);
		Version version2 = Environment.Version;
		message = new MMDbgLog.DebugLogTraceStringHandler(25, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("Returned system version: ");
			message.AppendFormatted(version2);
		}
		MMDbgLog.Trace(ref message);
		Type type = Type.GetType("System.Runtime.InteropServices.RuntimeInformation");
		if ((object)type == null)
		{
			type = Type.GetType("System.Runtime.InteropServices.RuntimeInformation, System.Runtime.InteropServices.RuntimeInformation");
		}
		string text = (string)type?.GetProperty("FrameworkDescription")?.GetValue(null, null);
		message = new MMDbgLog.DebugLogTraceStringHandler(22, 1, out isEnabled);
		if (isEnabled)
		{
			message.AppendLiteral("FrameworkDescription: ");
			message.AppendFormatted(text ?? "(null)");
		}
		MMDbgLog.Trace(ref message);
		if (text != null)
		{
			int length;
			if (text.StartsWith("Mono ", StringComparison.Ordinal))
			{
				runtimeKind = RuntimeKind.Mono;
				length = "Mono ".Length;
			}
			else if (text.StartsWith(".NET Core ", StringComparison.Ordinal))
			{
				runtimeKind = RuntimeKind.CoreCLR;
				length = ".NET Core ".Length;
			}
			else if (text.StartsWith(".NET Framework ", StringComparison.Ordinal))
			{
				runtimeKind = RuntimeKind.Framework;
				length = ".NET Framework ".Length;
			}
			else if (text.StartsWith(".NET ", StringComparison.Ordinal))
			{
				runtimeKind = RuntimeKind.CoreCLR;
				length = ".NET ".Length;
			}
			else
			{
				runtimeKind = RuntimeKind.Unknown;
				length = text.Length;
			}
			int num = text.IndexOfAny(new char[2] { ' ', '-' }, length);
			if (num < 0)
			{
				num = text.Length;
			}
			string version3 = text.Substring(length, num - length);
			try
			{
				version = new Version(version3);
			}
			catch (Exception value)
			{
				MMDbgLog.DebugLogErrorStringHandler message2 = new MMDbgLog.DebugLogErrorStringHandler(61, 2, out isEnabled);
				if (isEnabled)
				{
					message2.AppendLiteral("Invalid version string pulled from FrameworkDescription ('");
					message2.AppendFormatted(text);
					message2.AppendLiteral("') ");
					message2.AppendFormatted(value);
				}
				MMDbgLog.Error(ref message2);
			}
		}
		if (runtimeKind == RuntimeKind.Framework && (object)version == null)
		{
			version = version2;
		}
		MMDbgLog.DebugLogInfoStringHandler message3 = new MMDbgLog.DebugLogInfoStringHandler(19, 2, out isEnabled);
		if (isEnabled)
		{
			message3.AppendLiteral("Detected runtime: ");
			message3.AppendFormatted(runtimeKind);
			message3.AppendLiteral(" ");
			message3.AppendFormatted(version?.ToString() ?? "(null)");
		}
		MMDbgLog.Info(ref message3);
		return (Rt: runtimeKind, Ver: version ?? new Version(0, 0));
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using Mono.Cecil;
using MonoMod;
using MonoMod.Utils;

internal static class ReflectionHelper
{
	private delegate SignatureHelper GetUnmanagedSigHelperDelegate(Module? module, CallingConvention callConv, Type? returnType);

	private class CacheFixEntry
	{
		public object? Cache;

		public Array? Properties;

		public Array? Fields;

		public bool NeedsVerify;
	}

	internal static readonly bool IsCoreBCL;

	internal static readonly Dictionary<string, WeakReference> AssemblyCache;

	internal static readonly Dictionary<string, WeakReference[]> AssembliesCache;

	internal static readonly Dictionary<string, WeakReference> ResolveReflectionCache;

	public static readonly byte[] AssemblyHashPrefix;

	public static readonly string AssemblyHashNameTag;

	private const BindingFlags _BindingFlagsAll = (BindingFlags)(-1);

	private static readonly GetUnmanagedSigHelperDelegate GetUnmanagedSigHelper;

	private static readonly object?[] _CacheGetterArgs;

	private static Type t_RuntimeType;

	private static Type? t_RuntimeTypeCache;

	private static PropertyInfo? p_RuntimeType_Cache;

	private static MethodInfo? m_RuntimeTypeCache_GetFieldList;

	private static MethodInfo? m_RuntimeTypeCache_GetPropertyList;

	private static readonly ConditionalWeakTable<Type, CacheFixEntry> _CacheFixed;

	private static Type? t_RuntimeModule;

	private static PropertyInfo? p_RuntimeModule_RuntimeType;

	private static FieldInfo? f_RuntimeModule__impl;

	private static MethodInfo? m_RuntimeModule_GetGlobalType;

	private static readonly FieldInfo? f_SignatureHelper_module;

	private static MemberInfo _Cache(string cacheKey, MemberInfo value)
	{
		if (cacheKey != null && value == null)
		{
			bool isEnabled;
			MMDbgLog.DebugLogErrorStringHandler message = new MMDbgLog.DebugLogErrorStringHandler(21, 1, out isEnabled);
			if (isEnabled)
			{
				message.AppendLiteral("ResolveRefl failure: ");
				message.AppendFormatted(cacheKey);
			}
			MMDbgLog.Error(ref message);
		}
		if (cacheKey != null && value != null)
		{
			lock (ResolveReflectionCache)
			{
				ResolveReflectionCache[cacheKey] = new WeakReference(value);
			}
		}
		return value;
	}

	public static Assembly Load(ModuleDefinition module)
	{
		Helpers.ThrowIfArgumentNull(module, "module");
		using MemoryStream memoryStream = new MemoryStream();
		module.Write(memoryStream);
		memoryStream.Seek(0L, SeekOrigin.Begin);
		return Load(memoryStream);
	}

	public static Assembly Load(Stream stream)
	{
		Helpers.ThrowIfArgumentNull(stream, "stream");
		Assembly asm;
		if (stream is MemoryStream memoryStream)
		{
			asm = Assembly.Load(memoryStream.GetBuffer());
		}
		else
		{
			using MemoryStream memoryStream2 = new MemoryStream();
			stream.CopyTo(memoryStream2);
			memoryStream2.Seek(0L, SeekOrigin.Begin);
			asm = Assembly.Load(memoryStream2.GetBuffer());
		}
		AppDomain.CurrentDomain.AssemblyResolve += (object s, ResolveEventArgs e) => (!(e.Name == asm.FullName)) ? null : asm;
		return asm;
	}

	public static Type? GetType(string name)
	{
		if (string.IsNullOrEmpty(name))
		{
			return null;
		}
		Type type = Type.GetType(name);
		if (type != null)
		{
			return type;
		}
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		for (int i = 0; i < assemblies.Length; i++)
		{
			type = assemblies[i].GetType(name);
			if (type != null)
			{
				return type;
			}
		}
		return null;
	}

	public static void ApplyRuntimeHash(this AssemblyNameReference asmRef, Assembly asm)
	{
		Helpers.ThrowIfArgumentNull(asmRef, "asmRef");
		Helpers.ThrowIfArgumentNull(asm, "asm");
		byte[] array = new byte[AssemblyHashPrefix.Length + 4];
		Array.Copy(AssemblyHashPrefix, 0, array, 0, AssemblyHashPrefix.Length);
		Array.Copy(BitConverter.GetBytes(asm.GetHashCode()), 0, array, AssemblyHashPrefix.Length, 4);
		asmRef.HashAlgorithm = (AssemblyHashAlgorithm)4294967295u;
		asmRef.Hash = array;
	}

	public static string GetRuntimeHashedFullName(this Assembly asm)
	{
		Helpers.ThrowIfArgumentNull(asm, "asm");
		return $"{asm.FullName}{AssemblyHashNameTag}{asm.GetHashCode()}";
	}

	public static string GetRuntimeHashedFullName(this AssemblyNameReference asm)
	{
		Helpers.ThrowIfArgumentNull(asm, "asm");
		if (asm.HashAlgorithm != (AssemblyHashAlgorithm)4294967295u)
		{
			return asm.FullName;
		}
		byte[] hash = asm.Hash;
		if (hash.Length != AssemblyHashPrefix.Length + 4)
		{
			return asm.FullName;
		}
		for (int i = 0; i < AssemblyHashPrefix.Length; i++)
		{
			if (hash[i] != AssemblyHashPrefix[i])
			{
				return asm.FullName;
			}
		}
		return $"{asm.FullName}{AssemblyHashNameTag}{BitConverter.ToInt32(hash, AssemblyHashPrefix.Length)}";
	}

	public static Type ResolveReflection(this TypeReference mref)
	{
		return (Type)_ResolveReflection(mref, null);
	}

	public static MethodBase ResolveReflection(this MethodReference mref)
	{
		return (MethodBase)_ResolveReflection(mref, null);
	}

	public static FieldInfo ResolveReflection(this FieldReference mref)
	{
		return (FieldInfo)_ResolveReflection(mref, null);
	}

	public static PropertyInfo ResolveReflection(this PropertyReference mref)
	{
		return (PropertyInfo)_ResolveReflection(mref, null);
	}

	public static EventInfo ResolveReflection(this EventReference mref)
	{
		return (EventInfo)_ResolveReflection(mref, null);
	}

	public static MemberInfo ResolveReflection(this MemberReference mref)
	{
		return _ResolveReflection(mref, null);
	}

	[return: NotNullIfNotNull("mref")]
	private static MemberInfo? _ResolveReflection(MemberReference? mref, Module[]? modules)
	{
		if (mref == null)
		{
			return null;
		}
		if (mref is DynamicMethodReference dynamicMethodReference)
		{
			return dynamicMethodReference.DynamicMethod;
		}
		string value = (mref as MethodReference)?.GetID() ?? mref.FullName;
		TypeReference typeReference = mref.DeclaringType ?? (mref as TypeReference) ?? null;
		IMetadataScope metadataScope = typeReference?.Scope;
		string asmName;
		string moduleName;
		if (!(metadataScope is AssemblyNameReference asm2))
		{
			if (!(metadataScope is ModuleDefinition moduleDefinition))
			{
				if (!(metadataScope is ModuleReference))
				{
					if (metadataScope != null)
					{
					}
					asmName = null;
					moduleName = null;
				}
				else
				{
					asmName = typeReference.Module.Assembly.Name.GetRuntimeHashedFullName();
					moduleName = typeReference.Module.Name;
				}
			}
			else
			{
				asmName = moduleDefinition.Assembly.Name.GetRuntimeHashedFullName();
				moduleName = moduleDefinition.Name;
			}
		}
		else
		{
			asmName = asm2.GetRuntimeHashedFullName();
			moduleName = null;
		}
		value = $"{value} | {asmName ?? "NOASSEMBLY"}, {moduleName ?? "NOMODULE"}";
		lock (ResolveReflectionCache)
		{
			if (ResolveReflectionCache.TryGetValue(value, out WeakReference value2) && value2 != null && value2.SafeGetTarget() is MemberInfo result)
			{
				return result;
			}
		}
		if (mref is GenericParameter)
		{
			throw new NotSupportedException("ResolveReflection on GenericParameter currently not supported");
		}
		if (mref is MethodReference method && mref.DeclaringType is ArrayType)
		{
			Type type = (Type)_ResolveReflection(mref.DeclaringType, modules);
			string methodID = method.GetID(null, null, withType: false);
			MethodBase methodBase = type.GetMethods((BindingFlags)(-1)).Cast<MethodBase>().Concat(type.GetConstructors((BindingFlags)(-1)))
				.FirstOrDefault((MethodBase m) => m.GetID(null, null, withType: false) == methodID);
			if (methodBase != null)
			{
				return _Cache(value, methodBase);
			}
		}
		if (typeReference == null)
		{
			throw new ArgumentException("MemberReference hasn't got a DeclaringType / isn't a TypeReference in itself");
		}
		if (asmName == null && moduleName == null)
		{
			throw new NotSupportedException("Unsupported scope type " + typeReference.Scope.GetType().FullName);
		}
		bool flag = true;
		bool flag2 = false;
		bool flag3 = false;
		MemberInfo memberInfo;
		while (true)
		{
			if (flag3)
			{
				modules = null;
			}
			flag3 = true;
			if (modules == null)
			{
				Assembly[] array = null;
				if (flag && flag2)
				{
					flag2 = false;
					flag = false;
				}
				if (flag)
				{
					lock (AssemblyCache)
					{
						if (AssemblyCache.TryGetValue(asmName, out WeakReference value3) && value3.SafeGetTarget() is Assembly assembly)
						{
							array = new Assembly[1] { assembly };
						}
					}
				}
				if (array == null && !flag2)
				{
					lock (AssembliesCache)
					{
						if (AssembliesCache.TryGetValue(asmName, out WeakReference[] value4))
						{
							array = (from asmRef in value4
								select asmRef.SafeGetTarget() as Assembly into asm
								where asm != null
								select asm).ToArray();
						}
					}
				}
				if (array == null)
				{
					int num = asmName.IndexOf(AssemblyHashNameTag, StringComparison.Ordinal);
					if (num != -1 && int.TryParse(asmName.Substring(num + 2), out var hash))
					{
						array = (from other in AppDomain.CurrentDomain.GetAssemblies()
							where other.GetHashCode() == hash
							select other).ToArray();
						if (array.Length == 0)
						{
							array = null;
						}
						asmName = asmName.Substring(0, num);
					}
					if (array == null)
					{
						array = (from other in AppDomain.CurrentDomain.GetAssemblies()
							where other.GetName().FullName == asmName
							select other).ToArray();
						if (array.Length == 0)
						{
							array = (from other in AppDomain.CurrentDomain.GetAssemblies()
								where other.GetName().Name == asmName
								select other).ToArray();
						}
						if (array.Length == 0)
						{
							Assembly assembly2 = Assembly.Load(new AssemblyName(asmName));
							if ((object)assembly2 != null)
							{
								array = new Assembly[1] { assembly2 };
							}
						}
					}
					if (array.Length != 0)
					{
						lock (AssembliesCache)
						{
							AssembliesCache[asmName] = array.Select((Assembly asm) => new WeakReference(asm)).ToArray();
						}
					}
				}
				modules = (string.IsNullOrEmpty(moduleName) ? array.SelectMany((Assembly asm) => asm.GetModules()) : array.Select((Assembly asm) => asm.GetModule(moduleName))).Where((Module mod) => mod != null).ToArray();
				if (modules.Length == 0)
				{
					throw new MissingMemberException("Cannot resolve assembly / module " + asmName + " / " + moduleName);
				}
			}
			if (mref is TypeReference typeReference2)
			{
				if (typeReference2.FullName == "<Module>")
				{
					throw new ArgumentException("Type <Module> cannot be resolved to a runtime reflection type");
				}
				Type type;
				if (mref is TypeSpecification typeSpecification)
				{
					type = (Type)_ResolveReflection(typeSpecification.ElementType, null);
					if (typeSpecification.IsByReference)
					{
						return _Cache(value, type.MakeByRefType());
					}
					if (typeSpecification.IsPointer)
					{
						return _Cache(value, type.MakePointerType());
					}
					if (typeSpecification.IsArray)
					{
						return _Cache(value, ((ArrayType)typeSpecification).IsVector ? type.MakeArrayType() : type.MakeArrayType(((ArrayType)typeSpecification).Dimensions.Count));
					}
					if (typeSpecification.IsGenericInstance)
					{
						return _Cache(value, type.MakeGenericType(((GenericInstanceType)typeSpecification).GenericArguments.Select((TypeReference arg) => _ResolveReflection(arg, null) as Type).ToArray()));
					}
				}
				else
				{
					type = modules.Select((Module module) => module.GetType(System.StringExtensions.Replace(mref.FullName, "/", "+", StringComparison.Ordinal), throwOnError: false, ignoreCase: false)).FirstOrDefault((Type m) => m != null);
					if (type == null)
					{
						type = modules.Select((Module module) => module.GetTypes().FirstOrDefault((Type m) => mref.Is(m))).FirstOrDefault((Type m) => m != null);
					}
					if (type == null && !flag2)
					{
						goto IL_02cc;
					}
				}
				return _Cache(value, type);
			}
			bool flag4 = mref.DeclaringType?.FullName == "<Module>";
			if (mref is GenericInstanceMethod genericInstanceMethod)
			{
				memberInfo = _ResolveReflection(genericInstanceMethod.ElementMethod, modules);
				memberInfo = (memberInfo as MethodInfo)?.MakeGenericMethod(genericInstanceMethod.GenericArguments.Select((TypeReference arg) => _ResolveReflection(arg, null) as Type).ToArray());
			}
			else if (flag4)
			{
				if (mref is MethodReference)
				{
					memberInfo = modules.Select((Module module) => module.GetMethods((BindingFlags)(-1)).FirstOrDefault((MethodInfo m) => mref.Is(m))).FirstOrDefault((MethodInfo m) => m != null);
				}
				else
				{
					if (!(mref is FieldReference))
					{
						throw new NotSupportedException("Unsupported <Module> member type " + mref.GetType().FullName);
					}
					memberInfo = modules.Select((Module module) => module.GetFields((BindingFlags)(-1)).FirstOrDefault((FieldInfo m) => mref.Is(m))).FirstOrDefault((FieldInfo m) => m != null);
				}
			}
			else
			{
				Type type2 = (Type)_ResolveReflection(mref.DeclaringType, modules);
				memberInfo = ((mref is MethodReference) ? type2.GetMethods((BindingFlags)(-1)).Cast<MethodBase>().Concat(type2.GetConstructors((BindingFlags)(-1)))
					.FirstOrDefault((MethodBase m) => mref.Is(m)) : ((!(mref is FieldReference)) ? type2.GetMembers((BindingFlags)(-1)).FirstOrDefault((MemberInfo m) => mref.Is(m)) : type2.GetFields((BindingFlags)(-1)).FirstOrDefault((FieldInfo m) => mref.Is(m))));
			}
			if (!(memberInfo == null) || flag2)
			{
				break;
			}
			goto IL_02cc;
			IL_02cc:
			flag2 = true;
		}
		return _Cache(value, memberInfo);
	}

	public static SignatureHelper ResolveReflection(this Mono.Cecil.CallSite csite, Module context)
	{
		return csite.ResolveReflectionSignature(context);
	}

	public static SignatureHelper ResolveReflectionSignature(this IMethodSignature csite, Module context)
	{
		Helpers.ThrowIfArgumentNull(csite, "csite");
		Helpers.ThrowIfArgumentNull(context, "context");
		SignatureHelper signatureHelper = csite.CallingConvention switch
		{
			MethodCallingConvention.C => GetUnmanagedSigHelper(context, CallingConvention.Cdecl, csite.ReturnType.ResolveReflection()), 
			MethodCallingConvention.StdCall => GetUnmanagedSigHelper(context, CallingConvention.StdCall, csite.ReturnType.ResolveReflection()), 
			MethodCallingConvention.ThisCall => GetUnmanagedSigHelper(context, CallingConvention.ThisCall, csite.ReturnType.ResolveReflection()), 
			MethodCallingConvention.FastCall => GetUnmanagedSigHelper(context, CallingConvention.FastCall, csite.ReturnType.ResolveReflection()), 
			MethodCallingConvention.VarArg => SignatureHelper.GetMethodSigHelper(context, CallingConventions.VarArgs, csite.ReturnType.ResolveReflection()), 
			_ => (!csite.ExplicitThis) ? SignatureHelper.GetMethodSigHelper(context, CallingConventions.Standard, csite.ReturnType.ResolveReflection()) : SignatureHelper.GetMethodSigHelper(context, CallingConventions.ExplicitThis, csite.ReturnType.ResolveReflection()), 
		};
		if (context != null)
		{
			List<Type> list = new List<Type>();
			List<Type> list2 = new List<Type>();
			foreach (ParameterDefinition parameter in csite.Parameters)
			{
				if (parameter.ParameterType.IsSentinel)
				{
					signatureHelper.AddSentinel();
				}
				if (parameter.ParameterType.IsPinned)
				{
					signatureHelper.AddArgument(parameter.ParameterType.ResolveReflection(), pinned: true);
					continue;
				}
				list2.Clear();
				list.Clear();
				for (TypeReference typeReference = parameter.ParameterType; typeReference is TypeSpecification typeSpecification; typeReference = typeSpecification.ElementType)
				{
					if (!(typeReference is RequiredModifierType requiredModifierType))
					{
						if (typeReference is OptionalModifierType optionalModifierType)
						{
							list2.Add(optionalModifierType.ModifierType.ResolveReflection());
						}
					}
					else
					{
						list.Add(requiredModifierType.ModifierType.ResolveReflection());
					}
				}
				signatureHelper.AddArgument(parameter.ParameterType.ResolveReflection(), list.ToArray(), list2.ToArray());
			}
		}
		else
		{
			foreach (ParameterDefinition parameter2 in csite.Parameters)
			{
				signatureHelper.AddArgument(parameter2.ParameterType.ResolveReflection());
			}
		}
		return signatureHelper;
	}

	static ReflectionHelper()
	{
		IsCoreBCL = typeof(object).Assembly.GetName().Name == "System.Private.CoreLib";
		AssemblyCache = new Dictionary<string, WeakReference>();
		AssembliesCache = new Dictionary<string, WeakReference[]>();
		ResolveReflectionCache = new Dictionary<string, WeakReference>();
		AssemblyHashPrefix = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false).GetBytes("MonoModRefl").Concat(new byte[1]).ToArray();
		AssemblyHashNameTag = "@#";
		GetUnmanagedSigHelper = SignatureHelper.GetMethodSigHelper;
		_CacheGetterArgs = new object[2] { 0, null };
		t_RuntimeType = typeof(Type).Assembly.GetType("System.RuntimeType") ?? throw new InvalidOperationException("Could not find RuntimeType");
		t_RuntimeTypeCache = t_RuntimeType.GetNestedType("RuntimeTypeCache", BindingFlags.Public | BindingFlags.NonPublic);
		p_RuntimeType_Cache = ((t_RuntimeTypeCache == null) ? null : t_RuntimeType?.GetProperty("Cache", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, t_RuntimeTypeCache, Type.EmptyTypes, null));
		m_RuntimeTypeCache_GetFieldList = t_RuntimeTypeCache?.GetMethod("GetFieldList", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		m_RuntimeTypeCache_GetPropertyList = t_RuntimeTypeCache?.GetMethod("GetPropertyList", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		_CacheFixed = new ConditionalWeakTable<Type, CacheFixEntry>();
		t_RuntimeModule = typeof(Module).Assembly.GetType("System.Reflection.RuntimeModule");
		p_RuntimeModule_RuntimeType = typeof(Module).Assembly.GetType("System.Reflection.RuntimeModule")?.GetProperty("RuntimeType", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		f_RuntimeModule__impl = typeof(Module).Assembly.GetType("System.Reflection.RuntimeModule")?.GetField("_impl", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		m_RuntimeModule_GetGlobalType = typeof(Module).Assembly.GetType("System.Reflection.RuntimeModule")?.GetMethod("GetGlobalType", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		f_SignatureHelper_module = typeof(SignatureHelper).GetField("m_module", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) ?? typeof(SignatureHelper).GetField("module", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	public static void FixReflectionCacheAuto(this Type type)
	{
		type.FixReflectionCache();
	}

	public static void FixReflectionCache(this Type? type)
	{
		if (t_RuntimeType == null || p_RuntimeType_Cache == null || m_RuntimeTypeCache_GetFieldList == null || m_RuntimeTypeCache_GetPropertyList == null)
		{
			return;
		}
		while (type != null)
		{
			if (t_RuntimeType.IsInstanceOfType(type))
			{
				CacheFixEntry value = _CacheFixed.GetValue(type, delegate(Type rt)
				{
					CacheFixEntry cacheFixEntry = new CacheFixEntry();
					object cache = (cacheFixEntry.Cache = p_RuntimeType_Cache.GetValue(rt, ArrayEx.Empty<object>()));
					Array orig = (cacheFixEntry.Properties = _GetArray(cache, m_RuntimeTypeCache_GetPropertyList));
					Array orig2 = (cacheFixEntry.Fields = _GetArray(cache, m_RuntimeTypeCache_GetFieldList));
					_FixReflectionCacheOrder<PropertyInfo>(orig);
					_FixReflectionCacheOrder<FieldInfo>(orig2);
					cacheFixEntry.NeedsVerify = false;
					return cacheFixEntry;
				});
				if (value.NeedsVerify && !_Verify(value, type))
				{
					lock (value)
					{
						_FixReflectionCacheOrder<PropertyInfo>(value.Properties);
						_FixReflectionCacheOrder<FieldInfo>(value.Fields);
					}
				}
				value.NeedsVerify = true;
			}
			type = type.DeclaringType;
		}
	}

	private static bool _Verify(CacheFixEntry entry, Type type)
	{
		object value;
		if (entry.Cache != (value = p_RuntimeType_Cache.GetValue(type, ArrayEx.Empty<object>())))
		{
			entry.Cache = value;
			entry.Properties = _GetArray(value, m_RuntimeTypeCache_GetPropertyList);
			entry.Fields = _GetArray(value, m_RuntimeTypeCache_GetFieldList);
			return false;
		}
		Array properties;
		if (entry.Properties != (properties = _GetArray(value, m_RuntimeTypeCache_GetPropertyList)))
		{
			entry.Properties = properties;
			entry.Fields = _GetArray(value, m_RuntimeTypeCache_GetFieldList);
			return false;
		}
		Array fields;
		if (entry.Fields != (fields = _GetArray(value, m_RuntimeTypeCache_GetFieldList)))
		{
			entry.Fields = fields;
			return false;
		}
		return true;
	}

	private static Array _GetArray(object? cache, MethodInfo getter)
	{
		getter.Invoke(cache, _CacheGetterArgs);
		object obj = getter.Invoke(cache, _CacheGetterArgs);
		if (obj is Array result)
		{
			return result;
		}
		Type returnType = getter.ReturnType;
		if ((object)returnType != null && returnType.Namespace == "System.Reflection" && returnType.Name == "CerArrayList`1")
		{
			return (Array)returnType.GetField("m_array", (BindingFlags)(-1)).GetValue(obj);
		}
		throw new InvalidOperationException($"Unknown reflection cache type {obj.GetType()}");
	}

	private static void _FixReflectionCacheOrder<T>(Array? orig) where T : MemberInfo
	{
		if (orig == null)
		{
			return;
		}
		List<T> list = new List<T>(orig.Length);
		for (int i = 0; i < orig.Length; i++)
		{
			list.Add((T)orig.GetValue(i));
		}
		list.Sort(delegate(T? a, T? b)
		{
			if (a == b)
			{
				return 0;
			}
			if ((object)a == null)
			{
				return 1;
			}
			return ((object)b == null) ? (-1) : (a.MetadataToken - b.MetadataToken);
		});
		for (int num = orig.Length - 1; num >= 0; num--)
		{
			orig.SetValue(list[num], num);
		}
	}

	public static Type? GetModuleType(this Module? module)
	{
		if (module == null || t_RuntimeModule == null || !t_RuntimeModule.IsInstanceOfType(module))
		{
			return null;
		}
		if (p_RuntimeModule_RuntimeType != null)
		{
			return (Type)p_RuntimeModule_RuntimeType.GetValue(module, ArrayEx.Empty<object>());
		}
		if (f_RuntimeModule__impl != null && m_RuntimeModule_GetGlobalType != null)
		{
			return (Type)m_RuntimeModule_GetGlobalType.Invoke(null, new object[1] { f_RuntimeModule__impl.GetValue(module) });
		}
		return null;
	}

	public static Type? GetRealDeclaringType(this MemberInfo member)
	{
		Type? type = Helpers.ThrowIfNull(member, "member").DeclaringType;
		if ((object)type == null)
		{
			Module module = member.Module;
			if ((object)module == null)
			{
				return null;
			}
			type = module.GetModuleType();
		}
		return type;
	}

	private static Module GetSignatureHelperModule(SignatureHelper signature)
	{
		if (f_SignatureHelper_module == null)
		{
			throw new InvalidOperationException("Unable to find module field for SignatureHelper");
		}
		return (Module)f_SignatureHelper_module.GetValue(signature);
	}

	public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, ICallSiteGenerator signature)
	{
		return Helpers.ThrowIfNull(signature, "signature").ToCallSite(moduleTo);
	}

	public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, SignatureHelper signature)
	{
		return Helpers.ThrowIfNull(moduleTo, "moduleTo").ImportCallSite(GetSignatureHelperModule(signature), Helpers.ThrowIfNull(signature, "signature").GetSignature());
	}

	public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, Module moduleFrom, int token)
	{
		return Helpers.ThrowIfNull(moduleTo, "moduleTo").ImportCallSite(moduleFrom, Helpers.ThrowIfNull(moduleFrom, "moduleFrom").ResolveSignature(token));
	}

	public static Mono.Cecil.CallSite ImportCallSite(this ModuleDefinition moduleTo, Module moduleFrom, byte[] data)
	{
		Helpers.ThrowIfArgumentNull(moduleTo, "moduleTo");
		Helpers.ThrowIfArgumentNull(moduleFrom, "moduleFrom");
		Helpers.ThrowIfArgumentNull(data, "data");
		Mono.Cecil.CallSite callSite = new Mono.Cecil.CallSite(moduleTo.TypeSystem.Void);
		BinaryReader reader;
		using (MemoryStream input = new MemoryStream(data, writable: false))
		{
			reader = new BinaryReader(input);
			try
			{
				ReadMethodSignature(callSite);
				return callSite;
			}
			finally
			{
				if (reader != null)
				{
					((IDisposable)reader).Dispose();
				}
			}
			void ReadMethodSignature(IMethodSignature method)
			{
				byte b = reader.ReadByte();
				if ((b & 0x20) != 0)
				{
					method.HasThis = true;
					b = (byte)(b & -33);
				}
				if ((b & 0x40) != 0)
				{
					method.ExplicitThis = true;
					b = (byte)(b & -65);
				}
				method.CallingConvention = (MethodCallingConvention)b;
				if ((b & 0x10) != 0)
				{
					ReadCompressedUInt32();
				}
				uint num = ReadCompressedUInt32();
				method.MethodReturnType.ReturnType = ReadTypeSignature();
				for (int i = 0; i < num; i++)
				{
					method.Parameters.Add(new ParameterDefinition(ReadTypeSignature()));
				}
			}
		}
		TypeReference GetTypeDefOrRef()
		{
			uint num4 = ReadCompressedUInt32();
			uint num5 = num4 >> 2;
			return moduleTo.ImportReference(moduleFrom.ResolveType((num4 & 3) switch
			{
				0u => (int)(0x2000000 | num5), 
				1u => (int)(0x1000000 | num5), 
				2u => (int)(0x1B000000 | num5), 
				_ => 0, 
			}));
		}
		int ReadCompressedInt32()
		{
			byte b3 = reader.ReadByte();
			reader.BaseStream.Seek(-1L, SeekOrigin.Current);
			uint num6 = ReadCompressedUInt32();
			int num7 = (int)num6 >> 1;
			if ((num6 & 1) == 0)
			{
				return num7;
			}
			switch (b3 & 0xC0)
			{
			case 0:
			case 64:
				return num7 - 64;
			case 128:
				return num7 - 8192;
			default:
				return num7 - 268435456;
			}
		}
		uint ReadCompressedUInt32()
		{
			byte b2 = reader.ReadByte();
			if ((b2 & 0x80) == 0)
			{
				return b2;
			}
			if ((b2 & 0x40) == 0)
			{
				return (uint)(((b2 & -129) << 8) | reader.ReadByte());
			}
			return (uint)(((b2 & -193) << 24) | (reader.ReadByte() << 16) | (reader.ReadByte() << 8) | reader.ReadByte());
		}
		TypeReference ReadTypeSignature()
		{
			MetadataType metadataType = (MetadataType)reader.ReadByte();
			switch (metadataType)
			{
			case MetadataType.ValueType:
			case MetadataType.Class:
				return GetTypeDefOrRef();
			case MetadataType.Pointer:
				return new PointerType(ReadTypeSignature());
			case MetadataType.FunctionPointer:
			{
				FunctionPointerType functionPointerType = new FunctionPointerType();
				ReadMethodSignature(functionPointerType);
				return functionPointerType;
			}
			case MetadataType.ByReference:
				return new ByReferenceType(ReadTypeSignature());
			case MetadataType.Pinned:
				return new PinnedType(ReadTypeSignature());
			case (MetadataType)29:
				return new ArrayType(ReadTypeSignature());
			case MetadataType.Array:
			{
				ArrayType arrayType = new ArrayType(ReadTypeSignature());
				uint num2 = ReadCompressedUInt32();
				uint[] array = new uint[ReadCompressedUInt32()];
				for (int j = 0; j < array.Length; j++)
				{
					array[j] = ReadCompressedUInt32();
				}
				int[] array2 = new int[ReadCompressedUInt32()];
				for (int k = 0; k < array2.Length; k++)
				{
					array2[k] = ReadCompressedInt32();
				}
				arrayType.Dimensions.Clear();
				for (int l = 0; l < num2; l++)
				{
					int? num3 = null;
					int? upperBound = null;
					if (l < array2.Length)
					{
						num3 = array2[l];
					}
					if (l < array.Length)
					{
						upperBound = num3 + (int)array[l] - 1;
					}
					arrayType.Dimensions.Add(new ArrayDimension(num3, upperBound));
				}
				return arrayType;
			}
			case MetadataType.OptionalModifier:
				return new OptionalModifierType(GetTypeDefOrRef(), ReadTypeSignature());
			case MetadataType.RequiredModifier:
				return new RequiredModifierType(GetTypeDefOrRef(), ReadTypeSignature());
			case MetadataType.Sentinel:
				return new SentinelType(ReadTypeSignature());
			case MetadataType.Var:
			case MetadataType.GenericInstance:
			case MetadataType.MVar:
				throw new NotSupportedException($"Unsupported generic callsite element: {metadataType}");
			case MetadataType.Object:
				return moduleTo.TypeSystem.Object;
			case MetadataType.Void:
				return moduleTo.TypeSystem.Void;
			case MetadataType.TypedByReference:
				return moduleTo.TypeSystem.TypedReference;
			case MetadataType.IntPtr:
				return moduleTo.TypeSystem.IntPtr;
			case MetadataType.UIntPtr:
				return moduleTo.TypeSystem.UIntPtr;
			case MetadataType.Boolean:
				return moduleTo.TypeSystem.Boolean;
			case MetadataType.Char:
				return moduleTo.TypeSystem.Char;
			case MetadataType.SByte:
				return moduleTo.TypeSystem.SByte;
			case MetadataType.Byte:
				return moduleTo.TypeSystem.Byte;
			case MetadataType.Int16:
				return moduleTo.TypeSystem.Int16;
			case MetadataType.UInt16:
				return moduleTo.TypeSystem.UInt16;
			case MetadataType.Int32:
				return moduleTo.TypeSystem.Int32;
			case MetadataType.UInt32:
				return moduleTo.TypeSystem.UInt32;
			case MetadataType.Int64:
				return moduleTo.TypeSystem.Int64;
			case MetadataType.UInt64:
				return moduleTo.TypeSystem.UInt64;
			case MetadataType.Single:
				return moduleTo.TypeSystem.Single;
			case MetadataType.Double:
				return moduleTo.TypeSystem.Double;
			case MetadataType.String:
				return moduleTo.TypeSystem.String;
			default:
				throw new NotSupportedException($"Unsupported callsite element: {metadataType}");
			}
		}
	}
}


using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

private delegate SignatureHelper GetUnmanagedSigHelperDelegate(Module? module, CallingConvention callConv, Type? returnType);


using System;

private class CacheFixEntry
{
	public object? Cache;

	public Array? Properties;

	public Array? Fields;

	public bool NeedsVerify;
}


using System;
using System.Text;
using Mono.Cecil;

[Serializable]
internal class RelinkFailedException : Exception
{
	public const string DefaultMessage = "MonoMod failed relinking";

	public IMetadataTokenProvider MTP { get; }

	public IMetadataTokenProvider? Context { get; }

	public RelinkFailedException(IMetadataTokenProvider mtp, IMetadataTokenProvider? context = null)
		: this(Format("MonoMod failed relinking", mtp, context), mtp, context)
	{
	}

	public RelinkFailedException(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider? context = null)
		: base(message)
	{
		MTP = mtp;
		Context = context;
	}

	public RelinkFailedException(string message, Exception innerException, IMetadataTokenProvider mtp, IMetadataTokenProvider? context = null)
		: base(message ?? Format("MonoMod failed relinking", mtp, context), innerException)
	{
		MTP = mtp;
		Context = context;
	}

	protected static string Format(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider? context)
	{
		if (mtp == null && context == null)
		{
			return message;
		}
		StringBuilder stringBuilder = new StringBuilder(message);
		stringBuilder.Append(' ');
		if (mtp != null)
		{
			stringBuilder.Append(mtp.ToString());
		}
		if (context != null)
		{
			stringBuilder.Append(' ');
		}
		if (context != null)
		{
			stringBuilder.Append("(context: ").Append(context.ToString()).Append(')');
		}
		return stringBuilder.ToString();
	}
}


using System;
using Mono.Cecil;
using MonoMod.Utils;

[Serializable]
internal class RelinkTargetNotFoundException : RelinkFailedException
{
	public new const string DefaultMessage = "MonoMod relinker failed finding";

	public RelinkTargetNotFoundException(IMetadataTokenProvider mtp, IMetadataTokenProvider? context = null)
		: base(RelinkFailedException.Format("MonoMod relinker failed finding", mtp, context), mtp, context)
	{
	}

	public RelinkTargetNotFoundException(string message, IMetadataTokenProvider mtp, IMetadataTokenProvider? context = null)
		: base(message ?? "MonoMod relinker failed finding", mtp, context)
	{
	}

	public RelinkTargetNotFoundException(string message, Exception innerException, IMetadataTokenProvider mtp, IMetadataTokenProvider? context = null)
		: base(message ?? "MonoMod relinker failed finding", innerException, mtp, context)
	{
	}
}


internal enum RuntimeKind
{
	Unknown,
	Framework,
	CoreCLR,
	Mono
}


using System;
using System.Collections.Generic;
using MonoMod.Utils;

internal sealed class WeakReferenceComparer : EqualityComparer<WeakReference>
{
	public override bool Equals(WeakReference? x, WeakReference? y)
	{
		if (x?.SafeGetTarget() == y?.SafeGetTarget())
		{
			return x?.SafeGetIsAlive() == y?.SafeGetIsAlive();
		}
		return false;
	}

	public override int GetHashCode(WeakReference obj)
	{
		return obj.SafeGetTarget()?.GetHashCode() ?? 0;
	}
}


internal static class AssemblyInfo
{
	public const string AssemblyName = "MonoMod.Utils";

	public const string AssemblyVersion = "25.0.4";
}


using System.Runtime.InteropServices;

internal static class OSX
{
	public const string LibSystem = "libSystem";

	[DllImport("libSystem", CallingConvention = CallingConvention.Cdecl, EntryPoint = "uname", SetLastError = true)]
	public unsafe static extern int Uname(byte* buf);
}


using System;
using System.Buffers;
using System.Runtime.InteropServices;
using System.Text;
using MonoMod.Utils.Interop;

internal static class Unix
{
	public struct LinuxAuxvEntry
	{
		public nint Key;

		public nint Value;
	}

	public enum DlopenFlags
	{
		RTLD_LAZY = 1,
		RTLD_NOW = 2,
		RTLD_LOCAL = 0,
		RTLD_GLOBAL = 256
	}

	public const string LibC = "libc";

	public const string DL1 = "dl";

	public const string DL2 = "libdl.so.2";

	public const int AT_PLATFORM = 15;

	private static int dlVersion = 1;

	[DllImport("libc", CallingConvention = CallingConvention.Cdecl, EntryPoint = "uname", SetLastError = true)]
	public unsafe static extern int Uname(byte* buf);

	[DllImport("dl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlopen")]
	private unsafe static extern IntPtr DL1dlopen(byte* filename, DlopenFlags flags);

	[DllImport("dl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlclose")]
	private static extern int DL1dlclose(IntPtr handle);

	[DllImport("dl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlsym")]
	private unsafe static extern IntPtr DL1dlsym(IntPtr handle, byte* symbol);

	[DllImport("dl", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlerror")]
	private static extern IntPtr DL1dlerror();

	[DllImport("libdl.so.2", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlopen")]
	private unsafe static extern IntPtr DL2dlopen(byte* filename, DlopenFlags flags);

	[DllImport("libdl.so.2", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlclose")]
	private static extern int DL2dlclose(IntPtr handle);

	[DllImport("libdl.so.2", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlsym")]
	private unsafe static extern IntPtr DL2dlsym(IntPtr handle, byte* symbol);

	[DllImport("libdl.so.2", CallingConvention = CallingConvention.Cdecl, EntryPoint = "dlerror")]
	private static extern IntPtr DL2dlerror();

	internal static byte[]? MarshalToUtf8(string? str)
	{
		if (str == null)
		{
			return null;
		}
		int byteCount = Encoding.UTF8.GetByteCount(str);
		byte[] array = ArrayPool<byte>.Shared.Rent(byteCount + 1);
		MemoryExtensions.AsSpan(array).Clear();
		Encoding.UTF8.GetBytes(str, 0, str.Length, array, 0);
		return array;
	}

	internal static void FreeMarshalledArray(byte[]? arr)
	{
		if (arr != null)
		{
			ArrayPool<byte>.Shared.Return(arr);
		}
	}

	public unsafe static IntPtr DlOpen(string? filename, DlopenFlags flags)
	{
		byte[] array = MarshalToUtf8(filename);
		try
		{
			while (true)
			{
				try
				{
					fixed (byte* filename2 = array)
					{
						int num = dlVersion;
						if (num != 0 && num == 1)
						{
							return DL2dlopen(filename2, flags);
						}
						return DL1dlopen(filename2, flags);
					}
				}
				catch (DllNotFoundException) when (dlVersion > 0)
				{
					dlVersion--;
				}
			}
		}
		finally
		{
			FreeMarshalledArray(array);
		}
	}

	public static bool DlClose(IntPtr handle)
	{
		while (true)
		{
			try
			{
				int num = dlVersion;
				if (num != 0 && num == 1)
				{
					return DL2dlclose(handle) == 0;
				}
				return DL1dlclose(handle) == 0;
			}
			catch (DllNotFoundException) when (dlVersion > 0)
			{
				dlVersion--;
			}
		}
	}

	public unsafe static IntPtr DlSym(IntPtr handle, string symbol)
	{
		byte[] array = MarshalToUtf8(symbol);
		try
		{
			while (true)
			{
				try
				{
					fixed (byte* symbol2 = array)
					{
						int num = dlVersion;
						if (num != 0 && num == 1)
						{
							return DL2dlsym(handle, symbol2);
						}
						return DL1dlsym(handle, symbol2);
					}
				}
				catch (DllNotFoundException) when (dlVersion > 0)
				{
					dlVersion--;
				}
			}
		}
		finally
		{
			FreeMarshalledArray(array);
		}
	}

	public static IntPtr DlError()
	{
		while (true)
		{
			try
			{
				int num = dlVersion;
				if (num != 0 && num == 1)
				{
					return DL2dlerror();
				}
				return DL1dlerror();
			}
			catch (DllNotFoundException) when (dlVersion > 0)
			{
				dlVersion--;
			}
		}
	}
}


public struct LinuxAuxvEntry
{
	public nint Key;

	public nint Value;
}


public enum DlopenFlags
{
	RTLD_LAZY = 1,
	RTLD_NOW = 2,
	RTLD_LOCAL = 0,
	RTLD_GLOBAL = 256
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using MonoMod.Utils.Interop;

internal static class Windows
{
	[Conditional("NEVER")]
	[AttributeUsage(AttributeTargets.All)]
	private sealed class SetsLastSystemErrorAttribute : Attribute
	{
	}

	[Conditional("NEVER")]
	[AttributeUsage(AttributeTargets.All)]
	private sealed class NativeTypeNameAttribute : Attribute
	{
		public NativeTypeNameAttribute(string x)
		{
		}
	}

	public struct SYSTEM_INFO
	{
		[StructLayout(LayoutKind.Explicit)]
		public struct _Anonymous_e__Union
		{
			public struct _Anonymous_e__Struct
			{
				public ushort wProcessorArchitecture;

				public ushort wReserved;
			}

			[FieldOffset(0)]
			public uint dwOemId;

			[FieldOffset(0)]
			public _Anonymous_e__Struct Anonymous;
		}

		public _Anonymous_e__Union Anonymous;

		public uint dwPageSize;

		public unsafe void* lpMinimumApplicationAddress;

		public unsafe void* lpMaximumApplicationAddress;

		public nuint dwActiveProcessorMask;

		public uint dwNumberOfProcessors;

		public uint dwProcessorType;

		public uint dwAllocationGranularity;

		public ushort wProcessorLevel;

		public ushort wProcessorRevision;

		[UnscopedRef]
		public ref uint dwOemId
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref Anonymous.dwOemId;
			}
		}

		[UnscopedRef]
		public ref ushort wProcessorArchitecture
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref Anonymous.Anonymous.wProcessorArchitecture;
			}
		}

		[UnscopedRef]
		public ref ushort wReserved
		{
			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			get
			{
				return ref Anonymous.Anonymous.wReserved;
			}
		}
	}

	public readonly struct BOOL : IComparable, IComparable<BOOL>, IEquatable<BOOL>, IFormattable
	{
		public readonly int Value;

		public static BOOL FALSE => new BOOL(0);

		public static BOOL TRUE => new BOOL(1);

		public BOOL(int value)
		{
			Value = value;
		}

		public static bool operator ==(BOOL left, BOOL right)
		{
			return left.Value == right.Value;
		}

		public static bool operator !=(BOOL left, BOOL right)
		{
			return left.Value != right.Value;
		}

		public static bool operator <(BOOL left, BOOL right)
		{
			return left.Value < right.Value;
		}

		public static bool operator <=(BOOL left, BOOL right)
		{
			return left.Value <= right.Value;
		}

		public static bool operator >(BOOL left, BOOL right)
		{
			return left.Value > right.Value;
		}

		public static bool operator >=(BOOL left, BOOL right)
		{
			return left.Value >= right.Value;
		}

		public static implicit operator bool(BOOL value)
		{
			return value.Value != 0;
		}

		public static implicit operator BOOL(bool value)
		{
			return new BOOL(value ? 1 : 0);
		}

		public static bool operator false(BOOL value)
		{
			return value.Value == 0;
		}

		public static bool operator true(BOOL value)
		{
			return value.Value != 0;
		}

		public static implicit operator BOOL(byte value)
		{
			return new BOOL(value);
		}

		public static explicit operator byte(BOOL value)
		{
			return (byte)value.Value;
		}

		public static implicit operator BOOL(short value)
		{
			return new BOOL(value);
		}

		public static explicit operator short(BOOL value)
		{
			return (short)value.Value;
		}

		public static implicit operator BOOL(int value)
		{
			return new BOOL(value);
		}

		public static implicit operator int(BOOL value)
		{
			return value.Value;
		}

		public static explicit operator BOOL(long value)
		{
			return new BOOL((int)value);
		}

		public static implicit operator long(BOOL value)
		{
			return value.Value;
		}

		public static explicit operator BOOL(nint value)
		{
			return new BOOL((int)value);
		}

		public static implicit operator nint(BOOL value)
		{
			return value.Value;
		}

		public static implicit operator BOOL(sbyte value)
		{
			return new BOOL(value);
		}

		public static explicit operator sbyte(BOOL value)
		{
			return (sbyte)value.Value;
		}

		public static implicit operator BOOL(ushort value)
		{
			return new BOOL(value);
		}

		public static explicit operator ushort(BOOL value)
		{
			return (ushort)value.Value;
		}

		public static explicit operator BOOL(uint value)
		{
			return new BOOL((int)value);
		}

		public static explicit operator uint(BOOL value)
		{
			return (uint)value.Value;
		}

		public static explicit operator BOOL(ulong value)
		{
			return new BOOL((int)value);
		}

		public static explicit operator ulong(BOOL value)
		{
			return (ulong)value.Value;
		}

		public static explicit operator BOOL(nuint value)
		{
			return new BOOL((int)value);
		}

		public static explicit operator nuint(BOOL value)
		{
			return (nuint)value.Value;
		}

		public int CompareTo(object? obj)
		{
			if (obj is BOOL other)
			{
				return CompareTo(other);
			}
			if (obj != null)
			{
				throw new ArgumentException("obj is not an instance of BOOL.");
			}
			return 1;
		}

		public int CompareTo(BOOL other)
		{
			int value = Value;
			return value.CompareTo(other.Value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is BOOL other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(BOOL other)
		{
			int value = Value;
			return value.Equals(other.Value);
		}

		public override int GetHashCode()
		{
			int value = Value;
			return value.GetHashCode();
		}

		public override string ToString()
		{
			int value = Value;
			return value.ToString((IFormatProvider?)null);
		}

		public string ToString(string? format, IFormatProvider? formatProvider)
		{
			int value = Value;
			return value.ToString(format, formatProvider);
		}
	}

	public readonly struct HANDLE : IComparable, IComparable<HANDLE>, IEquatable<HANDLE>, IFormattable
	{
		public unsafe readonly void* Value;

		public unsafe static HANDLE INVALID_VALUE => new HANDLE((void*)(-1));

		public static HANDLE NULL => new HANDLE(null);

		public unsafe HANDLE(void* value)
		{
			Value = value;
		}

		public unsafe static bool operator ==(HANDLE left, HANDLE right)
		{
			return left.Value == right.Value;
		}

		public unsafe static bool operator !=(HANDLE left, HANDLE right)
		{
			return left.Value != right.Value;
		}

		public unsafe static bool operator <(HANDLE left, HANDLE right)
		{
			return left.Value < right.Value;
		}

		public unsafe static bool operator <=(HANDLE left, HANDLE right)
		{
			return left.Value <= right.Value;
		}

		public unsafe static bool operator >(HANDLE left, HANDLE right)
		{
			return left.Value > right.Value;
		}

		public unsafe static bool operator >=(HANDLE left, HANDLE right)
		{
			return left.Value >= right.Value;
		}

		public unsafe static explicit operator HANDLE(void* value)
		{
			return new HANDLE(value);
		}

		public unsafe static implicit operator void*(HANDLE value)
		{
			return value.Value;
		}

		public unsafe static explicit operator HANDLE(byte value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator byte(HANDLE value)
		{
			return (byte)value.Value;
		}

		public unsafe static explicit operator HANDLE(short value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator short(HANDLE value)
		{
			return (short)value.Value;
		}

		public unsafe static explicit operator HANDLE(int value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator int(HANDLE value)
		{
			return (int)value.Value;
		}

		public unsafe static explicit operator HANDLE(long value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator long(HANDLE value)
		{
			return (long)value.Value;
		}

		public unsafe static explicit operator HANDLE(nint value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static implicit operator nint(HANDLE value)
		{
			return (nint)value.Value;
		}

		public unsafe static explicit operator HANDLE(sbyte value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator sbyte(HANDLE value)
		{
			return (sbyte)value.Value;
		}

		public unsafe static explicit operator HANDLE(ushort value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator ushort(HANDLE value)
		{
			return (ushort)value.Value;
		}

		public unsafe static explicit operator HANDLE(uint value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator uint(HANDLE value)
		{
			return (uint)value.Value;
		}

		public unsafe static explicit operator HANDLE(ulong value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static explicit operator ulong(HANDLE value)
		{
			return (ulong)value.Value;
		}

		public unsafe static explicit operator HANDLE(nuint value)
		{
			return new HANDLE((void*)value);
		}

		public unsafe static implicit operator nuint(HANDLE value)
		{
			return (nuint)value.Value;
		}

		public int CompareTo(object? obj)
		{
			if (obj is HANDLE other)
			{
				return CompareTo(other);
			}
			if (obj != null)
			{
				throw new ArgumentException("obj is not an instance of HANDLE.");
			}
			return 1;
		}

		public unsafe int CompareTo(HANDLE other)
		{
			if (sizeof(IntPtr) != 4)
			{
				return ((ulong)Value).CompareTo((ulong)other.Value);
			}
			return ((uint)Value).CompareTo((uint)other.Value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is HANDLE other)
			{
				return Equals(other);
			}
			return false;
		}

		public unsafe bool Equals(HANDLE other)
		{
			UIntPtr value = (UIntPtr)Value;
			return value.Equals((object?)(nuint)other.Value);
		}

		public unsafe override int GetHashCode()
		{
			UIntPtr value = (UIntPtr)Value;
			return value.GetHashCode();
		}

		public unsafe override string ToString()
		{
			if (sizeof(UIntPtr) != 4)
			{
				return ((ulong)Value).ToString("X16", null);
			}
			return ((uint)Value).ToString("X8", null);
		}

		public unsafe string ToString(string? format, IFormatProvider? formatProvider)
		{
			if (sizeof(IntPtr) != 4)
			{
				return ((ulong)Value).ToString(format, formatProvider);
			}
			return ((uint)Value).ToString(format, formatProvider);
		}
	}

	public readonly struct HMODULE : IComparable, IComparable<HMODULE>, IEquatable<HMODULE>, IFormattable
	{
		public unsafe readonly void* Value;

		public unsafe static HMODULE INVALID_VALUE => new HMODULE((void*)(-1));

		public static HMODULE NULL => new HMODULE(null);

		public unsafe HMODULE(void* value)
		{
			Value = value;
		}

		public unsafe static bool operator ==(HMODULE left, HMODULE right)
		{
			return left.Value == right.Value;
		}

		public unsafe static bool operator !=(HMODULE left, HMODULE right)
		{
			return left.Value != right.Value;
		}

		public unsafe static bool operator <(HMODULE left, HMODULE right)
		{
			return left.Value < right.Value;
		}

		public unsafe static bool operator <=(HMODULE left, HMODULE right)
		{
			return left.Value <= right.Value;
		}

		public unsafe static bool operator >(HMODULE left, HMODULE right)
		{
			return left.Value > right.Value;
		}

		public unsafe static bool operator >=(HMODULE left, HMODULE right)
		{
			return left.Value >= right.Value;
		}

		public unsafe static explicit operator HMODULE(void* value)
		{
			return new HMODULE(value);
		}

		public unsafe static implicit operator void*(HMODULE value)
		{
			return value.Value;
		}

		public static explicit operator HMODULE(HANDLE value)
		{
			return new HMODULE(value);
		}

		public unsafe static implicit operator HANDLE(HMODULE value)
		{
			return new HANDLE(value.Value);
		}

		public unsafe static explicit operator HMODULE(byte value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator byte(HMODULE value)
		{
			return (byte)value.Value;
		}

		public unsafe static explicit operator HMODULE(short value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator short(HMODULE value)
		{
			return (short)value.Value;
		}

		public unsafe static explicit operator HMODULE(int value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator int(HMODULE value)
		{
			return (int)value.Value;
		}

		public unsafe static explicit operator HMODULE(long value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator long(HMODULE value)
		{
			return (long)value.Value;
		}

		public unsafe static explicit operator HMODULE(nint value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static implicit operator nint(HMODULE value)
		{
			return (nint)value.Value;
		}

		public unsafe static explicit operator HMODULE(sbyte value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator sbyte(HMODULE value)
		{
			return (sbyte)value.Value;
		}

		public unsafe static explicit operator HMODULE(ushort value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator ushort(HMODULE value)
		{
			return (ushort)value.Value;
		}

		public unsafe static explicit operator HMODULE(uint value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator uint(HMODULE value)
		{
			return (uint)value.Value;
		}

		public unsafe static explicit operator HMODULE(ulong value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static explicit operator ulong(HMODULE value)
		{
			return (ulong)value.Value;
		}

		public unsafe static explicit operator HMODULE(nuint value)
		{
			return new HMODULE((void*)value);
		}

		public unsafe static implicit operator nuint(HMODULE value)
		{
			return (nuint)value.Value;
		}

		public int CompareTo(object? obj)
		{
			if (obj is HMODULE other)
			{
				return CompareTo(other);
			}
			if (obj != null)
			{
				throw new ArgumentException("obj is not an instance of HMODULE.");
			}
			return 1;
		}

		public unsafe int CompareTo(HMODULE other)
		{
			if (sizeof(IntPtr) != 4)
			{
				return ((ulong)Value).CompareTo((ulong)other.Value);
			}
			return ((uint)Value).CompareTo((uint)other.Value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is HMODULE other)
			{
				return Equals(other);
			}
			return false;
		}

		public unsafe bool Equals(HMODULE other)
		{
			UIntPtr value = (UIntPtr)Value;
			return value.Equals((object?)(nuint)other.Value);
		}

		public unsafe override int GetHashCode()
		{
			UIntPtr value = (UIntPtr)Value;
			return value.GetHashCode();
		}

		public unsafe override string ToString()
		{
			if (sizeof(UIntPtr) != 4)
			{
				return ((ulong)Value).ToString("X16", null);
			}
			return ((uint)Value).ToString("X8", null);
		}

		public unsafe string ToString(string? format, IFormatProvider? formatProvider)
		{
			if (sizeof(IntPtr) != 4)
			{
				return ((ulong)Value).ToString(format, formatProvider);
			}
			return ((uint)Value).ToString(format, formatProvider);
		}
	}

	public const int PROCESSOR_ARCHITECTURE_INTEL = 0;

	public const int PROCESSOR_ARCHITECTURE_MIPS = 1;

	public const int PROCESSOR_ARCHITECTURE_ALPHA = 2;

	public const int PROCESSOR_ARCHITECTURE_PPC = 3;

	public const int PROCESSOR_ARCHITECTURE_SHX = 4;

	public const int PROCESSOR_ARCHITECTURE_ARM = 5;

	public const int PROCESSOR_ARCHITECTURE_IA64 = 6;

	public const int PROCESSOR_ARCHITECTURE_ALPHA64 = 7;

	public const int PROCESSOR_ARCHITECTURE_MSIL = 8;

	public const int PROCESSOR_ARCHITECTURE_AMD64 = 9;

	public const int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 = 10;

	public const int PROCESSOR_ARCHITECTURE_NEUTRAL = 11;

	public const int PROCESSOR_ARCHITECTURE_ARM64 = 12;

	public const int PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 = 13;

	public const int PROCESSOR_ARCHITECTURE_IA32_ON_ARM64 = 14;

	public const int PROCESSOR_ARCHITECTURE_UNKNOWN = 65535;

	[DllImport("kernel32", ExactSpelling = true)]
	[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
	public unsafe static extern void GetSystemInfo(SYSTEM_INFO* lpSystemInfo);

	[DllImport("kernel32", ExactSpelling = true)]
	[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
	public unsafe static extern HMODULE GetModuleHandleW(ushort* lpModuleName);

	[DllImport("kernel32", ExactSpelling = true)]
	[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
	public unsafe static extern IntPtr GetProcAddress(HMODULE hModule, sbyte* lpProcName);

	[DllImport("kernel32", ExactSpelling = true)]
	[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
	public unsafe static extern HMODULE LoadLibraryW(ushort* lpLibFileName);

	[DllImport("kernel32", ExactSpelling = true)]
	[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
	public static extern BOOL FreeLibrary(HMODULE hLibModule);

	[DllImport("kernel32", ExactSpelling = true)]
	[DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
	public static extern uint GetLastError();
}


using System;
using System.Diagnostics;

[Conditional("NEVER")]
[AttributeUsage(AttributeTargets.All)]
private sealed class SetsLastSystemErrorAttribute : Attribute
{
}


using System;
using System.Diagnostics;

[Conditional("NEVER")]
[AttributeUsage(AttributeTargets.All)]
private sealed class NativeTypeNameAttribute : Attribute
{
	public NativeTypeNameAttribute(string x)
	{
	}
}


using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

public struct SYSTEM_INFO
{
	[StructLayout(LayoutKind.Explicit)]
	public struct _Anonymous_e__Union
	{
		public struct _Anonymous_e__Struct
		{
			public ushort wProcessorArchitecture;

			public ushort wReserved;
		}

		[FieldOffset(0)]
		public uint dwOemId;

		[FieldOffset(0)]
		public _Anonymous_e__Struct Anonymous;
	}

	public _Anonymous_e__Union Anonymous;

	public uint dwPageSize;

	public unsafe void* lpMinimumApplicationAddress;

	public unsafe void* lpMaximumApplicationAddress;

	public nuint dwActiveProcessorMask;

	public uint dwNumberOfProcessors;

	public uint dwProcessorType;

	public uint dwAllocationGranularity;

	public ushort wProcessorLevel;

	public ushort wProcessorRevision;

	[UnscopedRef]
	public ref uint dwOemId
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref Anonymous.dwOemId;
		}
	}

	[UnscopedRef]
	public ref ushort wProcessorArchitecture
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref Anonymous.Anonymous.wProcessorArchitecture;
		}
	}

	[UnscopedRef]
	public ref ushort wReserved
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			return ref Anonymous.Anonymous.wReserved;
		}
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct _Anonymous_e__Union
{
	public struct _Anonymous_e__Struct
	{
		public ushort wProcessorArchitecture;

		public ushort wReserved;
	}

	[FieldOffset(0)]
	public uint dwOemId;

	[FieldOffset(0)]
	public _Anonymous_e__Struct Anonymous;
}


public struct _Anonymous_e__Struct
{
	public ushort wProcessorArchitecture;

	public ushort wReserved;
}


using System;

public readonly struct BOOL : IComparable, IComparable<BOOL>, IEquatable<BOOL>, IFormattable
{
	public readonly int Value;

	public static BOOL FALSE => new BOOL(0);

	public static BOOL TRUE => new BOOL(1);

	public BOOL(int value)
	{
		Value = value;
	}

	public static bool operator ==(BOOL left, BOOL right)
	{
		return left.Value == right.Value;
	}

	public static bool operator !=(BOOL left, BOOL right)
	{
		return left.Value != right.Value;
	}

	public static bool operator <(BOOL left, BOOL right)
	{
		return left.Value < right.Value;
	}

	public static bool operator <=(BOOL left, BOOL right)
	{
		return left.Value <= right.Value;
	}

	public static bool operator >(BOOL left, BOOL right)
	{
		return left.Value > right.Value;
	}

	public static bool operator >=(BOOL left, BOOL right)
	{
		return left.Value >= right.Value;
	}

	public static implicit operator bool(BOOL value)
	{
		return value.Value != 0;
	}

	public static implicit operator BOOL(bool value)
	{
		return new BOOL(value ? 1 : 0);
	}

	public static bool operator false(BOOL value)
	{
		return value.Value == 0;
	}

	public static bool operator true(BOOL value)
	{
		return value.Value != 0;
	}

	public static implicit operator BOOL(byte value)
	{
		return new BOOL(value);
	}

	public static explicit operator byte(BOOL value)
	{
		return (byte)value.Value;
	}

	public static implicit operator BOOL(short value)
	{
		return new BOOL(value);
	}

	public static explicit operator short(BOOL value)
	{
		return (short)value.Value;
	}

	public static implicit operator BOOL(int value)
	{
		return new BOOL(value);
	}

	public static implicit operator int(BOOL value)
	{
		return value.Value;
	}

	public static explicit operator BOOL(long value)
	{
		return new BOOL((int)value);
	}

	public static implicit operator long(BOOL value)
	{
		return value.Value;
	}

	public static explicit operator BOOL(nint value)
	{
		return new BOOL((int)value);
	}

	public static implicit operator nint(BOOL value)
	{
		return value.Value;
	}

	public static implicit operator BOOL(sbyte value)
	{
		return new BOOL(value);
	}

	public static explicit operator sbyte(BOOL value)
	{
		return (sbyte)value.Value;
	}

	public static implicit operator BOOL(ushort value)
	{
		return new BOOL(value);
	}

	public static explicit operator ushort(BOOL value)
	{
		return (ushort)value.Value;
	}

	public static explicit operator BOOL(uint value)
	{
		return new BOOL((int)value);
	}

	public static explicit operator uint(BOOL value)
	{
		return (uint)value.Value;
	}

	public static explicit operator BOOL(ulong value)
	{
		return new BOOL((int)value);
	}

	public static explicit operator ulong(BOOL value)
	{
		return (ulong)value.Value;
	}

	public static explicit operator BOOL(nuint value)
	{
		return new BOOL((int)value);
	}

	public static explicit operator nuint(BOOL value)
	{
		return (nuint)value.Value;
	}

	public int CompareTo(object? obj)
	{
		if (obj is BOOL other)
		{
			return CompareTo(other);
		}
		if (obj != null)
		{
			throw new ArgumentException("obj is not an instance of BOOL.");
		}
		return 1;
	}

	public int CompareTo(BOOL other)
	{
		int value = Value;
		return value.CompareTo(other.Value);
	}

	public override bool Equals(object? obj)
	{
		if (obj is BOOL other)
		{
			return Equals(other);
		}
		return false;
	}

	public bool Equals(BOOL other)
	{
		int value = Value;
		return value.Equals(other.Value);
	}

	public override int GetHashCode()
	{
		int value = Value;
		return value.GetHashCode();
	}

	public override string ToString()
	{
		int value = Value;
		return value.ToString((IFormatProvider?)null);
	}

	public string ToString(string? format, IFormatProvider? formatProvider)
	{
		int value = Value;
		return value.ToString(format, formatProvider);
	}
}


using System;

public readonly struct HANDLE : IComparable, IComparable<HANDLE>, IEquatable<HANDLE>, IFormattable
{
	public unsafe readonly void* Value;

	public unsafe static HANDLE INVALID_VALUE => new HANDLE((void*)(-1));

	public static HANDLE NULL => new HANDLE(null);

	public unsafe HANDLE(void* value)
	{
		Value = value;
	}

	public unsafe static bool operator ==(HANDLE left, HANDLE right)
	{
		return left.Value == right.Value;
	}

	public unsafe static bool operator !=(HANDLE left, HANDLE right)
	{
		return left.Value != right.Value;
	}

	public unsafe static bool operator <(HANDLE left, HANDLE right)
	{
		return left.Value < right.Value;
	}

	public unsafe static bool operator <=(HANDLE left, HANDLE right)
	{
		return left.Value <= right.Value;
	}

	public unsafe static bool operator >(HANDLE left, HANDLE right)
	{
		return left.Value > right.Value;
	}

	public unsafe static bool operator >=(HANDLE left, HANDLE right)
	{
		return left.Value >= right.Value;
	}

	public unsafe static explicit operator HANDLE(void* value)
	{
		return new HANDLE(value);
	}

	public unsafe static implicit operator void*(HANDLE value)
	{
		return value.Value;
	}

	public unsafe static explicit operator HANDLE(byte value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator byte(HANDLE value)
	{
		return (byte)value.Value;
	}

	public unsafe static explicit operator HANDLE(short value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator short(HANDLE value)
	{
		return (short)value.Value;
	}

	public unsafe static explicit operator HANDLE(int value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator int(HANDLE value)
	{
		return (int)value.Value;
	}

	public unsafe static explicit operator HANDLE(long value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator long(HANDLE value)
	{
		return (long)value.Value;
	}

	public unsafe static explicit operator HANDLE(nint value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static implicit operator nint(HANDLE value)
	{
		return (nint)value.Value;
	}

	public unsafe static explicit operator HANDLE(sbyte value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator sbyte(HANDLE value)
	{
		return (sbyte)value.Value;
	}

	public unsafe static explicit operator HANDLE(ushort value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator ushort(HANDLE value)
	{
		return (ushort)value.Value;
	}

	public unsafe static explicit operator HANDLE(uint value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator uint(HANDLE value)
	{
		return (uint)value.Value;
	}

	public unsafe static explicit operator HANDLE(ulong value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static explicit operator ulong(HANDLE value)
	{
		return (ulong)value.Value;
	}

	public unsafe static explicit operator HANDLE(nuint value)
	{
		return new HANDLE((void*)value);
	}

	public unsafe static implicit operator nuint(HANDLE value)
	{
		return (nuint)value.Value;
	}

	public int CompareTo(object? obj)
	{
		if (obj is HANDLE other)
		{
			return CompareTo(other);
		}
		if (obj != null)
		{
			throw new ArgumentException("obj is not an instance of HANDLE.");
		}
		return 1;
	}

	public unsafe int CompareTo(HANDLE other)
	{
		if (sizeof(IntPtr) != 4)
		{
			return ((ulong)Value).CompareTo((ulong)other.Value);
		}
		return ((uint)Value).CompareTo((uint)other.Value);
	}

	public override bool Equals(object? obj)
	{
		if (obj is HANDLE other)
		{
			return Equals(other);
		}
		return false;
	}

	public unsafe bool Equals(HANDLE other)
	{
		UIntPtr value = (UIntPtr)Value;
		return value.Equals((object?)(nuint)other.Value);
	}

	public unsafe override int GetHashCode()
	{
		UIntPtr value = (UIntPtr)Value;
		return value.GetHashCode();
	}

	public unsafe override string ToString()
	{
		if (sizeof(UIntPtr) != 4)
		{
			return ((ulong)Value).ToString("X16", null);
		}
		return ((uint)Value).ToString("X8", null);
	}

	public unsafe string ToString(string? format, IFormatProvider? formatProvider)
	{
		if (sizeof(IntPtr) != 4)
		{
			return ((ulong)Value).ToString(format, formatProvider);
		}
		return ((uint)Value).ToString(format, formatProvider);
	}
}


using System;

public readonly struct HMODULE : IComparable, IComparable<HMODULE>, IEquatable<HMODULE>, IFormattable
{
	public unsafe readonly void* Value;

	public unsafe static HMODULE INVALID_VALUE => new HMODULE((void*)(-1));

	public static HMODULE NULL => new HMODULE(null);

	public unsafe HMODULE(void* value)
	{
		Value = value;
	}

	public unsafe static bool operator ==(HMODULE left, HMODULE right)
	{
		return left.Value == right.Value;
	}

	public unsafe static bool operator !=(HMODULE left, HMODULE right)
	{
		return left.Value != right.Value;
	}

	public unsafe static bool operator <(HMODULE left, HMODULE right)
	{
		return left.Value < right.Value;
	}

	public unsafe static bool operator <=(HMODULE left, HMODULE right)
	{
		return left.Value <= right.Value;
	}

	public unsafe static bool operator >(HMODULE left, HMODULE right)
	{
		return left.Value > right.Value;
	}

	public unsafe static bool operator >=(HMODULE left, HMODULE right)
	{
		return left.Value >= right.Value;
	}

	public unsafe static explicit operator HMODULE(void* value)
	{
		return new HMODULE(value);
	}

	public unsafe static implicit operator void*(HMODULE value)
	{
		return value.Value;
	}

	public static explicit operator HMODULE(HANDLE value)
	{
		return new HMODULE(value);
	}

	public unsafe static implicit operator HANDLE(HMODULE value)
	{
		return new HANDLE(value.Value);
	}

	public unsafe static explicit operator HMODULE(byte value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator byte(HMODULE value)
	{
		return (byte)value.Value;
	}

	public unsafe static explicit operator HMODULE(short value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator short(HMODULE value)
	{
		return (short)value.Value;
	}

	public unsafe static explicit operator HMODULE(int value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator int(HMODULE value)
	{
		return (int)value.Value;
	}

	public unsafe static explicit operator HMODULE(long value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator long(HMODULE value)
	{
		return (long)value.Value;
	}

	public unsafe static explicit operator HMODULE(nint value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static implicit operator nint(HMODULE value)
	{
		return (nint)value.Value;
	}

	public unsafe static explicit operator HMODULE(sbyte value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator sbyte(HMODULE value)
	{
		return (sbyte)value.Value;
	}

	public unsafe static explicit operator HMODULE(ushort value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator ushort(HMODULE value)
	{
		return (ushort)value.Value;
	}

	public unsafe static explicit operator HMODULE(uint value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator uint(HMODULE value)
	{
		return (uint)value.Value;
	}

	public unsafe static explicit operator HMODULE(ulong value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static explicit operator ulong(HMODULE value)
	{
		return (ulong)value.Value;
	}

	public unsafe static explicit operator HMODULE(nuint value)
	{
		return new HMODULE((void*)value);
	}

	public unsafe static implicit operator nuint(HMODULE value)
	{
		return (nuint)value.Value;
	}

	public int CompareTo(object? obj)
	{
		if (obj is HMODULE other)
		{
			return CompareTo(other);
		}
		if (obj != null)
		{
			throw new ArgumentException("obj is not an instance of HMODULE.");
		}
		return 1;
	}

	public unsafe int CompareTo(HMODULE other)
	{
		if (sizeof(IntPtr) != 4)
		{
			return ((ulong)Value).CompareTo((ulong)other.Value);
		}
		return ((uint)Value).CompareTo((uint)other.Value);
	}

	public override bool Equals(object? obj)
	{
		if (obj is HMODULE other)
		{
			return Equals(other);
		}
		return false;
	}

	public unsafe bool Equals(HMODULE other)
	{
		UIntPtr value = (UIntPtr)Value;
		return value.Equals((object?)(nuint)other.Value);
	}

	public unsafe override int GetHashCode()
	{
		UIntPtr value = (UIntPtr)Value;
		return value.GetHashCode();
	}

	public unsafe override string ToString()
	{
		if (sizeof(UIntPtr) != 4)
		{
			return ((ulong)Value).ToString("X16", null);
		}
		return ((uint)Value).ToString("X8", null);
	}

	public unsafe string ToString(string? format, IFormatProvider? formatProvider)
	{
		if (sizeof(IntPtr) != 4)
		{
			return ((ulong)Value).ToString(format, formatProvider);
		}
		return ((uint)Value).ToString(format, formatProvider);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod.Utils;
using MonoMod.Utils.Cil;

internal sealed class CecilILGenerator : ILGeneratorShim
{
	private class LabelInfo
	{
		public bool Emitted;

		public Instruction Instruction = Mono.Cecil.Cil.Instruction.Create(Mono.Cecil.Cil.OpCodes.Nop);

		public readonly List<Instruction> Branches = new List<Instruction>();
	}

	private class LabelledExceptionHandler
	{
		public Label TryStart = NullLabel;

		public Label TryEnd = NullLabel;

		public Label HandlerStart = NullLabel;

		public Label HandlerEnd = NullLabel;

		public Label FilterStart = NullLabel;

		public ExceptionHandlerType HandlerType;

		public TypeReference? ExceptionType;
	}

	private class ExceptionHandlerChain
	{
		private readonly CecilILGenerator IL;

		private readonly Label _Start;

		public readonly Label SkipAll;

		private Label _SkipHandler;

		private LabelledExceptionHandler? _Prev;

		private LabelledExceptionHandler? _Handler;

		public ExceptionHandlerChain(CecilILGenerator il)
		{
			IL = il;
			_Start = il.DefineLabel();
			il.MarkLabel(_Start);
			SkipAll = il.DefineLabel();
		}

		public LabelledExceptionHandler BeginHandler(ExceptionHandlerType type)
		{
			LabelledExceptionHandler labelledExceptionHandler = (_Prev = _Handler);
			if (labelledExceptionHandler != null)
			{
				EndHandler(labelledExceptionHandler);
			}
			IL.Emit(System.Reflection.Emit.OpCodes.Leave, _SkipHandler = IL.DefineLabel());
			Label label = IL.DefineLabel();
			IL.MarkLabel(label);
			LabelledExceptionHandler labelledExceptionHandler2 = (_Handler = new LabelledExceptionHandler
			{
				TryStart = _Start,
				TryEnd = label,
				HandlerType = type,
				HandlerEnd = _SkipHandler
			});
			if (type == ExceptionHandlerType.Filter)
			{
				labelledExceptionHandler2.FilterStart = label;
			}
			else
			{
				labelledExceptionHandler2.HandlerStart = label;
			}
			return labelledExceptionHandler2;
		}

		public void EndHandler(LabelledExceptionHandler handler)
		{
			Label skipHandler = _SkipHandler;
			switch (handler.HandlerType)
			{
			case ExceptionHandlerType.Filter:
				IL.Emit(System.Reflection.Emit.OpCodes.Endfilter);
				break;
			case ExceptionHandlerType.Finally:
				IL.Emit(System.Reflection.Emit.OpCodes.Endfinally);
				break;
			default:
				IL.Emit(System.Reflection.Emit.OpCodes.Leave, skipHandler);
				break;
			}
			IL.MarkLabel(skipHandler);
			IL._ExceptionHandlersToMark.Add(handler);
		}

		public void End()
		{
			EndHandler(_Handler ?? throw new InvalidOperationException("Cannot end when there is no current handler!"));
			IL.MarkLabel(SkipAll);
		}
	}

	private static readonly ConstructorInfo c_LocalBuilder;

	private static readonly FieldInfo? f_LocalBuilder_position;

	private static readonly FieldInfo? f_LocalBuilder_is_pinned;

	private static int c_LocalBuilder_params;

	private static readonly Dictionary<short, Mono.Cecil.Cil.OpCode> _MCCOpCodes;

	private static Label NullLabel;

	private readonly Dictionary<Label, LabelInfo> _LabelInfos = new Dictionary<Label, LabelInfo>();

	private readonly List<LabelInfo> _LabelsToMark = new List<LabelInfo>();

	private readonly List<LabelledExceptionHandler> _ExceptionHandlersToMark = new List<LabelledExceptionHandler>();

	private readonly Dictionary<LocalBuilder, VariableDefinition> _Variables = new Dictionary<LocalBuilder, VariableDefinition>();

	private readonly Stack<ExceptionHandlerChain> _ExceptionHandlers = new Stack<ExceptionHandlerChain>();

	private int labelCounter;

	private int _ILOffset;

	public ILProcessor IL { get; }

	public override int ILOffset => _ILOffset;

	static CecilILGenerator()
	{
		c_LocalBuilder = (from c in typeof(LocalBuilder).GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
			orderby c.GetParameters().Length descending
			select c).First();
		f_LocalBuilder_position = typeof(LocalBuilder).GetField("position", BindingFlags.Instance | BindingFlags.NonPublic);
		f_LocalBuilder_is_pinned = typeof(LocalBuilder).GetField("is_pinned", BindingFlags.Instance | BindingFlags.NonPublic);
		c_LocalBuilder_params = c_LocalBuilder.GetParameters().Length;
		_MCCOpCodes = new Dictionary<short, Mono.Cecil.Cil.OpCode>();
		FieldInfo[] fields = typeof(Mono.Cecil.Cil.OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public);
		for (int i = 0; i < fields.Length; i++)
		{
			Mono.Cecil.Cil.OpCode value = (Mono.Cecil.Cil.OpCode)fields[i].GetValue(null);
			_MCCOpCodes[value.Value] = value;
		}
		Label source = default(Label);
		Unsafe.As<Label, int>(ref source) = -1;
		NullLabel = source;
	}

	public CecilILGenerator(ILProcessor il)
	{
		IL = il;
	}

	private static Mono.Cecil.Cil.OpCode _(System.Reflection.Emit.OpCode opcode)
	{
		return _MCCOpCodes[opcode.Value];
	}

	private LabelInfo? _(Label handle)
	{
		if (!_LabelInfos.TryGetValue(handle, out LabelInfo value))
		{
			return null;
		}
		return value;
	}

	private VariableDefinition _(LocalBuilder handle)
	{
		return _Variables[handle];
	}

	private TypeReference _(Type info)
	{
		return IL.Body.Method.Module.ImportReference(info);
	}

	private FieldReference _(FieldInfo info)
	{
		return IL.Body.Method.Module.ImportReference(info);
	}

	private MethodReference _(MethodBase info)
	{
		return IL.Body.Method.Module.ImportReference(info);
	}

	private Instruction ProcessLabels(Instruction ins)
	{
		if (_LabelsToMark.Count != 0)
		{
			foreach (LabelInfo item in _LabelsToMark)
			{
				foreach (Instruction branch in item.Branches)
				{
					object operand = branch.Operand;
					if (!(operand is Instruction))
					{
						if (!(operand is Instruction[] array))
						{
							continue;
						}
						for (int i = 0; i < array.Length; i++)
						{
							if (array[i] == item.Instruction)
							{
								array[i] = ins;
								break;
							}
						}
					}
					else
					{
						branch.Operand = ins;
					}
				}
				item.Emitted = true;
				item.Instruction = ins;
			}
			_LabelsToMark.Clear();
		}
		if (_ExceptionHandlersToMark.Count != 0)
		{
			foreach (LabelledExceptionHandler item2 in _ExceptionHandlersToMark)
			{
				IL.Body.ExceptionHandlers.Add(new ExceptionHandler(item2.HandlerType)
				{
					TryStart = _(item2.TryStart)?.Instruction,
					TryEnd = _(item2.TryEnd)?.Instruction,
					HandlerStart = _(item2.HandlerStart)?.Instruction,
					HandlerEnd = _(item2.HandlerEnd)?.Instruction,
					FilterStart = _(item2.FilterStart)?.Instruction,
					CatchType = item2.ExceptionType
				});
			}
			_ExceptionHandlersToMark.Clear();
		}
		return ins;
	}

	public unsafe override Label DefineLabel()
	{
		Label label = default(Label);
		*(int*)(&label) = labelCounter++;
		_LabelInfos[label] = new LabelInfo();
		return label;
	}

	public override void MarkLabel(Label loc)
	{
		if (_LabelInfos.TryGetValue(loc, out LabelInfo value) && !value.Emitted)
		{
			_LabelsToMark.Add(value);
		}
	}

	public override LocalBuilder DeclareLocal(Type localType)
	{
		return DeclareLocal(localType, pinned: false);
	}

	public override LocalBuilder DeclareLocal(Type localType, bool pinned)
	{
		int count = IL.Body.Variables.Count;
		object obj;
		if (c_LocalBuilder_params != 4)
		{
			if (c_LocalBuilder_params != 3)
			{
				if (c_LocalBuilder_params != 2)
				{
					if (c_LocalBuilder_params != 0)
					{
						throw new NotSupportedException();
					}
					obj = c_LocalBuilder.Invoke(ArrayEx.Empty<object>());
				}
				else
				{
					obj = c_LocalBuilder.Invoke(new object[2] { localType, null });
				}
			}
			else
			{
				obj = c_LocalBuilder.Invoke(new object[3] { count, localType, null });
			}
		}
		else
		{
			obj = c_LocalBuilder.Invoke(new object[4] { count, localType, null, pinned });
		}
		LocalBuilder localBuilder = (LocalBuilder)obj;
		f_LocalBuilder_position?.SetValue(localBuilder, (ushort)count);
		f_LocalBuilder_is_pinned?.SetValue(localBuilder, pinned);
		TypeReference typeReference = _(localType);
		if (pinned)
		{
			typeReference = new PinnedType(typeReference);
		}
		VariableDefinition variableDefinition = new VariableDefinition(typeReference);
		IL.Body.Variables.Add(variableDefinition);
		_Variables[localBuilder] = variableDefinition;
		return localBuilder;
	}

	private void Emit(Instruction ins)
	{
		ins.Offset = _ILOffset;
		_ILOffset += ins.GetSize();
		IL.Append(ProcessLabels(ins));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode)
	{
		Emit(IL.Create(_(opcode)));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, byte arg)
	{
		if (opcode.OperandType == System.Reflection.Emit.OperandType.ShortInlineVar || opcode.OperandType == System.Reflection.Emit.OperandType.InlineVar)
		{
			_EmitInlineVar(_(opcode), arg);
		}
		else
		{
			Emit(IL.Create(_(opcode), arg));
		}
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, sbyte arg)
	{
		if (opcode.OperandType == System.Reflection.Emit.OperandType.ShortInlineVar || opcode.OperandType == System.Reflection.Emit.OperandType.InlineVar)
		{
			_EmitInlineVar(_(opcode), arg);
		}
		else
		{
			Emit(IL.Create(_(opcode), arg));
		}
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, short arg)
	{
		if (opcode.OperandType == System.Reflection.Emit.OperandType.ShortInlineVar || opcode.OperandType == System.Reflection.Emit.OperandType.InlineVar)
		{
			_EmitInlineVar(_(opcode), arg);
		}
		else
		{
			Emit(IL.Create(_(opcode), arg));
		}
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, int arg)
	{
		if (opcode.OperandType == System.Reflection.Emit.OperandType.ShortInlineVar || opcode.OperandType == System.Reflection.Emit.OperandType.InlineVar)
		{
			_EmitInlineVar(_(opcode), arg);
			return;
		}
		string? name = opcode.Name;
		if (name != null && name.EndsWith(".s", StringComparison.Ordinal))
		{
			Emit(IL.Create(_(opcode), (sbyte)arg));
		}
		else
		{
			Emit(IL.Create(_(opcode), arg));
		}
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, long arg)
	{
		Emit(IL.Create(_(opcode), arg));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, float arg)
	{
		Emit(IL.Create(_(opcode), arg));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, double arg)
	{
		Emit(IL.Create(_(opcode), arg));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, string str)
	{
		Emit(IL.Create(_(opcode), str));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, Type cls)
	{
		Emit(IL.Create(_(opcode), _(cls)));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, FieldInfo field)
	{
		Emit(IL.Create(_(opcode), _(field)));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, ConstructorInfo con)
	{
		Emit(IL.Create(_(opcode), _(con)));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, MethodInfo meth)
	{
		Emit(IL.Create(_(opcode), _(meth)));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, Label label)
	{
		LabelInfo? labelInfo = _(label);
		Instruction instruction = IL.Create(_(opcode), _(label).Instruction);
		labelInfo.Branches.Add(instruction);
		Emit(ProcessLabels(instruction));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, Label[] labels)
	{
		LabelInfo[] array = (from x in labels.Distinct().Select(_)
			where x != null
			select x).ToArray();
		Instruction instruction = IL.Create(_(opcode), array.Select((LabelInfo labelInfo) => labelInfo.Instruction).ToArray());
		LabelInfo[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].Branches.Add(instruction);
		}
		Emit(ProcessLabels(instruction));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, LocalBuilder local)
	{
		Emit(IL.Create(_(opcode), _(local)));
	}

	public override void Emit(System.Reflection.Emit.OpCode opcode, SignatureHelper signature)
	{
		Emit(IL.Create(_(opcode), IL.Body.Method.Module.ImportCallSite(signature)));
	}

	public void Emit(System.Reflection.Emit.OpCode opcode, ICallSiteGenerator signature)
	{
		Emit(IL.Create(_(opcode), IL.Body.Method.Module.ImportCallSite(signature)));
	}

	private void _EmitInlineVar(Mono.Cecil.Cil.OpCode opcode, int index)
	{
		switch (opcode.OperandType)
		{
		case Mono.Cecil.Cil.OperandType.InlineArg:
		case Mono.Cecil.Cil.OperandType.ShortInlineArg:
			Emit(IL.Create(opcode, IL.Body.Method.Parameters[index]));
			return;
		case Mono.Cecil.Cil.OperandType.InlineVar:
		case Mono.Cecil.Cil.OperandType.ShortInlineVar:
			Emit(IL.Create(opcode, IL.Body.Variables[index]));
			return;
		}
		throw new NotSupportedException($"Unsupported SRE InlineVar -> Cecil {opcode.OperandType} for {opcode} {index}");
	}

	public override void EmitCall(System.Reflection.Emit.OpCode opcode, MethodInfo methodInfo, Type[]? optionalParameterTypes)
	{
		Emit(IL.Create(_(opcode), _(methodInfo)));
	}

	public override void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConventions callingConvention, Type? returnType, Type[]? parameterTypes, Type[]? optionalParameterTypes)
	{
		throw new NotSupportedException();
	}

	public override void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConvention unmanagedCallConv, Type? returnType, Type[]? parameterTypes)
	{
		throw new NotSupportedException();
	}

	public override void EmitWriteLine(FieldInfo fld)
	{
		if (fld.IsStatic)
		{
			Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Ldsfld, _(fld)));
		}
		else
		{
			Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Ldarg_0));
			Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Ldfld, _(fld)));
		}
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Call, _(typeof(Console).GetMethod("WriteLine", new Type[1] { fld.FieldType }))));
	}

	public override void EmitWriteLine(LocalBuilder localBuilder)
	{
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Ldloc, _(localBuilder)));
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Call, _(typeof(Console).GetMethod("WriteLine", new Type[1] { localBuilder.LocalType }))));
	}

	public override void EmitWriteLine(string value)
	{
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Ldstr, value));
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Call, _(typeof(Console).GetMethod("WriteLine", new Type[1] { typeof(string) }))));
	}

	public override void ThrowException(Type excType)
	{
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Newobj, _(excType.GetConstructor(Type.EmptyTypes) ?? throw new InvalidOperationException("No default constructor"))));
		Emit(IL.Create(Mono.Cecil.Cil.OpCodes.Throw));
	}

	public override Label BeginExceptionBlock()
	{
		ExceptionHandlerChain exceptionHandlerChain = new ExceptionHandlerChain(this);
		_ExceptionHandlers.Push(exceptionHandlerChain);
		return exceptionHandlerChain.SkipAll;
	}

	public override void BeginCatchBlock(Type exceptionType)
	{
		_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Catch).ExceptionType = (((object)exceptionType == null) ? null : _(exceptionType));
	}

	public override void BeginExceptFilterBlock()
	{
		_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Filter);
	}

	public override void BeginFaultBlock()
	{
		_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Fault);
	}

	public override void BeginFinallyBlock()
	{
		_ExceptionHandlers.Peek().BeginHandler(ExceptionHandlerType.Finally);
	}

	public override void EndExceptionBlock()
	{
		_ExceptionHandlers.Pop().End();
	}

	public override void BeginScope()
	{
	}

	public override void EndScope()
	{
	}

	public override void UsingNamespace(string usingNamespace)
	{
	}
}


using System.Collections.Generic;
using Mono.Cecil.Cil;

private class LabelInfo
{
	public bool Emitted;

	public Instruction Instruction = Mono.Cecil.Cil.Instruction.Create(OpCodes.Nop);

	public readonly List<Instruction> Branches = new List<Instruction>();
}


using System.Reflection.Emit;
using Mono.Cecil;
using Mono.Cecil.Cil;

private class LabelledExceptionHandler
{
	public Label TryStart = NullLabel;

	public Label TryEnd = NullLabel;

	public Label HandlerStart = NullLabel;

	public Label HandlerEnd = NullLabel;

	public Label FilterStart = NullLabel;

	public ExceptionHandlerType HandlerType;

	public TypeReference? ExceptionType;
}


using System;
using System.Reflection.Emit;
using Mono.Cecil.Cil;

private class ExceptionHandlerChain
{
	private readonly CecilILGenerator IL;

	private readonly Label _Start;

	public readonly Label SkipAll;

	private Label _SkipHandler;

	private LabelledExceptionHandler? _Prev;

	private LabelledExceptionHandler? _Handler;

	public ExceptionHandlerChain(CecilILGenerator il)
	{
		IL = il;
		_Start = il.DefineLabel();
		il.MarkLabel(_Start);
		SkipAll = il.DefineLabel();
	}

	public LabelledExceptionHandler BeginHandler(ExceptionHandlerType type)
	{
		LabelledExceptionHandler labelledExceptionHandler = (_Prev = _Handler);
		if (labelledExceptionHandler != null)
		{
			EndHandler(labelledExceptionHandler);
		}
		IL.Emit(System.Reflection.Emit.OpCodes.Leave, _SkipHandler = IL.DefineLabel());
		Label label = IL.DefineLabel();
		IL.MarkLabel(label);
		LabelledExceptionHandler labelledExceptionHandler2 = (_Handler = new LabelledExceptionHandler
		{
			TryStart = _Start,
			TryEnd = label,
			HandlerType = type,
			HandlerEnd = _SkipHandler
		});
		if (type == ExceptionHandlerType.Filter)
		{
			labelledExceptionHandler2.FilterStart = label;
		}
		else
		{
			labelledExceptionHandler2.HandlerStart = label;
		}
		return labelledExceptionHandler2;
	}

	public void EndHandler(LabelledExceptionHandler handler)
	{
		Label skipHandler = _SkipHandler;
		switch (handler.HandlerType)
		{
		case ExceptionHandlerType.Filter:
			IL.Emit(System.Reflection.Emit.OpCodes.Endfilter);
			break;
		case ExceptionHandlerType.Finally:
			IL.Emit(System.Reflection.Emit.OpCodes.Endfinally);
			break;
		default:
			IL.Emit(System.Reflection.Emit.OpCodes.Leave, skipHandler);
			break;
		}
		IL.MarkLabel(skipHandler);
		IL._ExceptionHandlersToMark.Add(handler);
	}

	public void End()
	{
		EndHandler(_Handler ?? throw new InvalidOperationException("Cannot end when there is no current handler!"));
		IL.MarkLabel(SkipAll);
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;
using MonoMod.Utils;
using MonoMod.Utils.Cil;

internal abstract class ILGeneratorShim
{
	internal static class ILGeneratorBuilder
	{
		public const string Namespace = "MonoMod.Utils.Cil";

		public const string Name = "ILGeneratorProxy";

		public const string FullName = "MonoMod.Utils.Cil.ILGeneratorProxy";

		public const string TargetName = "Target";

		private static Type? ProxyType;

		public static Type GenerateProxy()
		{
			if (ProxyType != null)
			{
				return ProxyType;
			}
			Type typeFromHandle = typeof(ILGenerator);
			Type typeFromHandle2 = typeof(ILGeneratorShim);
			Assembly assembly;
			using (ModuleDefinition moduleDefinition = ModuleDefinition.CreateModule("MonoMod.Utils.Cil.ILGeneratorProxy", new ModuleParameters
			{
				Kind = ModuleKind.Dll,
				ReflectionImporterProvider = MMReflectionImporter.Provider
			}))
			{
				CustomAttribute customAttribute = new CustomAttribute(moduleDefinition.ImportReference(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute));
				customAttribute.ConstructorArguments.Add(new CustomAttributeArgument(moduleDefinition.TypeSystem.String, typeof(ILGeneratorShim).Assembly.GetName().Name));
				moduleDefinition.Assembly.CustomAttributes.Add(customAttribute);
				TypeDefinition typeDefinition = new TypeDefinition("MonoMod.Utils.Cil", "ILGeneratorProxy", Mono.Cecil.TypeAttributes.Public)
				{
					BaseType = moduleDefinition.ImportReference(typeFromHandle)
				};
				moduleDefinition.Types.Add(typeDefinition);
				TypeReference constraintType = moduleDefinition.ImportReference(typeFromHandle2);
				GenericParameter genericParameter = new GenericParameter("TTarget", typeDefinition);
				genericParameter.Constraints.Add(new GenericParameterConstraint(constraintType));
				typeDefinition.GenericParameters.Add(genericParameter);
				FieldDefinition item = new FieldDefinition("Target", Mono.Cecil.FieldAttributes.Public, genericParameter);
				typeDefinition.Fields.Add(item);
				GenericInstanceType genericInstanceType = new GenericInstanceType(typeDefinition);
				genericInstanceType.GenericArguments.Add(genericParameter);
				FieldReference field = new FieldReference("Target", genericParameter, genericInstanceType);
				MethodDefinition methodDefinition = new MethodDefinition(".ctor", Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.HideBySig | Mono.Cecil.MethodAttributes.SpecialName | Mono.Cecil.MethodAttributes.RTSpecialName, moduleDefinition.TypeSystem.Void);
				methodDefinition.Parameters.Add(new ParameterDefinition(genericParameter));
				typeDefinition.Methods.Add(methodDefinition);
				ILProcessor iLProcessor = methodDefinition.Body.GetILProcessor();
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_0);
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_1);
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Stfld, field);
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
				MethodInfo[] methods = typeFromHandle.GetMethods(BindingFlags.Instance | BindingFlags.Public);
				foreach (MethodInfo methodInfo in methods)
				{
					MethodInfo method = typeFromHandle2.GetMethod(methodInfo.Name, (from p in methodInfo.GetParameters()
						select p.ParameterType).ToArray());
					if (method == null)
					{
						continue;
					}
					MethodDefinition methodDefinition2 = new MethodDefinition(methodInfo.Name, Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Virtual | Mono.Cecil.MethodAttributes.HideBySig, moduleDefinition.ImportReference(methodInfo.ReturnType))
					{
						HasThis = true
					};
					ParameterInfo[] parameters = methodInfo.GetParameters();
					foreach (ParameterInfo parameterInfo in parameters)
					{
						methodDefinition2.Parameters.Add(new ParameterDefinition(moduleDefinition.ImportReference(parameterInfo.ParameterType)));
					}
					typeDefinition.Methods.Add(methodDefinition2);
					iLProcessor = methodDefinition2.Body.GetILProcessor();
					iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_0);
					iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldfld, field);
					foreach (ParameterDefinition parameter in methodDefinition2.Parameters)
					{
						iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg, parameter);
					}
					iLProcessor.Emit(method.IsVirtual ? Mono.Cecil.Cil.OpCodes.Callvirt : Mono.Cecil.Cil.OpCodes.Call, iLProcessor.Body.Method.Module.ImportReference(method));
					iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
				}
				assembly = ReflectionHelper.Load(moduleDefinition);
				assembly.SetMonoCorlibInternal(value: true);
			}
			ResolveEventHandler value = (object asmSender, ResolveEventArgs asmArgs) => (new AssemblyName(asmArgs.Name).Name == typeof(ILGeneratorBuilder).Assembly.GetName().Name) ? typeof(ILGeneratorBuilder).Assembly : null;
			AppDomain.CurrentDomain.AssemblyResolve += value;
			try
			{
				ProxyType = assembly.GetType("MonoMod.Utils.Cil.ILGeneratorProxy");
			}
			finally
			{
				AppDomain.CurrentDomain.AssemblyResolve -= value;
			}
			if (ProxyType == null)
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("Couldn't find ILGeneratorShim proxy \"").Append("MonoMod.Utils.Cil.ILGeneratorProxy").Append("\" in autogenerated \"")
					.Append(assembly.FullName)
					.AppendLine("\"");
				Type[] types;
				Exception[] array;
				try
				{
					types = assembly.GetTypes();
					array = null;
				}
				catch (ReflectionTypeLoadException ex)
				{
					types = ex.Types;
					array = new Exception[ex.LoaderExceptions.Length + 1];
					array[0] = ex;
					for (int k = 0; k < ex.LoaderExceptions.Length; k++)
					{
						array[k + 1] = ex.LoaderExceptions[k];
					}
				}
				stringBuilder.AppendLine("Listing all types in autogenerated assembly:");
				Type[] array2 = types;
				for (int i = 0; i < array2.Length; i++)
				{
					stringBuilder.AppendLine(array2[i]?.FullName ?? "<NULL>");
				}
				if (array != null && array.Length != 0)
				{
					stringBuilder.AppendLine("Listing all exceptions:");
					for (int l = 0; l < array.Length; l++)
					{
						stringBuilder.Append('#').Append(l).Append(": ")
							.AppendLine(array[l]?.ToString() ?? "NULL");
					}
				}
				throw new InvalidOperationException(stringBuilder.ToString());
			}
			return ProxyType;
		}
	}

	public abstract int ILOffset { get; }

	public static Type GenericProxyType => ILGeneratorBuilder.GenerateProxy();

	public abstract void BeginCatchBlock(Type exceptionType);

	public abstract void BeginExceptFilterBlock();

	public abstract Label BeginExceptionBlock();

	public abstract void BeginFaultBlock();

	public abstract void BeginFinallyBlock();

	public abstract void BeginScope();

	public abstract LocalBuilder DeclareLocal(Type localType);

	public abstract LocalBuilder DeclareLocal(Type localType, bool pinned);

	public abstract Label DefineLabel();

	public abstract void Emit(System.Reflection.Emit.OpCode opcode);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, byte arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, double arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, short arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, int arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, long arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, ConstructorInfo con);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, Label label);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, Label[] labels);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, LocalBuilder local);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, SignatureHelper signature);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, FieldInfo field);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, MethodInfo meth);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, sbyte arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, float arg);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, string str);

	public abstract void Emit(System.Reflection.Emit.OpCode opcode, Type cls);

	public abstract void EmitCall(System.Reflection.Emit.OpCode opcode, MethodInfo methodInfo, Type[]? optionalParameterTypes);

	public abstract void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConventions callingConvention, Type? returnType, Type[]? parameterTypes, Type[]? optionalParameterTypes);

	public abstract void EmitCalli(System.Reflection.Emit.OpCode opcode, CallingConvention unmanagedCallConv, Type? returnType, Type[]? parameterTypes);

	public abstract void EmitWriteLine(LocalBuilder localBuilder);

	public abstract void EmitWriteLine(FieldInfo fld);

	public abstract void EmitWriteLine(string value);

	public abstract void EndExceptionBlock();

	public abstract void EndScope();

	public abstract void MarkLabel(Label loc);

	public abstract void ThrowException(Type excType);

	public abstract void UsingNamespace(string usingNamespace);

	public ILGenerator GetProxy()
	{
		return (ILGenerator)ILGeneratorBuilder.GenerateProxy().MakeGenericType(GetType()).GetConstructors()[0].Invoke(new object[1] { this });
	}

	public static Type GetProxyType<TShim>() where TShim : ILGeneratorShim
	{
		return GetProxyType(typeof(TShim));
	}

	public static Type GetProxyType(Type tShim)
	{
		return GenericProxyType.MakeGenericType(tShim);
	}
}


using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using Mono.Cecil;
using Mono.Cecil.Cil;

internal static class ILGeneratorBuilder
{
	public const string Namespace = "MonoMod.Utils.Cil";

	public const string Name = "ILGeneratorProxy";

	public const string FullName = "MonoMod.Utils.Cil.ILGeneratorProxy";

	public const string TargetName = "Target";

	private static Type? ProxyType;

	public static Type GenerateProxy()
	{
		if (ProxyType != null)
		{
			return ProxyType;
		}
		Type typeFromHandle = typeof(ILGenerator);
		Type typeFromHandle2 = typeof(ILGeneratorShim);
		Assembly assembly;
		using (ModuleDefinition moduleDefinition = ModuleDefinition.CreateModule("MonoMod.Utils.Cil.ILGeneratorProxy", new ModuleParameters
		{
			Kind = ModuleKind.Dll,
			ReflectionImporterProvider = MMReflectionImporter.Provider
		}))
		{
			CustomAttribute customAttribute = new CustomAttribute(moduleDefinition.ImportReference(DynamicMethodDefinition.c_IgnoresAccessChecksToAttribute));
			customAttribute.ConstructorArguments.Add(new CustomAttributeArgument(moduleDefinition.TypeSystem.String, typeof(ILGeneratorShim).Assembly.GetName().Name));
			moduleDefinition.Assembly.CustomAttributes.Add(customAttribute);
			TypeDefinition typeDefinition = new TypeDefinition("MonoMod.Utils.Cil", "ILGeneratorProxy", Mono.Cecil.TypeAttributes.Public)
			{
				BaseType = moduleDefinition.ImportReference(typeFromHandle)
			};
			moduleDefinition.Types.Add(typeDefinition);
			TypeReference constraintType = moduleDefinition.ImportReference(typeFromHandle2);
			GenericParameter genericParameter = new GenericParameter("TTarget", typeDefinition);
			genericParameter.Constraints.Add(new GenericParameterConstraint(constraintType));
			typeDefinition.GenericParameters.Add(genericParameter);
			FieldDefinition item = new FieldDefinition("Target", Mono.Cecil.FieldAttributes.Public, genericParameter);
			typeDefinition.Fields.Add(item);
			GenericInstanceType genericInstanceType = new GenericInstanceType(typeDefinition);
			genericInstanceType.GenericArguments.Add(genericParameter);
			FieldReference field = new FieldReference("Target", genericParameter, genericInstanceType);
			MethodDefinition methodDefinition = new MethodDefinition(".ctor", Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.HideBySig | Mono.Cecil.MethodAttributes.SpecialName | Mono.Cecil.MethodAttributes.RTSpecialName, moduleDefinition.TypeSystem.Void);
			methodDefinition.Parameters.Add(new ParameterDefinition(genericParameter));
			typeDefinition.Methods.Add(methodDefinition);
			ILProcessor iLProcessor = methodDefinition.Body.GetILProcessor();
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_0);
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_1);
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Stfld, field);
			iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
			MethodInfo[] methods = typeFromHandle.GetMethods(BindingFlags.Instance | BindingFlags.Public);
			foreach (MethodInfo methodInfo in methods)
			{
				MethodInfo method = typeFromHandle2.GetMethod(methodInfo.Name, (from p in methodInfo.GetParameters()
					select p.ParameterType).ToArray());
				if (method == null)
				{
					continue;
				}
				MethodDefinition methodDefinition2 = new MethodDefinition(methodInfo.Name, Mono.Cecil.MethodAttributes.Public | Mono.Cecil.MethodAttributes.Virtual | Mono.Cecil.MethodAttributes.HideBySig, moduleDefinition.ImportReference(methodInfo.ReturnType))
				{
					HasThis = true
				};
				ParameterInfo[] parameters = methodInfo.GetParameters();
				foreach (ParameterInfo parameterInfo in parameters)
				{
					methodDefinition2.Parameters.Add(new ParameterDefinition(moduleDefinition.ImportReference(parameterInfo.ParameterType)));
				}
				typeDefinition.Methods.Add(methodDefinition2);
				iLProcessor = methodDefinition2.Body.GetILProcessor();
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg_0);
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldfld, field);
				foreach (ParameterDefinition parameter in methodDefinition2.Parameters)
				{
					iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ldarg, parameter);
				}
				iLProcessor.Emit(method.IsVirtual ? Mono.Cecil.Cil.OpCodes.Callvirt : Mono.Cecil.Cil.OpCodes.Call, iLProcessor.Body.Method.Module.ImportReference(method));
				iLProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret);
			}
			assembly = ReflectionHelper.Load(moduleDefinition);
			assembly.SetMonoCorlibInternal(value: true);
		}
		ResolveEventHandler value = (object asmSender, ResolveEventArgs asmArgs) => (new AssemblyName(asmArgs.Name).Name == typeof(ILGeneratorBuilder).Assembly.GetName().Name) ? typeof(ILGeneratorBuilder).Assembly : null;
		AppDomain.CurrentDomain.AssemblyResolve += value;
		try
		{
			ProxyType = assembly.GetType("MonoMod.Utils.Cil.ILGeneratorProxy");
		}
		finally
		{
			AppDomain.CurrentDomain.AssemblyResolve -= value;
		}
		if (ProxyType == null)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("Couldn't find ILGeneratorShim proxy \"").Append("MonoMod.Utils.Cil.ILGeneratorProxy").Append("\" in autogenerated \"")
				.Append(assembly.FullName)
				.AppendLine("\"");
			Type[] types;
			Exception[] array;
			try
			{
				types = assembly.GetTypes();
				array = null;
			}
			catch (ReflectionTypeLoadException ex)
			{
				types = ex.Types;
				array = new Exception[ex.LoaderExceptions.Length + 1];
				array[0] = ex;
				for (int k = 0; k < ex.LoaderExceptions.Length; k++)
				{
					array[k + 1] = ex.LoaderExceptions[k];
				}
			}
			stringBuilder.AppendLine("Listing all types in autogenerated assembly:");
			Type[] array2 = types;
			for (int i = 0; i < array2.Length; i++)
			{
				stringBuilder.AppendLine(array2[i]?.FullName ?? "<NULL>");
			}
			if (array != null && array.Length != 0)
			{
				stringBuilder.AppendLine("Listing all exceptions:");
				for (int l = 0; l < array.Length; l++)
				{
					stringBuilder.Append('#').Append(l).Append(": ")
						.AppendLine(array[l]?.ToString() ?? "NULL");
				}
			}
			throw new InvalidOperationException(stringBuilder.ToString());
		}
		return ProxyType;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using MonoMod.Utils;
using MonoMod.Utils.Cil;

internal static class ILGeneratorShimExt
{
	private static readonly Dictionary<Type, MethodInfo> _Emitters;

	private static readonly Dictionary<Type, MethodInfo> _EmittersShim;

	static ILGeneratorShimExt()
	{
		_Emitters = new Dictionary<Type, MethodInfo>();
		_EmittersShim = new Dictionary<Type, MethodInfo>();
		MethodInfo[] methods = typeof(ILGenerator).GetMethods();
		foreach (MethodInfo methodInfo in methods)
		{
			if (!(methodInfo.Name != "Emit"))
			{
				ParameterInfo[] parameters = methodInfo.GetParameters();
				if (parameters.Length == 2 && !(parameters[0].ParameterType != typeof(OpCode)))
				{
					_Emitters[parameters[1].ParameterType] = methodInfo;
				}
			}
		}
		methods = typeof(ILGeneratorShim).GetMethods();
		foreach (MethodInfo methodInfo2 in methods)
		{
			if (!(methodInfo2.Name != "Emit"))
			{
				ParameterInfo[] parameters2 = methodInfo2.GetParameters();
				if (parameters2.Length == 2 && !(parameters2[0].ParameterType != typeof(OpCode)))
				{
					_EmittersShim[parameters2[1].ParameterType] = methodInfo2;
				}
			}
		}
	}

	public static ILGeneratorShim GetProxiedShim(this ILGenerator il)
	{
		return (ILGeneratorShim)(Helpers.ThrowIfNull(il, "il").GetType().GetField("Target", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)?.GetValue(il));
	}

	public static T GetProxiedShim<T>(this ILGenerator il) where T : ILGeneratorShim
	{
		return (T)il.GetProxiedShim();
	}

	public static object? DynEmit(this ILGenerator il, OpCode opcode, object operand)
	{
		return il.DynEmit(new object[2] { opcode, operand });
	}

	public static object? DynEmit(this ILGenerator il, object[] emitArgs)
	{
		Helpers.ThrowIfArgumentNull(emitArgs, "emitArgs");
		Type operandType = emitArgs[1].GetType();
		object obj = ((object)il.GetProxiedShim()) ?? ((object)il);
		Dictionary<Type, MethodInfo> dictionary = ((obj is ILGeneratorShim) ? _EmittersShim : _Emitters);
		if (!dictionary.TryGetValue(operandType, out var value))
		{
			value = dictionary.FirstOrDefault((KeyValuePair<Type, MethodInfo> kvp) => kvp.Key.IsAssignableFrom(operandType)).Value;
		}
		if (value == null)
		{
			throw new InvalidOperationException("Unexpected unemittable operand type " + operandType.FullName);
		}
		return value.Invoke(obj, emitArgs);
	}
}


using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal static class IsExternalInit
{
}


using System;

[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
internal sealed class IgnoresAccessChecksToAttribute : Attribute
{
	public string AssemblyName { get; }

	public IgnoresAccessChecksToAttribute(string assemblyName)
	{
		AssemblyName = assemblyName;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class AllowNullAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class DisallowNullAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class DoesNotReturnAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class DoesNotReturnIfAttribute : Attribute
{
	public bool ParameterValue { get; }

	public DoesNotReturnIfAttribute(bool parameterValue)
	{
		ParameterValue = parameterValue;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class MaybeNullAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class MaybeNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public MaybeNullWhenAttribute(bool returnValue)
	{
		ReturnValue = returnValue;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class MemberNotNullAttribute : Attribute
{
	public string[] Members { get; }

	public MemberNotNullAttribute(string member)
	{
		Members = new string[1] { member };
	}

	public MemberNotNullAttribute(params string[] members)
	{
		Members = members;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class MemberNotNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public string[] Members { get; }

	public MemberNotNullWhenAttribute(bool returnValue, string member)
	{
		ReturnValue = returnValue;
		Members = new string[1] { member };
	}

	public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
	{
		ReturnValue = returnValue;
		Members = members;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class NotNullAttribute : Attribute
{
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class NotNullIfNotNullAttribute : Attribute
{
	public string ParameterName { get; }

	public NotNullIfNotNullAttribute(string parameterName)
	{
		ParameterName = parameterName;
	}
}


using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Parameter, Inherited = false)]
[ExcludeFromCodeCoverage]
[DebuggerNonUserCode]
internal sealed class NotNullWhenAttribute : Attribute
{
	public bool ReturnValue { get; }

	public NotNullWhenAttribute(bool returnValue)
	{
		ReturnValue = returnValue;
	}
}


internal static class SR
{
}


using System;
using System.Resources;
using System.Runtime.CompilerServices;
using FxResources.System.ValueTuple;

internal static class SR
{
	private static ResourceManager s_resourceManager;

	private static ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new ResourceManager(ResourceType));

	internal static Type ResourceType { get; } = typeof(SR);

	internal static string ArgumentException_ValueTupleIncorrectType => GetResourceString("ArgumentException_ValueTupleIncorrectType", null);

	internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple => GetResourceString("ArgumentException_ValueTupleLastArgumentNotAValueTuple", null);

	[MethodImpl(MethodImplOptions.NoInlining)]
	private static bool UsingResourceKeys()
	{
		return false;
	}

	internal static string GetResourceString(string resourceKey, string defaultString)
	{
		string text = null;
		try
		{
			text = ResourceManager.GetString(resourceKey);
		}
		catch (MissingManifestResourceException)
		{
		}
		if (defaultString != null && resourceKey.Equals(text, StringComparison.Ordinal))
		{
			return defaultString;
		}
		return text;
	}

	internal static string Format(string resourceFormat, params object[] args)
	{
		if (args != null)
		{
			if (UsingResourceKeys())
			{
				return resourceFormat + string.Join(", ", args);
			}
			return string.Format(resourceFormat, args);
		}
		return resourceFormat;
	}

	internal static string Format(string resourceFormat, object p1)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1);
		}
		return string.Format(resourceFormat, p1);
	}

	internal static string Format(string resourceFormat, object p1, object p2)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1, p2);
		}
		return string.Format(resourceFormat, p1, p2);
	}

	internal static string Format(string resourceFormat, object p1, object p2, object p3)
	{
		if (UsingResourceKeys())
		{
			return string.Join(", ", resourceFormat, p1, p2, p3);
		}
		return string.Format(resourceFormat, p1, p2, p3);
	}
}


