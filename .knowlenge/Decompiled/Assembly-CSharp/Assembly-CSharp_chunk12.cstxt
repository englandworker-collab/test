using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct BoxBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float r = R * R;
		for (float num = val2.x; num <= val3.x; num += 1f)
		{
			for (float num2 = val2.y; num2 <= val3.y; num2 += 1f)
			{
				for (float num3 = val2.z; num3 <= val3.z; num3 += 1f)
				{
					float3 val5 = math.float3(num, num2, num3);
					int3 val6 = math.int3(val5);
					if (!Grid.InBoundsNotTouching(val6) || !SculptMathUtil.InFlatEndedCapsule(P0, val4, v, r, val5))
					{
						continue;
					}
					float num4 = 0f;
					int num5 = 0;
					for (int i = -1; i <= 1; i++)
					{
						for (int j = -1; j <= 1; j++)
						{
							for (int k = -1; k <= 1; k++)
							{
								if (i != 0 || j != 0 || k != 0)
								{
									int3 val7 = val6 + new int3(i, j, k);
									if (Grid.InBounds(val7))
									{
										num4 += Grid.Sample(val7);
										num5++;
									}
								}
							}
						}
					}
					Grid[val6] = num4 / (float)num5 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val2))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int l = -1; l <= 1; l++)
					{
						for (int m = -1; m <= 1; m++)
						{
							for (int n = -1; n <= 1; n++)
							{
								if (l != 0 || m != 0 || n != 0)
								{
									int3 val3 = val2 + new int3(l, m, n);
									if (Grid.InBounds(val3))
									{
										num2 += Grid.Sample(val3);
										num3++;
									}
								}
							}
						}
					}
					Grid[val2] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct CarveAndBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float num = R * R;
		NativeList<int3> val5 = default(NativeList<int3>);
		val5..ctor((int)num, AllocatorHandle.op_Implicit((Allocator)2));
		for (float num2 = val2.x; num2 <= val3.x; num2 += 1f)
		{
			for (float num3 = val2.y; num3 <= val3.y; num3 += 1f)
			{
				for (float num4 = val2.z; num4 <= val3.z; num4 += 1f)
				{
					float3 val6 = math.float3(num2, num3, num4);
					int3 p = math.int3(val6);
					if (Grid.InBounds(p) && SculptMathUtil.InFlatEndedCapsule(P0, val4, v, num, val6))
					{
						Grid[p] = false;
						val5.Add(ref p);
					}
				}
			}
		}
		NativeArray<int3> val7 = val5.AsArray();
		int length = val5.Length;
		for (int i = 0; i < length; i++)
		{
			int3 val8 = val7[i];
			if (!Grid.InBoundsNotTouching(val8))
			{
				continue;
			}
			float num5 = 0f;
			int num6 = 0;
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					for (int l = -1; l <= 1; l++)
					{
						if (j != 0 || k != 0 || l != 0)
						{
							int3 val9 = val8 + new int3(j, k, l);
							if (Grid.InBounds(val9))
							{
								num5 += Grid.Sample(val9);
								num6++;
							}
						}
					}
				}
			}
			Grid[val8] = num5 / (float)num6 > 0.5f;
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CarveAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBounds(val2))
					{
						Grid[val2] = false;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using System;
using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Profiling;

[BurstCompile]
internal struct CleanFloatingIslandsJob : IJob
{
	private struct NativeStack : IDisposable
	{
		public NativeList<int3> arr;

		public NativeStack(Allocator allocator)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
		}

		public void Dispose()
		{
			arr.Dispose();
		}

		public void Push(int3 v)
		{
			arr.Add(ref v);
		}

		public bool TryPop(out int3 v)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			v = default(int3);
			if (arr.Length == 0)
			{
				return false;
			}
			v = arr[arr.Length - 1];
			arr.RemoveAtSwapBack(arr.Length - 1);
			return true;
		}
	}

	public Point3DGrid Sampler;

	public static readonly ProfilerMarker k_Init = new ProfilerMarker("Init");

	public static readonly ProfilerMarker k_Flood = new ProfilerMarker("Flood");

	public static readonly ProfilerMarker k_Copy = new ProfilerMarker("CopyBack");

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray other = default(NativeBitArray);
		((NativeBitArray)(ref other))..ctor(Sampler.Length, AllocatorHandle.op_Implicit((Allocator)2), (NativeArrayOptions)1);
		NativeStack nativeStack = new NativeStack((Allocator)2);
		int width = Sampler.Width;
		int depth = Sampler.Depth;
		int3 val = default(int3);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < depth; j++)
			{
				((int3)(ref val))..ctor(i, 1, j);
				int num = Sampler.ToIndex(val);
				if (Sampler[num])
				{
					nativeStack.Push(val);
					((NativeBitArray)(ref other)).Set(num, true);
				}
			}
		}
		int3 v;
		int3 val2 = default(int3);
		while (nativeStack.TryPop(out v))
		{
			int num2 = v.x - 1;
			((int3)(ref val2))..ctor(num2, ((int3)(ref v)).yz);
			int num3 = 0;
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(--num2, ((int3)(ref v)).yz);
			}
			int num4 = v.x + 1;
			((int3)(ref val2))..ctor(num4, ((int3)(ref v)).yz);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(++num4, ((int3)(ref v)).yz);
			}
			int num5 = v.z - 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num5);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, --num5);
			}
			int num6 = v.z + 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num6);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, ++num6);
			}
			for (int k = num2; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					for (int m = -1; m <= 1; m += 2)
					{
						((int3)(ref val2))..ctor(k, v.y + m, l);
						if (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
						{
							nativeStack.Push(val2);
							((NativeBitArray)(ref other)).Set(num3, true);
						}
					}
				}
			}
		}
		Sampler.CopyFromNativeBitArray(ref other);
	}
}


using System;
using Unity.Collections;
using Unity.Mathematics;

private struct NativeStack : IDisposable
{
	public NativeList<int3> arr;

	public NativeStack(Allocator allocator)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
	}

	public void Dispose()
	{
		arr.Dispose();
	}

	public void Push(int3 v)
	{
		arr.Add(ref v);
	}

	public bool TryPop(out int3 v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		v = default(int3);
		if (arr.Length == 0)
		{
			return false;
		}
		v = arr[arr.Length - 1];
		arr.RemoveAtSwapBack(arr.Length - 1);
		return true;
	}
}


using Unity.Mathematics;

public static class SculptMathUtil
{
	public static bool InFlatEndedCapsule(float3 p0, float3 v, float v2, float r2, float3 check)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		float3 val = check - p0;
		if (math.dot(val, v) > v2)
		{
			return false;
		}
		return math.lengthsq(math.cross(val, v)) * math.rcp(v2) <= r2;
	}
}


using System;
using UnityEngine;

public class SculptingToolData : PrefabAttribute
{
	public enum CarvingShapeType
	{
		Cylinder,
		Sphere,
		Rectangle
	}

	[Flags]
	public enum CarvingMode
	{
		Carve = 1,
		Smooth = 2,
		Additive = 4
	}

	public CarvingShapeType CarvingShape;

	public CarvingMode CarvingModes = CarvingMode.Carve | CarvingMode.Smooth | CarvingMode.Additive;

	public Vector2Int CarvingSizeLimits = new Vector2Int(2, 5);

	public bool AllowCarve => (CarvingModes & CarvingMode.Carve) != 0;

	public bool AllowSmooth => (CarvingModes & CarvingMode.Smooth) != 0;

	public bool AllowAdditive => (CarvingModes & CarvingMode.Additive) != 0;

	public int MinCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).x;

	public int MaxCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).y;

	protected override Type GetIndexedType()
	{
		return typeof(SculptingToolData);
	}
}


public enum CarvingShapeType
{
	Cylinder,
	Sphere,
	Rectangle
}


using System;

[Flags]
public enum CarvingMode
{
	Carve = 1,
	Smooth = 2,
	Additive = 4
}


public class SeasonalTimedExplosive : TimedExplosive
{
	public RandomRendererEnable randomRenderer;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

public class ServerProjectile : EntityComponent<BaseEntity>
{
	public interface IProjectileImpact
	{
		void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
	}

	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float speed = 15f;

	public float scanRange;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float radius;

	public bool IgnoreAI;

	[HideInInspector]
	public BaseEntity ignoreEntity;

	protected bool shouldMoveProjectile = true;

	public bool impacted;

	public float swimRandom;

	public virtual bool HasRangeLimit => true;

	protected virtual int mask => 1237003025;

	public Vector3 CurrentVelocity { get; set; }

	public bool Impacted => impacted;

	public float GetMaxRange(float maxFuseTime)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (gravityModifier == 0f)
		{
			return float.PositiveInfinity;
		}
		float num = Mathf.Sin(MathF.PI / 2f) * speed * speed / (0f - Physics.gravity.y * gravityModifier);
		float num2 = speed * maxFuseTime;
		return Mathf.Min(num, num2);
	}

	protected void FixedUpdate()
	{
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.isServer)
		{
			DoMovement();
		}
	}

	public void AdjustVelocity(Vector3 adjustment)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		CurrentVelocity += adjustment;
	}

	public virtual Vector3 GetVelocityStep()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return Physics.gravity * gravityModifier * Time.fixedDeltaTime * Time.timeScale;
	}

	public virtual void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate())
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		initialVelocity = overrideVel;
		CurrentVelocity = overrideVel;
	}

	public void SetVelocity(Vector3 overrideVel)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate() && overrideVel != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		CurrentVelocity = overrideVel;
	}

	public virtual bool DoMovement()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.isClient)
		{
			return false;
		}
		if (impacted)
		{
			return false;
		}
		CurrentVelocity += GetVelocityStep();
		Vector3 val = AddSwim(CurrentVelocity);
		float num = ((Vector3)(ref val)).magnitude * Time.fixedDeltaTime;
		if (DoHitDetection(val, num))
		{
			return false;
		}
		if (shouldMoveProjectile)
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * num;
		}
		if (AutomaticallyRotate() && val != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		}
		PostDoMove();
		return true;
	}

	protected virtual bool DoHitDetection(Vector3 velocityToUse, float distance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = ((Component)this).transform.position;
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), radius, list, distance + scanRange, mask, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity)) && IsAValidHit(entity) && IsShootable(item))
			{
				ProcessHit(item, entity, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	private Vector3 AddSwim(Vector3 currentVelocity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentVelocity;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num = Time.time + swimRandom;
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(Mathf.Sin(num * swimSpeed.x) * swimScale.x, Mathf.Cos(num * swimSpeed.y) * swimScale.y, Mathf.Sin(num * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			val += val2;
		}
		return val;
	}

	protected void ProcessHit(RaycastHit hitInfo, BaseEntity hitEnt, Vector3 rayOrigin)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.forward * Mathf.Max(0f, ((RaycastHit)(ref hitInfo)).distance - 0.1f);
		((Component)this).GetComponent<IProjectileImpact>()?.ProjectileImpact(hitInfo, rayOrigin);
		SingletonComponent<NpcNoiseManager>.Instance.OnServerProjectileHit(base.baseEntity, this, hitInfo);
		impacted = true;
		OnHit(hitInfo, hitEnt);
		PostDoMove();
	}

	protected bool IsShootable(RaycastHit hitInfo)
	{
		ColliderInfo colliderInfo = (((Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null) ? ((Component)((RaycastHit)(ref hitInfo)).collider).GetComponent<ColliderInfo>() : null);
		if (!((Object)(object)colliderInfo == (Object)null))
		{
			return colliderInfo.HasFlag(ColliderInfo.Flags.Shootable);
		}
		return true;
	}

	protected virtual void OnHit(RaycastHit rayHit, BaseEntity hitEntity)
	{
	}

	protected virtual void PostDoMove()
	{
	}

	protected virtual bool IsAValidHit(BaseEntity hitEnt)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEnt.IsValid())
		{
			return true;
		}
		if (base.baseEntity.creatorEntity.IsValid() && hitEnt.net.ID == base.baseEntity.creatorEntity.net.ID)
		{
			return false;
		}
		if (ignoreEntity.IsValid() && hitEnt.net.ID == ignoreEntity.net.ID)
		{
			return false;
		}
		return true;
	}

	protected virtual bool IsAnIgnoredAI(BaseEntity hitEnt)
	{
		return hitEnt is ScientistNPC;
	}

	protected virtual bool AutomaticallyRotate()
	{
		return true;
	}
}


using UnityEngine;

public interface IProjectileImpact
{
	void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
}


using System;
using UnityEngine;

public class Ballista : BaseSiegeWeapon
{
	[Header("Ballista")]
	public GameObjectRef ballistaGunPrefab;

	public EntityRef<BallistaGun> ballistaGunRef;

	public Transform dismountPositionsParent;

	[SerializeField]
	[Header("Effects")]
	private GameObjectRef fireEffectPrefab;

	public override float DriveWheelVelocity { get; }

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == ballistaGunPrefab.GetEntity().prefabID)
		{
			BallistaGun ballistaGun = (BallistaGun)child;
			ballistaGunRef.Set(ballistaGun);
			ballistaGun.ballistaOwner = this;
		}
	}

	private BallistaGun GetBallistaGun()
	{
		BallistaGun ballistaGun = ballistaGunRef.Get(base.isServer);
		if (ballistaGun.IsValid())
		{
			return ballistaGun;
		}
		return null;
	}

	protected override bool CanPullNow(BasePlayer puller)
	{
		if (base.CanPullNow(puller))
		{
			return !IsGunMounted();
		}
		return false;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (base.CanPushNow(pusher))
		{
			return !IsGunMounted();
		}
		return false;
	}

	public bool IsGunMounted()
	{
		BallistaGun ballistaGun = GetBallistaGun();
		if ((Object)(object)ballistaGun != (Object)null)
		{
			return ballistaGun.IsMounted();
		}
		return false;
	}

	protected override void CreateEngineController()
	{
	}

	private void RotateDismountPositions()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ballistaGunRef.Get(base.isServer) != (Object)null)
		{
			dismountPositionsParent.rotation = ((Component)ballistaGunRef.Get(base.isServer)).transform.rotation;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		mountPose = PlayerModel.MountPoses.StandDrive;
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
	}

	public override BasePlayer GetMounted()
	{
		return GetDriver();
	}

	public override void OnTowAttach()
	{
		base.OnTowAttach();
		DismountAllPlayers();
	}

	public void OnFired()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (fireEffectPrefab != null && fireEffectPrefab.isValid)
		{
			Effect.server.Run(fireEffectPrefab.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.VehicleFixedUpdate();
		Vector3 worldVelocity = GetWorldVelocity();
		if (((Vector3)(ref worldVelocity)).magnitude > 5f || IsFlipping())
		{
			DismountAllPlayers();
		}
		RotateDismountPositions();
	}

	protected override void DoPushAction(BasePlayer player)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null))
		{
			Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.position - player.eyes.position, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float num = rigidBody.mass * 2.4f;
			rigidBody.AddForce(normalized * num, (ForceMode)1);
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	public override void LightToggle(BasePlayer player)
	{
	}
}


public class BallistaAnimationEvents : FacepunchBehaviour
{
	public BallistaGun ballista;

	public SoundDefinition reloadClickSoundDef;

	public SoundDefinition reloadWrenchForwardDef;

	public SoundDefinition reloadCompleteDef;
}


public class BaseSiegeWeaponVisuals : VehicleChassisVisuals<BaseSiegeWeapon>, IClientComponent
{
}


using UnityEngine;

public class SiegeWeaponVehicleAudio : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadProgressDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	public SoundDefinition reloadCompleteDef;

	[Header("Rattles")]
	[SerializeField]
	private SoundDefinition movementRattleLoop;

	[SerializeField]
	private float movementRattleMaxSpeed = 10f;

	[SerializeField]
	private float movementRattleIdleGain = 0.3f;

	[SerializeField]
	private float movementRattleGainChangeSpeed = 1f;

	[Header("Wheels")]
	[SerializeField]
	private SoundDefinition tyreRollingSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingWaterSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingGrassSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingSnowSoundDef;

	[SerializeField]
	private AnimationCurve tyreRollGainCurve;
}


using Rust;
using UnityEngine;

public class BatteringRamHead : BaseCombatEntity
{
	public float damagedHealthThreshold = 100f;

	public float brokenHealthThreshold = 20f;

	public Collider serverCollider;

	[HideInInspector]
	public BatteringRam batteringRamOwner;

	[HideInInspector]
	public DamageRenderer damageRenderer;

	public const Flags Flags_DamagedLow = Flags.Reserved6;

	public const Flags Flags_DamagedMid = Flags.Reserved7;

	public const Flags Flags_DamagedHeavy = Flags.Reserved8;

	public bool CanBeUsed()
	{
		return base.health > brokenHealthThreshold;
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateBrokenFlag();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateBrokenFlag();
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		UpdateDamageFlags();
	}

	private void UpdateDamageFlags()
	{
		float num = base.healthFraction;
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved7, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, b: false);
		if (num <= 0.1f)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (num <= 0.5f)
		{
			SetFlag(Flags.Reserved7, b: true);
		}
		else if (num <= 0.75f)
		{
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	private void UpdateBrokenFlag()
	{
		if (CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: false);
			SetFlag(Flags.Broken, b: false);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 0f;
	}

	public void TakeDamage(float damage)
	{
		damage = Mathf.Min(damage, base.health - 10f);
		Hurt(damage, DamageType.Blunt, this, useProtection: false);
		if (!CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: true);
			SetFlag(Flags.Broken, b: true);
		}
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		BatteringRamHead[] array = Util.FindAll<BatteringRamHead>();
		foreach (BatteringRamHead batteringRamHead in array)
		{
			if (batteringRamHead.isServer && Vector3.Distance(((Component)batteringRamHead).transform.position, ((Component)basePlayer).transform.position) <= 10f)
			{
				batteringRamHead.TakeDamage(@float);
			}
		}
	}
}


public class BatteringRamSeat : BaseVehicleSeat
{
}


using UnityEngine;

public class BatteringRamVehicleAudio : SiegeWeaponVehicleAudio
{
	public Transform lightToggleSoundPos;
}


using UnityEngine;

public class BatteringRamVisuals : BaseSiegeWeaponVisuals, IClientComponent
{
	private BatteringRam ram;

	public Transform frontAxle;

	public Transform middleAxle;

	public Transform rearAxle;

	[Space]
	public ParticleSystem rockDoorParticle;

	public ParticleSystem dirtDoorParticle;
}


using System;
using UnityEngine;

public class CatapultAmmoContainer : StorageContainer
{
	[NonSerialized]
	public Catapult catapult;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		catapult.UpdateLoadedAmmo(item, added);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if ((Object)(object)catapult != (Object)null)
		{
			return catapult.CanBeLooted(player);
		}
		return false;
	}
}


public class CatapultAnimationEvents : FacepunchBehaviour
{
	public Catapult catapult;

	public SoundDefinition reloadClickSoundDef;

	public void PlayReloadClick()
	{
	}

	public void PlaySound(SoundDefinition def)
	{
	}
}


using UnityEngine;

public class CatapultSounds : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadLoopDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[Header("Movement")]
	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private float movementGainAdjustmentSpeed = 5f;
}


using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ConstructableEntity : StorageContainer
{
	[Header("Constructable Entity")]
	public List<ItemAmount> ingredients = new List<ItemAmount>();

	private int[] currentMaterials;

	public GameObjectRef entityToSpawn;

	public PlayerDetectionTrigger trigger;

	public bool onlyRunTriggerCheckOnLastHit;

	public bool onlyBlockWhenStanding;

	public GameObject[] states;

	public SoundDefinition[] stateSounds;

	public GameObjectRef spawnEffect;

	public bool additiveMode;

	private int currentState;

	private void SetState(int index)
	{
		if (index < 0 || index >= states.Length)
		{
			return;
		}
		if (additiveMode)
		{
			for (int i = 0; i < states.Length; i++)
			{
				states[i].SetActive(i <= index);
			}
		}
		else
		{
			GameObject[] array = states;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(false);
			}
			states[index].SetActive(true);
		}
		currentState = index;
	}

	private void UpdateState()
	{
		int num = Mathf.FloorToInt(GetTotalMaterialFraction() * (float)states.Length);
		num = Mathf.Clamp(num, 0, states.Length - 1);
		if (num != currentState)
		{
			if (base.isServer)
			{
				timePlaced = GetNetworkTime();
			}
			SetState(num);
		}
	}

	private float GetTotalMaterialFraction()
	{
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += Mathf.Min((float)currentMaterials[i], ingredients[i].amount);
			num2 += ingredients[i].amount;
		}
		if (!(num2 > 0f))
		{
			return 0f;
		}
		return num / num2;
	}

	public bool IsNearlyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			float num = Mathf.Max(0f, ingredients[i].amount - (float)currentMaterials[i]);
			if (!(num <= 0f))
			{
				int num2 = Mathf.CeilToInt(ingredients[i].amount / 10f);
				if (num > (float)num2)
				{
					return false;
				}
			}
		}
		return true;
	}

	public override void ServerInit()
	{
		SetState(0);
		base.ServerInit();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.OnRepairFinished(player);
		ulong ownerID = base.OwnerID;
		Kill();
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityToSpawn.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
		baseEntity.OwnerID = ownerID;
		baseEntity.Spawn();
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 5f;
	}

	public override void DoRepair(BasePlayer player)
	{
		if (!CanRepair(player))
		{
			return;
		}
		bool flag = false;
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			ItemAmount itemAmount = ingredients[i];
			float num2 = Mathf.Max(0f, itemAmount.amount - (float)currentMaterials[i]);
			if (num2 != 0f)
			{
				int num3 = Mathf.CeilToInt(itemAmount.amount / 10f);
				int num4 = player.inventory.GetAmount(itemAmount.itemid);
				if (player.IsInCreativeMode && Creative.freeRepair)
				{
					num4 = int.MaxValue;
				}
				int num5 = Mathf.Min(new int[3]
				{
					num3,
					num4,
					Mathf.FloorToInt(num2)
				});
				if (num5 > 0)
				{
					currentMaterials[i] += num5;
					player.inventory.Take(null, itemAmount.itemid, num5);
					player.Command("note.inv", itemAmount.itemid, num5 * -1);
					flag = true;
					float num6 = MaxHealth() * (itemAmount.amount / GetTotalRequiredMaterials());
					num += num6 * ((float)num5 / itemAmount.amount);
				}
				else
				{
					OnBuildFailedResources(player, itemAmount.itemDef.itemid);
				}
			}
		}
		if (num != 0f)
		{
			SetHealth(Mathf.Min(Health() + num, MaxHealth()));
		}
		if (flag)
		{
			SendNetworkUpdate();
			UpdateState();
			if (IsFullyBuilt())
			{
				OnRepairFinished(player);
			}
			else
			{
				OnRepair();
			}
		}
	}

	public void OnBuildFailedResources(BasePlayer player, int itemID)
	{
		if ((Object)(object)player != (Object)null)
		{
			player.ClientRPC(RpcTarget.Player("Client_OnConstructableBuildFailed", player), itemID);
		}
	}

	private bool IsFullyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			if ((float)currentMaterials[i] < ingredients[i].amount)
			{
				return false;
			}
		}
		return true;
	}

	private float GetTotalRequiredMaterials()
	{
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += ingredients[i].amount;
		}
		return num;
	}

	protected virtual bool CanRepair(BasePlayer player)
	{
		if ((Object)(object)trigger != (Object)null && trigger.entityContents != null)
		{
			if (onlyRunTriggerCheckOnLastHit && !IsNearlyBuilt())
			{
				return true;
			}
			foreach (BaseEntity entityContent in trigger.entityContents)
			{
				if (entityContent is BaseVehicle baseVehicle)
				{
					if (!baseVehicle.IsDead() && !baseVehicle.isClient && !((Object)(object)((Component)baseVehicle).transform.root == (Object)(object)((Component)this).transform))
					{
						player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByVehicle, false);
						return false;
					}
				}
				else if (entityContent is BasePlayer { isClient: false } basePlayer && !basePlayer.IsDead() && (!onlyBlockWhenStanding || basePlayer.IsStandingOnEntity(this, 134226176)))
				{
					player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, overlay: false, (string[])null);
					return false;
				}
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.constructableEntity = Pool.Get<ConstructableEntity>();
		if (currentMaterials == null || currentMaterials.IsEmpty())
		{
			currentMaterials = new int[ingredients.Count];
			for (int i = 0; i < ingredients.Count; i++)
			{
				currentMaterials[i] = 0;
			}
		}
		info.msg.constructableEntity.addedResources = currentMaterials.ToList();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.constructableEntity != null)
		{
			currentMaterials = info.msg.constructableEntity.addedResources.ToArray();
		}
		UpdateState();
	}
}


using UnityEngine;

public class SiegeTowerDoor : Door
{
	private SiegeTower tower;

	protected override bool OnlyCheckForVehicles()
	{
		return false;
	}

	protected override bool InverseDotCheck()
	{
		return true;
	}

	protected override bool CheckOnClose()
	{
		return false;
	}

	public void SetupDoor(SiegeTower tower)
	{
		this.tower = tower;
	}

	private void UpdateTowerHP()
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedSetHealth(base.health);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateTowerHP();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateTowerHP();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)tower != (Object)null && !tower.IsDead())
		{
			tower.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)tower != (Object)null && old != next)
		{
			tower.RefreshLastUseTime();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class StabilityEntity : DecayEntity
{
	public class StabilityCheckWorkQueue : ObjectWorkQueue<StabilityEntity>
	{
		protected override void RunJob(StabilityEntity entity)
		{
			if (((ObjectWorkQueue<StabilityEntity>)this).ShouldAdd(entity))
			{
				entity.StabilityCheck();
			}
		}

		protected override bool ShouldAdd(StabilityEntity entity)
		{
			if (!ConVar.Server.stability)
			{
				return false;
			}
			if (!entity.IsValid())
			{
				return false;
			}
			if (!entity.isServer)
			{
				return false;
			}
			return true;
		}
	}

	public class UpdateSurroundingsQueue : ObjectWorkQueue<Bounds>
	{
		protected override void RunJob(Bounds bounds)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			NotifyNeighbours(bounds);
		}

		public static void NotifyNeighbours(Bounds bounds)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (!ConVar.Server.stability)
			{
				return;
			}
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vector3 center = ((Bounds)(ref bounds)).center;
			Vector3 extents = ((Bounds)(ref bounds)).extents;
			Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, -2010478334, (QueryTriggerInteraction)2);
			foreach (BaseEntity item in list)
			{
				if (!item.IsDestroyed && !item.isClient)
				{
					if (item is StabilityEntity stabilityEntity)
					{
						stabilityEntity.OnPhysicsNeighbourChanged();
					}
					else
					{
						((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
					}
				}
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
		}
	}

	public class Support
	{
		public StabilityEntity parent;

		public EntityLink link;

		public float factor = 1f;

		public Support(StabilityEntity parent, EntityLink link, float factor)
		{
			this.parent = parent;
			this.link = link;
			this.factor = factor;
		}

		public StabilityEntity SupportEntity(StabilityEntity ignoreEntity = null)
		{
			StabilityEntity stabilityEntity = null;
			for (int i = 0; i < link.connections.Count; i++)
			{
				StabilityEntity stabilityEntity2 = link.connections[i].owner as StabilityEntity;
				Socket_Base socket = link.connections[i].socket;
				if ((Object)(object)stabilityEntity2 == (Object)null || (Object)(object)stabilityEntity2 == (Object)(object)parent || (Object)(object)stabilityEntity2 == (Object)(object)ignoreEntity || stabilityEntity2.isClient || stabilityEntity2.IsDestroyed || socket is ConstructionSocket { femaleNoStability: not false })
				{
					continue;
				}
				if ((Object)(object)stabilityEntity == (Object)null)
				{
					stabilityEntity = stabilityEntity2;
				}
				else if (Stability.support_highest_stability)
				{
					if (stabilityEntity2.cachedStability > stabilityEntity.cachedStability)
					{
						stabilityEntity = stabilityEntity2;
					}
				}
				else if (stabilityEntity2.cachedDistanceFromGround < stabilityEntity.cachedDistanceFromGround)
				{
					stabilityEntity = stabilityEntity2;
				}
			}
			return stabilityEntity;
		}
	}

	public bool grounded;

	[NonSerialized]
	public float cachedStability;

	[NonSerialized]
	public int cachedDistanceFromGround = int.MaxValue;

	private int stabilityUpdateDepth;

	private List<Support> supports;

	private int stabilityStrikes;

	private bool dirty;

	public static StabilityCheckWorkQueue stabilityCheckQueue = new StabilityCheckWorkQueue();

	public static UpdateSurroundingsQueue updateSurroundingsQueue = new UpdateSurroundingsQueue();

	public override void ResetState()
	{
		base.ResetState();
		cachedStability = 0f;
		cachedDistanceFromGround = int.MaxValue;
		if (base.isServer)
		{
			supports = null;
			stabilityStrikes = 0;
			dirty = false;
		}
	}

	public void InitializeSupports()
	{
		supports = new List<Support>();
		if (grounded || (HasParent() && !GetParentEntity().AllowInitChildSupports()))
		{
			return;
		}
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			if (entityLink.IsMale())
			{
				if (entityLink.socket is StabilitySocket)
				{
					supports.Add(new Support(this, entityLink, (entityLink.socket as StabilitySocket).support));
				}
				if (entityLink.socket is ConstructionSocket)
				{
					supports.Add(new Support(this, entityLink, (entityLink.socket as ConstructionSocket).support));
				}
			}
		}
	}

	public int DistanceFromGround(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1;
		}
		if (supports == null)
		{
			return 1;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		int num = int.MaxValue;
		for (int i = 0; i < supports.Count; i++)
		{
			StabilityEntity stabilityEntity = supports[i].SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				int num2 = stabilityEntity.CachedDistanceFromGround(ignoreEntity);
				if (num2 != int.MaxValue)
				{
					num = Mathf.Min(num, num2 + 1);
				}
			}
		}
		return num;
	}

	public float SupportValue(out StabilityEntity supportEntity, StabilityEntity ignoreEntity = null)
	{
		supportEntity = null;
		if (grounded || HasParent())
		{
			return 1f;
		}
		if (supports == null)
		{
			return 1f;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		float num = 0f;
		for (int i = 0; i < supports.Count; i++)
		{
			Support support = supports[i];
			supportEntity = support.SupportEntity(ignoreEntity);
			if (!((Object)(object)supportEntity == (Object)null))
			{
				float num2 = supportEntity.CachedSupportValue(ignoreEntity);
				if (num2 != 0f)
				{
					num += num2 * support.factor;
				}
			}
		}
		return Mathf.Clamp01(num);
	}

	public int CachedDistanceFromGround(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1;
		}
		if (supports == null)
		{
			return 1;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		int num = int.MaxValue;
		for (int i = 0; i < supports.Count; i++)
		{
			StabilityEntity stabilityEntity = supports[i].SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				int num2 = stabilityEntity.cachedDistanceFromGround;
				if (num2 != int.MaxValue)
				{
					num = Mathf.Min(num, num2 + 1);
				}
			}
		}
		return num;
	}

	public float CachedSupportValue(StabilityEntity ignoreEntity = null)
	{
		if (grounded || HasParent())
		{
			return 1f;
		}
		if (supports == null)
		{
			return 1f;
		}
		if ((Object)(object)ignoreEntity == (Object)null)
		{
			ignoreEntity = this;
		}
		float num = 0f;
		for (int i = 0; i < supports.Count; i++)
		{
			Support support = supports[i];
			StabilityEntity stabilityEntity = support.SupportEntity(ignoreEntity);
			if (!((Object)(object)stabilityEntity == (Object)null))
			{
				float num2 = stabilityEntity.cachedStability;
				if (num2 != 0f)
				{
					num += num2 * support.factor;
				}
			}
		}
		return Mathf.Clamp01(num);
	}

	public void LogStabilityUpdate(string reason)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		DebugEx.Log((object)$"[Stability] [Depth:{stabilityUpdateDepth}] Updating {this} at position {((Component)this).transform.position} with distance {cachedDistanceFromGround} and building ID {buildingID} due to ({reason})", (StackTraceLogType)0);
	}

	public virtual void StabilityCheck()
	{
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", (object)this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			float num2 = cachedDistanceFromGround;
			cachedDistanceFromGround = num;
			if (!Stability.support_highest_stability)
			{
				if (Stability.log_stability_updates)
				{
					LogStabilityUpdate($"old distance : {num2} != new distance {num}");
				}
				flag = true;
			}
		}
		StabilityEntity supportEntity;
		float num3 = SupportValue(out supportEntity);
		if (Mathf.Abs(cachedStability - num3) > Stability.accuracy)
		{
			if (Stability.log_stability_updates)
			{
				LogStabilityUpdate(string.Format("old stability: {0} new stability: {1} support entity: {2}", cachedStability, num3, ((Object)(object)supportEntity == (Object)null) ? "null" : ((object)supportEntity).ToString()));
			}
			cachedStability = num3;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability(stabilityUpdateDepth + 1);
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num3 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				if (Stability.log_stability_updates)
				{
					LogStabilityUpdate($"stability strikes {stabilityStrikes} / {Stability.strikes}");
				}
				UpdateStability(stabilityUpdateDepth + 1);
				stabilityStrikes++;
				return;
			}
			if (Stability.log_stability_death)
			{
				Debug.Log((object)$"Killing '{((object)this).ToString()}' at position {((Component)this).transform.position} due to low stability: {Math.Round(num3 * 100f, 2)} < {Math.Round(Stability.collapse * 100f, 1)}%");
			}
			Kill(DestroyMode.Gib);
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

	public void UpdateStability(int depth = 0)
	{
		stabilityUpdateDepth = depth;
		((ObjectWorkQueue<StabilityEntity>)stabilityCheckQueue).Add(this);
	}

	public void UpdateSurroundingEntities()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		UpdateSurroundingsQueue obj = updateSurroundingsQueue;
		OBB val = WorldSpaceBounds();
		((ObjectWorkQueue<Bounds>)obj).Add(((OBB)(ref val)).ToBounds());
	}

	public void UpdateConnectedEntities()
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			if (!entityLink.IsFemale())
			{
				continue;
			}
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				StabilityEntity stabilityEntity = entityLink.connections[j].owner as StabilityEntity;
				if (!((Object)(object)stabilityEntity == (Object)null) && !stabilityEntity.isClient && !stabilityEntity.IsDestroyed)
				{
					stabilityEntity.UpdateStability(stabilityUpdateDepth + 1);
				}
			}
		}
	}

	protected void OnPhysicsNeighbourChanged()
	{
		if (!base.IsDestroyed)
		{
			StabilityCheck();
		}
	}

	protected void DebugNudge()
	{
		StabilityCheck();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			UpdateStability();
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		UpdateSurroundingEntities();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.stabilityEntity = Pool.Get<StabilityEntity>();
		info.msg.stabilityEntity.stability = cachedStability;
		info.msg.stabilityEntity.distanceFromGround = cachedDistanceFromGround;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.stabilityEntity != null)
		{
			cachedStability = info.msg.stabilityEntity.stability;
			cachedDistanceFromGround = info.msg.stabilityEntity.distanceFromGround;
			if (cachedStability <= 0f)
			{
				cachedStability = 0f;
			}
			if (cachedDistanceFromGround <= 0)
			{
				cachedDistanceFromGround = int.MaxValue;
			}
		}
	}
}


using ConVar;

public class StabilityCheckWorkQueue : ObjectWorkQueue<StabilityEntity>
{
	protected override void RunJob(StabilityEntity entity)
	{
		if (((ObjectWorkQueue<StabilityEntity>)this).ShouldAdd(entity))
		{
			entity.StabilityCheck();
		}
	}

	protected override bool ShouldAdd(StabilityEntity entity)
	{
		if (!Server.stability)
		{
			return false;
		}
		if (!entity.IsValid())
		{
			return false;
		}
		if (!entity.isServer)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class UpdateSurroundingsQueue : ObjectWorkQueue<Bounds>
{
	protected override void RunJob(Bounds bounds)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		NotifyNeighbours(bounds);
	}

	public static void NotifyNeighbours(Bounds bounds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.stability)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 center = ((Bounds)(ref bounds)).center;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vis.Entities(center, ((Vector3)(ref extents)).magnitude + 1f, list, -2010478334, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.IsDestroyed && !item.isClient)
			{
				if (item is StabilityEntity stabilityEntity)
				{
					stabilityEntity.OnPhysicsNeighbourChanged();
				}
				else
				{
					((Component)item).BroadcastMessage("OnPhysicsNeighbourChanged", (SendMessageOptions)1);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}
}


using ConVar;
using UnityEngine;

public class Support
{
	public StabilityEntity parent;

	public EntityLink link;

	public float factor = 1f;

	public Support(StabilityEntity parent, EntityLink link, float factor)
	{
		this.parent = parent;
		this.link = link;
		this.factor = factor;
	}

	public StabilityEntity SupportEntity(StabilityEntity ignoreEntity = null)
	{
		StabilityEntity stabilityEntity = null;
		for (int i = 0; i < link.connections.Count; i++)
		{
			StabilityEntity stabilityEntity2 = link.connections[i].owner as StabilityEntity;
			Socket_Base socket = link.connections[i].socket;
			if ((Object)(object)stabilityEntity2 == (Object)null || (Object)(object)stabilityEntity2 == (Object)(object)parent || (Object)(object)stabilityEntity2 == (Object)(object)ignoreEntity || stabilityEntity2.isClient || stabilityEntity2.IsDestroyed || socket is ConstructionSocket { femaleNoStability: not false })
			{
				continue;
			}
			if ((Object)(object)stabilityEntity == (Object)null)
			{
				stabilityEntity = stabilityEntity2;
			}
			else if (Stability.support_highest_stability)
			{
				if (stabilityEntity2.cachedStability > stabilityEntity.cachedStability)
				{
					stabilityEntity = stabilityEntity2;
				}
			}
			else if (stabilityEntity2.cachedDistanceFromGround < stabilityEntity.cachedDistanceFromGround)
			{
				stabilityEntity = stabilityEntity2;
			}
		}
		return stabilityEntity;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

public class TimedExplosive : BaseEntity, ServerProjectile.IProjectileImpact
{
	public enum ExplosionEffectOffsetMode
	{
		Local,
		World
	}

	[Header("General")]
	public float timerAmountMin = 10f;

	public float timerAmountMax = 20f;

	public float minExplosionRadius;

	public float explosionRadius = 10f;

	public bool explodeOnContact;

	public bool canStick;

	public bool onlyDamageParent;

	[Header("AI")]
	public bool IgnoreAI;

	public bool BlindAI;

	public float aiBlindDuration = 2.5f;

	public float aiBlindRange = 4f;

	[Header("Offsets")]
	public ExplosionEffectOffsetMode explosionOffsetMode;

	public Vector3 explosionEffectOffset = Vector3.zero;

	[Header("Normals")]
	public bool explosionMatchesNormal;

	public bool explosionUsesForward;

	public bool explosionMatchesOrientation;

	public bool explosionMatchesVelocity;

	public bool explosionMatchesInverseVelocity;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	[Tooltip("Optional: Will fall back to watersurfaceExplosionEffect or explosionEffect if not assigned.")]
	public GameObjectRef underwaterExplosionEffect;

	public GameObjectRef stickEffect;

	public GameObjectRef bounceEffect;

	public GameObjectRef watersurfaceExplosionEffect;

	[Min(0f)]
	[Header("Water")]
	public float underwaterExplosionDepth = 1f;

	[Tooltip("Optional: Will fall back to underwaterExplosionEffect or explosionEffect if not assigned.")]
	[MinMax(0f, 100f)]
	public MinMax watersurfaceExplosionDepth = new MinMax(0.5f, 10f);

	public bool waterCausesExplosion;

	[Header("Other")]
	public int vibrationLevel = 3;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public List<DamageTypeEntry> playerDamage = new List<DamageTypeEntry>();

	public bool splashWallpaperThroughWalls;

	[NonSerialized]
	private float lastBounceTime;

	private bool hadRB;

	private float rbMass;

	private float rbDrag;

	private float rbAngularDrag;

	private Vector3 rbVelocityBeforeCollision;

	private CollisionDetectionMode rbCollisionMode;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	protected BasePlayer creatorPlayer;

	private const int parentOnlySplashDamage = 166144;

	private const int fullSplashDamage = 1210222849;

	protected Vector3? hitNormal;

	private static BaseEntity[] queryResults = new BaseEntity[64];

	private Vector3 lastPosition = Vector3.zero;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	protected virtual bool AlwaysRunWaterCheck => false;

	public List<DamageTypeEntry> GetDamageList(BaseEntity entity)
	{
		if (ConVar.Server.explosive_testing_mode)
		{
			return new List<DamageTypeEntry>
			{
				new DamageTypeEntry
				{
					amount = 1f,
					type = DamageType.Explosion
				}
			};
		}
		if (entity is BasePlayer && playerDamage != null && playerDamage.Count > 0)
		{
			return playerDamage;
		}
		return damageTypes;
	}

	public void SetDamageScale(float scale)
	{
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			damageType.amount *= scale;
		}
	}

	public void SetCreator(BasePlayer ply)
	{
		creatorPlayer = ply;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		lastBounceTime = Time.time;
		base.ServerInit();
		SetFuse(GetRandomTimerTime());
		if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
		{
			ReceiveCollisionMessages(b: true);
		}
		if (waterCausesExplosion || AlwaysRunWaterCheck)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)WaterCheck, 0f, 0.5f);
		}
	}

	public virtual void WaterCheck()
	{
		if (waterCausesExplosion && WaterFactor() >= 0.5f)
		{
			Explode();
			Debug.Log((object)"water explode");
		}
	}

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", (object)this, (object)fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			((FacepunchBehaviour)this).Invoke((Action)Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	public virtual float GetRandomTimerTime()
	{
		return Random.Range(timerAmountMin, timerAmountMax);
	}

	public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		Explode();
	}

	public void ForceExplode()
	{
		if (this is DudTimedExplosive dudTimedExplosive)
		{
			dudTimedExplosive.dudChance = 0f;
		}
		if (this is RFTimedExplosive rFTimedExplosive)
		{
			rFTimedExplosive.DisarmRF();
		}
		Explode();
	}

	public virtual void Explode()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Explode(PivotPoint());
	}

	private Vector3 GetExplosionNormal()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result;
		if (explosionUsesForward)
		{
			result = ((Component)this).transform.forward;
		}
		else if (!explosionMatchesOrientation)
		{
			result = (explosionMatchesVelocity ? ((Vector3)(ref rbVelocityBeforeCollision)).normalized : ((!explosionMatchesInverseVelocity) ? Vector3.up : (-((Vector3)(ref rbVelocityBeforeCollision)).normalized)));
		}
		else
		{
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 forward = Vector3.forward;
			result = rotation * forward;
		}
		if (explosionMatchesNormal && hitNormal.HasValue)
		{
			result = hitNormal.Value;
		}
		return result;
	}

	public virtual void Explode(Vector3 explosionFxPos)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_041f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0434: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnExplosion(this);
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Vector3 val = explosionFxPos;
			if (explosionOffsetMode == ExplosionEffectOffsetMode.Local)
			{
				Vector3 val2 = ((Component)this).transform.TransformPoint(explosionEffectOffset) - ((Component)this).transform.position;
				val += val2;
			}
			if (explosionOffsetMode == ExplosionEffectOffsetMode.World)
			{
				val += explosionEffectOffset;
			}
			Effect.server.Run(explosionEffect.resourcePath, val, GetExplosionNormal(), null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, Vector3Ex.WithY(explosionFxPos, waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);
		}
		if (GetDamageList(null).Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", (object)this, (object)explosionFxPos) != null)
			{
				return;
			}
			Vector3 val3 = ExplosionCenter();
			if (onlyDamageParent)
			{
				int num = 166144;
				if (!ConVar.AntiHack.explosive_vehicle_parent_damage_deployables && parentEntity.Get(serverside: true) is BaseVehicle)
				{
					num &= -257;
				}
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, GetDamageList(null), num, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage, removeWallpaper: false, includeBoatBuildingPieces: false);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while ((Object)(object)baseCombatEntity == (Object)null && (Object)(object)baseEntity != (Object)null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if ((Object)(object)baseEntity == (Object)null || !((Component)baseEntity).gameObject.IsOnLayer((Layer)21))
				{
					List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, explosionRadius, list, 2097152, (QueryTriggerInteraction)1);
					BuildingBlock buildingBlock = null;
					float num2 = float.PositiveInfinity;
					foreach (BuildingBlock item in list)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num3 = Vector3.Distance(item.ClosestPoint(val3), val3);
							if (num3 < num2 && item.IsVisible(val3, explosionRadius))
							{
								buildingBlock = item;
								num2 = num3;
							}
						}
					}
					if (Object.op_Implicit((Object)(object)buildingBlock))
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(GetDamageList(buildingBlock));
						hitInfo.PointStart = val3;
						hitInfo.PointEnd = ((Component)buildingBlock).transform.position;
						float amount = 1f - Mathf.Clamp01((num2 - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
				}
				if (Object.op_Implicit((Object)(object)baseCombatEntity))
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(GetDamageList(baseEntity));
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if ((Object)(object)baseEntity != (Object)null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(GetDamageList(baseEntity));
					hitInfo3.PointStart = val3;
					hitInfo3.PointEnd = ((Component)baseEntity).transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
				if (splashWallpaperThroughWalls)
				{
					List<BuildingBlock> list2 = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, 3.4f, list2, 2097152, (QueryTriggerInteraction)1);
					foreach (BuildingBlock item2 in list2)
					{
						item2.RemoveWallpaper(0);
						item2.RemoveWallpaper(1);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list2);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, GetDamageList(null), 1210222849, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage, splashWallpaperThroughWalls);
			}
			SeismicSensor.Notify(val3, vibrationLevel);
			BlindAnyAI();
			SingletonComponent<NpcNoiseManager>.Instance.OnExplosion(creatorEntity, this);
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken) && !ConVar.Server.explosive_testing_mode)
		{
			Kill(DestroyMode.Gib);
		}
	}

	private Vector3 ExplosionCenter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStuck() && parentEntity.Get(base.isServer) is BaseVehicle)
		{
			OBB val = WorldSpaceBounds();
			return CenterPoint() - val.forward * (val.extents.z + 0.1f);
		}
		return CenterPoint();
	}

	private void BlindAnyAI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!BlindAI)
		{
			return;
		}
		int brainsInSphereFast = Query.Server.GetBrainsInSphereFast(((Component)this).transform.position, 10f, queryResults);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity baseEntity = queryResults[i];
			if (Vector3.Distance(((Component)this).transform.position, ((Component)baseEntity).transform.position) > aiBlindRange)
			{
				continue;
			}
			BaseAIBrain component = ((Component)baseEntity).GetComponent<BaseAIBrain>();
			if (!((Object)(object)component == (Object)null))
			{
				BaseEntity brainBaseEntity = component.GetBrainBaseEntity();
				if (!((Object)(object)brainBaseEntity == (Object)null) && brainBaseEntity.IsVisible(CenterPoint()))
				{
					float blinded = aiBlindDuration * component.BlindDurationMultiplier * Random.Range(0.6f, 1.4f);
					component.SetBlinded(blinded);
					queryResults[i] = null;
				}
			}
		}
	}

	public void FixedUpdate()
	{
		CheckClippingThroughWalls();
	}

	protected virtual bool ShouldBypassClippingWallCheck()
	{
		return false;
	}

	private void CheckClippingThroughWalls()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (!canStick)
		{
			return;
		}
		if (lastPosition == default(Vector3) || !parentEntity.IsValid(serverside: true))
		{
			lastPosition = CenterPoint();
			return;
		}
		Vector3 val = lastPosition;
		Vector3 val2 = CenterPoint();
		Vector3 val3 = val2 - val;
		lastPosition = val2;
		if (val == val2 || !IsStuck(bypassColliderCheck: true) || ShouldBypassClippingWallCheck())
		{
			return;
		}
		Ray ray = default(Ray);
		((Ray)(ref ray))..ctor(val, val2 - val);
		PooledList<RaycastHit> val4 = Pool.Get<PooledList<RaycastHit>>();
		try
		{
			GamePhysics.TraceAll(ray, 0f, (List<RaycastHit>)(object)val4, Vector3.Distance(val2, val), 2097152, (QueryTriggerInteraction)0);
			foreach (RaycastHit item in (List<RaycastHit>)(object)val4)
			{
				if ((Object)(object)(item.GetEntity() as BuildingBlock) != (Object)null)
				{
					Transform transform = ((Component)this).transform;
					transform.position -= val3;
					ForceExplode();
					break;
				}
			}
		}
		finally
		{
			((IDisposable)val4)?.Dispose();
		}
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (canStick && !IsStuck())
		{
			bool flag = true;
			if (Object.op_Implicit((Object)(object)hitEntity))
			{
				flag = CanStickTo(hitEntity);
				if (!flag)
				{
					Collider component = ((Component)this).GetComponent<Collider>();
					if ((Object)(object)collision.collider != (Object)null && (Object)(object)component != (Object)null)
					{
						Physics.IgnoreCollision(collision.collider, component);
					}
				}
			}
			if (flag)
			{
				DoCollisionStick(collision, hitEntity);
			}
		}
		if (explodeOnContact && !IsBusy())
		{
			hitNormal = ((ContactPoint)(ref collision.contacts[0])).normal;
			SetMotionEnabled(wantsMotion: false);
			SetFlag(Flags.Busy, b: true, recursive: false, networkupdate: false);
			((FacepunchBehaviour)this).Invoke((Action)Explode, 0.015f);
		}
		else
		{
			DoBounceEffect();
		}
	}

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		DecorDeployable decorDeployable = default(DecorDeployable);
		if (((Component)entity).TryGetComponent<DecorDeployable>(ref decorDeployable))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

	private void DoBounceEffect()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!bounceEffect.isValid || Time.time - lastBounceTime < 0.2f)
		{
			return;
		}
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			Vector3 velocity = component.velocity;
			if (((Vector3)(ref velocity)).magnitude < 1f)
			{
				return;
			}
		}
		if (bounceEffect.isValid)
		{
			Effect.server.Run(bounceEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		lastBounceTime = Time.time;
	}

	private void DoCollisionStick(Collision collision, BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		ContactPoint contact = collision.GetContact(0);
		DoStick(((ContactPoint)(ref contact)).point, ((ContactPoint)(ref contact)).normal, ent, collision.collider);
	}

	public virtual void SetMotionEnabled(bool wantsMotion)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (wantsMotion)
		{
			if ((Object)(object)component == (Object)null && hadRB)
			{
				component = ((Component)this).gameObject.AddComponent<Rigidbody>();
				component.mass = rbMass;
				component.drag = rbDrag;
				component.angularDrag = rbAngularDrag;
				component.collisionDetectionMode = rbCollisionMode;
				component.useGravity = true;
				component.isKinematic = false;
			}
		}
		else if ((Object)(object)component != (Object)null)
		{
			hadRB = true;
			rbMass = component.mass;
			rbDrag = component.drag;
			rbAngularDrag = component.angularDrag;
			rbCollisionMode = component.collisionDetectionMode;
			rbVelocityBeforeCollision = component.velocity;
			Object.Destroy((Object)(object)component);
		}
	}

	public bool IsStuck(bool bypassColliderCheck = false)
	{
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component) && !component.isKinematic)
		{
			return false;
		}
		if (!bypassColliderCheck)
		{
			Collider component2 = ((Component)this).GetComponent<Collider>();
			if (Object.op_Implicit((Object)(object)component2) && component2.enabled)
			{
				return false;
			}
		}
		return parentEntity.IsValid(serverside: true);
	}

	public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider collider)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		if (ent is TimedExplosive)
		{
			if (!ent.HasParent())
			{
				return;
			}
			position = ((Component)ent).transform.position;
			ent = ent.parentEntity.Get(serverside: true);
		}
		SetMotionEnabled(wantsMotion: false);
		if (!HasChild(ent))
		{
			((Component)this).transform.position = position;
			((Component)this).transform.rotation = Quaternion.LookRotation(normal, ((Component)this).transform.up);
			if ((Object)(object)collider != (Object)null)
			{
				SetParent(ent, ent.FindBoneID(((Component)collider).transform), worldPositionStays: true);
			}
			else
			{
				SetParent(ent, StringPool.closest, worldPositionStays: true);
			}
			if (ent is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.SetJustAttacked();
			}
			if (stickEffect.isValid)
			{
				Effect.server.Run(stickEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
			}
			ReceiveCollisionMessages(b: false);
		}
	}

	public void UnStick()
	{
		if (Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetMotionEnabled(wantsMotion: true);
			if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
			{
				ReceiveCollisionMessages(b: true);
			}
		}
	}

	internal override void OnParentRemoved()
	{
		UnStick();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void PostServerLoad()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (parentEntity.IsValid(serverside: true))
		{
			DoStick(((Component)this).transform.position, ((Component)this).transform.forward, parentEntity.Get(serverside: true), null);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.explosive != null)
		{
			parentEntity.uid = info.msg.explosive.parentid;
		}
	}

	public virtual void SetCollisionEnabled(bool wantsCollision)
	{
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component) && component.enabled != wantsCollision)
		{
			component.enabled = wantsCollision;
		}
	}
}


public enum ExplosionEffectOffsetMode
{
	Local,
	World
}


using UnityEngine;

public class BaseTrap : DecayEntity
{
	public virtual void ObjectEntered(GameObject obj)
	{
	}

	public virtual void Arm()
	{
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
	}

	public virtual void OnEmpty()
	{
	}
}


using Oxide.Core;
using UnityEngine;

public class BaseTrapTrigger : TriggerBase
{
	public BaseTrap _trap;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", (object)this, (object)obj, (object)col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		_trap.OnEmpty();
	}
}


public class BearTrapTrigger : BaseTrapTrigger
{
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class SurvivalFishTrap : WildlifeTrap
{
	private WaterBody cachedWaterBody;

	private bool bypassItemFilter;

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position + Vector3.up, Vector3.down), 0f, out var hitInfo, 1.5f, 16, (QueryTriggerInteraction)0))
		{
			cachedWaterBody = hitInfo.GetWaterBody();
		}
	}

	public override bool HasBait()
	{
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		foreach (Item item in base.inventory.itemList)
		{
			if (item != null && ((Component)item.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) && itemModCompostable.BaitValue > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public override void TrapThink()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				ItemModCompostable itemModCompostable = default(ItemModCompostable);
				if ((((Component)current.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(((Component)this).transform.position, cachedWaterBody, current, out var _, ((Component)current.info).GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (Random.Range(0f, 1f) <= trapSuccessRate || !((Object)(object)itemDefinition != (Object)null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if ((Object)(object)base.LastLootedByPlayer != (Object)null)
				{
					item2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
				}
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(((Component)this).transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool flag = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				flag = true;
				break;
			}
		}
		return base.ItemFilter(item, targetSlot) && flag;
	}

	protected override bool CanAcceptItem(Item item, int slot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool result = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				result = true;
				break;
			}
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
[CreateAssetMenu(menuName = "Rust/TrappableWildlife")]
public class TrappableWildlife : ScriptableObject
{
	[Serializable]
	public class BaitType
	{
		public float successRate = 1f;

		public ItemDefinition bait;

		public int minForInterest = 1;

		public int maxToConsume = 1;
	}

	public GameObjectRef worldObject;

	public ItemDefinition inventoryObject;

	public int minToCatch;

	public int maxToCatch;

	public List<BaitType> baitTypes;

	public int caloriesForInterest = 20;

	public float successRate = 1f;

	public float xpScale = 1f;
}


using System;

[Serializable]
public class BaitType
{
	public float successRate = 1f;

	public ItemDefinition bait;

	public int minForInterest = 1;

	public int maxToConsume = 1;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WildlifeTrap : StorageContainer
{
	[Serializable]
	public class WildlifeWeight
	{
		public TrappableWildlife wildlife;

		public int weight;
	}

	public static class WildlifeTrapFlags
	{
		public const Flags Occupied = Flags.Reserved1;
	}

	public float tickRate = 60f;

	public GameObjectRef trappedEffect;

	public float trappedEffectRepeatRate = 30f;

	public float trapSuccessRate = 0.5f;

	public List<ItemDefinition> ignoreBait;

	public List<WildlifeWeight> targetWildlife;

	public override void ResetState()
	{
		base.ResetState();
	}

	public void SetTrapActive(bool trapOn)
	{
		if (trapOn != IsTrapActive())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TrapThink);
			SetFlag(Flags.On, trapOn);
			if (trapOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
		}
	}

	[ContextMenu("DebugPrintout")]
	public void DebugPrintout()
	{
		bool flag = ((FacepunchBehaviour)this).IsInvoking((Action)TrapThink);
		Debug.Log((object)$"is invoking: {flag}");
	}

	private int CalculateBaitCalories(Item bait)
	{
		ItemModConsumable component = ((Component)bait.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		if (ignoreBait.Contains(bait.info))
		{
			return 0;
		}
		int num = 0;
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				num += Mathf.CeilToInt(effect.amount * (float)bait.amount);
			}
		}
		return num;
	}

	public int GetBaitCalories()
	{
		int num = 0;
		foreach (Item item in base.inventory.itemList)
		{
			num += CalculateBaitCalories(item);
		}
		return num;
	}

	public void DestroyRandomFoodItem()
	{
		int count = base.inventory.itemList.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = num + i;
			if (num2 >= count)
			{
				num2 -= count;
			}
			Item item = base.inventory.itemList[num2];
			if (item != null && !((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>() == (Object)null))
			{
				item.UseItem();
				break;
			}
		}
	}

	public void UseBaitCalories(int numToUse)
	{
		foreach (Item item in base.inventory.itemList)
		{
			int itemCalories = GetItemCalories(item);
			if (itemCalories > 0)
			{
				numToUse -= itemCalories;
				item.UseItem();
				if (numToUse <= 0)
				{
					break;
				}
			}
		}
	}

	public int GetItemCalories(Item item)
	{
		ItemModConsumable component = ((Component)item.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				return Mathf.CeilToInt(effect.amount);
			}
		}
		return 0;
	}

	public virtual void TrapThink()
	{
		int baitCalories = GetBaitCalories();
		if (baitCalories <= 0)
		{
			return;
		}
		TrappableWildlife randomWildlife = GetRandomWildlife();
		if (baitCalories >= randomWildlife.caloriesForInterest && Random.Range(0f, 1f) <= randomWildlife.successRate)
		{
			UseBaitCalories(randomWildlife.caloriesForInterest);
			if (Random.Range(0f, 1f) <= trapSuccessRate)
			{
				TrapWildlife(randomWildlife);
			}
		}
	}

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if ((Object)(object)base.LastLootedByPlayer != (Object)null)
			{
				item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
			}
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

	protected void OnTrappedWildlife(bool setFlag)
	{
		if (setFlag)
		{
			SetFlag(Flags.Reserved1, b: true);
		}
		SetTrapActive(trapOn: false);
		Hurt(StartMaxHealth() * 0.1f, DamageType.Decay, null, useProtection: false);
	}

	public void ClearTrap()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public virtual bool HasBait()
	{
		return GetBaitCalories() > 0;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		SetTrapActive(HasBait());
		ClearTrap();
		base.PlayerStoppedLooting(player);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		ClearTrap();
		return base.OnStartBeingLooted(baseEntity);
	}

	public TrappableWildlife GetRandomWildlife()
	{
		int num = targetWildlife.Sum((WildlifeWeight x) => x.weight);
		int num2 = Random.Range(0, num);
		for (int i = 0; i < targetWildlife.Count; i++)
		{
			num -= targetWildlife[i].weight;
			if (num2 >= num)
			{
				return targetWildlife[i].wildlife;
			}
		}
		return null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	protected virtual bool CanAcceptItem(Item item, int slot)
	{
		if (CalculateBaitCalories(item) > 0)
		{
			return true;
		}
		foreach (WildlifeWeight item2 in targetWildlife)
		{
			if ((Object)(object)item2.wildlife?.inventoryObject == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasCatch()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsTrapActive()
	{
		return HasFlag(Flags.On);
	}
}


using System;

[Serializable]
public class WildlifeWeight
{
	public TrappableWildlife wildlife;

	public int weight;
}


public static class WildlifeTrapFlags
{
	public const Flags Occupied = Flags.Reserved1;
}


using UnityEngine;

public class BaseAimable : BaseVehicleMountPoint
{
	public Transform aimBase;
}


public class BaseChair : BaseMountable
{
	public override float GetComfort()
	{
		return 1f;
	}

	public override float AntiHackPadding()
	{
		return 1f;
	}
}


using UnityEngine;

public class BaseVehicleMountPoint : BaseMountable
{
	[Header("BaseVehicleMountPoint")]
	[Tooltip("Only Set this if you definitely need a VehicleFixedUpdate tick on the seat for some reason")]
	public bool RequiresVehicleFixedUpdateOnSeat;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override BaseVehicle VehicleParent()
	{
		if (ignoreVehicleParent)
		{
			return null;
		}
		BaseVehicle baseVehicle = GetParentEntity() as BaseVehicle;
		while ((Object)(object)baseVehicle != (Object)null && !baseVehicle.IsVehicleRoot())
		{
			BaseVehicle baseVehicle2 = baseVehicle.GetParentEntity() as BaseVehicle;
			if ((Object)(object)baseVehicle2 == (Object)null)
			{
				return baseVehicle;
			}
			baseVehicle = baseVehicle2;
		}
		return baseVehicle;
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			info = default(WaterLevel.WaterInfo);
			return 0f;
		}
		return baseVehicle.WaterFactorForPlayer(player, out info);
	}

	public override float AirFactor()
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return 0f;
		}
		return baseVehicle.AirFactor();
	}
}


using UnityEngine;

public class BaseVehicleSeat : BaseVehicleMountPoint
{
	[Header("Vehicle Seat")]
	public bool sendClientInputToVehicleParent;

	public bool forcePlayerModelUpdate;

	public bool giveCrosshair;

	public bool canTeamInteract = true;

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.ScaleDamageForPlayer(player, info);
		}
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.MounteeTookDamage(mountee, info);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.PlayerServerInput(inputState, player);
		}
		base.PlayerServerInput(inputState, player);
	}

	public override void LightToggle(BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.LightToggle(player);
		}
	}

	public override void SwitchParent(BaseEntity ent)
	{
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.GetMountRagdollVelocity(player);
		}
		return base.GetMountRagdollVelocity(player);
	}
}


using System;
using UnityEngine;

public class BasicCar : BaseVehicle
{
	[Serializable]
	public class VehicleWheel
	{
		public Transform shock;

		public WheelCollider wheelCollider;

		public Transform wheel;

		public Transform axle;

		public bool steerWheel;

		public bool brakeWheel = true;

		public bool powerWheel = true;
	}

	public VehicleWheel[] wheels;

	public float brakePedal;

	public float gasPedal;

	public float steering;

	public Transform centerOfMass;

	public Transform steeringWheel;

	public float motorForceConstant = 150f;

	public float brakeForceConstant = 500f;

	public float GasLerpTime = 20f;

	public float SteeringLerpTime = 20f;

	public Transform driverEye;

	public GameObjectRef chairRef;

	public Transform chairAnchorTest;

	public SoundPlayer idleLoopPlayer;

	public Transform engineOffset;

	public SoundDefinition engineSoundDef;

	private static bool chairtest;

	public float throttle;

	public float brake;

	public bool lightsOn = true;

	public override float AntiHackVelocity()
	{
		return 50f;
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (PlayerIsMounted(player))
		{
			return ((Component)driverEye).transform.position;
		}
		return Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			base.ServerInit();
			rigidBody = ((Component)this).GetComponent<Rigidbody>();
			rigidBody.centerOfMass = centerOfMass.localPosition;
			rigidBody.isKinematic = false;
			if (chairtest)
			{
				SpawnChairTest();
			}
		}
	}

	public void SpawnChairTest()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(chairRef.resourcePath, ((Component)chairAnchorTest).transform.localPosition);
		baseEntity.Spawn();
		DestroyOnGroundMissing component = ((Component)baseEntity).GetComponent<DestroyOnGroundMissing>();
		if ((Object)(object)component != (Object)null)
		{
			((Behaviour)component).enabled = false;
		}
		MeshCollider component2 = ((Component)baseEntity).GetComponent<MeshCollider>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.convex = true;
		}
		baseEntity.SetParent(this);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BasicCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!HasDriver())
			{
				NoDriverInput();
			}
			ConvertInputToThrottle();
			DoSteering();
			ApplyForceAtWheels();
			SetFlag(Flags.Reserved1, HasDriver());
			SetFlag(Flags.Reserved2, HasDriver() && lightsOn);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void DoSteering()
	{
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.steerWheel)
			{
				vehicleWheel.wheelCollider.steerAngle = steering;
			}
		}
		SetFlag(Flags.Reserved4, steering < -2f);
		SetFlag(Flags.Reserved5, steering > 2f);
	}

	public void ConvertInputToThrottle()
	{
	}

	public void ApplyForceAtWheels()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		Vector3 velocity = rigidBody.velocity;
		float num = ((Vector3)(ref velocity)).magnitude * Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward);
		float num2 = brakePedal;
		float num3 = gasPedal;
		if (num > 0f && num3 < 0f)
		{
			num2 = 100f;
		}
		else if (num < 0f && num3 > 0f)
		{
			num2 = 100f;
		}
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.wheelCollider.isGrounded)
			{
				if (vehicleWheel.powerWheel)
				{
					vehicleWheel.wheelCollider.motorTorque = num3 * motorForceConstant;
				}
				if (vehicleWheel.brakeWheel)
				{
					vehicleWheel.wheelCollider.brakeTorque = num2 * brakeForceConstant;
				}
			}
		}
		SetFlag(Flags.Reserved3, num2 >= 100f && AnyMounted());
	}

	public void NoDriverInput()
	{
		if (chairtest)
		{
			gasPedal = Mathf.Sin(Time.time) * 50f;
			return;
		}
		gasPedal = 0f;
		brakePedal = Mathf.Lerp(brakePedal, 100f, Time.deltaTime * GasLerpTime / 5f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 100f;
			brakePedal = 0f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -30f;
			brakePedal = 0f;
		}
		else
		{
			gasPedal = 0f;
			brakePedal = 30f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = -60f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = 60f;
		}
		else
		{
			steering = 0f;
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			lightsOn = !lightsOn;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class VehicleWheel
{
	public Transform shock;

	public WheelCollider wheelCollider;

	public Transform wheel;

	public Transform axle;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using UnityEngine;

public class BicycleAudio : BikeVehicleAudio
{
	[Header("Bicycle")]
	[SerializeField]
	private SoundDefinition pedalActiveSoundDef;

	[SerializeField]
	private SoundDefinition pedalCoastSoundDef;

	[SerializeField]
	private SoundDefinition pedalStartDef;

	[SerializeField]
	private SoundDefinition pedalStopDef;

	[SerializeField]
	private SoundDefinition bellSoundDef;

	[SerializeField]
	private AnimationCurve pedalGainCurve;

	[SerializeField]
	private AnimationCurve pedalPitchCurve;

	[SerializeField]
	private SlicedGranularAudioClip pedalClicks;

	[SerializeField]
	private AnimationCurve pedalClickFrequencyCurve;
}


using System;
using UnityEngine;

public class BikeChassisVisuals : VehicleChassisVisuals<Bike>, IClientComponent
{
	[Serializable]
	private class SuspensionSettings
	{
		public bool enabled;

		public Transform front;

		public float frontMinZ = 0.3f;

		public float frontMaxZ = 0.55f;

		public Transform rearTop;

		public Transform rearBottom;

		public Transform rearSwingArm;

		public float swingArmMinAngle = 5f;

		public float swingArmMaxAngle = 25f;
	}

	[Serializable]
	private class PedalBikeSettings
	{
		public bool enabled;

		public Transform axle;

		public float ratio = 0.5f;

		public Transform left;

		public Transform right;

		public Transform[] clockwiseCogs;

		public Transform[] anticlockwiseCogs;

		public float cogRatio = 1f;
	}

	[Serializable]
	private class KickstandSettiongs
	{
		public bool enabled;

		public Transform pivot;

		public Transform spring;

		public Transform springTarget;

		public float kickstandZ;

		public float upX = 180f;

		public float downX = 80f;
	}

	[Serializable]
	private class ChainRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private SuspensionSettings suspension;

	[SerializeField]
	private PedalBikeSettings pedals;

	[SerializeField]
	private KickstandSettiongs kickstand;

	[SerializeField]
	private BikeVehicleAudio audioScript;

	[SerializeField]
	private ChainRenderer[] chainRenderers;

	[SerializeField]
	private float chainSpeedMultiplier = 1f;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private float minGroundFXSpeed = 3f;
}


using System;
using UnityEngine;

[Serializable]
private class SuspensionSettings
{
	public bool enabled;

	public Transform front;

	public float frontMinZ = 0.3f;

	public float frontMaxZ = 0.55f;

	public Transform rearTop;

	public Transform rearBottom;

	public Transform rearSwingArm;

	public float swingArmMinAngle = 5f;

	public float swingArmMaxAngle = 25f;
}


using System;
using UnityEngine;

[Serializable]
private class PedalBikeSettings
{
	public bool enabled;

	public Transform axle;

	public float ratio = 0.5f;

	public Transform left;

	public Transform right;

	public Transform[] clockwiseCogs;

	public Transform[] anticlockwiseCogs;

	public float cogRatio = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class KickstandSettiongs
{
	public bool enabled;

	public Transform pivot;

	public Transform spring;

	public Transform springTarget;

	public float kickstandZ;

	public float upX = 180f;

	public float downX = 80f;
}


using System;
using UnityEngine;

[Serializable]
private class ChainRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class BikeDriverSeat : BikeSeat
{
	[SerializeField]
	private Vector3 sprintPosOffset;

	[SerializeField]
	private Vector3 bunnyHopPosOffset;
}


using UnityEngine;

public class BikeSeat : MouseSteerableSeat
{
	[SerializeField]
	private Transform eyePosRef;
}


using UnityEngine;

public class BikeVehicleAudio : GroundVehicleAudio
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet engineAudioSet;

	[SerializeField]
	[Header("Suspension")]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	[Header("Tires")]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[Header("Skid")]
	[SerializeField]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;
}


public class MotorbikeAudio : BikeVehicleAudio
{
}


using System;
using UnityEngine;

public class SidecarBikeChassisVisuals : BikeChassisVisuals
{
	[Serializable]
	private class SidecarSuspensionSettings
	{
		public Transform sidecarVisualHinge;

		public Transform sidecarTop;

		public Transform sidecarBottom;

		public Transform sidecarSwingArm;

		public float scSwingArmMinAngle = -10f;

		public float scSwingArmMaxAngle = 10f;
	}

	[SerializeField]
	private SidecarSuspensionSettings sidecarSuspension;
}


using System;
using UnityEngine;

[Serializable]
private class SidecarSuspensionSettings
{
	public Transform sidecarVisualHinge;

	public Transform sidecarTop;

	public Transform sidecarBottom;

	public Transform sidecarSwingArm;

	public float scSwingArmMinAngle = -10f;

	public float scSwingArmMaxAngle = 10f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using VacuumBreather;

public class BaseBoat : BaseVehicle
{
	public enum CorrectionForceMode
	{
		Force = 0,
		Acceleration = 5
	}

	[Header("Boat")]
	public float engineThrust = 10f;

	public float steeringScale = 0.1f;

	public Transform thrustPoint;

	public Transform centerOfMass;

	public Buoyancy buoyancy;

	public bool preventDecayIndoors = true;

	[Header("Correction Forces")]
	public bool applyCorrectionForces = true;

	public Transform[] planeFitPoints;

	public Vector3 inAirPID;

	public float inAirDesiredPitch = -15f;

	public Vector3 wavePID;

	public MinMax correctionRange;

	public CorrectionForceMode correctionForceMode;

	public float correctionSpringForce;

	public float correctionSpringDamping;

	private Vector3[] worldAnchors;

	private PidQuaternionController pidController;

	[ServerVar]
	public static bool generate_paths = true;

	[ServerVar]
	public static bool do_shore_drift = true;

	public static int secondsUntilShoreDrift = 7200;

	public static int secondsBetweenShoreDrift = 120;

	[Help("Shore drift speed in metres per second")]
	[ServerVar]
	public static float drift_speed = 1f;

	[ServerVar]
	public static bool debug_eject_ai = false;

	private float driftDelayedUntil;

	[NonSerialized]
	public float gasPedal;

	[NonSerialized]
	public float steering;

	private TimeSince shoreDriftTimer;

	private string lastDriftCheckStatus = "Never checked";

	protected virtual bool AllowKinematicDrift => false;

	protected virtual bool SkipBoatForcedUpdate => false;

	[Help("Seconds until boat starts drifting to shore if there's nobody around")]
	[ServerVar]
	public static int seconds_until_shore_drift(Arg arg)
	{
		secondsUntilShoreDrift = arg.GetInt(0, secondsUntilShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsUntilShoreDrift;
	}

	[ServerVar]
	[Help("Seconds between shore drift teleport ticks")]
	public static int seconds_between_shore_drift(Arg arg)
	{
		secondsBetweenShoreDrift = arg.GetInt(0, secondsBetweenShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsBetweenShoreDrift;
	}

	public virtual bool DriftDelayed()
	{
		return Time.realtimeSinceStartup < driftDelayedUntil;
	}

	public void SetDriftDelayAmount(float delayAmount)
	{
		driftDelayedUntil = Time.realtimeSinceStartup + delayAmount;
	}

	public bool InDryDock()
	{
		return (Object)(object)GetParentEntity() != (Object)null;
	}

	public override float AntiHackVelocity()
	{
		return 25f;
	}

	public override void ServerInit()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.isKinematic = false;
		if ((Object)(object)rigidBody == (Object)null)
		{
			Debug.LogWarning((object)"Boat rigidbody null");
			return;
		}
		if ((Object)(object)centerOfMass == (Object)null)
		{
			Debug.LogWarning((object)"boat COM null");
			return;
		}
		rigidBody.centerOfMass = centerOfMass.localPosition;
		if (planeFitPoints == null || planeFitPoints.Length != 3)
		{
			Debug.LogWarning((object)"Boats require 3 plane fit points");
			return;
		}
		worldAnchors = (Vector3[])(object)new Vector3[3];
		pidController = new PidQuaternionController(wavePID.x, wavePID.y, wavePID.z);
		if (Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
			return;
		}
		shoreDriftTimer = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsUntilShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void RunAIDriverTick()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (aiInputProvider == null)
		{
			RemoveAIDriver();
		}
		else
		{
			aiInputProvider.OnTick(this, TimeSince.op_Implicit(base.TimeSinceLastAIUpdate), ref steering, ref gasPedal);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public virtual void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -0.5f;
		}
		else
		{
			gasPedal = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = 1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = -1f;
		}
		else
		{
			steering = 0f;
		}
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
	}

	protected override void OnServerWake()
	{
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public virtual bool EngineOn()
	{
		if (HasDriver())
		{
			return !IsFlipped();
		}
		return false;
	}

	public virtual bool EngineOnEligible()
	{
		if (EngineOn() && !IsFlipped())
		{
			return base.healthFraction > 0f;
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseBoat.VehicleFixedUpdate", 0);
		try
		{
			if (!EngineOn())
			{
				gasPedal = 0f;
				steering = 0f;
			}
			base.VehicleFixedUpdate();
			if (SkipBoatForcedUpdate)
			{
				return;
			}
			if (!IsDead())
			{
				ApplyCorrectionForces();
			}
			if (gasPedal != 0f && buoyancy.submergedFraction > 0.3f && WaterLevel.Test(thrustPoint.position, waves: true, volumes: true, this))
			{
				Vector3 val2 = ((Component)this).transform.forward + ((Component)this).transform.right * (steering * steeringScale);
				Vector3 val3 = ((Vector3)(ref val2)).normalized * (gasPedal * engineThrust);
				rigidBody.AddForceAtPosition(val3, thrustPoint.position, (ForceMode)0);
			}
			if (AnyMounted() && IsFlipped())
			{
				if (debug_eject_ai)
				{
					Debug.LogWarning((object)$"Ejecting players from flipped boat {this}");
					object arg = ((Component)this).transform.position;
					Quaternion rotation = ((Component)this).transform.rotation;
					Debug.LogWarning((object)$"Boat was in state / pos {arg} / rot {((Quaternion)(ref rotation)).eulerAngles}");
				}
				DismountAllPlayers();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ApplyCorrectionForces()
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ApplyCorrectionForces", 0);
		try
		{
			if (applyCorrectionForces && planeFitPoints != null && planeFitPoints.Length == 3 && EngineOn() && !(buoyancy.submergedFraction < 0.5f))
			{
				Vector3 val2 = default(Vector3);
				Quaternion currentOrientation = default(Quaternion);
				((Component)this).transform.GetPositionAndRotation(ref val2, ref currentOrientation);
				Vector3 eulerAngles = ((Quaternion)(ref currentOrientation)).eulerAngles;
				Matrix4x4 val3 = Matrix4x4.TRS(val2, Quaternion.Euler(0f, eulerAngles.y, 0f), Vector3.one);
				for (int i = 0; i < planeFitPoints.Length; i++)
				{
					Vector3 val4 = ((Matrix4x4)(ref val3)).MultiplyPoint(planeFitPoints[i].localPosition);
					val4.y = WaterLevel.GetWaterLevel(val4, waves: true);
					worldAnchors[i] = val4;
				}
				float y = planeFitPoints[0].localPosition.y;
				float num = (worldAnchors[0].y + worldAnchors[1].y + worldAnchors[2].y) / 3f - y;
				float y2 = val2.y;
				float x = correctionRange.x;
				float y3 = correctionRange.y;
				if (y2 > num + x && y2 < num + y3)
				{
					float num2 = num - y2;
					Vector3 velocity = rigidBody.velocity;
					float num3 = num2 * correctionSpringForce;
					float num4 = (0f - velocity.y) * correctionSpringDamping;
					rigidBody.AddForce(0f, num3 + num4, 0f, (ForceMode)correctionForceMode);
				}
				if (y2 > num + y3)
				{
					Quaternion desiredOrientation = Quaternion.Euler(inAirDesiredPitch, eulerAngles.y, 0f);
					pidController.Kp = inAirPID.x;
					pidController.Ki = inAirPID.y;
					pidController.Kd = inAirPID.z;
					Vector3 val5 = pidController.ComputeRequiredAngularAcceleration(currentOrientation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
					rigidBody.AddTorque(val5, (ForceMode)5);
				}
				else if (y2 > num + x)
				{
					Vector3 val6 = Vector3.Cross(worldAnchors[1] - worldAnchors[0], worldAnchors[2] - worldAnchors[0]);
					Vector3 val7 = worldAnchors[2] - worldAnchors[1];
					Quaternion desiredOrientation2 = Quaternion.LookRotation(Vector3.Cross(val6, val7), val6);
					pidController.Kp = wavePID.x;
					pidController.Ki = wavePID.y;
					pidController.Kd = wavePID.z;
					Vector3 val8 = pidController.ComputeRequiredAngularAcceleration(currentOrientation, desiredOrientation2, rigidBody.angularVelocity, Time.fixedDeltaTime);
					val8.y = 0f;
					rigidBody.AddTorque(val8, (ForceMode)5);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void WaterVehicleDecay(BaseCombatEntity entity, float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes, float decayStartDelayMinutes, bool preventDecayIndoors)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (entity.healthFraction != 0f && !(timeSinceLastUsed < 60f * decayStartDelayMinutes))
		{
			float overallWaterDepth = WaterLevel.GetOverallWaterDepth(((Component)entity).transform.position, waves: true, volumes: false);
			float num = outsideDecayMinutes;
			if (preventDecayIndoors && !entity.IsOutside())
			{
				num = float.PositiveInfinity;
			}
			if (overallWaterDepth > 12f)
			{
				float num2 = Mathf.InverseLerp(12f, 16f, overallWaterDepth);
				float num3 = Mathf.Lerp(0.1f, 1f, num2);
				num = Mathf.Min(num, deepWaterDecayMinutes / num3);
			}
			if (!float.IsPositiveInfinity(num))
			{
				float num4 = decayTickRate / 60f / num;
				entity.Hurt(entity.MaxHealth() * num4, DamageType.Decay, entity, useProtection: false);
			}
		}
	}

	private void CheckDriftToShore()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		if (!do_shore_drift)
		{
			return;
		}
		if (DriftDelayed())
		{
			lastDriftCheckStatus = "Drift delay active";
		}
		else if (TimeSince.op_Implicit(shoreDriftTimer) < (float)secondsUntilShoreDrift - 1f)
		{
			lastDriftCheckStatus = "Was too soon";
		}
		else if (!AllowKinematicDrift && rigidBody.isKinematic)
		{
			lastDriftCheckStatus = "Was kinematic";
		}
		else if (IsOn())
		{
			lastDriftCheckStatus = "Was on";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
		}
		else if (AnyPlayersOnBoat())
		{
			lastDriftCheckStatus = "Players were on boat";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
		}
		else if (HasParent())
		{
			lastDriftCheckStatus = "Was parented";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
		}
		else if (IsDead())
		{
			lastDriftCheckStatus = "Is dead";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
		}
		else if (WaterFactor() < 0.1f)
		{
			lastDriftCheckStatus = "Not in water";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
		}
		else if ((Object)(object)TerrainTexturing.Instance == (Object)null)
		{
			lastDriftCheckStatus = "No terrain tex";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
		}
		else if (BaseNetworkable.HasConnections(((Component)this).transform.position))
		{
			lastDriftCheckStatus = "Players were nearby";
		}
		else
		{
			if (!DeepSea.boat_drift_deep_sea && DeepSeaManager.IsInsideDeepSea((BaseNetworkable)this))
			{
				return;
			}
			float num = bounds.MaxExtent() + 2f;
			float num2 = drift_speed * (float)secondsBetweenShoreDrift;
			(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)this).transform.position);
			Vector3 item = coarseVectorToShore.shoreDir;
			float item2 = coarseVectorToShore.shoreDist;
			float num3 = 2f * num;
			if (item2 < num3)
			{
				shoreDriftTimer = TimeSince.op_Implicit(0f);
				lastDriftCheckStatus = "Was near shore already";
				return;
			}
			float maxDistance = num2 - num;
			Vector3 val = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * (num + 1f);
			Vector3 val2 = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * num2;
			Ray ray = new Ray(val, item);
			List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
			GamePhysics.TraceAll(ray, num, list, maxDistance, 1235583233, (QueryTriggerInteraction)1, this);
			if (list.Count > 0)
			{
				foreach (RaycastHit item3 in list)
				{
					RaycastHit current = item3;
					if ((Object)(object)((RaycastHit)(ref current)).collider != (Object)null)
					{
						BaseEntity baseEntity = ((RaycastHit)(ref current)).collider.ToBaseEntity();
						if ((Object)(object)baseEntity != (Object)null && baseEntity.HasEntityInParents(this))
						{
							continue;
						}
					}
					if (((RaycastHit)(ref current)).distance <= num3)
					{
						lastDriftCheckStatus = string.Format("Was blocked by {0}:{1} at {2}", ((Object)(object)((RaycastHit)(ref current)).transform.parent != (Object)null) ? ((Object)((RaycastHit)(ref current)).transform.parent).name : "", ((Object)((RaycastHit)(ref current)).transform).name, ((RaycastHit)(ref current)).transform.position);
						Pool.FreeUnmanaged<RaycastHit>(ref list);
						return;
					}
					val2 = ((RaycastHit)(ref current)).point - item * num3;
					val2.y = ((Component)this).transform.position.y + ((Bounds)(ref bounds)).center.y;
					break;
				}
			}
			Vector3 position = ((Component)this).transform.position;
			((Component)this).transform.position = val2 - ((Bounds)(ref bounds)).center;
			if (!rigidBody.isKinematic)
			{
				rigidBody.velocity = Vector3.zero;
				rigidBody.angularVelocity = Vector3.zero;
			}
			lastDriftCheckStatus = $"Drifted {Vector3.Distance(position, ((Component)this).transform.position):F0}m";
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			((FacepunchBehaviour)this).Invoke((Action)GoToSleep, 0f);
		}
	}

	private void GoToSleep()
	{
		rigidBody.Sleep();
	}

	public virtual bool AnyPlayersOnBoat()
	{
		return AnyMounted();
	}

	public virtual void GetPlayersOnBoat(List<BasePlayer> players)
	{
		GetMountedPlayers(players);
	}

	public string GetDriftStatus()
	{
		return lastDriftCheckStatus;
	}

	public static void UpdateShoreDriftInvokeOnAll()
	{
		BaseBoat[] array = Util.FindAll<BaseBoat>();
		foreach (BaseBoat baseBoat in array)
		{
			if (baseBoat.IsValid())
			{
				baseBoat.UpdateShoreDriftInvoke();
			}
		}
	}

	private void UpdateShoreDriftInvoke()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(0f, (float)secondsUntilShoreDrift - TimeSince.op_Implicit(shoreDriftTimer));
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, num, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseBoat = Pool.Get<BaseBoat>();
		info.msg.baseBoat.shoreDriftTimerValue = TimeSince.op_Implicit(shoreDriftTimer);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseBoat != null && base.isServer)
		{
			shoreDriftTimer = TimeSince.op_Implicit(info.msg.baseBoat.shoreDriftTimerValue);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		info = WaterLevel.GetWaterInfo(player.eyes.position, waves: true, volumes: true);
		if (!info.isValid)
		{
			return 0f;
		}
		return 1f;
	}

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 4f;
		float num8 = 200f;
		bool flag = true;
		RaycastHit val9 = default(RaycastHit);
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 val = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 val2 = list[index2];
				Vector3 val3 = list[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				int num9 = 16;
				for (int l = 0; l < num9; l++)
				{
					float num10 = (float)l / (float)num9 * 360f;
					val5 = new Vector3(Mathf.Sin(num10 * (MathF.PI / 180f)), num5, Mathf.Cos(num10 * (MathF.PI / 180f)));
					Vector3 normalized2 = ((Vector3)(ref val5)).normalized;
					Vector3 val7 = val6 + normalized2 * 1f;
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val6;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (!Physics.SphereCast(val4, 3f, val8, ref val9, minDistanceFromShore, 1084293377))
					{
						continue;
					}
					Collider collider = ((RaycastHit)(ref val9)).collider;
					if ((Object)(object)collider != (Object)null && !collider.IsOnLayer((Layer)23))
					{
						MonumentInfo monument = collider.GetMonument();
						if ((Object)(object)monument != (Object)null && monument.IsOilRig())
						{
							continue;
						}
					}
					flag2 = false;
					break;
				}
				if (flag2)
				{
					flag = true;
					list[k] = val6;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning((object)"Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log((object)("Generated ocean patrol path with node count: " + list.Count));
		return list;
	}
}


public enum CorrectionForceMode
{
	Force = 0,
	Acceleration = 5
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Serialization;
using UtilityJobs;
using WaterLevelJobs;

public class Buoyancy : ListComponent<Buoyancy>, IServerComponent, IPrefabPreProcess
{
	public enum Priority
	{
		High,
		Low
	}

	[Serializable]
	public struct BuoyancyPointData
	{
		[ReadOnly]
		public Vector3 localPosition;

		[ReadOnly]
		public Vector3 rootToPoint;

		[NonSerialized]
		public Vector3 position;
	}

	public BuoyancyPoint[] points;

	public GameObjectRef[] waterImpacts;

	public Rigidbody rigidBody;

	public float buoyancyScale = 1f;

	public bool scaleForceWithMass;

	public bool doEffects = true;

	public float flowMovementScale = 1f;

	public float requiredSubmergedFraction = 0.5f;

	public bool useUnderwaterDrag;

	[Range(0f, 3f)]
	public float underwaterDrag = 2f;

	[Range(0f, 1f)]
	[Tooltip("How much this object will pay attention to the wave system, 0 = flat water, 1 = full waves (default 1)")]
	[FormerlySerializedAs("flatWaterLerp")]
	public float wavesEffect = 1f;

	public Action<bool> SubmergedChanged;

	public BaseEntity forEntity;

	[NonSerialized]
	public float submergedFraction;

	public bool FlowForceDisabled;

	[SerializeField]
	[ReadOnly]
	private BuoyancyPointData[] pointData;

	private bool initedPointArrays;

	private Vector2[] pointPositionArray;

	private Vector2[] pointPositionUVArray;

	private float[] pointShoreDistanceArray;

	private float[] pointTerrainHeightArray;

	private float[] pointWaterHeightArray;

	private float defaultDrag;

	private float defaultAngularDrag;

	private float timeInWater;

	[NonSerialized]
	public float? ArtificialHeight;

	private BaseVehicle forVehicle;

	private bool hasLocalPlayers;

	private bool hadLocalPlayers;

	private static NativeArray<Vector2> allPositions2D;

	private static NativeArray<Vector3> allPositions3D;

	private static NativeArray<Vector2> allUVPositions;

	private static NativeArray<float> pointWaterHeightNativeArray;

	private static NativeArray<float> pointShoreDistanceNativeArray;

	private static NativeArray<float> pointTerrainHeightNativeArray;

	private static NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray;

	private static NativeArray<float> radiiIgnores;

	private static NativeArray<bool> waterIgnoreResults;

	private static NativeArray<bool> instanceDoDeepWaterChecksStateArray;

	private static NativeArray<int> instancePointCountNativeArray;

	[ServerVar]
	public static bool use_batching = true;

	public float timeOutOfWater { get; private set; }

	public bool InWater => submergedFraction > requiredSubmergedFraction;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public Priority BuoyancyPriority { get; set; }

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!Application.isPlaying || serverside)
		{
			SavePointData(forced: false);
		}
	}

	public void SavePointData(bool forced)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Length == 0)
		{
			Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			}
			GameObject val2 = new GameObject("BuoyancyPoint");
			val2.transform.parent = ((Component)val).gameObject.transform;
			val2.transform.localPosition = val.centerOfMass;
			BuoyancyPoint buoyancyPoint = val2.AddComponent<BuoyancyPoint>();
			buoyancyPoint.buoyancyForce = val.mass * (0f - Physics.gravity.y);
			buoyancyPoint.buoyancyForce *= 1.32f;
			buoyancyPoint.size = 0.2f;
			points = new BuoyancyPoint[1];
			points[0] = buoyancyPoint;
		}
		if (pointData == null || pointData.Length != points.Length || forced)
		{
			pointData = new BuoyancyPointData[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = ((Component)points[i]).transform;
				pointData[i].localPosition = transform.localPosition;
				pointData[i].rootToPoint = ((Component)this).transform.InverseTransformPoint(transform.position);
			}
		}
	}

	public void SetBuoyancyPointLocations(List<Vector3> locations)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Length != locations.Count)
		{
			Debug.LogWarning((object)"Trying to SetBuoyancyPointLocations with mismatching array lengths");
			return;
		}
		int num = 0;
		BuoyancyPoint[] array = points;
		for (int i = 0; i < array.Length; i++)
		{
			((Component)array[i]).transform.position = locations[num];
			num++;
		}
	}

	public static string DefaultWaterImpact()
	{
		return "assets/bundled/prefabs/fx/impacts/physics/water-enter-exit.prefab";
	}

	private void Awake()
	{
		forVehicle = forEntity as BaseVehicle;
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckSleepState, 0.5f, 5f, 1f);
	}

	public void Sleep()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancySleep(InWater)) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.Sleep();
		}
		((Behaviour)this).enabled = false;
	}

	private static void ClearArrays()
	{
		allPositions2D.MemClear<Vector2>();
		allPositions3D.MemClear<Vector3>();
		allUVPositions.MemClear<Vector2>();
		NativeArrayEx.MemClear(in pointShoreDistanceNativeArray);
		NativeArrayEx.MemClear(in pointTerrainHeightNativeArray);
		NativeArrayEx.MemClear(in pointWaterHeightNativeArray);
		NativeArrayEx.MemClear(in pointWaterInfoNativeArray);
		NativeArrayEx.MemClear(in radiiIgnores);
		NativeArrayEx.MemClear(in waterIgnoreResults);
		NativeArrayEx.MemClear(in instanceDoDeepWaterChecksStateArray);
		NativeArrayEx.MemClear(in instancePointCountNativeArray);
	}

	private static void EnsureNativeArrayLength(int maxPoints, int maxInstances)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		if (maxPoints > allPositions2D.Length || maxInstances > instancePointCountNativeArray.Length)
		{
			allPositions2D.SafeDispose<Vector2>();
			allPositions3D.SafeDispose<Vector3>();
			allUVPositions.SafeDispose<Vector2>();
			NativeArrayEx.SafeDispose(ref pointShoreDistanceNativeArray);
			NativeArrayEx.SafeDispose(ref pointTerrainHeightNativeArray);
			NativeArrayEx.SafeDispose(ref pointWaterHeightNativeArray);
			NativeArrayEx.SafeDispose(ref pointWaterInfoNativeArray);
			NativeArrayEx.SafeDispose(ref radiiIgnores);
			NativeArrayEx.SafeDispose(ref waterIgnoreResults);
			NativeArrayEx.SafeDispose(ref instanceDoDeepWaterChecksStateArray);
			NativeArrayEx.SafeDispose(ref instancePointCountNativeArray);
			allPositions2D = new NativeArray<Vector2>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			allPositions3D = new NativeArray<Vector3>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			allUVPositions = new NativeArray<Vector2>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			pointWaterHeightNativeArray = new NativeArray<float>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			pointShoreDistanceNativeArray = new NativeArray<float>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			pointTerrainHeightNativeArray = new NativeArray<float>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			pointWaterHeightNativeArray = new NativeArray<float>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			pointWaterInfoNativeArray = new NativeArray<WaterLevel.WaterInfo>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			radiiIgnores = new NativeArray<float>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			waterIgnoreResults = new NativeArray<bool>(maxPoints, (Allocator)4, (NativeArrayOptions)1);
			instanceDoDeepWaterChecksStateArray = new NativeArray<bool>(maxInstances, (Allocator)4, (NativeArrayOptions)1);
			instancePointCountNativeArray = new NativeArray<int>(maxInstances, (Allocator)4, (NativeArrayOptions)1);
		}
	}

	public void Wake()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancyWake()) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
		}
		((Behaviour)this).enabled = true;
	}

	public void CheckSleepState()
	{
		if ((Object)(object)((Component)this).transform == (Object)null || (Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		hasLocalPlayers = HasLocalPlayers();
		bool flag = rigidBody.IsSleeping() || rigidBody.isKinematic;
		bool flag2 = flag || (!hasLocalPlayers && timeInWater > 6f);
		if ((Object)(object)forVehicle != (Object)null && forVehicle.IsOn())
		{
			flag2 = false;
		}
		if (((Behaviour)this).enabled && flag2)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (!((Behaviour)this).enabled && hasLocalPlayers && !hadLocalPlayers)
		{
			DoCycle(forced: true);
		}
		bool flag3 = !flag || ShouldWake(hasLocalPlayers);
		if (!((Behaviour)this).enabled && flag3)
		{
			((FacepunchBehaviour)this).Invoke((Action)Wake, 0f);
		}
		hadLocalPlayers = hasLocalPlayers;
	}

	public void LowPriorityCheck(bool forceHighPriority)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Priority buoyancyPriority = BuoyancyPriority;
		Priority priority = buoyancyPriority;
		if (forceHighPriority)
		{
			priority = Priority.High;
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			priority = ((!BaseNetworkable.HasCloseConnections(position, Server.lowPriorityBuoyancyRange)) ? Priority.Low : Priority.High);
			if (priority == Priority.Low && priority != buoyancyPriority)
			{
				Vector3 val = Vector3Ex.WithY(((Component)this).transform.TransformPoint(Vector3.forward * 2f), position.y);
				Rigidbody obj = rigidBody;
				Vector3 val2 = val - rigidBody.position;
				obj.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
			}
		}
		if (priority != buoyancyPriority)
		{
			rigidBody.velocity = Vector3.zero;
			rigidBody.angularVelocity = Vector3.zero;
			BuoyancyPriority = priority;
		}
	}

	public bool ShouldWake()
	{
		return ShouldWake(HasLocalPlayers());
	}

	public bool ShouldWake(bool hasLocalPlayers)
	{
		if (hasLocalPlayers)
		{
			return submergedFraction > 0f;
		}
		return false;
	}

	private bool HasLocalPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f);
	}

	private static void DoCycleBatched(ReadOnlySpan<Buoyancy> buoyancies, bool forced)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (buoyancies.Length == 0)
		{
			return;
		}
		PooledArray<bool> wasSubmergedStates = default(PooledArray<bool>);
		wasSubmergedStates..ctor(buoyancies.Length);
		try
		{
			PooledList<Buoyancy> val = Pool.Get<PooledList<Buoyancy>>();
			try
			{
				PooledList<Buoyancy> val2 = Pool.Get<PooledList<Buoyancy>>();
				try
				{
					int num = 0;
					int num2 = 0;
					for (int i = 0; i < buoyancies.Length; i++)
					{
						Buoyancy buoyancy = buoyancies[i];
						if ((Object)(object)buoyancy == (Object)null || (Object)(object)buoyancy.rigidBody == (Object)null)
						{
							continue;
						}
						if (buoyancy.buoyancyScale == 0f)
						{
							buoyancy.Sleep();
							continue;
						}
						wasSubmergedStates[i] = buoyancy.submergedFraction > 0f;
						if (DeepSeaManager.IsInsideDeepSea(((Component)buoyancy).transform.position))
						{
							((List<Buoyancy>)(object)val2).Add(buoyancy);
							num2 += buoyancy.GetPointDataCount();
						}
						else
						{
							num += buoyancy.GetPointDataCount();
							((List<Buoyancy>)(object)val).Add(buoyancy);
						}
					}
					int count = ((List<Buoyancy>)(object)val).Count;
					int count2 = ((List<Buoyancy>)(object)val2).Count;
					int maxPoints = math.max(num, num2);
					int maxInstances = math.max(count, count2);
					EnsureNativeArrayLength(maxPoints, maxInstances);
					if (count > 0)
					{
						ClearArrays();
						BuoyancyFixedUpdateBatched(UnsafeListAccess.ListAsReadOnlySpan<Buoyancy>((List<Buoyancy>)(object)val), isDeepSea: false);
					}
					if (count2 > 0)
					{
						ClearArrays();
						BuoyancyFixedUpdateBatched(UnsafeListAccess.ListAsReadOnlySpan<Buoyancy>((List<Buoyancy>)(object)val2), isDeepSea: true);
					}
					UpdateSubmergedState(UnsafeListAccess.ListAsReadOnlySpan<Buoyancy>((List<Buoyancy>)(object)val), wasSubmergedStates);
					UpdateSubmergedState(UnsafeListAccess.ListAsReadOnlySpan<Buoyancy>((List<Buoyancy>)(object)val2), wasSubmergedStates);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)wasSubmergedStates/*cast due to .constrained prefix*/).Dispose();
		}
	}

	private static void UpdateSubmergedState(ReadOnlySpan<Buoyancy> buoyancies, PooledArray<bool> wasSubmergedStates)
	{
		for (int i = 0; i < buoyancies.Length; i++)
		{
			Buoyancy buoyancy = buoyancies[i];
			Rigidbody val = buoyancy.rigidBody;
			bool flag = buoyancy.submergedFraction > 0f;
			if (wasSubmergedStates[i] == flag)
			{
				continue;
			}
			if (buoyancy.useUnderwaterDrag && (Object)(object)val != (Object)null)
			{
				if (flag)
				{
					buoyancy.defaultDrag = val.drag;
					buoyancy.defaultAngularDrag = val.angularDrag;
					val.drag = buoyancy.underwaterDrag;
					val.angularDrag = buoyancy.underwaterDrag;
				}
				else
				{
					val.drag = buoyancy.defaultDrag;
					val.angularDrag = buoyancy.defaultAngularDrag;
				}
			}
			buoyancy.SubmergedChanged?.Invoke(flag);
		}
	}

	protected void DoCycle(bool forced = false)
	{
		if (!((Behaviour)this).enabled && !forced)
		{
			return;
		}
		bool num = submergedFraction > 0f;
		BuoyancyFixedUpdate();
		bool flag = submergedFraction > 0f;
		if (num == flag)
		{
			return;
		}
		if (useUnderwaterDrag && (Object)(object)rigidBody != (Object)null)
		{
			if (flag)
			{
				defaultDrag = rigidBody.drag;
				defaultAngularDrag = rigidBody.angularDrag;
				rigidBody.drag = underwaterDrag;
				rigidBody.angularDrag = underwaterDrag;
			}
			else
			{
				rigidBody.drag = defaultDrag;
				rigidBody.angularDrag = defaultAngularDrag;
			}
		}
		if (SubmergedChanged != null)
		{
			SubmergedChanged(flag);
		}
	}

	public static void Cycle()
	{
		bool autoSyncTransforms = Physics.autoSyncTransforms;
		try
		{
			Physics.autoSyncTransforms = false;
			Buoyancy[] buffer = ListComponent<Buoyancy>.InstanceList.Values.Buffer;
			int count = ListComponent<Buoyancy>.InstanceList.Count;
			if (use_batching)
			{
				DoCycleBatched(ListComponent<Buoyancy>.InstanceList.Values.ContentReadOnlySpan(), forced: false);
				return;
			}
			for (int i = 0; i < count; i++)
			{
				buffer[i].DoCycle();
			}
		}
		finally
		{
			if (autoSyncTransforms)
			{
				Physics.SyncTransforms();
			}
			Physics.autoSyncTransforms = autoSyncTransforms;
		}
	}

	private static Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetWaterFlowDirection(worldPos);
	}

	private static void BuoyancyFixedUpdateBatched(ReadOnlySpan<Buoyancy> activeComponents, bool isDeepSea)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0603: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_060e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_068f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0694: Unknown result type (might be due to invalid IL or missing references)
		//IL_0699: Unknown result type (might be due to invalid IL or missing references)
		//IL_069b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0817: Unknown result type (might be due to invalid IL or missing references)
		//IL_073e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0740: Unknown result type (might be due to invalid IL or missing references)
		//IL_0745: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		Bounds deepSeaBounds = DeepSeaManager.DeepSeaBounds;
		Vector3 terrainPosition = TerrainMeta.Position;
		Vector3 terrainOneOverSize = TerrainMeta.OneOverSize;
		int pointIndexOffset = 0;
		for (int i = 0; i < activeComponents.Length; i++)
		{
			Buoyancy buoyancy = activeComponents[i];
			if (buoyancy.BuoyancyPriority == Priority.High)
			{
				NativeArray<BuoyancyPointData> val = NativeArrayUtility.CopyToNativeArray<BuoyancyPointData>(buoyancy.pointData, (Allocator)2);
				BuoyancyBurstUtility.FillPointData(in pointIndexOffset, ref allPositions2D, ref allUVPositions, ((Component)buoyancy).transform.localToWorldMatrix, ref val, in deepSeaBounds, in terrainPosition, in terrainOneOverSize, in isDeepSea, ref allPositions3D, out var pointCount);
				pointIndexOffset += pointCount;
				instancePointCountNativeArray[i] = pointCount;
				val.Dispose();
			}
			else
			{
				allPositions2D[pointIndexOffset] = Vector2.op_Implicit(((Component)buoyancy).transform.position);
				allPositions3D[pointIndexOffset] = ((Component)buoyancy).transform.position;
				pointIndexOffset++;
				instancePointCountNativeArray[i] = 1;
			}
			instanceDoDeepWaterChecksStateArray[i] = !buoyancy.ArtificialHeight.HasValue;
		}
		NativeArray<Vector2> pos = allPositions2D.GetSubArray(0, pointIndexOffset);
		NativeArray<Vector3> allPositions = allPositions3D.GetSubArray(0, pointIndexOffset);
		NativeArray<Vector2> posUV = allUVPositions.GetSubArray(0, pointIndexOffset);
		NativeArray<float> shore = pointShoreDistanceNativeArray.GetSubArray(0, pointIndexOffset);
		NativeArray<float> terrainHeight = pointTerrainHeightNativeArray.GetSubArray(0, pointIndexOffset);
		NativeArray<float> waterHeight = pointWaterHeightNativeArray.GetSubArray(0, pointIndexOffset);
		NativeArray<WaterLevel.WaterInfo> pointWaterInfo = pointWaterInfoNativeArray.GetSubArray(0, pointIndexOffset);
		NativeArray<float> subArray = radiiIgnores.GetSubArray(0, pointIndexOffset);
		NativeArray<bool> waterIgnoreStates = waterIgnoreResults.GetSubArray(0, pointIndexOffset);
		WaterSystem.GetHeightArray(in pos, in posUV, ref shore, ref terrainHeight, ref waterHeight, isDeepSea);
		TerrainTopologyMap.TopologyQueryStructure topologyMap = TerrainMeta.TopologyMap.GetQueryStructure();
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Values = subArray;
		fillJob.Value = 0.01f;
		FillJob<float> fillJob2 = fillJob;
		IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
		WaterSystem.Collision.GetIgnore(allPositions.AsReadOnly(), subArray.AsReadOnly(), waterIgnoreStates);
		NativeArray<bool> needsDeepWaterChecks = default(NativeArray<bool>);
		needsDeepWaterChecks..ctor(pointWaterInfo.Length, (Allocator)2, (NativeArrayOptions)1);
		WaterLevelBurst.GetBuoyancyWaterInfoBatched(in allPositions, in posUV, in terrainHeight, in waterHeight, in instanceDoDeepWaterChecksStateArray, ref pointWaterInfo, in instancePointCountNativeArray, activeComponents.Length, in topologyMap, in waterIgnoreStates, ref needsDeepWaterChecks, isDeepSea, out var hasAnyDeepWaterChecks);
		if (hasAnyDeepWaterChecks)
		{
			WaterLevelBurst.ConstructDeepWaterCommands(in allPositions, in pointWaterInfo, in needsDeepWaterChecks, out var deepWaterCasts, out var raycastPointIndices, (Allocator)3);
			if (deepWaterCasts.Length > 0)
			{
				NativeArray<RaycastHit> val2 = default(NativeArray<RaycastHit>);
				val2..ctor(deepWaterCasts.Length, (Allocator)3, (NativeArrayOptions)1);
				NativeArray<RaycastCommand> val3 = NativeList<RaycastCommand>.op_Implicit(deepWaterCasts);
				NativeArray<RaycastHit> val4 = val2;
				JobHandle val5 = default(JobHandle);
				val5 = RaycastCommand.ScheduleBatch(val3, val4, 1, val5);
				((JobHandle)(ref val5)).Complete();
				for (int j = 0; j < deepWaterCasts.Length; j++)
				{
					RaycastHit val6 = val2[j];
					if (((RaycastHit)(ref val6)).colliderInstanceID != 0)
					{
						int num = raycastPointIndices[j];
						WaterLevel.WaterInfo waterInfo = pointWaterInfo[num];
						float surfaceLevel = waterInfo.surfaceLevel;
						val6 = val2[j];
						Bounds bounds = ((RaycastHit)(ref val6)).collider.bounds;
						float num2 = Mathf.Min(surfaceLevel, ((Bounds)(ref bounds)).max.y);
						waterInfo.currentDepth = Mathf.Max(0f, num2 - allPositions[num].y);
						waterInfo.overallDepth = Mathf.Max(0f, num2 - terrainHeight[num]);
						waterInfo.surfaceLevel = num2;
					}
				}
				val2.Dispose();
			}
			deepWaterCasts.Dispose();
		}
		float time = Time.time;
		float fixedDeltaTime = Time.fixedDeltaTime;
		NativeArray<BuoyancyForceAccumulationBurst.InstanceInput> instances = default(NativeArray<BuoyancyForceAccumulationBurst.InstanceInput>);
		instances..ctor(activeComponents.Length, (Allocator)2, (NativeArrayOptions)1);
		NativeArray<BuoyancyForceAccumulationBurst.InstanceOutput> results = default(NativeArray<BuoyancyForceAccumulationBurst.InstanceOutput>);
		results..ctor(activeComponents.Length, (Allocator)2, (NativeArrayOptions)1);
		NativeArray<float> pointSize = default(NativeArray<float>);
		pointSize..ctor(pointIndexOffset, (Allocator)2, (NativeArrayOptions)1);
		NativeArray<float> pointBuoyancyForce = default(NativeArray<float>);
		pointBuoyancyForce..ctor(pointIndexOffset, (Allocator)2, (NativeArrayOptions)1);
		NativeArray<float> pointRandomOffset = default(NativeArray<float>);
		pointRandomOffset..ctor(pointIndexOffset, (Allocator)2, (NativeArrayOptions)1);
		NativeArray<float> pointWaveFrequency = default(NativeArray<float>);
		pointWaveFrequency..ctor(pointIndexOffset, (Allocator)2, (NativeArrayOptions)1);
		NativeArray<float> pointWaveScale = default(NativeArray<float>);
		pointWaveScale..ctor(pointIndexOffset, (Allocator)2, (NativeArrayOptions)1);
		int num3 = 0;
		for (int k = 0; k < activeComponents.Length; k++)
		{
			Buoyancy buoyancy2 = activeComponents[k];
			int num4 = instancePointCountNativeArray[k];
			Rigidbody val7 = buoyancy2.rigidBody;
			instances[k] = new BuoyancyForceAccumulationBurst.InstanceInput
			{
				pointStartIndex = num3,
				pointCount = num4,
				buoyancyScale = buoyancy2.buoyancyScale,
				rigidBodyMass = (((Object)(object)val7 != (Object)null) ? val7.mass : 0f),
				wavesEffect = buoyancy2.wavesEffect,
				scaleForceWithMass = buoyancy2.scaleForceWithMass,
				flowForceDisabled = buoyancy2.FlowForceDisabled,
				flowMovementScale = buoyancy2.flowMovementScale,
				worldCom = (((Object)(object)val7 != (Object)null) ? float3.op_Implicit(val7.worldCenterOfMass) : float3.zero)
			};
			if (buoyancy2.BuoyancyPriority == Priority.High)
			{
				for (int l = 0; l < buoyancy2.points.Length; l++)
				{
					BuoyancyPoint buoyancyPoint = buoyancy2.points[l];
					int num5 = num3 + l;
					pointSize[num5] = buoyancyPoint.size;
					pointBuoyancyForce[num5] = buoyancyPoint.buoyancyForce;
					pointRandomOffset[num5] = buoyancyPoint.randomOffset;
					pointWaveFrequency[num5] = buoyancyPoint.waveFrequency;
					pointWaveScale[num5] = buoyancyPoint.waveScale;
				}
			}
			else
			{
				int num6 = num3;
				if (buoyancy2.points != null && buoyancy2.points.Length != 0)
				{
					BuoyancyPoint buoyancyPoint2 = buoyancy2.points[0];
					pointSize[num6] = buoyancyPoint2.size;
					pointBuoyancyForce[num6] = buoyancyPoint2.buoyancyForce;
					pointRandomOffset[num6] = buoyancyPoint2.randomOffset;
					pointWaveFrequency[num6] = buoyancyPoint2.waveFrequency;
					pointWaveScale[num6] = buoyancyPoint2.waveScale;
				}
				else
				{
					pointSize[num6] = 0f;
					pointBuoyancyForce[num6] = 0f;
					pointRandomOffset[num6] = 0f;
					pointWaveFrequency[num6] = 0f;
					pointWaveScale[num6] = 0f;
				}
			}
			num3 += num4;
		}
		NativeArray<float3> pointFlowDirection = (((Object)(object)TerrainMeta.WaterFlowMap != (Object)null) ? TerrainMeta.WaterFlowMap.GetFlowDirections(allPositions, (Allocator)2) : new NativeArray<float3>(pointIndexOffset, (Allocator)2, (NativeArrayOptions)1));
		BuoyancyForceAccumulationBurst.Compute(in instances, allPositions.Reinterpret<float3>(), in shore, in pointWaterInfo, in pointSize, in pointBuoyancyForce, in pointRandomOffset, in pointWaveFrequency, in pointWaveScale, in pointFlowDirection, time, ref results);
		num3 = 0;
		Vector3 val12 = default(Vector3);
		for (int m = 0; m < activeComponents.Length; m++)
		{
			Buoyancy buoyancy3 = activeComponents[m];
			int pointCount2 = instances[m].pointCount;
			int num7 = num3 + pointCount2;
			Rigidbody val8 = buoyancy3.rigidBody;
			GameObjectRef[] array = buoyancy3.waterImpacts;
			bool flag = buoyancy3.doEffects;
			bool inWater = buoyancy3.InWater;
			BuoyancyForceAccumulationBurst.InstanceOutput instanceOutput = results[m];
			int numSubmerged = instanceOutput.numSubmerged;
			Vector3 val9 = float3.op_Implicit(instanceOutput.netForce);
			Vector3 val10 = float3.op_Implicit(instanceOutput.netTorque);
			int num8 = 0;
			for (int n = num3; n < num7; n++)
			{
				BuoyancyPoint buoyancyPoint3 = buoyancy3.points[num8];
				Vector3 localPosition = buoyancy3.pointData[num8].localPosition;
				Vector3 val11 = allPositions[n];
				WaterLevel.WaterInfo waterInfo2 = pointWaterInfo[n];
				bool flag2 = waterInfo2.isValid && val11.y < waterInfo2.surfaceLevel;
				if (buoyancyPoint3.doSplashEffects && ((!buoyancyPoint3.wasSubmergedLastFrame && flag2) || (!flag2 && buoyancyPoint3.wasSubmergedLastFrame)) && flag)
				{
					Vector3 relativePointVelocity = val8.GetRelativePointVelocity(localPosition);
					if (((Vector3)(ref relativePointVelocity)).magnitude > 1f)
					{
						string strName = ((array != null && array.Length != 0 && array[0].isValid) ? array[0].resourcePath : DefaultWaterImpact());
						((Vector3)(ref val12))..ctor(Random.Range(-0.25f, 0.25f), 0f, Random.Range(-0.25f, 0.25f));
						Effect.server.Run(strName, val11 + val12, Vector3.up);
						buoyancyPoint3.nexSplashTime = time + 0.25f;
					}
				}
				buoyancyPoint3.wasSubmergedLastFrame = flag2;
				num8++;
			}
			num3 += pointCount2;
			if (((Vector3)(ref val9)).sqrMagnitude > 0f)
			{
				val8.AddForce(val9, (ForceMode)0);
			}
			if (((Vector3)(ref val10)).sqrMagnitude > 0f)
			{
				val8.AddTorque(val10, (ForceMode)0);
			}
			if (pointCount2 > 0)
			{
				buoyancy3.submergedFraction = (float)numSubmerged / (float)pointCount2;
			}
			if (inWater)
			{
				buoyancy3.timeInWater += fixedDeltaTime;
				buoyancy3.timeOutOfWater = 0f;
			}
			else
			{
				buoyancy3.timeOutOfWater += fixedDeltaTime;
				buoyancy3.timeInWater = 0f;
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int GetPointDataCount()
	{
		if (BuoyancyPriority == Priority.High)
		{
			return pointData.Length;
		}
		return 1;
	}

	public void BuoyancyFixedUpdate()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		if (buoyancyScale == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (BuoyancyPriority == Priority.Low)
		{
			WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: true, forEntity);
			Vector3 position = rigidBody.position;
			if (position.y < waterInfo.surfaceLevel)
			{
				rigidBody.position = new Vector3(position.x, waterInfo.surfaceLevel, position.z);
			}
			return;
		}
		if (!initedPointArrays)
		{
			InitPointArrays();
		}
		float time = Time.time;
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		bool flag = DeepSeaManager.IsInsideDeepSea(((Matrix4x4)(ref localToWorldMatrix)).GetPosition());
		float x;
		float z;
		float x2;
		float z2;
		if (flag)
		{
			x = ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).min.x;
			z = ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).min.z;
			x2 = Vector3Ex.Inverse(((Bounds)(ref DeepSeaManager.DeepSeaBounds)).size).x;
			z2 = Vector3Ex.Inverse(((Bounds)(ref DeepSeaManager.DeepSeaBounds)).size).z;
		}
		else
		{
			x = TerrainMeta.Position.x;
			z = TerrainMeta.Position.z;
			x2 = TerrainMeta.OneOverSize.x;
			z2 = TerrainMeta.OneOverSize.z;
		}
		for (int i = 0; i < pointData.Length; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(pointData[i].rootToPoint);
			pointData[i].position = val;
			float num = (val.x - x) * x2;
			float num2 = (val.z - z) * z2;
			pointPositionArray[i] = new Vector2(val.x, val.z);
			pointPositionUVArray[i] = new Vector2(num, num2);
		}
		WaterSystem.GetHeightArray(pointPositionArray, pointPositionUVArray, pointShoreDistanceArray, pointTerrainHeightArray, pointWaterHeightArray, flag);
		bool flag2 = wavesEffect < 1f;
		int num3 = 0;
		Vector3 accumForce = default(Vector3);
		Vector3 val2 = default(Vector3);
		for (int j = 0; j < points.Length; j++)
		{
			BuoyancyPoint buoyancyPoint = points[j];
			Vector3 pos = pointData[j].position;
			Vector3 localPosition = pointData[j].localPosition;
			Vector2 posUV = pointPositionUVArray[j];
			float terrainHeight = pointTerrainHeightArray[j];
			float num4 = pointWaterHeightArray[j];
			if (ArtificialHeight.HasValue)
			{
				num4 = ArtificialHeight.Value;
			}
			else if (flag2)
			{
				num4 = Mathf.Lerp(0f, num4, wavesEffect);
			}
			bool doDeepwaterChecks = !ArtificialHeight.HasValue;
			WaterLevel.WaterInfo waterInfo2 = WaterLevel.GetBuoyancyWaterInfo(pos, posUV, terrainHeight, num4, doDeepwaterChecks, forEntity);
			if (flag2 && waterInfo2.isValid)
			{
				waterInfo2.currentDepth = Mathf.Lerp(waterInfo2.currentDepth, waterInfo2.surfaceLevel - pos.y, wavesEffect);
			}
			bool flag3 = false;
			if (pos.y < waterInfo2.surfaceLevel && waterInfo2.isValid)
			{
				flag3 = true;
				num3++;
				float currentDepth = waterInfo2.currentDepth;
				float num5 = Mathf.InverseLerp(0f, buoyancyPoint.size, currentDepth);
				float num6 = 1f + Mathf.PerlinNoise(buoyancyPoint.randomOffset + time * buoyancyPoint.waveFrequency, 0f) * buoyancyPoint.waveScale;
				float scaledBuoyancyForce = buoyancyPoint.buoyancyForce * buoyancyScale;
				if (scaleForceWithMass)
				{
					scaledBuoyancyForce *= rigidBody.mass;
				}
				((Vector3)(ref accumForce))..ctor(0f, num6 * num5 * scaledBuoyancyForce, 0f);
				AccumulateFlowForce(ref accumForce, in pos, in waterInfo2, Mathf.Abs(pointShoreDistanceArray[j]), ref scaledBuoyancyForce, in FlowForceDisabled, in flowMovementScale);
				rigidBody.AddForceAtPosition(accumForce, pos, (ForceMode)0);
			}
			if (buoyancyPoint.doSplashEffects && ((!buoyancyPoint.wasSubmergedLastFrame && flag3) || (!flag3 && buoyancyPoint.wasSubmergedLastFrame)) && doEffects)
			{
				Vector3 relativePointVelocity = rigidBody.GetRelativePointVelocity(localPosition);
				if (((Vector3)(ref relativePointVelocity)).magnitude > 1f)
				{
					string strName = ((waterImpacts != null && waterImpacts.Length != 0 && waterImpacts[0].isValid) ? waterImpacts[0].resourcePath : DefaultWaterImpact());
					((Vector3)(ref val2))..ctor(Random.Range(-0.25f, 0.25f), 0f, Random.Range(-0.25f, 0.25f));
					Effect.server.Run(strName, pos + val2, Vector3.up);
					buoyancyPoint.nexSplashTime = Time.time + 0.25f;
				}
			}
			buoyancyPoint.wasSubmergedLastFrame = flag3;
		}
		if (points.Length != 0)
		{
			submergedFraction = (float)num3 / (float)points.Length;
		}
		if (InWater)
		{
			timeInWater += Time.fixedDeltaTime;
			timeOutOfWater = 0f;
		}
		else
		{
			timeOutOfWater += Time.fixedDeltaTime;
			timeInWater = 0f;
		}
	}

	public static void AccumulateFlowForce(ref Vector3 accumForce, in Vector3 pos, in WaterLevel.WaterInfo waterInfo, in float shoreDistance, ref float scaledBuoyancyForce, in bool flowForceDisabled, in float flowMovementScale)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!waterInfo.artificalWater && !flowForceDisabled && (waterInfo.topology & 0x10000) == 0)
		{
			float num = Mathf.Clamp01(Mathf.InverseLerp(60f, 0f, shoreDistance));
			if (!(num <= Mathf.Epsilon))
			{
				num = Mathf.Pow(num, 0.5f);
				Vector3 flowDirection = GetFlowDirection(pos);
				scaledBuoyancyForce *= 0.025f * num;
				accumForce.x += flowDirection.x * scaledBuoyancyForce * flowMovementScale;
				accumForce.z += flowDirection.z * scaledBuoyancyForce * flowMovementScale;
			}
		}
	}

	private void InitPointArrays()
	{
		pointPositionArray = (Vector2[])(object)new Vector2[points.Length];
		pointPositionUVArray = (Vector2[])(object)new Vector2[points.Length];
		pointShoreDistanceArray = new float[points.Length];
		pointTerrainHeightArray = new float[points.Length];
		pointWaterHeightArray = new float[points.Length];
		initedPointArrays = true;
	}
}


public enum Priority
{
	High,
	Low
}


using System;
using UnityEngine;

[Serializable]
public struct BuoyancyPointData
{
	[ReadOnly]
	public Vector3 localPosition;

	[ReadOnly]
	public Vector3 rootToPoint;

	[NonSerialized]
	public Vector3 position;
}


using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

[BurstCompile]
public class BuoyancyBurstUtility
{
	internal delegate void FillPointData_00004E79$PostfixBurstDelegate(in int pointIndexOffset, ref NativeArray<Vector2> pointPositionArray, ref NativeArray<Vector2> pointPositionUVArray, in Matrix4x4 rootToWorld, ref NativeArray<Buoyancy.BuoyancyPointData> pointData, in Bounds deepSeaBounds, in Vector3 terrainPosition, in Vector3 terrainOneOverSize, in bool isDeepSea, ref NativeArray<Vector3> allPositions3D, out int pointCount);

	internal static class FillPointData_00004E79$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(FillPointData_00004E79$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static FillPointData_00004E79$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in int pointIndexOffset, ref NativeArray<Vector2> pointPositionArray, ref NativeArray<Vector2> pointPositionUVArray, in Matrix4x4 rootToWorld, ref NativeArray<Buoyancy.BuoyancyPointData> pointData, in Bounds deepSeaBounds, in Vector3 terrainPosition, in Vector3 terrainOneOverSize, in bool isDeepSea, ref NativeArray<Vector3> allPositions3D, out int pointCount)
		{
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref int, ref NativeArray<Vector2>, ref NativeArray<Vector2>, ref Matrix4x4, ref NativeArray<Buoyancy.BuoyancyPointData>, ref Bounds, ref Vector3, ref Vector3, ref bool, ref NativeArray<Vector3>, ref int, void>)functionPointer)(ref pointIndexOffset, ref pointPositionArray, ref pointPositionUVArray, ref rootToWorld, ref pointData, ref deepSeaBounds, ref terrainPosition, ref terrainOneOverSize, ref isDeepSea, ref allPositions3D, ref pointCount);
					return;
				}
			}
			FillPointData$BurstManaged(in pointIndexOffset, ref pointPositionArray, ref pointPositionUVArray, in rootToWorld, ref pointData, in deepSeaBounds, in terrainPosition, in terrainOneOverSize, in isDeepSea, ref allPositions3D, out pointCount);
		}
	}

	[BurstCompile]
	public static void FillPointData(in int pointIndexOffset, ref NativeArray<Vector2> pointPositionArray, ref NativeArray<Vector2> pointPositionUVArray, in Matrix4x4 rootToWorld, ref NativeArray<Buoyancy.BuoyancyPointData> pointData, in Bounds deepSeaBounds, in Vector3 terrainPosition, in Vector3 terrainOneOverSize, in bool isDeepSea, ref NativeArray<Vector3> allPositions3D, out int pointCount)
	{
		FillPointData_00004E79$BurstDirectCall.Invoke(in pointIndexOffset, ref pointPositionArray, ref pointPositionUVArray, in rootToWorld, ref pointData, in deepSeaBounds, in terrainPosition, in terrainOneOverSize, in isDeepSea, ref allPositions3D, out pointCount);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void FillPointData$BurstManaged(in int pointIndexOffset, ref NativeArray<Vector2> pointPositionArray, ref NativeArray<Vector2> pointPositionUVArray, in Matrix4x4 rootToWorld, ref NativeArray<Buoyancy.BuoyancyPointData> pointData, in Bounds deepSeaBounds, in Vector3 terrainPosition, in Vector3 terrainOneOverSize, in bool isDeepSea, ref NativeArray<Vector3> allPositions3D, out int pointCount)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		float x;
		float z;
		float x2;
		float z2;
		if (isDeepSea)
		{
			Bounds val = deepSeaBounds;
			x = ((Bounds)(ref val)).min.x;
			val = deepSeaBounds;
			z = ((Bounds)(ref val)).min.z;
			val = deepSeaBounds;
			x2 = Vector3Ex.Inverse(((Bounds)(ref val)).size).x;
			val = deepSeaBounds;
			z2 = Vector3Ex.Inverse(((Bounds)(ref val)).size).z;
		}
		else
		{
			x = terrainPosition.x;
			z = terrainPosition.z;
			x2 = terrainOneOverSize.x;
			z2 = terrainOneOverSize.z;
		}
		for (int i = 0; i < pointData.Length; i++)
		{
			Matrix4x4 val2 = rootToWorld;
			Vector3 val3 = ((Matrix4x4)(ref val2)).MultiplyPoint3x4(pointData[i].rootToPoint);
			float num = (val3.x - x) * x2;
			float num2 = (val3.z - z) * z2;
			pointPositionArray[i + pointIndexOffset] = new Vector2(val3.x, val3.z);
			pointPositionUVArray[i + pointIndexOffset] = new Vector2(num, num2);
			allPositions3D[i + pointIndexOffset] = val3;
		}
		pointCount = pointData.Length;
	}
}


using Unity.Collections;
using UnityEngine;

internal delegate void FillPointData_00004E79$PostfixBurstDelegate(in int pointIndexOffset, ref NativeArray<Vector2> pointPositionArray, ref NativeArray<Vector2> pointPositionUVArray, in Matrix4x4 rootToWorld, ref NativeArray<Buoyancy.BuoyancyPointData> pointData, in Bounds deepSeaBounds, in Vector3 terrainPosition, in Vector3 terrainOneOverSize, in bool isDeepSea, ref NativeArray<Vector3> allPositions3D, out int pointCount);


using System;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

internal static class FillPointData_00004E79$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(FillPointData_00004E79$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static FillPointData_00004E79$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in int pointIndexOffset, ref NativeArray<Vector2> pointPositionArray, ref NativeArray<Vector2> pointPositionUVArray, in Matrix4x4 rootToWorld, ref NativeArray<Buoyancy.BuoyancyPointData> pointData, in Bounds deepSeaBounds, in Vector3 terrainPosition, in Vector3 terrainOneOverSize, in bool isDeepSea, ref NativeArray<Vector3> allPositions3D, out int pointCount)
	{
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref int, ref NativeArray<Vector2>, ref NativeArray<Vector2>, ref Matrix4x4, ref NativeArray<Buoyancy.BuoyancyPointData>, ref Bounds, ref Vector3, ref Vector3, ref bool, ref NativeArray<Vector3>, ref int, void>)functionPointer)(ref pointIndexOffset, ref pointPositionArray, ref pointPositionUVArray, ref rootToWorld, ref pointData, ref deepSeaBounds, ref terrainPosition, ref terrainOneOverSize, ref isDeepSea, ref allPositions3D, ref pointCount);
				return;
			}
		}
		FillPointData$BurstManaged(in pointIndexOffset, ref pointPositionArray, ref pointPositionUVArray, in rootToWorld, ref pointData, in deepSeaBounds, in terrainPosition, in terrainOneOverSize, in isDeepSea, ref allPositions3D, out pointCount);
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
public static class BuoyancyForceAccumulationBurst
{
	public struct InstanceInput
	{
		public int pointStartIndex;

		public int pointCount;

		public float buoyancyScale;

		public float rigidBodyMass;

		public float wavesEffect;

		public bool scaleForceWithMass;

		public bool flowForceDisabled;

		public float flowMovementScale;

		public float3 worldCom;
	}

	public struct InstanceOutput
	{
		public float3 netForce;

		public float3 netTorque;

		public int numSubmerged;
	}

	internal delegate void Compute_00004E7B$PostfixBurstDelegate(in NativeArray<InstanceInput> instances, in NativeArray<float3> allPositions3D, in NativeArray<float> pointShoreDistance, in NativeArray<WaterLevel.WaterInfo> pointWaterInfo, in NativeArray<float> pointSize, in NativeArray<float> pointBuoyancyForce, in NativeArray<float> pointRandomOffset, in NativeArray<float> pointWaveFrequency, in NativeArray<float> pointWaveScale, in NativeArray<float3> pointFlowDirection, float time, ref NativeArray<InstanceOutput> results);

	internal static class Compute_00004E7B$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Compute_00004E7B$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static Compute_00004E7B$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in NativeArray<InstanceInput> instances, in NativeArray<float3> allPositions3D, in NativeArray<float> pointShoreDistance, in NativeArray<WaterLevel.WaterInfo> pointWaterInfo, in NativeArray<float> pointSize, in NativeArray<float> pointBuoyancyForce, in NativeArray<float> pointRandomOffset, in NativeArray<float> pointWaveFrequency, in NativeArray<float> pointWaveScale, in NativeArray<float3> pointFlowDirection, float time, ref NativeArray<InstanceOutput> results)
		{
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref NativeArray<InstanceInput>, ref NativeArray<float3>, ref NativeArray<float>, ref NativeArray<WaterLevel.WaterInfo>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float3>, float, ref NativeArray<InstanceOutput>, void>)functionPointer)(ref instances, ref allPositions3D, ref pointShoreDistance, ref pointWaterInfo, ref pointSize, ref pointBuoyancyForce, ref pointRandomOffset, ref pointWaveFrequency, ref pointWaveScale, ref pointFlowDirection, time, ref results);
					return;
				}
			}
			Compute$BurstManaged(in instances, in allPositions3D, in pointShoreDistance, in pointWaterInfo, in pointSize, in pointBuoyancyForce, in pointRandomOffset, in pointWaveFrequency, in pointWaveScale, in pointFlowDirection, time, ref results);
		}
	}

	[BurstCompile]
	public static void Compute(in NativeArray<InstanceInput> instances, in NativeArray<float3> allPositions3D, in NativeArray<float> pointShoreDistance, in NativeArray<WaterLevel.WaterInfo> pointWaterInfo, in NativeArray<float> pointSize, in NativeArray<float> pointBuoyancyForce, in NativeArray<float> pointRandomOffset, in NativeArray<float> pointWaveFrequency, in NativeArray<float> pointWaveScale, in NativeArray<float3> pointFlowDirection, float time, ref NativeArray<InstanceOutput> results)
	{
		Compute_00004E7B$BurstDirectCall.Invoke(in instances, in allPositions3D, in pointShoreDistance, in pointWaterInfo, in pointSize, in pointBuoyancyForce, in pointRandomOffset, in pointWaveFrequency, in pointWaveScale, in pointFlowDirection, time, ref results);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void Compute$BurstManaged(in NativeArray<InstanceInput> instances, in NativeArray<float3> allPositions3D, in NativeArray<float> pointShoreDistance, in NativeArray<WaterLevel.WaterInfo> pointWaterInfo, in NativeArray<float> pointSize, in NativeArray<float> pointBuoyancyForce, in NativeArray<float> pointRandomOffset, in NativeArray<float> pointWaveFrequency, in NativeArray<float> pointWaveScale, in NativeArray<float3> pointFlowDirection, float time, ref NativeArray<InstanceOutput> results)
	{
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		float3 val4 = default(float3);
		for (int i = 0; i < instances.Length; i++)
		{
			InstanceInput instanceInput = instances[i];
			int pointStartIndex = instanceInput.pointStartIndex;
			int pointCount = instanceInput.pointCount;
			float wavesEffect = instanceInput.wavesEffect;
			bool flag = wavesEffect < 1f;
			float3 worldCom = instanceInput.worldCom;
			float3 val = float3.zero;
			float3 val2 = float3.zero;
			int num = 0;
			for (int j = 0; j < pointCount; j++)
			{
				int num2 = pointStartIndex + j;
				float3 val3 = allPositions3D[num2];
				WaterLevel.WaterInfo waterInfo = pointWaterInfo[num2];
				if (!waterInfo.isValid)
				{
					continue;
				}
				float surfaceLevel = waterInfo.surfaceLevel;
				float num3 = waterInfo.currentDepth;
				if (flag)
				{
					num3 = math.lerp(num3, surfaceLevel - val3.y, wavesEffect);
				}
				if (val3.y >= surfaceLevel)
				{
					continue;
				}
				num++;
				float num4 = pointSize[num2];
				float num5 = pointBuoyancyForce[num2];
				float num6 = pointRandomOffset[num2];
				float num7 = pointWaveFrequency[num2];
				float num8 = pointWaveScale[num2];
				float num9 = math.saturate(math.unlerp(0f, num4, num3));
				float num10 = 1f + Mathf.PerlinNoise(num6 + time * num7, 0f) * num8;
				float num11 = num5 * instanceInput.buoyancyScale;
				if (instanceInput.scaleForceWithMass)
				{
					num11 *= instanceInput.rigidBodyMass;
				}
				((float3)(ref val4))..ctor(0f, num10 * num9 * num11, 0f);
				if (!waterInfo.artificalWater && !instanceInput.flowForceDisabled && (waterInfo.topology & 0x10000) == 0)
				{
					float num12 = math.abs(pointShoreDistance[num2]);
					float num13 = math.saturate(math.unlerp(60f, 0f, num12));
					if (num13 > 1E-06f)
					{
						num13 = math.pow(num13, 0.5f);
						float3 val5 = pointFlowDirection[num2];
						float2 xz = ((float3)(ref val5)).xz;
						float num14 = num11 * 0.025f * num13 * instanceInput.flowMovementScale;
						val4.x += xz.x * num14;
						val4.z += xz.y * num14;
					}
				}
				val += val4;
				val2 += math.cross(val3 - worldCom, val4);
			}
			results[i] = new InstanceOutput
			{
				netForce = val,
				netTorque = val2,
				numSubmerged = num
			};
		}
	}
}


using Unity.Mathematics;

public struct InstanceInput
{
	public int pointStartIndex;

	public int pointCount;

	public float buoyancyScale;

	public float rigidBodyMass;

	public float wavesEffect;

	public bool scaleForceWithMass;

	public bool flowForceDisabled;

	public float flowMovementScale;

	public float3 worldCom;
}


using Unity.Mathematics;

public struct InstanceOutput
{
	public float3 netForce;

	public float3 netTorque;

	public int numSubmerged;
}


using Unity.Collections;
using Unity.Mathematics;

internal delegate void Compute_00004E7B$PostfixBurstDelegate(in NativeArray<InstanceInput> instances, in NativeArray<float3> allPositions3D, in NativeArray<float> pointShoreDistance, in NativeArray<WaterLevel.WaterInfo> pointWaterInfo, in NativeArray<float> pointSize, in NativeArray<float> pointBuoyancyForce, in NativeArray<float> pointRandomOffset, in NativeArray<float> pointWaveFrequency, in NativeArray<float> pointWaveScale, in NativeArray<float3> pointFlowDirection, float time, ref NativeArray<InstanceOutput> results);


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Mathematics;

internal static class Compute_00004E7B$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(Compute_00004E7B$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static Compute_00004E7B$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in NativeArray<InstanceInput> instances, in NativeArray<float3> allPositions3D, in NativeArray<float> pointShoreDistance, in NativeArray<WaterLevel.WaterInfo> pointWaterInfo, in NativeArray<float> pointSize, in NativeArray<float> pointBuoyancyForce, in NativeArray<float> pointRandomOffset, in NativeArray<float> pointWaveFrequency, in NativeArray<float> pointWaveScale, in NativeArray<float3> pointFlowDirection, float time, ref NativeArray<InstanceOutput> results)
	{
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref NativeArray<InstanceInput>, ref NativeArray<float3>, ref NativeArray<float>, ref NativeArray<WaterLevel.WaterInfo>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float3>, float, ref NativeArray<InstanceOutput>, void>)functionPointer)(ref instances, ref allPositions3D, ref pointShoreDistance, ref pointWaterInfo, ref pointSize, ref pointBuoyancyForce, ref pointRandomOffset, ref pointWaveFrequency, ref pointWaveScale, ref pointFlowDirection, time, ref results);
				return;
			}
		}
		Compute$BurstManaged(in instances, in allPositions3D, in pointShoreDistance, in pointWaterInfo, in pointSize, in pointBuoyancyForce, in pointRandomOffset, in pointWaveFrequency, in pointWaveScale, in pointFlowDirection, time, ref results);
	}
}


using System;
using UnityEngine;

public class BuoyancyPoint : MonoBehaviour
{
	public float buoyancyForce = 10f;

	public float size = 0.1f;

	public float waveScale = 0.2f;

	public float waveFrequency = 1f;

	public bool doSplashEffects = true;

	[NonSerialized]
	public float randomOffset;

	[NonSerialized]
	public bool wasSubmergedLastFrame;

	[NonSerialized]
	public float nexSplashTime;

	private static readonly Color gizmoColour = new Color(1f, 0f, 0f, 0.25f);

	public void Start()
	{
		randomOffset = Random.Range(0f, 20f);
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = gizmoColour;
		Gizmos.DrawSphere(((Component)this).transform.position, size * 0.5f);
	}
}


using UnityEngine;

public class KayakSeat : BaseVehicleSeat
{
	public ItemDefinition PaddleItem;

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerMounted();
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerDismounted(player);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RHIBAIController : FacepunchBehaviour
{
	public List<Vector3> nodes = new List<Vector3>();

	[ContextMenu("Calculate Path")]
	public void SetupPatrolPath()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		nodes = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			nodes.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 2f;
		float num8 = 200f;
		float num9 = 150f;
		float num10 = 8f;
		bool flag = true;
		int num11 = 1;
		float num12 = 20f;
		Vector3[] array = (Vector3[])(object)new Vector3[5]
		{
			new Vector3(0f, 0f, 0f),
			new Vector3(num12, 0f, 0f),
			new Vector3(0f - num12, 0f, 0f),
			new Vector3(0f, 0f, num12),
			new Vector3(0f, 0f, 0f - num12)
		};
		RaycastHit val9 = default(RaycastHit);
		while (flag)
		{
			Debug.Log((object)("Loop # :" + num11));
			num11++;
			flag = false;
			for (int j = 0; j < num3; j++)
			{
				Vector3 val = nodes[j];
				int index = ((j == 0) ? (num3 - 1) : (j - 1));
				int index2 = ((j != num3 - 1) ? (j + 1) : 0);
				Vector3 val2 = nodes[index2];
				Vector3 val3 = nodes[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				for (int k = 0; k < array.Length; k++)
				{
					Vector3 val7 = val6 + array[k];
					if (GetWaterDepth(val7) < num10)
					{
						flag2 = false;
					}
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val4;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.Raycast(val4, val8, ref val9, num9, 1218511105))
					{
						flag2 = false;
					}
				}
				if (flag2)
				{
					flag = true;
					nodes[j] = val6;
				}
			}
		}
		List<int> list = new List<int>();
		LineUtility.Simplify(nodes, 15f, list);
		List<Vector3> list2 = nodes;
		nodes = new List<Vector3>();
		foreach (int item in list)
		{
			nodes.Add(list2[item]);
		}
	}

	public float GetWaterDepth(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(pos, Vector3.down, ref val, 100f, 8388608))
		{
			return 100f;
		}
		return ((RaycastHit)(ref val)).distance;
	}

	public void OnDrawGizmosSelected()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.Path.OceanPatrolClose != null)
		{
			for (int i = 0; i < TerrainMeta.Path.OceanPatrolClose.Count; i++)
			{
				Vector3 val = TerrainMeta.Path.OceanPatrolClose[i];
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(val, 3f);
				Vector3 val2 = ((i + 1 == TerrainMeta.Path.OceanPatrolClose.Count) ? TerrainMeta.Path.OceanPatrolClose[0] : TerrainMeta.Path.OceanPatrolClose[i + 1]);
				Gizmos.DrawLine(val, val2);
			}
		}
	}
}


using UnityEngine;

public class TugboatInteriorSoundTrigger : MonoBehaviour, IClientComponent
{
	public TugboatSounds tugboatSounds;

	public bool bridge;
}


using UnityEngine;

public class TugboatSounds : MonoBehaviour, IClientComponent
{
	[SerializeField]
	private Tugboat tugboat;

	[SerializeField]
	private float roughHalfWidth = 5f;

	[SerializeField]
	private float roughHalfLength = 10f;

	private float soundCullDistanceSq;

	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineLoopDef;

	private Sound engineLoop;

	private SoundModulation.Modulator engineGainMod;

	private SoundModulation.Modulator enginePitchMod;

	[SerializeField]
	private SoundDefinition engineStartDef;

	[SerializeField]
	private SoundDefinition engineStartBridgeDef;

	[SerializeField]
	private SoundDefinition engineStopDef;

	[SerializeField]
	private SoundDefinition engineStopBridgeDef;

	[SerializeField]
	private float engineGainChangeRate = 1f;

	[SerializeField]
	private float enginePitchChangeRate = 0.5f;

	[SerializeField]
	private Transform engineTransform;

	[SerializeField]
	private Transform bridgeControlsTransform;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterIdleDef;

	[SerializeField]
	private SoundDefinition waterSideMovementSlowDef;

	[SerializeField]
	private SoundDefinition waterSideMovementFastDef;

	[SerializeField]
	private SoundDefinition waterSternMovementDef;

	[SerializeField]
	private SoundDefinition waterInteriorIdleDef;

	[SerializeField]
	private SoundDefinition waterInteriorDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private float waterMovementGainChangeRate = 0.5f;

	[SerializeField]
	private AnimationCurve waterDistanceGainCurve;

	private Sound leftWaterSound;

	private SoundModulation.Modulator leftWaterGainMod;

	private Sound rightWaterSound;

	private SoundModulation.Modulator rightWaterGainMod;

	private Sound sternWaterSound;

	private SoundModulation.Modulator sternWaterGainMod;

	[SerializeField]
	private Transform wakeTransform;

	[SerializeField]
	private Vector3 sideSoundLineStern;

	[SerializeField]
	private Vector3 sideSoundLineBow;

	[Header("Ambient")]
	[SerializeField]
	private SoundDefinition ambientActiveLoopDef;

	private Sound ambientActiveSound;

	[SerializeField]
	private SoundDefinition hullGroanDef;

	[SerializeField]
	private float hullGroanCooldown = 1f;

	private float lastHullGroan;

	[SerializeField]
	private SoundDefinition chainRattleDef;

	[SerializeField]
	private float chainRattleCooldown = 1f;

	[SerializeField]
	private Transform[] chainRattleLocations;

	[SerializeField]
	private float chainRattleAngleDeltaThreshold = 1f;

	private float lastChainRattle;

	[Header("Horn")]
	[SerializeField]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	[SerializeField]
	private SoundDefinition hornStop;

	[SerializeField]
	[Min(0f)]
	[Tooltip("The maximum amount of time a looped horn can last. If 0s then this is ignored.")]
	private float maxHornTime;

	[Tooltip("Used for rate limiting. This defines the maximum number of horn spams that can be invoked one after another.")]
	[Min(0f)]
	[SerializeField]
	private int hornTokenCapacity = 3;

	[SerializeField]
	[Min(0f)]
	[Tooltip("Used for rate limiting. This defines how quickly a new token regenerates, permitting another horn honk.")]
	private float hornTokenRegenerationTime = 1f;

	private Line leftSoundLine;

	private Line rightSoundLine;

	[Header("Runtime")]
	public bool engineOn;

	public bool throttleOn;

	public bool inWater = true;
}


using System;
using UnityEngine;

[Serializable]
public class CarSettings
{
	[Header("Vehicle Setup")]
	[Range(0f, 1f)]
	public float rollingResistance = 0.05f;

	[Range(0f, 1f)]
	public float antiRoll;

	public bool canSleep = true;

	public bool kinematicWhileAsleep;

	[Header("Wheels")]
	public bool tankSteering;

	[Range(0f, 50f)]
	public float maxSteerAngle = 35f;

	public bool steeringAssist = true;

	[Range(0f, 1f)]
	public float steeringAssistRatio = 0.5f;

	public bool steeringLimit;

	[Range(0f, 50f)]
	public float minSteerLimitAngle = 6f;

	[Range(10f, 50f)]
	public float minSteerLimitSpeed = 30f;

	[Range(0f, 1f)]
	public float rearWheelSteer = 1f;

	public float steerMinLerpSpeed = 75f;

	public float steerMaxLerpSpeed = 150f;

	public float steerReturnLerpSpeed = 200f;

	public bool retainLerpSpeed;

	[Header("Motor")]
	public float maxDriveSlip = 4f;

	public float driveForceToMaxSlip = 1000f;

	public float reversePercentSpeed = 0.3f;

	[Header("Brakes")]
	public float brakeForceMultiplier = 1000f;

	public bool disableHandbrakes;

	[Range(0f, 1f)]
	[Header("Front/Rear Vehicle Balance")]
	public float handlingBias = 0.5f;
}


using System;
using UnityEngine;

[Serializable]
public class CarWheel
{
	public WheelCollider wheelCollider;

	[Range(0.0001f, 3f)]
	public float tyreFriction = 1f;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using System;
using ConVar;
using UnityEngine;

public class CarPhysics<TCar> where TCar : BaseVehicle, CarPhysics<TCar>.ICar
{
	public interface ICar
	{
		VehicleTerrainHandler.Surface OnSurface { get; }

		float GetThrottleInput();

		float GetBrakeInput();

		float GetSteerInput();

		bool GetSteerSpeedMod(float speed);

		float GetSteerMaxMult(float speed);

		float GetMaxForwardSpeed();

		float GetMaxDriveForce();

		float GetAdjustedDriveForce(float absSpeed, float topSpeed);

		float GetModifiedDrag();

		CarWheel[] GetWheels();

		float GetWheelsMidPos();
	}

	private class ServerWheelData
	{
		public CarWheel wheel;

		public Transform wheelColliderTransform;

		public WheelCollider wheelCollider;

		public bool isGrounded;

		public float downforce;

		public float forceDistance;

		public WheelHit hit;

		public Vector2 localRigForce;

		public Vector2 localVelocity;

		public float angularVelocity;

		public Vector3 origin;

		public Vector2 tyreForce;

		public Vector2 tyreSlip;

		public Vector3 velocity;

		public bool isBraking;

		public bool hasThrottleInput;

		public bool isFrontWheel;

		public bool isLeftWheel;
	}

	private readonly ServerWheelData[] wheelData;

	private readonly TCar car;

	private readonly Transform transform;

	private readonly Rigidbody rBody;

	private readonly CarSettings vehicleSettings;

	private float speedAngle;

	private bool wasSleeping = true;

	private bool hasDriver;

	private bool hadDriver;

	private float steerLerpSpeed;

	public float lastMovingTime = float.MinValue;

	private WheelFrictionCurve zeroFriction;

	private Vector3 prevLocalCOM;

	private readonly float midWheelPos;

	private const bool WHEEL_HIT_CORRECTION = true;

	private const float SLEEP_SPEED = 0.25f;

	private const float SLEEP_DELAY = 10f;

	private const float AIR_DRAG = 0.25f;

	private const float DEFAULT_GROUND_GRIP = 0.75f;

	private const float ROAD_GROUND_GRIP = 1f;

	private const float ICE_GROUND_GRIP = 0.25f;

	private bool slowSpeedExitFlag;

	private const float SLOW_SPEED_EXIT_SPEED = 4f;

	public TimeSince timeSinceWaterCheck;

	public float DriveWheelVelocity { get; private set; }

	public float DriveWheelSlip { get; private set; }

	public float SteerAngle { get; private set; }

	public float TankThrottleLeft { get; private set; }

	public float TankThrottleRight { get; private set; }

	private bool InSlowSpeedExitMode
	{
		get
		{
			if (!hasDriver)
			{
				return slowSpeedExitFlag;
			}
			return false;
		}
	}

	public CarPhysics(TCar car, Transform transform, Rigidbody rBody, CarSettings vehicleSettings)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve val = default(WheelFrictionCurve);
		((WheelFrictionCurve)(ref val)).stiffness = 0f;
		zeroFriction = val;
		Transform transform2 = transform;
		base..ctor();
		CarPhysics<TCar> carPhysics = this;
		this.car = car;
		this.transform = transform2;
		this.rBody = rBody;
		this.vehicleSettings = vehicleSettings;
		timeSinceWaterCheck = default(TimeSince);
		timeSinceWaterCheck = TimeSince.op_Implicit(float.MaxValue);
		prevLocalCOM = rBody.centerOfMass;
		CarWheel[] wheels = car.GetWheels();
		wheelData = new ServerWheelData[wheels.Length];
		for (int i = 0; i < wheelData.Length; i++)
		{
			wheelData[i] = AddWheel(wheels[i]);
		}
		midWheelPos = car.GetWheelsMidPos();
		wheelData[0].wheel.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
		lastMovingTime = Time.realtimeSinceStartup;
		ServerWheelData AddWheel(CarWheel wheel)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			ServerWheelData obj = new ServerWheelData
			{
				wheelCollider = wheel.wheelCollider,
				wheelColliderTransform = ((Component)wheel.wheelCollider).transform,
				forceDistance = GetWheelForceDistance(wheel.wheelCollider),
				wheel = wheel
			};
			obj.wheelCollider.sidewaysFriction = zeroFriction;
			obj.wheelCollider.forwardFriction = zeroFriction;
			Vector3 val2 = transform2.InverseTransformPoint(((Component)wheel.wheelCollider).transform.position);
			obj.isFrontWheel = val2.z > 0f;
			obj.isLeftWheel = val2.x < 0f;
			return obj;
		}
	}

	public void FixedUpdate(float dt, float speed)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0479: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CarPhysics.FixedUpdate", 0);
		try
		{
			if (rBody.centerOfMass != prevLocalCOM)
			{
				COMChanged();
			}
			float num = Mathf.Abs(speed);
			hasDriver = car.HasDriver();
			if (!hasDriver && hadDriver)
			{
				if (num <= 4f)
				{
					slowSpeedExitFlag = true;
				}
			}
			else if (hasDriver && !hadDriver)
			{
				slowSpeedExitFlag = false;
			}
			if ((hasDriver || !vehicleSettings.canSleep) && rBody.IsSleeping())
			{
				rBody.WakeUp();
				if (vehicleSettings.kinematicWhileAsleep)
				{
					rBody.isKinematic = false;
				}
			}
			Vector3 val2;
			if (!rBody.IsSleeping())
			{
				if ((!wasSleeping || rBody.isKinematic) && !(num > 0.25f))
				{
					val2 = rBody.angularVelocity;
					if (!(Mathf.Abs(((Vector3)(ref val2)).magnitude) > 0.25f))
					{
						goto IL_011c;
					}
				}
				lastMovingTime = Time.time;
				goto IL_011c;
			}
			wasSleeping = true;
			goto IL_0625;
			IL_0615:
			wasSleeping = false;
			goto IL_0625;
			IL_044a:
			int num2;
			bool flag = (byte)num2 != 0;
			float num3;
			bool flag2 = !vehicleSettings.disableHandbrakes && !flag && num3 == 0f && num < 0.2f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f && car.OnSurface != VehicleTerrainHandler.Surface.Frictionless;
			int num4;
			float num5;
			for (int i = 0; i < wheelData.Length; i++)
			{
				ServerWheelData serverWheelData = wheelData[i];
				if (!((Collider)serverWheelData.wheelCollider).enabled)
				{
					((Collider)serverWheelData.wheelCollider).enabled = true;
					serverWheelData.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
				}
				serverWheelData.wheelCollider.motorTorque = 1E-05f;
				if (flag)
				{
					serverWheelData.wheelCollider.brakeTorque = 10000f;
				}
				else if (flag2)
				{
					serverWheelData.wheelCollider.brakeTorque = 1000f;
				}
				else
				{
					serverWheelData.wheelCollider.brakeTorque = 0f;
				}
				if (serverWheelData.wheel.steerWheel)
				{
					serverWheelData.wheel.wheelCollider.steerAngle = (serverWheelData.isFrontWheel ? SteerAngle : (vehicleSettings.rearWheelSteer * (0f - SteerAngle)));
				}
				UpdateSuspension(serverWheelData);
				if (serverWheelData.isGrounded)
				{
					num4++;
					num5 += wheelData[i].downforce;
				}
			}
			AdjustHitForces(num4, num5 / (float)num4);
			float maxForwardSpeed;
			float brakeInput;
			float num6;
			float maxDriveForce;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData wd = wheelData[j];
				UpdateLocalFrame(wd, dt);
				ComputeTyreForces(wd, speed, maxDriveForce, maxForwardSpeed, num3, brakeInput, num6);
				ApplyTyreForces(wd);
			}
			ComputeOverallForces();
			goto IL_0615;
			IL_0625:
			hadDriver = hasDriver;
			return;
			IL_011c:
			bool flag3 = vehicleSettings.canSleep && !hasDriver && Time.time > lastMovingTime + 10f;
			if (flag3 && (car.GetParentEntity() as BaseVehicle).IsValid())
			{
				flag3 = false;
			}
			if (flag3)
			{
				for (int k = 0; k < wheelData.Length; k++)
				{
					ServerWheelData serverWheelData2 = wheelData[k];
					serverWheelData2.wheelCollider.motorTorque = 0f;
					serverWheelData2.wheelCollider.brakeTorque = 0f;
					serverWheelData2.wheelCollider.steerAngle = 0f;
					if (vehicle.disable_wheels_when_sleeping)
					{
						((Collider)serverWheelData2.wheelCollider).enabled = false;
					}
				}
				rBody.Sleep();
				if (vehicleSettings.kinematicWhileAsleep)
				{
					rBody.isKinematic = true;
				}
				goto IL_0615;
			}
			speedAngle = Vector3.Angle(rBody.velocity, transform.forward) * Mathf.Sign(Vector3.Dot(rBody.velocity, transform.right));
			maxDriveForce = car.GetMaxDriveForce();
			maxForwardSpeed = car.GetMaxForwardSpeed();
			num3 = (car.IsOn() ? car.GetThrottleInput() : 0f);
			float steerInput = car.GetSteerInput();
			brakeInput = (InSlowSpeedExitMode ? 1f : car.GetBrakeInput());
			num6 = 1f;
			if (num < 3f)
			{
				num6 = 2.75f;
			}
			else if (num < 9f)
			{
				float num7 = Mathf.InverseLerp(9f, 3f, num);
				num6 = Mathf.Lerp(1f, 2.75f, num7);
			}
			maxDriveForce *= num6;
			ComputeSteerAngle(num3, steerInput, dt, speed);
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > 0.25f)
			{
				float num8 = car.WaterFactor();
				float num9 = 0f;
				if (car.FindTrigger<TriggerVehicleDrag>(out var result))
				{
					num9 = result.vehicleDrag;
				}
				float num10 = ((num3 != 0f) ? 0f : 0.25f);
				float num11 = Mathf.Max(num8, num9);
				num11 = Mathf.Max(num11, car.GetModifiedDrag());
				rBody.drag = Mathf.Max(num10, num11);
				rBody.angularDrag = num11 * 0.5f;
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
			num4 = 0;
			num5 = 0f;
			if (!vehicleSettings.disableHandbrakes)
			{
				if (!hasDriver)
				{
					val2 = rBody.velocity;
					if (((Vector3)(ref val2)).magnitude < 2.5f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f)
					{
						num2 = ((car.OnSurface != VehicleTerrainHandler.Surface.Frictionless) ? 1 : 0);
						goto IL_044a;
					}
				}
				num2 = 0;
			}
			else
			{
				num2 = 0;
			}
			goto IL_044a;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsGrounded()
	{
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].isGrounded)
			{
				num++;
			}
			if (num >= Mathf.FloorToInt((float)wheelData.Length * 0.5f))
			{
				return true;
			}
		}
		return false;
	}

	public bool IsWheelGrounded(int index)
	{
		if (index < 0 || index >= wheelData.Length)
		{
			return false;
		}
		return wheelData[index].isGrounded;
	}

	public bool HasHandbrake()
	{
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].wheelCollider.brakeTorque != 10000f)
			{
				return false;
			}
		}
		return true;
	}

	private void COMChanged()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			serverWheelData.forceDistance = GetWheelForceDistance(serverWheelData.wheel.wheelCollider);
		}
		prevLocalCOM = rBody.centerOfMass;
	}

	private void ComputeSteerAngle(float throttleInput, float steerInput, float dt, float speed)
	{
		if (vehicleSettings.tankSteering)
		{
			SteerAngle = 0f;
			ComputeTankSteeringThrottle(throttleInput, steerInput, speed);
			return;
		}
		float num = vehicleSettings.maxSteerAngle * steerInput;
		float num2 = Mathf.InverseLerp(0f, vehicleSettings.minSteerLimitSpeed, speed);
		if (vehicleSettings.steeringLimit)
		{
			float num3 = vehicleSettings.maxSteerAngle * car.GetSteerMaxMult(speed);
			float num4 = vehicleSettings.minSteerLimitAngle * car.GetSteerMaxMult(speed);
			float num5 = Mathf.Lerp(num3, num4, num2);
			num = Mathf.Clamp(num, 0f - num5, num5);
		}
		float num6 = 0f;
		if (vehicleSettings.steeringAssist)
		{
			float num7 = Mathf.InverseLerp(0.1f, 3f, speed);
			num6 = speedAngle * vehicleSettings.steeringAssistRatio * num7 * Mathf.InverseLerp(2f, 3f, Mathf.Abs(speedAngle));
		}
		float num8 = Mathf.Clamp(num + num6, 0f - vehicleSettings.maxSteerAngle, vehicleSettings.maxSteerAngle);
		if (SteerAngle == num8)
		{
			steerLerpSpeed = 0f;
			return;
		}
		float num9 = Mathf.Abs(SteerAngle / num8);
		float num10 = 1f - num2 * 0.7f;
		bool steerSpeedMod = car.GetSteerSpeedMod(speed);
		if ((SteerAngle == 0f || Mathf.Sign(num8) == Mathf.Sign(SteerAngle)) && Mathf.Abs(num8) > Mathf.Abs(SteerAngle))
		{
			float num11 = SteerAngle / vehicleSettings.maxSteerAngle;
			float num12 = vehicleSettings.steerMinLerpSpeed;
			if (steerSpeedMod)
			{
				num12 *= 1.8f;
			}
			float num13 = Mathf.Lerp(num12 * num10, vehicleSettings.steerMaxLerpSpeed * num10, num11 * num11);
			if (Mathf.Abs(num8) > Mathf.Abs(SteerAngle) && num9 > 0.85f)
			{
				num13 = Mathf.Lerp(num13, 0f, num9);
			}
			if (!vehicleSettings.retainLerpSpeed || num13 > steerLerpSpeed)
			{
				steerLerpSpeed = num13;
			}
		}
		else
		{
			float num14 = vehicleSettings.steerReturnLerpSpeed;
			if (num8 != 0f && Mathf.Sign(num8) != Mathf.Sign(SteerAngle))
			{
				num14 *= 1.33f;
			}
			if (steerSpeedMod)
			{
				num14 *= 1.5f;
			}
			steerLerpSpeed = num14 * num10;
		}
		if (steerSpeedMod)
		{
			steerLerpSpeed *= 1.2f;
		}
		SteerAngle = Mathf.MoveTowards(SteerAngle, num8, dt * steerLerpSpeed);
	}

	private float GetWheelForceDistance(WheelCollider col)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		return rBody.centerOfMass.y - transform.InverseTransformPoint(((Component)col).transform.position).y + col.radius + (1f - col.suspensionSpring.targetPosition) * col.suspensionDistance;
	}

	private void UpdateSuspension(ServerWheelData wd)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		wd.isGrounded = wd.wheelCollider.GetGroundHit(ref wd.hit);
		wd.origin = wd.wheelColliderTransform.TransformPoint(wd.wheelCollider.center);
		if (wd.isGrounded && GamePhysics.Trace(new Ray(wd.origin, -wd.wheelColliderTransform.up), 0f, out var hitInfo, wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius, 1235321089, (QueryTriggerInteraction)1))
		{
			((WheelHit)(ref wd.hit)).point = ((RaycastHit)(ref hitInfo)).point;
			((WheelHit)(ref wd.hit)).normal = ((RaycastHit)(ref hitInfo)).normal;
		}
		if (wd.isGrounded)
		{
			if (((WheelHit)(ref wd.hit)).force < 0f)
			{
				((WheelHit)(ref wd.hit)).force = 0f;
			}
			wd.downforce = ((WheelHit)(ref wd.hit)).force;
		}
		else
		{
			wd.downforce = 0f;
		}
	}

	private void AdjustHitForces(int groundedWheels, float neutralForcePerWheel)
	{
		float num = neutralForcePerWheel * 0.25f;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (!serverWheelData.isGrounded || !(serverWheelData.downforce < num))
			{
				continue;
			}
			if (groundedWheels == 1)
			{
				serverWheelData.downforce = num;
				continue;
			}
			float num2 = (num - serverWheelData.downforce) / (float)(groundedWheels - 1);
			serverWheelData.downforce = num;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (serverWheelData2.isGrounded && serverWheelData2.downforce > num)
				{
					float num3 = Mathf.Min(num2, serverWheelData2.downforce - num);
					serverWheelData2.downforce -= num3;
				}
			}
		}
	}

	private void UpdateLocalFrame(ServerWheelData wd, float dt)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		if (!wd.isGrounded)
		{
			((WheelHit)(ref wd.hit)).point = wd.origin - wd.wheelColliderTransform.up * (wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius);
			((WheelHit)(ref wd.hit)).normal = wd.wheelColliderTransform.up;
			((WheelHit)(ref wd.hit)).collider = null;
		}
		Vector3 pointVelocity = rBody.GetPointVelocity(((WheelHit)(ref wd.hit)).point);
		wd.velocity = pointVelocity - Vector3.Project(pointVelocity, ((WheelHit)(ref wd.hit)).normal);
		wd.localVelocity.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, wd.velocity);
		wd.localVelocity.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, wd.velocity);
		if (!wd.isGrounded)
		{
			wd.localRigForce = Vector2.zero;
			return;
		}
		float num = Mathf.InverseLerp(1f, 0.25f, ((Vector3)(ref wd.velocity)).sqrMagnitude);
		Vector2 val3 = default(Vector2);
		if (num > 0f)
		{
			float num2 = Vector3.Dot(Vector3.up, ((WheelHit)(ref wd.hit)).normal);
			Vector3 val2;
			if (num2 > 1E-06f)
			{
				Vector3 val = Vector3.up * wd.downforce / num2;
				val2 = val - Vector3.Project(val, ((WheelHit)(ref wd.hit)).normal);
			}
			else
			{
				val2 = Vector3.up * 100000f;
			}
			val3.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, val2);
			val3.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, val2);
			val3 *= num;
		}
		else
		{
			val3 = Vector2.zero;
		}
		Vector2 val4 = (0f - Mathf.Clamp(wd.downforce / (0f - Physics.gravity.y), 0f, wd.wheelCollider.sprungMass) * 0.5f) * wd.localVelocity / dt;
		wd.localRigForce = val4 + val3;
	}

	private void ComputeTyreForces(ServerWheelData wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float brakeInput, float driveForceMultiplier)
	{
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		float absSpeed = Mathf.Abs(speed);
		if (vehicleSettings.tankSteering && brakeInput == 0f)
		{
			throttleInput = ((!wd.isLeftWheel) ? TankThrottleRight : TankThrottleLeft);
		}
		float num = (wd.wheel.powerWheel ? throttleInput : 0f);
		wd.hasThrottleInput = num != 0f;
		float num2 = vehicleSettings.maxDriveSlip;
		if (Mathf.Sign(num) != Mathf.Sign(wd.localVelocity.y))
		{
			num2 -= wd.localVelocity.y * Mathf.Sign(num);
		}
		float num3 = Mathf.Abs(num);
		float num4 = 0f - vehicleSettings.rollingResistance + num3 * (1f + vehicleSettings.rollingResistance) - brakeInput * (1f - vehicleSettings.rollingResistance);
		if (InSlowSpeedExitMode || num4 < 0f || maxDriveForce == 0f)
		{
			num4 *= -1f;
			wd.isBraking = true;
		}
		else
		{
			num4 *= Mathf.Sign(num);
			wd.isBraking = false;
		}
		float num6;
		if (wd.isBraking)
		{
			float num5 = Mathf.Clamp(car.GetMaxForwardSpeed() * vehicleSettings.brakeForceMultiplier, 10f * vehicleSettings.brakeForceMultiplier, 50f * vehicleSettings.brakeForceMultiplier);
			num5 += rBody.mass * 1.5f;
			num6 = num4 * num5;
		}
		else
		{
			num6 = ComputeDriveForce(speed, absSpeed, num4 * maxDriveForce, maxDriveForce, maxSpeed, driveForceMultiplier);
		}
		if (wd.isGrounded)
		{
			wd.tyreSlip.x = wd.localVelocity.x;
			wd.tyreSlip.y = wd.localVelocity.y - wd.angularVelocity * wd.wheelCollider.radius;
			float num7 = car.OnSurface switch
			{
				VehicleTerrainHandler.Surface.Road => 1f, 
				VehicleTerrainHandler.Surface.Ice => 0.25f, 
				VehicleTerrainHandler.Surface.Frictionless => 0f, 
				_ => 0.75f, 
			};
			float num8 = wd.wheel.tyreFriction * wd.downforce * num7;
			float num9 = 0f;
			if (!wd.isBraking)
			{
				num9 = Mathf.Min(Mathf.Abs(num6 * wd.tyreSlip.x) / num8, num2);
				if (num6 != 0f && num9 < 0.1f)
				{
					num9 = 0.1f;
				}
			}
			if (Mathf.Abs(wd.tyreSlip.y) < num9)
			{
				wd.tyreSlip.y = num9 * Mathf.Sign(wd.tyreSlip.y);
			}
			Vector2 val = (0f - num8) * ((Vector2)(ref wd.tyreSlip)).normalized;
			val.x = Mathf.Abs(val.x) * 1.5f;
			val.y = Mathf.Abs(val.y);
			wd.tyreForce.x = Mathf.Clamp(wd.localRigForce.x, 0f - val.x, val.x);
			if (wd.isBraking)
			{
				float num10 = Mathf.Min(val.y, num6);
				wd.tyreForce.y = Mathf.Clamp(wd.localRigForce.y, 0f - num10, num10);
			}
			else
			{
				wd.tyreForce.y = Mathf.Clamp(num6, 0f - val.y, val.y);
			}
		}
		else
		{
			wd.tyreSlip = Vector2.zero;
			wd.tyreForce = Vector2.zero;
		}
		if (wd.isGrounded)
		{
			float num11;
			if (wd.isBraking)
			{
				num11 = 0f;
			}
			else
			{
				float driveForceToMaxSlip = vehicleSettings.driveForceToMaxSlip;
				num11 = Mathf.Clamp01((Mathf.Abs(num6) - Mathf.Abs(wd.tyreForce.y)) / driveForceToMaxSlip) * num2 * Mathf.Sign(num6);
			}
			wd.angularVelocity = (wd.localVelocity.y + num11) / wd.wheelCollider.radius;
			return;
		}
		float num12 = 50f;
		float num13 = 10f;
		if (num > 0f)
		{
			wd.angularVelocity += num12 * num;
		}
		else
		{
			wd.angularVelocity -= num13;
		}
		wd.angularVelocity -= num12 * brakeInput;
		wd.angularVelocity = Mathf.Clamp(wd.angularVelocity, 0f, maxSpeed / wd.wheelCollider.radius);
	}

	private void ComputeTankSteeringThrottle(float throttleInput, float steerInput, float speed)
	{
		TankThrottleLeft = throttleInput;
		TankThrottleRight = throttleInput;
		float tankSteerInvert = GetTankSteerInvert(throttleInput, speed);
		if (throttleInput == 0f)
		{
			TankThrottleLeft = 0f - steerInput;
			TankThrottleRight = steerInput;
		}
		else if (steerInput > 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, steerInput);
		}
		else if (steerInput < 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, 0f - steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, 0f - steerInput);
		}
	}

	private float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier)
	{
		float num = ((speed >= 0f) ? maxForwardSpeed : (maxForwardSpeed * vehicleSettings.reversePercentSpeed));
		if (absSpeed < num)
		{
			if ((speed >= 0f || demandedForce <= 0f) && (speed <= 0f || demandedForce >= 0f))
			{
				maxForce = car.GetAdjustedDriveForce(absSpeed, maxForwardSpeed) * driveForceMultiplier;
			}
			return Mathf.Clamp(demandedForce, 0f - maxForce, maxForce);
		}
		float num2 = maxForce * Mathf.Max(1f - absSpeed / num, -1f) * Mathf.Sign(speed);
		if ((speed < 0f && demandedForce > 0f) || (speed > 0f && demandedForce < 0f))
		{
			num2 = Mathf.Clamp(num2 + demandedForce, 0f - maxForce, maxForce);
		}
		return num2;
	}

	private void ComputeOverallForces()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		DriveWheelVelocity = 0f;
		DriveWheelSlip = 0f;
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (serverWheelData.wheel.powerWheel)
			{
				DriveWheelVelocity += serverWheelData.angularVelocity;
				if (serverWheelData.isGrounded)
				{
					float num2 = ComputeCombinedSlip(serverWheelData.localVelocity, serverWheelData.tyreSlip);
					DriveWheelSlip += num2;
				}
				num++;
			}
		}
		if (num > 0)
		{
			DriveWheelVelocity /= num;
			DriveWheelSlip /= num;
		}
	}

	private static float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tyreSlip)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float magnitude = ((Vector2)(ref localVelocity)).magnitude;
		if (magnitude > 0.01f)
		{
			float num = tyreSlip.x * localVelocity.x / magnitude;
			float y = tyreSlip.y;
			return Mathf.Sqrt(num * num + y * y);
		}
		return ((Vector2)(ref tyreSlip)).magnitude;
	}

	private void ApplyTyreForces(ServerWheelData wd)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (wd.isGrounded)
		{
			Vector3 val = ((WheelHit)(ref wd.hit)).forwardDir * wd.tyreForce.y;
			Vector3 val2 = ((WheelHit)(ref wd.hit)).sidewaysDir * wd.tyreForce.x;
			Vector3 sidewaysForceAppPoint = GetSidewaysForceAppPoint(wd, ((WheelHit)(ref wd.hit)).point);
			rBody.AddForceAtPosition(val, ((WheelHit)(ref wd.hit)).point, (ForceMode)0);
			rBody.AddForceAtPosition(val2, sidewaysForceAppPoint, (ForceMode)0);
		}
	}

	private Vector3 GetSidewaysForceAppPoint(ServerWheelData wd, Vector3 contactPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = contactPoint + wd.wheelColliderTransform.up * vehicleSettings.antiRoll * wd.forceDistance;
		float num = (wd.wheel.steerWheel ? SteerAngle : 0f);
		if (num != 0f && Mathf.Sign(num) != Mathf.Sign(wd.tyreSlip.x))
		{
			val += wd.wheelColliderTransform.forward * midWheelPos * (vehicleSettings.handlingBias - 0.5f);
		}
		return val;
	}

	private float GetTankSteerInvert(float throttleInput, float speed)
	{
		float result = 1f;
		if (throttleInput < 0f && speed < 1.75f)
		{
			result = -1f;
		}
		else if (throttleInput == 0f && speed < -1f)
		{
			result = -1f;
		}
		else if (speed < -1f)
		{
			result = -1f;
		}
		return result;
	}
}


public interface ICar
{
	VehicleTerrainHandler.Surface OnSurface { get; }

	float GetThrottleInput();

	float GetBrakeInput();

	float GetSteerInput();

	bool GetSteerSpeedMod(float speed);

	float GetSteerMaxMult(float speed);

	float GetMaxForwardSpeed();

	float GetMaxDriveForce();

	float GetAdjustedDriveForce(float absSpeed, float topSpeed);

	float GetModifiedDrag();

	CarWheel[] GetWheels();

	float GetWheelsMidPos();
}


using UnityEngine;

private class ServerWheelData
{
	public CarWheel wheel;

	public Transform wheelColliderTransform;

	public WheelCollider wheelCollider;

	public bool isGrounded;

	public float downforce;

	public float forceDistance;

	public WheelHit hit;

	public Vector2 localRigForce;

	public Vector2 localVelocity;

	public float angularVelocity;

	public Vector3 origin;

	public Vector2 tyreForce;

	public Vector2 tyreSlip;

	public Vector3 velocity;

	public bool isBraking;

	public bool hasThrottleInput;

	public bool isFrontWheel;

	public bool isLeftWheel;
}


using UnityEngine;

public class CrushTrigger : TriggerHurt
{
	public bool includeNPCs = true;

	public bool requireCentreBelowPosition;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!includeNPCs && baseEntity.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	protected override bool CanHurt(BaseCombatEntity ent)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (requireCentreBelowPosition && ent.CenterPoint().y > ((Component)this).transform.position.y)
		{
			return false;
		}
		return base.CanHurt(ent);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DamageRenderer : MonoBehaviour, IClientComponent
{
	[Serializable]
	private struct DamageShowingRenderer
	{
		public Renderer renderer;

		public int[] indices;

		public DamageShowingRenderer(Renderer renderer, int[] indices)
		{
			this.renderer = renderer;
			this.indices = indices;
		}
	}

	[SerializeField]
	private List<Material> damageShowingMats;

	[SerializeField]
	private float maxDamageOpacity = 0.9f;

	[HideInInspector]
	[SerializeField]
	private List<DamageShowingRenderer> damageShowingRenderers;

	[SerializeField]
	[HideInInspector]
	private List<GlassPane> damageShowingGlassRenderers;
}


using System;
using UnityEngine;

[Serializable]
private struct DamageShowingRenderer
{
	public Renderer renderer;

	public int[] indices;

	public DamageShowingRenderer(Renderer renderer, int[] indices)
	{
		this.renderer = renderer;
		this.indices = indices;
	}
}


using UnityEngine;

public class DiverPropulsionVehicleAudio : MonoBehaviour
{
	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[Header("Propeller")]
	[SerializeField]
	private SoundDefinition propellerLoopSoundDef;

	[SerializeField]
	private AnimationCurve propellerPitchCurve;

	[SerializeField]
	private AnimationCurve propellerGainCurve;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition waterMovementLoopDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private SoundDefinition waterSurfaceLoopDef;

	[SerializeField]
	private float surfaceWaterMovementStartDepth = 0.2f;

	[SerializeField]
	private float surfaceWaterMovementEndDepth = 2f;

	[SerializeField]
	private float waterMovementYSpeedScale = 0.2f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class GroundVehicle : BaseVehicle, IEngineControllerUser, IEntity, TriggerHurtNotChild.IHurtTriggerUser
{
	[SerializeField]
	[Header("GroundVehicle")]
	public GroundVehicleAudio gvAudio;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public Transform waterloggedPoint;

	[SerializeField]
	public GameObjectRef collisionEffect;

	[SerializeField]
	public float engineStartupTime = 0.5f;

	[SerializeField]
	private float minCollisionDamageForce = 20000f;

	[SerializeField]
	private float maxCollisionDamageForce = 2500000f;

	[SerializeField]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private Rigidbody secondaryRigidbody;

	public VehicleEngineController<GroundVehicle> engineController;

	private Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float dragMod;

	private float dragModDuration;

	private TimeSince timeSinceDragModSet;

	public Vector3 Velocity { get; protected set; }

	public abstract float DriveWheelVelocity { get; }

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public VehicleEngineController<GroundVehicle>.EngineState CurEngineState => engineController.CurEngineState;

	public override void InitShared()
	{
		base.InitShared();
		CreateEngineController();
	}

	protected virtual void CreateEngineController()
	{
		engineController = new VehicleEngineController<GroundVehicle>(this, CreateFuelSystem(), base.isServer, engineStartupTime, waterloggedPoint);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override float GetSpeed()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStationary())
		{
			return 0f;
		}
		return Vector3.Dot(Velocity, ((Component)this).transform.forward);
	}

	public abstract float GetMaxForwardSpeed();

	public abstract float GetThrottleInput();

	public abstract float GetBrakeInput();

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.isMounted || pusher.IsSwimming())
		{
			return false;
		}
		return !pusher.IsStandingOnEntity(this, 8192);
	}

	protected virtual IFuelSystem CreateFuelSystem()
	{
		return new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceDragModSet = default(TimeSince);
		timeSinceDragModSet = TimeSince.op_Implicit(float.MaxValue);
	}

	public abstract void OnEngineStartFailed();

	public abstract bool MeetsEngineRequirements();

	protected virtual void ServerFlagsChanged(Flags old, Flags next)
	{
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GroundVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.IsMovingOrOn)
			{
				Velocity = GetLocalVelocity();
			}
			else
			{
				Velocity = Vector3.zero;
			}
			if (LightsAreOn && !AnyMounted())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			if (!(Time.time >= nextCollisionDamageTime))
			{
				return;
			}
			nextCollisionDamageTime = Time.time + 0.33f;
			foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
			{
				DoCollisionDamage(item.Key, item.Value);
			}
			damageSinceLastTick.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !hurtEntity.IsDestroyed)
		{
			Vector3 val = hurtEntity.GetLocalVelocity() - Velocity;
			Vector3 val2 = ClosestPoint(((Component)hurtEntity).transform.position);
			Vector3 val3 = Mathf.Min(hurtEntity.RealisticMass, RealisticMass) * val;
			rigidBody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			if ((Object)(object)secondaryRigidbody != (Object)null)
			{
				secondaryRigidbody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			}
			QueueCollisionDamage(this, ((Vector3)(ref val3)).magnitude * 0.1f / Time.deltaTime);
			SetTempDrag(2.25f, 1f);
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		Hurt(damage, DamageType.Collision, this, useProtection: false);
	}

	protected virtual void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		ContactPoint contact = collision.GetContact(0);
		BaseEntity baseEntity = null;
		if ((Object)(object)((ContactPoint)(ref contact)).otherCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).otherCollider.ToBaseEntity();
		}
		else if ((Object)(object)((ContactPoint)(ref contact)).thisCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).thisCollider.ToBaseEntity();
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 impulse = collision.impulse;
			impulse.y *= 0.5f;
			float num = ((Vector3)(ref impulse)).magnitude / Time.fixedDeltaTime;
			if (collision.gameObject.ToBaseEntity() is RidableHorse)
			{
				num *= 0.5f;
			}
			if (QueueCollisionDamage(baseEntity, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public virtual float GetModifiedDrag()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return (1f - Mathf.InverseLerp(0f, dragModDuration, TimeSince.op_Implicit(timeSinceDragModSet))) * dragMod;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController?.FuelSystem;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem()?.CheckNewChild(child);
		}
	}

	private void SetTempDrag(float drag, float duration)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		dragMod = Mathf.Clamp(drag, 0f, 1000f);
		timeSinceDragModSet = TimeSince.op_Implicit(0f);
		dragModDuration = duration;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using UnityEngine;

public abstract class GroundVehicleAudio : MonoBehaviour, IClientComponent
{
	[SerializeField]
	protected GroundVehicle groundVehicle;

	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	protected BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private float overallVolume = 1f;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition waterSplashSoundDef;

	[SerializeField]
	private BlendedSoundLoops waterLoops;

	[SerializeField]
	private float waterSoundsMaxSpeed = 10f;

	[Header("Brakes")]
	[SerializeField]
	private SoundDefinition brakeSoundDef;

	[SerializeField]
	private SoundDefinition brakeStartSoundDef;

	[SerializeField]
	private SoundDefinition brakeStopSoundDef;

	[Header("Lights")]
	[SerializeField]
	protected SoundDefinition lightsToggleSound;
}


using UnityEngine;

public class AttackHeliDriverSeat : BaseVehicleSeat
{
	[SerializeField]
	private Sprite rocketCrosshair;

	[SerializeField]
	private Sprite incendRocketCrosshair;

	[SerializeField]
	private Sprite hvRocketCrosshair;

	[SerializeField]
	private Sprite reloadingCrosshair;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}
}


using UnityEngine;

public class AttackHeliGunnerSeat : BaseVehicleSeat
{
	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}

	public override bool CanHoldItems()
	{
		if ((Object)(object)Owner != (Object)null)
		{
			return !Owner.GunnerIsInGunnerView;
		}
		return false;
	}

	public override Transform GetEyeOverride()
	{
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.gunnerEyePos;
		}
		return base.GetEyeOverride();
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector2 GetPitchClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretPitchClamp;
		}
		return pitchClamp;
	}

	public override Vector2 GetYawClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretYawClamp;
		}
		return yawClamp;
	}
}


using Rust.UI;
using UnityEngine;

public class AttackHeliUIDialog : UIDialog
{
	[Header("Attack Helicopter")]
	[SerializeField]
	private Material compassStripMat;

	[SerializeField]
	private Canvas mainCanvas;

	[SerializeField]
	private CanvasGroup gunCrosshair;

	[SerializeField]
	private CanvasGroup gunNoAmmoCrosshair;

	[SerializeField]
	private CanvasGroup gunCrosshairGhost;

	[SerializeField]
	private RectTransform gunCrosshairGhostRect;

	[SerializeField]
	private Canvas rocketCrosshairDefaultCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairDefaultRect;

	[SerializeField]
	private Canvas rocketCrosshairHVCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairHVRect;

	[SerializeField]
	private Canvas rocketCrosshairIncenCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairIncenRect;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	[SerializeField]
	private CanvasGroup crosshairHitMarkerGroup;

	[SerializeField]
	private RectTransform zoomIndicator;

	[SerializeField]
	private RectTransform positionBox;

	[SerializeField]
	private RustText ammoTextGunMag;

	[SerializeField]
	private RustText ammoTextGunRest;

	[SerializeField]
	private RustText ammoTextRocketMag;

	[SerializeField]
	private RustText ammoTextRocketRest;

	[SerializeField]
	private RustText rangeText;

	[SerializeField]
	private float zoomIndicatorMinY;

	[SerializeField]
	private float zoomIndicatorMaxY;

	[SerializeField]
	private float positionBoxXMult;

	[SerializeField]
	private float positionBoxYMult;

	[SerializeField]
	private Animator damageWarning;
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Rust;
using UnityEngine;

public abstract class BaseHelicopter : BaseVehicle, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	protected class GroundEffect
	{
		public ParticleSystem effect;

		public Transform groundPoint;
	}

	public class HelicopterInputState
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;

		public bool groundControl;

		public void Reset()
		{
			throttle = 0f;
			roll = 0f;
			yaw = 0f;
			pitch = 0f;
			groundControl = false;
		}
	}

	[Header("Helicopter")]
	[SerializeField]
	public float engineThrustMax;

	[SerializeField]
	public Vector3 torqueScale;

	[SerializeField]
	protected Transform com;

	[SerializeField]
	public GameObject[] killTriggers;

	[SerializeField]
	protected GroundEffect[] groundEffects;

	[SerializeField]
	public GameObjectRef serverGibs;

	[SerializeField]
	public GameObjectRef explosionEffect;

	[SerializeField]
	public GameObjectRef fireBall;

	[SerializeField]
	public GameObjectRef crashEffect;

	[Range(0.1f, 0.95f)]
	[Tooltip("Lower values mean more lift is produced at high angles.")]
	[SerializeField]
	public float liftDotMax = 0.75f;

	[SerializeField]
	[Range(0.1f, 0.95f)]
	public float altForceDotMin = 0.85f;

	[Range(0.1f, 0.95f)]
	[SerializeField]
	public float liftFraction = 0.25f;

	[SerializeField]
	public float thrustLerpSpeed = 1f;

	public const Flags Flag_InternalLights = Flags.Reserved6;

	public float currentThrottle;

	public float avgThrust;

	public float avgTerrainHeight;

	public HelicopterInputState currentInputState = new HelicopterInputState();

	public float lastPlayerInputTime;

	public float hoverForceScale = 0.99f;

	public Vector3 damageTorque;

	public float nextDamageTime;

	public float nextEffectTime;

	public float pendingImpactDamage;

	public bool autoHover { get; set; }

	public virtual bool ForceMovementHandling => false;

	public virtual float GetServiceCeiling()
	{
		return 1000f;
	}

	public virtual float GetMinimumAltitudeTerrain()
	{
		return 0f;
	}

	public override float AntiHackVelocity()
	{
		return 50f;
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = com.localPosition;
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!autoHover)
			{
				PilotInput(inputState, player);
			}
		}
		else
		{
			PassengerInput(inputState, player);
		}
	}

	public bool ToggleAutoHover(BasePlayer player)
	{
		autoHover = !autoHover;
		if (autoHover && !IsEngineOn())
		{
			TryStartEngine(player);
		}
		return autoHover;
	}

	public virtual void PilotInput(InputState inputState, BasePlayer player)
	{
		currentInputState.Reset();
		currentInputState.throttle = (inputState.IsDown(BUTTON.FORWARD) ? 1f : 0f);
		currentInputState.throttle -= ((inputState.IsDown(BUTTON.BACKWARD) || inputState.IsDown(BUTTON.DUCK)) ? 1f : 0f);
		currentInputState.pitch = inputState.current.mouseDelta.y;
		currentInputState.roll = 0f - inputState.current.mouseDelta.x;
		currentInputState.yaw = (inputState.IsDown(BUTTON.RIGHT) ? 1f : 0f);
		currentInputState.yaw -= (inputState.IsDown(BUTTON.LEFT) ? 1f : 0f);
		currentInputState.pitch = MouseToBinary(currentInputState.pitch);
		currentInputState.roll = MouseToBinary(currentInputState.roll);
		lastPlayerInputTime = Time.time;
		static float MouseToBinary(float amount)
		{
			return Mathf.Clamp(amount, -1f, 1f);
		}
	}

	public virtual void PassengerInput(InputState inputState, BasePlayer player)
	{
	}

	public virtual void SetDefaultInputState()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		if (HasDriver())
		{
			float num = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
			float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
			currentInputState.roll = ((num < 0f) ? 1f : 0f);
			currentInputState.roll -= ((num > 0f) ? 1f : 0f);
			if (num2 < -0f)
			{
				currentInputState.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				currentInputState.pitch = 1f;
			}
		}
		else
		{
			currentInputState.throttle = -1f;
		}
	}

	public virtual bool IsEnginePowered()
	{
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseHelicopter.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (Time.time > lastPlayerInputTime + 0.5f)
			{
				SetDefaultInputState();
			}
			EnableGlobalBroadcast(IsEngineOn());
			if (IsEngineOn() || ForceMovementHandling)
			{
				MovementUpdate();
			}
			else if (!HasDriver() && TimeSince.op_Implicit(timeSinceLastPush) > 2f)
			{
				ApplyHandbrake();
			}
			SetFlag(Flags.Reserved6, TOD_Sky.Instance.IsNight);
			GameObject[] array = killTriggers;
			foreach (GameObject obj in array)
			{
				bool active = rigidBody.velocity.y < 0f;
				obj.SetActive(active);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
		}
	}

	public virtual bool IsEngineOn()
	{
		return true;
	}

	protected virtual void TryStartEngine(BasePlayer player)
	{
	}

	protected abstract void ApplyHandbrake();

	public void ClearDamageTorque()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SetDamageTorque(Vector3.zero);
	}

	public void SetDamageTorque(Vector3 newTorque)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		damageTorque = newTorque;
	}

	public void AddDamageTorque(Vector3 torqueToAdd)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		damageTorque += torqueToAdd;
	}

	public virtual void MovementUpdate()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState helicopterInputState = currentInputState;
		if (autoHover)
		{
			float num = 50f - ((Component)this).transform.position.y;
			helicopterInputState.throttle = Mathf.Clamp(num * 0.01f, -1f, 1f);
			helicopterInputState.pitch = 0f;
			helicopterInputState.roll = 0f;
			helicopterInputState.yaw = 0f;
		}
		if (helicopterInputState.groundControl)
		{
			currentThrottle = -0.75f;
		}
		else
		{
			currentThrottle = Mathf.Lerp(currentThrottle, helicopterInputState.throttle, 2f * Time.fixedDeltaTime);
			currentThrottle = Mathf.Clamp(currentThrottle, -0.8f, 1f);
			if (helicopterInputState.pitch != 0f || helicopterInputState.roll != 0f || helicopterInputState.yaw != 0f)
			{
				rigidBody.AddRelativeTorque(new Vector3(helicopterInputState.pitch * torqueScale.x, helicopterInputState.yaw * torqueScale.y, helicopterInputState.roll * torqueScale.z), (ForceMode)0);
			}
		}
		if (damageTorque != Vector3.zero)
		{
			rigidBody.AddRelativeTorque(new Vector3(damageTorque.x, damageTorque.y, damageTorque.z), (ForceMode)0);
		}
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime * thrustLerpSpeed);
		float num2 = Mathf.Clamp01(Vector3.Dot(((Component)this).transform.up, Vector3.up));
		float num3 = Mathf.InverseLerp(liftDotMax, 1f, num2);
		float serviceCeiling = GetServiceCeiling();
		float num4 = Mathf.Max(GetMinimumAltitudeTerrain(), TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position));
		avgTerrainHeight = Mathf.Lerp(avgTerrainHeight, num4, Time.deltaTime);
		float num5 = 1f - Mathf.InverseLerp(avgTerrainHeight + serviceCeiling - 20f, avgTerrainHeight + serviceCeiling, ((Component)this).transform.position.y);
		num3 *= num5;
		float num6 = 1f - Mathf.InverseLerp(altForceDotMin, 1f, num2);
		Vector3 val = Vector3.up * engineThrustMax * liftFraction * currentThrottle * num3;
		Vector3 val2 = ((Component)this).transform.up - Vector3.up;
		Vector3 val3 = ((Vector3)(ref val2)).normalized * engineThrustMax * currentThrottle * num6;
		float num7 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(((Component)this).transform.up * num7 * num3 * hoverForceScale, (ForceMode)0);
		rigidBody.AddForce(val, (ForceMode)0);
		rigidBody.AddForce(val3, (ForceMode)0);
	}

	public void DelayedImpactDamage()
	{
		float num = explosionForceMultiplier;
		explosionForceMultiplier = 0f;
		Hurt(pendingImpactDamage * MaxHealth(), DamageType.Explosion, this, useProtection: false);
		pendingImpactDamage = 0f;
		explosionForceMultiplier = num;
	}

	public virtual bool CollisionDamageEnabled()
	{
		return true;
	}

	public void ProcessCollision(Collision collision)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !CollisionDamageEnabled() || Time.time < nextDamageTime)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		if (Object.op_Implicit((Object)(object)collision.gameObject))
		{
			if (((1 << ((Component)collision.collider).gameObject.layer) & 0x48A18101) <= 0)
			{
				return;
			}
			BaseEntity entity = collision.GetEntity();
			if ((Object)(object)entity != (Object)null && (entity is Parachute || entity is RidableHorse || entity is MagnetCrane))
			{
				return;
			}
		}
		float num = Mathf.InverseLerp(7f, 30f, magnitude);
		if (!(num > 0f))
		{
			return;
		}
		pendingImpactDamage += Mathf.Max(num, 0.05f);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.5f)
		{
			pendingImpactDamage *= 5f;
		}
		if (Time.time > nextEffectTime)
		{
			nextEffectTime = Time.time + 0.25f;
			if (crashEffect.isValid)
			{
				ContactPoint contact = collision.GetContact(0);
				Vector3 point = ((ContactPoint)(ref contact)).point;
				TryShowCollisionFX(point);
			}
		}
		Rigidbody obj = rigidBody;
		ContactPoint contact2 = collision.GetContact(0);
		Vector3 val = ((ContactPoint)(ref contact2)).normal * (1f + 3f * num);
		contact2 = collision.GetContact(0);
		obj.AddForceAtPosition(val, ((ContactPoint)(ref contact2)).point, (ForceMode)2);
		nextDamageTime = Time.time + 0.333f;
		((FacepunchBehaviour)this).Invoke((Action)DelayedImpactDamage, 0.015f);
	}

	public override GameObjectRef GetCollisionFX()
	{
		return crashEffect;
	}

	public void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			base.OnDied(info);
			return;
		}
		if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		Vector3 val = rigidBody.velocity * 0.25f;
		List<ServerGib> list = null;
		if (serverGibs.isValid)
		{
			GameObject gibSource = serverGibs.Get().GetComponent<ServerGib>()._gibSource;
			list = ServerGib.CreateGibs(serverGibs.resourcePath, ((Component)this).gameObject, gibSource, val, 3f);
		}
		Vector3 val2 = CenterPoint();
		if (fireBall.isValid && !InSafeZone())
		{
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < 12; i++)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(fireBall.resourcePath, val2, ((Component)this).transform.rotation);
				if (!Object.op_Implicit((Object)(object)baseEntity))
				{
					continue;
				}
				float num = 3f;
				float num2 = 10f;
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Vector3)(ref onUnitSphere)).Normalize();
				float num3 = Random.Range(0.5f, 4f);
				bool num4 = Physics.Raycast(val2, onUnitSphere, ref val3, num3, 1218652417);
				Vector3 val4 = ((RaycastHit)(ref val3)).point;
				if (!num4)
				{
					val4 = val2 + onUnitSphere * num3;
				}
				val4 -= onUnitSphere * 0.5f;
				((Component)baseEntity).transform.position = val4;
				Collider component = ((Component)baseEntity).GetComponent<Collider>();
				baseEntity.Spawn();
				baseEntity.SetVelocity(val + onUnitSphere * Random.Range(num, num2));
				if (list == null)
				{
					continue;
				}
				foreach (ServerGib item in list)
				{
					Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		SeismicSensor.Notify(((Component)this).transform.position, 1);
		base.OnDied(info);
	}

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
protected class GroundEffect
{
	public ParticleSystem effect;

	public Transform groundPoint;
}


public class HelicopterInputState
{
	public float throttle;

	public float roll;

	public float yaw;

	public float pitch;

	public bool groundControl;

	public void Reset()
	{
		throttle = 0f;
		roll = 0f;
		yaw = 0f;
		pitch = 0f;
		groundControl = false;
	}
}


using System;
using UnityEngine;

public class CH47AIBrain : BaseAIBrain
{
	public class DropCrate : BasicAIState
	{
		private float nextDropTime;

		public DropCrate()
			: base(AIState.DropCrate)
		{
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return !CanDrop();
			}
			return false;
		}

		public bool CanDrop()
		{
			if (Time.time > nextDropTime)
			{
				return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
			}
			return false;
		}

		public override float GetWeight()
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (!CanDrop())
			{
				return 0f;
			}
			if (IsInState())
			{
				return 10000f;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
			{
				CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
				if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
				{
					CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
					if ((Object)(object)component != (Object)null)
					{
						float num = Mathf.InverseLerp(300f, 600f, component.Age);
						return 1000f * num;
					}
				}
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.SetDropDoorOpen(open: true);
			obj.EnableFacingOverride(enabled: false);
			CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
			if ((Object)(object)closest == (Object)null)
			{
				nextDropTime = Time.time + 60f;
			}
			brain.mainInterestPoint = ((Component)closest).transform.position;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
			{
				Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
				if (((Vector3)(ref velocity)).magnitude < 5f)
				{
					cH47HelicopterAIController.DropCrate();
					nextDropTime = Time.time + 120f;
				}
			}
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
			nextDropTime = Time.time + 60f;
			base.StateLeave(brain, entity);
		}
	}

	public class EgressState : BasicAIState
	{
		private bool killing;

		private bool egressAltitueAchieved;

		public EgressState()
			: base(AIState.Egress)
		{
		}

		public override bool CanInterrupt()
		{
			return false;
		}

		public override float GetWeight()
		{
			CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
			if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
			{
				return 10000f;
			}
			CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
			if ((Object)(object)component != (Object)null)
			{
				if (!(component.Age > 1800f))
				{
					return 0f;
				}
				return 10000f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			Transform transform = ((Component)obj).transform;
			Rigidbody rigidBody = obj.rigidBody;
			Vector3 val = rigidBody.velocity;
			Vector3 val2;
			if (!(((Vector3)(ref val)).magnitude < 0.1f))
			{
				val = rigidBody.velocity;
				val2 = ((Vector3)(ref val)).normalized;
			}
			else
			{
				val2 = transform.forward;
			}
			Vector3 val3 = val2;
			Vector3 val4 = Vector3.Cross(Vector3.Cross(transform.up, val3), Vector3.up);
			if (val4.x <= 0f)
			{
				val4.x = 0f - val4.x;
				val = new Vector3(val4.x, 0f, val4.z);
				val4 = ((Vector3)(ref val)).normalized;
			}
			brain.mainInterestPoint = transform.position + val4 * 8000f;
			brain.mainInterestPoint.y = 100f;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (killing)
			{
				return StateStatus.Running;
			}
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			if (position.y < 85f && !egressAltitueAchieved)
			{
				CH47LandingZone closest = CH47LandingZone.GetClosest(position);
				if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
				{
					float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
					waterOrTerrainSurface += 100f;
					Vector3 moveTarget = position;
					moveTarget.y = waterOrTerrainSurface;
					cH47HelicopterAIController.SetMoveTarget(moveTarget);
					return StateStatus.Running;
				}
			}
			egressAltitueAchieved = true;
			cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
			if (base.TimeInState > 300f)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
				killing = true;
			}
			return StateStatus.Running;
		}
	}

	public class IdleState : BaseIdleState
	{
		public override float GetWeight()
		{
			return 0.1f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
			base.StateEnter(brain, entity);
		}
	}

	public class LandState : BasicAIState
	{
		private float landedForSeconds;

		private float lastLandtime;

		private float landingHeight = 20f;

		private float nextDismountTime;

		public LandState()
			: base(AIState.Land)
		{
		}

		public override float GetWeight()
		{
			if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
			{
				return 0f;
			}
			float num = Time.time - lastLandtime;
			if (IsInState() && landedForSeconds < 12f)
			{
				return 1000f;
			}
			if (!IsInState() && num > 10f)
			{
				return 9000f;
			}
			return 0f;
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_016c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			_ = ((Component)cH47HelicopterAIController).transform.forward;
			CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
			if (!Object.op_Implicit((Object)(object)closest))
			{
				return StateStatus.Error;
			}
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			float magnitude = ((Vector3)(ref velocity)).magnitude;
			float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
			bool enabled = num < 40f;
			bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
			cH47HelicopterAIController.EnableFacingOverride(enabled);
			cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
			int num2;
			if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
			{
				num2 = ((magnitude < 1f) ? 1 : 0);
				if (num2 != 0)
				{
					landedForSeconds += delta;
					if (lastLandtime == 0f)
					{
						lastLandtime = Time.time;
					}
				}
			}
			else
			{
				num2 = 0;
			}
			float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
			landingHeight -= 4f * num3 * Time.deltaTime;
			if (landingHeight < -5f)
			{
				landingHeight = -5f;
			}
			cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
			Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
			if (num < 100f && num > 15f)
			{
				Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
				RaycastHit val2 = default(RaycastHit);
				if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
				{
					Vector3 val3 = Vector3.Cross(val, Vector3.up);
					moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
				}
			}
			cH47HelicopterAIController.SetMoveTarget(moveTarget);
			if (num2 != 0)
			{
				if (landedForSeconds > 1f && Time.time > nextDismountTime && cH47HelicopterAIController.TryDismountOne())
				{
					nextDismountTime = Time.time + 0.5f;
				}
				if (landedForSeconds > 8f)
				{
					((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
				}
			}
			return StateStatus.Running;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
			landingHeight = 15f;
			base.StateEnter(brain, entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.SetAltitudeProtection(on: true);
			obj.SetMinHoverHeight(30f);
			landedForSeconds = 0f;
			base.StateLeave(brain, entity);
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public class OrbitState : BasicAIState
	{
		public OrbitState()
			: base(AIState.Orbit)
		{
		}

		public Vector3 GetOrbitCenter()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
				return 5f * num;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
			{
				return 5f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: true);
			obj.InitiateAnger();
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			Vector3 orbitCenter = GetOrbitCenter();
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
			float num2 = 75f;
			Vector3 val3 = -val + val2 * num * 0.6f;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			Vector3 val4 = orbitCenter + normalized * num2;
			cH47HelicopterAIController.SetMoveTarget(val4);
			cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
			base.StateThink(delta, brain, entity);
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.CancelAnger();
			base.StateLeave(brain, entity);
		}
	}

	public class PatrolState : BasePatrolState
	{
		protected float patrolApproachDist = 75f;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
			return StateStatus.Running;
		}

		public bool AtPatrolDestination()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
		}

		public Vector3 GetDestination()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return AtPatrolDestination();
			}
			return false;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				if (AtPatrolDestination() && base.TimeInState > 2f)
				{
					return 0f;
				}
				return 3f;
			}
			float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
			return 1f + num;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new PatrolState());
		AddState(new OrbitState());
		AddState(new EgressState());
		AddState(new DropCrate());
		AddState(new LandState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.FixedUpdate;
		base.PathFinder = new CH47PathFinder();
	}

	public void FixedUpdate()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			Think(Time.fixedDeltaTime);
		}
	}
}


using UnityEngine;

public class DropCrate : BasicAIState
{
	private float nextDropTime;

	public DropCrate()
		: base(AIState.DropCrate)
	{
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return !CanDrop();
		}
		return false;
	}

	public bool CanDrop()
	{
		if (Time.time > nextDropTime)
		{
			return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
		}
		return false;
	}

	public override float GetWeight()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!CanDrop())
		{
			return 0f;
		}
		if (IsInState())
		{
			return 10000f;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
		{
			CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
			if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
			{
				CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
				if ((Object)(object)component != (Object)null)
				{
					float num = Mathf.InverseLerp(300f, 600f, component.Age);
					return 1000f * num;
				}
			}
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.SetDropDoorOpen(open: true);
		obj.EnableFacingOverride(enabled: false);
		CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
		if ((Object)(object)closest == (Object)null)
		{
			nextDropTime = Time.time + 60f;
		}
		brain.mainInterestPoint = ((Component)closest).transform.position;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
		{
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude < 5f)
			{
				cH47HelicopterAIController.DropCrate();
				nextDropTime = Time.time + 120f;
			}
		}
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
		nextDropTime = Time.time + 60f;
		base.StateLeave(brain, entity);
	}
}


using System;
using UnityEngine;

public class EgressState : BasicAIState
{
	private bool killing;

	private bool egressAltitueAchieved;

	public EgressState()
		: base(AIState.Egress)
	{
	}

	public override bool CanInterrupt()
	{
		return false;
	}

	public override float GetWeight()
	{
		CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
		if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
		{
			return 10000f;
		}
		CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
		if ((Object)(object)component != (Object)null)
		{
			if (!(component.Age > 1800f))
			{
				return 0f;
			}
			return 10000f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		Transform transform = ((Component)obj).transform;
		Rigidbody rigidBody = obj.rigidBody;
		Vector3 val = rigidBody.velocity;
		Vector3 val2;
		if (!(((Vector3)(ref val)).magnitude < 0.1f))
		{
			val = rigidBody.velocity;
			val2 = ((Vector3)(ref val)).normalized;
		}
		else
		{
			val2 = transform.forward;
		}
		Vector3 val3 = val2;
		Vector3 val4 = Vector3.Cross(Vector3.Cross(transform.up, val3), Vector3.up);
		if (val4.x <= 0f)
		{
			val4.x = 0f - val4.x;
			val = new Vector3(val4.x, 0f, val4.z);
			val4 = ((Vector3)(ref val)).normalized;
		}
		brain.mainInterestPoint = transform.position + val4 * 8000f;
		brain.mainInterestPoint.y = 100f;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (killing)
		{
			return StateStatus.Running;
		}
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		if (position.y < 85f && !egressAltitueAchieved)
		{
			CH47LandingZone closest = CH47LandingZone.GetClosest(position);
			if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
			{
				float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
				waterOrTerrainSurface += 100f;
				Vector3 moveTarget = position;
				moveTarget.y = waterOrTerrainSurface;
				cH47HelicopterAIController.SetMoveTarget(moveTarget);
				return StateStatus.Running;
			}
		}
		egressAltitueAchieved = true;
		cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
		if (base.TimeInState > 300f)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
			killing = true;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class IdleState : BaseIdleState
{
	public override float GetWeight()
	{
		return 0.1f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
		base.StateEnter(brain, entity);
	}
}


using UnityEngine;

public class LandState : BasicAIState
{
	private float landedForSeconds;

	private float lastLandtime;

	private float landingHeight = 20f;

	private float nextDismountTime;

	public LandState()
		: base(AIState.Land)
	{
	}

	public override float GetWeight()
	{
		if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
		{
			return 0f;
		}
		float num = Time.time - lastLandtime;
		if (IsInState() && landedForSeconds < 12f)
		{
			return 1000f;
		}
		if (!IsInState() && num > 10f)
		{
			return 9000f;
		}
		return 0f;
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		_ = ((Component)cH47HelicopterAIController).transform.forward;
		CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
		if (!Object.op_Implicit((Object)(object)closest))
		{
			return StateStatus.Error;
		}
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
		bool enabled = num < 40f;
		bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
		cH47HelicopterAIController.EnableFacingOverride(enabled);
		cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
		int num2;
		if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
		{
			num2 = ((magnitude < 1f) ? 1 : 0);
			if (num2 != 0)
			{
				landedForSeconds += delta;
				if (lastLandtime == 0f)
				{
					lastLandtime = Time.time;
				}
			}
		}
		else
		{
			num2 = 0;
		}
		float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
		landingHeight -= 4f * num3 * Time.deltaTime;
		if (landingHeight < -5f)
		{
			landingHeight = -5f;
		}
		cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
		Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
		if (num < 100f && num > 15f)
		{
			Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
			{
				Vector3 val3 = Vector3.Cross(val, Vector3.up);
				moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
			}
		}
		cH47HelicopterAIController.SetMoveTarget(moveTarget);
		if (num2 != 0)
		{
			if (landedForSeconds > 1f && Time.time > nextDismountTime && cH47HelicopterAIController.TryDismountOne())
			{
				nextDismountTime = Time.time + 0.5f;
			}
			if (landedForSeconds > 8f)
			{
				((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
			}
		}
		return StateStatus.Running;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
		landingHeight = 15f;
		base.StateEnter(brain, entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.SetAltitudeProtection(on: true);
		obj.SetMinHoverHeight(30f);
		landedForSeconds = 0f;
		base.StateLeave(brain, entity);
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using UnityEngine;

public class OrbitState : BasicAIState
{
	public OrbitState()
		: base(AIState.Orbit)
	{
	}

	public Vector3 GetOrbitCenter()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
			return 5f * num;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
		{
			return 5f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: true);
		obj.InitiateAnger();
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 orbitCenter = GetOrbitCenter();
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
		float num2 = 75f;
		Vector3 val3 = -val + val2 * num * 0.6f;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 val4 = orbitCenter + normalized * num2;
		cH47HelicopterAIController.SetMoveTarget(val4);
		cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
		base.StateThink(delta, brain, entity);
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.CancelAnger();
		base.StateLeave(brain, entity);
	}
}


using UnityEngine;

public class PatrolState : BasePatrolState
{
	protected float patrolApproachDist = 75f;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
		return StateStatus.Running;
	}

	public bool AtPatrolDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
	}

	public Vector3 GetDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return AtPatrolDestination();
		}
		return false;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			if (AtPatrolDestination() && base.TimeInState > 2f)
			{
				return 0f;
			}
			return 3f;
		}
		float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
		return 1f + num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47DropZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47DropZone> dropZones = new List<CH47DropZone>();

	public void Awake()
	{
		if (!dropZones.Contains(this))
		{
			dropZones.Add(this);
		}
	}

	public static CH47DropZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47DropZone result = null;
		foreach (CH47DropZone dropZone in dropZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)dropZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = dropZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (dropZones.Contains(this))
		{
			dropZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.yellow;
		Gizmos.DrawSphere(((Component)this).transform.position, 5f);
	}
}


using Oxide.Core;
using UnityEngine;

public class CH47Helicopter : BaseHelicopter
{
	public GameObjectRef mapMarkerEntityPrefab;

	[Header("Sounds")]
	public SoundDefinition flightEngineSoundDef;

	public SoundDefinition flightThwopsSoundDef;

	public float rotorGainModSmoothing = 0.25f;

	public float engineGainMin = 0.5f;

	public float engineGainMax = 1f;

	public float thwopGainMin = 0.5f;

	public float thwopGainMax = 1f;

	public BaseEntity mapMarkerInstance;

	public override void ServerInit()
	{
		rigidBody.isKinematic = false;
		base.ServerInit();
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		mapMarkerInstance = baseEntity;
	}

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected override void ApplyHandbrake()
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

public class CH47HelicopterAIController : CH47Helicopter
{
	[Tooltip("Prefab for the NPCs that will be spawned in the helicopter IF it doesn't land and just drops a crate.")]
	public GameObjectRef scientistPrefab;

	[Tooltip("Prefab for the NPCs that will be spawned in the helicopter IF it lands.")]
	public GameObjectRef dismountablePrefab;

	public float maxTiltAngle = 0.3f;

	public float AiAltitudeForce = 10000f;

	public GameObjectRef lockedCratePrefab;

	public const Flags Flag_Damaged = Flags.Reserved9;

	public const Flags Flag_NearDeath = Flags.OnFire;

	public const Flags Flag_DropDoorOpen = Flags.Reserved8;

	public Vector3 landingTarget;

	private List<BaseNPC2> parentedNpcs = new List<BaseNPC2>();

	public int numCrates = 1;

	private bool shouldLand;

	public bool aimDirOverride;

	public Vector3 _aimDirection = Vector3.forward;

	public Vector3 _moveTarget = Vector3.zero;

	public int lastAltitudeCheckFrame;

	public float altOverride;

	public float currentDesiredAltitude;

	private bool altitudeProtection = true;

	public float hoverHeight = 30f;

	[ServerVar]
	public static void dropCrate()
	{
		CH47HelicopterAIController[] array = Object.FindObjectsByType<CH47HelicopterAIController>((FindObjectsInactive)0, (FindObjectsSortMode)0);
		foreach (CH47HelicopterAIController cH47HelicopterAIController in array)
		{
			if (cH47HelicopterAIController.isServer)
			{
				cH47HelicopterAIController.DropCrate();
			}
		}
	}

	public void DropCrate()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (numCrates > 0)
		{
			Vector3 pos = ((Component)this).transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				Interface.CallHook("OnHelicopterDropCrate", (object)this);
				((Component)baseEntity).SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

	public bool IsDropDoorOpen()
	{
		return HasFlag(Flags.Reserved8);
	}

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", (object)this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

	public bool ShouldLand()
	{
		return shouldLand;
	}

	public void SetLandingTarget(Vector3 target)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		shouldLand = true;
		landingTarget = target;
		numCrates = 0;
	}

	public void ClearLandingTarget()
	{
		shouldLand = false;
	}

	public void TriggeredEventSpawn()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = TerrainMeta.RandomPointOffshore(avoidDeepSeaPortal: false, avoidDeepSea: true);
		val.y = WaterLevel.GetWaterSurface(val, waves: false, volumes: false) + 30f;
		((Component)this).transform.position = val;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", (object)player, (object)this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 0.25f);
		SetMoveTarget(((Component)this).transform.position);
	}

	public void SpawnPassenger(Vector3 spawnPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SpawnInternal(spawnPos, dismountablePrefab);
	}

	public void SpawnScientist(Vector3 spawnPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SpawnInternal(spawnPos, scientistPrefab);
	}

	private void SpawnInternal(Vector3 spawnPos, GameObjectRef prefab)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)(object)prefab.GetEntity()).Is<HumanNPC>(out HumanNPC _))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefab.resourcePath, spawnPos, Quaternion.identity);
			baseEntity.Spawn();
			HumanNPC humanNPC = baseEntity as HumanNPC;
			AttemptMount(humanNPC);
			if (prefab == scientistPrefab)
			{
				humanNPC.Brain.SetEnabled(flag: false);
			}
			OnSpawnedHuman(humanNPC);
		}
		else
		{
			if (!((Object)(object)prefab.GetEntity()).Is<BaseNPC2>(out BaseNPC2 _))
			{
				return;
			}
			BaseMountable baseMountable = null;
			float num = float.MaxValue;
			foreach (MountPointInfo allMountPoint in base.allMountPoints)
			{
				if (allMountPoint.mountable.AnyMounted())
				{
					continue;
				}
				bool flag = false;
				foreach (BaseNPC2 parentedNpc in parentedNpcs)
				{
					if (Vector3.Distance(((Component)parentedNpc).transform.position, allMountPoint.mountable.mountAnchor.position) < 0.5f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					float num2 = Vector3.Distance(allMountPoint.mountable.mountAnchor.position, spawnPos);
					if (num2 < num)
					{
						baseMountable = allMountPoint.mountable;
						num = num2;
					}
				}
			}
			if ((Object)(object)baseMountable != (Object)null)
			{
				BaseEntity baseEntity2 = GameManager.server.CreateEntity(prefab.resourcePath, spawnPos, Quaternion.identity);
				baseEntity2.Spawn();
				parentedNpcs.Add(baseEntity2 as BaseNPC2);
				baseEntity2.SetParent(this);
				((Component)baseEntity2).transform.position = baseMountable.mountAnchor.position;
				((Component)baseEntity2).transform.rotation = baseMountable.mountAnchor.rotation;
				((Behaviour)((Component)baseEntity2).GetComponent<NavMeshAgent>()).enabled = false;
			}
		}
	}

	public bool TryDismountOne()
	{
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
			{
				mountPoint.mountable.DismountAllPlayers();
				return true;
			}
		}
		foreach (BaseNPC2 parentedNpc in parentedNpcs)
		{
			Transform val = null;
			float num = float.MaxValue;
			Transform[] array = dismountPositions;
			foreach (Transform val2 in array)
			{
				bool flag = false;
				foreach (BaseNPC2 parentedNpc2 in parentedNpcs)
				{
					if (Vector3.Distance(((Component)parentedNpc2).transform.position, val2.position) < 0.5f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					float num2 = Vector3.Distance(((Component)parentedNpc).transform.position, val2.position);
					if (num2 < num)
					{
						num = num2;
						val = val2;
					}
				}
			}
			if ((Object)(object)val != (Object)null)
			{
				parentedNpc.SetParent(null, worldPositionStays: true);
				((Behaviour)((Component)parentedNpc).GetComponent<NavMeshAgent>()).enabled = true;
				parentedNpcs.Remove(parentedNpc);
				((Component)parentedNpc).transform.position = val.position;
				((Component)parentedNpc).transform.rotation = val.rotation;
				return true;
			}
		}
		return false;
	}

	private void OnSpawnedHuman(HumanNPC human)
	{
		if (!((Object)(object)human == (Object)null) && (Object)(object)human.Brain != (Object)null && human.Brain.Senses != null)
		{
			human.Brain.Senses.ignoreTutorialPlayers = true;
		}
	}

	public void CheckSpawnScientists()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (ValidBounds.Test(this, ((Component)this).transform.position))
		{
			((FacepunchBehaviour)this).Invoke((Action)SpawnScientists, 2f);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 2f);
		}
	}

	public void SpawnScientists()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (shouldLand)
		{
			float dropoffScale = CH47LandingZone.GetClosest(landingTarget).dropoffScale;
			int num = Mathf.FloorToInt((float)(mountPoints.Count - 2) * dropoffScale);
			for (int i = 0; i < num; i++)
			{
				Vector3 spawnPos = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnPassenger(spawnPos);
			}
			Vector3 spawnPos2 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
			SpawnPassenger(spawnPos2);
		}
		else
		{
			for (int j = 0; j < 4; j++)
			{
				Vector3 spawnPos3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnScientist(spawnPos3);
			}
			Vector3 spawnPos4 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
			SpawnScientist(spawnPos4);
		}
	}

	public void EnableFacingOverride(bool enabled)
	{
		aimDirOverride = enabled;
	}

	public void SetMoveTarget(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_moveTarget = position;
	}

	public Vector3 GetMoveTarget()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _moveTarget;
	}

	public void SetAimDirection(Vector3 dir)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_aimDirection = dir;
	}

	public Vector3 GetAimDirectionOverride()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _aimDirection;
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		InitiateAnger();
	}

	public void CancelAnger()
	{
		if (base.SecondsSinceAttacked > 120f)
		{
			UnHostile();
			((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		}
	}

	public void InitiateAnger()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		((FacepunchBehaviour)this).Invoke((Action)UnHostile, 120f);
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: true);
				}
			}
		}
	}

	public void UnHostile()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: false);
				}
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", (object)this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnDied(info);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", (object)this, (object)info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

	public void DelayedKill()
	{
		DismountAllPlayers();
		Kill();
	}

	public override void DismountAllPlayers()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null)
			{
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if (Object.op_Implicit((Object)(object)mounted) && mounted.IsAlive())
				{
					mounted.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
				}
			}
		}
		foreach (BaseNPC2 parentedNpc in parentedNpcs)
		{
			if (parentedNpc.IsAlive())
			{
				parentedNpc.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
			}
		}
		parentedNpcs.Clear();
	}

	public override void AdminKill()
	{
		DismountAllPlayers();
		base.AdminKill();
	}

	public void SetAltitudeProtection(bool on)
	{
		altitudeProtection = on;
	}

	public void CalculateDesiredAltitude()
	{
		CalculateOverrideAltitude();
		if (altOverride > currentDesiredAltitude)
		{
			currentDesiredAltitude = altOverride;
		}
		else
		{
			currentDesiredAltitude = Mathf.MoveTowards(currentDesiredAltitude, altOverride, Time.fixedDeltaTime * 5f);
		}
	}

	public void SetMinHoverHeight(float newHeight)
	{
		hoverHeight = newHeight;
	}

	public float CalculateOverrideAltitude()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (Time.frameCount == lastAltitudeCheckFrame)
		{
			return altOverride;
		}
		lastAltitudeCheckFrame = Time.frameCount;
		float y = GetMoveTarget().y;
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(GetMoveTarget(), waves: false, volumes: false);
		float num = Mathf.Max(y, waterOrTerrainSurface + hoverHeight);
		if (altitudeProtection)
		{
			Vector3 val = rigidBody.velocity;
			Vector3 val2;
			if (!(((Vector3)(ref val)).magnitude < 0.1f))
			{
				val = rigidBody.velocity;
				val2 = ((Vector3)(ref val)).normalized;
			}
			else
			{
				val2 = ((Component)this).transform.forward;
			}
			Vector3 val3 = val2;
			val = Vector3.Cross(Vector3.Cross(((Component)this).transform.up, val3), Vector3.up) + Vector3.down * 0.3f;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			RaycastHit val4 = default(RaycastHit);
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(((Component)this).transform.position - normalized * 20f, 20f, normalized, ref val4, 75f, 1218511105) && Physics.SphereCast(((RaycastHit)(ref val4)).point + Vector3.up * 200f, 20f, Vector3.down, ref val5, 200f, 1218511105))
			{
				num = ((RaycastHit)(ref val5)).point.y + hoverHeight;
			}
		}
		altOverride = num;
		return altOverride;
	}

	public override void SetDefaultInputState()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		Vector3 moveTarget = GetMoveTarget();
		Vector3 val = Vector3.Cross(((Component)this).transform.right, Vector3.up);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = 0f - Vector3.Dot(Vector3.up, ((Component)this).transform.right);
		float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
		float num3 = Vector3Ex.Distance2D(((Component)this).transform.position, moveTarget);
		float y = ((Component)this).transform.position.y;
		float num4 = currentDesiredAltitude;
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
		val3.y = num4;
		Vector3 val4 = Vector3Ex.Direction2D(moveTarget, ((Component)this).transform.position);
		float num5 = 0f - Vector3.Dot(val4, val2);
		float num6 = Vector3.Dot(val4, val);
		float num7 = Mathf.InverseLerp(0f, 25f, num3);
		if (num6 > 0f)
		{
			float num8 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num2);
			currentInputState.pitch = 1f * num6 * num8 * num7;
		}
		else
		{
			float num9 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num2);
			currentInputState.pitch = 1f * num6 * num9 * num7;
		}
		if (num5 > 0f)
		{
			float num10 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num);
			currentInputState.roll = 1f * num5 * num10 * num7;
		}
		else
		{
			float num11 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num);
			currentInputState.roll = 1f * num5 * num11 * num7;
		}
		float num12 = Mathf.Abs(num4 - y);
		float num13 = 1f - Mathf.InverseLerp(10f, 30f, num12);
		currentInputState.pitch *= num13;
		currentInputState.roll *= num13;
		float num14 = maxTiltAngle;
		float num15 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.pitch) * num14, num14 + Mathf.Abs(currentInputState.pitch) * num14, Mathf.Abs(num2));
		currentInputState.pitch += num15 * ((num2 < 0f) ? (-1f) : 1f);
		float num16 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.roll) * num14, num14 + Mathf.Abs(currentInputState.roll) * num14, Mathf.Abs(num));
		currentInputState.roll += num16 * ((num < 0f) ? (-1f) : 1f);
		if (aimDirOverride || num3 > 30f)
		{
			Vector3 val5 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			Vector3 val6 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			float num17 = Vector3.Dot(val2, val5);
			float num18 = Vector3.Angle(val, val6);
			float num19 = Mathf.InverseLerp(0f, 70f, Mathf.Abs(num18));
			currentInputState.yaw = ((num17 > 0f) ? 1f : 0f);
			currentInputState.yaw -= ((num17 < 0f) ? 1f : 0f);
			currentInputState.yaw *= num19;
		}
		float throttle = Mathf.InverseLerp(5f, 30f, num3);
		currentInputState.throttle = throttle;
	}

	public void MaintainAIAltutide()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + rigidBody.velocity;
		float num = currentDesiredAltitude;
		float y = val.y;
		float num2 = Mathf.Abs(num - y);
		bool flag = num > y;
		float num3 = Mathf.InverseLerp(0f, 10f, num2) * AiAltitudeForce * (flag ? 1f : (-1f));
		rigidBody.AddForce(Vector3.up * num3, (ForceMode)0);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("CH47HeliAI.VehicleFixedUpdate", 0);
		try
		{
			hoverForceScale = 1f;
			base.VehicleFixedUpdate();
			SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
			CalculateDesiredAltitude();
			MaintainAIAltutide();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			foreach (MountPointInfo mountPoint in mountPoints)
			{
				if ((Object)(object)mountPoint.mountable != (Object)null)
				{
					BasePlayer mounted = mountPoint.mountable.GetMounted();
					if (Object.op_Implicit((Object)(object)mounted) && (Object)(object)((Component)mounted).transform != (Object)null && !mounted.IsDestroyed && !mounted.IsDead() && mounted.IsNpc)
					{
						mounted.Kill();
					}
				}
			}
		}
		base.DestroyShared();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47LandingZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47LandingZone> landingZones = new List<CH47LandingZone>();

	public float dropoffScale = 1f;

	public static bool HasAnyLandingZones => !landingZones.IsNullOrEmpty();

	public void Awake()
	{
		if (!landingZones.Contains(this))
		{
			landingZones.Add(this);
		}
	}

	public static CH47LandingZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47LandingZone result = null;
		foreach (CH47LandingZone landingZone in landingZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)landingZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = landingZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (landingZones.Contains(this))
		{
			landingZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Color magenta = Color.magenta;
		magenta.a = 0.25f;
		Gizmos.color = magenta;
		GizmosUtil.DrawCircleY(((Component)this).transform.position, 6f);
		magenta.a = 1f;
		Gizmos.color = magenta;
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, 6f);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class CH47PathFinder : BasePathFinder
{
	public List<Vector3> visitedPatrolPoints = new List<Vector3>();

	public override Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		MonumentInfo monumentInfo = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			PooledList<MonumentInfo> val2 = Pool.Get<PooledList<MonumentInfo>>();
			try
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.Type == MonumentType.Cave || monument.Type == MonumentType.WaterWell || monument.Tier == MonumentTier.Tier0 || monument.IsSafeZone || (monument.Tier & MonumentTier.Tier0) > (MonumentTier)0)
					{
						continue;
					}
					bool flag = false;
					foreach (Vector3 visitedPatrolPoint in visitedPatrolPoints)
					{
						if (Vector3Ex.Distance2D(((Component)monument).transform.position, visitedPatrolPoint) < 100f)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						((List<MonumentInfo>)(object)val2).Add(monument);
					}
				}
				if (((List<MonumentInfo>)(object)val2).Count > 0)
				{
					int index = Random.Range(0, ((List<MonumentInfo>)(object)val2).Count);
					monumentInfo = ((List<MonumentInfo>)(object)val2)[index];
				}
				if ((Object)(object)monumentInfo == (Object)null)
				{
					visitedPatrolPoints.Clear();
					monumentInfo = GetRandomValidMonumentInfo();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		if ((Object)(object)monumentInfo != (Object)null)
		{
			visitedPatrolPoints.Add(((Component)monumentInfo).transform.position);
			val = ((Component)monumentInfo).transform.position;
		}
		else
		{
			float x = TerrainMeta.Size.x;
			float y = 30f;
			val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * Random.Range(0f, 0.75f);
			val.y = y;
		}
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		float num = waterOrTerrainSurface;
		RaycastHit val3 = default(RaycastHit);
		if (Physics.SphereCast(val + new Vector3(0f, 200f, 0f), 20f, Vector3.down, ref val3, 300f, 1218511105))
		{
			num = Mathf.Max(((RaycastHit)(ref val3)).point.y, waterOrTerrainSurface);
		}
		val.y = num + 30f;
		return val;
	}

	private MonumentInfo GetRandomValidMonumentInfo()
	{
		int count = TerrainMeta.Path.Monuments.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = i + num;
			if (num2 >= count)
			{
				num2 -= count;
			}
			MonumentInfo monumentInfo = TerrainMeta.Path.Monuments[num2];
			if (monumentInfo.Type != 0 && monumentInfo.Type != MonumentType.WaterWell && monumentInfo.Tier != MonumentTier.Tier0 && !monumentInfo.IsSafeZone)
			{
				return monumentInfo;
			}
		}
		return null;
	}
}


using UnityEngine;

public class CH47ReinforcementListener : BaseEntity
{
	public string listenString;

	public GameObjectRef heliPrefab;

	public float startDist = 300f;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			Call();
		}
	}

	public void Call()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TryCall(heliPrefab.resourcePath, ((Component)this).transform.position, startDist);
	}

	public static bool TryCall(string resourcePath, Vector3 ourPos, float startDist)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController component = ((Component)GameManager.server.CreateEntity(resourcePath)).GetComponent<CH47HelicopterAIController>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		_ = TerrainMeta.Size;
		CH47LandingZone closest = CH47LandingZone.GetClosest(ourPos);
		if ((Object)(object)closest == (Object)null)
		{
			return false;
		}
		Vector3 zero = Vector3.zero;
		zero.y = ((Component)closest).transform.position.y;
		Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, zero);
		Vector3 position = ((Component)closest).transform.position + val * startDist;
		position.y = ((Component)closest).transform.position.y;
		((Component)component).transform.position = position;
		component.SetLandingTarget(((Component)closest).transform.position);
		component.Spawn();
		return true;
	}
}


using Oxide.Core;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class HeliPilotFlare : MonoBehaviour, SeekerTarget.ISeekerTargetOwner
{
	protected void Start()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	protected void OnDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
	}

	public void Init(Vector3 initialVelocity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).GetComponent<Rigidbody>().velocity = initialVelocity;
	}

	public Vector3 CenterPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public bool IsVisible(Vector3 from, float maxDistance = float.PositiveInfinity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.LineOfSight(from, CenterPoint(), 1218519041);
	}

	public bool InSafeZone()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckSphere<TriggerSafeZone>(CenterPoint(), 0.1f, 262144, (QueryTriggerInteraction)2);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public void OnEntityMessage(BaseEntity from, string msg)
	{
	}
}


public interface ICanFireHelicopterFlares
{
	BaseEntity flareEntity { get; }

	HelicopterFlares FlaresInstance { get; }

	void FireFlares();

	void FlareFireFailed(BasePlayer player);
}


using UnityEngine;

public class Minicopter : PlayerHelicopterWithFlares
{
	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;

	[Header(" Minicopter Specific ")]
	[SerializeField]
	private ParticleSystemContainer fxMediumDamage;

	[SerializeField]
	private ParticleSystemContainer fxHeavyDamage;

	[SerializeField]
	private SoundDefinition damagedMediumLoop;

	[SerializeField]
	private SoundDefinition damagedHeavyLoop;

	[SerializeField]
	private GameObject damageSoundTarget;
}


using UnityEngine;

public class MiniCopterAnimation : MonoBehaviour
{
	public void UpdateRotorSpeed(float newSpeed)
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

public class PlayerHeliSounds : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class FlightSoundLayer
	{
		public SoundDefinition loopDefinition;

		public SoundDefinition startDefinition;

		public SoundDefinition stopDefinition;

		public Transform targetParent;

		public float fadeTime = 0.25f;

		public float initialGain = 1f;

		public float gainRateUp = 5f;

		public float gainRateDown = 5f;

		public float gainInterpRate = 0.5f;

		public float initialPitch = 1f;

		public float pitchRateUp = 5f;

		public float pitchRateDown = 5f;

		public float pitchInterpRate = 0.5f;

		public bool returnToInitialWhenTurnedOff;

		public bool useUpDotPitchCurve;

		public AnimationCurve upDotPitchCurve;
	}

	[FormerlySerializedAs("miniCopter")]
	public PlayerHelicopter miniCopter;

	public GameObject soundAttachPoint;

	public List<FlightSoundLayer> flightSoundLayers = new List<FlightSoundLayer>();

	public SoundDefinition engineStartDef;

	public SoundDefinition engineLoopDef;

	public SoundDefinition engineStopDef;

	public SoundDefinition rotorLoopDef;

	public SoundDefinition radarWarningDef;

	public SoundDefinition radarLockDef;

	public SoundDefinition noAmmoDef;

	public SoundDefinition noFlaresDef;

	public SoundDefinition flaresReadyDef;

	public SoundDefinition flightControlMovementSoundDef;

	public GameObject flightControlSoundPosition;

	public float engineStartFadeOutTime = 1f;

	public float engineLoopFadeInTime = 0.7f;

	public float engineLoopFadeOutTime = 0.25f;

	public float engineStopFadeOutTime = 0.25f;

	public float rotorLoopFadeInTime = 0.7f;

	public float rotorLoopFadeOutTime = 0.25f;

	public float enginePitchInterpRate = 0.5f;

	public float rotorPitchInterpRate = 1f;

	public float rotorGainInterpRate = 0.5f;

	public float rotorStartStopPitchRateUp = 7f;

	public float rotorStartStopPitchRateDown = 9f;

	public float rotorStartStopGainRateUp = 5f;

	public float rotorStartStopGainRateDown = 4f;

	public AnimationCurve engineUpDotPitchCurve;

	public AnimationCurve rotorUpDotPitchCurve;

	public Animator animator;

	public SoundDefinition reloadStartSoundDef;

	public SoundDefinition reloadLoopSoundDef;

	public SoundDefinition reloadFinishSoundDef;
}


using System;
using UnityEngine;

[Serializable]
public class FlightSoundLayer
{
	public SoundDefinition loopDefinition;

	public SoundDefinition startDefinition;

	public SoundDefinition stopDefinition;

	public Transform targetParent;

	public float fadeTime = 0.25f;

	public float initialGain = 1f;

	public float gainRateUp = 5f;

	public float gainRateDown = 5f;

	public float gainInterpRate = 0.5f;

	public float initialPitch = 1f;

	public float pitchRateUp = 5f;

	public float pitchRateDown = 5f;

	public float pitchInterpRate = 0.5f;

	public bool returnToInitialWhenTurnedOff;

	public bool useUpDotPitchCurve;

	public AnimationCurve upDotPitchCurve;
}


using System;
using Rust;
using UnityEngine;

public class ScrapTransportHelicopter : PlayerHelicopterWithFlares, TriggerHurtNotChild.IHurtTriggerUser
{
	[Header("Scrap Transport Helicopter Specific")]
	[SerializeField]
	private Transform searchlightEye;

	[SerializeField]
	private BoxCollider parentTriggerCollider;

	[Header("Damage Effects")]
	[SerializeField]
	private ParticleSystemContainer tailDamageLight;

	[SerializeField]
	private ParticleSystemContainer tailDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageLight;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer cockpitSparks;

	[SerializeField]
	private Transform tailDamageLightEffects;

	[SerializeField]
	private Transform mainEngineDamageLightEffects;

	[SerializeField]
	private SoundDefinition damagedFireSoundDef;

	[SerializeField]
	private SoundDefinition damagedFireTailSoundDef;

	[SerializeField]
	private SoundDefinition damagedSparksSoundDef;

	[SerializeField]
	private float pilotRotorScale = 1.5f;

	[SerializeField]
	private float compassOffset;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;

	public const string PASSENGER_ACHIEVEMENT = "RUST_AIR";

	public const int PASSENGER_ACHIEVEMENT_REQ_COUNT = 5;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.inertiaTensor = new Vector3(19082f, 14356f, 7940f);
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (base.isServer)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedNetworking, 0.15f);
		}
	}

	public void DelayedNetworking()
	{
		SendNetworkUpdate();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!GameInfo.HasAchievements || !base.isServer || old.HasFlag(Flags.On) || !next.HasFlag(Flags.On) || !((Object)(object)GetDriver() != (Object)null))
		{
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if ((Object)(object)child.ToPlayer() != (Object)null)
			{
				num++;
			}
			if (child is BaseVehicleSeat baseVehicleSeat && (Object)(object)baseVehicleSeat.GetMounted() != (Object)null && (Object)(object)baseVehicleSeat.GetMounted() != (Object)(object)GetDriver())
			{
				num++;
			}
		}
		if (num >= 5)
		{
			GetDriver().GiveAchievement("RUST_AIR");
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using UnityEngine;

public class ScrapTransportHelicopterWheelEffects : MonoBehaviour, IServerComponent
{
	public WheelCollider wheelCollider;

	public GameObjectRef impactEffect;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	private bool wasGrounded;

	private float lastEffectPlayed;

	private Vector3 lastCollisionPos;

	public void Update()
	{
		bool isGrounded = wheelCollider.isGrounded;
		if (isGrounded && !wasGrounded)
		{
			DoImpactEffect();
		}
		wasGrounded = isGrounded;
	}

	private void DoImpactEffect()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (impactEffect.isValid && !(Time.time < lastEffectPlayed + minTimeBetweenEffects) && (!(Vector3.Distance(((Component)this).transform.position, lastCollisionPos) < minDistBetweenEffects) || lastEffectPlayed == 0f))
		{
			Effect.server.Run(impactEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
			lastEffectPlayed = Time.time;
			lastCollisionPos = ((Component)this).transform.position;
		}
	}
}


using UnityEngine;

public class AnimalRagdoll : Ragdoll
{
	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BaseAnimalRagdoll : BaseCombatEntity
{
	[SerializeField]
	private Ragdoll Ragdoll;

	private EntityRef<BaseCombatEntity> linkedEntity;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (linkedEntity.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = linkedEntity.uid;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	private void LateUpdate()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		BaseCombatEntity baseCombatEntity = linkedEntity.Get(base.isServer);
		if (base.isServer)
		{
			if ((Object)(object)baseCombatEntity == (Object)null || baseCombatEntity.IsDead())
			{
				Kill();
				return;
			}
			((Component)baseCombatEntity).transform.position = ((Component)this).transform.position;
			((Component)baseCombatEntity).transform.rotation = ((Component)this).transform.rotation;
			SendNetworkUpdateImmediate();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)0;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
	}

	public void InitFromEnt(BaseCombatEntity ent)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		linkedEntity.Set(ent);
		ent.model.skeleton.CopyTo(model.skeleton);
		((Component)this).transform.SetPositionAndRotation(((Component)ent).transform.position, ((Component)ent).transform.rotation);
		Ragdoll.ServerInit();
		Vector3 worldVelocity = ent.GetWorldVelocity();
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.AddForce(worldVelocity, (ForceMode)2);
			rigidbody.drag = 0f;
		}
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 5f);
	}

	private void StopRagdolling()
	{
		linkedEntity.Get(serverside: true)?.SetFlag(Flags.Reserved12, b: false);
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		ProcessCollision(collision);
	}

	protected void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	protected void ProcessCollision(Collision collision)
	{
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null) && linkedEntity.Get(serverside: true) is IAnimalRagdollCollisionReceiver animalRagdollCollisionReceiver)
		{
			animalRagdollCollisionReceiver.OnRagdollCollisionEnter(collision);
		}
	}
}


using UnityEngine;

public interface IAnimalRagdollCollisionReceiver
{
	void OnRagdollCollisionEnter(Collision collision);
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Horse Breed", fileName = "newbreed.asset")]
public class HorseBreed : ScriptableObject
{
	public Phrase breedName;

	public Phrase breedDesc;

	public Sprite trophyHeadSprite;

	public Material[] materialOverrides;

	public float maxHealth = 1f;

	public float maxSpeed = 1f;

	public float staminaDrain = 1f;

	public float maxStamina = 1f;
}


using Facepunch;
using ProtoBuf;

public class HorseCorpse : LootableCorpse
{
	public int breedIndex;

	public Phrase lootPanelTitle;

	public override string playerName => lootPanelTitle.translated;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		info.msg.horse.breedIndex = breedIndex;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.horse != null)
		{
			breedIndex = info.msg.horse.breedIndex;
		}
	}
}


using UnityEngine;

public class HorseLeadingRope : FakePhysicsRope
{
	public RidableHorse horse;

	public Vector2 minMaxLength;

	public Vector2 minMaxDistance;
}


using UnityEngine;

public class HorseRagdoll : AnimalRagdoll
{
	public GameObject mane;

	public GameObject woodArmor;

	public GameObject roadsignArmor;

	public GameObject lnyArmor;

	public HorseBreed overrideBreed;

	public GameObject singleSaddle;

	public GameObject doubleSaddle;

	public GameObjectRef breedSource;
}


using UnityEngine;

public class HorseSaddle : BaseVehicleSeat
{
	[SerializeField]
	private bool isDriver;

	[SerializeField]
	private Transform eyePosRef;

	private RidableHorse _owner;

	protected RidableHorse Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<RidableHorse>();
			}
			return _owner;
		}
	}

	public override void VehicleFixedUpdate()
	{
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			BaseVehicle baseVehicle = VehicleParent();
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PlayerMounted(mounted, this);
			}
		}
	}
}


public interface IHorseInputProvider
{
	float GetMoveInput();

	float GetSteerInput();
}


using UnityEngine;

public class AIHorseInputProvider : IHorseInputProvider
{
	private Transform playerTransform;

	private RidableHorse horse;

	private float followSpeed;

	private float stoppingDistance;

	private float turnChangeCooldown = 0.3f;

	private float turnCooldownTimer;

	private float currentSteerInput;

	public AIHorseInputProvider(RidableHorse horse, Transform playerTransform, float stoppingDistance)
	{
		this.horse = horse;
		this.playerTransform = playerTransform;
		this.stoppingDistance = stoppingDistance;
	}

	public float GetMoveInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (horse.GetSpeed() > 2f)
		{
			return -1f;
		}
		if (magnitude > stoppingDistance)
		{
			return Mathf.Clamp(((Component)horse).transform.InverseTransformDirection(((Vector3)(ref val)).normalized).z, 0f, 1f);
		}
		return 0f;
	}

	public float GetSteerInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		if (((Vector3)(ref val)).magnitude > stoppingDistance - 2f)
		{
			Vector3 val2 = Vector3.Cross(((Component)horse).transform.forward, ((Vector3)(ref val)).normalized);
			int num = 0;
			if (val2.y > 0.4f)
			{
				num = 1;
			}
			else if (val2.y < -0.4f)
			{
				num = -1;
			}
			Quaternion val3 = Quaternion.LookRotation(val);
			float num2 = Quaternion.Angle(((Component)horse).transform.rotation, val3);
			if (num2 > 160f && num2 < 180f)
			{
				num = -1;
			}
			if ((float)num != currentSteerInput && turnCooldownTimer <= 0f)
			{
				currentSteerInput = num;
				turnCooldownTimer = turnChangeCooldown;
			}
		}
		else if (currentSteerInput != 0f && turnCooldownTimer <= 0f)
		{
			currentSteerInput = 0f;
			turnCooldownTimer = turnChangeCooldown;
		}
		if (turnCooldownTimer > 0f)
		{
			turnCooldownTimer -= Time.fixedDeltaTime;
		}
		return currentSteerInput;
	}
}


public class PlayerHorseInputProvider : IHorseInputProvider
{
	public BasePlayer player;

	public PlayerHorseInputProvider(BasePlayer player)
	{
		this.player = player;
	}

	public float GetMoveInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.FORWARD))
		{
			result = 1f;
		}
		else if (player.serverInput.IsDown(BUTTON.BACKWARD))
		{
			result = -1f;
		}
		return result;
	}

	public float GetSteerInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.LEFT))
		{
			result = -1f;
		}
		else if (player.serverInput.IsDown(BUTTON.RIGHT))
		{
			result = 1f;
		}
		return result;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[DefaultExecutionOrder(-1302)]
public class RidableHorseAnimation : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	public LegsAnimator legsAnimator;

	[Space]
	[SerializeField]
	private Transform backHipTransform;

	[SerializeField]
	private Vector3 skiddingHipPosition;

	[SerializeField]
	private Vector3 skiddingHipRotation;

	[SerializeField]
	[Range(0f, 1f)]
	[Header("Head")]
	private float headBlend = 1f;

	[ReadOnly]
	public float headSecondaryBlend = 1f;

	public Transform[] neckBones;

	public AnimationCurve rotationResponsivenessCurve;

	public float yawInertiaFactor = 15f;

	public float maxYawAngle = 10f;

	public Vector2 minMaxStiffness;

	public Vector2 minMaxDamping;

	public float headTurnSpeed = 3.5f;

	public Vector3 headLookOffset = Vector3.zero;

	[Range(0f, 1f)]
	[SerializeField]
	[Header("Spine")]
	private float spineBlend = 0.5f;

	[ReadOnly]
	public float spineSecondaryBlend = 1f;

	public Transform[] spineBones;

	public float spineTurnSpeed = 3.5f;

	public float spineYawInertiaFactor = 150f;

	[SerializeField]
	[ReadOnly]
	private Quaternion[] targetNeckRotations;

	[SerializeField]
	[ReadOnly]
	private Quaternion[] targetSpineRotations;

	[ReadOnly]
	[SerializeField]
	private Vector3[] localSpinePositions;

	[ReadOnly]
	[SerializeField]
	private Vector3 originalHipPosition;

	[ReadOnly]
	[SerializeField]
	private Quaternion originalHipRotation;

	public Vector3 spineOffset;

	private float HeadBlend => headBlend * headSecondaryBlend;

	private float SpineBlend => spineBlend * spineSecondaryBlend;
}


using UnityEngine;

public class RidableHorseAudio : FacepunchBehaviour, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	[Space]
	public SoundPlayer breathingSound;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDef;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefWood;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefRoadsign;

	[SerializeField]
	private AnimationCurve saddleMovementGainCurve;

	[SerializeField]
	[Space]
	private MaterialEffect footstepEffects;

	[SerializeField]
	private Transform[] feet;

	[SerializeField]
	[Space]
	private GameObjectRef swimmingSloshEffect;

	[SerializeField]
	private string BaseFolder;

	[SerializeField]
	[Space]
	private SoundDefinition skidLoopSoundDef;

	[SerializeField]
	private AnimationCurve skidLoopGainCurve;
}


using UnityEngine;

[DefaultExecutionOrder(-1300)]
public class RidableHorseSiegeHarness : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private Transform[] targetBone;

	[SerializeField]
	private Transform[] constrainedBone;

	[SerializeField]
	private Vector3 rotationOffset;

	private void LookAtBone(int index)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (targetBone != null && constrainedBone != null)
		{
			Vector3 val = targetBone[index].position - constrainedBone[index].position;
			if (!(val == Vector3.zero))
			{
				Quaternion val2 = Quaternion.LookRotation(val);
				Quaternion val3 = Quaternion.Euler(rotationOffset);
				Quaternion rotation = val2 * val3;
				constrainedBone[index].rotation = rotation;
			}
		}
	}

	private void LateUpdate()
	{
		LookAtBone(0);
		LookAtBone(1);
	}
}


using UnityEngine;

public class SM_DisableHorseProceduralMotion : StateMachineBehaviour
{
}


using UnityEngine;

public class HumanFuelSystem : IFuelSystem
{
	private readonly bool isServer;

	private float percentFood;

	private EntityRef<BaseVehicle> vehilceRef;

	private float pendingFuel;

	public HumanFuelSystem(bool isServer, BaseVehicle owner, float percentFood)
	{
		this.isServer = isServer;
		this.percentFood = Mathf.Clamp01(percentFood);
		vehilceRef.Set(owner);
	}

	public bool HasValidInstance(bool isServer)
	{
		return vehilceRef.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return vehilceRef.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		vehilceRef.uid = uid;
	}

	private BaseVehicle GetVehilce()
	{
		BaseVehicle baseVehicle = vehilceRef.Get(isServer);
		if (baseVehicle.IsValid())
		{
			return baseVehicle;
		}
		return null;
	}

	public int GetFuelCapacity()
	{
		return 0;
	}

	public bool CheckNewChild(BaseEntity child)
	{
		return false;
	}

	public int GetFuelAmount()
	{
		if (TryGetHuman(out var driver))
		{
			float value = driver.metabolism.calories.value;
			float value2 = driver.metabolism.hydration.value;
			return Mathf.FloorToInt(value + value2);
		}
		return 0;
	}

	public float GetFuelFraction()
	{
		if (TryGetHuman(out var driver))
		{
			float num = driver.metabolism.calories.Fraction() * percentFood;
			float num2 = driver.metabolism.hydration.Fraction() * (1f - percentFood);
			return num + num2;
		}
		return 0f;
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (!TryGetHuman(out var driver))
		{
			return false;
		}
		if (percentFood == 0f)
		{
			return driver.metabolism.hydration.Fraction() > 0f;
		}
		if (percentFood == 1f)
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		if (!(driver.metabolism.hydration.Fraction() > 0f))
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		return true;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		if (!TryGetHuman(out var driver))
		{
			return 0;
		}
		pendingFuel += seconds + fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			MetabolismAttribute calories = driver.metabolism.calories;
			MetabolismAttribute hydration = driver.metabolism.hydration;
			float val = fuelUsedPerSecond * percentFood;
			float val2 = fuelUsedPerSecond * (1f - percentFood);
			float value = calories.value;
			calories.Subtract(val);
			pendingFuel -= Mathf.RoundToInt(value - calories.value);
			float value2 = hydration.value;
			hydration.Subtract(val2);
			pendingFuel -= Mathf.RoundToInt(value2 - hydration.value);
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
	}

	public void AddFuel(int amount)
	{
	}

	public void RemoveFuel(int amount)
	{
	}

	public void FillFuel()
	{
	}

	private bool TryGetHuman(out BasePlayer driver)
	{
		driver = null;
		BaseVehicle vehilce = GetVehilce();
		if ((Object)(object)vehilce != (Object)null)
		{
			driver = vehilce.GetDriver();
		}
		return (Object)(object)driver != (Object)null;
	}
}


public interface IFuelSystem
{
	bool HasValidInstance(bool isServer);

	NetworkableId GetInstanceID();

	void SetInstanceID(NetworkableId uid);

	bool CheckNewChild(BaseEntity child);

	int GetFuelAmount();

	float GetFuelFraction();

	bool HasFuel(bool forceCheck = false);

	int TryUseFuel(float seconds, float fuelUsedPerSecond);

	int GetFuelCapacity();

	void LootFuel(BasePlayer player);

	void AddFuel(int amount);

	void RemoveFuel(int amount);

	void FillFuel();
}


public interface IMountable
{
}


using UnityEngine;

public class BaseMagnet : MonoBehaviour
{
	public BaseEntity entityOwner;

	public BaseEntity.Flags magnetFlag = BaseEntity.Flags.Reserved6;

	public TriggerMagnet magnetTrigger;

	public FixedJoint fixedJoint;

	public Rigidbody kinematicAttachmentBody;

	public float magnetForce;

	public Transform attachDepthPoint;

	public GameObjectRef attachEffect;

	public bool isMagnetOn;

	public GameObject colliderSource;

	private BasePlayer associatedPlayer;

	public bool HasConnectedObject()
	{
		if ((Object)(object)((Joint)fixedJoint).connectedBody != (Object)null)
		{
			return isMagnetOn;
		}
		return false;
	}

	public OBB GetConnectedOBB(float scale = 1f)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
		{
			Debug.LogError((object)"BaseMagnet returning fake OBB because no connected body!");
			return new OBB(Vector3.zero, Vector3.one, Quaternion.identity);
		}
		BaseEntity component = ((Component)((Joint)fixedJoint).connectedBody).gameObject.GetComponent<BaseEntity>();
		Bounds bounds = component.bounds;
		((Bounds)(ref bounds)).extents = ((Bounds)(ref bounds)).extents * scale;
		return new OBB(((Component)component).transform.position, ((Component)component).transform.rotation, bounds);
	}

	public void SetCollisionsEnabled(GameObject other, bool wants)
	{
		Collider[] componentsInChildren = other.GetComponentsInChildren<Collider>();
		Collider[] componentsInChildren2 = colliderSource.GetComponentsInChildren<Collider>();
		Collider[] array = componentsInChildren;
		foreach (Collider val in array)
		{
			Collider[] array2 = componentsInChildren2;
			foreach (Collider val2 in array2)
			{
				Physics.IgnoreCollision(val, val2, !wants);
			}
		}
	}

	public virtual void SetMagnetEnabled(bool wantsOn, BasePlayer forPlayer)
	{
		if (isMagnetOn != wantsOn)
		{
			associatedPlayer = forPlayer;
			isMagnetOn = wantsOn;
			if (isMagnetOn)
			{
				OnMagnetEnabled();
			}
			else
			{
				OnMagnetDisabled();
			}
			if ((Object)(object)entityOwner != (Object)null)
			{
				entityOwner.SetFlag(magnetFlag, isMagnetOn);
			}
		}
	}

	public virtual void OnMagnetEnabled()
	{
	}

	public virtual void OnMagnetDisabled()
	{
		if (Object.op_Implicit((Object)(object)((Joint)fixedJoint).connectedBody))
		{
			SetCollisionsEnabled(((Component)((Joint)fixedJoint).connectedBody).gameObject, wants: true);
			Rigidbody connectedBody = ((Joint)fixedJoint).connectedBody;
			((Joint)fixedJoint).connectedBody = null;
			connectedBody.WakeUp();
		}
	}

	public bool IsMagnetOn()
	{
		return isMagnetOn;
	}

	public void MagnetThink(float delta)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (!isMagnetOn)
		{
			return;
		}
		Vector3 position = ((Component)magnetTrigger).transform.position;
		if (magnetTrigger.entityContents == null)
		{
			return;
		}
		OBB val = default(OBB);
		foreach (BaseEntity entityContent in magnetTrigger.entityContents)
		{
			if ((Object)(object)entityContent == (Object)null || !entityContent.syncPosition)
			{
				continue;
			}
			Rigidbody component = ((Component)entityContent).GetComponent<Rigidbody>();
			if ((Object)(object)component == (Object)null || component.isKinematic || entityContent.isClient)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)entityContent).transform.position, ((Component)entityContent).transform.rotation, entityContent.bounds);
			if (((OBB)(ref val)).Contains(attachDepthPoint.position))
			{
				MagnetLiftable component2 = ((Component)entityContent).GetComponent<MagnetLiftable>();
				if ((Object)(object)component2 != (Object)null)
				{
					if (component2.requireObjectOff && entityContent.IsOn())
					{
						continue;
					}
					component2.SetMagnetized(wantsOn: true, this, associatedPlayer);
					if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
					{
						Effect.server.Run(attachEffect.resourcePath, attachDepthPoint.position, -attachDepthPoint.up);
						((Joint)fixedJoint).connectedBody = component;
						SetCollisionsEnabled(((Component)component).gameObject, wants: false);
						continue;
					}
				}
			}
			if ((Object)(object)((Joint)fixedJoint).connectedBody == (Object)null)
			{
				Vector3 position2 = ((Component)entityContent).transform.position;
				float num = Vector3.Distance(position2, position);
				Vector3 val2 = Vector3Ex.Direction(position, position2);
				float num2 = 1f / Mathf.Max(1f, num);
				component.AddForce(val2 * magnetForce * num2, (ForceMode)5);
			}
		}
	}
}


using UnityEngine;

public class IMagnetLiftable : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class MagnetCraneAudio : MonoBehaviour
{
	public MagnetCrane crane;

	[Header("Sound defs")]
	public SoundDefinition engineStartSoundDef;

	public SoundDefinition engineStopSoundDef;

	public BlendedLoopEngineSound engineLoops;

	public SoundDefinition cabinRotationStartDef;

	public SoundDefinition cabinRotationStopDef;

	public SoundDefinition cabinRotationLoopDef;

	private Sound cabinRotationLoop;

	public SoundDefinition turningLoopDef;

	private Sound turningLoop;

	public SoundDefinition trackMovementLoopDef;

	private Sound trackMovementLoop;

	private SoundModulation.Modulator trackGainMod;

	private SoundModulation.Modulator trackPitchMod;

	public SoundDefinition armMovementLoopDef;

	public SoundDefinition armMovementStartDef;

	public SoundDefinition armMovementStopDef;

	private Sound armMovementLoop01;

	private SoundModulation.Modulator armMovementLoop01PitchMod;

	public GameObject arm01SoundPosition;

	public GameObject arm02SoundPosition;

	private Sound armMovementLoop02;

	private SoundModulation.Modulator armMovementLoop02PitchMod;
}


using UnityEngine;

public class MagnetLiftable : EntityComponent<BaseEntity>
{
	public ItemAmount[] shredResources;

	public bool scaleScrapResourcesByHealth;

	public Vector3 shredDirection = Vector3.forward;

	public bool requireObjectOff;

	public BasePlayer associatedPlayer { get; private set; }

	public virtual void SetMagnetized(bool wantsOn, BaseMagnet magnetSource, BasePlayer player)
	{
		associatedPlayer = player;
	}
}


using UnityEngine;

public class TriggerMagnet : TriggerBase
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.syncPosition)
		{
			return null;
		}
		if (!Object.op_Implicit((Object)(object)((Component)baseEntity).GetComponent<MagnetLiftable>()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class MapMarkerMLRSRocket : MapMarker
{
	public RectTransform uiMarkerTransform;

	public override void ServerInit()
	{
		base.ServerInit();
		base.limitNetworking = true;
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		return (ulong)player.userID == base.OwnerID;
	}
}


using UnityEngine;

public class MLRSAmmoIcon : MonoBehaviour
{
	[SerializeField]
	private GameObject fill;

	protected void Awake()
	{
		SetState(filled: false);
	}

	public void SetState(bool filled)
	{
		fill.SetActive(filled);
	}
}


using Rust.UI;
using UnityEngine;

public class MLRSAmmoUI : MonoBehaviour
{
	[SerializeField]
	private RustText ammoText;

	[SerializeField]
	private MLRSAmmoIcon[] ammoIcons;
}


using UnityEngine;

public class MLRSAudio : MonoBehaviour
{
	[SerializeField]
	private MLRS mlrs;

	[SerializeField]
	private Transform pitchTransform;

	[SerializeField]
	private Transform yawTransform;

	[SerializeField]
	private float pitchDeltaSmoothRate = 5f;

	[SerializeField]
	private float yawDeltaSmoothRate = 5f;

	[SerializeField]
	private float pitchDeltaThreshold = 0.5f;

	[SerializeField]
	private float yawDeltaThreshold = 0.5f;

	private float lastPitch;

	private float lastYaw;

	private float pitchDelta;

	private float yawDelta;

	public SoundDefinition turretMovementStartDef;

	public SoundDefinition turretMovementLoopDef;

	public SoundDefinition turretMovementStopDef;

	private Sound turretMovementLoop;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class MLRSMainUI : MonoBehaviour
{
	[SerializeField]
	private bool isFullscreen;

	[SerializeField]
	private GameObject noAimingModuleModeGO;

	[SerializeField]
	private GameObject activeModeGO;

	[SerializeField]
	private MLRSAmmoUI noAimingModuleAmmoUI;

	[SerializeField]
	private MLRSAmmoUI activeAmmoUI;

	[SerializeField]
	private MLRSVelocityUI velocityUI;

	[SerializeField]
	private RustText titleText;

	[SerializeField]
	private RustText usernameText;

	[SerializeField]
	private TokenisedPhrase readyStatus;

	[SerializeField]
	private TokenisedPhrase realigningStatus;

	[SerializeField]
	private TokenisedPhrase firingStatus;

	[SerializeField]
	private RustText statusText;

	[SerializeField]
	private MapView mapView;

	[SerializeField]
	private ScrollRectEx mapScrollRect;

	[SerializeField]
	private ScrollRectZoom mapScrollRectZoom;

	[SerializeField]
	private RectTransform mapBaseRect;

	[SerializeField]
	private RectTransform minRangeCircle;

	[SerializeField]
	private RectTransform targetAimRect;

	[SerializeField]
	private RectTransform trueAimRect;

	[SerializeField]
	private UILineRenderer connectingLine;

	[SerializeField]
	private GameObject noTargetCirclePrefab;

	[SerializeField]
	private Transform noTargetCircleParent;

	[SerializeField]
	private SoundDefinition changeTargetSoundDef;

	[SerializeField]
	private SoundDefinition readyToFireSoundDef;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MLRSRocket : TimedExplosive, SamSite.ISamSiteTarget
{
	[SerializeField]
	private GameObjectRef mapMarkerPrefab;

	[SerializeField]
	private GameObjectRef launchBlastFXPrefab;

	[SerializeField]
	private GameObjectRef explosionGroundFXPrefab;

	[SerializeField]
	private ServerProjectile serverProjectile;

	private EntityRef mapMarkerInstanceRef;

	public static List<MLRSRocket> serverList = new List<MLRSRocket>();

	public SamSite.SamTargetType SAMTargetType => SamSite.targetTypeMissile;

	public override void ServerInit()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		serverList.Add(this);
		CreateMapMarker();
		Effect.server.Run(launchBlastFXPrefab.resourcePath, PivotPoint(), ((Component)this).transform.up, null, broadcast: true);
	}

	internal override void DoServerDestroy()
	{
		serverList.Remove(this);
		base.DoServerDestroy();
	}

	public override void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Explode(rayOrigin);
		if (Physics.Raycast(((RaycastHit)(ref info)).point + Vector3.up, Vector3.down, 4f, 1084293393, (QueryTriggerInteraction)1))
		{
			Effect.server.Run(explosionGroundFXPrefab.resourcePath, ((RaycastHit)(ref info)).point, Vector3.up, null, broadcast: true);
		}
	}

	private void CreateMapMarker()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = mapMarkerInstanceRef.Get(base.isServer);
		if (baseEntity.IsValid())
		{
			baseEntity.Kill();
		}
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(mapMarkerPrefab?.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity2.OwnerID = base.OwnerID;
		baseEntity2.Spawn();
		baseEntity2.SetParent(this, worldPositionStays: true);
		mapMarkerInstanceRef.Set(baseEntity2);
	}

	public bool IsValidSAMTarget(bool staticRespawn)
	{
		return !staticRespawn;
	}

	public override Vector3 GetLocalVelocityServer()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return serverProjectile.CurrentVelocity;
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.IsOnLayer((Layer)18))
		{
			return;
		}
		if (((Component)other).CompareTag("MLRSRocketTrigger"))
		{
			Explode();
			TimedExplosive componentInParent = ((Component)other).GetComponentInParent<TimedExplosive>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				componentInParent.Explode();
			}
		}
		else if ((Object)(object)((Component)other).GetComponent<TriggerSafeZone>() != (Object)null)
		{
			Kill();
		}
	}
}


public class MLRSServerProjectile : ServerProjectile
{
	public override bool HasRangeLimit => false;

	protected override int mask => 1235954449;

	protected override bool IsAValidHit(BaseEntity hitEnt)
	{
		if (!base.IsAValidHit(hitEnt))
		{
			return false;
		}
		if (hitEnt.IsValid())
		{
			return !(hitEnt is MLRS);
		}
		return true;
	}
}


using UnityEngine;

public class MLRSUIDialog : UIDialog
{
	[SerializeField]
	private MLRSMainUI mainUI;

	[SerializeField]
	private TokenisedPhrase howToUsePhrase;

	[SerializeField]
	private float titleChangeInterval = 2f;
}


using Rust.UI;
using UnityEngine;

public class MLRSVelocityUI : MonoBehaviour
{
	[SerializeField]
	private RustText percentText;

	[SerializeField]
	private HudElement percentBar;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Modular;
using UnityEngine;

public abstract class BaseModularVehicle : GroundVehicle, IPrefabPreProcess, PlayerInventory.ICanMoveFrom
{
	[Header("Modular Vehicle")]
	[SerializeField]
	public List<ModularVehicleSocket> moduleSockets;

	[SerializeField]
	public Transform centreOfMassTransform;

	[SerializeField]
	public Transform waterSample;

	[SerializeField]
	public LODGroup lodGroup;

	public GameObjectRef keyEnterDialog;

	private float _mass = -1f;

	public const Flags FLAG_KINEMATIC = Flags.Reserved6;

	public Dictionary<BaseVehicleModule, Action> moduleAddActions = new Dictionary<BaseVehicleModule, Action>();

	public bool inEditableLocation;

	public bool prevEditable;

	public bool immuneToDecay;

	public Vector3 realLocalCOM;

	public Item AssociatedItemInstance;

	private bool disablePhysics;

	public Vector3 CentreOfMass => centreOfMassTransform.localPosition;

	public int NumAttachedModules => AttachedModuleEntities.Count;

	public bool HasAnyModules => AttachedModuleEntities.Count > 0;

	public List<BaseVehicleModule> AttachedModuleEntities { get; } = new List<BaseVehicleModule>();

	public int TotalSockets => moduleSockets.Count;

	public int NumFreeSockets
	{
		get
		{
			int num = 0;
			for (int i = 0; i < NumAttachedModules; i++)
			{
				num += AttachedModuleEntities[i].GetNumSocketsTaken();
			}
			return TotalSockets - num;
		}
	}

	private float Mass
	{
		get
		{
			if (base.isServer)
			{
				return rigidBody.mass;
			}
			return _mass;
		}
	}

	public float TotalMass { get; set; }

	public bool IsKinematic => HasFlag(Flags.Reserved6);

	public virtual bool IsLockable => false;

	public bool HasInited { get; private set; }

	public ItemDefinition AssociatedItemDef => repair.itemTarget;

	public bool IsEditableNow
	{
		get
		{
			if (base.isServer)
			{
				if (inEditableLocation)
				{
					return CouldBeEdited();
				}
				return false;
			}
			return false;
		}
	}

	public ModularVehicleInventory Inventory { get; set; }

	public override void InitShared()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		AddMass(Mass, CentreOfMass, ((Component)this).transform.position);
		HasInited = true;
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			attachedModuleEntity.RefreshConditionals(canGib: false);
		}
	}

	public virtual bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType)
	{
		return true;
	}

	public bool TryDeduceSocketIndex(BaseVehicleModule addedModule, out int index)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (addedModule.FirstSocketIndex >= 0)
		{
			index = addedModule.FirstSocketIndex;
			return index >= 0;
		}
		index = -1;
		for (int i = 0; i < moduleSockets.Count; i++)
		{
			if (Vector3.SqrMagnitude(moduleSockets[i].WorldPosition - ((Component)addedModule).transform.position) < 0.1f)
			{
				index = i;
				return true;
			}
		}
		return false;
	}

	public void AddMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(moduleWorldPos) + moduleCOM;
			if (TotalMass == 0f)
			{
				SetMass(moduleMass);
				SetCOM(val);
				return;
			}
			float num = TotalMass + moduleMass;
			Vector3 cOM = realLocalCOM * (TotalMass / num) + val * (moduleMass / num);
			SetMass(num);
			SetCOM(cOM);
		}
	}

	public void RemoveMass(float moduleMass, Vector3 moduleCOM, Vector3 moduleWorldPos)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			float num = TotalMass - moduleMass;
			Vector3 val = ((Component)this).transform.InverseTransformPoint(moduleWorldPos) + moduleCOM;
			Vector3 cOM = (realLocalCOM - val * (moduleMass / TotalMass)) / (num / TotalMass);
			SetMass(num);
			SetCOM(cOM);
		}
	}

	public bool TryGetModuleAt(int socketIndex, out BaseVehicleModule result)
	{
		if (socketIndex < 0 || socketIndex >= moduleSockets.Count)
		{
			result = null;
			return false;
		}
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			int firstSocketIndex = attachedModuleEntity.FirstSocketIndex;
			int num = firstSocketIndex + attachedModuleEntity.GetNumSocketsTaken() - 1;
			if (firstSocketIndex <= socketIndex && num >= socketIndex)
			{
				result = attachedModuleEntity;
				return true;
			}
		}
		result = null;
		return false;
	}

	public ModularVehicleSocket GetSocket(int index)
	{
		if (index < 0 || index >= moduleSockets.Count)
		{
			return null;
		}
		return moduleSockets[index];
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.modularVehicle;
	}

	public override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (!IsKinematic)
		{
			return !IsEditableNow;
		}
		return false;
	}

	public override void OnChildAdded(BaseEntity childEntity)
	{
		base.OnChildAdded(childEntity);
		BaseVehicleModule module = childEntity as BaseVehicleModule;
		if (module != null)
		{
			Action action = delegate
			{
				ModuleEntityAdded(module);
			};
			moduleAddActions[module] = action;
			((FacepunchBehaviour)module).Invoke(action, 0f);
		}
	}

	public override void OnChildRemoved(BaseEntity childEntity)
	{
		base.OnChildRemoved(childEntity);
		if (childEntity is BaseVehicleModule removedModule)
		{
			ModuleEntityRemoved(removedModule);
		}
	}

	public virtual void ModuleEntityAdded(BaseVehicleModule addedModule)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if (AttachedModuleEntities.Contains(addedModule))
		{
			return;
		}
		if (base.isServer && ((Object)(object)this == (Object)null || IsDead() || base.IsDestroyed))
		{
			if ((Object)(object)addedModule != (Object)null && !addedModule.IsDestroyed)
			{
				addedModule.Kill();
			}
			return;
		}
		int index = -1;
		if (base.isServer && addedModule.AssociatedItemInstance != null)
		{
			index = addedModule.AssociatedItemInstance.position;
		}
		if (index == -1 && !TryDeduceSocketIndex(addedModule, out index))
		{
			string text = $"{((object)this).GetType().Name}: Couldn't get socket index from position ({((Component)addedModule).transform.position}).";
			for (int i = 0; i < moduleSockets.Count; i++)
			{
				text += $" Sqr dist to socket {i} at {moduleSockets[i].WorldPosition} is {Vector3.SqrMagnitude(moduleSockets[i].WorldPosition - ((Component)addedModule).transform.position)}.";
			}
			Debug.LogError((object)text, (Object)(object)((Component)addedModule).gameObject);
			return;
		}
		if (moduleAddActions.ContainsKey(addedModule))
		{
			moduleAddActions.Remove(addedModule);
		}
		AttachedModuleEntities.Add(addedModule);
		addedModule.ModuleAdded(this, index);
		AddMass(addedModule.Mass, addedModule.CentreOfMass, ((Component)addedModule).transform.position);
		if (base.isServer && !Inventory.TrySyncModuleInventory(addedModule, index))
		{
			Debug.LogError((object)$"{((object)this).GetType().Name}: Unable to add module {((Object)addedModule).name} to socket ({index}). Destroying it.", (Object)(object)((Component)this).gameObject);
			addedModule.Kill();
			AttachedModuleEntities.Remove(addedModule);
			return;
		}
		RefreshModulesExcept(addedModule);
		if (base.isServer)
		{
			UpdateMountFlags();
		}
	}

	public virtual void ModuleEntityRemoved(BaseVehicleModule removedModule)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (base.IsDestroyed)
		{
			return;
		}
		if (moduleAddActions.ContainsKey(removedModule))
		{
			((FacepunchBehaviour)removedModule).CancelInvoke(moduleAddActions[removedModule]);
			moduleAddActions.Remove(removedModule);
		}
		if (AttachedModuleEntities.Contains(removedModule))
		{
			RemoveMass(removedModule.Mass, removedModule.CentreOfMass, ((Component)removedModule).transform.position);
			AttachedModuleEntities.Remove(removedModule);
			removedModule.ModuleRemoved();
			RefreshModulesExcept(removedModule);
			if (base.isServer)
			{
				UpdateMountFlags();
			}
		}
	}

	public void RefreshModulesExcept(BaseVehicleModule ignoredModule)
	{
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			if ((Object)(object)attachedModuleEntity != (Object)(object)ignoredModule)
			{
				attachedModuleEntity.OtherVehicleModulesChanged();
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!disablePhysics)
		{
			rigidBody.isKinematic = false;
		}
		prevEditable = IsEditableNow;
		if (Inventory == null)
		{
			Inventory = new ModularVehicleInventory(this, AssociatedItemDef, giveUID: true);
		}
	}

	public override void PreServerLoad()
	{
		base.PreServerLoad();
		if (Inventory == null)
		{
			Inventory = new ModularVehicleInventory(this, AssociatedItemDef, giveUID: false);
		}
	}

	public override void PostServerLoad()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (Inventory != null)
		{
			ItemContainerId uID = Inventory.UID;
			if (!((ItemContainerId)(ref uID)).IsValid)
			{
				Inventory.GiveUIDs();
			}
		}
		SetFlag(Flags.Open, b: false);
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (Inventory != null)
		{
			Inventory.Dispose();
			Inventory = null;
		}
	}

	public override float AntiHackVelocity()
	{
		return Mathf.Max(GetMaxForwardSpeed() * 1.3f, 30f);
	}

	public abstract bool IsComplete();

	public bool CouldBeEdited()
	{
		if (!AnyMounted())
		{
			return !IsDead();
		}
		return false;
	}

	public void DisablePhysics()
	{
		disablePhysics = true;
		rigidBody.isKinematic = true;
	}

	public void EnablePhysics()
	{
		disablePhysics = false;
		rigidBody.isKinematic = false;
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BaseModularVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (IsEditableNow != prevEditable)
			{
				SendNetworkUpdate();
				prevEditable = IsEditableNow;
			}
			SetFlag(Flags.Reserved6, rigidBody.isKinematic);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool MountEligable(BasePlayer player)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!base.MountEligable(player))
		{
			return false;
		}
		if (IsDead())
		{
			return false;
		}
		if (HasDriver())
		{
			Vector3 velocity = base.Velocity;
			if (((Vector3)(ref velocity)).magnitude >= 2f)
			{
				return false;
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.modularVehicle = Pool.Get<ModularVehicle>();
		info.msg.modularVehicle.editable = IsEditableNow;
	}

	public PlayerInventory.CanMoveFromResponse CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", (object)moduleForItem, (object)this, (object)player);
			if (obj is PlayerInventory.CanMoveFromResponse)
			{
				return (PlayerInventory.CanMoveFromResponse)obj;
			}
			return new PlayerInventory.CanMoveFromResponse(moduleForItem.CanBeMovedNow(), moduleForItem.CannotBeMovedNowReason());
		}
		return PlayerInventory.CanMoveFromResponse.Success();
	}

	protected abstract Vector3 GetCOMMultiplier();

	public virtual void ModuleHurt(BaseVehicleModule hurtModule, HitInfo info)
	{
		DoExplosionForce(info);
	}

	public abstract void ModuleReachedZeroHealth();

	public bool TryAddModule(Item moduleItem, int socketIndex)
	{
		if (!ModuleCanBeAdded(moduleItem, socketIndex, out var failureReason))
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Can't add module: " + failureReason));
			return false;
		}
		bool num = Inventory.TryAddModuleItem(moduleItem, socketIndex);
		if (!num)
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Couldn't add new item!"));
		}
		return num;
	}

	public bool TryAddModule(Item moduleItem)
	{
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		int socketsTaken = component.socketsTaken;
		int num = Inventory.TryGetFreeSocket(socketsTaken);
		if (num < 0)
		{
			return false;
		}
		return TryAddModule(moduleItem, num);
	}

	public bool ModuleCanBeAdded(Item moduleItem, int socketIndex, out string failureReason)
	{
		if (!base.isServer)
		{
			failureReason = "Can only add modules on server";
			return false;
		}
		if (moduleItem == null)
		{
			failureReason = "Module item is null";
			return false;
		}
		if (moduleItem.info.category != ItemCategory.Component)
		{
			failureReason = "Not a component type item";
			return false;
		}
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if ((Object)(object)component == (Object)null)
		{
			failureReason = "Not the right item module type";
			return false;
		}
		int socketsTaken = component.socketsTaken;
		if (socketIndex < 0)
		{
			socketIndex = Inventory.TryGetFreeSocket(socketsTaken);
		}
		if (!Inventory.SocketsAreFree(socketIndex, socketsTaken, moduleItem))
		{
			failureReason = "One or more desired sockets already in use";
			return false;
		}
		failureReason = string.Empty;
		return true;
	}

	public BaseVehicleModule CreatePhysicalModuleEntity(Item moduleItem, ItemModVehicleModule itemModModule, int socketIndex)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldPosition = moduleSockets[socketIndex].WorldPosition;
		Quaternion worldRotation = moduleSockets[socketIndex].WorldRotation;
		BaseVehicleModule baseVehicleModule = itemModModule.CreateModuleEntity(this, worldPosition, worldRotation);
		baseVehicleModule.AssociatedItemInstance = moduleItem;
		SetUpModule(baseVehicleModule, moduleItem);
		return baseVehicleModule;
	}

	public void SetUpModule(BaseVehicleModule moduleEntity, Item moduleItem)
	{
		moduleEntity.InitializeHealth(moduleItem.condition, moduleItem.maxCondition);
		if (moduleItem.condition < moduleItem.maxCondition)
		{
			moduleEntity.SendNetworkUpdate();
		}
	}

	public Item GetVehicleItem(ItemId itemUID)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Item item = Inventory.ChassisContainer.FindItemByUID(itemUID);
		if (item == null)
		{
			item = Inventory.ModuleContainer.FindItemByUID(itemUID);
		}
		return item;
	}

	public BaseVehicleModule GetModuleForItem(Item item)
	{
		if (item == null)
		{
			return null;
		}
		foreach (BaseVehicleModule attachedModuleEntity in AttachedModuleEntities)
		{
			if (attachedModuleEntity.AssociatedItemInstance == item)
			{
				return attachedModuleEntity;
			}
		}
		return null;
	}

	public void SetMass(float mass)
	{
		TotalMass = mass;
		rigidBody.mass = TotalMass;
	}

	public void SetCOM(Vector3 com)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		realLocalCOM = com;
		rigidBody.centerOfMass = Vector3.Scale(realLocalCOM, GetCOMMultiplier());
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "Engine Audio Preset", menuName = "Scriptable Object/Vehicles/Engine Audio Preset")]
public class EngineAudioSet : ScriptableObject
{
	public BlendedEngineLoopDefinition[] engineAudioLoops;

	public int priority;

	public float idleRpm = 600f;

	public float gearUpRpm = 5000f;

	public float gearDownRpm = 2500f;

	public int numGears = 5;

	public float minRpm = 10f;

	public float maxRpm = 6000f;

	public float gearUpRpmRate = 5f;

	public float gearDownRpmRate = 6f;

	public SoundDefinition badPerformanceLoop;

	public BlendedEngineLoopDefinition GetEngineLoopDef(int numEngines)
	{
		int num = (numEngines - 1) % engineAudioLoops.Length;
		return engineAudioLoops[num];
	}
}


using UnityEngine;

public class GlassPane : BaseMonoBehaviour, IClientComponent
{
	public Renderer glassRendereer;

	[SerializeField]
	private BaseVehicleModule module;

	[SerializeField]
	private float showFullDamageAt = 0.75f;
}


using UnityEngine;

public class MagnetSnap
{
	private Transform snapLocation;

	private Vector3 prevSnapLocation;

	public MagnetSnap(Transform snapLocation)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		this.snapLocation = snapLocation;
		prevSnapLocation = snapLocation.position;
	}

	public void FixedUpdate(Transform target)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		PositionTarget(target);
		if (snapLocation.hasChanged)
		{
			prevSnapLocation = snapLocation.position;
			snapLocation.hasChanged = false;
		}
	}

	public void PositionTarget(Transform target)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null))
		{
			Transform transform = ((Component)target).transform;
			Quaternion val = snapLocation.rotation;
			if (Vector3.Angle(transform.forward, snapLocation.forward) > 90f)
			{
				val *= Quaternion.Euler(0f, 180f, 0f);
			}
			if (transform.position != snapLocation.position)
			{
				transform.position += snapLocation.position - prevSnapLocation;
				transform.position = Vector3.MoveTowards(transform.position, snapLocation.position, 1f * Time.fixedDeltaTime);
			}
			if (transform.rotation != val)
			{
				transform.rotation = Quaternion.RotateTowards(transform.rotation, val, 40f * Time.fixedDeltaTime);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ModularCarCentralLockingSwitch : VehicleModuleButtonComponent
{
	public Transform centralLockingSwitch;

	public Vector3 switchOffPos;

	public Vector3 switchOnPos;

	public override void ServerUse(BasePlayer player, BaseVehicleModule parentModule)
	{
		if (parentModule.Vehicle is ModularCar modularCar)
		{
			modularCar.CarLock.ToggleCentralLocking();
		}
	}
}


using System;
using UnityEngine;

public class ModularCarChassisVisuals : VehicleChassisVisuals<ModularCar>, IClientComponent
{
	[Serializable]
	public class Steering
	{
		public Transform steerL;

		public Transform steerR;

		public LookAtTarget steerRodL;

		public LookAtTarget steerRodR;

		public LookAtTarget steeringArm;
	}

	[Serializable]
	public class LookAtTarget
	{
		public Transform aim;

		public Transform target;

		public Vector3 angleAdjust;
	}

	public Transform frontAxle;

	public Transform rearAxle;

	public Steering steering;

	public LookAtTarget transmission;
}


using System;
using UnityEngine;

[Serializable]
public class Steering
{
	public Transform steerL;

	public Transform steerR;

	public LookAtTarget steerRodL;

	public LookAtTarget steerRodR;

	public LookAtTarget steeringArm;
}


using System;
using UnityEngine;

[Serializable]
public class LookAtTarget
{
	public Transform aim;

	public Transform target;

	public Vector3 angleAdjust;
}


public interface IVehicleLockUser
{
	bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule);

	bool PlayerHasUnlockPermission(BasePlayer player);

	bool PlayerCanUseThis(BasePlayer player, ModularCarCodeLock.LockType lockType);

	void RemoveLock();
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class ModularCarCodeLock
{
	public enum LockType
	{
		Door,
		General
	}

	private readonly bool isServer;

	public readonly ModularCar owner;

	public const BaseEntity.Flags FLAG_CENTRAL_LOCKING = BaseEntity.Flags.Reserved2;

	public const BaseEntity.Flags FLAG_CODE_ENTRY_BLOCKED = BaseEntity.Flags.Reserved10;

	public const float LOCK_DESTROY_HEALTH = 0.2f;

	private List<ulong> whitelistPlayers = new List<ulong>();

	private int wrongCodes;

	private float lastWrongTime = float.NegativeInfinity;

	public bool HasALock
	{
		get
		{
			if (isServer)
			{
				return !string.IsNullOrEmpty(Code);
			}
			return false;
		}
	}

	public bool CentralLockingIsOn
	{
		get
		{
			if ((Object)(object)owner != (Object)null)
			{
				return owner.HasFlag(BaseEntity.Flags.Reserved2);
			}
			return false;
		}
	}

	public IList<ulong> WhitelistPlayers => whitelistPlayers.AsReadOnly();

	public string Code { get; private set; } = "";

	public ModularCarCodeLock(ModularCar owner, bool isServer)
	{
		this.owner = owner;
		this.isServer = isServer;
		if (isServer)
		{
			CheckEnableCentralLocking();
		}
	}

	public bool PlayerCanDestroyLock(BaseVehicleModule viaModule)
	{
		if (!HasALock)
		{
			return false;
		}
		return viaModule.healthFraction <= 0.2f;
	}

	public bool CodeEntryBlocked(BasePlayer player)
	{
		if (!HasALock)
		{
			return true;
		}
		if (HasLockPermission(player))
		{
			return false;
		}
		if ((Object)(object)owner != (Object)null)
		{
			return owner.HasFlag(BaseEntity.Flags.Reserved10);
		}
		return false;
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		Code = info.msg.modularCar.lockCode;
		if (Code == null)
		{
			Code = "";
		}
		whitelistPlayers.Clear();
		whitelistPlayers.AddRange(info.msg.modularCar.whitelistUsers);
	}

	public bool HasLockPermission(ulong steamId)
	{
		if (!HasALock)
		{
			return true;
		}
		return whitelistPlayers.Contains(steamId);
	}

	public bool HasLockPermission(BasePlayer player)
	{
		if (!player.IsValid() || player.IsDead())
		{
			return false;
		}
		object obj = Interface.CallHook("CanLock", (object)player, (object)owner, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasLockPermission(player.userID);
	}

	public bool PlayerCanUseThis(BasePlayer player, LockType lockType)
	{
		if (lockType == LockType.Door && !CentralLockingIsOn)
		{
			return true;
		}
		return HasLockPermission(player);
	}

	public void PostServerLoad()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved10, b: false);
		CheckEnableCentralLocking();
	}

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", (object)this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

	public bool TryAddALock(string code, ulong userID)
	{
		if (!isServer)
		{
			return false;
		}
		if (owner.IsDead())
		{
			return false;
		}
		TrySetNewCode(code, userID);
		return HasALock;
	}

	public bool IsValidLockCode(string code)
	{
		if (code != null && code.Length == 4)
		{
			return StringEx.IsNumeric(code);
		}
		return false;
	}

	public bool TrySetNewCode(string newCode, ulong userID)
	{
		if (!IsValidLockCode(newCode))
		{
			return false;
		}
		Code = newCode;
		whitelistPlayers.Clear();
		whitelistPlayers.Add(userID);
		owner.SendNetworkUpdate();
		return true;
	}

	public void RemoveLock()
	{
		if (isServer && HasALock)
		{
			Code = "";
			owner.SendNetworkUpdate();
		}
	}

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", (object)player, (object)this, (object)codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				((FacepunchBehaviour)owner).Invoke((Action)ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (TryAddPlayer(player.userID))
		{
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

	private void ClearCodeEntryBlocked()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved10, b: false);
		wrongCodes = 0;
	}

	public void CheckEnableCentralLocking()
	{
		if (CentralLockingIsOn)
		{
			return;
		}
		bool flag = false;
		foreach (BaseVehicleModule attachedModuleEntity in owner.AttachedModuleEntities)
		{
			if (attachedModuleEntity is VehicleModuleSeating vehicleModuleSeating && vehicleModuleSeating.HasADriverSeat() && vehicleModuleSeating.AnyMounted())
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			owner.SetFlag(BaseEntity.Flags.Reserved2, b: true);
		}
	}

	public void ToggleCentralLocking()
	{
		owner.SetFlag(BaseEntity.Flags.Reserved2, !CentralLockingIsOn);
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		info.msg.modularCar.hasLock = HasALock;
		if (info.forDisk)
		{
			info.msg.modularCar.lockCode = Code;
		}
		info.msg.modularCar.whitelistUsers = Pool.Get<List<ulong>>();
		info.msg.modularCar.whitelistUsers.AddRange(whitelistPlayers);
	}

	public bool TryAddPlayer(ulong userID)
	{
		if (!whitelistPlayers.Contains(userID))
		{
			whitelistPlayers.Add(userID);
			return true;
		}
		return false;
	}

	public bool TryRemovePlayer(ulong userID)
	{
		return whitelistPlayers.Remove(userID);
	}
}


public enum LockType
{
	Door,
	General
}


using System;
using UnityEngine;

[Serializable]
public class ModularCarCodeLockVisuals : MonoBehaviour
{
	[SerializeField]
	private GameObject lockedVisuals;

	[SerializeField]
	private GameObject unlockedVisuals;

	[SerializeField]
	private GameObject blockedVisuals;

	[SerializeField]
	private GameObjectRef codelockEffectDenied;

	[SerializeField]
	private GameObjectRef codelockEffectShock;

	[SerializeField]
	private float xOffset = 0.91f;

	[SerializeField]
	private ParticleSystemContainer keycodeDestroyableFX;
}


using Rust;
using UnityEngine;

public class VehicleLiftOccupantTrigger : TriggerBase
{
	public ModularCar carOccupant { get; private set; }

	protected override void OnDisable()
	{
		if (!Application.isQuitting)
		{
			base.OnDisable();
			if ((Object)(object)carOccupant != (Object)null)
			{
				carOccupant = null;
			}
		}
	}

	internal override GameObject InterestedInObject(GameObject obj)
	{
		if ((Object)(object)base.InterestedInObject(obj) == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null || baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is ModularCar))
		{
			return null;
		}
		return obj;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)carOccupant == (Object)null && ent.isServer)
		{
			carOccupant = (ModularCar)ent;
		}
	}

	internal override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (!((Object)(object)carOccupant == (Object)(object)ent))
		{
			return;
		}
		carOccupant = null;
		if (entityContents == null || entityContents.Count <= 0)
		{
			return;
		}
		foreach (BaseEntity entityContent in entityContents)
		{
			if ((Object)(object)entityContent != (Object)null)
			{
				carOccupant = (ModularCar)entityContent;
				break;
			}
		}
	}
}


using Rust.Modular;
using UnityEngine;

[CreateAssetMenu(fileName = "Modular Car Preset", menuName = "Scriptable Object/Vehicles/Modular Car Preset")]
public class ModularCarPresetConfig : ScriptableObject
{
	public ItemModVehicleModule[] socketItemDefs;
}


using System;
using Oxide.Core;
using UnityEngine;

public class ModularCarSeat : MouseSteerableSeat
{
	[SerializeField]
	public Vector3 leftFootIKPos;

	[SerializeField]
	public Vector3 rightFootIKPos;

	[SerializeField]
	private Vector3 leftHandIKPos;

	[SerializeField]
	private Vector3 rightHandIKPos;

	public float providesComfort;

	[NonSerialized]
	public VehicleModuleSeating associatedSeatingModule;

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if ((Object)(object)modularCar != (Object)null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

	public override float GetComfort()
	{
		return providesComfort;
	}
}


using UnityEngine;

public class ModularVehicleShopFront : ShopFront
{
	[SerializeField]
	public float maxUseDistance = 1.5f;

	public override bool CanBeLooted(BasePlayer player)
	{
		if (WithinUseDistance(player))
		{
			return base.CanBeLooted(player);
		}
		return false;
	}

	public bool WithinUseDistance(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Distance(player.eyes.position) <= maxUseDistance;
	}
}


using UnityEngine;

public class CamperSeatConfig : MonoBehaviour
{
	public Transform[] SeatPositions;

	public Transform StovePosition;

	public Transform StoragePosition;
}


using UnityEngine;

public abstract class VehicleModuleButtonComponent : MonoBehaviour
{
	public string interactionColliderName = "MyCollider";

	public SoundDefinition pressSoundDef;

	public abstract void ServerUse(BasePlayer player, BaseVehicleModule parentModule);
}


using System;
using Oxide.Core;
using Rust;
using Rust.Modular;
using UnityEngine;

public class VehicleModuleEngine : VehicleModuleStorage
{
	[Serializable]
	public class Engine
	{
		[Header("Engine Stats")]
		public int engineKW;

		public float idleFuelPerSec = 0.25f;

		public float maxFuelPerSec = 0.25f;

		[Header("Engine Audio")]
		public EngineAudioSet audioSet;

		[Header("Engine FX")]
		public ParticleSystemContainer[] engineParticles;

		public ParticleSystem[] exhaustSmoke;

		public ParticleSystem[] exhaustBackfire;

		public float exhaustSmokeMinOpacity = 0.1f;

		public float exhaustSmokeMaxOpacity = 0.7f;

		public float exhaustSmokeChangeRate = 0.5f;
	}

	[SerializeField]
	public Engine engine;

	private const float FORCE_MULTIPLIER = 12.75f;

	private const float HEALTH_PERFORMANCE_FRACTION = 0.25f;

	private const float LOW_PERFORMANCE_THRESHOLD = 0.5f;

	private Sound badPerformanceLoop;

	private SoundModulation.Modulator badPerformancePitchModulator;

	private float prevSmokePercent;

	private const float MIN_FORCE_BIAS = 0.0002f;

	private const float MAX_FORCE_BIAS = 0.7f;

	public override bool HasAnEngine => true;

	public bool IsUsable { get; set; }

	public float PerformanceFractionAcceleration { get; set; }

	public float PerformanceFractionTopSpeed { get; set; }

	public float PerformanceFractionFuelEconomy { get; set; }

	public float OverallPerformanceFraction { get; set; }

	public bool AtLowPerformance => OverallPerformanceFraction <= 0.5f;

	public bool AtPeakPerformance => Mathf.Approximately(OverallPerformanceFraction, 1f);

	public int KW => engine.engineKW;

	public EngineAudioSet AudioSet => engine.audioSet;

	private bool EngineIsOn
	{
		get
		{
			if ((Object)(object)base.Car != (Object)null)
			{
				return base.Car.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On;
			}
			return false;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override void OnEngineStateChanged(VehicleEngineController<GroundVehicle>.EngineState oldState, VehicleEngineController<GroundVehicle>.EngineState newState)
	{
		base.OnEngineStateChanged(oldState, newState);
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override float GetMaxDriveForce()
	{
		if (!IsUsable)
		{
			return 0f;
		}
		return (float)engine.engineKW * 12.75f * PerformanceFractionTopSpeed;
	}

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", (object)this, (object)engineStorage) == null)
		{
			if ((Object)(object)engineStorage == (Object)null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", (object)this, (object)engineStorage);
		}
	}

	public float GetPerformanceFraction(float statBoostPercent)
	{
		if (!IsUsable)
		{
			return 0f;
		}
		float num = Mathf.Lerp(0f, 0.25f, base.healthFraction);
		float num2 = ((base.healthFraction != 0f) ? (statBoostPercent * 0.75f) : 0f);
		return num + num2;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		RefreshPerformanceStats(GetContainer() as EngineStorage);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		if (!base.CanBeLooted(player))
		{
			return false;
		}
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		if (!isSpawned || !base.IsOnAVehicle)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("VehicleModuleEngine.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.Vehicle.IsMovingOrOn && !((Object)(object)base.Car == (Object)null) && base.Car.CurEngineState == VehicleEngineController<GroundVehicle>.EngineState.On && IsUsable)
			{
				float num = Mathf.Lerp(engine.idleFuelPerSec, engine.maxFuelPerSec, Mathf.Abs(base.Car.GetThrottleInput()));
				num /= PerformanceFractionFuelEconomy;
				base.Car.TickFuel(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override float GetAdjustedDriveForce(float absSpeed, float topSpeed)
	{
		float maxDriveForce = GetMaxDriveForce();
		float num = Mathf.Lerp(0.0002f, 0.7f, PerformanceFractionAcceleration);
		float num2 = MathEx.BiasedLerp(1f - absSpeed / topSpeed, num);
		return maxDriveForce * num2;
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
		if (!IsTransferProtected() && info.damageTypes.GetMajorityDamageType() != DamageType.Decay)
		{
			float num = info.damageTypes.Total();
			EngineStorage engineStorage = GetContainer() as EngineStorage;
			if ((Object)(object)engineStorage != (Object)null && num > 0f)
			{
				engineStorage.OnModuleDamaged(num);
			}
		}
	}

	public override void OnHealthChanged(float oldValue, float newValue)
	{
		base.OnHealthChanged(oldValue, newValue);
		if (base.isServer)
		{
			RefreshPerformanceStats(GetContainer() as EngineStorage);
		}
	}

	public override bool AdminFixUp(int tier)
	{
		if (!base.AdminFixUp(tier))
		{
			return false;
		}
		EngineStorage engineStorage = GetContainer() as EngineStorage;
		engineStorage.AdminAddParts(tier);
		RefreshPerformanceStats(engineStorage);
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Engine
{
	[Header("Engine Stats")]
	public int engineKW;

	public float idleFuelPerSec = 0.25f;

	public float maxFuelPerSec = 0.25f;

	[Header("Engine Audio")]
	public EngineAudioSet audioSet;

	[Header("Engine FX")]
	public ParticleSystemContainer[] engineParticles;

	public ParticleSystem[] exhaustSmoke;

	public ParticleSystem[] exhaustBackfire;

	public float exhaustSmokeMinOpacity = 0.1f;

	public float exhaustSmokeMaxOpacity = 0.7f;

	public float exhaustSmokeChangeRate = 0.5f;
}


using System;
using Rust;
using UnityEngine;

[RequireComponent(typeof(Collider))]
public class TakeCollisionDamage : FacepunchBehaviour
{
	public interface ICanRestoreVelocity
	{
		void RestoreVelocity(Vector3 amount);
	}

	[SerializeField]
	private BaseCombatEntity entity;

	[SerializeField]
	private float minDamage = 1f;

	[SerializeField]
	private float maxDamage = 250f;

	[SerializeField]
	private float forceForAnyDamage = 20000f;

	[SerializeField]
	private float forceForMaxDamage = 1000000f;

	[SerializeField]
	private float velocityRestorePercent = 0.75f;

	private float pendingDamage;

	private bool IsServer => entity.isServer;

	private bool IsClient => entity.isClient;

	protected void OnCollisionEnter(Collision collision)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		if (IsClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		Rigidbody rigidbody = collision.rigidbody;
		float num = (((Object)(object)rigidbody == (Object)null) ? 100f : rigidbody.mass);
		Vector3 relativeVelocity = collision.relativeVelocity;
		float num2 = ((Vector3)(ref relativeVelocity)).magnitude * (entity.RealisticMass + num) / Time.fixedDeltaTime;
		float num3 = Mathf.InverseLerp(forceForAnyDamage, forceForMaxDamage, num2);
		if (num3 > 0f)
		{
			pendingDamage = Mathf.Max(pendingDamage, Mathf.Lerp(minDamage, maxDamage, num3));
			if (pendingDamage > entity.Health() && collision.gameObject.ToBaseEntity() is ICanRestoreVelocity canRestoreVelocity)
			{
				canRestoreVelocity.RestoreVelocity(collision.relativeVelocity * velocityRestorePercent);
			}
			((FacepunchBehaviour)this).Invoke((Action)DoDamage, 0f);
		}
	}

	protected void OnDestroy()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DoDamage);
	}

	private void DoDamage()
	{
		if (!((Object)(object)entity == (Object)null) && !entity.IsDead() && !entity.IsDestroyed && pendingDamage > 0f)
		{
			entity.Hurt(pendingDamage, DamageType.Collision, null, useProtection: false);
			pendingDamage = 0f;
		}
	}
}


using UnityEngine;

public interface ICanRestoreVelocity
{
	void RestoreVelocity(Vector3 amount);
}


using System;
using UnityEngine;

public class VehicleLight : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class LightRenderer
	{
		public Renderer renderer;

		public int matIndex;
	}

	public bool IsBrake;

	public GameObject toggleObject;

	public LightRenderer[] renderers;

	[ColorUsage(true, true)]
	public Color lightOnColour;

	[ColorUsage(true, true)]
	public Color brakesOnColour;

	public bool applyToTransmittance;

	public bool useLightOnColourForBrake;
}


using System;
using UnityEngine;

[Serializable]
public class LightRenderer
{
	public Renderer renderer;

	public int matIndex;
}


public class PlayerBoatPrivilege : VehiclePrivilege
{
}


public class PTBoat : RHIB
{
	public override void ServerInit()
	{
		base.ServerInit();
	}
}


using UnityEngine;

public class SimpleSplineTranslator
{
	private WorldSpline spline;

	private WorldSplineData splineData;

	private float currentDistance;

	private float speed;

	private bool loop;

	private Vector3 offset;

	private int direction;

	public int Direction;

	public float Speed => speed;

	public Vector3 Offset => offset;

	public float CurrentDistance => currentDistance;

	public bool Loop => loop;

	public SimpleSplineTranslator(WorldSpline spline, float speed, int direction = 1, bool loop = false)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		this.spline = spline;
		this.speed = speed;
		this.loop = loop;
		this.direction = direction;
		splineData = spline.GetData();
		offset = Vector3.zero;
		currentDistance = ((direction == 1) ? 0f : splineData.Length);
	}

	public SimpleSplineTranslator()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		spline = null;
		splineData = null;
		speed = 0f;
		loop = false;
		direction = 1;
		offset = Vector3.zero;
		currentDistance = 0f;
	}

	public void Update(float deltaTime)
	{
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			return;
		}
		float delta = speed * deltaTime;
		currentDistance = CalculateNextDistance(currentDistance, delta, direction);
	}

	public Vector3 PeekNextPosition(float delta = 0.1f, int dir = 1, bool getLocal = false)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			return Vector3.zero;
		}
		float distance = CalculateNextDistance(currentDistance, delta, dir);
		Vector3 positionAtDistance = GetPositionAtDistance(distance, out var _);
		positionAtDistance += offset;
		if (!getLocal)
		{
			positionAtDistance = ((Component)spline).transform.TransformPoint(positionAtDistance);
		}
		return positionAtDistance;
	}

	public Vector3 PeekNextPositionFollowingDirection(float delta = 0.1f, bool getLocal = false)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return PeekNextPosition(delta, direction, getLocal);
	}

	public void GetCurrentPositionAndTangent(out Vector3 position, out Vector3 tangent, bool getLocal = false)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)spline == (Object)null)
		{
			Debug.LogError((object)"Can't traverse over a null spline. Please set the spline data first.");
			position = Vector3.zero;
			tangent = Vector3.zero;
			return;
		}
		position = GetPositionAtDistance(currentDistance, out tangent);
		position += offset;
		if (!getLocal)
		{
			position = ((Component)spline).transform.TransformPoint(position);
		}
	}

	private float CalculateNextDistance(float currentDistance, float delta, float dir)
	{
		float num = currentDistance + delta * dir;
		if (loop)
		{
			return num % splineData.Length;
		}
		return Mathf.Clamp(num, 0f, splineData.Length);
	}

	public float GetEnd()
	{
		if (direction == 1)
		{
			return splineData.Length;
		}
		return 0f;
	}

	public float GetStart()
	{
		if (direction == -1)
		{
			return splineData.Length;
		}
		return 0f;
	}

	public Vector3 GetPositionAtDistance(float distance, out Vector3 tangent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return splineData.GetPointAndTangentCubicHermite(distance, out tangent);
	}

	public SimpleSplineTranslator SetSpeed(float newSpeed)
	{
		speed = newSpeed;
		return this;
	}

	public SimpleSplineTranslator SetOffset(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.offset = offset;
		return this;
	}

	public SimpleSplineTranslator SetCurrentDistance(float distance)
	{
		currentDistance = Mathf.Clamp(distance, 0f, splineData.Length);
		return this;
	}

	public SimpleSplineTranslator CalculateStartingDistance()
	{
		currentDistance = GetStart();
		return this;
	}

	public SimpleSplineTranslator Reset()
	{
		currentDistance = 0f;
		return this;
	}

	public SimpleSplineTranslator SetSpline(WorldSpline spline)
	{
		this.spline = spline;
		splineData = spline.GetData();
		return this;
	}

	public SimpleSplineTranslator SetDirection(int direction)
	{
		this.direction = direction;
		return this;
	}

	public float GetCurrentDistance()
	{
		return currentDistance;
	}
}


public static class SimpleVehicleVisuals
{
}


using System;
using UnityEngine;

[Serializable]
public class SimpleCarVisualsController
{
	public enum RotationAxis
	{
		X,
		Z,
		Y
	}

	[Header("Simple Visuals Settings")]
	public float wheelLerpSpeed = 5f;

	public float wheelAngleMaximum = 40f;

	public float timeSinceLastUpdateMinimum = 0.5f;

	[Tooltip("Should the wheels be rotated on the Y axis?")]
	public RotationAxis rotateAxis = RotationAxis.Z;

	public RotationAxis steerAxis;

	public TimeSince timeSinceUpdated;

	public void Updated()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		timeSinceUpdated = TimeSince.op_Implicit(0f);
	}
}


public enum RotationAxis
{
	X,
	Z,
	Y
}


using UnityEngine;

public class MouseSteerableSeat : BaseVehicleSeat
{
	[SerializeField]
	private bool supportsMouseSteer;

	public const BUTTON MouseSteerButton = BUTTON.FIRE_THIRD;
}


using UnityEngine;

public class SnowmobileAudio : GroundVehicleAudio
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet engineAudioSet;

	[SerializeField]
	[Header("Skis")]
	private AnimationCurve skiGainCurve;

	[SerializeField]
	private SoundDefinition skiSlideSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideSnowSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideSandSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideGrassSoundDef;

	[SerializeField]
	private SoundDefinition skiSlideWaterSoundDef;

	[SerializeField]
	[Header("Movement")]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private SoundDefinition suspensionLurchSoundDef;

	[SerializeField]
	private float suspensionLurchMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionLurchMinTimeBetweenSounds = 0.25f;
}


using System;
using UnityEngine;

public class SnowmobileChassisVisuals : VehicleChassisVisuals<Snowmobile>, IClientComponent
{
	[Serializable]
	private class TreadRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private SnowmobileAudio audioScript;

	[SerializeField]
	private TreadRenderer[] treadRenderers;

	[SerializeField]
	private float treadSpeedMultiplier = 0.01f;

	[SerializeField]
	private bool flipRightSkiExtension;

	[SerializeField]
	private Transform leftSki;

	[SerializeField]
	private Transform leftSkiPistonIn;

	[SerializeField]
	private Transform leftSkiPistonOut;

	[SerializeField]
	private Transform rightSki;

	[SerializeField]
	private Transform rightSkiPistonIn;

	[SerializeField]
	private Transform rightSkiPistonOut;

	[SerializeField]
	private float skiVisualAdjust;

	[SerializeField]
	private float treadVisualAdjust;

	[SerializeField]
	private float skiVisualMaxExtension;

	[SerializeField]
	private float treadVisualMaxExtension;

	[SerializeField]
	private float wheelSizeVisualMultiplier = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class TreadRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class SoccerBall : BaseCombatEntity
{
	[SerializeField]
	[Header("Soccer Ball")]
	private Rigidbody rigidBody;

	[SerializeField]
	private float additionalForceMultiplier = 0.2f;

	[SerializeField]
	private float upForceMultiplier = 0.15f;

	[SerializeField]
	private DamageRenderer damageRenderer;

	[SerializeField]
	private float explosionForceMultiplier = 40f;

	[SerializeField]
	private float otherForceMultiplier = 10f;

	protected void OnCollisionEnter(Collision collision)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			Vector3 impulse = collision.impulse;
			if (((Vector3)(ref impulse)).magnitude > 0f && (Object)(object)collision.collider.attachedRigidbody != (Object)null && !((Component)(object)collision.collider.attachedRigidbody).HasComponent<SoccerBall>())
			{
				Vector3 val = rigidBody.position - collision.collider.attachedRigidbody.position;
				impulse = collision.impulse;
				float magnitude = ((Vector3)(ref impulse)).magnitude;
				rigidBody.AddForce(val * magnitude * additionalForceMultiplier + Vector3.up * magnitude * upForceMultiplier, (ForceMode)1);
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		float num = 0f;
		float[] types = info.damageTypes.types;
		foreach (float num2 in types)
		{
			num = (((int)num2 != 16 && (int)num2 != 22) ? (num + num2 * otherForceMultiplier) : (num + num2 * explosionForceMultiplier));
		}
		if (num > 3f)
		{
			if (info.attackNormal != Vector3.zero)
			{
				rigidBody.AddForce(info.attackNormal * num, (ForceMode)1);
			}
			else
			{
				rigidBody.AddExplosionForce(num * 5f, info.HitPositionWorld, 0.25f, 0.25f);
			}
		}
		base.Hurt(info);
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class EntityFuelSystem : IFuelSystem
{
	public readonly bool isServer;

	private readonly bool editorGiveFreeFuel;

	private readonly uint fuelStorageID;

	private readonly Action<bool> fuelAddedRemovedCallback;

	public EntityRef<StorageContainer> fuelStorageInstance;

	public float nextFuelCheckTime;

	public bool cachedHasFuel;

	public float pendingFuel;

	public EntityFuelSystem(bool isServer, GameObjectRef fuelStoragePrefab, List<BaseEntity> children, bool editorGiveFreeFuel = true, Action<bool> fuelAddedRemovedCallback = null)
	{
		this.isServer = isServer;
		this.editorGiveFreeFuel = editorGiveFreeFuel;
		fuelStorageID = fuelStoragePrefab.GetEntity().prefabID;
		this.fuelAddedRemovedCallback = fuelAddedRemovedCallback;
		if (!isServer)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			CheckNewChild(child);
		}
	}

	public bool HasValidInstance(bool isServer)
	{
		return fuelStorageInstance.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return fuelStorageInstance.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		fuelStorageInstance.uid = uid;
	}

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", (object)this, (object)fuelContainer, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)fuelContainer != (Object)null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

	public StorageContainer GetFuelContainer()
	{
		return fuelStorageInstance.Get(isServer);
	}

	public bool CheckNewChild(BaseEntity child)
	{
		if (child.prefabID == fuelStorageID)
		{
			if (child is StorageContainer storageContainer)
			{
				fuelStorageInstance.Set(storageContainer);
				storageContainer.inventory.onItemAddedRemoved = OnFuelAddedRemoved;
			}
			return true;
		}
		return false;
	}

	private void OnFuelAddedRemoved(Item arg1, bool arg2)
	{
		nextFuelCheckTime = 0f;
		fuelAddedRemovedCallback?.Invoke(arg2);
	}

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", (object)this, (object)fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if ((Object)(object)fuelContainer == (Object)null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", (object)this, (object)fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

	public float GetFuelFraction()
	{
		Item fuelItem = GetFuelItem();
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0f;
		}
		return Mathf.Clamp01((float)fuelItem.amount / (float)fuelItem.MaxStackable());
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", (object)this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", (object)this, (object)fuelContainer, (object)seconds, (object)fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelContainer.IsRealNull())
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
		if (IsInFuelInteractionRange(player))
		{
			GetFuelContainer().PlayerOpenLoot(player);
		}
	}

	public void AddFuel(int amount)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			fuelContainer.inventory.AddItem(GetFuelContainer().allowedItem, Mathf.FloorToInt((float)amount), 0uL);
		}
	}

	public void RemoveFuel(int amount)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			Item slot = fuelContainer.inventory.GetSlot(0);
			slot.UseItem(amount);
			Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, amount, "fuel_system");
		}
	}

	public void FillFuel()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		if ((Object)(object)fuelContainer != (Object)null)
		{
			fuelContainer.inventory.AddItem(GetFuelContainer().allowedItem, GetFuelContainer().allowedItem.stackable, 0uL);
		}
	}

	public int GetFuelCapacity()
	{
		return GetFuelContainer().allowedItem.stackable;
	}
}


using UnityEngine;

public class SubmarineAudio : MonoBehaviour
{
	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition underwaterLoopDef;

	[SerializeField]
	private SoundDefinition underwaterMovementLoopDef;

	[SerializeField]
	private BlendedSoundLoops surfaceWaterLoops;

	[SerializeField]
	private float surfaceWaterSoundsMaxSpeed = 5f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;

	[SerializeField]
	[Header("Interior")]
	private SoundDefinition activeLoopDef;

	[SerializeField]
	private SoundDefinition footPedalSoundDef;

	[SerializeField]
	private Transform footPedalSoundPos;

	[SerializeField]
	private SoundDefinition steeringWheelSoundDef;

	[SerializeField]
	private Transform steeringWheelSoundPos;

	[SerializeField]
	private SoundDefinition heavyDamageSparksDef;

	[SerializeField]
	private Transform heavyDamageSparksPos;

	[SerializeField]
	private SoundDefinition flagRaise;

	[SerializeField]
	private SoundDefinition flagLower;

	[SerializeField]
	private GameObject dashboardAudioPoint;

	[SerializeField]
	[Header("Other")]
	private SoundDefinition climbOrDiveLoopSound;

	[SerializeField]
	private SoundDefinition torpedoFailedSound;
}


using Sonar;
using UnityEngine;

public class SubmarineDuo : BaseSubmarine
{
	[Header("Duo Sub Seating & Controls")]
	[SerializeField]
	private Transform steeringWheel;

	[SerializeField]
	private Transform steeringWheelLeftGrip;

	[SerializeField]
	private Transform steeringWheelRightGrip;

	[SerializeField]
	private Transform leftPedal;

	[SerializeField]
	private Transform rightPedal;

	[SerializeField]
	private Transform driverLeftFoot;

	[SerializeField]
	private Transform driverRightFoot;

	[SerializeField]
	private Transform mphNeedle;

	[SerializeField]
	private Transform fuelNeedle;

	[SerializeField]
	private Transform waterDepthNeedle;

	[SerializeField]
	private Transform ammoFlag;

	[SerializeField]
	private SonarSystem sonar;

	[SerializeField]
	private Transform torpedoTubeHatch;
}


using System;
using UnityEngine;

public class TowConfig : PrefabAttribute
{
	[Serializable]
	public struct Configuration
	{
		public Vector2 AngularLimitsX;

		public float AngularLimitY;

		public float AngularLimitZ;
	}

	private static readonly Configuration DefaultConfig = new Configuration
	{
		AngularLimitsX = new Vector2(-80f, 80f),
		AngularLimitY = 60f,
		AngularLimitZ = 55f
	};

	public Configuration Config = DefaultConfig;

	protected override Type GetIndexedType()
	{
		return typeof(TowConfig);
	}

	public Configuration Combine(TowConfig other)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Configuration result = default(Configuration);
		Configuration config = other.Config;
		result.AngularLimitsX = new Vector2(Mathf.Max(Config.AngularLimitsX.x, config.AngularLimitsX.x), Mathf.Min(Config.AngularLimitsX.y, config.AngularLimitsX.y));
		result.AngularLimitY = Mathf.Min(Config.AngularLimitY, config.AngularLimitY);
		result.AngularLimitZ = Mathf.Min(Config.AngularLimitZ, config.AngularLimitZ);
		return result;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Configuration
{
	public Vector2 AngularLimitsX;

	public float AngularLimitY;

	public float AngularLimitZ;
}


using UnityEngine;

public interface ITowing
{
	bool IsTowing { get; }

	bool IsTowingAllowed { get; }

	BaseEntity TowEntity { get; }

	Transform TowAnchor { get; }

	Rigidbody TowBody { get; }

	void OnTowAttach();

	void OnTowDetach();
}


public abstract class TowingAttachment
{
	public const BaseEntity.Flags Flag_IsTowing = BaseEntity.Flags.Reserved14;
}


using ConVar;
using UnityEngine;

public class TowingAttachment<TEntity> : TowingAttachment where TEntity : BaseEntity, ITowing
{
	private readonly TEntity _entity;

	private readonly TowConfig _towingConfig;

	private ConfigurableJoint _towingJoint;

	private EntityRef<BaseEntity> _otherEntity;

	private float _lastBreakingForce;

	private float _idealBreakingForce;

	public TowingAttachment(TEntity entity)
	{
		_entity = entity;
		_towingConfig = PrefabAttribute.server.Find<TowConfig>(_entity.prefabID);
	}

	public void FixedUpdate()
	{
		BaseEntity baseEntity = _otherEntity.Get(serverside: true);
		if (_entity.IsTowing && (!baseEntity.IsValid() || baseEntity.IsDestroyed || (Object)(object)_towingJoint == (Object)null))
		{
			Detach();
		}
		if (_entity.IsTowing)
		{
			MoveToNormalBreakForce();
		}
	}

	public void AttachTo<TTowableEntity>(TTowableEntity other) where TTowableEntity : ITowing
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		if (_entity.IsTowing)
		{
			Detach();
		}
		if ((Object)(object)_towingJoint != (Object)null)
		{
			Object.Destroy((Object)(object)_towingJoint);
		}
		Rigidbody towBody = other.TowBody;
		BaseEntity towEntity = other.TowEntity;
		TowConfig towConfig = PrefabAttribute.server.Find<TowConfig>(towEntity.prefabID);
		if (towConfig == null)
		{
			Debug.LogError((object)"Attaching to towable without TowConfig", (Object)(object)towEntity);
			return;
		}
		TowConfig.Configuration configuration = _towingConfig.Combine(towConfig);
		_towingJoint = ((Component)_entity.TowBody).gameObject.AddComponent<ConfigurableJoint>();
		((Joint)_towingJoint).connectedBody = towBody;
		Matrix4x4 worldToLocalMatrix = ((Component)_entity.TowBody).transform.worldToLocalMatrix;
		((Joint)_towingJoint).autoConfigureConnectedAnchor = false;
		((Joint)_towingJoint).anchor = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(_entity.TowAnchor.position);
		ConfigurableJoint towingJoint = _towingJoint;
		Vector3 val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(((Component)towBody).transform.right);
		((Joint)towingJoint).axis = ((Vector3)(ref val)).normalized;
		ConfigurableJoint towingJoint2 = _towingJoint;
		val = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyVector(((Component)towBody).transform.up);
		towingJoint2.secondaryAxis = ((Vector3)(ref val)).normalized;
		_towingJoint.swapBodies = false;
		Matrix4x4 worldToLocalMatrix2 = ((Component)towBody).transform.worldToLocalMatrix;
		((Joint)_towingJoint).connectedAnchor = ((Matrix4x4)(ref worldToLocalMatrix2)).MultiplyPoint3x4(other.TowAnchor.position);
		_towingJoint.xMotion = (ConfigurableJointMotion)1;
		_towingJoint.yMotion = (ConfigurableJointMotion)1;
		_towingJoint.zMotion = (ConfigurableJointMotion)1;
		ConfigurableJoint towingJoint3 = _towingJoint;
		SoftJointLimitSpring linearLimitSpring = default(SoftJointLimitSpring);
		((SoftJointLimitSpring)(ref linearLimitSpring)).spring = 100000f;
		((SoftJointLimitSpring)(ref linearLimitSpring)).damper = 100f;
		towingJoint3.linearLimitSpring = linearLimitSpring;
		ConfigurableJoint towingJoint4 = _towingJoint;
		SoftJointLimit val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = 0.2f;
		towingJoint4.linearLimit = val2;
		((Joint)_towingJoint).enableCollision = true;
		_towingJoint.angularXMotion = (ConfigurableJointMotion)1;
		_towingJoint.angularYMotion = (ConfigurableJointMotion)1;
		_towingJoint.angularZMotion = (ConfigurableJointMotion)1;
		ConfigurableJoint towingJoint5 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitsX.x;
		towingJoint5.lowAngularXLimit = val2;
		ConfigurableJoint towingJoint6 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitsX.y;
		towingJoint6.highAngularXLimit = val2;
		ConfigurableJoint towingJoint7 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitY;
		towingJoint7.angularYLimit = val2;
		ConfigurableJoint towingJoint8 = _towingJoint;
		val2 = default(SoftJointLimit);
		((SoftJointLimit)(ref val2)).limit = configuration.AngularLimitZ;
		towingJoint8.angularZLimit = val2;
		_towingJoint.targetRotation = Quaternion.identity;
		_towingJoint.projectionMode = (JointProjectionMode)1;
		((Joint)_towingJoint).breakForce = 1E+20f;
		_lastBreakingForce = ((Joint)_towingJoint).breakForce;
		float num = Mathf.Min(_entity.TowBody.isKinematic ? 10000f : _entity.TowBody.mass, towBody.isKinematic ? 10000f : towBody.mass);
		_idealBreakingForce = num * Physics.towingmaxlinearaccelfromjoint;
		_otherEntity.Set(towEntity);
		_entity.SetFlag(BaseEntity.Flags.Reserved14, b: true);
		towEntity.SetFlag(BaseEntity.Flags.Reserved14, b: true);
		_entity.OnTowAttach();
		other.OnTowAttach();
	}

	public void Detach()
	{
		if ((Object)(object)_towingJoint != (Object)null)
		{
			Object.Destroy((Object)(object)_towingJoint);
		}
		_entity.SetFlag(BaseEntity.Flags.Reserved14, b: false);
		BaseEntity baseEntity = _otherEntity.Get(serverside: true);
		bool num = (Object)(object)baseEntity == (Object)null;
		if (!num)
		{
			baseEntity.SetFlag(BaseEntity.Flags.Reserved14, b: false);
		}
		_otherEntity = default(EntityRef<BaseEntity>);
		_entity.OnTowDetach();
		if (!num && baseEntity is ITowing towing)
		{
			towing.OnTowDetach();
		}
	}

	private void MoveToNormalBreakForce()
	{
		if (Mathf.Approximately(_lastBreakingForce, _idealBreakingForce))
		{
			if (!_towingJoint.swapBodies)
			{
				_towingJoint.swapBodies = true;
			}
		}
		else
		{
			float num = Mathf.Lerp(((Joint)_towingJoint).breakForce, _idealBreakingForce, Time.fixedDeltaTime * 10f);
			((Joint)_towingJoint).breakForce = num;
			_lastBreakingForce = num;
		}
	}
}


public class TowingJointBreakDebug : FacepunchBehaviour
{
}


using UnityEngine;

public class TowingVisuals : FacepunchBehaviour, IClientComponent
{
	public GameObject visualPrefab;

	public Transform centralAnchor;

	public Transform[] visualAnchors;

	public Transform[] leadPoints;

	public TransformLineRenderer transformLineRenderer;
}


using UnityEngine;

public class TriggerEntityType<TEntity> : TriggerBase where TEntity : BaseEntity
{
	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!(baseEntity is TEntity))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


public class TriggerTowing : TriggerEntityType<BaseSiegeWeapon>
{
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class CompleteTrain : IDisposable
{
	private enum ShuntState
	{
		None,
		Forwards,
		Backwards
	}

	public enum StaticCollisionState
	{
		Free,
		StaticColliding,
		StayingStill
	}

	private Vector3 unloaderPos;

	public float trackSpeed;

	private float prevTrackSpeed;

	public List<TrainCar> trainCars;

	public TriggerTrainCollisions frontCollisionTrigger;

	public TriggerTrainCollisions rearCollisionTrigger;

	public bool ranUpdateTick;

	public bool disposed;

	public const float IMPACT_ENERGY_FRACTION = 0.75f;

	public const float MIN_COLLISION_FORCE = 70000f;

	public float lastMovingTime = float.MinValue;

	public const float SLEEP_SPEED = 0.1f;

	public const float SLEEP_DELAY = 10f;

	public TimeSince timeSinceLastChange;

	private bool isShunting;

	private TimeSince timeSinceShuntStart;

	private const float MAX_SHUNT_TIME = 20f;

	private const float SHUNT_SPEED = 4f;

	private const float SHUNT_SPEED_CHANGE_RATE = 10f;

	private Action<CoalingTower.ActionAttemptStatus> shuntEndCallback;

	private float shuntDistance;

	private Vector3 shuntDirection;

	private Vector2 shuntStartPos2D = Vector2.zero;

	private Vector2 shuntTargetPos2D = Vector2.zero;

	private TrainCar shuntTarget;

	public StaticCollisionState staticCollidingAtFront;

	private HashSet<GameObject> monitoredStaticContentF = new HashSet<GameObject>();

	public StaticCollisionState staticCollidingAtRear;

	private HashSet<GameObject> monitoredStaticContentR = new HashSet<GameObject>();

	public Dictionary<Rigidbody, float> prevTrackSpeeds = new Dictionary<Rigidbody, float>();

	public TrainCar PrimaryTrainCar { get; set; }

	public bool TrainIsReversing => (Object)(object)PrimaryTrainCar != (Object)(object)trainCars[0];

	public float TotalForces { get; set; }

	public float TotalMass { get; set; }

	public int NumTrainCars => trainCars.Count;

	public int LinedUpToUnload { get; private set; } = -1;

	public bool IsLinedUpToUnload => LinedUpToUnload >= 0;

	public CompleteTrain(TrainCar trainCar)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		List<TrainCar> list = Pool.Get<List<TrainCar>>();
		list.Add(trainCar);
		Init(list);
	}

	public CompleteTrain(List<TrainCar> allTrainCars)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Init(allTrainCars);
	}

	private void Init(List<TrainCar> allTrainCars)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		trainCars = allTrainCars;
		timeSinceLastChange = TimeSince.op_Implicit(0f);
		lastMovingTime = Time.time;
		float num = 0f;
		PrimaryTrainCar = trainCars[0];
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (trainCar.completeTrain != null)
			{
				trainCar.savedTrackSpeed = trainCar.GetTrackSpeed();
			}
		}
		for (int j = 0; j < trainCars.Count; j++)
		{
			TrainCar trainCar2 = trainCars[j];
			if (trainCar2.completeTrain != this)
			{
				trainCar2.SetNewCompleteTrain(this);
				num = ((!trainCar2.IsCoupledBackwards()) ? (num + trainCar2.savedTrackSpeed) : (num - trainCar2.savedTrackSpeed));
			}
		}
		num = (trackSpeed = num / (float)trainCars.Count);
		prevTrackSpeed = trackSpeed;
		ParamsTick();
	}

	~CompleteTrain()
	{
		Cleanup();
	}

	public void Dispose()
	{
		Cleanup();
		System.GC.SuppressFinalize(this);
	}

	private void Cleanup()
	{
		if (!disposed)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.GenericError);
			disposed = true;
			Pool.FreeUnmanaged<TrainCar>(ref trainCars);
		}
	}

	public void RemoveTrainCar(TrainCar trainCar)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			return;
		}
		if (trainCars.Count <= 1)
		{
			Debug.LogWarning((object)(GetType().Name + ": Can't remove car from CompleteTrain of length one."));
			return;
		}
		int num = IndexOf(trainCar);
		bool flag = ((num != 0) ? trainCars[0].IsCoupledBackwards() : trainCars[1].IsCoupledBackwards());
		trainCars.RemoveAt(num);
		timeSinceLastChange = TimeSince.op_Implicit(0f);
		LinedUpToUnload = -1;
		if (trainCars[0].IsCoupledBackwards() != flag)
		{
			trackSpeed *= -1f;
		}
	}

	public float GetTrackSpeedFor(TrainCar trainCar)
	{
		if (disposed)
		{
			return 0f;
		}
		if (trainCars.IndexOf(trainCar) < 0)
		{
			Debug.LogError((object)(GetType().Name + ": Train car not found in the trainCars list."));
			return 0f;
		}
		if (trainCar.IsCoupledBackwards())
		{
			return 0f - trackSpeed;
		}
		return trackSpeed;
	}

	public float GetPrevTrackSpeedFor(TrainCar trainCar)
	{
		if (trainCars.IndexOf(trainCar) < 0)
		{
			Debug.LogError((object)(GetType().Name + ": Train car not found in the trainCars list."));
			return 0f;
		}
		if (trainCar.IsCoupledBackwards())
		{
			return 0f - prevTrackSpeed;
		}
		return prevTrackSpeed;
	}

	public void UpdateTick(float dt)
	{
		if (ranUpdateTick || disposed)
		{
			return;
		}
		ranUpdateTick = true;
		if (IsAllAsleep() && !HasAnyEnginesOn() && !HasAnyCollisions() && !isShunting)
		{
			trackSpeed = 0f;
			return;
		}
		ParamsTick();
		MovementTick(dt);
		LinedUpToUnload = CheckLinedUpToUnload(out unloaderPos);
		if (!disposed)
		{
			if (Mathf.Abs(trackSpeed) > 0.1f)
			{
				lastMovingTime = Time.time;
			}
			if (!HasAnyEnginesOn() && !HasAnyCollisions() && Time.time > lastMovingTime + 10f)
			{
				trackSpeed = 0f;
				SleepAll();
			}
		}
	}

	public bool IncludesAnEngine()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.CarType == TrainCar.TrainCarType.Engine)
			{
				return true;
			}
		}
		return false;
	}

	protected bool HasAnyCollisions()
	{
		if (!frontCollisionTrigger.HasAnyContents)
		{
			return rearCollisionTrigger.HasAnyContents;
		}
		return true;
	}

	private bool HasAnyEnginesOn()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.CarType == TrainCar.TrainCarType.Engine && trainCar.IsOn())
			{
				return true;
			}
		}
		return false;
	}

	private bool IsAllAsleep()
	{
		if (disposed)
		{
			return true;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (!trainCar.rigidBody.IsSleeping())
			{
				return false;
			}
		}
		return true;
	}

	private void SleepAll()
	{
		if (disposed)
		{
			return;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			trainCar.rigidBody.Sleep();
		}
	}

	public bool TryShuntCarTo(Vector3 shuntDirection, float shuntDistance, TrainCar shuntTarget, Action<CoalingTower.ActionAttemptStatus> shuntEndCallback, out CoalingTower.ActionAttemptStatus status)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			status = CoalingTower.ActionAttemptStatus.NoTrainCar;
			return false;
		}
		if (isShunting)
		{
			status = CoalingTower.ActionAttemptStatus.AlreadyShunting;
			return false;
		}
		if (Mathf.Abs(trackSpeed) > 0.1f)
		{
			status = CoalingTower.ActionAttemptStatus.TrainIsMoving;
			return false;
		}
		if (HasThrottleInput())
		{
			status = CoalingTower.ActionAttemptStatus.TrainHasThrottle;
			return false;
		}
		this.shuntDirection = shuntDirection;
		this.shuntDistance = shuntDistance;
		this.shuntTarget = shuntTarget;
		timeSinceShuntStart = TimeSince.op_Implicit(0f);
		shuntStartPos2D.x = ((Component)shuntTarget).transform.position.x;
		shuntStartPos2D.y = ((Component)shuntTarget).transform.position.z;
		isShunting = true;
		this.shuntEndCallback = shuntEndCallback;
		status = CoalingTower.ActionAttemptStatus.NoError;
		return true;
	}

	private void EndShunting(CoalingTower.ActionAttemptStatus status)
	{
		isShunting = false;
		if (shuntEndCallback != null)
		{
			shuntEndCallback(status);
			shuntEndCallback = null;
		}
		shuntTarget = null;
	}

	public bool ContainsOnly(TrainCar trainCar)
	{
		if (disposed)
		{
			return false;
		}
		if (trainCars.Count == 1)
		{
			return (Object)(object)trainCars[0] == (Object)(object)trainCar;
		}
		return false;
	}

	public int IndexOf(TrainCar trainCar)
	{
		if (disposed)
		{
			return -1;
		}
		return trainCars.IndexOf(trainCar);
	}

	public bool TryGetAdjacentTrainCar(TrainCar trainCar, bool next, Vector3 forwardDir, out TrainCar result)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		int num = trainCars.IndexOf(trainCar);
		Vector3 val = ((!trainCars[num].IsCoupledBackwards()) ? ((Component)trainCar).transform.forward : (-((Component)trainCar).transform.forward));
		if (Vector3.Dot(val, forwardDir) < 0f)
		{
			next = !next;
		}
		if (num >= 0)
		{
			num = ((!next) ? (num - 1) : (num + 1));
			if (num >= 0 && num < trainCars.Count)
			{
				result = trainCars[num];
				return true;
			}
		}
		result = null;
		return false;
	}

	private void ParamsTick()
	{
		TotalForces = 0f;
		TotalMass = 0f;
		int num = 0;
		float num2 = 0f;
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (trainCar.rigidBody.mass > num2)
			{
				num2 = trainCar.rigidBody.mass;
				num = i;
			}
		}
		bool flag = false;
		for (int j = 0; j < trainCars.Count; j++)
		{
			TrainCar trainCar2 = trainCars[j];
			float forces = trainCar2.GetForces();
			TotalForces += (trainCar2.IsCoupledBackwards() ? (0f - forces) : forces);
			flag |= trainCar2.HasThrottleInput();
			if (j == num)
			{
				TotalMass += trainCar2.rigidBody.mass;
			}
			else
			{
				TotalMass += trainCar2.rigidBody.mass * 0.4f;
			}
		}
		if (isShunting && flag)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.TrainHasThrottle);
		}
		if (trainCars.Count == 1)
		{
			frontCollisionTrigger = trainCars[0].FrontCollisionTrigger;
			rearCollisionTrigger = trainCars[0].RearCollisionTrigger;
		}
		else
		{
			frontCollisionTrigger = (trainCars[0].coupling.IsRearCoupled ? trainCars[0].FrontCollisionTrigger : trainCars[0].RearCollisionTrigger);
			rearCollisionTrigger = (trainCars[trainCars.Count - 1].coupling.IsRearCoupled ? trainCars[trainCars.Count - 1].FrontCollisionTrigger : trainCars[trainCars.Count - 1].RearCollisionTrigger);
		}
	}

	private void MovementTick(float dt)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		prevTrackSpeed = trackSpeed;
		if (!isShunting)
		{
			trackSpeed += TotalForces * dt / TotalMass;
		}
		else
		{
			bool flag = Vector3.Dot(shuntDirection, ((Component)PrimaryTrainCar).transform.forward) >= 0f;
			if (PrimaryTrainCar.IsCoupledBackwards())
			{
				flag = !flag;
			}
			if ((Object)(object)shuntTarget == (Object)null || shuntTarget.IsDead() || shuntTarget.IsDestroyed)
			{
				EndShunting(CoalingTower.ActionAttemptStatus.NoTrainCar);
			}
			else
			{
				float num = 4f;
				shuntTargetPos2D.x = ((Component)shuntTarget).transform.position.x;
				shuntTargetPos2D.y = ((Component)shuntTarget).transform.position.z;
				float num2 = shuntDistance - Vector3.Distance(Vector2.op_Implicit(shuntStartPos2D), Vector2.op_Implicit(shuntTargetPos2D));
				if (num2 < 2f)
				{
					float num3 = Mathf.InverseLerp(0f, 2f, num2);
					num *= Mathf.Lerp(0.1f, 1f, num3);
				}
				trackSpeed = Mathf.MoveTowards(trackSpeed, flag ? num : (0f - num), dt * 10f);
				if (TimeSince.op_Implicit(timeSinceShuntStart) > 20f || num2 <= 0f)
				{
					EndShunting(CoalingTower.ActionAttemptStatus.NoError);
					trackSpeed = 0f;
				}
			}
		}
		float num4 = trainCars[0].rigidBody.drag;
		if (IsLinedUpToUnload)
		{
			float num5 = Mathf.Abs(trackSpeed);
			if (num5 > 1f)
			{
				TrainCarUnloadable trainCarUnloadable = trainCars[LinedUpToUnload] as TrainCarUnloadable;
				if ((Object)(object)trainCarUnloadable != (Object)null)
				{
					float num6 = trainCarUnloadable.MinDistToUnloadingArea(unloaderPos);
					float num7 = Mathf.InverseLerp(2f, 0f, num6);
					if (num5 < 2f)
					{
						float num8 = (num5 - 1f) / 1f;
						num7 *= num8;
					}
					num4 = Mathf.Lerp(num4, 3.5f, num7);
				}
			}
		}
		if (trackSpeed > 0f)
		{
			trackSpeed -= num4 * 4f * dt;
			if (trackSpeed < 0f)
			{
				trackSpeed = 0f;
			}
		}
		else if (trackSpeed < 0f)
		{
			trackSpeed += num4 * 4f * dt;
			if (trackSpeed > 0f)
			{
				trackSpeed = 0f;
			}
		}
		float num9 = trackSpeed;
		trackSpeed = ApplyCollisionsToTrackSpeed(trackSpeed, TotalMass, dt);
		if (isShunting && trackSpeed != num9)
		{
			EndShunting(CoalingTower.ActionAttemptStatus.GenericError);
		}
		if (disposed)
		{
			return;
		}
		trackSpeed = Mathf.Clamp(trackSpeed, 0f - (TrainCar.TRAINCAR_MAX_SPEED - 1f), TrainCar.TRAINCAR_MAX_SPEED - 1f);
		if (trackSpeed > 0f)
		{
			PrimaryTrainCar = trainCars[0];
		}
		else if (trackSpeed < 0f)
		{
			PrimaryTrainCar = trainCars[trainCars.Count - 1];
		}
		else if (TotalForces > 0f)
		{
			PrimaryTrainCar = trainCars[0];
		}
		else if (TotalForces < 0f)
		{
			PrimaryTrainCar = trainCars[trainCars.Count - 1];
		}
		else
		{
			PrimaryTrainCar = trainCars[0];
		}
		if (trackSpeed == 0f && TotalForces == 0f)
		{
			return;
		}
		PrimaryTrainCar.FrontTrainCarTick(GetTrackSelection(), dt);
		if (trainCars.Count <= 1)
		{
			return;
		}
		if ((Object)(object)PrimaryTrainCar == (Object)(object)trainCars[0])
		{
			for (int i = 1; i < trainCars.Count; i++)
			{
				MoveOtherTrainCar(trainCars[i], trainCars[i - 1]);
			}
			return;
		}
		for (int num10 = trainCars.Count - 2; num10 >= 0; num10--)
		{
			MoveOtherTrainCar(trainCars[num10], trainCars[num10 + 1]);
		}
	}

	private void MoveOtherTrainCar(TrainCar trainCar, TrainCar prevTrainCar)
	{
		TrainTrackSpline frontTrackSection = prevTrainCar.FrontTrackSection;
		float frontWheelSplineDist = prevTrainCar.FrontWheelSplineDist;
		float num = 0f;
		TrainCoupling coupledTo = trainCar.coupling.frontCoupling.CoupledTo;
		TrainCoupling coupledTo2 = trainCar.coupling.rearCoupling.CoupledTo;
		if (coupledTo == prevTrainCar.coupling.frontCoupling)
		{
			num += trainCar.DistFrontWheelToFrontCoupling;
			num += prevTrainCar.DistFrontWheelToFrontCoupling;
		}
		else if (coupledTo2 == prevTrainCar.coupling.rearCoupling)
		{
			num -= trainCar.DistFrontWheelToBackCoupling;
			num -= prevTrainCar.DistFrontWheelToBackCoupling;
		}
		else if (coupledTo == prevTrainCar.coupling.rearCoupling)
		{
			num += trainCar.DistFrontWheelToFrontCoupling;
			num += prevTrainCar.DistFrontWheelToBackCoupling;
		}
		else if (coupledTo2 == prevTrainCar.coupling.frontCoupling)
		{
			num -= trainCar.DistFrontWheelToBackCoupling;
			num -= prevTrainCar.DistFrontWheelToFrontCoupling;
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": Uncoupled!"));
		}
		trainCar.OtherTrainCarTick(frontTrackSection, frontWheelSplineDist, 0f - num);
	}

	public void ResetUpdateTick()
	{
		ranUpdateTick = false;
	}

	public bool Matches(List<TrainCar> listToCompare)
	{
		if (disposed)
		{
			return false;
		}
		if (listToCompare.Count != trainCars.Count)
		{
			return false;
		}
		for (int i = 0; i < listToCompare.Count; i++)
		{
			if ((Object)(object)trainCars[i] != (Object)(object)listToCompare[i])
			{
				return false;
			}
		}
		return true;
	}

	public void ReduceSpeedBy(float velChange)
	{
		prevTrackSpeed = trackSpeed;
		if (trackSpeed > 0f)
		{
			trackSpeed = Mathf.Max(0f, trackSpeed - velChange);
		}
		else if (trackSpeed < 0f)
		{
			trackSpeed = Mathf.Min(0f, trackSpeed + velChange);
		}
	}

	public bool AnyPlayersOnTrain()
	{
		if (disposed)
		{
			return false;
		}
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.AnyPlayersOnTrainCar())
			{
				return true;
			}
		}
		return false;
	}

	private int CheckLinedUpToUnload(out Vector3 unloaderPos)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (disposed)
		{
			unloaderPos = Vector3.zero;
			return -1;
		}
		for (int i = 0; i < trainCars.Count; i++)
		{
			TrainCar trainCar = trainCars[i];
			if (CoalingTower.IsUnderAnUnloader(trainCar, out var isLinedUp, out unloaderPos))
			{
				trainCar.SetFlag(BaseEntity.Flags.Reserved4, isLinedUp);
				if (isLinedUp)
				{
					return i;
				}
			}
		}
		unloaderPos = Vector3.zero;
		return -1;
	}

	public bool GetIsCoupledBackwards(TrainCar trainCar)
	{
		if (disposed)
		{
			return false;
		}
		return GetIsCoupledBackwards(trainCars.IndexOf(trainCar));
	}

	private bool GetIsCoupledBackwards(int trainCarIndex)
	{
		if (disposed || trainCars.Count == 1 || trainCarIndex < 0 || trainCarIndex > trainCars.Count - 1)
		{
			return false;
		}
		TrainCar trainCar = trainCars[trainCarIndex];
		if (trainCarIndex == 0)
		{
			return trainCar.coupling.IsFrontCoupled;
		}
		TrainCoupling coupledTo = trainCar.coupling.frontCoupling.CoupledTo;
		if (coupledTo != null)
		{
			return (Object)(object)coupledTo.owner != (Object)(object)trainCars[trainCarIndex - 1];
		}
		return true;
	}

	private bool HasThrottleInput()
	{
		for (int i = 0; i < trainCars.Count; i++)
		{
			if (trainCars[i].HasThrottleInput())
			{
				return true;
			}
		}
		return false;
	}

	private TrainTrackSpline.TrackSelection GetTrackSelection()
	{
		TrainTrackSpline.TrackSelection result = TrainTrackSpline.TrackSelection.Default;
		foreach (TrainCar trainCar in trainCars)
		{
			if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Default)
			{
				continue;
			}
			if (trainCar.IsCoupledBackwards() != PrimaryTrainCar.IsCoupledBackwards())
			{
				if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Left)
				{
					return TrainTrackSpline.TrackSelection.Right;
				}
				if (trainCar.localTrackSelection == TrainTrackSpline.TrackSelection.Right)
				{
					return TrainTrackSpline.TrackSelection.Left;
				}
			}
			return trainCar.localTrackSelection;
		}
		return result;
	}

	public void FreeStaticCollision()
	{
		staticCollidingAtFront = StaticCollisionState.Free;
		staticCollidingAtRear = StaticCollisionState.Free;
	}

	private float ApplyCollisionsToTrackSpeed(float trackSpeed, float totalMass, float deltaTime)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TrainCar owner = frontCollisionTrigger.owner;
		Vector3 forwardVector = (owner.IsCoupledBackwards() ? (-((Component)owner).transform.forward) : ((Component)owner).transform.forward);
		trackSpeed = ApplyCollisions(trackSpeed, owner, forwardVector, atOurFront: true, frontCollisionTrigger, totalMass, ref staticCollidingAtFront, staticCollidingAtRear, deltaTime);
		if (disposed)
		{
			return trackSpeed;
		}
		owner = rearCollisionTrigger.owner;
		forwardVector = (owner.IsCoupledBackwards() ? (-((Component)owner).transform.forward) : ((Component)owner).transform.forward);
		trackSpeed = ApplyCollisions(trackSpeed, owner, forwardVector, atOurFront: false, rearCollisionTrigger, totalMass, ref staticCollidingAtRear, staticCollidingAtFront, deltaTime);
		if (disposed)
		{
			return trackSpeed;
		}
		Rigidbody val = null;
		foreach (KeyValuePair<Rigidbody, float> prevTrackSpeed in prevTrackSpeeds)
		{
			if ((Object)(object)prevTrackSpeed.Key == (Object)null || (!frontCollisionTrigger.otherRigidbodyContents.Contains(prevTrackSpeed.Key) && !rearCollisionTrigger.otherRigidbodyContents.Contains(prevTrackSpeed.Key)))
			{
				val = prevTrackSpeed.Key;
				break;
			}
		}
		if ((Object)(object)val != (Object)null)
		{
			prevTrackSpeeds.Remove(val);
		}
		return trackSpeed;
	}

	private float ApplyCollisions(float trackSpeed, TrainCar ourTrainCar, Vector3 forwardVector, bool atOurFront, TriggerTrainCollisions trigger, float ourTotalMass, ref StaticCollisionState wasStaticColliding, StaticCollisionState otherEndStaticColliding, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = forwardVector * trackSpeed;
		bool flag = trigger.HasAnyStaticContents;
		if (atOurFront && ourTrainCar.FrontAtEndOfLine)
		{
			flag = true;
		}
		else if (!atOurFront && ourTrainCar.RearAtEndOfLine)
		{
			flag = true;
		}
		float num = (flag ? (((Vector3)(ref val)).magnitude * Mathf.Clamp(ourTotalMass, 1f, 13000f)) : 0f);
		trackSpeed = HandleStaticCollisions(flag, atOurFront, trackSpeed, ref wasStaticColliding, trigger);
		if (!flag && otherEndStaticColliding == StaticCollisionState.Free)
		{
			foreach (TrainCar trainContent in trigger.trainContents)
			{
				Vector3 val2 = ((Component)trainContent).transform.forward * trainContent.GetPrevTrackSpeed();
				trackSpeed = HandleTrainCollision(atOurFront, forwardVector, trackSpeed, ((Component)ourTrainCar).transform, trainContent, deltaTime, ref wasStaticColliding);
				num += Vector3.Magnitude(val2 - val) * Mathf.Clamp(trainContent.rigidBody.mass, 1f, 13000f);
			}
			foreach (Rigidbody otherRigidbodyContent in trigger.otherRigidbodyContents)
			{
				trackSpeed = HandleRigidbodyCollision(atOurFront, trackSpeed, forwardVector, ourTotalMass, otherRigidbodyContent, otherRigidbodyContent.velocity, otherRigidbodyContent.mass, deltaTime, calcSecondaryForces: true);
				num += Vector3.Magnitude(otherRigidbodyContent.velocity - val) * Mathf.Clamp(otherRigidbodyContent.mass, 1f, 13000f);
			}
		}
		if (num >= 70000f && TimeSince.op_Implicit(timeSinceLastChange) > 1f && trigger.owner.ApplyCollisionDamage(num) > 5f)
		{
			foreach (Collider colliderContent in trigger.colliderContents)
			{
				Vector3 contactPoint = colliderContent.ClosestPointOnBounds(((Component)trigger.owner).transform.position);
				trigger.owner.TryShowCollisionFX(contactPoint, trigger.owner.collisionEffect);
			}
		}
		return trackSpeed;
	}

	private float HandleStaticCollisions(bool staticColliding, bool front, float trackSpeed, ref StaticCollisionState wasStaticColliding, TriggerTrainCollisions trigger = null)
	{
		float num = (front ? (-5f) : 5f);
		if (staticColliding && (front ? (trackSpeed > num) : (trackSpeed < num)))
		{
			trackSpeed = num;
			wasStaticColliding = StaticCollisionState.StaticColliding;
			HashSet<GameObject> hashSet = (front ? monitoredStaticContentF : monitoredStaticContentR);
			hashSet.Clear();
			if ((Object)(object)trigger != (Object)null)
			{
				foreach (GameObject staticContent in trigger.staticContents)
				{
					hashSet.Add(staticContent);
				}
			}
		}
		else if (wasStaticColliding == StaticCollisionState.StaticColliding)
		{
			trackSpeed = 0f;
			wasStaticColliding = StaticCollisionState.StayingStill;
		}
		else if (wasStaticColliding == StaticCollisionState.StayingStill)
		{
			bool flag = (front ? (trackSpeed > 0.01f) : (trackSpeed < -0.01f));
			bool flag2 = false;
			if (!flag)
			{
				flag2 = (front ? (trackSpeed < -0.01f) : (trackSpeed > 0.01f));
			}
			if (flag)
			{
				HashSet<GameObject> hashSet2 = (front ? monitoredStaticContentF : monitoredStaticContentR);
				if (hashSet2.Count > 0)
				{
					bool flag3 = true;
					foreach (GameObject item in hashSet2)
					{
						if ((Object)(object)item != (Object)null)
						{
							flag3 = false;
							break;
						}
					}
					if (flag3)
					{
						flag = false;
					}
				}
			}
			if (flag)
			{
				trackSpeed = 0f;
			}
			else if (flag2)
			{
				wasStaticColliding = StaticCollisionState.Free;
			}
		}
		else if (front)
		{
			monitoredStaticContentF.Clear();
		}
		else
		{
			monitoredStaticContentR.Clear();
		}
		return trackSpeed;
	}

	private float HandleTrainCollision(bool front, Vector3 forwardVector, float trackSpeed, Transform ourTransform, TrainCar theirTrain, float deltaTime, ref StaticCollisionState wasStaticColliding)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (front ? forwardVector : (-forwardVector));
		float num = Vector3.Angle(val, ((Component)theirTrain).transform.forward);
		Vector3 val2 = ((Component)theirTrain).transform.position - ourTransform.position;
		float num2 = Vector3.Dot(val, ((Vector3)(ref val2)).normalized);
		if ((num > 40f && num < 140f) || Mathf.Abs(num2) < 0.95f)
		{
			trackSpeed = (front ? (-0.5f) : 0.5f);
		}
		else
		{
			List<CompleteTrain> prevTrains = Pool.Get<List<CompleteTrain>>();
			float totalPushingMass = GetTotalPushingMass(val, forwardVector, ref prevTrains);
			trackSpeed = ((!(totalPushingMass < 0f)) ? HandleRigidbodyCollision(front, trackSpeed, forwardVector, TotalMass, theirTrain.rigidBody, theirTrain.GetLocalVelocityServer(), totalPushingMass, deltaTime, calcSecondaryForces: false) : HandleStaticCollisions(staticColliding: true, front, trackSpeed, ref wasStaticColliding));
			prevTrains.Clear();
			float nextTrainTrackSpeed;
			float num3 = GetTotalPushingForces(val, forwardVector, ref prevTrains, out nextTrainTrackSpeed);
			if (!front)
			{
				num3 *= -1f;
			}
			if ((front && num3 <= 0f) || (!front && num3 >= 0f))
			{
				float num4 = Mathf.Max(trackSpeed + 2f, nextTrainTrackSpeed + 2f);
				float num5 = Mathf.Min(trackSpeed - 2f, nextTrainTrackSpeed - 2f);
				trackSpeed += num3 / TotalMass * deltaTime;
				trackSpeed = Mathf.Clamp(trackSpeed, num5, num4);
			}
			Pool.FreeUnmanaged<CompleteTrain>(ref prevTrains);
		}
		return trackSpeed;
	}

	private float HandleRigidbodyCollision(bool atOurFront, float trackSpeed, Vector3 forwardVector, float ourTotalMass, Rigidbody theirRB, Vector3 theirVelocity, float theirTotalMass, float deltaTime, bool calcSecondaryForces)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		if (theirTotalMass < 500f)
		{
			return trackSpeed;
		}
		float num = Vector3.Dot(forwardVector, theirVelocity);
		float num2 = trackSpeed - num;
		if ((atOurFront && num2 <= 0f) || (!atOurFront && num2 >= 0f))
		{
			return trackSpeed;
		}
		float num3 = num2 / deltaTime * theirTotalMass * 0.75f;
		if (calcSecondaryForces)
		{
			if (prevTrackSpeeds.ContainsKey(theirRB))
			{
				float num4 = num2 / deltaTime * ourTotalMass * 0.75f / theirTotalMass * deltaTime;
				float num5 = prevTrackSpeeds[theirRB] - num;
				num3 -= Mathf.Clamp((num5 - num4) * ourTotalMass, 0f, 1000000f);
				prevTrackSpeeds[theirRB] = num;
			}
			else if (num != 0f)
			{
				prevTrackSpeeds.Add(theirRB, num);
			}
		}
		float num6 = num3 / ourTotalMass * deltaTime;
		num6 = Mathf.Clamp(num6, 0f - Mathf.Abs(num - trackSpeed) - 0.5f, Mathf.Abs(num - trackSpeed) + 0.5f);
		trackSpeed -= num6;
		return trackSpeed;
	}

	private float GetTotalPushingMass(Vector3 pushDirection, Vector3 ourForward, ref List<CompleteTrain> prevTrains)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if (prevTrains.Count > 0)
		{
			if (prevTrains.Contains(this))
			{
				if (Global.developer > 1 || Application.isEditor)
				{
					Debug.LogWarning((object)"GetTotalPushingMass: Recursive loop detected. Bailing out.");
				}
				return 0f;
			}
			num += TotalMass;
		}
		prevTrains.Add(this);
		bool flag = Vector3.Dot(ourForward, pushDirection) >= 0f;
		if ((flag ? staticCollidingAtFront : staticCollidingAtRear) != 0)
		{
			return -1f;
		}
		TriggerTrainCollisions triggerTrainCollisions = (flag ? frontCollisionTrigger : rearCollisionTrigger);
		foreach (TrainCar trainContent in triggerTrainCollisions.trainContents)
		{
			if (trainContent.completeTrain != this)
			{
				Vector3 ourForward2 = (trainContent.IsCoupledBackwards() ? (-((Component)trainContent).transform.forward) : ((Component)trainContent).transform.forward);
				float totalPushingMass = trainContent.completeTrain.GetTotalPushingMass(pushDirection, ourForward2, ref prevTrains);
				if (totalPushingMass < 0f)
				{
					return -1f;
				}
				num += totalPushingMass;
			}
		}
		foreach (Rigidbody otherRigidbodyContent in triggerTrainCollisions.otherRigidbodyContents)
		{
			num += otherRigidbodyContent.mass;
		}
		return num;
	}

	private float GetTotalPushingForces(Vector3 pushDirection, Vector3 ourForward, ref List<CompleteTrain> prevTrains, out float nextTrainTrackSpeed)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		nextTrainTrackSpeed = 0f;
		if (prevTrains.Count > 0)
		{
			if (prevTrains.Contains(this))
			{
				if (Global.developer > 1 || Application.isEditor)
				{
					Debug.LogWarning((object)"GetTotalPushingForces: Recursive loop detected. Bailing out.");
				}
				return 0f;
			}
			num += TotalForces;
		}
		prevTrains.Add(this);
		bool num2 = Vector3.Dot(ourForward, pushDirection) >= 0f;
		TriggerTrainCollisions triggerTrainCollisions = (num2 ? frontCollisionTrigger : rearCollisionTrigger);
		if (!num2)
		{
			num *= -1f;
		}
		foreach (TrainCar trainContent in triggerTrainCollisions.trainContents)
		{
			if (trainContent.completeTrain != this)
			{
				Vector3 ourForward2 = (trainContent.IsCoupledBackwards() ? (-((Component)trainContent).transform.forward) : ((Component)trainContent).transform.forward);
				num += trainContent.completeTrain.GetTotalPushingForces(pushDirection, ourForward2, ref prevTrains, out var _);
				if (nextTrainTrackSpeed == 0f)
				{
					nextTrainTrackSpeed = trainContent.completeTrain.trackSpeed;
				}
			}
		}
		return num;
	}
}


private enum ShuntState
{
	None,
	Forwards,
	Backwards
}


public enum StaticCollisionState
{
	Free,
	StaticColliding,
	StayingStill
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class EngineDamageOverTime
{
	private struct RecentDamage
	{
		public readonly float time;

		public readonly float amount;

		public RecentDamage(float time, float amount)
		{
			this.time = time;
			this.amount = amount;
		}
	}

	private readonly List<RecentDamage> recentDamage = new List<RecentDamage>();

	private readonly float maxSeconds;

	private readonly float triggerDamage;

	private readonly Action trigger;

	public EngineDamageOverTime(float triggerDamage, float maxSeconds, Action trigger)
	{
		this.triggerDamage = triggerDamage;
		this.maxSeconds = maxSeconds;
		this.trigger = trigger;
	}

	public void TakeDamage(float amount)
	{
		recentDamage.Add(new RecentDamage(Time.time, amount));
		if (GetRecentDamage() > triggerDamage)
		{
			trigger();
			recentDamage.Clear();
		}
	}

	private float GetRecentDamage()
	{
		float num = 0f;
		int num2;
		for (num2 = this.recentDamage.Count - 1; num2 >= 0; num2--)
		{
			RecentDamage recentDamage = this.recentDamage[num2];
			if (Time.time > recentDamage.time + maxSeconds)
			{
				break;
			}
			num += recentDamage.amount;
		}
		if (num2 > 0)
		{
			this.recentDamage.RemoveRange(0, num2 + 1);
		}
		return num;
	}
}


private struct RecentDamage
{
	public readonly float time;

	public readonly float amount;

	public RecentDamage(float time, float amount)
	{
		this.time = time;
		this.amount = amount;
	}
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class HittableByTrains : EntityComponent<BaseCombatEntity>, ITrainCollidable, TrainTrackSpline.ITrainTrackUser, IOnParentDestroying, IOnParentSpawning
{
	[SerializeField]
	private float trainDamagePerMPS = 10f;

	[SerializeField]
	private float barricadeDamageMultiplier = 0.002f;

	[SerializeField]
	private float minVelToDestroy = 6f;

	[SerializeField]
	private float velReduction = 10f;

	[SerializeField]
	private GameObjectRef barricadeDamageEffect;

	private TrainCar hitTrain;

	private TriggerTrainCollisions hitTrainTrigger;

	private TrainTrackSpline track;

	public Vector3 Position => ((Component)this).transform.position;

	public float FrontWheelSplineDist { get; private set; }

	public TrainCar.TrainCarType CarType => TrainCar.TrainCarType.Other;

	public bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		bool result = false;
		if (base.baseEntity.isServer)
		{
			float num = Mathf.Abs(train.GetTrackSpeed());
			SetHitTrain(train, trainTrigger);
			if (num < minVelToDestroy && !vehicle.cinematictrains)
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)PushForceTick, 0f, 0.25f, 0.025f);
			}
			else
			{
				result = true;
				((FacepunchBehaviour)this).Invoke((Action)DestroyThisBarrier, 0f);
			}
		}
		return result;
	}

	public bool EqualNetID(BaseNetworkable other)
	{
		return base.baseEntity.EqualNetID(other);
	}

	public Vector3 GetWorldVelocity()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return base.baseEntity.GetWorldVelocity();
	}

	public void OnParentSpawning()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		if (TrainTrackSpline.TryFindTrackNear(((Component)this).transform.position, 5f, out var splineResult, out var distResult))
		{
			track = splineResult;
			FrontWheelSplineDist = distResult;
			track.RegisterTrackUser(this);
		}
	}

	public void OnParentDestroying()
	{
		if ((Object)(object)track != (Object)null)
		{
			track.DeregisterTrackUser(this);
		}
	}

	private void SetHitTrain(TrainCar train, TriggerTrainCollisions trainTrigger)
	{
		hitTrain = train;
		hitTrainTrigger = trainTrigger;
	}

	private void ClearHitTrain()
	{
		SetHitTrain(null, null);
	}

	private void DestroyThisBarrier()
	{
		if (base.baseEntity.IsDead() || base.baseEntity.IsDestroyed)
		{
			return;
		}
		if ((Object)(object)hitTrain != (Object)null)
		{
			hitTrain.completeTrain.ReduceSpeedBy(velReduction);
			if (vehicle.cinematictrains)
			{
				hitTrain.Hurt(9999f, DamageType.Collision, base.baseEntity, useProtection: false);
			}
			else
			{
				float amount = Mathf.Abs(hitTrain.GetTrackSpeed()) * trainDamagePerMPS;
				hitTrain.Hurt(amount, DamageType.Collision, base.baseEntity, useProtection: false);
			}
		}
		ClearHitTrain();
		base.baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
	}

	private void PushForceTick()
	{
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)hitTrain == (Object)null || (Object)(object)hitTrainTrigger == (Object)null || hitTrain.IsDead() || hitTrain.IsDestroyed || base.baseEntity.IsDead() || !hitTrain.IsOn())
		{
			ClearHitTrain();
			((FacepunchBehaviour)this).CancelInvoke((Action)PushForceTick);
			return;
		}
		bool flag = true;
		Bounds bounds = hitTrainTrigger.triggerCollider.bounds;
		if (!((Bounds)(ref bounds)).Intersects(base.baseEntity.bounds))
		{
			Vector3 val = ((hitTrainTrigger.location != 0) ? hitTrainTrigger.owner.GetRearOfTrainPos() : hitTrainTrigger.owner.GetFrontOfTrainPos());
			flag = Vector3.SqrMagnitude(((Component)this).transform.position + ((Bounds)(ref base.baseEntity.bounds)).ClosestPoint(val - ((Component)this).transform.position) - val) < 2f;
		}
		if (flag)
		{
			float num = hitTrainTrigger.owner.completeTrain.TotalForces;
			if (hitTrainTrigger.location == TriggerTrainCollisions.Location.Rear)
			{
				num *= -1f;
			}
			num = Mathf.Max(0f, num);
			base.baseEntity.Hurt(num * barricadeDamageMultiplier, DamageType.Generic, hitTrain);
			if (base.baseEntity.IsDead())
			{
				hitTrain.completeTrain.FreeStaticCollision();
			}
		}
		else
		{
			ClearHitTrain();
			((FacepunchBehaviour)this).CancelInvoke((Action)PushForceTick);
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		bool flag = base.baseEntity.lastAttacker is TrainCar;
		info.msg.simpleInt = Pool.Get<SimpleInt>();
		info.msg.simpleInt.value = (flag ? 1 : 0);
	}
}


public interface ITrainCollidable
{
	bool CustomCollision(TrainCar train, TriggerTrainCollisions trainTrigger);

	bool EqualNetID(BaseNetworkable other);
}


using UnityEngine;

public class LocomotiveExtraVisuals : MonoBehaviour
{
	[SerializeField]
	[Header("Gauges")]
	private TrainEngine trainEngine;

	[SerializeField]
	private Transform needleA;

	[SerializeField]
	private Transform needleB;

	[SerializeField]
	private Transform needleC;

	[SerializeField]
	private float maxAngle = 240f;

	[SerializeField]
	private float speedoMoveSpeed = 75f;

	[SerializeField]
	private float pressureMoveSpeed = 25f;

	[SerializeField]
	private float fanAcceleration = 50f;

	[SerializeField]
	private float fanMaxSpeed = 1000f;

	[SerializeField]
	private float speedoMax = 80f;

	[Header("Fans")]
	[SerializeField]
	private Transform[] engineFans;
}


using UnityEngine;

public class MountableParentCombatEntity : BaseCombatEntity
{
	private BaseMountable mountable;

	private BaseMountable Mountable
	{
		get
		{
			if ((Object)(object)mountable == (Object)null)
			{
				mountable = ((Component)this).GetComponentInParent<BaseMountable>();
			}
			return mountable;
		}
	}
}


using UnityEngine;

public class TrainCarAudio : MonoBehaviour
{
	[SerializeField]
	[Header("Train Car Audio")]
	private TrainCar trainCar;

	[SerializeField]
	private SoundDefinition movementStartDef;

	[SerializeField]
	private SoundDefinition movementStopDef;

	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementLoopGainCurve;

	[SerializeField]
	private float movementChangeOneshotDebounce = 1f;

	private Sound movementLoop;

	private SoundModulation.Modulator movementLoopGain;

	[SerializeField]
	private SoundDefinition turnLoopDef;

	private Sound turnLoop;

	[SerializeField]
	private SoundDefinition trackClatterLoopDef;

	[SerializeField]
	private AnimationCurve trackClatterGainCurve;

	[SerializeField]
	private AnimationCurve trackClatterPitchCurve;

	private Sound trackClatterLoop;

	private SoundModulation.Modulator trackClatterGain;

	private SoundModulation.Modulator trackClatterPitch;
}


using System;
using UnityEngine;

public class TrainCarFuelHatches : MonoBehaviour
{
	[SerializeField]
	private TrainCar owner;

	[SerializeField]
	private float animSpeed = 1f;

	[SerializeField]
	private Transform hatch1Col;

	[SerializeField]
	private Transform hatch1Vis;

	[SerializeField]
	private Transform hatch2Col;

	[SerializeField]
	private Transform hatch2Vis;

	[SerializeField]
	private Transform hatch3Col;

	[SerializeField]
	private Transform hatch3Vis;

	private const float closedXAngle = 0f;

	private const float openXAngle = -145f;

	[SerializeField]
	private SoundDefinition hatchOpenSoundDef;

	[SerializeField]
	private SoundDefinition hatchCloseSoundDef;

	private Vector3 _angles = Vector3.zero;

	private float _hatchLerp;

	private bool opening;

	private bool openingQueued;

	private bool isMoving;

	public void LinedUpStateChanged(bool linedUp)
	{
		openingQueued = linedUp;
		if (!isMoving)
		{
			opening = linedUp;
			_ = opening;
			isMoving = true;
			InvokeHandler.InvokeRepeating((Behaviour)(object)this, (Action)MoveTick, 0f, 0f);
		}
	}

	private void MoveTick()
	{
		if (opening)
		{
			_hatchLerp += Time.deltaTime * animSpeed;
			if (_hatchLerp >= 1f)
			{
				EndMove();
			}
			else
			{
				SetAngleOnAll(_hatchLerp, closing: false);
			}
		}
		else
		{
			_hatchLerp += Time.deltaTime * animSpeed;
			if (_hatchLerp >= 1f)
			{
				EndMove();
			}
			else
			{
				SetAngleOnAll(_hatchLerp, closing: true);
			}
		}
	}

	private void EndMove()
	{
		_hatchLerp = 0f;
		if (openingQueued == opening)
		{
			InvokeHandler.CancelInvoke((Behaviour)(object)this, (Action)MoveTick);
			isMoving = false;
		}
		else
		{
			opening = openingQueued;
		}
	}

	private void SetAngleOnAll(float lerpT, bool closing)
	{
		float angle;
		float angle2;
		float angle3;
		if (closing)
		{
			angle = LeanTween.easeOutBounce(-145f, 0f, Mathf.Clamp01(_hatchLerp * 1.15f));
			angle2 = LeanTween.easeOutBounce(-145f, 0f, _hatchLerp);
			angle3 = LeanTween.easeOutBounce(-145f, 0f, Mathf.Clamp01(_hatchLerp * 1.25f));
		}
		else
		{
			angle = LeanTween.easeOutBounce(0f, -145f, Mathf.Clamp01(_hatchLerp * 1.15f));
			angle2 = LeanTween.easeOutBounce(0f, -145f, _hatchLerp);
			angle3 = LeanTween.easeOutBounce(0f, -145f, Mathf.Clamp01(_hatchLerp * 1.25f));
		}
		SetAngle(hatch1Col, angle);
		SetAngle(hatch2Col, angle2);
		SetAngle(hatch3Col, angle3);
	}

	private void SetAngle(Transform transform, float angle)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		_angles.x = angle;
		transform.localEulerAngles = _angles;
	}
}


using System;
using Rust;
using UnityEngine;

public class TrainCarUnloadableLoot : TrainCarUnloadable
{
	[Serializable]
	public class LootCrateSet
	{
		public GameObjectRef[] crates;
	}

	[SerializeField]
	private LootCrateSet[] lootLayouts;

	[SerializeField]
	private Transform[] lootPositions;

	public override void Spawn()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		base.Spawn();
		if (Application.isLoadingSave)
		{
			return;
		}
		int num = Random.Range(0, lootLayouts.Length);
		for (int i = 0; i < lootLayouts[num].crates.Length; i++)
		{
			GameObjectRef gameObjectRef = lootLayouts[num].crates[i];
			BaseEntity baseEntity = GameManager.server.CreateEntity(gameObjectRef.resourcePath, lootPositions[i].localPosition, lootPositions[i].localRotation);
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.Spawn();
				baseEntity.SetParent(this);
			}
		}
	}
}


using System;

[Serializable]
public class LootCrateSet
{
	public GameObjectRef[] crates;
}


using Oxide.Core;
using UnityEngine;

public class TrainCoupling
{
	public readonly TrainCar owner;

	public readonly bool isFrontCoupling;

	public readonly TrainCouplingController controller;

	public readonly Transform couplingPoint;

	public readonly Transform couplingPivot;

	public readonly BaseEntity.Flags flag;

	public readonly bool isValid;

	public TimeSince timeSinceCouplingBlock;

	public bool IsCoupled => owner.HasFlag(flag);

	public bool IsUncoupled => !owner.HasFlag(flag);

	public TrainCoupling CoupledTo { get; private set; }

	public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller)
		: this(owner, isFrontCoupling, controller, null, null, BaseEntity.Flags.Placeholder)
	{
	}

	public TrainCoupling(TrainCar owner, bool isFrontCoupling, TrainCouplingController controller, Transform couplingPoint, Transform couplingPivot, BaseEntity.Flags flag)
	{
		this.owner = owner;
		this.isFrontCoupling = isFrontCoupling;
		this.controller = controller;
		this.couplingPoint = couplingPoint;
		this.couplingPivot = couplingPivot;
		this.flag = flag;
		isValid = (Object)(object)couplingPoint != (Object)null;
	}

	public bool IsCoupledTo(TrainCar them)
	{
		if (CoupledTo != null)
		{
			return (Object)(object)CoupledTo.owner == (Object)(object)them;
		}
		return false;
	}

	public bool IsCoupledTo(TrainCoupling them)
	{
		if (CoupledTo != null)
		{
			return CoupledTo == them;
		}
		return false;
	}

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", (object)owner, (object)theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

	public void Uncouple(bool reflect)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!IsUncoupled)
		{
			if (reflect && CoupledTo != null)
			{
				CoupledTo.Uncouple(reflect: false);
			}
			CoupledTo = null;
			owner.SetFlag(flag, b: false, recursive: false, networkupdate: false);
			owner.SendNetworkUpdate();
			timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
		}
	}

	public TrainCoupling GetOppositeCoupling()
	{
		if (!isFrontCoupling)
		{
			return controller.frontCoupling;
		}
		return controller.rearCoupling;
	}

	public bool TryGetCoupledToID(out NetworkableId id)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (CoupledTo != null && (Object)(object)CoupledTo.owner != (Object)null && CoupledTo.owner.IsValid())
		{
			id = CoupledTo.owner.net.ID;
			return true;
		}
		id = default(NetworkableId);
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TrainCouplingController
{
	public const BaseEntity.Flags Flag_CouplingFront = BaseEntity.Flags.Reserved2;

	public const BaseEntity.Flags Flag_CouplingRear = BaseEntity.Flags.Reserved3;

	public readonly TrainCoupling frontCoupling;

	public readonly TrainCoupling rearCoupling;

	private readonly TrainCar owner;

	[ServerVar(Help = "Maximum difference in velocity for train cars to couple")]
	public static float max_couple_speed = 9f;

	public bool IsCoupled
	{
		get
		{
			if (!IsFrontCoupled)
			{
				return IsRearCoupled;
			}
			return true;
		}
	}

	public bool IsFrontCoupled => owner.HasFlag(BaseEntity.Flags.Reserved2);

	public bool IsRearCoupled => owner.HasFlag(BaseEntity.Flags.Reserved3);

	public TrainCouplingController(TrainCar owner)
	{
		this.owner = owner;
		frontCoupling = new TrainCoupling(owner, isFrontCoupling: true, this, owner.frontCoupling, owner.frontCouplingPivot, BaseEntity.Flags.Reserved2);
		rearCoupling = new TrainCoupling(owner, isFrontCoupling: false, this, owner.rearCoupling, owner.rearCouplingPivot, BaseEntity.Flags.Reserved3);
	}

	public bool IsCoupledTo(TrainCar them)
	{
		if (!frontCoupling.IsCoupledTo(them))
		{
			return rearCoupling.IsCoupledTo(them);
		}
		return true;
	}

	public bool TryCouple(TrainCar them, TriggerTrainCollisions.Location ourLocation)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		TrainCoupling trainCoupling = ((ourLocation == TriggerTrainCollisions.Location.Front) ? frontCoupling : rearCoupling);
		if (!trainCoupling.isValid)
		{
			return false;
		}
		if (trainCoupling.IsCoupled)
		{
			return false;
		}
		if (TimeSince.op_Implicit(trainCoupling.timeSinceCouplingBlock) < 1.5f)
		{
			return false;
		}
		if ((Object)(object)them == (Object)(object)owner)
		{
			return false;
		}
		float num = Vector3.Angle(((Component)owner).transform.forward, ((Component)them).transform.forward);
		if (num > 25f && num < 155f)
		{
			return false;
		}
		bool num2 = num < 90f;
		TrainCoupling trainCoupling2 = ((!num2) ? ((ourLocation == TriggerTrainCollisions.Location.Front) ? them.coupling.frontCoupling : them.coupling.rearCoupling) : ((ourLocation == TriggerTrainCollisions.Location.Front) ? them.coupling.rearCoupling : them.coupling.frontCoupling));
		float num3 = them.GetTrackSpeed();
		if (!num2)
		{
			num3 = 0f - num3;
		}
		if (Mathf.Abs(num3 - owner.GetTrackSpeed()) > max_couple_speed)
		{
			trainCoupling.timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
			trainCoupling2.timeSinceCouplingBlock = TimeSince.op_Implicit(0f);
			return false;
		}
		if (!trainCoupling2.isValid)
		{
			return false;
		}
		if (Vector3.SqrMagnitude(trainCoupling.couplingPoint.position - trainCoupling2.couplingPoint.position) > 0.5f)
		{
			return false;
		}
		TrainTrackSpline frontTrackSection = owner.FrontTrackSection;
		TrainTrackSpline frontTrackSection2 = them.FrontTrackSection;
		if ((Object)(object)frontTrackSection2 != (Object)(object)frontTrackSection && !frontTrackSection.HasConnectedTrack(frontTrackSection2))
		{
			return false;
		}
		return trainCoupling.TryCouple(trainCoupling2, reflect: true);
	}

	public void Uncouple(bool front)
	{
		if (front)
		{
			frontCoupling.Uncouple(reflect: true);
		}
		else
		{
			rearCoupling.Uncouple(reflect: true);
		}
	}

	public void GetAll(ref List<TrainCar> result)
	{
		result.Add(owner);
		TrainCoupling coupledTo = rearCoupling.CoupledTo;
		while (coupledTo != null && coupledTo.IsCoupled && !result.Contains(coupledTo.owner))
		{
			result.Insert(0, coupledTo.owner);
			coupledTo = coupledTo.GetOppositeCoupling();
			coupledTo = coupledTo.CoupledTo;
		}
		TrainCoupling coupledTo2 = frontCoupling.CoupledTo;
		while (coupledTo2 != null && coupledTo2.IsCoupled && !result.Contains(coupledTo2.owner))
		{
			result.Add(coupledTo2.owner);
			coupledTo2 = coupledTo2.GetOppositeCoupling();
			coupledTo2 = coupledTo2.CoupledTo;
		}
	}
}


using System;
using UnityEngine;

public class TrainEngineAudio : TrainCarAudio
{
	[Serializable]
	public class EngineReflection
	{
		public Vector3 direction;

		public Vector3 offset;

		public SoundDefinition soundDef;

		public Sound sound;

		public SoundModulation.Modulator pitchMod;

		public SoundModulation.Modulator gainMod;

		public float distance = 20f;
	}

	[SerializeField]
	private TrainEngine trainEngine;

	[SerializeField]
	private Transform cockpitSoundPosition;

	[SerializeField]
	private Transform hornSoundPosition;

	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[SerializeField]
	private AnimationCurve engineActiveLoopPitchCurve;

	[SerializeField]
	private float engineActiveLoopChangeSpeed = 0.2f;

	private Sound engineActiveLoop;

	private SoundModulation.Modulator engineActiveLoopPitch;

	[SerializeField]
	private BlendedLoopEngineSound engineLoops;

	[SerializeField]
	private EngineReflection[] engineReflections;

	[SerializeField]
	private LayerMask reflectionLayerMask;

	[SerializeField]
	private float reflectionMaxDistance = 20f;

	[SerializeField]
	private float reflectionGainChangeSpeed = 10f;

	[SerializeField]
	private float reflectionPositionChangeSpeed = 10f;

	[SerializeField]
	private float reflectionRayOffset = 0.5f;

	[SerializeField]
	[Header("Horn")]
	private SoundDefinition hornLoop;

	[SerializeField]
	private SoundDefinition hornStart;

	[Header("Other")]
	[SerializeField]
	private SoundDefinition lightsToggleSound;

	[SerializeField]
	private SoundDefinition proximityAlertDef;

	private Sound proximityAlertSound;

	[SerializeField]
	private SoundDefinition damagedLoopDef;

	private Sound damagedLoop;

	[SerializeField]
	private SoundDefinition changeThrottleDef;

	[SerializeField]
	private SoundDefinition changeCouplingDef;

	[SerializeField]
	private SoundDefinition unloadableStartDef;

	[SerializeField]
	private SoundDefinition unloadableEndDef;

	[SerializeField]
	private GameObject bellObject;

	[SerializeField]
	private SoundDefinition bellRingDef;

	[SerializeField]
	private SoundPlayer brakeSound;
}


using System;
using UnityEngine;

[Serializable]
public class EngineReflection
{
	public Vector3 direction;

	public Vector3 offset;

	public SoundDefinition soundDef;

	public Sound sound;

	public SoundModulation.Modulator pitchMod;

	public SoundModulation.Modulator gainMod;

	public float distance = 20f;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class TrainTrackSpline : WorldSpline
{
	public enum TrackSelection
	{
		Default,
		Left,
		Right
	}

	public enum TrackPosition
	{
		Next,
		Prev
	}

	public enum TrackOrientation
	{
		Same,
		Reverse
	}

	public class ConnectedTrackInfo
	{
		public readonly TrainTrackSpline track;

		public readonly TrackOrientation orientation;

		public readonly float angle;

		public ConnectedTrackInfo(TrainTrackSpline track, TrackOrientation orientation, float angle)
		{
			this.track = track;
			this.orientation = orientation;
			this.angle = angle;
		}
	}

	public enum DistanceType
	{
		SplineDistance,
		WorldDistance
	}

	public interface ITrainTrackUser
	{
		Vector3 Position { get; }

		float FrontWheelSplineDist { get; }

		TrainCar.TrainCarType CarType { get; }

		Vector3 GetWorldVelocity();
	}

	public struct MoveRequest
	{
		public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);

		public float distAlongSpline;

		public float maxMoveDist;

		public SplineAction onSpline;

		public TrackRequest trackRequest;

		public float totalDistMoved;

		public float ProjectEndDist(bool facingForward)
		{
			if (!facingForward)
			{
				return distAlongSpline - maxMoveDist;
			}
			return distAlongSpline + maxMoveDist;
		}

		public MoveRequest(float distAlongSpline, float maxMoveDist, SplineAction onSpline, TrackRequest trackRequest)
		{
			this.distAlongSpline = distAlongSpline;
			this.maxMoveDist = maxMoveDist;
			this.onSpline = onSpline;
			this.trackRequest = trackRequest;
			totalDistMoved = 0f;
		}
	}

	public struct TrackRequest
	{
		public TrackSelection trackSelection;

		public TrainTrackSpline preferredAltA;

		public TrainTrackSpline preferredAltB;

		public TrackRequest(TrackSelection trackSelection, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
		{
			this.trackSelection = trackSelection;
			this.preferredAltA = preferredAltA;
			this.preferredAltB = preferredAltB;
		}
	}

	public struct MoveResult
	{
		public TrainTrackSpline spline;

		public float distAlongSpline;

		public bool atEndOfLine;

		public TrainSignal signal;

		public float totalDistMoved;
	}

	[Tooltip("Is this track spline part of a train station?")]
	public bool isStation;

	[Tooltip("Can above-ground trains spawn here?")]
	public bool aboveGroundSpawn;

	public int hierarchy;

	public static List<TrainTrackSpline> SidingSplines = new List<TrainTrackSpline>();

	public readonly List<ConnectedTrackInfo> nextTracks = new List<ConnectedTrackInfo>();

	public int straightestNextIndex;

	public readonly List<ConnectedTrackInfo> prevTracks = new List<ConnectedTrackInfo>();

	public int straightestPrevIndex;

	[NonSerialized]
	public HashSet<ITrainTrackUser> trackUsers = new HashSet<ITrainTrackUser>();

	[NonSerialized]
	public HashSet<TrainSignal> signals = new HashSet<TrainSignal>();

	public bool HasNextTrack => nextTracks.Count > 0;

	public bool HasPrevTrack => prevTracks.Count > 0;

	public void SetAll(Vector3[] points, Vector3[] tangents, TrainTrackSpline sourceSpline)
	{
		base.points = points;
		base.tangents = tangents;
		lutInterval = sourceSpline.lutInterval;
		isStation = sourceSpline.isStation;
		aboveGroundSpawn = sourceSpline.aboveGroundSpawn;
		hierarchy = sourceSpline.hierarchy;
	}

	public MoveResult MoveAlongSpline(float prevSplineDist, Vector3 askerForward, float distMoved, TrackRequest tReq = default(TrackRequest), MoveRequest.SplineAction onSpline = null)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		MoveRequest request = new MoveRequest(prevSplineDist, distMoved, onSpline, tReq);
		bool facingForward = IsForward(askerForward, prevSplineDist);
		return MoveAlongSpline(request, facingForward, 0f);
	}

	private MoveResult MoveAlongSpline(MoveRequest request, bool facingForward, float prevDistMoved)
	{
		MoveResult moveResult = default(MoveResult);
		moveResult.totalDistMoved = prevDistMoved;
		MoveResult result = moveResult;
		WorldSplineData data = GetData();
		result.distAlongSpline = request.ProjectEndDist(facingForward);
		if (request.onSpline != null)
		{
			result = request.onSpline(result, request, this, data.Length);
		}
		result.spline = this;
		if (result.distAlongSpline < 0f)
		{
			result.totalDistMoved += request.distAlongSpline;
			result = MoveToPrevSpline(result, request, facingForward);
		}
		else if (result.distAlongSpline > data.Length)
		{
			result.totalDistMoved += data.Length - request.distAlongSpline;
			result = MoveToNextSpline(result, request, facingForward, data.Length);
		}
		else
		{
			result.totalDistMoved += Mathf.Abs(result.distAlongSpline - request.distAlongSpline);
		}
		return result;
	}

	private MoveResult MoveToNextSpline(MoveResult result, MoveRequest request, bool facingForward, float splineLength)
	{
		if (HasNextTrack)
		{
			ConnectedTrackInfo trackSelection = GetTrackSelection(nextTracks, straightestNextIndex, nextTrack: true, facingForward, request.trackRequest);
			request.maxMoveDist = (facingForward ? (result.distAlongSpline - splineLength) : (0f - (result.distAlongSpline - splineLength)));
			if (trackSelection.orientation == TrackOrientation.Same)
			{
				request.distAlongSpline = 0f;
			}
			else
			{
				request.distAlongSpline = trackSelection.track.GetLength();
				facingForward = !facingForward;
			}
			return trackSelection.track.MoveAlongSpline(request, facingForward, result.totalDistMoved);
		}
		result.atEndOfLine = true;
		result.distAlongSpline = splineLength;
		return result;
	}

	private MoveResult MoveToPrevSpline(MoveResult result, MoveRequest request, bool facingForward)
	{
		if (HasPrevTrack)
		{
			ConnectedTrackInfo trackSelection = GetTrackSelection(prevTracks, straightestPrevIndex, nextTrack: false, facingForward, request.trackRequest);
			request.maxMoveDist = (facingForward ? result.distAlongSpline : (0f - result.distAlongSpline));
			if (trackSelection.orientation == TrackOrientation.Same)
			{
				request.distAlongSpline = trackSelection.track.GetLength();
			}
			else
			{
				request.distAlongSpline = 0f;
				facingForward = !facingForward;
			}
			return trackSelection.track.MoveAlongSpline(request, facingForward, result.totalDistMoved);
		}
		result.atEndOfLine = true;
		result.distAlongSpline = 0f;
		return result;
	}

	public float GetDistance(Vector3 position, float maxError, out float minSplineDist)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		float num = maxError * maxError;
		Vector3 val = ((Component)this).transform.InverseTransformPoint(position);
		float num2 = float.MaxValue;
		minSplineDist = 0f;
		int num3 = 0;
		int num4 = data.LUTValues.Count;
		if (data.Length > 40f)
		{
			for (int i = 0; (float)i < data.Length + 10f; i += 10)
			{
				float num5 = Vector3.SqrMagnitude(data.GetPointCubicHermite(i) - val);
				if (num5 < num2)
				{
					num2 = num5;
					minSplineDist = i;
				}
			}
			num3 = Mathf.FloorToInt(Mathf.Max(0f, minSplineDist - 10f + 1f));
			num4 = Mathf.CeilToInt(Mathf.Min((float)data.LUTValues.Count, minSplineDist + 10f - 1f));
		}
		for (int j = num3; j < num4; j++)
		{
			WorldSplineData.LUTEntry lUTEntry = data.LUTValues[j];
			for (int k = 0; k < lUTEntry.points.Count; k++)
			{
				WorldSplineData.LUTEntry.LUTPoint lUTPoint = lUTEntry.points[k];
				float num6 = Vector3.SqrMagnitude(lUTPoint.pos - val);
				if (num6 < num2)
				{
					num2 = num6;
					minSplineDist = lUTPoint.distance;
					if (num6 < num)
					{
						break;
					}
				}
			}
		}
		return Mathf.Sqrt(num2);
	}

	public float GetLength()
	{
		return GetData().Length;
	}

	public Vector3 GetPosition(float distance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GetPointCubicHermiteWorld(distance);
	}

	public Vector3 GetPositionAndTangent(float distance, Vector3 askerForward, out Vector3 tangent)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermiteWorld = GetPointAndTangentCubicHermiteWorld(distance, out tangent);
		if (Vector3.Dot(askerForward, tangent) < 0f)
		{
			tangent = -tangent;
		}
		return pointAndTangentCubicHermiteWorld;
	}

	public void AddTrackConnection(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		List<ConnectedTrackInfo> list = ((p == TrackPosition.Next) ? nextTracks : prevTracks);
		for (int i = 0; i < list.Count; i++)
		{
			if ((Object)(object)list[i].track == (Object)(object)track)
			{
				return;
			}
		}
		Vector3 val = ((p == TrackPosition.Next) ? points[points.Length - 2] : points[0]);
		Vector3 val2 = ((p == TrackPosition.Next) ? points[points.Length - 1] : points[1]);
		Vector3 val3 = ((Component)this).transform.TransformPoint(val2) - ((Component)this).transform.TransformPoint(val);
		Vector3 initialVector = GetInitialVector(track, p, o);
		float num = Vector3.SignedAngle(val3, initialVector, Vector3.up);
		int j;
		for (j = 0; j < list.Count && !(list[j].angle > num); j++)
		{
		}
		list.Insert(j, new ConnectedTrackInfo(track, o, num));
		int num2 = int.MaxValue;
		for (int k = 0; k < list.Count; k++)
		{
			num2 = Mathf.Min(num2, list[k].track.hierarchy);
		}
		float num3 = float.MaxValue;
		int num4 = 0;
		for (int l = 0; l < list.Count; l++)
		{
			ConnectedTrackInfo connectedTrackInfo = list[l];
			if (connectedTrackInfo.track.hierarchy > num2)
			{
				continue;
			}
			float num5 = Mathf.Abs(connectedTrackInfo.angle);
			if (num5 < num3)
			{
				num3 = num5;
				num4 = l;
				if (num3 == 0f)
				{
					break;
				}
			}
		}
		if (p == TrackPosition.Next)
		{
			straightestNextIndex = num4;
		}
		else
		{
			straightestPrevIndex = num4;
		}
	}

	public void RegisterTrackUser(ITrainTrackUser user)
	{
		trackUsers.Add(user);
	}

	public void DeregisterTrackUser(ITrainTrackUser user)
	{
		if (user != null)
		{
			trackUsers.Remove(user);
		}
	}

	public void RegisterSignal(TrainSignal signal)
	{
		signals.Add(signal);
	}

	public void DeregisterSignal(TrainSignal signal)
	{
		if (!((Object)(object)signal == (Object)null))
		{
			signals.Remove(signal);
		}
	}

	public bool IsForward(Vector3 askerForward, float askerSplineDist)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		Vector3 tangentCubicHermiteWorld = GetTangentCubicHermiteWorld(askerSplineDist, data);
		return Vector3.Dot(askerForward, tangentCubicHermiteWorld) >= 0f;
	}

	public bool HasValidHazardWithin(TrainCar asker, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, float trackSpeed, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 askerForward = ((trackSpeed >= 0f) ? ((Component)asker).transform.forward : (-((Component)asker).transform.forward));
		bool movingForward = IsForward(askerForward, askerSplineDist);
		return HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist, maxHazardDist, trackSelection, movingForward, preferredAltA, preferredAltB);
	}

	public bool HasValidHazardWithin(ITrainTrackUser asker, Vector3 askerForward, float askerSplineDist, float minHazardDist, float maxHazardDist, TrackSelection trackSelection, bool movingForward, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		WorldSplineData data = GetData();
		foreach (ITrainTrackUser trackUser in trackUsers)
		{
			if (trackUser == asker)
			{
				continue;
			}
			Vector3 val = trackUser.Position - asker.Position;
			if (!(Vector3.Dot(askerForward, val) >= 0f))
			{
				continue;
			}
			float magnitude = ((Vector3)(ref val)).magnitude;
			if (magnitude > minHazardDist && magnitude < maxHazardDist)
			{
				Vector3 worldVelocity = trackUser.GetWorldVelocity();
				if (((Vector3)(ref worldVelocity)).sqrMagnitude < 4f || Vector3.Dot(worldVelocity, val) < 0f)
				{
					return true;
				}
			}
		}
		float num = (movingForward ? (askerSplineDist + minHazardDist) : (askerSplineDist - minHazardDist));
		float num2 = (movingForward ? (askerSplineDist + maxHazardDist) : (askerSplineDist - maxHazardDist));
		if (num2 < 0f)
		{
			if (HasPrevTrack)
			{
				ConnectedTrackInfo connectedTrackInfo = GetTrackSelection(request: new TrackRequest(trackSelection, preferredAltA, preferredAltB), trackOptions: prevTracks, straightestIndex: straightestPrevIndex, nextTrack: false, trainForward: movingForward);
				if (connectedTrackInfo.orientation == TrackOrientation.Same)
				{
					askerSplineDist = connectedTrackInfo.track.GetLength();
				}
				else
				{
					askerSplineDist = 0f;
					movingForward = !movingForward;
				}
				float minHazardDist2 = Mathf.Max(0f - num, 0f);
				float maxHazardDist2 = 0f - num2;
				return connectedTrackInfo.track.HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist2, maxHazardDist2, trackSelection, movingForward, preferredAltA, preferredAltB);
			}
		}
		else if (num2 > data.Length && HasNextTrack)
		{
			ConnectedTrackInfo connectedTrackInfo2 = GetTrackSelection(request: new TrackRequest(trackSelection, preferredAltA, preferredAltB), trackOptions: nextTracks, straightestIndex: straightestNextIndex, nextTrack: true, trainForward: movingForward);
			if (connectedTrackInfo2.orientation == TrackOrientation.Same)
			{
				askerSplineDist = 0f;
			}
			else
			{
				askerSplineDist = connectedTrackInfo2.track.GetLength();
				movingForward = !movingForward;
			}
			float minHazardDist3 = Mathf.Max(num - data.Length, 0f);
			float maxHazardDist3 = num2 - data.Length;
			return connectedTrackInfo2.track.HasValidHazardWithin(asker, askerForward, askerSplineDist, minHazardDist3, maxHazardDist3, trackSelection, movingForward, preferredAltA, preferredAltB);
		}
		return false;
	}

	public bool HasAnyUsers()
	{
		return trackUsers.Count > 0;
	}

	public bool HasAnyUsersOfType(TrainCar.TrainCarType carType)
	{
		foreach (ITrainTrackUser trackUser in trackUsers)
		{
			if (trackUser.CarType == carType)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectedTrack(TrainTrackSpline tts)
	{
		if (!HasConnectedNextTrack(tts))
		{
			return HasConnectedPrevTrack(tts);
		}
		return true;
	}

	public bool HasConnectedNextTrack(TrainTrackSpline tts)
	{
		foreach (ConnectedTrackInfo nextTrack in nextTracks)
		{
			if ((Object)(object)nextTrack.track == (Object)(object)tts)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasConnectedPrevTrack(TrainTrackSpline tts)
	{
		foreach (ConnectedTrackInfo prevTrack in prevTracks)
		{
			if ((Object)(object)prevTrack.track == (Object)(object)tts)
			{
				return true;
			}
		}
		return false;
	}

	public static Vector3 GetInitialVector(TrainTrackSpline track, TrackPosition p, TrackOrientation o)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val;
		Vector3 val2;
		if (p == TrackPosition.Next)
		{
			if (o == TrackOrientation.Reverse)
			{
				val = track.points[track.points.Length - 1];
				val2 = track.points[track.points.Length - 2];
			}
			else
			{
				val = track.points[0];
				val2 = track.points[1];
			}
		}
		else if (o == TrackOrientation.Reverse)
		{
			val = track.points[1];
			val2 = track.points[0];
		}
		else
		{
			val = track.points[track.points.Length - 2];
			val2 = track.points[track.points.Length - 1];
		}
		return ((Component)track).transform.TransformPoint(val2) - ((Component)track).transform.TransformPoint(val);
	}

	protected override void OnDrawGizmosSelected()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmosSelected();
		for (int i = 0; i < nextTracks.Count; i++)
		{
			Color splineColour = Color.white;
			if (straightestNextIndex != i && nextTracks.Count > 1)
			{
				if (i == 0)
				{
					splineColour = Color.green;
				}
				else if (i == nextTracks.Count - 1)
				{
					splineColour = Color.yellow;
				}
			}
			WorldSpline.DrawSplineGizmo(nextTracks[i].track, splineColour);
		}
		for (int j = 0; j < prevTracks.Count; j++)
		{
			Color splineColour2 = Color.white;
			if (straightestPrevIndex != j && prevTracks.Count > 1)
			{
				if (j == 0)
				{
					splineColour2 = Color.green;
				}
				else if (j == nextTracks.Count - 1)
				{
					splineColour2 = Color.yellow;
				}
			}
			WorldSpline.DrawSplineGizmo(prevTracks[j].track, splineColour2);
		}
	}

	public ConnectedTrackInfo GetTrackSelection(List<ConnectedTrackInfo> trackOptions, int straightestIndex, bool nextTrack, bool trainForward, TrackRequest request)
	{
		if (trackOptions.Count == 1)
		{
			return trackOptions[0];
		}
		foreach (ConnectedTrackInfo trackOption in trackOptions)
		{
			if ((Object)(object)trackOption.track == (Object)(object)request.preferredAltA || (Object)(object)trackOption.track == (Object)(object)request.preferredAltB)
			{
				return trackOption;
			}
		}
		bool flag = nextTrack ^ trainForward;
		switch (request.trackSelection)
		{
		case TrackSelection.Left:
			if (!flag)
			{
				return trackOptions[0];
			}
			return trackOptions[trackOptions.Count - 1];
		case TrackSelection.Right:
			if (!flag)
			{
				return trackOptions[trackOptions.Count - 1];
			}
			return trackOptions[0];
		default:
			return trackOptions[straightestIndex];
		}
	}

	public static bool TryFindTrackNear(Vector3 pos, float maxDist, out TrainTrackSpline splineResult, out float distResult)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		splineResult = null;
		distResult = 0f;
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, maxDist, list, 65536, (QueryTriggerInteraction)1);
		if (list.Count > 0)
		{
			List<TrainTrackSpline> list2 = Pool.Get<List<TrainTrackSpline>>();
			float num = float.MaxValue;
			foreach (Collider item in list)
			{
				((Component)item).GetComponentsInParent<TrainTrackSpline>(false, list2);
				if (list2.Count <= 0)
				{
					continue;
				}
				foreach (TrainTrackSpline item2 in list2)
				{
					float minSplineDist;
					float distance = item2.GetDistance(pos, 1f, out minSplineDist);
					if (distance < num)
					{
						num = distance;
						distResult = minSplineDist;
						splineResult = item2;
					}
				}
			}
			Pool.FreeUnmanaged<TrainTrackSpline>(ref list2);
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return (Object)(object)splineResult != (Object)null;
	}
}


public enum TrackSelection
{
	Default,
	Left,
	Right
}


public enum TrackPosition
{
	Next,
	Prev
}


public enum TrackOrientation
{
	Same,
	Reverse
}


public class ConnectedTrackInfo
{
	public readonly TrainTrackSpline track;

	public readonly TrackOrientation orientation;

	public readonly float angle;

	public ConnectedTrackInfo(TrainTrackSpline track, TrackOrientation orientation, float angle)
	{
		this.track = track;
		this.orientation = orientation;
		this.angle = angle;
	}
}


public enum DistanceType
{
	SplineDistance,
	WorldDistance
}


using UnityEngine;

public interface ITrainTrackUser
{
	Vector3 Position { get; }

	float FrontWheelSplineDist { get; }

	TrainCar.TrainCarType CarType { get; }

	Vector3 GetWorldVelocity();
}


public struct MoveRequest
{
	public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);

	public float distAlongSpline;

	public float maxMoveDist;

	public SplineAction onSpline;

	public TrackRequest trackRequest;

	public float totalDistMoved;

	public float ProjectEndDist(bool facingForward)
	{
		if (!facingForward)
		{
			return distAlongSpline - maxMoveDist;
		}
		return distAlongSpline + maxMoveDist;
	}

	public MoveRequest(float distAlongSpline, float maxMoveDist, SplineAction onSpline, TrackRequest trackRequest)
	{
		this.distAlongSpline = distAlongSpline;
		this.maxMoveDist = maxMoveDist;
		this.onSpline = onSpline;
		this.trackRequest = trackRequest;
		totalDistMoved = 0f;
	}
}


public delegate MoveResult SplineAction(MoveResult result, MoveRequest request, TrainTrackSpline spline, float splineLength);


public struct TrackRequest
{
	public TrackSelection trackSelection;

	public TrainTrackSpline preferredAltA;

	public TrainTrackSpline preferredAltB;

	public TrackRequest(TrackSelection trackSelection, TrainTrackSpline preferredAltA, TrainTrackSpline preferredAltB)
	{
		this.trackSelection = trackSelection;
		this.preferredAltA = preferredAltA;
		this.preferredAltB = preferredAltB;
	}
}


public struct MoveResult
{
	public TrainTrackSpline spline;

	public float distAlongSpline;

	public bool atEndOfLine;

	public TrainSignal signal;

	public float totalDistMoved;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Scriptable Object/Vehicles/Train Wagon Loot Data", fileName = "Train Wagon Loot Data")]
public class TrainWagonLootData : ScriptableObject
{
	[Serializable]
	public class LootOption
	{
		public bool showsFX = true;

		public ItemDefinition lootItem;

		[FormerlySerializedAs("lootAmount")]
		public int maxLootAmount;

		public int minLootAmount;

		public Material lootMaterial;

		public float spawnWeighting = 1f;

		public Color fxTint;

		[FormerlySerializedAs("indoorFXTint")]
		public Color particleFXTint;
	}

	[SerializeField]
	private LootOption[] oreOptions;

	[SerializeField]
	[ReadOnly]
	private LootOption lootWagonContent;

	[SerializeField]
	private LootOption fuelWagonContent;

	private static TrainWagonLootData _instance;

	private const int LOOT_WAGON_INDEX = 1000;

	private const int FUEL_WAGON_INDEX = 1001;

	public static TrainWagonLootData instance
	{
		get
		{
			if ((Object)(object)_instance == (Object)null)
			{
				_instance = Resources.Load<TrainWagonLootData>("Train Wagon Loot Data");
			}
			return _instance;
		}
	}

	public LootOption GetLootOption(TrainCarUnloadable.WagonType wagonType, out int index)
	{
		switch (wagonType)
		{
		case TrainCarUnloadable.WagonType.Lootboxes:
			index = 1000;
			return lootWagonContent;
		case TrainCarUnloadable.WagonType.Fuel:
			index = 1001;
			return fuelWagonContent;
		default:
		{
			float num = 0f;
			LootOption[] array = oreOptions;
			foreach (LootOption lootOption in array)
			{
				num += lootOption.spawnWeighting;
			}
			float num2 = Random.value * num;
			for (index = 0; index < oreOptions.Length; index++)
			{
				if ((num2 -= oreOptions[index].spawnWeighting) < 0f)
				{
					return oreOptions[index];
				}
			}
			return oreOptions[index];
		}
		}
	}

	public bool TryGetLootFromIndex(int index, out LootOption lootOption)
	{
		switch (index)
		{
		case 1000:
			lootOption = lootWagonContent;
			return true;
		case 1001:
			lootOption = fuelWagonContent;
			return true;
		default:
			index = Mathf.Clamp(index, 0, oreOptions.Length - 1);
			lootOption = oreOptions[index];
			return true;
		}
	}

	public bool TryGetIndexFromLoot(LootOption lootOption, out int index)
	{
		if (lootOption == lootWagonContent)
		{
			index = 1000;
			return true;
		}
		if (lootOption == fuelWagonContent)
		{
			index = 1001;
			return true;
		}
		for (index = 0; index < oreOptions.Length; index++)
		{
			if (oreOptions[index] == lootOption)
			{
				return true;
			}
		}
		index = -1;
		return false;
	}

	public static float GetOrePercent(int lootTypeIndex, StorageContainer sc)
	{
		if (instance.TryGetLootFromIndex(lootTypeIndex, out var lootOption))
		{
			return GetOrePercent(lootOption, sc);
		}
		return 0f;
	}

	public static void SetOrePercent(int lootTypeIndex, StorageContainer sc, float percent)
	{
		if (instance.TryGetLootFromIndex(lootTypeIndex, out var lootOption))
		{
			SetOrePercent(lootOption, sc, percent);
		}
	}

	public static float GetOrePercent(LootOption lootOption, StorageContainer sc)
	{
		float result = 0f;
		if (sc.IsValid())
		{
			int maxLootAmount = lootOption.maxLootAmount;
			result = (((float)maxLootAmount != 0f) ? Mathf.Clamp01((float)sc.inventory.GetAmount(lootOption.lootItem.itemid, onlyUsableAmounts: false) / (float)maxLootAmount) : 0f);
		}
		return result;
	}

	public static void SetOrePercent(LootOption lootOption, StorageContainer sc, float percent)
	{
		if (!sc.IsValid())
		{
			return;
		}
		int maxLootAmount = lootOption.maxLootAmount;
		if ((float)maxLootAmount > 0f)
		{
			Item item = sc.inventory.FindItemByItemID(lootOption.lootItem.itemid);
			if (item != null)
			{
				item.amount = Mathf.Max(Mathf.RoundToInt((float)maxLootAmount * percent), 1);
			}
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class LootOption
{
	public bool showsFX = true;

	public ItemDefinition lootItem;

	[FormerlySerializedAs("lootAmount")]
	public int maxLootAmount;

	public int minLootAmount;

	public Material lootMaterial;

	public float spawnWeighting = 1f;

	public Color fxTint;

	[FormerlySerializedAs("indoorFXTint")]
	public Color particleFXTint;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TriggerTrainCollisions : TriggerBase
{
	public enum Location
	{
		Front,
		Rear
	}

	public Collider triggerCollider;

	public Location location;

	public TrainCar owner;

	[NonSerialized]
	public HashSet<GameObject> staticContents = new HashSet<GameObject>();

	[NonSerialized]
	public HashSet<TrainCar> trainContents = new HashSet<TrainCar>();

	[NonSerialized]
	public HashSet<Rigidbody> otherRigidbodyContents = new HashSet<Rigidbody>();

	[NonSerialized]
	public HashSet<Collider> colliderContents = new HashSet<Collider>();

	private const float TICK_RATE = 0.2f;

	public bool HasAnyStaticContents => staticContents.Count > 0;

	public bool HasAnyTrainContents => trainContents.Count > 0;

	public bool HasAnyOtherRigidbodyContents => otherRigidbodyContents.Count > 0;

	public bool HasAnyNonStaticContents
	{
		get
		{
			if (!HasAnyTrainContents)
			{
				return HasAnyOtherRigidbodyContents;
			}
			return true;
		}
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (!owner.isServer)
		{
			return;
		}
		base.OnObjectAdded(obj, col);
		if ((Object)(object)obj != (Object)null)
		{
			BaseEntity baseEntity = obj.ToBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 val = ((Component)baseEntity).transform.position + ((Component)baseEntity).transform.rotation * Vector3.Scale(obj.transform.lossyScale, ((Bounds)(ref baseEntity.bounds)).center);
				Bounds bounds = triggerCollider.bounds;
				Vector3 center = ((Bounds)(ref bounds)).center;
				Vector3 val2 = val - center;
				bool flag = Vector3.Dot(((Component)owner).transform.forward, val2) > 0f;
				if ((location == Location.Front && !flag) || (location == Location.Rear && flag))
				{
					return;
				}
			}
		}
		if ((Object)(object)obj != (Object)null)
		{
			Rigidbody componentInParent = obj.GetComponentInParent<Rigidbody>();
			if ((Object)(object)componentInParent != (Object)null)
			{
				TrainCar componentInParent2 = obj.GetComponentInParent<TrainCar>();
				if ((Object)(object)componentInParent2 != (Object)null && (Object)(object)componentInParent2 != (Object)(object)owner)
				{
					trainContents.Add(componentInParent2);
					if (owner.coupling != null)
					{
						owner.coupling.TryCouple(componentInParent2, location);
					}
					((FacepunchBehaviour)this).InvokeRepeating((Action)TrainContentsTick, 0.2f, 0.2f);
				}
				else
				{
					otherRigidbodyContents.Add(componentInParent);
				}
			}
			else
			{
				ITrainCollidable componentInParent3 = obj.GetComponentInParent<ITrainCollidable>();
				if (componentInParent3 == null)
				{
					if (!obj.CompareTag("Railway"))
					{
						staticContents.Add(obj);
					}
				}
				else if (!componentInParent3.EqualNetID(owner) && !componentInParent3.CustomCollision(owner, this))
				{
					staticContents.Add(obj);
				}
			}
		}
		if ((Object)(object)col != (Object)null)
		{
			colliderContents.Add(col);
		}
	}

	internal override void OnObjectRemoved(GameObject obj)
	{
		if (!owner.isServer || (Object)(object)obj == (Object)null)
		{
			return;
		}
		Collider[] components = obj.GetComponents<Collider>();
		foreach (Collider item in components)
		{
			colliderContents.Remove(item);
		}
		if (!staticContents.Remove(obj))
		{
			TrainCar componentInParent = obj.GetComponentInParent<TrainCar>();
			if ((Object)(object)componentInParent != (Object)null && (Object)(object)componentInParent != (Object)(object)owner)
			{
				if (!HasAnotherColliderFor<TrainCar>(componentInParent))
				{
					trainContents.Remove(componentInParent);
					if (trainContents == null || trainContents.Count == 0)
					{
						((FacepunchBehaviour)this).CancelInvoke((Action)TrainContentsTick);
					}
				}
			}
			else
			{
				Rigidbody componentInParent2 = obj.GetComponentInParent<Rigidbody>();
				if (!HasAnotherColliderFor<Rigidbody>(componentInParent2))
				{
					otherRigidbodyContents.Remove(componentInParent2);
				}
			}
		}
		base.OnObjectRemoved(obj);
		bool HasAnotherColliderFor<T>(T component) where T : Component
		{
			foreach (Collider colliderContent in colliderContents)
			{
				if ((Object)(object)colliderContent != (Object)null && (Object)(object)((Component)colliderContent).GetComponentInParent<T>() == (Object)(object)component)
				{
					return true;
				}
			}
			return false;
		}
	}

	private void TrainContentsTick()
	{
		if (trainContents == null)
		{
			return;
		}
		foreach (TrainCar trainContent in trainContents)
		{
			if (trainContent.IsValid() && !trainContent.IsDestroyed && owner.coupling != null)
			{
				owner.coupling.TryCouple(trainContent, location);
			}
		}
	}
}


public enum Location
{
	Front,
	Rear
}


using System;
using UnityEngine;

[Serializable]
public class VisualCarWheel : CarWheel
{
	public Transform visualWheel;

	public Transform visualWheelSteering;

	public bool visualPowerWheel = true;

	public ParticleSystem snowFX;

	public ParticleSystem sandFX;

	public ParticleSystem dirtFX;

	public ParticleSystem asphaltFX;

	public ParticleSystem waterFX;

	public ParticleSystem snowSpinFX;

	public ParticleSystem sandSpinFX;

	public ParticleSystem dirtSpinFX;

	public ParticleSystem asphaltSpinFX;
}


using UnityEngine;

public abstract class VehicleChassisVisuals<T> : MonoBehaviour where T : BaseEntity, VehicleChassisVisuals<T>.IClientWheelUser
{
	public interface IClientWheelUser
	{
		Vector3 Velocity { get; }

		float DriveWheelVelocity { get; }

		float SteerAngle { get; }

		float MaxSteerAngle { get; }

		float GetThrottleInput();
	}
}


using UnityEngine;

public interface IClientWheelUser
{
	Vector3 Velocity { get; }

	float DriveWheelVelocity { get; }

	float SteerAngle { get; }

	float MaxSteerAngle { get; }

	float GetThrottleInput();
}


using System;
using Rust;

public interface IEngineControllerUser : IEntity
{
	bool HasFlag(BaseEntity.Flags f);

	bool IsDead();

	void SetFlag(BaseEntity.Flags f, bool b, bool recursive = false, bool networkupdate = true);

	void Invoke(Action action, float time);

	void CancelInvoke(Action action);

	void OnEngineStartFailed();

	bool MeetsEngineRequirements();
}


using System;
using Oxide.Core;
using UnityEngine;

public class VehicleEngineController<TOwner> where TOwner : BaseMountable, IEngineControllerUser
{
	public enum EngineState
	{
		Off,
		Starting,
		On
	}

	public readonly TOwner owner;

	private readonly bool isServer;

	public readonly float engineStartupTime;

	public readonly Transform waterloggedPoint;

	public readonly BaseEntity.Flags engineStartingFlag;

	public EngineState CurEngineState
	{
		get
		{
			if (owner.HasFlag(engineStartingFlag))
			{
				return EngineState.Starting;
			}
			if (owner.HasFlag(BaseEntity.Flags.On))
			{
				return EngineState.On;
			}
			return EngineState.Off;
		}
	}

	public bool IsOn => CurEngineState == EngineState.On;

	public bool IsOff => CurEngineState == EngineState.Off;

	public bool IsStarting => CurEngineState == EngineState.Starting;

	public bool IsStartingOrOn => CurEngineState != EngineState.Off;

	public IFuelSystem FuelSystem { get; private set; }

	public VehicleEngineController(TOwner owner, IFuelSystem fuelSystem, bool isServer, float engineStartupTime, Transform waterloggedPoint = null, BaseEntity.Flags engineStartingFlag = BaseEntity.Flags.Reserved1)
	{
		FuelSystem = fuelSystem;
		this.owner = owner;
		this.isServer = isServer;
		this.engineStartupTime = engineStartupTime;
		this.waterloggedPoint = waterloggedPoint;
		this.engineStartingFlag = engineStartingFlag;
	}

	public EngineState EngineStateFrom(BaseEntity.Flags flags)
	{
		if (flags.HasFlag(engineStartingFlag))
		{
			return EngineState.Starting;
		}
		if (flags.HasFlag(BaseEntity.Flags.On))
		{
			return EngineState.On;
		}
		return EngineState.Off;
	}

	public bool IsWaterlogged()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)waterloggedPoint != (Object)null)
		{
			return WaterLevel.Test(waterloggedPoint.position, waves: true, volumes: true, owner);
		}
		return false;
	}

	public void TryStartEngine(BasePlayer player)
	{
		if (isServer && !owner.IsDead() && !IsStartingOrOn && player.net != null)
		{
			if (!CanRunEngine())
			{
				owner.OnEngineStartFailed();
			}
			else if (Interface.CallHook("OnEngineStart", (object)((VehicleEngineController<>)(object)this).owner, (object)player) == null)
			{
				owner.SetFlag(engineStartingFlag, b: true);
				owner.SetFlag(BaseEntity.Flags.On, b: false);
				((FacepunchBehaviour)owner).Invoke((Action)FinishStartingEngine, engineStartupTime);
				Interface.CallHook("OnEngineStarted", (object)((VehicleEngineController<>)(object)this).owner, (object)player);
			}
		}
	}

	public void FinishStartingEngine()
	{
		if (isServer && !owner.IsDead() && !IsOn)
		{
			owner.SetFlag(BaseEntity.Flags.On, b: true);
			owner.SetFlag(engineStartingFlag, b: false);
			Interface.CallHook("OnEngineStartFinished", (object)((VehicleEngineController<>)(object)this).owner);
		}
	}

	public void StopEngine()
	{
		if (isServer && !IsOff && Interface.CallHook("OnEngineStop", (object)((VehicleEngineController<>)(object)this).owner) == null)
		{
			CancelEngineStart();
			owner.SetFlag(BaseEntity.Flags.On, b: false);
			owner.SetFlag(engineStartingFlag, b: false);
			Interface.CallHook("OnEngineStopped", (object)((VehicleEngineController<>)(object)this).owner);
		}
	}

	public void CheckEngineState()
	{
		if (IsStartingOrOn && !CanRunEngine())
		{
			StopEngine();
		}
	}

	public bool CanRunEngine()
	{
		if (owner.MeetsEngineRequirements() && FuelSystem.HasFuel() && !IsWaterlogged())
		{
			return !owner.IsDead();
		}
		return false;
	}

	public int TickFuel(float fuelPerSecond)
	{
		if (IsOn)
		{
			return FuelSystem.TryUseFuel(Time.fixedDeltaTime, fuelPerSecond);
		}
		return 0;
	}

	public void UseFuel(int amount)
	{
		FuelSystem.RemoveFuel(amount);
	}

	public void CancelEngineStart()
	{
		if (CurEngineState == EngineState.Starting)
		{
			((FacepunchBehaviour)owner).CancelInvoke((Action)FinishStartingEngine);
		}
	}
}


public enum EngineState
{
	Off,
	Starting,
	On
}


using UnityEngine;

public class VehicleTerrainHandler
{
	public enum Surface
	{
		Default,
		Road,
		Snow,
		Ice,
		Sand,
		Frictionless
	}

	public string CurGroundPhysicsMatName;

	public Surface OnSurface;

	public bool IsGrounded;

	public float RayLength = 1.5f;

	private readonly string[] TerrainRoad = new string[5] { "rock", "concrete", "gravel", "metal", "path" };

	private const float SECONDS_BETWEEN_TERRAIN_SAMPLE = 0.25f;

	private TimeSince timeSinceTerrainCheck;

	private readonly BaseVehicle vehicle;

	public bool IsOnSnowOrIce
	{
		get
		{
			if (OnSurface != Surface.Snow)
			{
				return OnSurface == Surface.Ice;
			}
			return true;
		}
	}

	public VehicleTerrainHandler(BaseVehicle vehicle)
	{
		this.vehicle = vehicle;
	}

	public void FixedUpdate()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!vehicle.IsStationary() && TimeSince.op_Implicit(timeSinceTerrainCheck) > 0.25f)
		{
			DoTerrainCheck();
		}
	}

	private void DoTerrainCheck()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		timeSinceTerrainCheck = TimeSince.op_Implicit(Random.Range(-0.025f, 0.025f));
		Transform transform = ((Component)vehicle).transform;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(transform.position + transform.up * 0.5f, -transform.up, ref val, RayLength, 161546241, (QueryTriggerInteraction)1))
		{
			CurGroundPhysicsMatName = ((RaycastHit)(ref val)).collider.GetMaterialAt(((RaycastHit)(ref val)).point).GetNameLower();
			if (GetOnRoad(CurGroundPhysicsMatName))
			{
				OnSurface = Surface.Road;
			}
			else if (CurGroundPhysicsMatName == "snow")
			{
				if (((Component)((RaycastHit)(ref val)).collider).CompareTag("TreatSnowAsIce"))
				{
					OnSurface = Surface.Ice;
				}
				else
				{
					OnSurface = Surface.Snow;
				}
			}
			else if (CurGroundPhysicsMatName == "sand")
			{
				OnSurface = Surface.Sand;
			}
			else if (CurGroundPhysicsMatName.Contains("zero friction"))
			{
				OnSurface = Surface.Frictionless;
			}
			else
			{
				OnSurface = Surface.Default;
			}
			IsGrounded = true;
		}
		else
		{
			CurGroundPhysicsMatName = "concrete";
			OnSurface = Surface.Default;
			IsGrounded = false;
		}
	}

	private bool GetOnRoad(string physicMat)
	{
		for (int i = 0; i < TerrainRoad.Length; i++)
		{
			if (TerrainRoad[i] == physicMat)
			{
				return true;
			}
		}
		return false;
	}
}


public enum Surface
{
	Default,
	Road,
	Snow,
	Ice,
	Sand,
	Frictionless
}


public interface IPoolVehicle
{
	void OnPoolDestroyed();

	void WakeUp();
}


public class GhostShipMapMarker : MapMarker
{
}


using System.Collections.Generic;
using Prefabs.Misc;
using UnityEngine;

public class GhostShipSounds : MonoBehaviour
{
	[SerializeField]
	private GhostShip ghostShip;

	private float soundCullDistanceSq;

	[SerializeField]
	[Header("Ambient")]
	private SoundDefinition hullGroanDef;

	[SerializeField]
	private float hullGroanCooldown = 1f;

	[SerializeField]
	private List<AmbienceDefinitionList> AmbienceStormHullStings;

	[SerializeField]
	private float stormHullStingsCooldown = 2f;

	private float lastHullGroan;

	private float lastStormHullStingGroan;
}


public class DeployGuide : BaseMonoBehaviour
{
	public static DeployGuide current;
}


using UnityEngine;

public class DeployGuideRenderer : MonoBehaviour
{
	public BaseEntity Prefab;
}


using System;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class DroppedItem : WorldItem, IContainerSounds, Hopper.IHopperTarget
{
	public enum DropReasonEnum
	{
		Unknown,
		Player,
		Death,
		Loot
	}

	public class DroppedItemUnderwaterQueue : PersistentObjectWorkQueue<DroppedItem>
	{
		protected override void RunJob(DroppedItem entity)
		{
			if ((Object)(object)entity != (Object)null)
			{
				entity.CheckUnderwaterStatus(canSplash: true);
			}
		}
	}

	[Header("DroppedItem")]
	public GameObjectRef itemModel;

	public GameObjectRef splashEffect;

	[ServerVar(Help = "How many milliseconds to spend on updating underwater drag levels")]
	public static float underwater_drag_budget_ms = 0.05f;

	private const Flags FLAG_STUCK = Flags.Reserved1;

	private const Flags FLAG_UNDERWATER = Flags.Reserved2;

	public const Flags FLAG_HOPPERANIMATING = Flags.Reserved3;

	private int originalLayer = -1;

	[NonSerialized]
	public DropReasonEnum DropReason;

	[NonSerialized]
	public ulong DroppedBy;

	[NonSerialized]
	public DateTime DroppedTime;

	[NonSerialized]
	public bool NeverCombine;

	private Rigidbody rB;

	private CollisionDetectionMode originalCollisionMode;

	private Vector3 prevLocalPos;

	private const float SLEEP_CHECK_FREQUENCY = 11f;

	private const float AIR_DRAG = 0.1f;

	private const float UNDERWATER_DRAG = 7f;

	private bool hasLastPos;

	private Vector3 lastGoodColliderCentre;

	private Vector3 lastGoodPos;

	private Quaternion lastGoodRot;

	private Action cachedSleepCheck;

	private float maxBoundsExtent;

	private readonly Vector3 smallVerticalOffset = new Vector3(0f, 0.05f, 0f);

	public static DroppedItemUnderwaterQueue underwaterStatusQueue = new DroppedItemUnderwaterQueue();

	private TimeSince lastUnderwaterFlowImpulse;

	public Collider childCollider { get; private set; }

	private bool StuckInSomething => HasFlag(Flags.Reserved1);

	public SoundDefinition OpenSound
	{
		get
		{
			if (item == null)
			{
				return null;
			}
			ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			return component.openSound;
		}
	}

	public SoundDefinition CloseSound
	{
		get
		{
			if (item == null)
			{
				return null;
			}
			ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
			if ((Object)(object)component == (Object)null)
			{
				return null;
			}
			return component.closeSound;
		}
	}

	public Rigidbody Rigidbody => rB;

	public int NumberOfItemsToTransfer => 1 + ((item.contents != null) ? item.contents.itemList.Count() : 0);

	public float EndPositionToleranceMultiplier => 1f;

	public bool IsSleeping
	{
		get
		{
			if ((Object)(object)rB != (Object)null)
			{
				return rB.IsSleeping();
			}
			return false;
		}
	}

	public BaseEntity ToEntity => this;

	protected override bool CanBePickedUp => !HasFlag(Flags.Reserved3);

	public void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 itemFallbackPosition)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || itemContainer == null)
		{
			return;
		}
		if (item.contents != null && item.IsBackpack())
		{
			int capacity = item.contents.capacity;
			for (int i = 0; i < capacity; i++)
			{
				if (item.contents != null)
				{
					Item slot = item.contents.GetSlot(i);
					if (slot != null && !slot.MoveToContainer(itemContainer))
					{
						slot.DropAndTossUpwards(itemFallbackPosition);
					}
				}
			}
		}
		if (item != null)
		{
			if (item.MoveToContainer(itemContainer))
			{
				RemoveItem();
			}
			else
			{
				CancelHopper();
			}
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GetDespawnDuration() < float.PositiveInfinity)
		{
			((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
		}
		ReceiveCollisionMessages(b: true);
		prevLocalPos = ((Component)this).transform.localPosition;
		((PersistentObjectWorkQueue<DroppedItem>)underwaterStatusQueue).Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<DroppedItem>)underwaterStatusQueue).Remove(this);
	}

	public virtual float GetDespawnDuration()
	{
		return item?.GetDespawnDuration() ?? Server.itemdespawn;
	}

	public void IdleDestroy()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("OnItemDespawn", (object)item);
		Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		if (item != null)
		{
			BuriedItems.Instance.Register(item, ((Component)this).transform.position);
		}
		DestroyItem();
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (item != null && item.MaxStackable() > 1)
		{
			DroppedItem droppedItem = hitEntity as DroppedItem;
			if (!((Object)(object)droppedItem == (Object)null) && droppedItem.item != null && !((Object)(object)droppedItem.item.info != (Object)(object)item.info) && droppedItem.item.skin == item.skin)
			{
				droppedItem.OnDroppedOn(this);
			}
		}
	}

	public void OnDroppedOn(DroppedItem di)
	{
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", (object)this, (object)di) != null || (Object)(object)di.item.info != (Object)(object)item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if ((Object)(object)di.item.info != (Object)null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if (((Object)(object)((Component)di.item.info).GetComponent<ItemModSign>() != (Object)null && (Object)(object)ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != (Object)null) || ((Object)(object)item.info != (Object)null && (Object)(object)((Component)item.info).GetComponent<ItemModSign>() != (Object)null && (Object)(object)ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != (Object)null))
			{
				return;
			}
		}
		if (Item.BlockStackFoodItem(item, di.item))
		{
			return;
		}
		Interface.CallHook("OnDroppedItemCombined", (object)this);
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.item.MigrateItemOwnership(item, di.item.amount);
			di.DestroyItem();
			di.Kill();
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(((Component)this).transform.position, Vector3.zero, ((Component)this).transform.rotation);
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null && (Object)(object)newParent != (Object)(object)oldParent)
		{
			OnParented();
		}
		else if ((Object)(object)newParent == (Object)null && (Object)(object)oldParent != (Object)null)
		{
			OnUnparented();
		}
	}

	internal override void OnParentRemoved()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rB == (Object)null)
		{
			base.OnParentRemoved();
			return;
		}
		Vector3 val = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		SetParent(null);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 2f, Vector3.down, ref val2, 2f, 161546240) && val.y < ((RaycastHit)(ref val2)).point.y)
		{
			val += Vector3.up * 1.5f;
		}
		((Component)this).transform.position = val;
		((Component)this).transform.rotation = rotation;
		Unstick();
		if (GetDespawnDuration() < float.PositiveInfinity)
		{
			((FacepunchBehaviour)this).Invoke((Action)IdleDestroy, GetDespawnDuration());
		}
	}

	public void StickIn()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void Unstick()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	private void SleepCheck()
	{
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!HasParent() || StuckInSomething)
		{
			return;
		}
		if (rB.isKinematic)
		{
			if (maxBoundsExtent == 0f)
			{
				float num;
				if (!((Object)(object)childCollider != (Object)null))
				{
					num = Vector3Ex.Max(((Bounds)(ref bounds)).extents);
				}
				else
				{
					Bounds val = childCollider.bounds;
					num = Vector3Ex.Max(((Bounds)(ref val)).extents);
				}
				maxBoundsExtent = num;
			}
			if (!GamePhysics.Trace(new Ray(CenterPoint(), Vector3.down), 0f, out var _, maxBoundsExtent + 0.1f, -928830719, (QueryTriggerInteraction)1, this))
			{
				BecomeActive();
			}
		}
		else if (Vector3.SqrMagnitude(((Component)this).transform.localPosition - prevLocalPos) < 0.075f)
		{
			BecomeInactive();
		}
		prevLocalPos = ((Component)this).transform.localPosition;
	}

	private void OnPhysicsNeighbourChanged()
	{
		if (!StuckInSomething)
		{
			BecomeActive();
		}
	}

	public override void OnPositionalNetworkUpdate()
	{
		base.OnPositionalNetworkUpdate();
		if (!HasFlag(Flags.Reserved3))
		{
			CheckValidPosition();
		}
	}

	protected override bool ShouldUpdateNetworkPosition()
	{
		if (syncPosition)
		{
			return !rB.isKinematic;
		}
		return false;
	}

	private void CheckValidPosition()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rB != (Object)null) || !((Object)(object)childCollider != (Object)null))
		{
			return;
		}
		Bounds val = childCollider.bounds;
		Vector3 val2 = ((Bounds)(ref val)).center + smallVerticalOffset;
		Vector3 val3 = val2 - lastGoodColliderCentre;
		Ray ray = default(Ray);
		((Ray)(ref ray))..ctor(lastGoodColliderCentre, ((Vector3)(ref val3)).normalized);
		if (hasLastPos && GamePhysics.Trace(ray, 0f, out var _, ((Vector3)(ref val3)).magnitude, 1218511105, (QueryTriggerInteraction)1, this))
		{
			((Component)this).transform.position = lastGoodPos + smallVerticalOffset;
			((Component)this).transform.rotation = lastGoodRot;
			if (!rB.isKinematic)
			{
				rB.velocity = Vector3.zero;
				rB.angularVelocity = Vector3.zero;
			}
			Physics.SyncTransforms();
		}
		else
		{
			lastGoodColliderCentre = val2;
			lastGoodPos = ((Component)this).transform.position;
			lastGoodRot = ((Component)this).transform.rotation;
			hasLastPos = true;
		}
	}

	public void PrepareForHopper()
	{
		SetFlag(Flags.Reserved3, b: true);
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = false;
		}
	}

	public void HopperCancelled()
	{
		SetFlag(Flags.Reserved3, b: false);
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = true;
		}
	}

	public void CancelHopper()
	{
		SetFlag(Flags.Reserved3, b: false);
		if ((Object)(object)Rigidbody != (Object)null)
		{
			Rigidbody.useGravity = true;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			childCollider.enabled = true;
		}
	}

	private void OnUnparented()
	{
		if (cachedSleepCheck != null)
		{
			((FacepunchBehaviour)this).CancelInvoke(cachedSleepCheck);
		}
	}

	private void OnParented()
	{
		if ((Object)(object)childCollider == (Object)null)
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)EnableCollider, 0.1f);
		}
		if (base.isServer && !StuckInSomething)
		{
			if (cachedSleepCheck == null)
			{
				cachedSleepCheck = SleepCheck;
			}
			((FacepunchBehaviour)this).InvokeRandomized(cachedSleepCheck, 5.5f, 11f, Random.Range(-1.1f, 1.1f));
		}
	}

	public override void PostInitShared()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		base.PostInitShared();
		GameObject val = null;
		if (item != null && item.GetWorldModel().isValid)
		{
			val = base.gameManager.CreatePrefab(item.GetWorldModel().resourcePath, ((Component)this).transform);
			val.transform.localScale = item.GetWorldModel().Get().transform.localScale;
		}
		else
		{
			val = base.gameManager.CreatePrefab(itemModel.resourcePath, ((Component)this).transform);
		}
		val.transform.localPosition = Vector3.zero;
		val.transform.localRotation = Quaternion.identity;
		val.SetLayerRecursive(((Component)this).gameObject.layer);
		childCollider = val.GetComponentInChildren<Collider>();
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = false;
			if (HasParent())
			{
				OnParented();
			}
			else
			{
				childCollider.enabled = true;
			}
			originalLayer = ((Component)childCollider).gameObject.layer;
		}
		if (base.isServer)
		{
			float angularDrag = 0.1f;
			rB = ((Component)this).gameObject.AddComponent<Rigidbody>();
			UpdateItemMass();
			rB.drag = 0.1f;
			rB.angularDrag = angularDrag;
			rB.interpolation = (RigidbodyInterpolation)0;
			rB.collisionDetectionMode = (CollisionDetectionMode)3;
			originalCollisionMode = rB.collisionDetectionMode;
			rB.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
			CheckValidPosition();
			CheckUnderwaterStatus(canSplash: false);
			UpdateUnderwaterDrag();
		}
		if (item != null)
		{
			PhysicsEffects component = ((Component)this).gameObject.GetComponent<PhysicsEffects>();
			if ((Object)(object)component != (Object)null)
			{
				component.entity = this;
				if ((Object)(object)item.info.physImpactSoundDef != (Object)null)
				{
					component.physImpactSoundDef = item.info.physImpactSoundDef;
				}
			}
			Buoyancy component2 = val.GetComponent<Buoyancy>();
			if ((Object)(object)component2 != (Object)null && base.isServer)
			{
				component2.rigidBody = rB;
			}
		}
		val.SetActive(true);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!old.HasFlag(Flags.Reserved1) && next.HasFlag(Flags.Reserved1))
		{
			BecomeInactive();
		}
		else if (old.HasFlag(Flags.Reserved1) && !next.HasFlag(Flags.Reserved1))
		{
			BecomeActive();
		}
		if (base.isServer && old.HasFlag(Flags.Reserved2) != next.HasFlag(Flags.Reserved2))
		{
			UpdateUnderwaterDrag();
		}
	}

	private void BecomeActive()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			rB.isKinematic = false;
			rB.collisionDetectionMode = originalCollisionMode;
			rB.WakeUp();
			if (HasParent())
			{
				Rigidbody component = ((Component)GetParentEntity()).GetComponent<Rigidbody>();
				if ((Object)(object)component != (Object)null)
				{
					rB.velocity = component.velocity;
					rB.angularVelocity = component.angularVelocity;
				}
			}
			prevLocalPos = ((Component)this).transform.localPosition;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			((Component)childCollider).gameObject.layer = originalLayer;
		}
	}

	private void BecomeInactive()
	{
		if (base.isServer)
		{
			rB.collisionDetectionMode = (CollisionDetectionMode)0;
			rB.isKinematic = true;
		}
		if ((Object)(object)childCollider != (Object)null)
		{
			((Component)childCollider).gameObject.layer = 19;
		}
	}

	private void EnableCollider()
	{
		if (Object.op_Implicit((Object)(object)childCollider))
		{
			childCollider.enabled = true;
		}
	}

	public void UpdateItemMass()
	{
		if ((Object)(object)rB == (Object)null)
		{
			rB = ((Component)this).GetComponent<Rigidbody>();
		}
		if ((Object)(object)rB == (Object)null || item == null || item.contents?.itemList == null)
		{
			return;
		}
		float num = item.info.GetWorldModelMass();
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if ((Object)(object)component != (Object)null)
		{
			_ = component.worldWeightScale;
		}
		foreach (Item item in item.contents.itemList)
		{
			num += item.info.GetWorldModelMass() * component.worldWeightScale;
		}
		if ((Object)(object)component != (Object)null && component.maxWeight > 0f)
		{
			num = Mathf.Min(component.maxWeight, num);
		}
		rB.mass = num;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SetFlag(Flags.Reserved3, b: false);
	}

	public override bool ShouldInheritNetworkGroup()
	{
		return false;
	}

	private void CheckUnderwaterStatus(bool canSplash)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)Rigidbody != (Object)null) || !Rigidbody.IsSleeping())
		{
			bool flag = WaterLevel.Test(((Component)this).transform.position, waves: false, volumes: true, this);
			if (canSplash && flag && !HasFlag(Flags.Reserved2) && splashEffect.isValid)
			{
				Effect.server.Run(splashEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
			}
			SetFlag(Flags.Reserved2, flag);
			if (flag && (Object)(object)rB != (Object)null && !rB.IsSleeping() && TimeSince.op_Implicit(lastUnderwaterFlowImpulse) > 1f)
			{
				lastUnderwaterFlowImpulse = TimeSince.op_Implicit(0f - Random.Range(0f, 1f));
				rB.AddForceAtPosition(Random.onUnitSphere, ((Component)this).transform.position + Random.onUnitSphere * 3f, (ForceMode)1);
			}
		}
	}

	private void UpdateUnderwaterDrag()
	{
		if ((Object)(object)rB != (Object)null)
		{
			rB.drag = (HasFlag(Flags.Reserved2) ? 7f : 0.1f);
		}
	}
}


public enum DropReasonEnum
{
	Unknown,
	Player,
	Death,
	Loot
}


using UnityEngine;

public class DroppedItemUnderwaterQueue : PersistentObjectWorkQueue<DroppedItem>
{
	protected override void RunJob(DroppedItem entity)
	{
		if ((Object)(object)entity != (Object)null)
		{
			entity.CheckUnderwaterStatus(canSplash: true);
		}
	}
}


using Rust;

public class ItemPickup : DroppedItem
{
	public ItemDefinition itemDef;

	public int amount = 1;

	public ulong skinOverride;

	public override float GetDespawnDuration()
	{
		return float.PositiveInfinity;
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Item item = ItemManager.Create(itemDef, amount, skinOverride);
			InitializeItem(item);
			item.SetWorldEntity(this);
		}
	}

	internal override void DoServerDestroy()
	{
		if (item != null)
		{
			item.Remove();
			item = null;
		}
		base.DoServerDestroy();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		IdleDestroy();
	}

	public override void TryApplyOwnershipOnPickup(BasePlayer player, Item item)
	{
		item.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
	}
}


using UnityEngine;

public class ANDSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (input1Amount == 0 || input2Amount == 0)
		{
			return false;
		}
		if (input1Amount == input2Amount)
		{
			return inputIndex == 0;
		}
		int num = ((input1Amount <= input2Amount) ? 1 : 0);
		return inputIndex == num;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (input1Amount <= 0 || input2Amount <= 0)
		{
			return 0;
		}
		return Mathf.Max(input1Amount, input2Amount);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		}
		int num = ((input1Amount > 0 && input2Amount > 0) ? (input1Amount + input2Amount) : 0);
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 && input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(inputAmount, slot);
	}
}


public interface ISubscribable
{
	bool AddSubscription(ulong steamId);

	bool RemoveSubscription(ulong steamId);

	bool HasSubscription(ulong steamId);
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class StorageMonitor : AppIOEntity
{
	public readonly Action<Item, bool> _onItemAddedRemoved;

	private readonly Action<Item, int> _onItemAddedToStack;

	private readonly Action<Item, int> _onItemRemovedFromStack;

	private readonly Action _resetSwitchHandler;

	private double _lastPowerOnUpdate;

	public override AppEntityType Type => (AppEntityType)3;

	public override bool Value
	{
		get
		{
			return IsOn();
		}
		set
		{
		}
	}

	public StorageMonitor()
	{
		_onItemAddedRemoved = OnItemAddedRemoved;
		_onItemAddedToStack = OnItemAddedToStack;
		_onItemRemovedFromStack = OnItemRemovedFromStack;
		_resetSwitchHandler = ResetSwitch;
	}

	internal override void FillEntityPayload(AppEntityPayload payload)
	{
		base.FillEntityPayload(payload);
		StorageContainer storageContainer = GetStorageContainer();
		ContainerIOEntity containerIOEntity = GetContainerIOEntity();
		if (((Object)(object)storageContainer == (Object)null && (Object)(object)containerIOEntity == (Object)null) || !HasFlag(Flags.Reserved8))
		{
			return;
		}
		payload.items = Pool.Get<List<Item>>();
		ItemContainer inventory = GetInventory();
		if (inventory == null)
		{
			return;
		}
		foreach (Item item in inventory.itemList)
		{
			Item val = Pool.Get<Item>();
			val.itemId = (item.IsBlueprint() ? item.blueprintTargetDef.itemid : item.info.itemid);
			val.quantity = item.amount;
			val.itemIsBlueprint = item.IsBlueprint();
			payload.items.Add(val);
		}
		payload.capacity = inventory.capacity;
		if ((Object)(object)storageContainer != (Object)null && storageContainer is BuildingPrivlidge buildingPrivlidge)
		{
			payload.hasProtection = true;
			float protectedMinutes = buildingPrivlidge.GetProtectedMinutes();
			if (protectedMinutes > 0f)
			{
				payload.protectionExpiry = (uint)DateTimeOffset.UtcNow.AddMinutes(protectedMinutes).ToUnixTimeSeconds();
			}
		}
	}

	public override void Init()
	{
		base.Init();
		ItemContainer inventory = GetInventory();
		if (inventory != null)
		{
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Combine(inventory.onItemAddedRemoved, _onItemAddedRemoved);
			inventory.onItemAddedToStack = (Action<Item, int>)Delegate.Combine(inventory.onItemAddedToStack, _onItemAddedToStack);
			inventory.onItemRemovedFromStack = (Action<Item, int>)Delegate.Combine(inventory.onItemRemovedFromStack, _onItemRemovedFromStack);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		ItemContainer inventory = GetInventory();
		if (inventory != null)
		{
			inventory.onItemAddedRemoved = (Action<Item, bool>)Delegate.Remove(inventory.onItemAddedRemoved, _onItemAddedRemoved);
			inventory.onItemAddedToStack = (Action<Item, int>)Delegate.Remove(inventory.onItemAddedToStack, _onItemAddedToStack);
			inventory.onItemRemovedFromStack = (Action<Item, int>)Delegate.Remove(inventory.onItemRemovedFromStack, _onItemRemovedFromStack);
		}
	}

	private StorageContainer GetStorageContainer()
	{
		return GetParentEntity() as StorageContainer;
	}

	private ContainerIOEntity GetContainerIOEntity()
	{
		return GetParentEntity() as ContainerIOEntity;
	}

	private ItemContainer GetInventory()
	{
		StorageContainer storageContainer = GetStorageContainer();
		ContainerIOEntity containerIOEntity = GetContainerIOEntity();
		if ((Object)(object)storageContainer == (Object)null && (Object)(object)containerIOEntity != (Object)null && containerIOEntity.inventory != null)
		{
			return containerIOEntity.inventory;
		}
		if ((Object)(object)storageContainer != (Object)null && storageContainer.inventory != null && (Object)(object)containerIOEntity == (Object)null)
		{
			return storageContainer.inventory;
		}
		return null;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		switch (outputSlot)
		{
		case 0:
			if (!IsOn())
			{
				return 0;
			}
			return Mathf.Min(1, GetCurrentEnergy());
		case 1:
		{
			int num = GetCurrentEnergy();
			if (!IsOn())
			{
				return num;
			}
			return num - 1;
		}
		default:
			return 0;
		}
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		bool flag = HasFlag(Flags.Reserved8);
		base.UpdateHasPower(inputAmount, inputSlot);
		if (inputSlot == 0)
		{
			bool num = inputAmount >= ConsumptionAmount();
			double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
			if (num && !flag && _lastPowerOnUpdate < realtimeSinceStartup - 1.0)
			{
				_lastPowerOnUpdate = realtimeSinceStartup;
				BroadcastValueChange();
			}
		}
	}

	private void OnItemAddedRemoved(Item item, bool added)
	{
		OnContainerChanged();
	}

	private void OnItemAddedToStack(Item item, int amount)
	{
		OnContainerChanged();
	}

	private void OnItemRemovedFromStack(Item item, int amount)
	{
		OnContainerChanged();
	}

	public void OnContainerChanged()
	{
		if (HasFlag(Flags.Reserved8))
		{
			((FacepunchBehaviour)this).Invoke(_resetSwitchHandler, 0.5f);
			if (!IsOn())
			{
				SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
				MarkDirty();
				BroadcastValueChange();
			}
		}
	}

	private void ResetSwitch()
	{
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		MarkDirty();
		BroadcastValueChange();
	}
}


using System;
using UnityEngine;

public static class DigitalClockEx
{
	public static TimeSpan ToTimeSpan(this float value)
	{
		int num = Mathf.RoundToInt(value * 60f);
		int hours = num / 60;
		int minutes = num % 60;
		return new TimeSpan(hours, minutes, 0);
	}

	public static float ToFloat(this TimeSpan timeSpan)
	{
		int hours = timeSpan.Hours;
		float num = (float)timeSpan.Minutes / 60f;
		return (float)hours + num;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DoorManipulator : IOEntity
{
	public enum DoorEffect
	{
		Close,
		Open,
		Toggle
	}

	public EntityRef entityRef;

	public Door targetDoor;

	public DoorEffect powerAction;

	private bool toggle = true;

	public virtual bool CanPairWithLockedDoors()
	{
		return true;
	}

	public override void Init()
	{
		base.Init();
		SetupInitialDoorConnection();
	}

	public virtual void SetupInitialDoorConnection()
	{
		if ((Object)(object)targetDoor == (Object)null && !entityRef.IsValid(serverside: true))
		{
			SetTargetDoor(FindDoor(CanPairWithLockedDoors()));
		}
		if ((Object)(object)targetDoor != (Object)null && !entityRef.IsValid(serverside: true))
		{
			entityRef.Set(targetDoor);
		}
		if (entityRef.IsValid(serverside: true) && (Object)(object)targetDoor == (Object)null)
		{
			SetTargetDoor(((Component)entityRef.Get(serverside: true)).GetComponent<Door>());
		}
	}

	public virtual void SetTargetDoor(Door newTargetDoor)
	{
		Door door = targetDoor;
		targetDoor = newTargetDoor;
		SetFlag(Flags.On, (Object)(object)targetDoor != (Object)null);
		entityRef.Set(newTargetDoor);
		if ((Object)(object)door != (Object)(object)targetDoor && (Object)(object)targetDoor != (Object)null)
		{
			DoAction(powerAction);
		}
	}

	public virtual Door FindDoor(bool allowLocked = true)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		List<Door> list = Pool.Get<List<Door>>();
		Vis.Entities(((Component)this).transform.position, 1f, list, 2097152, (QueryTriggerInteraction)1);
		Door result = null;
		float num = float.PositiveInfinity;
		foreach (Door item in list)
		{
			if (!item.isServer)
			{
				continue;
			}
			if (!allowLocked)
			{
				BaseLock baseLock = item.GetSlot(Slot.Lock) as BaseLock;
				if ((Object)(object)baseLock != (Object)null && baseLock.IsLocked())
				{
					continue;
				}
			}
			if (!item.IsOnMovingObject())
			{
				float num2 = Vector3.Distance(((Component)item).transform.position, ((Component)this).transform.position);
				if (num2 < num)
				{
					result = item;
					num = num2;
				}
			}
		}
		Pool.FreeUnmanaged<Door>(ref list);
		return result;
	}

	public virtual void DoActionDoorMissing()
	{
		SetTargetDoor(FindDoor(CanPairWithLockedDoors()));
	}

	public virtual void DoAction(DoorEffect action)
	{
		bool flag = IsPowered();
		if ((Object)(object)targetDoor == (Object)null)
		{
			DoActionDoorMissing();
		}
		if (!((Object)(object)targetDoor != (Object)null))
		{
			return;
		}
		if (targetDoor.IsBusy())
		{
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				DoAction(action);
			}, 1f);
		}
		else if (action == DoorEffect.Open)
		{
			if (flag)
			{
				if (!targetDoor.IsOpen())
				{
					targetDoor.SetOpen(open: true);
				}
			}
			else if (targetDoor.IsOpen())
			{
				targetDoor.SetOpen(open: false);
			}
		}
		else if (action == DoorEffect.Close)
		{
			if (flag)
			{
				if (targetDoor.IsOpen())
				{
					targetDoor.SetOpen(open: false);
				}
			}
			else if (!targetDoor.IsOpen())
			{
				targetDoor.SetOpen(open: true);
			}
		}
		else if (action == DoorEffect.Toggle)
		{
			if (flag && toggle)
			{
				targetDoor.SetOpen(!targetDoor.IsOpen());
				toggle = false;
			}
			else if (!toggle)
			{
				toggle = true;
			}
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		DoAction(powerAction);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity.genericEntRef1 = entityRef.uid;
		info.msg.ioEntity.genericInt1 = (int)powerAction;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			entityRef.uid = info.msg.ioEntity.genericEntRef1;
			powerAction = (DoorEffect)info.msg.ioEntity.genericInt1;
		}
	}
}


public enum DoorEffect
{
	Close,
	Open,
	Toggle
}


using System;

public class DummySwitch : IOEntity
{
	public string listenString = "";

	public string listenStringOff = "";

	public float duration = -1f;

	public override bool WantsPower(int inputIndex)
	{
		return IsOn();
	}

	public override void ResetIOState()
	{
		SetFlag(Flags.On, b: false);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (!IsOn())
		{
			return 0;
		}
		return GetCurrentEnergy();
	}

	public void SetOn(bool wantsOn)
	{
		SetFlag(Flags.On, wantsOn);
		MarkDirty();
		if (IsOn() && duration != -1f)
		{
			((FacepunchBehaviour)this).Invoke((Action)SetOff, duration);
		}
	}

	public void SetOff()
	{
		SetOn(wantsOn: false);
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			if (IsOn())
			{
				SetOn(wantsOn: false);
			}
			SetOn(wantsOn: true);
		}
		else if (msg == listenStringOff && listenStringOff != "" && IsOn())
		{
			SetOn(wantsOn: false);
		}
	}
}


using UnityEngine;

public class ElectricFurnaceIO : IOEntity, IIndustrialStorage
{
	public int PowerConsumption = 3;

	public ItemContainer Container => GetParentOven().inventory;

	public BaseEntity IndustrialEntity => this;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		if ((Object)(object)GetParentEntity() == (Object)null)
		{
			return 0;
		}
		if (!GetParentEntity().IsOn())
		{
			return 0;
		}
		return PowerConsumption;
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		base.UpdateHasPower(inputAmount, inputSlot);
		ElectricOven parentOven = GetParentOven();
		if (!((Object)(object)parentOven == (Object)null))
		{
			if (inputAmount > 0)
			{
				parentOven.StartCooking();
			}
			else
			{
				parentOven.StopCooking();
			}
		}
	}

	private ElectricOven GetParentOven()
	{
		return GetParentEntity() as ElectricOven;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(1, 2);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i(3, 5);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricGenerator : IOEntity
{
	public float electricAmount = 8f;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override int MaximalPowerOutput()
	{
		return Mathf.FloorToInt(electricAmount);
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetCurrentEnergy()
	{
		return (int)electricAmount;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return GetCurrentEnergy();
	}

	public override void UpdateOutputs()
	{
		currentEnergy = GetCurrentEnergy();
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().UpdateFromInput(currentEnergy, iOSlot.connectedToSlot);
			}
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		((FacepunchBehaviour)this).Invoke((Action)ForcePuzzleReset, 4f);
	}

	private void ForcePuzzleReset()
	{
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if ((Object)(object)component != (Object)null)
		{
			component.DoReset();
			component.ResetTimer();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if (Object.op_Implicit((Object)(object)component))
		{
			info.msg.puzzleReset = Pool.Get<PuzzleReset>();
			info.msg.puzzleReset.playerBlocksReset = component.playersBlockReset;
			if ((Object)(object)component.playerDetectionOrigin != (Object)null)
			{
				info.msg.puzzleReset.playerDetectionOrigin = component.playerDetectionOrigin.position;
			}
			info.msg.puzzleReset.playerDetectionRadius = component.playerDetectionRadius;
			info.msg.puzzleReset.scaleWithServerPopulation = component.scaleWithServerPopulation;
			info.msg.puzzleReset.timeBetweenResets = component.timeBetweenResets;
			info.msg.puzzleReset.checkSleepingAIZForPlayers = component.CheckSleepingAIZForPlayers;
			info.msg.puzzleReset.ignoreAboveGroundPlayers = component.ignoreAboveGroundPlayers;
			info.msg.puzzleReset.broadcastResetMessage = component.broadcastResetMessage;
			info.msg.puzzleReset.resetPhrase = component.resetPhrase?.token ?? "";
			info.msg.puzzleReset.radiationReset = component.radiationReset;
			info.msg.puzzleReset.pauseUntilLooted = component.pauseUntilLooted;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!info.fromDisk || info.msg.puzzleReset == null)
		{
			return;
		}
		PuzzleReset component = ((Component)this).GetComponent<PuzzleReset>();
		if (!((Object)(object)component != (Object)null))
		{
			return;
		}
		component.playersBlockReset = info.msg.puzzleReset.playerBlocksReset;
		if ((Object)(object)component.playerDetectionOrigin != (Object)null)
		{
			component.playerDetectionOrigin.position = info.msg.puzzleReset.playerDetectionOrigin;
		}
		component.playerDetectionRadius = info.msg.puzzleReset.playerDetectionRadius;
		component.scaleWithServerPopulation = info.msg.puzzleReset.scaleWithServerPopulation;
		component.timeBetweenResets = info.msg.puzzleReset.timeBetweenResets;
		component.CheckSleepingAIZForPlayers = info.msg.puzzleReset.checkSleepingAIZForPlayers;
		component.ignoreAboveGroundPlayers = info.msg.puzzleReset.ignoreAboveGroundPlayers;
		component.broadcastResetMessage = info.msg.puzzleReset.broadcastResetMessage;
		if (!string.IsNullOrEmpty(info.msg.puzzleReset.resetPhrase))
		{
			Phrase phrase = Translate.GetPhrase(info.msg.puzzleReset.resetPhrase);
			if (phrase != null)
			{
				component.resetPhrase = phrase;
			}
		}
		component.radiationReset = info.msg.puzzleReset.radiationReset;
		component.pauseUntilLooted = info.msg.puzzleReset.pauseUntilLooted;
		component.ResetTimer();
	}
}


using System;
using UnityEngine;

public class FluidSwitch : ElectricSwitch
{
	private Flags Flag_PumpPowered = Flags.Reserved6;

	public Animator PumpAnimator;

	private bool pumpEnabled;

	private int lastToggleInput;

	private Action delayedSendChangedAction;

	public override bool IsGravitySource => true;

	protected override bool DisregardGravityRestrictionsOnLiquid => HasFlag(Flag_PumpPowered);

	public override void ResetState()
	{
		base.ResetState();
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		if (inputSlot == 1 && lastToggleInput != inputAmount)
		{
			lastToggleInput = inputAmount;
			SetSwitch(inputAmount > 0);
		}
		if (inputSlot == 2)
		{
			bool num = pumpEnabled;
			pumpEnabled = inputAmount > 0;
			if (num != pumpEnabled)
			{
				lastPassthroughEnergy = -1;
				SetFlag(Flag_PumpPowered, pumpEnabled);
				SendChangedToRoot(forceUpdate: true);
			}
		}
	}

	public override void SetSwitch(bool wantsOn)
	{
		base.SetSwitch(wantsOn);
		if (delayedSendChangedAction == null)
		{
			delayedSendChangedAction = DelayedSendChanged;
		}
		((FacepunchBehaviour)this).Invoke(delayedSendChangedAction, IOEntity.responsetime * 2f);
	}

	private void DelayedSendChanged()
	{
		SendChangedToRoot(forceUpdate: true);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot == 0)
		{
			if (!IsOn())
			{
				return 0;
			}
			return GetCurrentEnergy();
		}
		return 0;
	}

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!forPlacement && !IsOn())
		{
			return false;
		}
		return base.AllowLiquidPassthrough(fromSource, sourceWorldPosition);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class Fridge : ContainerIOEntity, IFoodSpoilModifier
{
	public ItemCategory OnlyAcceptCategory = ItemCategory.All;

	public List<ItemDefinition> IncludedItems = new List<ItemDefinition>();

	public int PowerConsumption = 5;

	[Range(0f, 1f)]
	public float PoweredFoodSpoilageRateMultiplier = 0.1f;

	public float GetSpoilMultiplier(Item arg)
	{
		if (IsPowered())
		{
			return PoweredFoodSpoilageRateMultiplier;
		}
		return 1f;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		base.inventory.canAcceptItem = CanAcceptItem;
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		if (OnlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		if (item.info.category != OnlyAcceptCategory)
		{
			return IsItemInAcceptedList(item);
		}
		return true;
	}

	private bool IsItemInAcceptedList(Item item)
	{
		foreach (ItemDefinition includedItem in IncludedItems)
		{
			if ((Object)(object)item.info == (Object)(object)includedItem)
			{
				return true;
			}
		}
		return false;
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	private bool CanOpenLootPanel(BasePlayer player)
	{
		if (!CanBeLooted(player))
		{
			return false;
		}
		BaseLock @lock = GetLock();
		if ((Object)(object)@lock != (Object)null && !@lock.OnTryToOpen(player))
		{
			player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
			return false;
		}
		return true;
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (!CanOpenLootPanel(player))
		{
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if ((Object)(object)GetSlot(Slot.Lock) != (Object)null)
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasLock, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}
}


public class FuseBox : IOEntity
{
	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		SetFlag(Flags.On, IsPowered());
	}
}


using UnityEngine;

public class ORSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		if (IsFlickering())
		{
			return true;
		}
		if (input1Amount == 0 && input2Amount == 0)
		{
			return false;
		}
		if (input1Amount == input2Amount)
		{
			return inputIndex == 0;
		}
		int num = ((input1Amount <= input2Amount) ? 1 : 0);
		return inputIndex == num;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int num = Mathf.Max(input1Amount, input2Amount);
		return Mathf.Max(0, num);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (IsConnectedTo(this, slot, IOEntity.backtracking))
		{
			inputAmount = 0;
		}
		switch (slot)
		{
		case 0:
			input1Amount = inputAmount;
			break;
		case 1:
			input2Amount = inputAmount;
			break;
		}
		int num = input1Amount + input2Amount;
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
		base.UpdateFromInput(inputAmount, slot);
	}
}


using System;
using UnityEngine;

public class PanelLight : SimpleLight
{
	[Serializable]
	public struct ColorSetting
	{
		public Phrase name;

		public Phrase desc;

		public Color color;

		public Material mat;
	}

	public ColorSetting[] colorSettings;

	public MeshRenderer lightOnMesh;
}


using System;
using UnityEngine;

[Serializable]
public struct ColorSetting
{
	public Phrase name;

	public Phrase desc;

	public Color color;

	public Material mat;
}


public class PressButton_TrainTunnel : PressButton
{
}


using UnityEngine;

public class SimpleLight : IOEntity
{
	public bool visibilityPassesThroughParent;

	[SerializeField]
	private int powerConsumption = 1;

	public override bool VisibilityPassesThroughParent => visibilityPassesThroughParent;

	public override int ConsumptionAmount()
	{
		return powerConsumption;
	}

	public override void ResetIOState()
	{
		base.ResetIOState();
		if (IsOn())
		{
			SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		bool num = IsOn();
		bool flag = IsPowered();
		if (num != flag)
		{
			SetFlag(Flags.On, flag, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}
}


using UnityEngine;

public class Splitter : IOEntity
{
	public override bool BlockFluidDraining => true;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot < 0 || outputSlot >= outputs.Length)
		{
			return 0;
		}
		IOEntity iOEntity = outputs[outputSlot].connectedTo.Get();
		if ((Object)(object)iOEntity == (Object)null || iOEntity.IsDestroyed)
		{
			return 0;
		}
		int num = ((cachedOutputsUsed == 0) ? 1 : cachedOutputsUsed);
		int num2 = GetCurrentEnergy();
		int num3 = num2 / num;
		int num4 = 0;
		for (int i = 0; i < outputs.Length; i++)
		{
			if (!((Object)(object)outputs[i].connectedTo.Get() != (Object)null) || outputs[i].connectedTo.Get().IsDestroyed)
			{
				continue;
			}
			if (outputSlot == i)
			{
				if (num4 < num2 % num)
				{
					return num3 + 1;
				}
				return num3;
			}
			num4++;
		}
		return 0;
	}

	public override bool IsRootEntity()
	{
		return true;
	}

	public override void OnCircuitChanged(bool forceUpdate)
	{
		MarkDirtyForceUpdateOutputs();
	}
}


using System;
using UnityEngine;

public class XORSwitch : IOEntity
{
	private int input1Amount;

	private int input2Amount;

	private bool input1Set;

	private bool input2Set;

	private bool firstRun = true;

	public override int ConsumptionAmount()
	{
		return 0;
	}

	public override bool WantsPower(int inputIndex)
	{
		bool num = input1Amount > 0;
		bool flag = input2Amount > 0;
		return num != flag;
	}

	public override void ResetState()
	{
		base.ResetState();
		input1Set = false;
		input2Set = false;
		firstRun = true;
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if ((HasFlag(Flags.Reserved1) && !input1Set) || (HasFlag(Flags.Reserved2) && !input2Set))
		{
			return 0;
		}
		if (input1Amount > 0 && input2Amount > 0)
		{
			return 0;
		}
		int num = Mathf.Max(input1Amount, input2Amount);
		return Mathf.Max(0, num);
	}

	public override void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
	}

	public override void UpdateFromInput(int inputAmount, int slot)
	{
		if (inputAmount > 0 && IsConnectedTo(this, slot, IOEntity.backtracking))
		{
			inputAmount = 0;
			SetFlag(Flags.Reserved7, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved7, b: false);
		}
		switch (slot)
		{
		case 0:
			input1Set = true;
			input1Amount = inputAmount;
			break;
		case 1:
			input2Set = true;
			input2Amount = inputAmount;
			break;
		}
		if (firstRun)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)UpdateFlags))
			{
				((FacepunchBehaviour)this).Invoke((Action)UpdateFlags, 0.1f);
			}
		}
		else
		{
			UpdateFlags();
		}
		firstRun = false;
		base.UpdateFromInput(inputAmount, slot);
	}

	private void UpdateFlags()
	{
		int num = ((input1Amount <= 0 || input2Amount <= 0) ? Mathf.Max(input1Amount, input2Amount) : 0);
		bool b = num > 0;
		Flags num2 = flags;
		SetFlag(Flags.Reserved1, input1Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved3, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, input1Amount > 0 || input2Amount > 0, recursive: false, networkupdate: false);
		SetFlag(Flags.On, num > 0, recursive: false, networkupdate: false);
		if (num2 != flags)
		{
			SendNetworkUpdate_Flags();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class Hopper : IndustrialEntity, IIndustrialStorage
{
	public enum MountType
	{
		Flat,
		Barrel
	}

	private struct HopperMove : IEqualityComparer<HopperMove>
	{
		public IHopperTarget Target;

		public TimeSince Duration;

		public bool Equals(HopperMove x, HopperMove y)
		{
			return object.Equals(x.Target, y.Target);
		}

		public int GetHashCode(HopperMove obj)
		{
			return HashCode.Combine(obj.Target);
		}
	}

	[BurstCompile]
	private struct FillRaycastJob : IJobParallelFor
	{
		[ReadOnly]
		public NativeArray<Vector3> points;

		public NativeArray<RaycastCommand> commands;

		public Vector3 originPoint;

		public int layerMask;

		public void Execute(int index)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = points[index];
			if (!(val == Vector3.zero))
			{
				ref NativeArray<RaycastCommand> reference = ref commands;
				Vector3 val2 = originPoint - val;
				reference[index] = new RaycastCommand(val, ((Vector3)(ref val2)).normalized, Vector3.Distance(val, originPoint), layerMask, 1);
			}
		}
	}

	public class HopperAnimationWorkQueue : PersistentObjectWorkQueue<Hopper>
	{
		protected override void RunJob(Hopper entity)
		{
			entity.MovingItemsTick();
		}
	}

	public interface IHopperTarget
	{
		BaseEntity ToEntity { get; }

		Rigidbody Rigidbody { get; }

		int NumberOfItemsToTransfer { get; }

		float EndPositionToleranceMultiplier { get; }

		void PrepareForHopper();

		void HopperCancelled();

		void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos);
	}

	public TriggerEnterTimer ItemTrigger;

	public Transform ItemMoveTarget;

	public float ItemMoveSpeed = 2f;

	public AnimationCurve ItemHeightChangeSpeed;

	private const float MoveRate = 1f / 60f;

	public AnimationCurve ItemHeightCurve;

	public AnimationCurve ItemSpeedMultiplierCurve;

	public AnimationCurve ItemRotationSpeed;

	public GameObjectRef BloodSpray;

	public bool DebugMode;

	public const Flags MovingItems = Flags.Reserved1;

	public const Flags StandardMount = Flags.Reserved2;

	public const Flags BarrelMount = Flags.Reserved3;

	public Transform RaycastOriginPoint;

	private Action queueScanAction;

	private HashSet<HopperMove> movingItems = new HashSet<HopperMove>();

	private BaseEntity _cachedParent;

	private ItemContainer cachedContainer;

	private Predicate<HopperMove> cachedCheckNull;

	private Predicate<HopperMove> cachedRemove;

	private IHopperTarget matchCheck;

	public static HopperAnimationWorkQueue WorkQueue = new HopperAnimationWorkQueue();

	public BaseEntity cachedParent
	{
		get
		{
			if ((Object)(object)_cachedParent == (Object)null)
			{
				_cachedParent = GetParentEntity();
			}
			return _cachedParent;
		}
	}

	public ItemContainer Container
	{
		get
		{
			if (cachedContainer == null)
			{
				cachedContainer = (cachedParent as StorageContainer)?.inventory;
			}
			return cachedContainer;
		}
	}

	public BaseEntity IndustrialEntity => this;

	public override int ConsumptionAmount()
	{
		return 8;
	}

	public override int DesiredPower(int inputIndex = 0)
	{
		return 8;
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Container != null)
		{
			return new Vector2i(0, Container.capacity - 1);
		}
		return new Vector2i(0, 0);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}

	private void ScanForItemsTick()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		if (ItemTrigger.HasAnyEntityContents && TimeSince.op_Implicit(ItemTrigger.EnterTime) > 0.5f)
		{
			Vector3 position = RaycastOriginPoint.position;
			int num = 128;
			NativeArray<RaycastCommand> val = default(NativeArray<RaycastCommand>);
			val..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<RaycastHit> val2 = default(NativeArray<RaycastHit>);
			val2..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<Vector3> points = default(NativeArray<Vector3>);
			points..ctor(num, (Allocator)3, (NativeArrayOptions)1);
			List<IHopperTarget> list = Pool.Get<List<IHopperTarget>>();
			int num2 = 0;
			int count = movingItems.Count;
			foreach (BaseEntity entityContent in ItemTrigger.entityContents)
			{
				if (entityContent is IHopperTarget hopperTarget && hopperTarget.ToEntity.isServer)
				{
					if (entityContent is DroppedItem droppedItem && !droppedItem.HasFlag(Flags.Reserved3) && Container.QuickIndustrialPreCheck(droppedItem.item, new Vector2i(0, Container.capacity - 1), count, out var _))
					{
						Vector3 val3 = ((Component)droppedItem).transform.position;
						if ((Object)(object)droppedItem.childCollider != (Object)null)
						{
							Bounds val4 = droppedItem.childCollider.bounds;
							val3 = ((Bounds)(ref val4)).center;
						}
						points[num2++] = val3;
						list.Add(hopperTarget);
					}
					else if (entityContent is BaseCorpse baseCorpse && !baseCorpse.HasFlag(Flags.Reserved1))
					{
						Vector3 position2 = ((Component)baseCorpse).transform.position;
						points[num2++] = position2;
						list.Add(hopperTarget);
					}
				}
				if (list.Count == num)
				{
					break;
				}
			}
			FillRaycastJob fillRaycastJob = default(FillRaycastJob);
			fillRaycastJob.originPoint = position;
			fillRaycastJob.points = points;
			fillRaycastJob.commands = val;
			fillRaycastJob.layerMask = 2097152;
			JobHandle val5 = IJobParallelForExtensions.Schedule<FillRaycastJob>(fillRaycastJob, num2, 6, default(JobHandle));
			val5 = RaycastCommand.ScheduleBatch(val, val2, 1, 1, val5);
			((JobHandle)(ref val5)).Complete();
			for (int i = 0; i < num2; i++)
			{
				RaycastHit val6 = val2[i];
				IHopperTarget hopperTarget2 = list[i];
				if ((Object)(object)((RaycastHit)(ref val6)).collider == (Object)null && movingItems.Add(new HopperMove
				{
					Target = hopperTarget2,
					Duration = TimeSince.op_Implicit(0f)
				}))
				{
					hopperTarget2.PrepareForHopper();
					if ((Object)(object)hopperTarget2.Rigidbody != (Object)null)
					{
						hopperTarget2.Rigidbody.useGravity = false;
						hopperTarget2.Rigidbody.velocity = Vector3.zero;
						hopperTarget2.Rigidbody.angularVelocity = Vector3.zero;
					}
					if (Server.hopperAnimationBudgetMs <= 0f)
					{
						IntakeItem(hopperTarget2);
					}
					break;
				}
			}
			val.Dispose();
			val2.Dispose();
			points.Dispose();
			Pool.FreeUnmanaged<IHopperTarget>(ref list);
		}
		SetFlag(Flags.Reserved1, movingItems.Count > 0);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isServer)
		{
			bool flag = next.HasFlag(Flags.Reserved8) || DebugMode;
			if (!((FacepunchBehaviour)this).IsInvoking(queueScanAction) && flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating(queueScanAction, 0.5f, 0.5f);
			}
			else if (((FacepunchBehaviour)this).IsInvoking(queueScanAction) && !flag)
			{
				((FacepunchBehaviour)this).CancelInvoke(queueScanAction);
			}
			bool flag2 = next.HasFlag(Flags.Reserved1);
			if (!((PersistentObjectWorkQueue<Hopper>)WorkQueue).Contains(this) && flag2)
			{
				((PersistentObjectWorkQueue<Hopper>)WorkQueue).Add(this);
			}
			else if (((PersistentObjectWorkQueue<Hopper>)WorkQueue).Contains(this) && !flag2)
			{
				((PersistentObjectWorkQueue<Hopper>)WorkQueue).Remove(this);
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		queueScanAction = QueueScan;
		if (DebugMode)
		{
			OnFlagsChanged(flags, flags);
		}
	}

	internal override void DoServerDestroy()
	{
		if (HasFlag(Flags.Reserved1))
		{
			ResetAllMovingItems();
		}
		base.DoServerDestroy();
	}

	public override void OnPickedUp(Item createdItem, BasePlayer player)
	{
		if (HasFlag(Flags.Reserved1))
		{
			ResetAllMovingItems();
		}
		base.OnPickedUp(createdItem, player);
	}

	private void ResetAllMovingItems()
	{
		((PersistentObjectWorkQueue<Hopper>)WorkQueue).Remove(this);
		SetFlag(Flags.Reserved1, b: false, recursive: false, networkupdate: false);
		Rigidbody val = default(Rigidbody);
		foreach (HopperMove movingItem in movingItems)
		{
			if (movingItem.Target != null && (Object)(object)movingItem.Target.ToEntity != (Object)null)
			{
				if (((Component)movingItem.Target.ToEntity).TryGetComponent<Rigidbody>(ref val))
				{
					val.useGravity = true;
				}
				movingItem.Target.HopperCancelled();
			}
		}
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		base.OnParentChanging(oldParent, newParent);
		MountType mountType = MountType.Flat;
		if ((Object)(object)newParent != (Object)null && newParent is BoxStorage boxStorage)
		{
			mountType = boxStorage.HopperMountType;
		}
		SetFlag(Flags.Reserved3, mountType == MountType.Barrel);
		SetFlag(Flags.Reserved2, mountType == MountType.Flat);
	}

	private void QueueScan()
	{
		((ObjectWorkQueue<IndustrialEntity>)global::IndustrialEntity.Queue).Add((IndustrialEntity)this);
	}

	protected override void RunJob()
	{
		base.RunJob();
		if (IsPowered() || DebugMode)
		{
			ScanForItemsTick();
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot == 0)
		{
			bool b = inputAmount >= ConsumptionAmount() && inputAmount > 0;
			SetFlag(Flags.Reserved8, b);
			currentEnergy = inputAmount;
			ensureOutputsUpdated = true;
			MarkDirty();
		}
	}

	private void MovingItemsTick()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		if (movingItems.Count == 0)
		{
			return;
		}
		if (cachedCheckNull == null)
		{
			cachedCheckNull = CheckNull;
		}
		movingItems.RemoveWhere(cachedCheckNull);
		PooledList<IHopperTarget> val = Pool.Get<PooledList<IHopperTarget>>();
		try
		{
			float num = ItemMoveSpeed * (1f / 60f * Time.timeScale);
			Vector3 position = ItemMoveTarget.position;
			Quaternion rotation = ItemMoveTarget.rotation;
			foreach (HopperMove movingItem in movingItems)
			{
				if (movingItem.Target != null && !((Object)(object)movingItem.Target.ToEntity == (Object)null))
				{
					Vector3 position2 = ((Component)movingItem.Target.ToEntity).transform.position;
					Quaternion rotation2 = ((Component)movingItem.Target.ToEntity).transform.rotation;
					float num2 = Mathf.Clamp01(Vector3.Distance(position2, Vector3Ex.WithY(position, position2.y)) / 3f);
					float num3 = ItemHeightCurve.Evaluate(num2);
					float num4 = ItemSpeedMultiplierCurve.Evaluate(1f - num2);
					Vector3 val2 = Vector3.MoveTowards(position2, position, num * num4);
					val2.y = Mathf.MoveTowards(val2.y, position.y + num3, Time.deltaTime * ItemHeightChangeSpeed.Evaluate(1f - num2));
					Quaternion val3 = Quaternion.RotateTowards(rotation2, rotation, Time.deltaTime * ItemRotationSpeed.Evaluate(1f - num2));
					((Component)movingItem.Target.ToEntity).transform.SetPositionAndRotation(val2, val3);
					if ((Object)(object)movingItem.Target.Rigidbody != (Object)null)
					{
						movingItem.Target.Rigidbody.velocity = Vector3.zero;
						movingItem.Target.Rigidbody.angularVelocity = Vector3.zero;
					}
					float num5 = 0.015f * movingItem.Target.EndPositionToleranceMultiplier;
					Vector3 val4 = val2 - position;
					if (((Vector3)(ref val4)).sqrMagnitude < num5 * num5)
					{
						((List<IHopperTarget>)(object)val).Add(movingItem.Target);
					}
				}
			}
			foreach (HopperMove movingItem2 in movingItems)
			{
				if (TimeSince.op_Implicit(movingItem2.Duration) > 5f)
				{
					((List<IHopperTarget>)(object)val).Add(movingItem2.Target);
				}
			}
			foreach (IHopperTarget item in (List<IHopperTarget>)(object)val)
			{
				IntakeItem(item);
			}
			if (movingItems.Count == 0)
			{
				SetFlag(Flags.Reserved1, b: false);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static bool CheckNull(HopperMove obj)
		{
			if (obj.Target != null)
			{
				return (Object)(object)obj.Target.ToEntity == (Object)null;
			}
			return true;
		}
	}

	private bool Match(HopperMove obj)
	{
		return obj.Target == matchCheck;
	}

	private void IntakeItem(IHopperTarget targetItem)
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (cachedRemove == null)
		{
			cachedRemove = Match;
		}
		matchCheck = targetItem;
		movingItems.RemoveWhere(cachedRemove);
		if (BloodSpray.isValid && targetItem.ToEntity is BaseCorpse)
		{
			Effect.server.Run(BloodSpray.resourcePath, ((Component)this).transform.position);
		}
		targetItem.TransferAllItemsToContainer(Container, ItemMoveTarget.position);
	}
}


public enum MountType
{
	Flat,
	Barrel
}


using System;
using System.Collections.Generic;

private struct HopperMove : IEqualityComparer<HopperMove>
{
	public IHopperTarget Target;

	public TimeSince Duration;

	public bool Equals(HopperMove x, HopperMove y)
	{
		return object.Equals(x.Target, y.Target);
	}

	public int GetHashCode(HopperMove obj)
	{
		return HashCode.Combine(obj.Target);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
private struct FillRaycastJob : IJobParallelFor
{
	[ReadOnly]
	public NativeArray<Vector3> points;

	public NativeArray<RaycastCommand> commands;

	public Vector3 originPoint;

	public int layerMask;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = points[index];
		if (!(val == Vector3.zero))
		{
			ref NativeArray<RaycastCommand> reference = ref commands;
			Vector3 val2 = originPoint - val;
			reference[index] = new RaycastCommand(val, ((Vector3)(ref val2)).normalized, Vector3.Distance(val, originPoint), layerMask, 1);
		}
	}
}


public class HopperAnimationWorkQueue : PersistentObjectWorkQueue<Hopper>
{
	protected override void RunJob(Hopper entity)
	{
		entity.MovingItemsTick();
	}
}


using UnityEngine;

public interface IHopperTarget
{
	BaseEntity ToEntity { get; }

	Rigidbody Rigidbody { get; }

	int NumberOfItemsToTransfer { get; }

	float EndPositionToleranceMultiplier { get; }

	void PrepareForHopper();

	void HopperCancelled();

	void TransferAllItemsToContainer(ItemContainer itemContainer, Vector3 fallbackWorldPos);
}


using UnityEngine;

public class IndustrialEntity : IOEntity
{
	public class IndustrialProcessQueue : ObjectWorkQueue<IndustrialEntity>
	{
		protected override void RunJob(IndustrialEntity job)
		{
			if ((Object)(object)job != (Object)null)
			{
				job.RunJob();
			}
		}
	}

	public static IndustrialProcessQueue Queue = new IndustrialProcessQueue();

	protected virtual void RunJob()
	{
	}
}


using UnityEngine;

public class IndustrialProcessQueue : ObjectWorkQueue<IndustrialEntity>
{
	protected override void RunJob(IndustrialEntity job)
	{
		if ((Object)(object)job != (Object)null)
		{
			job.RunJob();
		}
	}
}


public interface IIndustrialStorage
{
	ItemContainer Container { get; }

	BaseEntity IndustrialEntity { get; }

	Vector2i InputSlotRange(int slotIndex);

	Vector2i OutputSlotRange(int slotIndex);

	void OnStorageItemTransferBegin();

	void OnStorageItemTransferEnd();
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class IndustrialFilterBuffer : MonoBehaviour
{
	public RustText ItemName;

	public Image ItemIcon;

	public GameObject BlueprintRoot;

	public RustSlider BufferSlider;

	public RustText BufferProgressText;
}


using Rust.UI;
using UnityEngine;

public class IndustrialFilterDialog : UIDialog
{
	public GameObjectRef ItemPrefab;

	public Transform ItemParent;

	public GameObject ItemSearchParent;

	public ItemSearchEntry ItemSearchEntryPrefab;

	public GameObject NoItemsPrompt;

	public Dropdown FilterModeDropdown;

	public GameObject[] FilterModeExplanations;

	public GameObject FilterModeBlocker;

	public RustText FilterCountText;

	public GameObject BufferRoot;

	public GameObjectRef BufferItemPrefab;

	public Transform BufferTransform;

	public RustButton PasteButton;

	public GameObject[] RegularCopyPasteButtons;

	public GameObject[] JsonCopyPasteButtons;

	public bool closeWhenClicked;

	public int count = 20;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class IndustrialFilterItemIcon : MonoBehaviour
{
	public Image ItemIcon;

	public RustText ItemName;

	public RustInput MaxInput;

	public RustInput BufferInput;

	public RustInput MinInput;

	public GameObject BlueprintIcon;

	public GameObject InverseModeBlocker;
}


public interface IIndustrialStorageCallbackReceiver
{
	void OnIndustrialItemTransferBegins();

	void OnIndustrialItemTransferEnd();
}


using System;
using UnityEngine;

[RequireComponent(typeof(IOEntity))]
public class IOEntityMovementChecker : FacepunchBehaviour
{
	private IOEntity ioEntity;

	private Vector3 prevPos;

	private const float MAX_MOVE = 0.05f;

	private const float MAX_MOVE_SQR = 0.0025000002f;

	protected void Awake()
	{
		ioEntity = ((Component)this).GetComponent<IOEntity>();
	}

	protected void OnEnable()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckPosition, Random.Range(0f, 0.25f), 0.25f);
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckPosition);
	}

	private void CheckPosition()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!ioEntity.isClient && Vector3.SqrMagnitude(((Component)this).transform.position - prevPos) > 0.0025000002f)
		{
			prevPos = ((Component)this).transform.position;
			if (ioEntity.HasConnections())
			{
				ioEntity.SendChangedToRoot(forceUpdate: true);
				ioEntity.ClearConnections();
			}
		}
	}
}


using UnityEngine;

public class IOHandle : MonoBehaviour
{
}


public enum IOHandlePriority
{
	Normal,
	Low,
	High
}


public class IOManager : SingletonComponent<IOManager>
{
}


using UnityEngine;

public class ProgressDoor : IOEntity
{
	public float storedEnergy;

	public float energyForOpen = 1f;

	public float secondsToClose = 1f;

	public float openProgress;

	public override void ResetIOState()
	{
		storedEnergy = 0f;
		UpdateProgress();
	}

	public override float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		if (inputAmount > 0f)
		{
			AddEnergy(inputAmount);
			if (storedEnergy == energyForOpen)
			{
				return inputAmount;
			}
			return 0f;
		}
		NoEnergy();
		return inputAmount;
	}

	public virtual void NoEnergy()
	{
	}

	public virtual void AddEnergy(float amount)
	{
		if (!(amount <= 0f))
		{
			storedEnergy += amount;
			storedEnergy = Mathf.Clamp(storedEnergy, 0f, energyForOpen);
		}
	}

	public virtual void UpdateProgress()
	{
		SendNetworkUpdate();
	}
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SlidingProgressDoor : ProgressDoor
{
	public Vector3 openPosition;

	public Vector3 closedPosition;

	public GameObject doorObject;

	public TriggerVehiclePush vehiclePhysBox;

	private float lastEnergyTime;

	private float lastServerUpdateTime;

	public override void Spawn()
	{
		base.Spawn();
		((FacepunchBehaviour)this).InvokeRepeating((Action)ServerUpdate, 0f, 0.1f);
		if ((Object)(object)vehiclePhysBox != (Object)null)
		{
			((Component)vehiclePhysBox).gameObject.SetActive(false);
		}
	}

	public override void NoEnergy()
	{
		base.NoEnergy();
	}

	public override void AddEnergy(float amount)
	{
		lastEnergyTime = Time.time;
		base.AddEnergy(amount);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return true;
	}

	public void ServerUpdate()
	{
		if (!base.isServer)
		{
			return;
		}
		if (lastServerUpdateTime == 0f)
		{
			lastServerUpdateTime = Time.realtimeSinceStartup;
		}
		float num = Time.realtimeSinceStartup - lastServerUpdateTime;
		lastServerUpdateTime = Time.realtimeSinceStartup;
		if (Time.time > lastEnergyTime + 0.333f)
		{
			float num2 = energyForOpen * num / secondsToClose;
			float num3 = Mathf.Min(storedEnergy, num2);
			if ((Object)(object)vehiclePhysBox != (Object)null)
			{
				((Component)vehiclePhysBox).gameObject.SetActive(num3 > 0f && storedEnergy > 0f);
				if (((Component)vehiclePhysBox).gameObject.activeSelf && vehiclePhysBox.ContentsCount > 0)
				{
					num3 = 0f;
				}
			}
			storedEnergy -= num3;
			storedEnergy = Mathf.Clamp(storedEnergy, 0f, energyForOpen);
			if (num3 > 0f)
			{
				IOSlot[] array = outputs;
				foreach (IOSlot iOSlot in array)
				{
					if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
					{
						iOSlot.connectedTo.Get().IOInput(this, ioType, 0f - num3, iOSlot.connectedToSlot);
					}
				}
			}
		}
		UpdateProgress();
	}

	public override void UpdateProgress()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localPosition = doorObject.transform.localPosition;
		float num = storedEnergy / energyForOpen;
		Vector3 val = Vector3.Lerp(closedPosition, openPosition, num);
		doorObject.transform.localPosition = val;
		if (base.isServer)
		{
			bool flag = Vector3.Distance(localPosition, val) > 0.01f;
			SetFlag(Flags.Reserved1, flag);
			if (flag)
			{
				SendNetworkUpdate();
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.sphereEntity;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = storedEnergy;
	}
}


using System;
using UnityEngine;

public class NoPlayersIOReset : FacepunchBehaviour
{
	[SerializeField]
	private IOEntity[] entitiesToReset;

	[SerializeField]
	private float radius;

	[SerializeField]
	private float timeBetweenChecks;

	protected void OnEnable()
	{
		((FacepunchBehaviour)this).InvokeRandomized((Action)Check, timeBetweenChecks, timeBetweenChecks, timeBetweenChecks * 0.1f);
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Check);
	}

	private void Check()
	{
		if (!PuzzleReset.AnyPlayersWithinDistance(((Component)this).transform, radius, 0f))
		{
			Reset();
		}
	}

	private void Reset()
	{
		IOEntity[] array = entitiesToReset;
		foreach (IOEntity iOEntity in array)
		{
			if (iOEntity.IsValid() && iOEntity.isServer)
			{
				iOEntity.ResetIOState();
				iOEntity.MarkDirty();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Rust;
using UnityEngine;

public class PuzzleReset : FacepunchBehaviour
{
	public SpawnGroup[] respawnGroups;

	public IOEntity[] resetEnts;

	public GameObject[] resetObjects;

	public bool playersBlockReset;

	public bool CheckSleepingAIZForPlayers;

	public float playerDetectionRadius;

	public Transform playerDetectionOrigin;

	public bool ignoreAboveGroundPlayers;

	public float timeBetweenResets = 30f;

	public bool scaleWithServerPopulation;

	public bool pauseUntilLooted;

	[Tooltip("Ignore players below this height")]
	public float minimumHeightOffset;

	private float timeSpentBlocked;

	[HideInInspector]
	public Vector3[] resetPositions;

	public bool broadcastResetMessage;

	public Phrase resetPhrase;

	private List<SpawnGroup> _cachedSpawnGroups;

	public bool radiationReset;

	public static Phrase BlockedWarningPhrase = new Phrase("monument.blocked.warning", "This monument is resetting, please leave the area!");

	private AIInformationZone zone;

	private TwoTierRadiationZone radiationZone;

	public static ListHashSet<PuzzleReset> AllResets = new ListHashSet<PuzzleReset>();

	private float currentResetTotalTime;

	private float timePausedUnlooted;

	public float resetTimeElapsed;

	private float timeSpentEmptyWithRads;

	private float timeSpentBlockedWithRads;

	private bool hasBeenLooted;

	private float resetTickTime = 10f;

	private bool hasPlayerEnteredRange;

	private string lootedSpawnGroupName;

	private static string TwoTierRadSpherePath = "assets/prefabs/io/electric/generators/twotierradiationsphere.prefab";

	private static string TwoTierRadBoxPath = "assets/prefabs/io/electric/generators/twotierradiationbox.prefab";

	private bool canUseRadiationReset
	{
		get
		{
			if (radiationReset)
			{
				return ConVar.Server.monumentPuzzleResetRadiation;
			}
			return false;
		}
	}

	public float lastNormalizedRadiation { get; private set; }

	public float GetResetSpacing()
	{
		return timeBetweenResets * (scaleWithServerPopulation ? (1f - SpawnHandler.PlayerLerp(Spawn.min_rate, Spawn.max_rate)) : 1f);
	}

	private void OnEnable()
	{
		AllResets.Add(this);
	}

	private void OnDisable()
	{
		AllResets.Remove(this);
	}

	public void Start()
	{
		if (timeBetweenResets != float.PositiveInfinity)
		{
			ResetTimer();
		}
	}

	public void ResetTimer()
	{
		ResetTimeCounters();
		((FacepunchBehaviour)this).CancelInvoke((Action)ResetTick);
		((FacepunchBehaviour)this).InvokeRandomized((Action)ResetTick, Random.Range(0f, 1f), resetTickTime, 0.5f);
	}

	private void ResetTimeCounters()
	{
		resetTimeElapsed = 0f;
		timePausedUnlooted = 0f;
		timeSpentBlocked = 0f;
		timeSpentEmptyWithRads = 0f;
		timeSpentBlockedWithRads = 0f;
		currentResetTotalTime = 0f;
		hasPlayerEnteredRange = false;
	}

	public bool PassesResetCheck()
	{
		if (playersBlockReset)
		{
			if (CheckSleepingAIZForPlayers)
			{
				if (radiationReset && (Object)(object)radiationZone != (Object)null && lastNormalizedRadiation > 0f)
				{
					return !radiationZone.HasPlayersInRange();
				}
				bool num = AIZSleeping();
				if (!num)
				{
					TryDDrawAIZone();
				}
				return num;
			}
			return !PlayersWithinDistance();
		}
		return true;
	}

	private void TryDDrawAIZone()
	{
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		AIInformationZone aIZone = GetAIZone();
		if (!ConVar.Server.drawpuzzleresets || !((Object)(object)aIZone != (Object)null))
		{
			return;
		}
		if (aIZone.wakeTriggers.Count == 0)
		{
			Debug.LogWarning((object)"Trying to draw AIZone for PuzzleReset but it has no TriggerWakeAIZ!");
			return;
		}
		TriggerWakeAIZ triggerWakeAIZ = aIZone.wakeTriggers[0];
		if (aIZone.wakeTriggers.Count > 1)
		{
			Debug.LogWarning((object)"Trying to draw AIZone for PuzzleReset but it has multiple TriggerWakeAIZs! Defaulting to first one found");
		}
		if (triggerWakeAIZ.entityContents == null)
		{
			Debug.LogWarning((object)"Trying to draw AIZone for PuzzleReset but TriggerWakeAIZ has null entity contents");
			return;
		}
		foreach (BasePlayer item in triggerWakeAIZ.entityContents.OfType<BasePlayer>())
		{
			if (item.IsAdmin)
			{
				OBB areaBox = aIZone.areaBox;
				if (((OBB)(ref areaBox)).Contains(((Component)item).transform.position))
				{
					item.SendConsoleCommand(DDrawCommand.Box(aIZone.areaBox.position, 10f, Color.green, aIZone.areaBox.extents * 2f, aIZone.areaBox.rotation, distanceFade: false));
					item.SendConsoleCommand(DDrawCommand.Box(aIZone.areaBox.position, 10f, Color.yellow, ScaleSizeByConVar(aIZone.areaBox.extents * 2f), aIZone.areaBox.rotation, distanceFade: false));
				}
			}
		}
	}

	private void DDrawLootedStatus()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)playerDetectionOrigin == (Object)null)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.IsAdmin && IsPlayerInRange(current))
				{
					string text = $"Looted: {hasBeenLooted}";
					if (hasBeenLooted)
					{
						text = text + "\nGroup: " + (lootedSpawnGroupName ?? "Unknown");
					}
					current.SendConsoleCommand(DDrawCommand.Text(((Component)playerDetectionOrigin).transform.position, 10f, Color.green, text, distanceFade: false));
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public AIInformationZone GetAIZone()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)zone != (Object)null)
		{
			if (!zone.PointInside(((Component)this).transform.position))
			{
				zone = AIInformationZone.GetForPoint(((Component)this).transform.position);
			}
		}
		else
		{
			zone = AIInformationZone.GetForPoint(((Component)this).transform.position);
		}
		return zone;
	}

	public List<SpawnGroup> GetSpawnGroups()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (_cachedSpawnGroups != null)
		{
			return _cachedSpawnGroups;
		}
		_cachedSpawnGroups = new List<SpawnGroup>();
		Vis.Components<SpawnGroup>(((Component)this).transform.position, 1f, _cachedSpawnGroups, 262144, (QueryTriggerInteraction)2);
		return _cachedSpawnGroups;
	}

	private bool AIZSleeping()
	{
		AIInformationZone aIZone = GetAIZone();
		if ((Object)(object)aIZone == (Object)null)
		{
			return false;
		}
		return aIZone.Sleeping;
	}

	private bool PlayersWithinDistance()
	{
		return AnyPlayersWithinDistance(playerDetectionOrigin, playerDetectionRadius, minimumHeightOffset, ignoreAboveGroundPlayers);
	}

	public static bool AnyPlayersWithinDistance(Transform origin, float radius, float heightOffset, bool ignoreAboveGroundPlayers = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		float num = origin.position.y - radius + heightOffset;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.IsSleeping() || !current.IsAlive() || current.isInvisible || ((Component)current).transform.position.y < num || !(Vector3.Distance(((Component)current).transform.position, origin.position) < radius) || (ignoreAboveGroundPlayers && !current.IsUnderground()))
				{
					continue;
				}
				if (ConVar.Server.drawpuzzleresets && current.IsAdmin)
				{
					float duration = 10f;
					current.SendConsoleCommand(DDrawCommand.Sphere(origin.position, duration, Color.green, radius, distanceFade: false));
					current.SendConsoleCommand(DDrawCommand.Sphere(origin.position, duration, Color.yellow, ScaleRadiusByConVar(radius), distanceFade: false));
					if (heightOffset > 0f)
					{
						Vector3 val = origin.position + new Vector3(0f, 0f - radius + heightOffset, 0f);
						current.SendConsoleCommand(DDrawCommand.Line(val + new Vector3(radius, 0f, 0f), val - new Vector3(radius, 0f, 0f), duration, Color.red, distanceFade: false, zTest: true));
						current.SendConsoleCommand(DDrawCommand.Line(val + new Vector3(0f, 0f, radius), val - new Vector3(0f, 0f, radius), duration, Color.red, distanceFade: false, zTest: true));
					}
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	public void ResetTick()
	{
		float num = resetTickTime * Debugging.puzzleResetTimeMultiplier;
		currentResetTotalTime += num;
		if (pauseUntilLooted && ConVar.Server.pauseunlootedpuzzles)
		{
			hasBeenLooted = HasPuzzleBeenPartialLooted(out var lootedSpawnGroup);
			lootedSpawnGroupName = (((Object)(object)lootedSpawnGroup == (Object)null) ? null : ((Object)lootedSpawnGroup).name);
			if (ConVar.Server.drawpuzzleresets)
			{
				DDrawLootedStatus();
			}
			if (!hasBeenLooted)
			{
				timePausedUnlooted += num;
				return;
			}
		}
		if (canUseRadiationReset)
		{
			bool num2 = !PassesResetCheck();
			if (num2)
			{
				hasPlayerEnteredRange = true;
			}
			if (!hasPlayerEnteredRange)
			{
				num = 0f;
			}
			resetTimeElapsed += num;
			if (num2)
			{
				timeSpentBlocked += num;
				timeSpentBlockedWithRads += num;
				hasPlayerEnteredRange = true;
			}
			else if (lastNormalizedRadiation > 0f)
			{
				timeSpentEmptyWithRads += num;
			}
		}
		else if (PassesResetCheck())
		{
			resetTimeElapsed += num;
		}
		else
		{
			timeSpentBlocked += num;
		}
		float resetSpacing = GetResetSpacing();
		if (resetTimeElapsed > resetSpacing && (!canUseRadiationReset || timeSpentEmptyWithRads > ConVar.Server.monumentPuzzleResetRadiationPlayerEmptyTime))
		{
			DoReset();
			ResetTimeCounters();
		}
		float num3 = resetSpacing - resetTimeElapsed;
		if (!canUseRadiationReset || (!(num3 < ConVar.Server.monumentPuzzleResetRadiationPreResetTime) && !ConVar.Server.monumentpuzzleresetradiationoverride))
		{
			return;
		}
		SetRadiusRadiationAmount(ConVar.Server.monumentpuzzleresetradiationoverride ? 0.95f : (1f - Mathf.Clamp01(num3 / ConVar.Server.monumentPuzzleResetRadiationPreResetTime)));
		if (ConVar.Server.monumentPuzzleResetWarnings && (Object)(object)radiationZone != (Object)null)
		{
			PooledList<BasePlayer> val = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				NotifyRadiationZone(radiationZone.InnerRadiation, (List<BasePlayer>)(object)val);
				NotifyRadiationZone(radiationZone.OuterRadiation, (List<BasePlayer>)(object)val);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		void NotifyRadiationZone(TriggerRadiation r, List<BasePlayer> sentPlayers)
		{
			if (r.entityContents == null)
			{
				return;
			}
			foreach (BaseEntity entityContent in r.entityContents)
			{
				if (entityContent is BasePlayer { IsNpc: false } basePlayer && !sentPlayers.Contains(basePlayer) && (!ignoreAboveGroundPlayers || basePlayer.IsUnderground()))
				{
					sentPlayers.Add(basePlayer);
					basePlayer.ShowToast(GameTip.Styles.Error, BlockedWarningPhrase, false);
				}
			}
		}
	}

	private bool HasPuzzleBeenPartialLooted(out SpawnGroup lootedSpawnGroup)
	{
		lootedSpawnGroup = null;
		if (GetSpawnGroups().Count == 0)
		{
			return true;
		}
		foreach (SpawnGroup spawnGroup in GetSpawnGroups())
		{
			if ((Object)(object)spawnGroup == (Object)null || spawnGroup.WantsTimedSpawn() || spawnGroup.resetBehavior == SpawnGroupResetBehavior.Exclude || (spawnGroup.DoesGroupContainNPCs() && spawnGroup.resetBehavior != SpawnGroupResetBehavior.Include))
			{
				continue;
			}
			if (spawnGroup.ObjectsActive < Mathf.Min(spawnGroup.maxPopulation, spawnGroup.SpawnPointCount))
			{
				lootedSpawnGroup = spawnGroup;
				return true;
			}
			foreach (SpawnPointInstance spawnInstance in spawnGroup.SpawnInstances)
			{
				if (spawnInstance.Entity is LootContainer { HasBeenLooted: not false })
				{
					lootedSpawnGroup = spawnGroup;
					return true;
				}
			}
		}
		return false;
	}

	public void CleanupSleepers()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)playerDetectionOrigin == (Object)null || BasePlayer.sleepingPlayerList == null)
		{
			return;
		}
		for (int num = BasePlayer.sleepingPlayerList.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer = BasePlayer.sleepingPlayerList[num];
			if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsSleeping() && Vector3.Distance(((Component)basePlayer).transform.position, playerDetectionOrigin.position) <= playerDetectionRadius && (!ignoreAboveGroundPlayers || basePlayer.IsUnderground()))
			{
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
			}
		}
	}

	public void DoReset()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		SetRadiusRadiationAmount(0f);
		CleanupSleepers();
		IOEntity component = ((Component)this).GetComponent<IOEntity>();
		if ((Object)(object)component != (Object)null)
		{
			ResetIOEntRecursive(component, Time.frameCount);
			component.MarkDirty();
		}
		else if (resetPositions != null)
		{
			Vector3[] array = resetPositions;
			foreach (Vector3 val in array)
			{
				Vector3 position = ((Component)this).transform.TransformPoint(val);
				List<IOEntity> list = Pool.Get<List<IOEntity>>();
				Vis.Entities(position, 0.5f, list, 1235288065, (QueryTriggerInteraction)1);
				foreach (IOEntity item in list)
				{
					if (item.IsRootEntity() && item.isServer)
					{
						ResetIOEntRecursive(item, Time.frameCount);
						item.MarkDirty();
					}
				}
				Pool.FreeUnmanaged<IOEntity>(ref list);
			}
		}
		foreach (SpawnGroup spawnGroup in GetSpawnGroups())
		{
			if (!((Object)(object)spawnGroup == (Object)null))
			{
				spawnGroup.Clear();
				spawnGroup.DelayedSpawn();
			}
		}
		GameObject[] array2 = resetObjects;
		foreach (GameObject val2 in array2)
		{
			if ((Object)(object)val2 != (Object)null)
			{
				val2.SendMessage("OnPuzzleReset", (SendMessageOptions)1);
			}
		}
		if (broadcastResetMessage)
		{
			Enumerator<BasePlayer> enumerator3 = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator3.MoveNext())
				{
					BasePlayer current3 = enumerator3.Current;
					if (!current3.IsNpc && current3.IsConnected && !current3.IsInTutorial)
					{
						current3.ShowToast(GameTip.Styles.Server_Event, resetPhrase, false);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator3/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Analytics.Azure.OnPuzzleReset(this, currentResetTotalTime, timeSpentBlocked, timeSpentBlockedWithRads, timePausedUnlooted);
	}

	public void DebugApplyPuzzleResetTime(float time)
	{
		float num = resetTickTime;
		resetTickTime = time;
		ResetTick();
		resetTickTime = num;
	}

	public static void ResetIOEntRecursive(IOEntity target, int resetIndex)
	{
		if (target.lastResetIndex == resetIndex)
		{
			return;
		}
		target.lastResetIndex = resetIndex;
		target.ResetIOState();
		IOEntity.IOSlot[] outputs = target.outputs;
		foreach (IOEntity.IOSlot iOSlot in outputs)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null && (Object)(object)iOSlot.connectedTo.Get() != (Object)(object)target)
			{
				ResetIOEntRecursive(iOSlot.connectedTo.Get(), resetIndex);
			}
		}
	}

	private void SetRadiusRadiationAmount(float normalisedAmount)
	{
		if (!canUseRadiationReset)
		{
			normalisedAmount = 0f;
		}
		InitialiseRadiationTriggers();
		if ((Object)(object)radiationZone == (Object)null)
		{
			return;
		}
		((Component)radiationZone).gameObject.SetActive(normalisedAmount > 0f);
		radiationZone.SetRadiationLevel(normalisedAmount * ConVar.Server.monumentPuzzleResetRadiationAmount, normalisedAmount * 10f);
		radiationZone.SetBypassArmor(state: true);
		radiationZone.SetIgnoreAboveGroundPlayers(ignoreAboveGroundPlayers);
		lastNormalizedRadiation = normalisedAmount;
		if (!(normalisedAmount >= 1f) || radiationZone.InnerRadiation.entityContents == null)
		{
			return;
		}
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			((List<BaseEntity>)(object)val).AddRange((IEnumerable<BaseEntity>)radiationZone.InnerRadiation.entityContents);
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				if (item is BasePlayer basePlayer && (!ignoreAboveGroundPlayers || basePlayer.IsUnderground()))
				{
					basePlayer.Hurt(25f, DamageType.Radiation, null, useProtection: false);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void InitialiseRadiationTriggers()
	{
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		if (!canUseRadiationReset)
		{
			return;
		}
		if ((Object)(object)radiationZone == (Object)null)
		{
			if (CheckSleepingAIZForPlayers)
			{
				if ((Object)(object)GetAIZone() != (Object)null)
				{
					GameObject val = GameManager.server.CreatePrefab(TwoTierRadBoxPath, ((Component)this).transform);
					radiationZone = val.GetComponent<TwoTierRadiationZone>();
				}
			}
			else
			{
				GameObject val2 = GameManager.server.CreatePrefab(TwoTierRadSpherePath, ((Component)this).transform);
				radiationZone = val2.GetComponent<TwoTierRadiationZone>();
				if ((Object)(object)playerDetectionOrigin != (Object)null)
				{
					val2.transform.localPosition = playerDetectionOrigin.localPosition;
					val2.transform.localRotation = playerDetectionOrigin.localRotation;
					val2.transform.localScale = Vector3.one;
				}
			}
		}
		if (CheckSleepingAIZForPlayers)
		{
			Vector3 val3 = ScaleSizeByConVar(zone.areaBox.extents * 2f);
			Vector3 val4 = ((Component)this).transform.InverseTransformPoint(zone.areaBox.position);
			radiationZone.Apply(new Bounds(val4, zone.areaBox.extents * 2f), new Bounds(val4, val3));
			((Component)radiationZone).transform.rotation = zone.areaBox.rotation;
			return;
		}
		float num = playerDetectionRadius;
		float num2 = ScaleRadiusByConVar(playerDetectionRadius);
		float num3 = num2 - num;
		((Component)radiationZone).transform.localPosition = playerDetectionOrigin.localPosition;
		radiationZone.Apply(num, num2);
		radiationZone.InnerRadiation.MinLocalHeight = 0f - num + minimumHeightOffset;
		_ = playerDetectionRadius;
		radiationZone.OuterRadiation.MinLocalHeight = 0f - num2 + num3 + minimumHeightOffset;
		radiationZone.InnerRadiation.ApplyLocalHeightCheck = true;
		radiationZone.OuterRadiation.ApplyLocalHeightCheck = true;
	}

	public bool IsPlayerInRange(BasePlayer bp)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (CheckSleepingAIZForPlayers)
		{
			OBB areaBox = GetAIZone().areaBox;
			if (((OBB)(ref areaBox)).Contains(((Component)bp).transform.position))
			{
				return true;
			}
		}
		else
		{
			float num = playerDetectionOrigin.position.y - playerDetectionRadius + minimumHeightOffset;
			if (((Component)bp).transform.position.y < num)
			{
				return false;
			}
			if (bp.Distance(playerDetectionOrigin.position) <= playerDetectionRadius)
			{
				return true;
			}
		}
		return false;
	}

	public void GetDebugInfo(List<string> readout)
	{
		float resetSpacing = GetResetSpacing();
		readout.Add($"Reset time: {resetTimeElapsed}/{resetSpacing}");
		if (canUseRadiationReset)
		{
			float num = resetSpacing - ConVar.Server.monumentPuzzleResetRadiationPreResetTime - resetTimeElapsed;
			if (num > 0f)
			{
				readout.Add($"Rads begin in {num}");
			}
			else
			{
				readout.Add($"Rads active: {lastNormalizedRadiation}");
				readout.Add($"Time spent empty with rads:{timeSpentEmptyWithRads}/{ConVar.Server.monumentPuzzleResetRadiationPlayerEmptyTime}");
			}
			if (!hasPlayerEnteredRange)
			{
				readout.Add("No player has entered range, will not tick");
			}
			else
			{
				readout.Add("Player has entered range, ticking...");
			}
		}
	}

	public MonumentInfo GetClosestMonumentInfo()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null)
		{
			float num = float.MaxValue;
			MonumentInfo result = null;
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					float num2 = Vector3.Distance(((Component)this).transform.position, ((Component)monument).transform.position);
					if (num2 < num)
					{
						num = num2;
						result = monument;
					}
				}
				return result;
			}
		}
		return null;
	}

	private static float ScaleRadiusByConVar(float radius)
	{
		return Mathf.Min(radius * ConVar.Server.monumentPuzzleResetRadiationRadiusMultiplier, radius + ConVar.Server.monumentPuzzleResetRadiationMaxRadiusIncrease);
	}

	private static Vector3 ScaleSizeByConVar(Vector3 size)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		size.x = Mathf.Min(size.x * ConVar.Server.monumentPuzzleResetRadiationRadiusMultiplier, size.x + ConVar.Server.monumentPuzzleResetRadiationMaxRadiusIncrease * 2f);
		size.y = Mathf.Min(size.y * ConVar.Server.monumentPuzzleResetRadiationRadiusMultiplier, size.y + ConVar.Server.monumentPuzzleResetRadiationMaxRadiusIncrease * 2f);
		size.z = Mathf.Min(size.z * ConVar.Server.monumentPuzzleResetRadiationRadiusMultiplier, size.z + ConVar.Server.monumentPuzzleResetRadiationMaxRadiusIncrease * 2f);
		return size;
	}
}


public class FrequencyConfig : IOConfig<IRFObject>
{
}


using UnityEngine;

public interface IRFObject
{
	Vector3 GetPosition();

	float GetMaxRange();

	void RFSignalUpdate(bool on);

	int GetFrequency();
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class RFManager
{
	private static readonly Dictionary<int, HashSet<IRFObject>> _listeners = new Dictionary<int, HashSet<IRFObject>>();

	private static readonly Dictionary<int, HashSet<IRFObject>> _broadcasters = new Dictionary<int, HashSet<IRFObject>>();

	private static readonly Dictionary<int, bool> _isFrequencyBroadcasting = new Dictionary<int, bool>();

	public static int minFreq = 1;

	public static int maxFreq = 999999;

	private static int reserveRangeMin = 4760;

	private static int reserveRangeMax = 4790;

	public static Phrase reservedFrequencyPhrase = new Phrase("rf.reservedfrequency", "Channels {0} to {1} are restricted");

	public static int ClampFrequency(int freq)
	{
		return Mathf.Clamp(freq, minFreq, maxFreq);
	}

	public static HashSet<IRFObject> GetListenerSet(int frequency)
	{
		frequency = ClampFrequency(frequency);
		if (!_listeners.TryGetValue(frequency, out var value))
		{
			value = new HashSet<IRFObject>();
			_listeners[frequency] = value;
		}
		return value;
	}

	public static HashSet<IRFObject> GetBroadcasterSet(int frequency)
	{
		frequency = ClampFrequency(frequency);
		if (!_broadcasters.TryGetValue(frequency, out var value))
		{
			value = new HashSet<IRFObject>();
			_broadcasters[frequency] = value;
		}
		return value;
	}

	public static void AddListener(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfListenerAdd", (object)obj, (object)frequency) == null && GetListenerSet(frequency).Add(obj))
		{
			bool value;
			bool on = _isFrequencyBroadcasting.TryGetValue(frequency, out value) && value;
			obj.RFSignalUpdate(on);
			Interface.CallHook("OnRfListenerAdded", (object)obj, (object)frequency);
		}
	}

	public static void RemoveListener(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfListenerRemove", (object)obj, (object)frequency) == null && GetListenerSet(frequency).Remove(obj))
		{
			obj.RFSignalUpdate(on: false);
			Interface.CallHook("OnRfListenerRemoved", (object)obj, (object)frequency);
		}
	}

	public static void AddBroadcaster(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfBroadcasterAdd", (object)obj, (object)frequency) != null)
		{
			return;
		}
		HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);
		if (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)
		{
			Debug.LogWarning((object)$"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.");
		}
		if (broadcasterSet.Add(obj))
		{
			Interface.CallHook("OnRfBroadcasterAdded", (object)obj, (object)frequency);
			if (!_isFrequencyBroadcasting.TryGetValue(frequency, out var value) || !value)
			{
				_isFrequencyBroadcasting[frequency] = true;
				UpdateListenersForFrequency(frequency, isBroadcasting: true);
			}
		}
	}

	public static void RemoveBroadcaster(int frequency, IRFObject obj)
	{
		frequency = ClampFrequency(frequency);
		if (Interface.CallHook("OnRfBroadcasterRemove", (object)obj, (object)frequency) != null)
		{
			return;
		}
		HashSet<IRFObject> broadcasterSet = GetBroadcasterSet(frequency);
		if (broadcasterSet.RemoveWhere((IRFObject b) => b == null || !b.IsValidEntityReference()) > 0)
		{
			Debug.LogWarning((object)$"Found null entries in the RF broadcaster set for frequency {frequency}... cleaning up.");
		}
		if (broadcasterSet.Remove(obj))
		{
			Interface.CallHook("OnRfBroadcasterRemoved", (object)obj, (object)frequency);
			if (broadcasterSet.Count == 0)
			{
				_isFrequencyBroadcasting[frequency] = false;
				UpdateListenersForFrequency(frequency, isBroadcasting: false);
			}
		}
	}

	private static void UpdateListenersForFrequency(int frequency, bool isBroadcasting)
	{
		HashSet<IRFObject> listenerSet = GetListenerSet(frequency);
		listenerSet.RemoveWhere((IRFObject l) => l == null || !l.IsValidEntityReference());
		foreach (IRFObject item in listenerSet)
		{
			item.RFSignalUpdate(isBroadcasting);
		}
	}

	public static bool IsReserved(int frequency)
	{
		if (frequency >= reserveRangeMin && frequency <= reserveRangeMax)
		{
			return true;
		}
		return false;
	}

	public static void ReserveErrorPrint(BasePlayer player)
	{
		player.ShowToast(GameTip.Styles.Error, reservedFrequencyPhrase, false, reserveRangeMin.ToString(), reserveRangeMax.ToString());
	}

	public static void ChangeFrequency(int oldFrequency, int newFrequency, IRFObject obj, bool isListener, bool isOn = true)
	{
		newFrequency = ClampFrequency(newFrequency);
		if (isListener)
		{
			RemoveListener(oldFrequency, obj);
			if (isOn)
			{
				AddListener(newFrequency, obj);
			}
		}
		else
		{
			RemoveBroadcaster(oldFrequency, obj);
			if (isOn)
			{
				AddBroadcaster(newFrequency, obj);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BaseHuntEvent : BaseEntity
{
	public GameObjectRef[] HuntablePrefab;

	protected List<string> HuntableResourcePathCached;

	public AudioSource huntStartSound;

	public override void ServerInit()
	{
		base.ServerInit();
		HuntableResourcePathCached = new List<string>();
		for (int i = 0; i < HuntablePrefab.Length; i++)
		{
			HuntableResourcePathCached.Add(HuntablePrefab[i].resourcePath);
		}
	}
}


using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class CargoPlane : BaseEntity
{
	public GameObjectRef prefabDrop;

	public SpawnFilter filter;

	public Vector3 startPos;

	public Vector3 endPos;

	public float secondsToTake;

	public float secondsTaken;

	public bool dropped;

	public Vector3 dropPosition = Vector3.zero;

	public override void ServerInit()
	{
		base.ServerInit();
		Initialize();
	}

	public override void PostServerLoad()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (dropPosition == Vector3.zero)
		{
			Initialize();
		}
	}

	private void Initialize()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (dropPosition == Vector3.zero)
		{
			dropPosition = RandomDropPosition();
		}
		UpdateDropPosition(dropPosition);
	}

	public void InitDropPosition(Vector3 newDropPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		dropPosition = newDropPosition;
		dropPosition.y = 0f;
	}

	public Vector3 RandomDropPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		float num = 100f;
		float x = TerrainMeta.Size.x;
		do
		{
			zero = Vector3Ex.Range(0f - x / 3f, x / 3f);
		}
		while (filter.GetFactor(zero) == 0f && (num -= 1f) > 0f);
		zero.y = 0f;
		return zero;
	}

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		((Vector3)(ref startPos)).Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= Random.Range(0.95f, 1.05f);
		((Component)this).transform.position = startPos;
		((Component)this).transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", (object)this, (object)newDropPosition);
	}

	private void Update()
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, ((Component)this).transform.position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", (object)baseEntity, (object)this);
			}
		}
		((Component)this).transform.position = Vector3.Lerp(startPos, endPos, num);
		((Component)this).transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (base.isServer && info.forDisk)
		{
			info.msg.cargoPlane = Pool.Get<CargoPlane>();
			info.msg.cargoPlane.startPos = startPos;
			info.msg.cargoPlane.endPos = endPos;
			info.msg.cargoPlane.secondsToTake = secondsToTake;
			info.msg.cargoPlane.secondsTaken = secondsTaken;
			info.msg.cargoPlane.dropped = dropped;
			info.msg.cargoPlane.dropPosition = dropPosition;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (base.isServer && info.fromDisk && info.msg.cargoPlane != null)
		{
			startPos = info.msg.cargoPlane.startPos;
			endPos = info.msg.cargoPlane.endPos;
			secondsToTake = info.msg.cargoPlane.secondsToTake;
			secondsTaken = info.msg.cargoPlane.secondsTaken;
			dropped = info.msg.cargoPlane.dropped;
			dropPosition = info.msg.cargoPlane.dropPosition;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RoadBradleys : TriggeredEvent
{
	private List<BradleyAPC> spawnedAPCs = new List<BradleyAPC>();

	public static int StaticBradleyCount;

	public int GetNumBradleys()
	{
		CleanList();
		return spawnedAPCs.Count;
	}

	public int GetDesiredNumber()
	{
		return Mathf.CeilToInt((float)World.Size / 1000f) * 2;
	}

	private void CleanList()
	{
		for (int num = spawnedAPCs.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)spawnedAPCs[num] == (Object)null)
			{
				spawnedAPCs.RemoveAt(num);
			}
		}
	}

	public override void RunEvent()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		int numBradleys = GetNumBradleys();
		int num = GetDesiredNumber() - numBradleys;
		if (num <= 0 || (Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.Roads.Count == 0)
		{
			return;
		}
		Debug.Log((object)"[event] assets/prefabs/npc/m2bradley/bradleyapc.prefab");
		Debug.Log((object)("Spawning :" + num + "Bradleys"));
		for (int i = 0; i < num; i++)
		{
			Vector3 zero = Vector3.zero;
			PathList pathList = TerrainMeta.Path.Roads[Random.Range(0, TerrainMeta.Path.Roads.Count)];
			zero = pathList.Path.Points[Random.Range(0, pathList.Path.Points.Length)];
			BradleyAPC bradleyAPC = BradleyAPC.SpawnRoadDrivingBradley(zero, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)bradleyAPC))
			{
				spawnedAPCs.Add(bradleyAPC);
				continue;
			}
			Vector3 val = zero;
			Debug.Log((object)("Failed to spawn bradley at: " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString()));
		}
		StaticBradleyCount = spawnedAPCs.Count;
	}

	public override void Kill()
	{
		base.Kill();
		foreach (BradleyAPC spawnedAPC in spawnedAPCs)
		{
			spawnedAPC.Kill();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class EventSchedule : BaseMonoBehaviour
{
	[Tooltip("The minimum amount of hours between events")]
	public float minimumHoursBetween = 12f;

	[Tooltip("The maximum amount of hours between events")]
	public float maxmumHoursBetween = 24f;

	[Tooltip("ID to reference this event via convars")]
	public string Key;

	public static HashSet<EventSchedule> allEvents = new HashSet<EventSchedule>();

	public static HashSet<EventSchedule> enabledEvents = new HashSet<EventSchedule>();

	public float hoursRemaining;

	public long lastRun;

	[ServerVar(Name = "triggerevent")]
	public static void TriggerEvent(Arg arg)
	{
		string eventName = arg.GetString(0, "");
		string[] source = enabledEvents.Select((EventSchedule x) => x.GetName().ToLower()).ToArray();
		string[] array = (from x in source
			where StringEx.Contains(x, eventName, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (string.IsNullOrEmpty(eventName) || array.Length == 0)
		{
			arg.ReplyWith("Unknown event - event list:\n\n" + string.Join("\n", source.Select(Path.GetFileNameWithoutExtension).ToArray()));
			return;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(x, eventName, StringComparison.OrdinalIgnoreCase) == 0);
			if (text != null)
			{
				array[0] = text;
			}
		}
		foreach (EventSchedule enabledEvent in enabledEvents)
		{
			if (enabledEvent.GetName() == array[0])
			{
				enabledEvent.Trigger();
				arg.ReplyWith("Triggered " + enabledEvent.GetName());
			}
		}
	}

	[ServerVar(Name = "killallevents")]
	public static void KillAllEvents()
	{
		foreach (EventSchedule enabledEvent in enabledEvents)
		{
			TriggeredEvent[] components = ((Component)enabledEvent).GetComponents<TriggeredEvent>();
			for (int i = 0; i < components.Length; i++)
			{
				components[i].Kill();
			}
		}
	}

	public string GetName()
	{
		return Path.GetFileNameWithoutExtension(((Object)this).name);
	}

	private void Awake()
	{
		allEvents.Add(this);
		Events.UpdateScheduleFromConVars(this);
	}

	private void OnDestroy()
	{
		allEvents.Remove(this);
	}

	private void OnEnable()
	{
		hoursRemaining = Random.Range(minimumHoursBetween, maxmumHoursBetween);
		((FacepunchBehaviour)this).InvokeRepeating((Action)RunSchedule, 1f, 1f);
		enabledEvents.Add(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			enabledEvents.Remove(this);
			((FacepunchBehaviour)this).CancelInvoke((Action)RunSchedule);
		}
	}

	public virtual void RunSchedule()
	{
		if (!Application.isLoading && ConVar.Server.events)
		{
			CountHours();
			if (!(hoursRemaining > 0f))
			{
				Trigger();
			}
		}
	}

	private void Trigger()
	{
		hoursRemaining = Random.Range(minimumHoursBetween, maxmumHoursBetween);
		TriggeredEvent[] components = ((Component)this).GetComponents<TriggeredEvent>();
		if (components.Length != 0)
		{
			TriggeredEvent triggeredEvent = components[Random.Range(0, components.Length)];
			if (!((Object)(object)triggeredEvent == (Object)null))
			{
				triggeredEvent.RunEvent();
			}
		}
	}

	private void CountHours()
	{
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			if (lastRun != 0L)
			{
				hoursRemaining -= (float)TOD_Sky.Instance.Cycle.DateTime.Subtract(DateTime.FromBinary(lastRun)).TotalSeconds / 60f / 60f;
			}
			lastRun = TOD_Sky.Instance.Cycle.DateTime.ToBinary();
		}
	}
}


using UnityEngine;

public class EventScheduleWipeOffset : EventSchedule
{
	[ServerVar(Name = "event_hours_before_wipe")]
	public static float hoursBeforeWipeRealtime = 24f;

	public override void RunSchedule()
	{
		if (!((Object)(object)WipeTimer.serverinstance == (Object)null) && !(WipeTimer.serverinstance.GetTimeSpanUntilWipe().TotalHours > (double)hoursBeforeWipeRealtime))
		{
			base.RunSchedule();
		}
	}
}


using UnityEngine;

public class TriggeredEvent : MonoBehaviour
{
	public virtual void RunEvent()
	{
	}

	public virtual void Kill()
	{
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class TriggeredEventPrefab : TriggeredEvent
{
	public GameObjectRef targetPrefab;

	public bool shouldBroadcastSpawn;

	public Phrase spawnPhrase;

	public BaseEntity spawnedEntity;

	public override void RunEvent()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEventTrigger", (object)this) != null)
		{
			return;
		}
		Debug.Log((object)("[event] " + targetPrefab.resourcePath));
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		((Component)baseEntity).SendMessage("TriggeredEventSpawn", (SendMessageOptions)1);
		baseEntity.Spawn();
		((Component)baseEntity).SendMessage("TriggeredEventPostSpawn", (SendMessageOptions)1);
		spawnedEntity = baseEntity;
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (Object.op_Implicit((Object)(object)current) && current.IsConnected && !current.IsInTutorial)
				{
					current.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public override void Kill()
	{
		if (!((Object)(object)spawnedEntity == (Object)null))
		{
			base.Kill();
			spawnedEntity.Kill();
			spawnedEntity = null;
			Debug.Log((object)("Killed " + ((Object)this).name));
		}
	}
}


using System;
using UnityEngine;

public class TravellingVendorEvent : TriggeredEvent
{
	public Phrase spawnPhrase;

	public static TravellingVendor currentVendor = null;

	public static float dontSpawnHoursBeforeWipe = 24f;

	public override void RunEvent()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentVendor != (Object)null || (Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.Roads.Count == 0 || !TravellingVendor.should_spawn || RoadBradleys.StaticBradleyCount > 0 || TerrainMeta.Path.MainRoads.Count == 0)
		{
			return;
		}
		TravellingVendor travellingVendor = TravellingVendor.SpawnTravellingVendorForEvent();
		if (Object.op_Implicit((Object)(object)travellingVendor))
		{
			Debug.Log((object)"[event] assets/prefabs/npc/travelling vendor/travellingvendor.prefab");
			currentVendor = travellingVendor;
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if (Object.op_Implicit((Object)(object)current) && current.IsConnected && !current.IsInTutorial)
					{
						current.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
					}
				}
				return;
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Debug.Log((object)"Failed to spawn travelling vendor.");
	}

	private bool HoursCheck()
	{
		if (WipeTimer.serverinstance.GetTimeSpanUntilWipe().TotalHours > (double)dontSpawnHoursBeforeWipe)
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Network;
using Facepunch.Network.Raknet;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Facepunch.Utility;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using Rust.UI;
using UnityEngine;
using UnityEngine.AI;

[ResetStaticFields]
public class Bootstrap : SingletonComponent<Bootstrap>
{
	internal static bool bootstrapInitRun;

	public static bool isErrored;

	public Phrase currentLoadingPhrase;

	public CanvasGroup BootstrapUiCanvas;

	public GameObject errorPanel;

	public RustText errorText;

	public RustText statusText;

	private Phrase openingBundles = new Phrase("bootstrap.openingbundles", "Opening Bundles");

	private static string lastWrittenValue;

	public static bool needsSetup => !bootstrapInitRun;

	public static bool isPresent
	{
		get
		{
			if (bootstrapInitRun)
			{
				return true;
			}
			if (Object.FindObjectsOfType<GameSetup>().Count() > 0)
			{
				return true;
			}
			return false;
		}
	}

	public static void RunDefaults()
	{
		Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
		Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;
		Application.targetFrameRate = 256;
		Time.fixedDeltaTime = 0.0625f;
		Time.maximumDeltaTime = 0.125f;
	}

	public static void Init_Tier0()
	{
		RunDefaults();
		GameSetup.RunOnce = true;
		bootstrapInitRun = true;
		Index.Initialize(ConsoleGen.All);
		Index.Reset();
		UnityButtons.Register();
		Output.Install();
		Pool.ResizeBuffer<NetRead>(16384);
		Pool.ResizeBuffer<NetWrite>(16384);
		Pool.ResizeBuffer<BufferStream>(32768);
		Pool.ResizeBuffer<Networkable>(65536);
		Pool.ResizeBuffer<EntityLink>(65536);
		Pool.ResizeBuffer<EventRecord>(16384);
		Pool.ResizeBuffer<SellOrder>(2048);
		Pool.ResizeBuffer<ListHashSet<BaseNetworkable>>(2048);
		Pool.FillBuffer<Networkable>();
		Pool.FillBuffer<EntityLink>();
		if (CommandLine.HasSwitch("-nonetworkthread"))
		{
			BaseNetwork.Multithreading = false;
		}
		SteamNetworking.SetDebugFunction();
		if (CommandLine.HasSwitch("-swnet"))
		{
			NetworkInitSteamworks(enableSteamDatagramRelay: false);
		}
		else if (CommandLine.HasSwitch("-sdrnet"))
		{
			NetworkInitSteamworks(enableSteamDatagramRelay: true);
		}
		else if (CommandLine.HasSwitch("-raknet"))
		{
			NetworkInitRaknet();
		}
		else
		{
			NetworkInitRaknet();
		}
		if (!Application.isEditor)
		{
			string text = CommandLine.Full.Replace(CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", "RCONPASSWORD")), "******");
			WriteToLog("Command Line: " + text);
		}
		Interface.Initialize();
		int parentProcessId = CommandLine.GetSwitchInt("-parent-pid", 0);
		if (parentProcessId != 0)
		{
			try
			{
				SynchronizationContext syncContext = SynchronizationContext.Current;
				Process processById = Process.GetProcessById(parentProcessId);
				processById.EnableRaisingEvents = true;
				processById.Exited += delegate
				{
					syncContext.Post(delegate
					{
						//IL_001a: Unknown result type (might be due to invalid IL or missing references)
						WriteToLog($"Parent process ID {parentProcessId} exited. Exiting the server now...");
						ConsoleSystem.Run(Option.Server, "quit", Array.Empty<object>());
					}, null);
				};
				WriteToLog($"Watching parent process ID {parentProcessId}...");
			}
			catch (ArgumentException)
			{
				WriteToLog($"Parent process ID {parentProcessId} has exited during boot! Exiting now...");
				Application.Quit();
			}
		}
		UnityHookHandler.EnsureCreated();
	}

	public static void Init_Systems()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Expected O, but got Unknown
		Global.Init();
		Translate.Init();
		Integration val = new Integration();
		val.OnManifestUpdated += CpuAffinity.Apply;
		Application.Initialize((BaseIntegration)val);
		Performance.GetMemoryUsage = () => SystemInfoEx.systemMemoryUsed;
	}

	public static void Init_Config()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		ConsoleNetwork.Init();
		ConsoleSystem.UpdateValuesFromCommandLine();
		ConsoleSystem.Run(Option.Server, "server.readcfg", Array.Empty<object>());
		ServerUsers.Load();
		if (string.IsNullOrEmpty(ConVar.Server.server_id))
		{
			ConVar.Server.server_id = Guid.NewGuid().ToString("N");
			ConsoleSystem.Run(Option.Server, "server.writecfg", Array.Empty<object>());
		}
		if (CommandLine.HasSwitch("-disable-server-occlusion"))
		{
			ServerOcclusion.OcclusionEnabled = false;
			ServerOcclusion.OcclusionIncludeRocks = false;
		}
		if (CommandLine.HasSwitch("-disable-server-occlusion-rocks"))
		{
			ServerOcclusion.OcclusionIncludeRocks = false;
		}
		if (CommandLine.HasSwitch("-enable-new-server-occlusion-groups"))
		{
			ServerOcclusion.DisableNewOcclusionGroups = false;
		}
		HttpManager.UpdateMaxConnections();
		if (!RuntimeProfiler.runtime_profiling_persist)
		{
			RuntimeProfiler.Disable();
		}
		if (!CommandLine.HasSwitch("-disableconsolelog"))
		{
			ConsoleSystem.loggingEnabled = true;
		}
		ConsoleSystem.IdentityDirectory = ConVar.Server.rootFolder;
	}

	public static void NetworkInitRaknet()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Expected O, but got Unknown
		Net.sv = (Server)new Server();
	}

	public static void NetworkInitSteamworks(bool enableSteamDatagramRelay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		Net.sv = (Server)new Server(enableSteamDatagramRelay);
	}

	private IEnumerator Start()
	{
		WriteToLog("Bootstrap Startup");
		EarlyInitialize();
		BenchmarkTimer.Enabled = CommandLine.Full.Contains("+autobench");
		Stopwatch timer = BenchmarkTimer.Get("bootstrap");
		timer?.Start();
		if (!Application.isEditor)
		{
			BuildInfo current = BuildInfo.Current;
			if ((current.Scm.Branch == null || !(current.Scm.Branch == "experimental/release")) && !(current.Scm.Branch == "release"))
			{
				ExceptionReporter.InitializeFromUrl("https://0654eb77d1e04d6babad83201b6b6b95:d2098f1d15834cae90501548bd5dbd0d@sentry.io/1836389");
			}
			else
			{
				ExceptionReporter.InitializeFromUrl("https://83df169465e84da091c1a3cd2fbffeee:3671b903f9a840ecb68411cf946ab9b6@sentry.io/51080");
			}
			bool num = CommandLine.Full.Contains("-official") || CommandLine.Full.Contains("-server.official") || CommandLine.Full.Contains("+official") || CommandLine.Full.Contains("+server.official");
			bool flag = CommandLine.Full.Contains("-stats") || CommandLine.Full.Contains("-server.stats") || CommandLine.Full.Contains("+stats") || CommandLine.Full.Contains("+server.stats");
			ExceptionReporter.Disabled = !(num && flag);
		}
		Scope val;
		Scope val2;
		if (AssetBundleBackend.Enabled)
		{
			AssetBundleBackend newBackend = new AssetBundleBackend();
			val = BenchmarkTimer.Measure("bootstrap;bundles");
			try
			{
				yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(openingBundles));
				newBackend.Load("Bundles/Bundles");
				FileSystem.Backend = (FileSystemBackend)(object)newBackend;
			}
			finally
			{
				((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
			}
			val = default(Scope);
			if (FileSystem.Backend.isError)
			{
				ThrowError(FileSystem.Backend.loadingError);
				yield break;
			}
			val2 = BenchmarkTimer.Measure("bootstrap;bundlesindex");
			try
			{
				newBackend.BuildFileIndex();
			}
			finally
			{
				((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
			}
			while (true)
			{
				if (FileSystem.Backend.isError)
				{
					ThrowError(FileSystem.Backend.loadingError);
					yield break;
				}
				float assetSceneProgress = newBackend.GetAssetSceneProgress("AssetScene-bootstrap");
				if (assetSceneProgress >= 1f)
				{
					break;
				}
				yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit($"Loading Menu Prefabs {assetSceneProgress * 100f:0.0}%")));
			}
		}
		if (FileSystem.Backend.isError)
		{
			ThrowError(FileSystem.Backend.loadingError);
			yield break;
		}
		if (!Application.isEditor)
		{
			WriteToLog(SystemInfoGeneralText.currentInfo);
		}
		Texture.SetGlobalAnisotropicFilteringLimits(1, 16);
		if (isErrored)
		{
			yield break;
		}
		val = BenchmarkTimer.Measure("bootstrap;gamemanifest");
		try
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Loading Game Manifest")));
			GameManifest.Load();
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("DONE!")));
		}
		finally
		{
			((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
		}
		val = default(Scope);
		val = BenchmarkTimer.Measure("bootstrap;selfcheck");
		try
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Running Self Check")));
			SelfCheck.Run();
		}
		finally
		{
			((IDisposable)(Scope)(ref val)/*cast due to .constrained prefix*/).Dispose();
		}
		val = default(Scope);
		if (isErrored)
		{
			yield break;
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Tier0")));
		val2 = BenchmarkTimer.Measure("bootstrap;tier0");
		try
		{
			Init_Tier0();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		val2 = BenchmarkTimer.Measure("bootstrap;commandlinevalues");
		try
		{
			ConsoleSystem.UpdateValuesFromCommandLine();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Systems")));
		val2 = BenchmarkTimer.Measure("bootstrap;init_systems");
		try
		{
			Init_Systems();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Bootstrap Config")));
		val2 = BenchmarkTimer.Measure("bootstrap;init_config");
		try
		{
			Init_Config();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		val2 = BenchmarkTimer.Measure("bootstrap;commandlinevalues2");
		try
		{
			ConsoleSystem.UpdateValuesFromCommandLine();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		if (!isErrored)
		{
			yield return ((MonoBehaviour)this).StartCoroutine(LoadingUpdate(Phrase.op_Implicit("Loading Items")));
			val2 = BenchmarkTimer.Measure("bootstrap;itemmanager");
			try
			{
				ItemManager.Initialize();
			}
			finally
			{
				((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
			}
			if (!isErrored)
			{
				yield return ((MonoBehaviour)this).StartCoroutine(DedicatedServerStartup());
				timer?.Stop();
				GameManager.Destroy(((Component)this).gameObject);
			}
		}
	}

	private IEnumerator DedicatedServerStartup()
	{
		Application.isLoading = true;
		Application.backgroundLoadingPriority = (ThreadPriority)4;
		WriteToLog("Skinnable Warmup");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		GameManifest.LoadAssets();
		WriteToLog("Initializing Nexus");
		yield return ((MonoBehaviour)this).StartCoroutine(StartNexusServer());
		WriteToLog("Loading Scene");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		Physics.defaultSolverIterations = 3;
		int @int = PlayerPrefs.GetInt("UnityGraphicsQuality");
		QualitySettings.SetQualityLevel(0);
		PlayerPrefs.SetInt("UnityGraphicsQuality", @int);
		Object.DontDestroyOnLoad((Object)(object)((Component)this).gameObject);
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server_console.prefab"));
		StartupShared();
		World.InitSize(ConVar.Server.worldsize);
		World.InitSeed(ConVar.Server.seed);
		World.InitSalt(ConVar.Server.salt);
		World.Url = ConVar.Server.levelurl;
		World.Transfer = ConVar.Server.leveltransfer;
		yield return LevelManager.LoadLevelAsync(ConVar.Server.level);
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return ((MonoBehaviour)this).StartCoroutine(FileSystem_Warmup.Run(WriteToLog, "Asset Warmup ({0}/{1})"));
		yield return ((MonoBehaviour)this).StartCoroutine(StartServer(!CommandLine.HasSwitch("-skipload"), "", allowOutOfDateSaves: false));
		if (!Object.op_Implicit((Object)(object)Object.FindObjectOfType<Performance>()))
		{
			Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/performance.prefab"));
		}
		Rust.GC.Collect();
		Application.isLoading = false;
	}

	private static void EnsureRootFolderCreated()
	{
		try
		{
			Directory.CreateDirectory(ConVar.Server.rootFolder);
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Failed to automatically create the save directory: {ConVar.Server.rootFolder}\n\n{arg}");
		}
	}

	public static IEnumerator StartNexusServer()
	{
		EnsureRootFolderCreated();
		yield return NexusServer.Initialize();
		if (NexusServer.FailedToStart)
		{
			Debug.LogError((object)"Nexus server failed to start, terminating");
			Application.Quit();
		}
	}

	public static IEnumerator StartServer(bool doLoad, string saveFileOverride, bool allowOutOfDateSaves)
	{
		float timeScale = Time.timeScale;
		if (ConVar.Time.pausewhileloading)
		{
			Time.timeScale = 0f;
		}
		RCon.Initialize();
		BaseEntity.Query.Server = new BaseEntity.Query.EntityTree(8096f);
		EnsureRootFolderCreated();
		if (Object.op_Implicit((Object)(object)SingletonComponent<WorldSetup>.Instance))
		{
			yield return ((MonoBehaviour)SingletonComponent<WorldSetup>.Instance).StartCoroutine(SingletonComponent<WorldSetup>.Instance.InitCoroutine());
		}
		if (Object.op_Implicit((Object)(object)SingletonComponent<DynamicNavMesh>.Instance) && ((Behaviour)SingletonComponent<DynamicNavMesh>.Instance).enabled && !AiManager.nav_disable)
		{
			yield return ((MonoBehaviour)SingletonComponent<DynamicNavMesh>.Instance).StartCoroutine(SingletonComponent<DynamicNavMesh>.Instance.UpdateNavMeshAndWait());
		}
		if (Object.op_Implicit((Object)(object)SingletonComponent<AiManager>.Instance) && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled)
		{
			SingletonComponent<AiManager>.Instance.Initialize();
			if (!AiManager.nav_disable && AI.npc_enable && (Object)(object)TerrainMeta.Path != (Object)null)
			{
				foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
				{
					if (monument.HasNavmesh)
					{
						yield return ((MonoBehaviour)monument).StartCoroutine(monument.GetMonumentNavMesh().UpdateNavMeshAndWait());
					}
				}
				if (Object.op_Implicit((Object)(object)TerrainMeta.Path) && World.SpawnedPrefabs.TryGetValue("Dungeon", out var value))
				{
					DungeonNavmesh dungeonNavmesh = new GameObject("DungeonGridNavMesh").AddComponent<DungeonNavmesh>();
					dungeonNavmesh.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
					dungeonNavmesh.LayerMask = LayerMask.op_Implicit(65537);
					yield return ((MonoBehaviour)dungeonNavmesh).StartCoroutine(dungeonNavmesh.UpdateNavMeshAndWait(value));
				}
				else
				{
					Debug.LogWarning((object)"Failed to find DungeonGridRoot, NOT generating Dungeon navmesh");
				}
				if (Object.op_Implicit((Object)(object)TerrainMeta.Path) && World.SpawnedPrefabs.TryGetValue("DungeonBase", out var value2))
				{
					DungeonNavmesh dungeonNavmesh2 = new GameObject("DungeonBaseNavMesh").AddComponent<DungeonNavmesh>();
					dungeonNavmesh2.NavmeshResolutionModifier = 0.3f;
					dungeonNavmesh2.NavMeshCollectGeometry = (NavMeshCollectGeometry)1;
					dungeonNavmesh2.LayerMask = LayerMask.op_Implicit(65537);
					yield return ((MonoBehaviour)dungeonNavmesh2).StartCoroutine(dungeonNavmesh2.UpdateNavMeshAndWait(value2));
				}
				else
				{
					Debug.LogWarning((object)"Failed to find DungeonBaseRoot , NOT generating Dungeon navmesh");
				}
				GenerateDungeonBase.SetupAI();
			}
		}
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/shared.prefab"));
		GameObject val = GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server.prefab");
		Object.DontDestroyOnLoad((Object)(object)val);
		ServerMgr serverMgr = val.GetComponent<ServerMgr>();
		bool saveWasLoaded = serverMgr.Initialize(doLoad, saveFileOverride, allowOutOfDateSaves);
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntityLinks();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntitySupports();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.InitializeEntityConditionals();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		SaveRestore.GetSaveCache();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		BaseGameMode.CreateGameMode();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		MissionManifest.Get();
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (Clan.enabled)
		{
			ClanManager clanManager = ClanManager.ServerInstance;
			if ((Object)(object)clanManager == (Object)null)
			{
				Debug.LogError((object)"ClanManager was not spawned!");
				Application.Quit();
				yield break;
			}
			Task initializeTask = clanManager.Initialize();
			yield return (object)new WaitUntil((Func<bool>)(() => initializeTask.IsCompleted));
			initializeTask.Wait();
			clanManager.LoadClanInfoForSleepers();
		}
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (ServerOcclusion.OcclusionEnabled)
		{
			ServerOcclusion.SetupGrid();
		}
		yield return CoroutineEx.waitForSecondsRealtime(0.1f);
		if (NexusServer.Started)
		{
			NexusServer.UploadMapImage();
			if (saveWasLoaded)
			{
				NexusServer.RestoreUnsavedState();
			}
			NexusServer.ZoneClient.StartListening();
		}
		if (ConVar.Server.autoUploadMap)
		{
			Task uploadTask = MapUploader.UploadMap();
			while (!uploadTask.IsCompleted)
			{
				yield return null;
			}
			if (!uploadTask.IsCompletedSuccessfully)
			{
				Debug.LogError((object)"Failed to upload map file:");
				Debug.LogException((Exception)uploadTask.Exception);
			}
		}
		serverMgr.OpenConnection();
		CompanionServer.Server.Initialize();
		if (ConVar.Server.autoUploadMapImages && Map.ImageData != null)
		{
			MapUploader.UploadMapImage(Map.ImageData);
		}
		Scope val2 = BenchmarkTimer.Measure("Boombox.LoadStations");
		try
		{
			BoomBox.LoadStations();
		}
		finally
		{
			((IDisposable)(Scope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
		RustEmojiLibrary.FindAllServerEmoji();
		if (ConVar.Time.pausewhileloading)
		{
			Time.timeScale = timeScale;
		}
		WriteToLog("Server startup complete");
		Application.isServerStarted = true;
	}

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

	public bool RetrySteam()
	{
		if (!CommandLine.HasSwitch("-nosteam"))
		{
			return !PlatformService.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		}
		return true;
	}

	public void ThrowError(string error)
	{
		isErrored = true;
	}

	public void ClearError()
	{
		isErrored = false;
	}

	public void ThrowSteamError()
	{
		isErrored = true;
	}

	public void ExitGame()
	{
		Debug.Log((object)"Exiting due to Exit Game button on bootstrap error panel");
		Application.Quit();
	}

	public static IEnumerator LoadingUpdate(Phrase phrase)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Bootstrap>.Instance))
		{
			SingletonComponent<Bootstrap>.Instance.currentLoadingPhrase = phrase;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
		}
	}

	public static void WriteToLog(string str)
	{
		if (!(lastWrittenValue == str))
		{
			DebugEx.Log((object)str, (StackTraceLogType)0);
			lastWrittenValue = str;
		}
	}

	private static void EarlyInitialize()
	{
	}
}


using System;
using System.Runtime.InteropServices;
using Facepunch;
using UnityEngine;

public static class SelfCheck
{
	public static bool Run()
	{
		if (FileSystem.Backend.isError)
		{
			return Failed("Asset Bundle Error: " + FileSystem.Backend.loadingError);
		}
		if ((Object)(object)FileSystem.Load<GameManifest>("Assets/manifest.asset", true) == (Object)null)
		{
			return Failed("Couldn't load game manifest - verify your game content!");
		}
		if (!TestRustNative())
		{
			return false;
		}
		if (CommandLine.HasSwitch("-force-feature-level-9-3"))
		{
			return Failed("Invalid command line argument: -force-feature-level-9-3");
		}
		if (CommandLine.HasSwitch("-force-feature-level-10-0"))
		{
			return Failed("Invalid command line argument: -force-feature-level-10-0");
		}
		if (CommandLine.HasSwitch("-force-feature-level-10-1"))
		{
			return Failed("Invalid command line argument: -force-feature-level-10-1");
		}
		return true;
	}

	private static bool Failed(string Message)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Bootstrap>.Instance))
		{
			SingletonComponent<Bootstrap>.Instance.currentLoadingPhrase = null;
			SingletonComponent<Bootstrap>.Instance.ThrowError(Message);
		}
		Debug.LogError((object)("SelfCheck Failed: " + Message));
		return false;
	}

	private static bool TestRustNative()
	{
		try
		{
			if (!RustNative_VersionCheck(5))
			{
				return Failed("RustNative is wrong version!");
			}
		}
		catch (DllNotFoundException ex)
		{
			return Failed("RustNative library couldn't load! " + ex.Message);
		}
		return true;
	}

	[DllImport("RustNative")]
	private static extern bool RustNative_VersionCheck(int version);
}


using UnityEngine;

public class BuildingBlockedGuide : MonoBehaviour
{
	public Mesh BoxMesh;

	public Mesh SphereMesh;

	public Mesh CapsuleMesh;

	public MeshRenderer Renderer;

	public MeshFilter Filter;

	public Collider LargestVolume;

	public float OverrideEnableDistance;
}


using ConVar;
using Development.Attributes;
using UnityEngine;
using UnityEngine.AI;

[ResetStaticFields]
public abstract class BuildingManager
{
	public class Building
	{
		public uint ID;

		public ListHashSet<BuildingPrivlidge> buildingPrivileges = new ListHashSet<BuildingPrivlidge>();

		public ListHashSet<BuildingBlock> buildingBlocks = new ListHashSet<BuildingBlock>();

		public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

		public ListHashSet<Door> doors = new ListHashSet<Door>();

		public NavMeshObstacle buildingNavMeshObstacle;

		public ListHashSet<NavMeshObstacle> navmeshCarvers;

		public bool isNavMeshCarvingDirty;

		public bool isNavMeshCarveOptimized;

		public bool IsEmpty()
		{
			if (HasBuildingPrivileges())
			{
				return false;
			}
			if (HasBuildingBlocks())
			{
				return false;
			}
			if (HasDecayEntities())
			{
				return false;
			}
			return true;
		}

		public BuildingPrivlidge GetDominatingBuildingPrivilege()
		{
			BuildingPrivlidge buildingPrivlidge = null;
			if (HasBuildingPrivileges())
			{
				for (int i = 0; i < buildingPrivileges.Count; i++)
				{
					BuildingPrivlidge buildingPrivlidge2 = buildingPrivileges[i];
					if (!((Object)(object)buildingPrivlidge2 == (Object)null) && buildingPrivlidge2.IsOlderThan(buildingPrivlidge))
					{
						buildingPrivlidge = buildingPrivlidge2;
					}
				}
			}
			return buildingPrivlidge;
		}

		public bool HasBuildingPrivileges()
		{
			if (buildingPrivileges != null)
			{
				return buildingPrivileges.Count > 0;
			}
			return false;
		}

		public bool HasBuildingBlocks()
		{
			if (buildingBlocks != null)
			{
				return buildingBlocks.Count > 0;
			}
			return false;
		}

		public bool HasDecayEntities()
		{
			if (decayEntities != null)
			{
				return decayEntities.Count > 0;
			}
			return false;
		}

		public void AddBuildingPrivilege(BuildingPrivlidge ent)
		{
			if (!((Object)(object)ent == (Object)null) && !buildingPrivileges.Contains(ent))
			{
				buildingPrivileges.Add(ent);
			}
		}

		public void RemoveBuildingPrivilege(BuildingPrivlidge ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				buildingPrivileges.Remove(ent);
			}
		}

		public void AddBuildingBlock(BuildingBlock ent)
		{
			if ((Object)(object)ent == (Object)null || buildingBlocks.Contains(ent))
			{
				return;
			}
			buildingBlocks.Add(ent);
			if (!AI.nav_carve_use_building_optimization)
			{
				return;
			}
			NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
			if ((Object)(object)component != (Object)null)
			{
				isNavMeshCarvingDirty = true;
				if (navmeshCarvers == null)
				{
					navmeshCarvers = new ListHashSet<NavMeshObstacle>();
				}
				navmeshCarvers.Add(component);
			}
		}

		public void RemoveBuildingBlock(BuildingBlock ent)
		{
			if ((Object)(object)ent == (Object)null)
			{
				return;
			}
			buildingBlocks.Remove(ent);
			if (!AI.nav_carve_use_building_optimization || navmeshCarvers == null)
			{
				return;
			}
			NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
			if (!((Object)(object)component != (Object)null))
			{
				return;
			}
			navmeshCarvers.Remove(component);
			if (navmeshCarvers.Count == 0)
			{
				navmeshCarvers = null;
			}
			isNavMeshCarvingDirty = true;
			if (navmeshCarvers == null)
			{
				Building building = ent.GetBuilding();
				if (building != null)
				{
					int ticks = 2;
					server.UpdateNavMeshCarver(building, ref ticks, 0);
				}
			}
		}

		public void AddDecayEntity(DecayEntity ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				if (!decayEntities.Contains(ent))
				{
					decayEntities.Add(ent);
				}
				if (ent is Door door && !doors.Contains(door))
				{
					doors.Add(ent as Door);
				}
			}
		}

		public void RemoveDecayEntity(DecayEntity ent)
		{
			if (!((Object)(object)ent == (Object)null))
			{
				decayEntities.Remove(ent);
				if (ent is Door door)
				{
					doors.Remove(door);
				}
			}
		}

		public void Add(DecayEntity ent)
		{
			AddDecayEntity(ent);
			AddBuildingBlock(ent as BuildingBlock);
			AddBuildingPrivilege(ent as BuildingPrivlidge);
		}

		public void Remove(DecayEntity ent)
		{
			RemoveDecayEntity(ent);
			RemoveBuildingBlock(ent as BuildingBlock);
			RemoveBuildingPrivilege(ent as BuildingPrivlidge);
		}

		public void Dirty()
		{
			BuildingPrivlidge dominatingBuildingPrivilege = GetDominatingBuildingPrivilege();
			if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
			{
				dominatingBuildingPrivilege.BuildingDirty();
			}
		}
	}

	public static ServerBuildingManager server = new ServerBuildingManager();

	public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

	public ListDictionary<uint, Building> buildingDictionary = new ListDictionary<uint, Building>();

	public Building GetBuilding(uint buildingID)
	{
		Building result = null;
		buildingDictionary.TryGetValue(buildingID, ref result);
		return result;
	}

	public void Add(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			if (!decayEntities.Contains(ent))
			{
				decayEntities.Add(ent);
			}
			return;
		}
		Building building = GetBuilding(ent.buildingID);
		if (building == null)
		{
			building = CreateBuilding(ent.buildingID);
			buildingDictionary.Add(ent.buildingID, building);
		}
		building.Add(ent);
		building.Dirty();
	}

	public void Remove(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			decayEntities.Remove(ent);
			return;
		}
		Building building = GetBuilding(ent.buildingID);
		if (building != null)
		{
			building.Remove(ent);
			if (building.IsEmpty())
			{
				buildingDictionary.Remove(ent.buildingID);
				DisposeBuilding(ref building);
			}
			else
			{
				building.Dirty();
			}
		}
	}

	public void Clear()
	{
		buildingDictionary.Clear();
	}

	protected abstract Building CreateBuilding(uint id);

	protected abstract void DisposeBuilding(ref Building building);
}


using ConVar;
using UnityEngine;
using UnityEngine.AI;

public class Building
{
	public uint ID;

	public ListHashSet<BuildingPrivlidge> buildingPrivileges = new ListHashSet<BuildingPrivlidge>();

	public ListHashSet<BuildingBlock> buildingBlocks = new ListHashSet<BuildingBlock>();

	public ListHashSet<DecayEntity> decayEntities = new ListHashSet<DecayEntity>();

	public ListHashSet<Door> doors = new ListHashSet<Door>();

	public NavMeshObstacle buildingNavMeshObstacle;

	public ListHashSet<NavMeshObstacle> navmeshCarvers;

	public bool isNavMeshCarvingDirty;

	public bool isNavMeshCarveOptimized;

	public bool IsEmpty()
	{
		if (HasBuildingPrivileges())
		{
			return false;
		}
		if (HasBuildingBlocks())
		{
			return false;
		}
		if (HasDecayEntities())
		{
			return false;
		}
		return true;
	}

	public BuildingPrivlidge GetDominatingBuildingPrivilege()
	{
		BuildingPrivlidge buildingPrivlidge = null;
		if (HasBuildingPrivileges())
		{
			for (int i = 0; i < buildingPrivileges.Count; i++)
			{
				BuildingPrivlidge buildingPrivlidge2 = buildingPrivileges[i];
				if (!((Object)(object)buildingPrivlidge2 == (Object)null) && buildingPrivlidge2.IsOlderThan(buildingPrivlidge))
				{
					buildingPrivlidge = buildingPrivlidge2;
				}
			}
		}
		return buildingPrivlidge;
	}

	public bool HasBuildingPrivileges()
	{
		if (buildingPrivileges != null)
		{
			return buildingPrivileges.Count > 0;
		}
		return false;
	}

	public bool HasBuildingBlocks()
	{
		if (buildingBlocks != null)
		{
			return buildingBlocks.Count > 0;
		}
		return false;
	}

	public bool HasDecayEntities()
	{
		if (decayEntities != null)
		{
			return decayEntities.Count > 0;
		}
		return false;
	}

	public void AddBuildingPrivilege(BuildingPrivlidge ent)
	{
		if (!((Object)(object)ent == (Object)null) && !buildingPrivileges.Contains(ent))
		{
			buildingPrivileges.Add(ent);
		}
	}

	public void RemoveBuildingPrivilege(BuildingPrivlidge ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			buildingPrivileges.Remove(ent);
		}
	}

	public void AddBuildingBlock(BuildingBlock ent)
	{
		if ((Object)(object)ent == (Object)null || buildingBlocks.Contains(ent))
		{
			return;
		}
		buildingBlocks.Add(ent);
		if (!AI.nav_carve_use_building_optimization)
		{
			return;
		}
		NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
		if ((Object)(object)component != (Object)null)
		{
			isNavMeshCarvingDirty = true;
			if (navmeshCarvers == null)
			{
				navmeshCarvers = new ListHashSet<NavMeshObstacle>();
			}
			navmeshCarvers.Add(component);
		}
	}

	public void RemoveBuildingBlock(BuildingBlock ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		buildingBlocks.Remove(ent);
		if (!AI.nav_carve_use_building_optimization || navmeshCarvers == null)
		{
			return;
		}
		NavMeshObstacle component = ((Component)ent).GetComponent<NavMeshObstacle>();
		if (!((Object)(object)component != (Object)null))
		{
			return;
		}
		navmeshCarvers.Remove(component);
		if (navmeshCarvers.Count == 0)
		{
			navmeshCarvers = null;
		}
		isNavMeshCarvingDirty = true;
		if (navmeshCarvers == null)
		{
			Building building = ent.GetBuilding();
			if (building != null)
			{
				int ticks = 2;
				server.UpdateNavMeshCarver(building, ref ticks, 0);
			}
		}
	}

	public void AddDecayEntity(DecayEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (!decayEntities.Contains(ent))
			{
				decayEntities.Add(ent);
			}
			if (ent is Door door && !doors.Contains(door))
			{
				doors.Add(ent as Door);
			}
		}
	}

	public void RemoveDecayEntity(DecayEntity ent)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			decayEntities.Remove(ent);
			if (ent is Door door)
			{
				doors.Remove(door);
			}
		}
	}

	public void Add(DecayEntity ent)
	{
		AddDecayEntity(ent);
		AddBuildingBlock(ent as BuildingBlock);
		AddBuildingPrivilege(ent as BuildingPrivlidge);
	}

	public void Remove(DecayEntity ent)
	{
		RemoveDecayEntity(ent);
		RemoveBuildingBlock(ent as BuildingBlock);
		RemoveBuildingPrivilege(ent as BuildingPrivlidge);
	}

	public void Dirty()
	{
		BuildingPrivlidge dominatingBuildingPrivilege = GetDominatingBuildingPrivilege();
		if ((Object)(object)dominatingBuildingPrivilege != (Object)null)
		{
			dominatingBuildingPrivilege.BuildingDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using UnityEngine;
using UnityEngine.AI;

public class ServerBuildingManager : BuildingManager
{
	private int decayTickBuildingIndex;

	private int decayTickEntityIndex;

	private int decayTickWorldIndex;

	private int navmeshCarveTickBuildingIndex;

	private uint maxBuildingID;

	public void CheckSplit(DecayEntity ent)
	{
		if (ent.buildingID != 0)
		{
			Building building = ent.GetBuilding();
			if (building != null && ShouldSplit(building))
			{
				Split(building);
			}
		}
	}

	private bool ShouldSplit(Building building)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (building.HasBuildingBlocks())
		{
			building.buildingBlocks[0].EntityLinkBroadcast();
			Enumerator<BuildingBlock> enumerator = building.buildingBlocks.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (!enumerator.Current.ReceivedEntityLinkBroadcast())
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		return false;
	}

	private void Split(Building oldBuilding)
	{
		List<Building> list = Pool.Get<List<Building>>();
		Building largestSplit = null;
		while (oldBuilding.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = oldBuilding.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", (object)oldBuilding, (object)newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
			Building building = BuildingManager.server.GetBuilding(newID);
			if (building != null)
			{
				list.Add(building);
			}
		}
		int num = 0;
		foreach (Building item in list)
		{
			if (item.buildingBlocks.Count > num)
			{
				num = item.buildingBlocks.Count;
				largestSplit = item;
			}
		}
		SplitEntities<BuildingPrivlidge>(oldBuilding.buildingPrivileges, largestSplit);
		SplitEntities<DecayEntity>(oldBuilding.decayEntities, largestSplit);
		if (AI.nav_carve_use_building_optimization)
		{
			oldBuilding.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(oldBuilding, ref ticks, 0);
		}
		Pool.FreeUnmanaged<Building>(ref list);
	}

	private static void SplitEntities<T>(ListHashSet<T> input, Building largestSplit) where T : DecayEntity
	{
		List<T> list = Pool.Get<List<T>>();
		list.AddRange((IEnumerable<T>)input);
		foreach (T item in list)
		{
			BuildingBlock nearbyBuildingBlock = item.GetNearbyBuildingBlock();
			uint num = ((item is ContainerCorpse || item.GetParentEntity() is ContainerCorpse) ? largestSplit.ID : 0u);
			item.AttachToBuilding(Object.op_Implicit((Object)(object)nearbyBuildingBlock) ? nearbyBuildingBlock.buildingID : num);
		}
		Pool.FreeUnmanaged<T>(ref list);
	}

	public void CheckMerge(DecayEntity ent)
	{
		if (ent.buildingID == 0)
		{
			return;
		}
		Building building = ent.GetBuilding();
		if (building == null)
		{
			return;
		}
		ent.EntityLinkMessage(delegate(BuildingBlock b)
		{
			if (b.buildingID != building.ID)
			{
				Building building2 = b.GetBuilding();
				if (building2 != null)
				{
					Merge(building, building2);
				}
			}
		});
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", (object)this, (object)building1, (object)building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

	public void Cycle()
	{
		TimeWarning val = TimeWarning.New("StabilityCheckQueue", 0);
		try
		{
			((ObjectWorkQueue<StabilityEntity>)StabilityEntity.stabilityCheckQueue).RunQueue((double)Stability.stabilityqueue);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("UpdateSurroundingsQueue", 0);
		try
		{
			((ObjectWorkQueue<Bounds>)StabilityEntity.updateSurroundingsQueue).RunQueue((double)Stability.surroundingsqueue);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("UpdateSkinQueue", 0);
		try
		{
			((ObjectWorkQueue<BuildingBlock>)BuildingBlock.updateSkinQueueServer).RunQueue(1.0);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("BuildingDecayTick", 0);
		try
		{
			int num = 5;
			BufferList<Building> values = buildingDictionary.Values;
			for (int i = decayTickBuildingIndex; i < values.Count; i++)
			{
				if (num <= 0)
				{
					break;
				}
				BufferList<DecayEntity> values2 = values[i].decayEntities.Values;
				for (int j = decayTickEntityIndex; j < values2.Count; j++)
				{
					if (num <= 0)
					{
						break;
					}
					values2[j].DecayTick();
					num--;
					if (num <= 0)
					{
						decayTickBuildingIndex = i;
						decayTickEntityIndex = j;
					}
				}
				if (num > 0)
				{
					decayTickEntityIndex = 0;
				}
			}
			if (num > 0)
			{
				decayTickBuildingIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("WorldDecayTick", 0);
		try
		{
			int num2 = 5;
			BufferList<DecayEntity> values3 = decayEntities.Values;
			for (int k = decayTickWorldIndex; k < values3.Count; k++)
			{
				if (num2 <= 0)
				{
					break;
				}
				values3[k].DecayTick();
				num2--;
				if (num2 <= 0)
				{
					decayTickWorldIndex = k;
				}
			}
			if (num2 > 0)
			{
				decayTickWorldIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (!AI.nav_carve_use_building_optimization)
		{
			return;
		}
		val = TimeWarning.New("NavMeshCarving", 0);
		try
		{
			int ticks = 5;
			BufferList<Building> values4 = buildingDictionary.Values;
			for (int l = navmeshCarveTickBuildingIndex; l < values4.Count; l++)
			{
				if (ticks <= 0)
				{
					break;
				}
				Building building = values4[l];
				UpdateNavMeshCarver(building, ref ticks, l);
			}
			if (ticks > 0)
			{
				navmeshCarveTickBuildingIndex = 0;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void UpdateNavMeshCarver(Building building, ref int ticks, int i)
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.nav_carve_use_building_optimization || (!building.isNavMeshCarveOptimized && building.navmeshCarvers.Count < AI.nav_carve_min_building_blocks_to_apply_optimization) || !building.isNavMeshCarvingDirty)
		{
			return;
		}
		building.isNavMeshCarvingDirty = false;
		if (building.navmeshCarvers == null)
		{
			if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
			{
				Object.Destroy((Object)(object)((Component)building.buildingNavMeshObstacle).gameObject);
				building.buildingNavMeshObstacle = null;
				building.isNavMeshCarveOptimized = false;
			}
			return;
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)World.Size, (float)World.Size, (float)World.Size);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor((float)(0L - (long)World.Size), (float)(0L - (long)World.Size), (float)(0L - (long)World.Size));
		int count = building.navmeshCarvers.Count;
		if (count > 0)
		{
			for (int j = 0; j < count; j++)
			{
				NavMeshObstacle val3 = building.navmeshCarvers[j];
				if (((Behaviour)val3).enabled)
				{
					((Behaviour)val3).enabled = false;
				}
				for (int k = 0; k < 3; k++)
				{
					Vector3 position = ((Component)val3).transform.position;
					if (((Vector3)(ref position))[k] < ((Vector3)(ref val))[k])
					{
						int num = k;
						position = ((Component)val3).transform.position;
						((Vector3)(ref val))[num] = ((Vector3)(ref position))[k];
					}
					position = ((Component)val3).transform.position;
					if (((Vector3)(ref position))[k] > ((Vector3)(ref val2))[k])
					{
						int num2 = k;
						position = ((Component)val3).transform.position;
						((Vector3)(ref val2))[num2] = ((Vector3)(ref position))[k];
					}
				}
			}
			Vector3 val4 = (val2 + val) * 0.5f;
			Vector3 zero = Vector3.zero;
			float num3 = Mathf.Abs(val4.x - val.x);
			float num4 = Mathf.Abs(val4.y - val.y);
			float num5 = Mathf.Abs(val4.z - val.z);
			float num6 = Mathf.Abs(val2.x - val4.x);
			float num7 = Mathf.Abs(val2.y - val4.y);
			float num8 = Mathf.Abs(val2.z - val4.z);
			zero.x = Mathf.Max((num3 > num6) ? num3 : num6, AI.nav_carve_min_base_size);
			zero.y = Mathf.Max((num4 > num7) ? num4 : num7, AI.nav_carve_min_base_size);
			zero.z = Mathf.Max((num5 > num8) ? num5 : num8, AI.nav_carve_min_base_size);
			zero = ((count >= 10) ? (zero * (AI.nav_carve_size_multiplier - 1f)) : (zero * AI.nav_carve_size_multiplier));
			if (building.navmeshCarvers.Count > 0)
			{
				if ((Object)(object)building.buildingNavMeshObstacle == (Object)null)
				{
					building.buildingNavMeshObstacle = new GameObject($"Building ({building.ID}) NavMesh Carver").AddComponent<NavMeshObstacle>();
					((Behaviour)building.buildingNavMeshObstacle).enabled = false;
					building.buildingNavMeshObstacle.carving = true;
					building.buildingNavMeshObstacle.shape = (NavMeshObstacleShape)1;
					building.buildingNavMeshObstacle.height = AI.nav_carve_height;
					building.isNavMeshCarveOptimized = true;
				}
				if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
				{
					((Component)building.buildingNavMeshObstacle).transform.position = val4;
					building.buildingNavMeshObstacle.size = zero;
					if (!((Behaviour)building.buildingNavMeshObstacle).enabled)
					{
						((Behaviour)building.buildingNavMeshObstacle).enabled = true;
					}
				}
			}
		}
		else if ((Object)(object)building.buildingNavMeshObstacle != (Object)null)
		{
			Object.Destroy((Object)(object)((Component)building.buildingNavMeshObstacle).gameObject);
			building.buildingNavMeshObstacle = null;
			building.isNavMeshCarveOptimized = false;
		}
		ticks--;
		if (ticks <= 0)
		{
			navmeshCarveTickBuildingIndex = i;
		}
	}

	public uint NewBuildingID()
	{
		return ++maxBuildingID;
	}

	public void LoadBuildingID(uint id)
	{
		maxBuildingID = Mathx.Max(maxBuildingID, id);
	}

	protected override Building CreateBuilding(uint id)
	{
		return new Building
		{
			ID = id
		};
	}

	protected override void DisposeBuilding(ref Building building)
	{
		building = null;
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using Facepunch;
using UnityEngine;

public sealed class ClanAsyncResult<T> : IPooled
{
	private readonly List<Action<T>> _callbacks = new List<Action<T>>(4);

	private readonly Stopwatch _sinceStarted = new Stopwatch();

	private bool _isComplete;

	private T _result;

	public bool IsStarted => _sinceStarted.IsRunning;

	public float Elapsed => (float)_sinceStarted.Elapsed.TotalSeconds;

	public bool IsComplete => _isComplete;

	public void Start()
	{
		_sinceStarted.Restart();
	}

	public bool TrySetResult(T result)
	{
		if (_isComplete)
		{
			return false;
		}
		_result = result;
		_isComplete = true;
		_sinceStarted.Stop();
		foreach (Action<T> callback in _callbacks)
		{
			try
			{
				callback(_result);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		_callbacks.Clear();
		return true;
	}

	public void OnComplete(Action<T> callback)
	{
		if (callback == null)
		{
			throw new ArgumentNullException("callback");
		}
		if (_isComplete)
		{
			try
			{
				callback(_result);
				return;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				return;
			}
		}
		_callbacks.Add(callback);
	}

	private void Reset()
	{
		_callbacks.Clear();
		_sinceStarted.Reset();
		_isComplete = false;
		_result = default(T);
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}
}


using System;
using System.Collections.Generic;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using ProtoBuf;
using UnityEngine;

public class ClanChangeTracker : IClanChangeSink
{
	private struct ClanChangedEvent
	{
		public long ClanId;

		public ClanDataSource DataSources;
	}

	private struct ClanDisbandedEvent
	{
		public long ClanId;
	}

	private struct InvitationCreatedEvent
	{
		public ulong SteamId;

		public long ClanId;
	}

	private struct MembershipChangedEvent
	{
		public ulong SteamId;

		public long ClanId;
	}

	private struct ChatMessageEvent
	{
		public long ClanId;

		public ClanChatEntry Message;
	}

	private class ChatMessageEventComparer : IComparer<ChatMessageEvent>
	{
		public static readonly ChatMessageEventComparer Instance = new ChatMessageEventComparer();

		public int Compare(ChatMessageEvent x, ChatMessageEvent y)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			return x.Message.Time.CompareTo(y.Message.Time);
		}
	}

	private readonly ClanManager _clanManager;

	private readonly List<ClanChangedEvent> _clanChangedEvents = new List<ClanChangedEvent>();

	private readonly List<ClanDisbandedEvent> _clanDisbandedEvents = new List<ClanDisbandedEvent>();

	private readonly List<InvitationCreatedEvent> _invitationCreatedEvents = new List<InvitationCreatedEvent>();

	private readonly List<MembershipChangedEvent> _membershipChangedEvents = new List<MembershipChangedEvent>();

	private readonly List<ChatMessageEvent> _chatMessageEvents = new List<ChatMessageEvent>();

	public ClanChangeTracker(ClanManager clanManager)
	{
		_clanManager = clanManager;
	}

	public void HandleEvents()
	{
		lock (_clanChangedEvents)
		{
			foreach (ClanChangedEvent clanChangedEvent in _clanChangedEvents)
			{
				HandleClanChanged(clanChangedEvent);
			}
			_clanChangedEvents.Clear();
		}
		lock (_clanDisbandedEvents)
		{
			foreach (ClanDisbandedEvent clanDisbandedEvent in _clanDisbandedEvents)
			{
				HandleClanDisbanded(clanDisbandedEvent);
			}
			_clanDisbandedEvents.Clear();
		}
		lock (_invitationCreatedEvents)
		{
			foreach (InvitationCreatedEvent invitationCreatedEvent in _invitationCreatedEvents)
			{
				HandleInvitationCreated(invitationCreatedEvent);
			}
			_invitationCreatedEvents.Clear();
		}
		lock (_membershipChangedEvents)
		{
			foreach (MembershipChangedEvent membershipChangedEvent in _membershipChangedEvents)
			{
				HandleMembershipChanged(membershipChangedEvent);
			}
			_membershipChangedEvents.Clear();
		}
		lock (_chatMessageEvents)
		{
			foreach (ChatMessageEvent chatMessageEvent in _chatMessageEvents)
			{
				HandleChatMessageEvent(chatMessageEvent);
			}
			_chatMessageEvents.Clear();
		}
	}

	private void HandleClanChanged(in ClanChangedEvent data)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		IClan clan = default(IClan);
		if (_clanManager.Backend.TryGet(data.ClanId, ref clan))
		{
			_clanManager.SendClanChanged(clan);
			AppBroadcast val = Pool.Get<AppBroadcast>();
			val.clanChanged = Pool.Get<AppClanChanged>();
			val.clanChanged.clanInfo = clan.ToProto();
			CompanionServer.Server.Broadcast(new ClanTarget(data.ClanId), val);
		}
		if (((Enum)data.DataSources).HasFlag((Enum)(object)(ClanDataSource)16))
		{
			_clanManager.ClanMemberConnectionsChanged(data.ClanId);
		}
	}

	private void HandleClanDisbanded(in ClanDisbandedEvent data)
	{
	}

	private void HandleInvitationCreated(in InvitationCreatedEvent data)
	{
		_clanManager.SendClanInvitation(data.SteamId, data.ClanId);
	}

	private void HandleMembershipChanged(in MembershipChangedEvent data)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(data.SteamId);
		if ((Object)(object)basePlayer == (Object)null)
		{
			basePlayer = BasePlayer.FindSleeping(data.SteamId);
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.clanId = data.ClanId;
			basePlayer.SendNetworkUpdateImmediate();
			if (basePlayer.IsConnected)
			{
				_clanManager.ClientRPC(RpcTarget.Player("Client_CurrentClanChanged", basePlayer));
			}
			IClan serverClan = default(IClan);
			if (_clanManager.Backend.TryGet(basePlayer.clanId, ref serverClan))
			{
				basePlayer.serverClan = serverClan;
			}
			else
			{
				basePlayer.LoadClanInfo();
			}
		}
	}

	private void HandleChatMessageEvent(in ChatMessageEvent data)
	{
		if (_clanManager.TryGetClanMemberConnections(data.ClanId, out var connections) && connections.Count > 0)
		{
			string nameColor = Chat.GetNameColor(data.Message.SteamId);
			ConsoleNetwork.SendClientCommand(connections, "chat.add2", 5, data.Message.SteamId, data.Message.Message, data.Message.Name, nameColor, 1f);
		}
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.clanMessage = Pool.Get<AppNewClanMessage>();
		val.clanMessage.clanId = data.ClanId;
		val.clanMessage.message = Pool.Get<AppClanMessage>();
		val.clanMessage.message.steamId = data.Message.SteamId;
		val.clanMessage.message.name = data.Message.Name;
		val.clanMessage.message.message = data.Message.Message;
		val.clanMessage.message.time = data.Message.Time;
		CompanionServer.Server.Broadcast(new ClanTarget(data.ClanId), val);
	}

	public void ClanChanged(long clanId, ClanDataSource dataSources)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected I4, but got Unknown
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		lock (_clanChangedEvents)
		{
			int num = List.FindIndexWith<ClanChangedEvent, long>((IReadOnlyList<ClanChangedEvent>)_clanChangedEvents, (Func<ClanChangedEvent, long>)((ClanChangedEvent e) => e.ClanId), clanId, (IEqualityComparer<long>)null);
			if (num < 0)
			{
				_clanChangedEvents.Add(new ClanChangedEvent
				{
					ClanId = clanId,
					DataSources = dataSources
				});
			}
			else
			{
				ClanChangedEvent value = _clanChangedEvents[num];
				ref ClanDataSource dataSources2 = ref value.DataSources;
				dataSources2 |= dataSources;
				_clanChangedEvents[num] = value;
			}
		}
	}

	public void ClanDisbanded(long clanId)
	{
		lock (_clanDisbandedEvents)
		{
			_clanDisbandedEvents.Add(new ClanDisbandedEvent
			{
				ClanId = clanId
			});
		}
	}

	public void InvitationCreated(ulong steamId, long clanId)
	{
		lock (_invitationCreatedEvents)
		{
			_invitationCreatedEvents.Add(new InvitationCreatedEvent
			{
				SteamId = steamId,
				ClanId = clanId
			});
		}
	}

	public void MembershipChanged(ulong steamId, long? clanId)
	{
		lock (_membershipChangedEvents)
		{
			_membershipChangedEvents.Add(new MembershipChangedEvent
			{
				SteamId = steamId,
				ClanId = clanId.GetValueOrDefault()
			});
		}
	}

	public void ClanChatMessage(long clanId, ClanChatEntry entry)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatMessageEvents)
		{
			ChatMessageEvent chatMessageEvent = default(ChatMessageEvent);
			chatMessageEvent.ClanId = clanId;
			chatMessageEvent.Message = entry;
			ChatMessageEvent item = chatMessageEvent;
			int num = _chatMessageEvents.BinarySearch(item, ChatMessageEventComparer.Instance);
			_chatMessageEvents.Insert((num >= 0) ? num : (~num), item);
		}
	}
}


private struct ClanChangedEvent
{
	public long ClanId;

	public ClanDataSource DataSources;
}


private struct ClanDisbandedEvent
{
	public long ClanId;
}


private struct InvitationCreatedEvent
{
	public ulong SteamId;

	public long ClanId;
}


private struct MembershipChangedEvent
{
	public ulong SteamId;

	public long ClanId;
}


private struct ChatMessageEvent
{
	public long ClanId;

	public ClanChatEntry Message;
}


using System.Collections.Generic;

private class ChatMessageEventComparer : IComparer<ChatMessageEvent>
{
	public static readonly ChatMessageEventComparer Instance = new ChatMessageEventComparer();

	public int Compare(ChatMessageEvent x, ChatMessageEvent y)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return x.Message.Time.CompareTo(y.Message.Time);
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class ClanInfoExtensions
{
	public static ClanInfo ToProto(this IClan clan)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if (clan == null)
		{
			return null;
		}
		ClanInfo val = Pool.Get<ClanInfo>();
		val.clanId = clan.ClanId;
		val.name = clan.Name;
		val.created = clan.Created;
		val.creator = clan.Creator;
		val.motd = clan.Motd;
		val.motdTimestamp = clan.MotdTimestamp;
		val.motdAuthor = clan.MotdAuthor;
		val.logo = clan.Logo;
		val.color = ColorEx.ToInt32(clan.Color);
		val.maxMemberCount = clan.MaxMemberCount;
		val.score = clan.Score;
		val.roles = Pool.Get<List<Role>>();
		foreach (ClanRole role in clan.Roles)
		{
			val.roles.Add(role.ToProto());
		}
		val.members = Pool.Get<List<Member>>();
		foreach (ClanMember member in clan.Members)
		{
			val.members.Add(member.ToProto());
		}
		val.invites = Pool.Get<List<Invite>>();
		foreach (ClanInvite invite in clan.Invites)
		{
			val.invites.Add(invite.ToProto());
		}
		return val;
	}

	private static Role ToProto(this ClanRole role)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = role.Rank == 1;
		Role obj = Pool.Get<Role>();
		obj.roleId = role.RoleId;
		obj.rank = role.Rank;
		obj.name = role.Name;
		obj.canSetMotd = flag || role.CanSetMotd;
		obj.canSetLogo = flag || role.CanSetLogo;
		obj.canInvite = flag || role.CanInvite;
		obj.canKick = flag || role.CanKick;
		obj.canPromote = flag || role.CanPromote;
		obj.canDemote = flag || role.CanDemote;
		obj.canSetPlayerNotes = flag || role.CanSetPlayerNotes;
		obj.canAccessLogs = flag || role.CanAccessLogs;
		obj.canAccessScoreEvents = flag || role.CanAccessScoreEvents;
		return obj;
	}

	public static ClanRole FromProto(this Role proto)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		ClanRole result = default(ClanRole);
		result.RoleId = proto.roleId;
		result.Rank = proto.rank;
		result.Name = proto.name;
		result.CanSetMotd = proto.canSetMotd;
		result.CanSetLogo = proto.canSetLogo;
		result.CanInvite = proto.canInvite;
		result.CanKick = proto.canKick;
		result.CanPromote = proto.canPromote;
		result.CanDemote = proto.canDemote;
		result.CanSetPlayerNotes = proto.canSetPlayerNotes;
		result.CanAccessLogs = proto.canAccessLogs;
		result.CanAccessScoreEvents = proto.canAccessScoreEvents;
		return result;
	}

	private static Member ToProto(this ClanMember member)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Member obj = Pool.Get<Member>();
		obj.steamId = member.SteamId;
		obj.roleId = member.RoleId;
		obj.joined = member.Joined;
		obj.lastSeen = member.LastSeen;
		obj.notes = member.Notes;
		obj.online = (NexusServer.Started ? NexusServer.IsOnline(member.SteamId) : ServerPlayers.IsOnline(member.SteamId));
		return obj;
	}

	private static Invite ToProto(this ClanInvite invite)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Invite obj = Pool.Get<Invite>();
		obj.steamId = invite.SteamId;
		obj.recruiter = invite.Recruiter;
		obj.timestamp = invite.Timestamp;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanInvitationExtensions
{
	public static ClanInvitations ToProto(this List<ClanInvitation> invitations)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		List<Invitation> list = Pool.Get<List<Invitation>>();
		foreach (ClanInvitation invitation in invitations)
		{
			list.Add(invitation.ToProto());
		}
		ClanInvitations obj = Pool.Get<ClanInvitations>();
		obj.invitations = list;
		return obj;
	}

	public static Invitation ToProto(this ClanInvitation invitation)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Invitation obj = Pool.Get<Invitation>();
		obj.clanId = invitation.ClanId;
		obj.recruiter = invitation.Recruiter;
		obj.timestamp = invitation.Timestamp;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanLeaderboardExtensions
{
	public static ClanLeaderboard ToProto(this List<ClanLeaderboardEntry> leaderboard)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanLeaderboardEntry item in leaderboard)
		{
			list.Add(item.ToProto());
		}
		ClanLeaderboard obj = Pool.Get<ClanLeaderboard>();
		obj.entries = list;
		return obj;
	}

	public static Entry ToProto(this ClanLeaderboardEntry entry)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Entry obj = Pool.Get<Entry>();
		obj.clanId = entry.ClanId;
		obj.name = entry.Name;
		obj.score = entry.Score;
		return obj;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public static class ClanLogExtensions
{
	public static ClanLog ToProto(this ClanLogs clanLogs)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanLogEntry entry in clanLogs.Entries)
		{
			Entry val = Pool.Get<Entry>();
			val.timestamp = entry.Timestamp;
			val.eventKey = entry.EventKey;
			val.arg1 = entry.Arg1;
			val.arg2 = entry.Arg2;
			val.arg3 = entry.Arg3;
			val.arg4 = entry.Arg4;
			list.Add(val);
		}
		ClanLog obj = Pool.Get<ClanLog>();
		obj.clanId = clanLogs.ClanId;
		obj.logEntries = list;
		return obj;
	}

	public static ClanScoreEvents ToProto(this ClanScoreEvents clanScoreEvents)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected I4, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		List<Entry> list = Pool.Get<List<Entry>>();
		foreach (ClanScoreEvent scoreEvent in clanScoreEvents.ScoreEvents)
		{
			Entry val = Pool.Get<Entry>();
			val.timestamp = scoreEvent.Timestamp;
			val.type = (int)scoreEvent.Type;
			val.score = scoreEvent.Score;
			val.multiplier = scoreEvent.Multiplier;
			val.steamId = scoreEvent.SteamId.GetValueOrDefault();
			val.otherSteamId = scoreEvent.OtherSteamId.GetValueOrDefault();
			val.otherClanId = scoreEvent.OtherClanId.GetValueOrDefault();
			val.arg1 = scoreEvent.Arg1;
			val.arg2 = scoreEvent.Arg2;
			list.Add(val);
		}
		ClanScoreEvents obj = Pool.Get<ClanScoreEvents>();
		obj.clanId = clanScoreEvents.ClanId;
		obj.scoreEvents = list;
		return obj;
	}
}


using UnityEngine;

public struct ClanMetadata
{
	public long ClanId;

	public string Name;

	public int Members;

	public Color32 Color;
}


using System;
using System.Collections.Generic;
using CompanionServer;
using ConVar;
using Facepunch;
using UnityEngine;

public static class ClanPushNotifications
{
	public static async void SendClanAnnouncement(IClan clan, long previousTimestamp, ulong ignorePlayer)
	{
		if (ClanUtility.Timestamp() - previousTimestamp < 300000)
		{
			return;
		}
		try
		{
			List<ulong> steamIds = Pool.Get<List<ulong>>();
			foreach (ClanMember member in clan.Members)
			{
				if (member.SteamId != ignorePlayer)
				{
					steamIds.Add(member.SteamId);
				}
			}
			Dictionary<string, string> dictionary = Util.TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "clan");
				dictionary.Add("fromId", ignorePlayer.ToString("G"));
				await NotificationList.SendNotificationTo(steamIds, NotificationChannel.ClanAnnouncement, "[" + clan.Name + "] Announcement was updated", ConVar.Server.hostname, dictionary);
			}
			Pool.FreeUnmanaged<ulong>(ref steamIds);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


public class ClientIOLineParent : FacepunchBehaviour
{
	public AnimatedBuildingBlock parentEntity;

	public string boneName;

	public bool ignoreForPlugConnections;
}


using UnityEngine;

public class ClientIOLineParentClampedBounds : ClientIOLineParent
{
	public Bounds ClampedLocalBounds;

	public Transform BoundsRelativeTo;

	private OBB clampedObb;
}


using UnityEngine;

public class ClientStubComponent : MonoBehaviour, IClientComponent
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class Climate : SingletonComponent<Climate>
{
	[Serializable]
	public class ClimateParameters
	{
		public AnimationCurve Temperature;

		[Horizontal(4, -1)]
		public Float4 AerialDensity;

		[Horizontal(4, -1)]
		public Float4 FogDensity;

		[Horizontal(4, -1)]
		public Color4 FogColorGrad;

		[Horizontal(4, -1)]
		public Float4 FogAmbientIntensity = Float4.One();

		[Horizontal(4, -1)]
		[Range(0f, 1f)]
		public Float4 FogAmbientSaturation = Float4.One();

		[Horizontal(4, -1)]
		public Float4 FogLightBoost = Float4.One();

		public float BiomeWeightExponent = 1f;

		public float FogHeightFalloff = 0.02f;
	}

	[Serializable]
	public class WeatherParameters
	{
		[Range(0f, 1f)]
		public float ClearChance = 1f;

		[Range(0f, 1f)]
		public float DustChance;

		[Range(0f, 1f)]
		public float FogChance;

		[Range(0f, 1f)]
		public float OvercastChance;

		[Range(0f, 1f)]
		public float StormChance;

		[Range(0f, 1f)]
		public float RainChance;
	}

	public class Value4<T>
	{
		public T Dawn;

		public T Noon;

		public T Dusk;

		public T Night;

		public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
		{
			float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
			float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
			float num3 = (180f - sky.SunZenith) / 180f;
			float num4 = 1f / 9f;
			if (num < num2)
			{
				if (num3 < 0.5f)
				{
					src = Night;
					dst = Dawn;
					return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
				}
				src = Dawn;
				dst = Noon;
				return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
			}
			if (num3 > 0.5f)
			{
				src = Noon;
				dst = Dusk;
				return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
			}
			src = Dusk;
			dst = Night;
			return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
		}
	}

	[Serializable]
	public class Float4 : Value4<float>
	{
		public static Float4 One()
		{
			return new Float4
			{
				Dawn = 1f,
				Dusk = 1f,
				Noon = 1f,
				Night = 1f
			};
		}
	}

	[Serializable]
	public class Color4 : Value4<Color>
	{
	}

	[Serializable]
	public class Texture2D4 : Value4<Texture2D>
	{
	}

	private const float fadeAngle = 20f;

	private const float defaultTemp = 15f;

	private const int weatherDurationHours = 18;

	private const int weatherFadeHours = 6;

	public float BiomeFogShoreDistanceFalloff = -25f;

	[Range(0f, 1f)]
	public float BlendingSpeed = 1f;

	public float FogDarknessDistance = 200f;

	public bool DebugLUTBlending;

	public WeatherParameters Weather;

	public WeatherPreset[] WeatherPresets;

	public WeatherPreset DeepSeaCalmWeather;

	public WeatherPreset DeepSeaWipeWeather;

	public WeatherPreset DeepSeaPortalWeather;

	public ClimateParameters Arid;

	public ClimateParameters Temperate;

	public ClimateParameters Tundra;

	public ClimateParameters Arctic;

	public ClimateParameters Jungle;

	public ClimateParameters DeepSea;

	public float UndergroundFogDensity;

	public Color UndergroundFogColor = Color.black;

	public VolumeCloudsConfig[] DefaultCloudConfigs;

	public VolumeCloudsCirrusConfig[] DefaultCirrusConfigs;

	public VolumeCloudsConfig[] AllCloudConfigs;

	public Dictionary<WeatherPresetType, WeatherPreset[]> presetLookup;

	private ClimateParameters[] climateLookup;

	public float WeatherStateBlend { get; set; }

	public uint WeatherSeedPrevious { get; set; }

	public uint WeatherSeedTarget { get; set; }

	public uint WeatherSeedNext { get; set; }

	public WeatherPreset WeatherStatePrevious { get; set; }

	public WeatherPreset WeatherStateTarget { get; set; }

	public WeatherPreset WeatherStateNext { get; set; }

	public WeatherPreset DeepSeaWeatherState { get; private set; }

	public WeatherPreset WeatherState { get; set; }

	public WeatherPreset WeatherClampsMin { get; private set; }

	public WeatherPreset WeatherClampsMax { get; private set; }

	public WeatherPreset WeatherOverrides { get; set; }

	public LegacyWeatherState Overrides { get; set; }

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		WeatherState = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMin = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherClampsMax = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherOverrides = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherState = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		DeepSeaWeatherState = ScriptableObject.CreateInstance(typeof(WeatherPreset)) as WeatherPreset;
		WeatherState.Reset();
		DeepSeaWeatherState.Reset();
		WeatherClampsMin.Reset();
		WeatherClampsMax.Reset();
		WeatherOverrides.Reset();
		Overrides = new LegacyWeatherState(WeatherOverrides);
	}

	protected override void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			((SingletonComponent)this).OnDestroy();
			if ((Object)(object)WeatherState != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherState);
			}
			if ((Object)(object)WeatherClampsMin != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMin);
			}
			if ((Object)(object)WeatherClampsMax != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherClampsMax);
			}
			if ((Object)(object)WeatherOverrides != (Object)null)
			{
				Object.Destroy((Object)(object)WeatherOverrides);
			}
		}
	}

	private void GetPresetVCloudConfigs(WeatherPreset preset, uint seed, out VolumeCloudsConfig cfg, out VolumeCloudsCirrusConfig cfgCirrus, out VolumeCloudsRadialWeatherLayerConfig cfgStorm)
	{
		if (preset.VolumeCloudsConfigs != null && preset.VolumeCloudsConfigs.Length != 0)
		{
			cfg = preset.VolumeCloudsConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsConfigs.Length)];
		}
		else if (DefaultCloudConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cloud config, and default cloud config list is empty!  This shouldn't be so");
			cfg = null;
		}
		else
		{
			cfg = DefaultCloudConfigs[SeedRandom.Range(seed, 0, DefaultCloudConfigs.Length)];
		}
		if (preset.VolumeCloudsCirrusConfigs != null && preset.VolumeCloudsCirrusConfigs.Length != 0)
		{
			cfgCirrus = preset.VolumeCloudsCirrusConfigs[SeedRandom.Range(seed, 0, preset.VolumeCloudsCirrusConfigs.Length)];
		}
		else if (DefaultCirrusConfigs.Length == 0)
		{
			Debug.LogError((object)"Current weather profile has no cirrus cloud config, and default cirrus cloud config list is empty!  This shouldn't be so");
			cfgCirrus = null;
		}
		else
		{
			cfgCirrus = DefaultCirrusConfigs[SeedRandom.Range(seed, 0, DefaultCirrusConfigs.Length)];
		}
		if (preset.VolumeCloudsStormLayers != null && preset.VolumeCloudsStormLayers.Length != 0)
		{
			cfgStorm = preset.VolumeCloudsStormLayers[SeedRandom.Range(seed, 0, preset.VolumeCloudsStormLayers.Length)];
		}
		else
		{
			cfgStorm = null;
		}
	}

	public void Update()
	{
		if (!Application.isReceiving && !Application.isLoading && Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			TOD_Sky instance = TOD_Sky.Instance;
			float num = 0f;
			long num2 = World.Seed + instance.Cycle.Ticks;
			long num3 = 648000000000L;
			long num4 = 216000000000L;
			long num5 = num2 / num3;
			WeatherStateBlend = Mathf.InverseLerp(0f, (float)num4, (float)(num2 % num3));
			uint seed = (WeatherSeedPrevious = GetSeedFromLong(num5));
			WeatherStatePrevious = GetWeatherPreset(seed);
			seed = (WeatherSeedTarget = GetSeedFromLong(num5 + 1));
			WeatherStateTarget = GetWeatherPreset(seed);
			seed = (WeatherSeedNext = GetSeedFromLong(num5 + 2));
			WeatherStateNext = GetWeatherPreset(seed);
			WeatherState.Fade(WeatherStatePrevious, WeatherStateTarget, WeatherStateBlend);
			WeatherState.Override(WeatherOverrides);
			DeepSeaManager serverInstance = PointEntity<DeepSeaManager>.ServerInstance;
			if ((Object)(object)serverInstance != (Object)null)
			{
				num = serverInstance.GetWipeWeatherLerp();
				DeepSeaWeatherState.Fade(DeepSeaCalmWeather, DeepSeaWipeWeather, num);
			}
		}
	}

	private static bool Initialized()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStatePrevious))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateTarget))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherStateNext))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherState))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherClampsMin))
		{
			return false;
		}
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance.WeatherOverrides))
		{
			return false;
		}
		return true;
	}

	public static float GetClouds(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Clouds.Coverage;
	}

	public static float GetFog(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Atmosphere.Fogginess;
	}

	public static float GetWind(Vector3 position)
	{
		if (!Initialized())
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Wind;
	}

	public static float GetThunder(Vector3 position)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		if (DeepSeaManager.IsInsideDeepSea(position))
		{
			return SingletonComponent<Climate>.Instance.DeepSeaWeatherState.Thunder;
		}
		float thunder = SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		if (thunder >= 0f)
		{
			return thunder;
		}
		float thunder2 = SingletonComponent<Climate>.Instance.WeatherState.Thunder;
		float thunder3 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Thunder;
		float thunder4 = SingletonComponent<Climate>.Instance.WeatherStateTarget.Thunder;
		if (thunder3 > 0f && thunder2 > 0.5f * thunder3)
		{
			return thunder2;
		}
		if (thunder4 > 0f && thunder2 > 0.5f * thunder4)
		{
			return thunder2;
		}
		return 0f;
	}

	public static float GetRainbow(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsDay || instance.LerpValue < 1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.25f)
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 3) : 0f);
		if (num <= 0f)
		{
			return 0f;
		}
		float rainbow = SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		if (rainbow >= 0f)
		{
			return rainbow * num;
		}
		if (SingletonComponent<Climate>.Instance.WeatherState.Rainbow <= 0f)
		{
			return 0f;
		}
		if (SingletonComponent<Climate>.Instance.WeatherStateTarget.Rainbow > 0f)
		{
			return 0f;
		}
		float rainbow2 = SingletonComponent<Climate>.Instance.WeatherStatePrevious.Rainbow;
		float num2 = SeedRandom.Value(SingletonComponent<Climate>.Instance.WeatherSeedPrevious);
		if (rainbow2 < num2)
		{
			return 0f;
		}
		return num;
	}

	public static float GetAurora(Vector3 position)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance) || !instance.IsNight || instance.LerpValue > 0f)
		{
			return 0f;
		}
		if (GetClouds(position) > 0.1f)
		{
			return 0f;
		}
		if (GetFog(position) > 0.1f)
		{
			return 0f;
		}
		if (!Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
		{
			return 0f;
		}
		return TerrainMeta.BiomeMap.GetBiome(position, 8);
	}

	public static float GetRain(Vector3 position)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		if (DeepSeaManager.IsInsidePortal(position, DeepSeaPortal.PortalModeEnum.Entrance) || DeepSeaManager.IsInsidePortal(position, DeepSeaPortal.PortalModeEnum.Exit))
		{
			return SingletonComponent<Climate>.Instance.WeatherState.Rain;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 1) : 0f);
		float num2 = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * Mathf.Lerp(1f, 0.5f, num) * (1f - num2);
	}

	public static float GetSnow(Vector3 position)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 0f;
		}
		float num = (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap) ? TerrainMeta.BiomeMap.GetBiome(position, 8) : 0f);
		if (num != 0f && DeepSeaManager.IsInsidePortal(position, DeepSeaPortal.PortalModeEnum.Entrance))
		{
			return 0f;
		}
		return SingletonComponent<Climate>.Instance.WeatherState.Rain * num;
	}

	public static float GetTemperature(Vector3 position)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!Initialized())
		{
			return 15f;
		}
		TOD_Sky instance = TOD_Sky.Instance;
		if (!Object.op_Implicit((Object)(object)instance))
		{
			return 15f;
		}
		ClimateParameters src;
		ClimateParameters dst;
		float num = SingletonComponent<Climate>.Instance.FindBlendParameters(position, out src, out dst);
		if (src == null || dst == null)
		{
			return 15f;
		}
		float hour = instance.Cycle.Hour;
		float num2 = src.Temperature.Evaluate(hour);
		float num3 = dst.Temperature.Evaluate(hour);
		return Mathf.Lerp(num2, num3, num);
	}

	private uint GetSeedFromLong(long val)
	{
		uint result = (uint)((val % uint.MaxValue + uint.MaxValue) % uint.MaxValue);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		SeedRandom.Wanghash(ref result);
		return result;
	}

	private WeatherPreset GetWeatherPreset(uint seed)
	{
		float num = Weather.ClearChance + Weather.DustChance + Weather.FogChance + Weather.OvercastChance + Weather.StormChance + Weather.RainChance;
		float num2 = SeedRandom.Range(ref seed, 0f, num);
		if (num2 < Weather.RainChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Rain);
		}
		if (num2 < Weather.RainChance + Weather.StormChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Storm);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Overcast);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Fog);
		}
		if (num2 < Weather.RainChance + Weather.StormChance + Weather.OvercastChance + Weather.FogChance + Weather.DustChance)
		{
			return GetWeatherPreset(seed, WeatherPresetType.Dust);
		}
		return GetWeatherPreset(seed, WeatherPresetType.Clear);
	}

	private WeatherPreset GetWeatherPreset(uint seed, WeatherPresetType type)
	{
		if (presetLookup == null)
		{
			presetLookup = new Dictionary<WeatherPresetType, WeatherPreset[]>();
		}
		if (!presetLookup.TryGetValue(type, out var value))
		{
			presetLookup.Add(type, value = CacheWeatherPresets(type));
		}
		return value.GetRandom(ref seed);
	}

	public WeatherPreset[] CacheWeatherPresets(WeatherPresetType type)
	{
		return WeatherPresets.Where((WeatherPreset x) => x.Type == type).ToArray();
	}

	private float FindBlendParameters(Vector3 pos, out ClimateParameters src, out ClimateParameters dst)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		if (DeepSeaManager.IsInsideDeepSea(pos))
		{
			src = DeepSea;
			dst = DeepSea;
			return 1f;
		}
		if (climateLookup == null)
		{
			climateLookup = new ClimateParameters[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			src = Temperate;
			dst = Temperate;
			return 0.5f;
		}
		int biomeMaxType = TerrainMeta.BiomeMap.GetBiomeMaxType(pos);
		int biomeMaxType2 = TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~biomeMaxType);
		src = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType)];
		dst = climateLookup[TerrainBiome.TypeToIndex(biomeMaxType2)];
		return TerrainMeta.BiomeMap.GetBiome(pos, biomeMaxType2);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ClimateParameters
{
	public AnimationCurve Temperature;

	[Horizontal(4, -1)]
	public Float4 AerialDensity;

	[Horizontal(4, -1)]
	public Float4 FogDensity;

	[Horizontal(4, -1)]
	public Color4 FogColorGrad;

	[Horizontal(4, -1)]
	public Float4 FogAmbientIntensity = Float4.One();

	[Horizontal(4, -1)]
	[Range(0f, 1f)]
	public Float4 FogAmbientSaturation = Float4.One();

	[Horizontal(4, -1)]
	public Float4 FogLightBoost = Float4.One();

	public float BiomeWeightExponent = 1f;

	public float FogHeightFalloff = 0.02f;
}


using System;
using UnityEngine;

[Serializable]
public class WeatherParameters
{
	[Range(0f, 1f)]
	public float ClearChance = 1f;

	[Range(0f, 1f)]
	public float DustChance;

	[Range(0f, 1f)]
	public float FogChance;

	[Range(0f, 1f)]
	public float OvercastChance;

	[Range(0f, 1f)]
	public float StormChance;

	[Range(0f, 1f)]
	public float RainChance;
}


using UnityEngine;

public class Value4<T>
{
	public T Dawn;

	public T Noon;

	public T Dusk;

	public T Night;

	public float FindBlendParameters(TOD_Sky sky, out T src, out T dst)
	{
		float num = Mathf.Abs(sky.SunriseTime - sky.Cycle.Hour);
		float num2 = Mathf.Abs(sky.SunsetTime - sky.Cycle.Hour);
		float num3 = (180f - sky.SunZenith) / 180f;
		float num4 = 1f / 9f;
		if (num < num2)
		{
			if (num3 < 0.5f)
			{
				src = Night;
				dst = Dawn;
				return Mathf.InverseLerp(0.5f - num4, 0.5f, num3);
			}
			src = Dawn;
			dst = Noon;
			return Mathf.InverseLerp(0.5f, 0.5f + num4, num3);
		}
		if (num3 > 0.5f)
		{
			src = Noon;
			dst = Dusk;
			return Mathf.InverseLerp(0.5f + num4, 0.5f, num3);
		}
		src = Dusk;
		dst = Night;
		return Mathf.InverseLerp(0.5f, 0.5f - num4, num3);
	}
}


using System;

[Serializable]
public class Float4 : Value4<float>
{
	public static Float4 One()
	{
		return new Float4
		{
			Dawn = 1f,
			Dusk = 1f,
			Noon = 1f,
			Night = 1f
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class Color4 : Value4<Color>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2D4 : Value4<Texture2D>
{
}


using System;
using UnityEngine;

public class ColliderInfo : MonoBehaviour
{
	[Flags]
	public enum Flags
	{
		Usable = 1,
		Shootable = 2,
		Melee = 4,
		Opaque = 8,
		Airflow = 0x10,
		OnlyBlockBuildingBlock = 0x20,
		Monument = 0x40,
		Tunnels = 0x80,
		AllowBuildInsideMesh = 0x100,
		OnlyBlockDeployables = 0x200,
		OnlyEvaluatePreventBuildingInMonuments = 0x400
	}

	public const Flags FlagsNone = (Flags)0;

	public const Flags FlagsEverything = (Flags)(-1);

	public const Flags FlagsDefault = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	[InspectorFlags]
	public Flags flags = Flags.Usable | Flags.Shootable | Flags.Melee | Flags.Opaque;

	public bool HasFlag(Flags f)
	{
		return (flags & f) == f;
	}

	public void SetFlag(Flags f, bool b)
	{
		if (b)
		{
			flags |= f;
		}
		else
		{
			flags &= ~f;
		}
	}

	public bool Filter(HitTest info)
	{
		switch (info.type)
		{
		case HitTest.Type.MeleeAttack:
			if ((flags & Flags.Melee) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.ProjectileEffect:
		case HitTest.Type.Projectile:
			if ((flags & Flags.Shootable) == 0)
			{
				return false;
			}
			break;
		case HitTest.Type.Use:
			if ((flags & Flags.Usable) == 0)
			{
				return false;
			}
			break;
		}
		return true;
	}
}


using System;

[Flags]
public enum Flags
{
	Usable = 1,
	Shootable = 2,
	Melee = 4,
	Opaque = 8,
	Airflow = 0x10,
	OnlyBlockBuildingBlock = 0x20,
	Monument = 0x40,
	Tunnels = 0x80,
	AllowBuildInsideMesh = 0x100,
	OnlyBlockDeployables = 0x200,
	OnlyEvaluatePreventBuildingInMonuments = 0x400
}


public class ColliderInfo_Pipe : ColliderInfo
{
	public int OutputSlotIndex;

	public IOEntity ParentEntity;
}


using UnityEngine;

public class ConditionalGibbable : MonoBehaviour
{
	[ReadOnly]
	public int id;
}


using UnityEngine;

public class CreateEffect : MonoBehaviour
{
	public GameObjectRef EffectToCreate;

	public void OnEnable()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Effect.client.Run(EffectToCreate.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up, ((Component)this).transform.forward);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class CreationGibSpawner : BaseMonoBehaviour
{
	[Serializable]
	public class GibReplacement
	{
		public GameObject oldGib;

		public GameObject newGib;
	}

	[Serializable]
	public class EffectMaterialPair
	{
		public PhysicMaterial material;

		public GameObjectRef effect;
	}

	[Serializable]
	public struct ConditionalGibSource
	{
		public GameObject source;

		public Vector3 pos;

		public Quaternion rot;
	}

	private GameObject gibSource;

	public GameObject gibsInstance;

	public float startTime;

	public float duration = 1f;

	public float buildScaleAdditionalAmount = 0.5f;

	[Tooltip("Entire object will be scaled on xyz during duration by this curve")]
	public AnimationCurve scaleCurve;

	[Tooltip("Object will be pushed out along transform.forward/right/up based on build direction by this amount")]
	public AnimationCurve buildCurve;

	[Tooltip("Additional scaling to apply to object based on build direction")]
	public AnimationCurve buildScaleCurve;

	public AnimationCurve xCurve;

	public AnimationCurve yCurve;

	public AnimationCurve zCurve;

	public Vector3[] spawnPositions;

	public GameObject[] particles;

	public float[] gibProgress;

	public PhysicMaterial physMaterial;

	public List<Transform> gibs;

	public bool started;

	public GameObjectRef placeEffect;

	public GameObject smokeEffect;

	public float effectSpacing = 0.2f;

	public bool invert;

	public Vector3 buildDirection;

	[Horizontal(1, 0)]
	public GibReplacement[] GibReplacements;

	public EffectMaterialPair[] effectLookup;

	private float startDelay;

	public List<ConditionalGibSource> conditionalGibSources = new List<ConditionalGibSource>();

	private float nextEffectTime = float.NegativeInfinity;

	public GameObjectRef GetEffectForMaterial(PhysicMaterial mat)
	{
		EffectMaterialPair[] array = effectLookup;
		foreach (EffectMaterialPair effectMaterialPair in array)
		{
			if ((Object)(object)effectMaterialPair.material == (Object)(object)mat)
			{
				return effectMaterialPair.effect;
			}
		}
		return effectLookup[0].effect;
	}

	public void SetDelay(float newDelay)
	{
		startDelay = newDelay;
	}

	public void FinishSpawn()
	{
		if (startDelay == 0f)
		{
			Init();
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)Init, startDelay);
		}
	}

	public float GetProgress(float delay)
	{
		if (!started)
		{
			return 0f;
		}
		if (duration == 0f)
		{
			return 1f;
		}
		return Mathf.Clamp01((Time.time - (startTime + delay)) / duration);
	}

	public void AddConditionalGibSource(GameObject cGibSource, Vector3 pos, Quaternion rot)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Adding conditional gib source");
		ConditionalGibSource item = default(ConditionalGibSource);
		item.source = cGibSource;
		item.pos = pos;
		item.rot = rot;
		conditionalGibSources.Add(item);
	}

	public void SetGibSource(GameObject newGibSource)
	{
		GameObject val = newGibSource;
		for (int i = 0; i < GibReplacements.Length; i++)
		{
			if ((Object)(object)GibReplacements[i].oldGib == (Object)(object)newGibSource)
			{
				val = GibReplacements[i].newGib;
				break;
			}
		}
		gibSource = val;
	}

	private int SortsGibs(Transform a, Transform b)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderer component = ((Component)a).GetComponent<MeshRenderer>();
		MeshRenderer component2 = ((Component)b).GetComponent<MeshRenderer>();
		Bounds bounds;
		if (!invert)
		{
			float y;
			if (!((Object)(object)component == (Object)null))
			{
				bounds = ((Renderer)component).bounds;
				y = ((Bounds)(ref bounds)).center.y;
			}
			else
			{
				y = a.localPosition.y;
			}
			float num = y;
			float y2;
			if (!((Object)(object)component2 == (Object)null))
			{
				bounds = ((Renderer)component2).bounds;
				y2 = ((Bounds)(ref bounds)).center.y;
			}
			else
			{
				y2 = b.localPosition.y;
			}
			float value = y2;
			return num.CompareTo(value);
		}
		float y3;
		if (!((Object)(object)component == (Object)null))
		{
			bounds = ((Renderer)component).bounds;
			y3 = ((Bounds)(ref bounds)).center.y;
		}
		else
		{
			y3 = a.localPosition.y;
		}
		float value2 = y3;
		float y4;
		if (!((Object)(object)component2 == (Object)null))
		{
			bounds = ((Renderer)component2).bounds;
			y4 = ((Bounds)(ref bounds)).center.y;
		}
		else
		{
			y4 = b.localPosition.y;
		}
		float num2 = y4;
		return num2.CompareTo(value2);
	}

	public void Init()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		started = true;
		startTime = Time.time;
		gibsInstance = Object.Instantiate<GameObject>(gibSource, ((Component)this).transform.position, ((Component)this).transform.rotation);
		List<Transform> list = gibsInstance.GetComponentsInChildren<Transform>().ToList();
		list.Remove(gibsInstance.transform);
		list.Sort(SortsGibs);
		gibs = list;
		spawnPositions = (Vector3[])(object)new Vector3[gibs.Count];
		gibProgress = new float[gibs.Count];
		particles = (GameObject[])(object)new GameObject[gibs.Count];
		for (int i = 0; i < gibs.Count; i++)
		{
			Transform val = gibs[i];
			spawnPositions[i] = val.localPosition;
			gibProgress[i] = 0f;
			particles[i] = null;
			val.localScale = Vector3.one * scaleCurve.Evaluate(0f);
			_ = spawnPositions[i].x;
			_ = 0f;
			Transform transform = ((Component)val).transform;
			transform.position += ((Component)this).transform.right * GetPushDir(spawnPositions[i], val) * buildCurve.Evaluate(0f) * buildDirection.x;
			Transform transform2 = ((Component)val).transform;
			transform2.position += ((Component)this).transform.up * yCurve.Evaluate(0f);
			Transform transform3 = ((Component)val).transform;
			transform3.position += ((Component)this).transform.forward * zCurve.Evaluate(0f);
		}
		((FacepunchBehaviour)this).Invoke((Action)DestroyMe, duration + 0.05f);
	}

	public float GetPushDir(Vector3 spawnPos, Transform theGib)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if (!(spawnPos.x >= 0f))
		{
			return 1f;
		}
		return -1f;
	}

	public void DestroyMe()
	{
		Object.Destroy((Object)(object)gibsInstance);
	}

	public float GetStartDelay(Transform gib)
	{
		return 0f;
	}

	public void Update()
	{
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		if (!started)
		{
			return;
		}
		float deltaTime = Time.deltaTime;
		int num = Mathf.CeilToInt((float)gibs.Count / 10f);
		for (int i = 0; i < gibs.Count; i++)
		{
			Transform val = gibs[i];
			if ((Object)(object)val == (Object)(object)((Component)this).transform)
			{
				continue;
			}
			if (deltaTime <= 0f)
			{
				break;
			}
			float num2 = 0.33f;
			float num3 = num2 / ((float)gibs.Count * num2) * (duration - num2);
			float num4 = (float)i * num3;
			if (Time.time - startTime < num4)
			{
				continue;
			}
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			int seed = Random.seed;
			Random.seed = i + gibs.Count;
			bool num5 = num <= 1 || Random.Range(0, num) == 0;
			Random.seed = seed;
			if (num5 && (Object)(object)particles[i] == (Object)null && (Object)(object)component != (Object)null && (Object)(object)component.sharedMesh != (Object)null)
			{
				Bounds bounds = component.sharedMesh.bounds;
				Vector3 size = ((Bounds)(ref bounds)).size;
				if (((Vector3)(ref size)).magnitude == 0f)
				{
					continue;
				}
				GameObject val2 = Object.Instantiate<GameObject>(smokeEffect);
				val2.transform.SetParent(val);
				val2.transform.localPosition = Vector3.zero;
				val2.transform.localScale = Vector3.one;
				val2.transform.localRotation = Quaternion.identity;
				ParticleSystem component2 = val2.GetComponent<ParticleSystem>();
				MeshRenderer component3 = ((Component)component).GetComponent<MeshRenderer>();
				ShapeModule shape = component2.shape;
				((ShapeModule)(ref shape)).shapeType = (ParticleSystemShapeType)5;
				bounds = ((Renderer)component3).bounds;
				((ShapeModule)(ref shape)).boxThickness = ((Bounds)(ref bounds)).extents;
				particles[i] = val2;
			}
			float num6 = Mathf.Clamp01(gibProgress[i] / num2);
			float num7 = Mathf.Clamp01((num6 + Time.deltaTime) / num2);
			gibProgress[i] += Time.deltaTime;
			float num8 = scaleCurve.Evaluate(num7);
			((Component)val).transform.localScale = new Vector3(num8, num8, num8);
			Transform transform = ((Component)val).transform;
			transform.localScale += buildDirection * buildScaleCurve.Evaluate(num7) * buildScaleAdditionalAmount;
			((Component)val).transform.localPosition = spawnPositions[i];
			Transform transform2 = ((Component)val).transform;
			transform2.position += ((Component)this).transform.right * GetPushDir(spawnPositions[i], val) * buildCurve.Evaluate(num7) * buildDirection.x;
			Transform transform3 = ((Component)val).transform;
			transform3.position += ((Component)this).transform.up * buildCurve.Evaluate(num7) * buildDirection.y;
			Transform transform4 = ((Component)val).transform;
			transform4.position += ((Component)this).transform.forward * buildCurve.Evaluate(num7) * buildDirection.z;
			if (num7 >= 1f && num7 > num6 && Time.time > nextEffectTime)
			{
				nextEffectTime = Time.time + effectSpacing;
				if ((Object)(object)particles[i] != (Object)null)
				{
					particles[i].GetComponent<ParticleSystem>();
					particles[i].transform.SetParent((Transform)null, true);
					particles[i].BroadcastOnParentDestroying();
				}
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class GibReplacement
{
	public GameObject oldGib;

	public GameObject newGib;
}


using System;
using UnityEngine;

[Serializable]
public class EffectMaterialPair
{
	public PhysicMaterial material;

	public GameObjectRef effect;
}


using System;
using UnityEngine;

[Serializable]
public struct ConditionalGibSource
{
	public GameObject source;

	public Vector3 pos;

	public Quaternion rot;
}


using UnityEngine;

[DefaultExecutionOrder(-1275)]
public class CullingManager : SingletonComponent<CullingManager>
{
}


using System.Collections.Generic;
using UnityEngine;

public class CullingVolume : MonoBehaviour, IClientComponent
{
	[Tooltip("Override occludee root from children of this object (default) to children of any other object.")]
	public GameObject OccludeeRoot;

	[Tooltip("Invert visibility. False will show occludes. True will hide them.")]
	public bool Invert;

	[Tooltip("A portal in the culling volume chain does not toggle objects visible, it merely signals the non-portal volumes to hide their occludees.")]
	public bool Portal;

	[Tooltip("Secondary culling volumes, connected to this one, that will get signaled when this trigger is activated.")]
	public List<CullingVolume> Connections = new List<CullingVolume>();

	[Tooltip("If enabled this culling group will completely disable all LODGroups in its hierarchy")]
	public bool IncludeLodGroup;

	public bool AllowOnEntities;
}


using System;
using UnityEngine;

public class Deployable : PrefabAttribute
{
	public GameObjectRef guidePrefab;

	public Mesh guideMesh;

	public Vector3 guideMeshScale = Vector3.one;

	public bool overrideRotation;

	public Vector3 guideMeshOrientation = Vector3.zero;

	public Vector3 guideMeshPositionOffset = Vector3.zero;

	[Tooltip("Moves the deploy guide towards the camera by 0.05 units, to avoid clipping. Sometimes you want that off to avoid that little offset in betweenthe deploy guide position and the actual position the deployable is going to spawn at.")]
	public bool moveGuideTowardsCamera = true;

	public bool guideLights = true;

	public bool wantsInstanceData;

	public bool copyInventoryFromItem;

	public bool setSocketParent;

	public bool toSlot;

	public BaseEntity.Slot slot;

	public GameObjectRef placeEffect;

	[Tooltip("Only required if the guideMesh is in a significantly different position or there are multiple meshes")]
	public Transform[] guideTargets;

	[NonSerialized]
	public Bounds bounds;

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}

	protected override Type GetIndexedType()
	{
		return typeof(Deployable);
	}

	public bool IsGuideTarget(Transform t)
	{
		if (guideTargets != null)
		{
			Transform[] array = guideTargets;
			for (int i = 0; i < array.Length; i++)
			{
				if ((Object)(object)array[i] == (Object)(object)t)
				{
					return true;
				}
			}
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployableShowVolume : PrefabAttribute, IClientComponent
{
	public enum VolumeType
	{
		PrefabHemisphere,
		PrefabSphere,
		Sphere,
		Hemisphere,
		Cone
	}

	[Serializable]
	public class Volume
	{
		public VolumeType type;

		[Tooltip("Adding a sphere collider here will automatically fill out the fields below in the PreProcess step.")]
		public SphereCollider associatedCollider;

		public Vector3 localPosition;

		public Vector3 rotation;

		public float size;
	}

	public List<Volume> volumes = new List<Volume>();

	protected override Type GetIndexedType()
	{
		return typeof(DeployableShowVolume);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (volumes == null || volumes.Count == 0)
		{
			return;
		}
		foreach (Volume volume in volumes)
		{
			if (volume != null && !((Object)(object)volume.associatedCollider == (Object)null))
			{
				volume.size = volume.associatedCollider.radius * 2f;
				Transform transform = ((Component)volume.associatedCollider).transform;
				volume.localPosition = transform.localPosition;
				volume.rotation = transform.localEulerAngles;
			}
		}
	}
}


public enum VolumeType
{
	PrefabHemisphere,
	PrefabSphere,
	Sphere,
	Hemisphere,
	Cone
}


using System;
using UnityEngine;

[Serializable]
public class Volume
{
	public VolumeType type;

	[Tooltip("Adding a sphere collider here will automatically fill out the fields below in the PreProcess step.")]
	public SphereCollider associatedCollider;

	public Vector3 localPosition;

	public Vector3 rotation;

	public float size;
}


using System;
using UnityEngine;

public class DeployShell : PrefabAttribute
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public OBB WorldSpaceBounds(Transform transform)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(transform.position, transform.lossyScale, transform.rotation, bounds);
	}

	public float LineOfSightPadding()
	{
		return 0.025f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DeployShell);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

public abstract class DeployVolume : PrefabAttribute
{
	public enum EntityMode
	{
		ExcludeList,
		IncludeList
	}

	public enum TypeFilterMode
	{
		Include,
		Ignore
	}

	public LayerMask layers = LayerMask.op_Implicit(537001984);

	[InspectorFlags]
	public ColliderInfo.Flags ignore;

	public EntityMode entityMode;

	[FormerlySerializedAs("entities")]
	public BaseEntity[] entityList;

	[SerializeField]
	public EntityListScriptableObject[] entityGroups;

	[SerializeField]
	public bool includeAllDoors;

	public bool IsBuildingBlock { get; set; }

	public static Collider LastDeployHit { get; set; }

	protected override Type GetIndexedType()
	{
		return typeof(DeployVolume);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		IsBuildingBlock = (Object)(object)rootObj.GetComponent<BuildingBlock>() != (Object)null;
	}

	protected abstract bool Check(Vector3 position, Quaternion rotation, int mask = -1);

	protected abstract bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false);

	protected abstract bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1);

	public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, int mask = -1)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(position, rotation, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 position, Quaternion rotation, DeployVolume[] volumes, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(position, rotation, types, filterMode, ignoredEntity, mask, ignoreChildrenOfEntity))
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 position, Quaternion rotation, List<DeployVolume> volumes, OBB test, int mask = -1)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < volumes.Count; i++)
		{
			if (volumes[i].Check(position, rotation, test, mask))
			{
				return true;
			}
		}
		return false;
	}

	public static bool CheckSphere(Vector3 pos, float radius, int layerMask, DeployVolume volume)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(pos, radius, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return CheckCapsule(start, end, radius, layerMask, volume, null, TypeFilterMode.Include);
	}

	public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask, DeployVolume volume, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapCapsule(start, end, radius, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, types, filterMode, ignoredEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return CheckOBB(obb, layerMask, volume, null, TypeFilterMode.Include);
	}

	public static bool CheckOBB(OBB obb, int layerMask, DeployVolume volume, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, bool ignoreChildrenOfEntity = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume, types, filterMode, ignoredEntity, ignoreChildrenOfEntity);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	public static bool CheckBounds(Bounds bounds, int layerMask, DeployVolume volume)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapBounds(bounds, list, layerMask, (QueryTriggerInteraction)2);
		bool result = CheckFlags(list, volume);
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private static bool CheckFlags(List<Collider> list, DeployVolume volume, List<Type> types = null, TypeFilterMode filterMode = TypeFilterMode.Include, BaseEntity ignoredEntity = null, bool ignoreChildrenOfEntity = false)
	{
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		if (volume == null)
		{
			return true;
		}
		LastDeployHit = null;
		for (int i = 0; i < list.Count; i++)
		{
			LastDeployHit = list[i];
			BaseEntity baseEntity = LastDeployHit.ToBaseEntity();
			if ((Object)(object)ignoredEntity != (Object)null && (Object)(object)baseEntity != (Object)null && ((Object)(object)baseEntity == (Object)(object)ignoredEntity || (ignoreChildrenOfEntity && (Object)(object)baseEntity.GetRootParentEntity() == (Object)(object)ignoredEntity)))
			{
				continue;
			}
			if (volume.includeAllDoors && (Object)(object)list[i] != (Object)null)
			{
				BaseEntity baseEntity2 = list[i].ToBaseEntity();
				if ((Object)(object)baseEntity2 != (Object)null && baseEntity2 is Door)
				{
					return true;
				}
			}
			if ((Object)(object)baseEntity != (Object)null && types != null)
			{
				Type type = ((object)baseEntity).GetType();
				bool flag = types.Contains(type);
				if ((filterMode == TypeFilterMode.Include && !flag) || (filterMode == TypeFilterMode.Ignore && flag))
				{
					continue;
				}
			}
			GameObject gameObject = ((Component)list[i]).gameObject;
			if (gameObject.CompareTag("DeployVolumeIgnore"))
			{
				continue;
			}
			ColliderInfo component = gameObject.GetComponent<ColliderInfo>();
			if (((Object)(object)component != (Object)null && component.HasFlag(ColliderInfo.Flags.OnlyBlockBuildingBlock) && !volume.IsBuildingBlock) || ((Object)(object)component != (Object)null && component.HasFlag(ColliderInfo.Flags.OnlyBlockDeployables) && volume.IsBuildingBlock))
			{
				continue;
			}
			if (gameObject.HasCustomTag(GameObjectTag.BlockPlacement))
			{
				return true;
			}
			MonumentInfo monument = list[i].GetMonument();
			if ((!((Object)(object)monument != (Object)null) || monument.IsSafeZone || !volume.ignore.HasFlag(ColliderInfo.Flags.Monument)) && (!((Object)(object)monument == (Object)null) || (LayerMask.op_Implicit(volume.layers) & 0x20000000) == 0 || !volume.ignore.HasFlag(ColliderInfo.Flags.OnlyEvaluatePreventBuildingInMonuments)) && (!((Object)(object)component != (Object)null) || (volume.ignore & component.flags) == 0))
			{
				if ((Object)(object)component != (Object)null && volume.ignore != 0 && component.HasFlag(volume.ignore))
				{
					return false;
				}
				if (ShouldApplyVolumeForEntity(volume, baseEntity))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool ShouldApplyVolumeForEntity(DeployVolume volume, BaseEntity entity)
	{
		if (volume.entityList == null || volume.entityGroups == null || (volume.entityList.Length == 0 && volume.entityGroups.Length == 0))
		{
			return true;
		}
		if (volume.entityGroups.Length != 0)
		{
			EntityListScriptableObject[] array = volume.entityGroups;
			foreach (EntityListScriptableObject entityListScriptableObject in array)
			{
				if (entityListScriptableObject.entities.IsNullOrEmpty())
				{
					Debug.LogWarning((object)("Skipping entity group '" + ((Object)entityListScriptableObject).name + "' when checking volume: there are no entities"));
				}
				else if (CheckEntityList(entity, entityListScriptableObject.entities, trueIfAnyFound: true))
				{
					return true;
				}
			}
		}
		if (volume.entityList.Length != 0 && CheckEntityList(entity, volume.entityList, volume.entityMode == EntityMode.IncludeList))
		{
			return true;
		}
		return false;
	}

	public static bool CheckEntityList(BaseEntity entity, BaseEntity[] entities, bool trueIfAnyFound)
	{
		if (entities == null || entities.Length == 0)
		{
			return true;
		}
		bool flag = false;
		if ((Object)(object)entity != (Object)null)
		{
			foreach (BaseEntity baseEntity in entities)
			{
				if (entity.prefabID == baseEntity.prefabID)
				{
					flag = true;
					break;
				}
				if (entity is ModularCar && baseEntity is ModularCar)
				{
					flag = true;
					break;
				}
			}
		}
		if (trueIfAnyFound)
		{
			return flag;
		}
		return !flag;
	}
}


public enum EntityMode
{
	ExcludeList,
	IncludeList
}


public enum TypeFilterMode
{
	Include,
	Ignore
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeCapsule : DeployVolume
{
	public Vector3 center = Vector3.zero;

	public float radius = 0.5f;

	public float height = 1f;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		Vector3 start = position + rotation * worldRotation * Vector3.up * height * 0.5f;
		Vector3 end = position + rotation * worldRotation * Vector3.down * height * 0.5f;
		if (DeployVolume.CheckCapsule(start, end, radius, LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		Vector3 start = position + rotation * worldRotation * Vector3.up * height * 0.5f;
		Vector3 end = position + rotation * worldRotation * Vector3.down * height * 0.5f;
		if (DeployVolume.CheckCapsule(start, end, radius, LayerMask.op_Implicit(layers) & mask, this, types, filterMode, ignoredEntity))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeEntityBounds : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * ((Bounds)(ref bounds)).center;
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation), LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DeployVolumeEntityBoundsReverse : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public int layer;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * ((Bounds)(ref bounds)).center;
		OBB test = default(OBB);
		((OBB)(ref test))..ctor(position, ((Bounds)(ref bounds)).size, rotation);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, ((Vector3)(ref test.extents)).magnitude, list, LayerMask.op_Implicit(layers) & mask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			DeployVolume[] array = PrefabAttribute.server.FindAll<DeployVolume>(item.prefabID);
			List<DeployVolume> list2 = Pool.Get<List<DeployVolume>>();
			DeployVolume[] array2 = array;
			foreach (DeployVolume deployVolume in array2)
			{
				if (DeployVolume.ShouldApplyVolumeForEntity(deployVolume, item))
				{
					list2.Add(deployVolume);
				}
			}
			if (DeployVolume.Check(((Component)item).transform.position, ((Component)item).transform.rotation, list2, test, 1 << layer))
			{
				Pool.FreeUnmanaged<DeployVolume>(ref list2);
				Pool.FreeUnmanaged<BaseEntity>(ref list);
				return true;
			}
			Pool.FreeUnmanaged<DeployVolume>(ref list2);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
		layer = rootObj.layer;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeOBB : DeployVolume
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public DeployVolumeOBB(Bounds bounds, LayerMask layers)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		this.bounds = bounds;
		base.layers = layers;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		if (DeployVolume.CheckOBB(new OBB(position, ((Bounds)(ref bounds)).size, rotation * worldRotation), LayerMask.op_Implicit(layers) & mask, this, types, filterMode, ignoredEntity, ignoreChildrenOfEntity))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB test, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * ((Bounds)(ref bounds)).center + worldPosition);
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(position, ((Bounds)(ref bounds)).size, rotation * worldRotation);
		if ((LayerMask.op_Implicit(layers) & mask) != 0 && ((OBB)(ref val)).Intersects(test))
		{
			return true;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class DeployVolumeRequireBoatBuildingVolume : DeployVolume
{
	public List<Transform> Points = new List<Transform>();

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		List<TriggerBoatBuildingArea> list = Pool.Get<List<TriggerBoatBuildingArea>>();
		Vis.Components<TriggerBoatBuildingArea>(position, 3f, list, 262144, (QueryTriggerInteraction)2);
		using (List<TriggerBoatBuildingArea>.Enumerator enumerator = list.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				TriggerBoatBuildingArea current = enumerator.Current;
				Vector3 position2 = ((Component)current).transform.position;
				Vector3 lossyScale = ((Component)current).transform.lossyScale;
				Quaternion rotation2 = ((Component)current).transform.rotation;
				OBB val = default(OBB);
				((OBB)(ref val))..ctor(position2, lossyScale, rotation2);
				foreach (Transform point in Points)
				{
					Vector3 val2 = position + rotation * point.position;
					if (!((OBB)(ref val)).Contains(val2))
					{
						Pool.FreeUnmanaged<TriggerBoatBuildingArea>(ref list);
						return true;
					}
				}
				Pool.FreeUnmanaged<TriggerBoatBuildingArea>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<TriggerBoatBuildingArea>(ref list);
		return true;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		return false;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DeployVolumeSphere : DeployVolume
{
	public Vector3 center = Vector3.zero;

	public float radius = 0.5f;

	protected override bool Check(Vector3 position, Quaternion rotation, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		if (DeployVolume.CheckSphere(position, radius, LayerMask.op_Implicit(layers) & mask, this))
		{
			return true;
		}
		return false;
	}

	protected override bool Check(Vector3 position, Quaternion rotation, List<Type> types, TypeFilterMode filterMode, BaseEntity ignoredEntity = null, int mask = -1, bool ignoreChildrenOfEntity = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Check(position, rotation, mask);
	}

	protected override bool Check(Vector3 position, Quaternion rotation, OBB obb, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (worldRotation * center + worldPosition);
		if ((LayerMask.op_Implicit(layers) & mask) != 0 && Vector3.Distance(position, ((OBB)(ref obb)).ClosestPoint(position)) <= radius)
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "NewEntityList", menuName = "Rust/EntityList")]
public class EntityListScriptableObject : ScriptableObject
{
	public string AutoPopulateFromAssetLabel;

	[SerializeField]
	public BaseEntity[] entities;

	public bool blockIfAny;

	public bool IsInList(uint prefabId)
	{
		if (entities == null)
		{
			return false;
		}
		BaseEntity[] array = entities;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].prefabID == prefabId)
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

public class PreventBuildingMonumentTag : MonoBehaviour
{
	public bool autoFindMonument;

	[SerializeField]
	private MonumentInfo AttachedMonument;

	public MonumentInfo GetAttachedMonument()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (autoFindMonument && (Object)(object)AttachedMonument == (Object)null)
		{
			MonumentInfo attachedMonument = TerrainMeta.Path.FindClosest(TerrainMeta.Path.Monuments, ((Component)this).transform.position);
			AttachedMonument = attachedMonument;
		}
		return AttachedMonument;
	}

	public void SetMonument(MonumentInfo monument)
	{
		AttachedMonument = monument;
	}
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class DestroyOnGroundMissing : MonoBehaviour, IServerComponent
{
	private void OnGroundMissing()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = ((Component)this).gameObject.ToBaseEntity();
		if ((Object)(object)baseEntity != (Object)null && Interface.CallHook("OnEntityGroundMissing", (object)baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (Stability.log_ground_missing_death)
			{
				Debug.Log((object)$"Killing '{((object)baseEntity).ToString()}' at position {((Component)this).transform.position} due to ground missing");
			}
			if ((Object)(object)baseCombatEntity != (Object)null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}
}


using UnityEngine;

public class DetachMonumentChildren : MonoBehaviour
{
	private void Awake()
	{
		((Component)this).transform.DetachChildren();
	}
}


public class EffectBlood : EffectRecycle
{
	public GameObjectRef ReplacementEffect;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class EffectDictionary
{
	private static Dictionary<string, string[]> effectDictionary;

	public static string GetParticle(string impactType, string materialName)
	{
		return LookupEffect("impacts", impactType, materialName);
	}

	public static string GetParticle(DamageType damageType, string materialName)
	{
		return damageType switch
		{
			DamageType.Bullet => GetParticle("bullet", materialName), 
			DamageType.Arrow => GetParticle("bullet", materialName), 
			DamageType.Blunt => GetParticle("blunt", materialName), 
			DamageType.Slash => GetParticle("slash", materialName), 
			DamageType.Stab => GetParticle("stab", materialName), 
			DamageType.Paintball => GetParticle("paintball", materialName), 
			_ => GetParticle("blunt", materialName), 
		};
	}

	public static string GetDecal(string impactType, string materialName)
	{
		return LookupEffect("decals", impactType, materialName);
	}

	public static string GetDecal(DamageType damageType, string materialName)
	{
		return damageType switch
		{
			DamageType.Bullet => GetDecal("bullet", materialName), 
			DamageType.Arrow => GetDecal("bullet", materialName), 
			DamageType.Blunt => GetDecal("blunt", materialName), 
			DamageType.Slash => GetDecal("slash", materialName), 
			DamageType.Stab => GetDecal("stab", materialName), 
			DamageType.Paintball => GetDecal("paintball", materialName), 
			_ => GetDecal("blunt", materialName), 
		};
	}

	public static string GetDisplacement(string impactType, string materialName)
	{
		return LookupEffect("displacement", impactType, materialName);
	}

	private static string LookupEffect(string category, string effect, string material)
	{
		if (effectDictionary == null)
		{
			effectDictionary = GameManifest.LoadEffectDictionary();
		}
		string format = "assets/bundled/prefabs/fx/{0}/{1}/{2}";
		if (!effectDictionary.TryGetValue(StringFormatCache.Get(format, category, effect, material), out var value) && !effectDictionary.TryGetValue(StringFormatCache.Get(format, category, effect, "generic"), out value))
		{
			return string.Empty;
		}
		return value[Random.Range(0, value.Length)];
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class EffectRecycle : BaseMonoBehaviour, IClientComponent, IRagdollInhert, IEffectRecycle
{
	public enum PlayMode
	{
		Once,
		Looped
	}

	public enum ParentDestroyBehaviour
	{
		Detach,
		Destroy,
		DetachWaitDestroy
	}

	[ReadOnly]
	[FormerlySerializedAs("lifeTime")]
	public float detachTime;

	[ReadOnly]
	[FormerlySerializedAs("lifeTime")]
	public float recycleTime;

	public PlayMode playMode;

	public ParentDestroyBehaviour onParentDestroyed;

	[Range(1f, 50f)]
	public int WarmedUpAmount = 1;
}


public enum PlayMode
{
	Once,
	Looped
}


public enum ParentDestroyBehaviour
{
	Detach,
	Destroy,
	DetachWaitDestroy
}


public class EffectRecycleDetach : BaseMonoBehaviour, IClientComponent, IEffectRecycle
{
	public float recycleTime = 1f;
}


public class EffectRecycleLite : BasePrefab, IClientComponent, IEffectRecycle
{
	private const float lifeTime = 60f;
}


using UnityEngine;

public class EffectSilencerSelect : MonoBehaviour
{
	public GameObjectRef MilitaryEffect;

	public GameObjectRef OilFilterEffect;

	public GameObjectRef SodaCanEffect;

	public bool GetEffectForSilencerType(ProjectileWeaponMod.SilencerType silencerType, out GameObjectRef result)
	{
		result = null;
		switch (silencerType)
		{
		case ProjectileWeaponMod.SilencerType.Military:
			result = MilitaryEffect;
			break;
		case ProjectileWeaponMod.SilencerType.OilFilter:
			result = OilFilterEffect;
			break;
		case ProjectileWeaponMod.SilencerType.SodaCan:
			result = SodaCanEffect;
			break;
		}
		if (result != null)
		{
			return result.isValid;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using Development.Attributes;
using Facepunch;
using UnityEngine;

[ResetStaticFields]
public class EnvironmentManager : SingletonComponent<EnvironmentManager>
{
	private static ListHashSet<EnvironmentVolume> dynamicVolumes = new ListHashSet<EnvironmentVolume>();

	private static Collider[] check_colliderBuffer = (Collider[])(object)new Collider[32768];

	private void Update()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<EnvironmentVolume> enumerator = dynamicVolumes.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.UpdateVolumeTransformationAndBounds();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void RegisterDynamicVolume(EnvironmentVolume volume)
	{
		dynamicVolumes.Add(volume);
	}

	public void UnregisterDynamicVolume(EnvironmentVolume volume)
	{
		dynamicVolumes.Remove(volume);
	}

	public static EnvironmentType Get(OBB obb)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = (EnvironmentType)0;
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		GamePhysics.OverlapOBB<EnvironmentVolume>(obb, list, 262144, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			environmentType |= list[i].Type;
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return environmentType;
	}

	public static EnvironmentType Get(Vector3 pos, ref List<EnvironmentVolume> list, float radius = 0.01f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentType environmentType = (EnvironmentType)0;
		GamePhysics.OverlapSphere<EnvironmentVolume>(pos, radius, list, 262144, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			environmentType |= list[i].Type;
		}
		return environmentType;
	}

	public static EnvironmentType Get(Vector3 pos, float radius = 0.01f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		EnvironmentType result = Get(pos, ref list, radius);
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return result;
	}

	public static bool Check(OBB obb, EnvironmentType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		int num = GamePhysics.HandleIgnoreCollision(obb.position, 262144);
		int num2 = Physics.OverlapBoxNonAlloc(obb.position, obb.extents, check_colliderBuffer, obb.rotation, num, (QueryTriggerInteraction)2);
		EnvironmentVolume environmentVolume = default(EnvironmentVolume);
		for (int i = 0; i < num2; i++)
		{
			if (((Component)check_colliderBuffer[i]).TryGetComponent<EnvironmentVolume>(ref environmentVolume) && (environmentVolume.Type & type) != 0)
			{
				return true;
			}
		}
		return false;
	}

	public static bool Check(Vector3 pos, EnvironmentType type, float radius = 0.01f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		int num = GamePhysics.HandleIgnoreCollision(pos, 262144);
		int num2 = Physics.OverlapSphereNonAlloc(pos, radius, check_colliderBuffer, num, (QueryTriggerInteraction)2);
		EnvironmentVolume environmentVolume = default(EnvironmentVolume);
		for (int i = 0; i < num2; i++)
		{
			if (((Component)check_colliderBuffer[i]).TryGetComponent<EnvironmentVolume>(ref environmentVolume) && (environmentVolume.Type & type) != 0)
			{
				return true;
			}
		}
		return false;
	}
}


using System;

[Flags]
public enum EnvironmentType
{
	Underground = 1,
	Building = 2,
	Outdoor = 4,
	Elevator = 8,
	PlayerConstruction = 0x10,
	TrainTunnels = 0x20,
	UnderwaterLab = 0x40,
	Submarine = 0x80,
	BuildingDark = 0x100,
	BuildingVeryDark = 0x200,
	NoSunlight = 0x400,
	SpatiallyAware = 0x800,
	Entrance = 0x1000
}


using System;

[Flags]
public enum NetworkGroupType
{
	Cave = 1,
	TrainTunnels = 2,
	Canyon = 4
}


using System;
using System.Runtime.CompilerServices;
using Unity.Mathematics;
using UnityEngine;

[ExecuteInEditMode]
public class EnvironmentVolume : MonoBehaviour, IPrefabPreProcess
{
	public enum VolumeShape
	{
		Cube,
		Sphere,
		Capsule
	}

	private static readonly Vector3[] volumeCorners = (Vector3[])(object)new Vector3[8]
	{
		new Vector3(-0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, -0.5f, -0.5f),
		new Vector3(0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, 0.5f, -0.5f),
		new Vector3(-0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, -0.5f, 0.5f),
		new Vector3(0.5f, 0.5f, 0.5f),
		new Vector3(-0.5f, 0.5f, 0.5f)
	};

	[InspectorFlags]
	public EnvironmentType Type = EnvironmentType.Underground;

	[InspectorFlags]
	public NetworkGroupType NetworkType;

	public Vector3 Center = Vector3.zero;

	public Vector3 Size = Vector3.one;

	[NonSerialized]
	public float4x4 VolumeTransformation;

	[NonSerialized]
	public float4x4 VolumeTransformationInverse;

	[NonSerialized]
	public float3 VolumePosition;

	[NonSerialized]
	public Bounds VolumeBounds;

	[field: Tooltip("Controls the falloff amount of the positive axes of spatially aware volumes.")]
	[field: SerializeField]
	public Vector3 FalloffPositive { get; private set; } = Vector3.zero;

	[field: Tooltip("Controls the falloff amount of the negative axes of spatially aware volumes.")]
	[field: SerializeField]
	public Vector3 FalloffNegative { get; private set; } = Vector3.zero;

	[field: SerializeField]
	public VolumeShape SpatialVolumeShape { get; private set; }

	public float AmbientMultiplier { get; private set; }

	public float ReflectionMultiplier { get; private set; }

	public float CombinedMultiplier { get; private set; }

	public bool NoSunlight { get; private set; }

	public bool PropertiesCached { get; private set; }

	[field: SerializeField]
	public bool IsDynamic { get; private set; }

	public Collider trigger { get; private set; }

	public bool IsSpatialVolume => (Type & EnvironmentType.SpatiallyAware) != 0;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private void OnValidate()
	{
		PropertiesCached = false;
		UpdateVolumeTransformationAndBounds();
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside && IsSpatialVolume && !((Object)(object)((Component)this).gameObject == (Object)null) && (Object)(object)((Component)this).GetComponent<EnvironmentVolumeLOD>() == (Object)null)
		{
			((Component)this).gameObject.AddComponent<EnvironmentVolumeLOD>();
		}
	}

	protected void Awake()
	{
		UpdateTrigger();
	}

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)trigger) && !trigger.enabled)
		{
			trigger.enabled = true;
		}
		NetworkVisibilityGrid.RegisterEnvironmentVolume(this);
		UpdateVolumeTransformationAndBounds();
		if (IsDynamic && Object.op_Implicit((Object)(object)SingletonComponent<EnvironmentManager>.Instance))
		{
			SingletonComponent<EnvironmentManager>.Instance.RegisterDynamicVolume(this);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void UpdateVolumeTransformationAndBounds()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		EnvironmentVolumeMath.UpdateVolumeTransformationAndBoundsBurst(float3.op_Implicit(Size), float3.op_Implicit(Center), float4x4.op_Implicit(((Component)this).transform.localToWorldMatrix), IsSpatialVolume && SpatialVolumeShape == VolumeShape.Capsule, out VolumeTransformation, out VolumeTransformationInverse, out VolumePosition, out VolumeBounds);
	}

	protected void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)trigger) && trigger.enabled)
		{
			trigger.enabled = false;
		}
		if (IsDynamic && Object.op_Implicit((Object)(object)SingletonComponent<EnvironmentManager>.Instance))
		{
			SingletonComponent<EnvironmentManager>.Instance.UnregisterDynamicVolume(this);
		}
	}

	public void CacheVolumeProperties(EnvironmentVolumePropertiesCollection properties)
	{
		if (!PropertiesCached)
		{
			PropertiesCached = true;
			NoSunlight = (Type & EnvironmentType.NoSunlight) != 0 || (Type & EnvironmentType.TrainTunnels) != 0;
			CombinedMultiplier = AmbientMultiplier * ReflectionMultiplier;
		}
	}

	public void UpdateTrigger()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)trigger))
		{
			trigger = ((Component)this).gameObject.GetComponent<Collider>();
		}
		if (!Object.op_Implicit((Object)(object)trigger))
		{
			trigger = (Collider)(object)((Component)this).gameObject.AddComponent<BoxCollider>();
		}
		trigger.isTrigger = true;
		Collider obj = trigger;
		BoxCollider val = (BoxCollider)(object)((obj is BoxCollider) ? obj : null);
		if (Object.op_Implicit((Object)(object)val))
		{
			val.center = Center;
			val.size = Size;
		}
	}
}


public enum VolumeShape
{
	Cube,
	Sphere,
	Capsule
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class EnvironmentVolumeEx
{
	public static bool CheckEnvironmentVolumes(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		OBB obb = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			((OBB)(ref obb))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref obb)).Transform(pos, scale, rot);
			if (EnvironmentManager.Check(obb, type))
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return false;
	}

	public static bool CheckEnvironmentVolumes(this Transform transform, EnvironmentType type)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumes(transform.position, transform.rotation, transform.lossyScale, type);
	}

	public static bool CheckEnvironmentVolumesInsideTerrain(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			return true;
		}
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) == 0 || (environmentVolume.Type & typeIgnore) != 0)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref val)).Transform(pos, scale, rot);
			Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
			Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
			Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
			Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
			Bounds val2 = ((OBB)(ref val)).ToBounds();
			float max = ((Bounds)(ref val2)).max.y + padding;
			bool fail = false;
			TerrainMeta.HeightMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
			{
				if (TerrainMeta.HeightMap.GetHeight(x, z) <= max)
				{
					fail = true;
				}
			});
			if (fail)
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesInsideTerrain(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesInsideTerrain(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesOutsideTerrain(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float padding = 0f)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.HeightMap == (Object)null)
		{
			return true;
		}
		List<EnvironmentVolume> list = Pool.Get<List<EnvironmentVolume>>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) == 0 || (environmentVolume.Type & typeIgnore) != 0)
			{
				continue;
			}
			((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
			((OBB)(ref val)).Transform(pos, scale, rot);
			Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
			Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
			Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
			Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
			Bounds val2 = ((OBB)(ref val)).ToBounds();
			float min = ((Bounds)(ref val2)).min.y - padding;
			bool fail = false;
			TerrainMeta.HeightMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
			{
				if (TerrainMeta.HeightMap.GetHeight(x, z) >= min)
				{
					fail = true;
				}
			});
			if (fail)
			{
				Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesOutsideTerrain(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesOutsideTerrain(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesAboveAltitude(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.GetList<EnvironmentVolume>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeList<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) != 0 && (environmentVolume.Type & typeIgnore) == 0)
			{
				((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
				((OBB)(ref val)).Transform(pos, scale, rot);
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				if (((Bounds)(ref val2)).min.y <= altitude)
				{
					Pool.FreeList<EnvironmentVolume>(ref list);
					return false;
				}
			}
		}
		Pool.FreeList<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesAboveAltitude(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesAboveAltitude(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}

	public static bool CheckEnvironmentVolumesBelowAltitude(this Transform transform, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType typeRequire, EnvironmentType typeIgnore, float altitude = 0f)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		List<EnvironmentVolume> list = Pool.GetList<EnvironmentVolume>();
		((Component)transform).GetComponentsInChildren<EnvironmentVolume>(true, list);
		if (list.Count == 0)
		{
			Pool.FreeList<EnvironmentVolume>(ref list);
			return true;
		}
		OBB val = default(OBB);
		for (int i = 0; i < list.Count; i++)
		{
			EnvironmentVolume environmentVolume = list[i];
			if ((environmentVolume.Type & typeRequire) != 0 && (environmentVolume.Type & typeIgnore) == 0)
			{
				((OBB)(ref val))..ctor(((Component)environmentVolume).transform, new Bounds(environmentVolume.Center, environmentVolume.Size));
				((OBB)(ref val)).Transform(pos, scale, rot);
				Bounds val2 = ((OBB)(ref val)).ToBounds();
				if (((Bounds)(ref val2)).max.y >= altitude)
				{
					Pool.FreeList<EnvironmentVolume>(ref list);
					return false;
				}
			}
		}
		Pool.FreeList<EnvironmentVolume>(ref list);
		return true;
	}

	public static bool CheckEnvironmentVolumesBelowAltitude(this Transform transform, EnvironmentType typeRequire, EnvironmentType typeIgnore)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return transform.CheckEnvironmentVolumesBelowAltitude(transform.position, transform.rotation, transform.lossyScale, typeRequire, typeIgnore);
	}
}


