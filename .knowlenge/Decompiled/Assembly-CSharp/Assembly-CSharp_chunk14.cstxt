using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/Base Mission")]
public class BaseMission : BaseScriptableObject
{
	public class MissionInstance : IPooled
	{
		[Serializable]
		public class ObjectiveStatus : IPooled
		{
			public bool started;

			public bool softCompleted;

			public bool blockReset;

			public bool completed;

			public bool failed;

			public float progressTarget;

			public float progressCurrent;

			public Vector3 worldLocation;

			public RealTimeSince sinceLastThink;

			void IPooled.EnterPool()
			{
				Reset();
			}

			void IPooled.LeavePool()
			{
			}

			public void Reset()
			{
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				started = false;
				softCompleted = false;
				blockReset = false;
				completed = false;
				failed = false;
				progressTarget = 0f;
				progressCurrent = 0f;
				worldLocation = default(Vector3);
				sinceLastThink = default(RealTimeSince);
			}

			public bool IsObjectiveActive()
			{
				if (started && !completed)
				{
					return !failed;
				}
				return false;
			}

			public bool IsWorldPositionValid()
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_000e: Unknown result type (might be due to invalid IL or missing references)
				return worldLocation != default(Vector3);
			}
		}

		private IMissionProvider _cachedProvider;

		private BaseMission _cachedMission;

		public NetworkableId providerID;

		public uint missionID;

		public MissionStatus status;

		public long startTimeUtcSeconds;

		public long endTimeUtcSeconds;

		public float timePassed;

		public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

		public Dictionary<string, MissionEntity> spawnedMissionEntities = new Dictionary<string, MissionEntity>();

		public ListHashSet<BaseEntity> persistentMissionEntities = new ListHashSet<BaseEntity>();

		public bool hasDispensedRewards;

		private int playerInputCounter;

		public BufferList<ObjectiveStatus> objectiveStatuses = new BufferList<ObjectiveStatus>();

		public IMissionProvider GetMissionProvider()
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if (_cachedProvider == null)
			{
				_cachedProvider = BaseNetworkable.serverEntities.Find(providerID) as IMissionProvider;
			}
			return _cachedProvider;
		}

		public BaseMission GetMission()
		{
			TimeWarning val = TimeWarning.New("MissionInstance.GetMission", 0);
			try
			{
				if (_cachedMission == null)
				{
					_cachedMission = MissionManifest.GetFromID(missionID);
				}
				return _cachedMission;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public bool NeedsPlayerInput()
		{
			return playerInputCounter > 0;
		}

		public void EnablePlayerInput()
		{
			playerInputCounter++;
		}

		public void DisablePlayerInput()
		{
			playerInputCounter--;
			if (playerInputCounter < 0)
			{
				playerInputCounter = 0;
			}
		}

		public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
		{
			if (status == MissionStatus.Active)
			{
				BaseMission mission = GetMission();
				for (int i = 0; i < mission.objectives.Length; i++)
				{
					mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
				}
			}
		}

		public void ServerThink(BasePlayer assignee, float timeSinceLastThink)
		{
			MissionStatus missionStatus = status;
			if (missionStatus != 0 && missionStatus != MissionStatus.Failed && missionStatus != MissionStatus.Completed)
			{
				BaseMission mission = GetMission();
				timePassed = (float)(DateTimeOffset.UtcNow.ToUnixTimeSeconds() - startTimeUtcSeconds) * Time.missiontimerscale;
				mission.ServerThink(this, assignee, timeSinceLastThink);
				if (mission.timeLimitSeconds > 0 && timePassed >= (float)mission.timeLimitSeconds)
				{
					mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
				}
			}
		}

		public bool TryGetMissionPoint(string identifier, out Vector3 point, int depth = 0)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("MissionInstance.TryGetMissionPoint", 0);
			try
			{
				if (identifier == null)
				{
					identifier = string.Empty;
				}
				if (missionPoints.TryGetValue(identifier, out point))
				{
					return true;
				}
				BaseMission mission = GetMission();
				point = Vector3.zero;
				if (!mission.TryGetPositionGenerator(identifier, out var positionGenerator))
				{
					Debug.LogError((object)("Failure in TryGetMissionPoint on mission instance for " + ((Object)GetMission()).name + ", cannot find position generator for '" + identifier + "'"), (Object)(object)GetMission());
					return false;
				}
				if (!positionGenerator.TryGetPosition(this, out point, depth))
				{
					return false;
				}
				missionPoints.Add(identifier, point);
				if (positionGenerator.positionsAreExclusive)
				{
					AddPositionBlocker(this, point);
				}
				return true;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public MissionEntity GetSpawnedMissionEntity(string identifier, BasePlayer playerFor)
		{
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			if (identifier == null)
			{
				identifier = "";
			}
			MissionEntity value = null;
			if (spawnedMissionEntities.TryGetValue(identifier, out value))
			{
				return value;
			}
			MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().spawnMissionEntityDefinitions, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
			Vector3 point;
			if (missionEntityEntry == null)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
				value = null;
			}
			else if (!missionEntityEntry.entityRef.isValid)
			{
				Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
				value = null;
			}
			else if (TryGetMissionPoint(missionEntityEntry.spawnPositionToUse, out point))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, point, Quaternion.identity);
				MissionEntity missionEntity = default(MissionEntity);
				value = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
				value.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
				baseEntity.Spawn();
				if (baseEntity is LootContainer lootContainer && missionEntityEntry.overrideLootOnItem != null && missionEntityEntry.overrideLootOnItem.Length != 0)
				{
					lootContainer.inventory.Clear();
					ItemAmount[] overrideLootOnItem = missionEntityEntry.overrideLootOnItem;
					foreach (ItemAmount itemAmount in overrideLootOnItem)
					{
						lootContainer.inventory.AddItem(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
					}
				}
			}
			if ((Object)(object)value != (Object)null)
			{
				spawnedMissionEntities.Add(identifier, value);
				value.MissionStarted(playerFor, this);
			}
			return value;
		}

		public void PostServerLoad(BasePlayer player)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				if (i >= 0 && i < objectiveStatuses.Count)
				{
					mission.objectives[i].objective.PostServerLoad(i, this, player);
				}
			}
		}

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
		}

		public void Reset()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			RemovePositionBlockers(this);
			providerID = default(NetworkableId);
			missionID = 0u;
			status = MissionStatus.Undefined;
			startTimeUtcSeconds = long.MinValue;
			endTimeUtcSeconds = long.MinValue;
			_cachedMission = null;
			_cachedProvider = null;
			timePassed = 0f;
			missionPoints.Clear();
			spawnedMissionEntities.Clear();
			persistentMissionEntities.Clear();
			for (int i = 0; i < objectiveStatuses.Count; i++)
			{
				ObjectiveStatus objectiveStatus = objectiveStatuses[i];
				Pool.Free<ObjectiveStatus>(ref objectiveStatus);
			}
			objectiveStatuses.Clear();
			hasDispensedRewards = false;
		}

		public bool IsActive()
		{
			MissionStatus missionStatus = status;
			return missionStatus == MissionStatus.Accomplished || missionStatus == MissionStatus.Active;
		}

		public bool TryGetTotalRequiredRewardItemSlots(out int requiredSlots)
		{
			requiredSlots = 0;
			BaseMission mission = GetMission();
			int count = objectiveStatuses.Count;
			int num = mission.objectives.Length;
			if (count != num)
			{
				Debug.LogError((object)$"Mission instance for mission {((Object)mission).name} contains data for {count} objectives but mission has {num} objectives", (Object)(object)mission);
				return false;
			}
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				MissionObjectiveEntry missionObjectiveEntry = mission.objectives[i];
				if (missionObjectiveEntry.bonusRewards == null)
				{
					continue;
				}
				ObjectiveStatus objectiveStatus = objectiveStatuses[i];
				if (missionObjectiveEntry.isRequired || !objectiveStatus.completed)
				{
					continue;
				}
				foreach (MissionBonusReward bonusReward in missionObjectiveEntry.bonusRewards)
				{
					if (bonusReward.RewardType == RewardType.Item)
					{
						num2 += bonusReward.GetRequiredInventorySlots();
					}
				}
			}
			int num3 = 0;
			mission.TryGetRewardsForChoice(0, out var rewards);
			if (rewards != null)
			{
				foreach (MissionReward item in rewards)
				{
					if (item.RewardType == RewardType.Item)
					{
						num3 += item.GetRequiredInventorySlots();
					}
				}
			}
			requiredSlots = num3 + num2;
			return true;
		}
	}

	[Serializable]
	public class PositionGenerator
	{
		public enum RelativeType
		{
			Player,
			Provider,
			Position
		}

		public enum PositionType
		{
			MissionPoint,
			WorldPositionGenerator,
			DungeonPoint,
			Radius,
			UnderwaterLab,
			UnderwaterLabWithBoomboxes
		}

		public class PositionPointAttribute : PropertyAttribute
		{
		}

		public string identifier;

		public float minDistForMovePoint;

		public float maxDistForMovePoint = 25f;

		public bool allowDoubleDistanceIfNoOptionsAreFound;

		public bool positionsAreExclusive = true;

		public RelativeType relativeTo;

		public PositionType positionType;

		[PositionPoint]
		public string centerOnPositionIdentifier = "";

		[InspectorFlags]
		public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

		[InspectorFlags]
		public MissionPoint.MissionPointEnum ExclusionFlags;

		public WorldPositionGenerator worldPositionGenerator;

		private float minDistForMovePoint_2x;

		private float maxDistForMovePoint_2x;

		private float minDistForMovePoint_sqr;

		private float maxDistForMovePoint_sqr;

		private float maxDistForMovePoint_2x_sqr;

		public void CacheDistanceValues()
		{
			minDistForMovePoint_2x = minDistForMovePoint * 2f;
			maxDistForMovePoint_2x = maxDistForMovePoint * 2f;
			minDistForMovePoint_sqr = minDistForMovePoint * minDistForMovePoint;
			maxDistForMovePoint_sqr = maxDistForMovePoint * maxDistForMovePoint;
			maxDistForMovePoint_2x_sqr = maxDistForMovePoint_2x * maxDistForMovePoint_2x;
		}

		public bool TryGetPosition(MissionInstance instance, out Vector3 outPosition, int depth = 0)
		{
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01af: Unknown result type (might be due to invalid IL or missing references)
			//IL_026c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01db: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_020b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0217: Unknown result type (might be due to invalid IL or missing references)
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0417: Unknown result type (might be due to invalid IL or missing references)
			//IL_0381: Unknown result type (might be due to invalid IL or missing references)
			//IL_044f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0454: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_048c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0491: Unknown result type (might be due to invalid IL or missing references)
			//IL_049c: Unknown result type (might be due to invalid IL or missing references)
			//IL_049e: Unknown result type (might be due to invalid IL or missing references)
			//IL_04a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("PositionGenerator.TryGetPosition", 0);
			try
			{
				if (depth > 10)
				{
					Debug.Log((object)$"Exceeded max depth while calculating position, mission: {((Object)instance.GetMission()).name} missionID: {instance.missionID}, identifier: {identifier}");
					outPosition = Vector3.zero;
					return false;
				}
				Vector3 point;
				bool num = TryGetRelativeToPosition(instance, depth, out point);
				outPosition = point;
				if (!num)
				{
					Debug.LogError((object)("Failed to get relative to position for mission " + ((Object)instance.GetMission()).name), (Object)(object)instance.GetMission());
					return false;
				}
				switch (positionType)
				{
				case PositionType.MissionPoint:
				{
					List<Vector3> points = Pool.Get<List<Vector3>>();
					bool missionPoints = MissionPoint.GetMissionPoints(ref points, point, minDistForMovePoint_sqr, maxDistForMovePoint_sqr, (int)Flags, (int)ExclusionFlags);
					if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
					{
						points.Clear();
						missionPoints = MissionPoint.GetMissionPoints(ref points, point, minDistForMovePoint_sqr, maxDistForMovePoint_2x_sqr, (int)Flags, (int)ExclusionFlags);
					}
					if (missionPoints)
					{
						outPosition = points[Random.Range(0, points.Count)];
					}
					Pool.FreeUnmanaged<Vector3>(ref points);
					return missionPoints;
				}
				case PositionType.WorldPositionGenerator:
					if ((Object)(object)worldPositionGenerator != (Object)null)
					{
						for (int n = 0; n < 10; n++)
						{
							if (worldPositionGenerator.TrySample(point, minDistForMovePoint, maxDistForMovePoint, minDistForMovePoint_2x, maxDistForMovePoint_2x, checkBlockedPoints: true, out var position3) && TryAlignToGround(position3, out var correctedPosition2))
							{
								outPosition = correctedPosition2;
								return true;
							}
						}
						return false;
					}
					goto default;
				case PositionType.DungeonPoint:
					outPosition = DynamicDungeon.GetNextDungeonPoint();
					return true;
				case PositionType.Radius:
				{
					for (int m = 0; m < 10; m++)
					{
						Vector3 onUnitSphere = Random.onUnitSphere;
						onUnitSphere.y = 0f;
						((Vector3)(ref onUnitSphere)).Normalize();
						Vector3 val6 = point + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
						val6.y = WaterLevel.GetWaterOrTerrainSurface(val6, waves: false, volumes: false);
						if (TryAlignToGround(val6, out var correctedPosition))
						{
							outPosition = correctedPosition;
							return true;
						}
					}
					return false;
				}
				case PositionType.UnderwaterLab:
				{
					List<DungeonBaseInfo> dungeonBaseEntrances2 = TerrainMeta.Path.DungeonBaseEntrances;
					if (dungeonBaseEntrances2.Count > 0)
					{
						int index2 = Random.Range(0, dungeonBaseEntrances2.Count);
						outPosition = ((Component)dungeonBaseEntrances2[index2]).transform.position;
						return true;
					}
					return false;
				}
				case PositionType.UnderwaterLabWithBoomboxes:
				{
					List<DungeonBaseInfo> dungeonBaseEntrances = TerrainMeta.Path.DungeonBaseEntrances;
					int count = dungeonBaseEntrances.Count;
					if (count <= 0)
					{
						return false;
					}
					BaseMission mission = instance.GetMission();
					if (mission == null)
					{
						Debug.LogError((object)$"Failed to retrieve mission from mission instance with ID {instance.missionID}");
						return false;
					}
					MissionObjective_UnderwaterLabsBoomboxBonus missionObjective_UnderwaterLabsBoomboxBonus = null;
					for (int i = 0; i < mission.objectives.Length; i++)
					{
						if (mission.objectives[i].Get() is MissionObjective_UnderwaterLabsBoomboxBonus missionObjective_UnderwaterLabsBoomboxBonus2)
						{
							missionObjective_UnderwaterLabsBoomboxBonus = missionObjective_UnderwaterLabsBoomboxBonus2;
							break;
						}
					}
					if ((Object)(object)missionObjective_UnderwaterLabsBoomboxBonus == (Object)null)
					{
						Debug.LogError((object)("Failed to find lab boombox objective in mission " + ((Object)mission).name), (Object)(object)mission);
						return false;
					}
					int num2 = 0;
					if (string.IsNullOrWhiteSpace(missionObjective_UnderwaterLabsBoomboxBonus.requireProximityToPosition))
					{
						TimeWarning val2 = TimeWarning.New("PositionGenerator.TryGetPosition.UnderwaterLabWithBoomboxes.GetValidLabDistanceIrrespective", 0);
						try
						{
							for (int j = 0; j < DeployableBoomBox.ServerStaticInstances.Count; j++)
							{
								DeployableBoomBox deployableBoomBox = DeployableBoomBox.ServerStaticInstances[j];
								if (!((Object)(object)deployableBoomBox == (Object)null))
								{
									if (EnvironmentManager.Check(((Component)deployableBoomBox).transform.position, EnvironmentType.UnderwaterLab))
									{
										num2++;
									}
									if (num2 >= 2)
									{
										int index = Random.Range(0, count);
										outPosition = ((Component)dungeonBaseEntrances[index]).transform.position;
										return true;
									}
								}
							}
						}
						finally
						{
							((IDisposable)val2)?.Dispose();
						}
					}
					else
					{
						TimeWarning val3 = TimeWarning.New("PositionGenerator.TryGetPosition.UnderwaterLabWithBoomboxes.GetValidLab", 0);
						try
						{
							ListHashSet<Vector3> val4 = Pool.Get<ListHashSet<Vector3>>();
							for (int k = 0; k < count; k++)
							{
								val4.Add(((Component)dungeonBaseEntrances[k]).transform.position);
							}
							while (val4.Count > 0)
							{
								int num3 = Random.Range(0, val4.Count);
								Vector3 position = ((Component)dungeonBaseEntrances[num3]).transform.position;
								for (int l = 0; l < DeployableBoomBox.ServerStaticInstances.Count; l++)
								{
									TimeWarning val5 = TimeWarning.New("PositionGenerator.TryGetPosition.UnderwaterLabWithBoomboxes.CheckBoombox", 0);
									try
									{
										DeployableBoomBox deployableBoomBox2 = DeployableBoomBox.ServerStaticInstances[l];
										if ((Object)(object)deployableBoomBox2 == (Object)null)
										{
											continue;
										}
										Vector3 position2 = ((Component)deployableBoomBox2).transform.position;
										float sqrMinimumDistanceToMissionPoint = missionObjective_UnderwaterLabsBoomboxBonus.sqrMinimumDistanceToMissionPoint;
										if (!(Vector3.SqrMagnitude(position - position2) > sqrMinimumDistanceToMissionPoint))
										{
											if (EnvironmentManager.Check(((Component)deployableBoomBox2).transform.position, EnvironmentType.UnderwaterLab))
											{
												num2++;
											}
											if (num2 >= 2)
											{
												outPosition = position;
												Pool.FreeUnmanaged<Vector3>(ref val4);
												return true;
											}
										}
									}
									finally
									{
										((IDisposable)val5)?.Dispose();
									}
								}
								num2 = 0;
								val4.RemoveAt(num3);
							}
							Pool.FreeUnmanaged<Vector3>(ref val4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					return false;
				}
				default:
					Debug.LogError((object)$"Unhandled position generator type ({positionType}), defaulting to use {PositionType.Radius}");
					goto case PositionType.Radius;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		private bool TryGetRelativeToPosition(MissionInstance instance, int depth, out Vector3 point)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("PositionGenerator.TryGetRelativeToPosition", 0);
			try
			{
				switch (relativeTo)
				{
				case RelativeType.Position:
					if (instance.TryGetMissionPoint(centerOnPositionIdentifier, out point, depth + 1))
					{
						return true;
					}
					break;
				case RelativeType.Provider:
				{
					IMissionProvider missionProvider = instance.GetMissionProvider();
					if (missionProvider != null)
					{
						point = missionProvider.ProviderPosition();
						return true;
					}
					break;
				}
				}
				point = Vector3.zero;
				Debug.LogError((object)string.Format("Failed to get point for {0} {1}, outputting {2} as a fallback", "RelativeType", relativeTo, point));
				return false;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("WorldPositionGenerator.TryAlignToGround", 0);
			try
			{
				Vector3 val2 = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
				RaycastHit hit = default(RaycastHit);
				if (!Physics.Raycast(new Ray(val2, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
				{
					correctedPosition = wishPosition;
					return true;
				}
				if ((Object)(object)hit.GetEntity() != (Object)null)
				{
					correctedPosition = wishPosition;
					return false;
				}
				correctedPosition = ((RaycastHit)(ref hit)).point;
				return true;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	[Serializable]
	public class MissionDependancy
	{
		[FormerlySerializedAs("targetMission")]
		public BaseMission mission;

		[FormerlySerializedAs("targetMissionDesiredStatus")]
		[FilteredEnum(0, 4)]
		public MissionStatus desiredStatus;

		public uint missionID
		{
			get
			{
				if (!(mission == null))
				{
					return mission.id;
				}
				return 0u;
			}
		}
	}

	public enum MissionStatus
	{
		Undefined,
		Active,
		Accomplished,
		Failed,
		Completed,
		Pending
	}

	public enum MissionEventType
	{
		CUSTOM,
		HARVEST,
		CONVERSATION,
		KILL_ENTITY,
		ACQUIRE_ITEM,
		FREE_CRATE,
		MOUNT_ENTITY,
		HURT_ENTITY,
		PLAYER_TICK,
		CRAFT_ITEM,
		DEPLOY,
		HEAL,
		CLOTHINGCHANGED,
		STARTOVEN,
		CONSUME,
		ACQUITE_ITEM_STACK,
		OPEN_STORAGE,
		COOK,
		ENTER_TRIGGER,
		UPGRADE_BUILDING_GRADE,
		RESPAWN,
		METAL_DETECTOR_FIND,
		LONG_USE_OBJECT,
		PLAY_BOOMBOX
	}

	[Serializable]
	public class MissionObjectiveEntry
	{
		public Phrase description;

		public bool startAfterPriorObjectives;

		public int[] startAfterCompletedObjectives;

		public int[] autoCompleteOtherObjectives;

		public bool onlyProgressIfStarted = true;

		public bool isRequired = true;

		public MissionObjective objective;

		public string[] requiredEntities;

		public List<MissionBonusReward> bonusRewards;

		public MissionObjective Get()
		{
			return objective;
		}
	}

	public struct MissionEventPayload
	{
		public NetworkableId NetworkIdentifier;

		public uint UintIdentifier;

		public int IntIdentifier;

		public Vector3 WorldPosition;

		public string StringIdentifier;
	}

	public struct MissionIdentifierData : IEquatable<MissionIdentifierData>
	{
		public BaseMission mission;

		public NetworkableId missionProviderNetId;

		public MissionIdentifierData(BaseMission mission, NetworkableId missionProviderNetId)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.mission = mission;
			this.missionProviderNetId = missionProviderNetId;
		}

		public bool Equals(MissionIdentifierData other)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			if (mission.id == other.mission.id)
			{
				return missionProviderNetId == other.missionProviderNetId;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is MissionIdentifierData other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(mission.id, missionProviderNetId.Value);
		}
	}

	public struct MissionValidStateData
	{
		public MissionInstance missionInstance;

		public bool isValid;

		public int lastUpdateFrame;

		public MissionValidStateData(MissionInstance missionInstance, bool isValid, int lastUpdateFrame)
		{
			this.missionInstance = missionInstance;
			this.isValid = isValid;
			this.lastUpdateFrame = lastUpdateFrame;
		}
	}

	[Serializable]
	public class MissionEntityEntry
	{
		[FormerlySerializedAs("entityIdentifier")]
		public string identifier;

		public GameObjectRef entityRef;

		[PositionGenerator.PositionPoint]
		public string spawnPositionToUse;

		public bool spawnOnMissionStart = true;

		public bool cleanupOnMissionFailed;

		public bool cleanupOnMissionSuccess;

		public ItemAmount[] overrideLootOnItem;
	}

	[Serializable]
	public class MissionReward
	{
		public RewardType RewardType;

		public ItemAmount Item;

		public NonItemReward NonItem;

		public int GetRequiredInventorySlots()
		{
			return Mathf.CeilToInt(Item.GetAmount() / (float)Item.itemDef.stackable);
		}
	}

	[Serializable]
	public class MissionBonusReward : MissionReward
	{
		[Tooltip("If enabled, this reward will be dispensed for each amount the player got towards the target. Otherwise, this reward will only be dispensed once if the objective is fully complete.\nExample: if player achieved 2/3 for this bonus objective, then this reward will be dispensed 2 times.")]
		public bool isIncremental;
	}

	[Serializable]
	public class RewardsList
	{
		public List<MissionReward> rewards = new List<MissionReward>();
	}

	[Serializable]
	public class EraSpecificRewards
	{
		public Era[] eras;

		public List<RewardsList> rewardChoices = new List<RewardsList>();
	}

	[Serializable]
	public class NonItemReward
	{
		public Phrase DisplayPhrase;

		public Sprite DisplaySprite;

		public NonItemRewardType RewardType;
	}

	public enum NonItemRewardType
	{
		None,
		SafeZoneRespawnUnlock
	}

	public enum RewardType
	{
		Item,
		Other
	}

	public enum MissionFailReason
	{
		TimeOut,
		Disconnect,
		ResetPlayerState,
		Abandon,
		ObjectiveFailed,
		DeepSeaClosed
	}

	public class UpdateMissionValidStateWorkQueue : ObjectWorkQueue<MissionIdentifierData>
	{
		protected override void RunJob(MissionIdentifierData missionIdentifierData)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			missionIdentifierData.mission.Server_UpdateMissionValidState(missionIdentifierData.missionProviderNetId, out var _);
		}
	}

	public static readonly Phrase missionFailedPhrase = new Phrase("missionfailed.message", "You have failed the mission: {0}. Reason: {1}");

	public static readonly Phrase missionFailedReason_Timeout = new Phrase("missionfailed.reason.timeout", "Mission timeout");

	public static readonly Phrase missionFailedReason_Disconnect = new Phrase("missionfailed.reason.disconnect", "Disconnected");

	public static readonly Phrase missionFailedReason_PlayerStateReset = new Phrase("missionfailed.reason.playerstatereset", "Player state reset");

	public static readonly Phrase missionFailedReason_Abandon = new Phrase("missionfailed.reason.abandon", "Mission abandoned");

	public static readonly Phrase missionFailedReason_ObjectiveFailed = new Phrase("missionfailed.reason.objectivefailed", "Objective failed");

	public static readonly Phrase missionFailedReason_DeepSeaClosed = new Phrase("missionfailed.reason.deepseaclosed", "Deep sea closed");

	[ServerVar]
	public static bool missionsenabled = true;

	public static Dictionary<MissionIdentifierData, MissionValidStateData> server_missionInstanceValidStates = new Dictionary<MissionIdentifierData, MissionValidStateData>();

	public string shortname;

	private uint _id;

	private string previousShortname;

	public Phrase missionName;

	public Phrase missionDesc;

	public bool canBeAbandoned = true;

	public bool completeSilently;

	public string[] requiredGameModeTags = Array.Empty<string>();

	public MissionObjectiveEntry[] objectives;

	public static Dictionary<MissionInstance, ListHashSet<Vector3>> blockedPoints = new Dictionary<MissionInstance, ListHashSet<Vector3>>();

	public GameObjectRef acceptEffect;

	public GameObjectRef failedEffect;

	public GameObjectRef victoryEffect;

	public BaseMission followupMission;

	public int repeatDelaySecondsSuccess = -1;

	public int repeatDelaySecondsFailed = -1;

	public int timeLimitSeconds;

	[FormerlySerializedAs("hideStagesNotStarted")]
	public bool hideObjectivesNotStarted;

	[FormerlySerializedAs("acceptDependancies")]
	public MissionDependancy[] prerequisiteMissions;

	[FormerlySerializedAs("missionEntities")]
	public MissionEntityEntry[] spawnMissionEntityDefinitions;

	public PositionGenerator[] positionGenerators;

	private Dictionary<string, PositionGenerator> positionGeneratorMap;

	public List<RewardsList> defaultRewardChoices = new List<RewardsList>();

	public List<EraSpecificRewards> eraSpecificRewardChoices = new List<EraSpecificRewards>();

	[ServerVar(Help = "How long per frame (ms) to spend processing which missions are valid", Saved = true, ShowInAdminUI = true)]
	public static float missionValidStateWorkQueueBudget = 0.1f;

	public static UpdateMissionValidStateWorkQueue updateMissionValidStateWorkQueue = new UpdateMissionValidStateWorkQueue();

	public static ListHashSet<MissionIdentifierData> validStatesToProcess = new ListHashSet<MissionIdentifierData>();

	public uint id
	{
		get
		{
			if (previousShortname != shortname)
			{
				previousShortname = shortname;
				_id = StringEx.ManifestHash(shortname);
			}
			return _id;
		}
	}

	public bool isRepeatable
	{
		get
		{
			if (repeatDelaySecondsSuccess < 0)
			{
				return repeatDelaySecondsFailed >= 0;
			}
			return true;
		}
	}

	public static Phrase GetPhraseForFailureReason(MissionFailReason reason)
	{
		return (Phrase)(reason switch
		{
			MissionFailReason.TimeOut => missionFailedReason_Timeout, 
			MissionFailReason.Disconnect => missionFailedReason_Disconnect, 
			MissionFailReason.ResetPlayerState => missionFailedReason_PlayerStateReset, 
			MissionFailReason.Abandon => missionFailedReason_Abandon, 
			MissionFailReason.ObjectiveFailed => missionFailedReason_ObjectiveFailed, 
			MissionFailReason.DeepSeaClosed => missionFailedReason_DeepSeaClosed, 
			_ => Phrase.op_Implicit($"Unhandled reason: {reason}"), 
		});
	}

	public static void PlayerDisconnected(BasePlayer player)
	{
		if (!player.IsNpc && player.TryGetActiveMissionInstance(out var instance))
		{
			BaseMission mission = instance.GetMission();
			if (mission.spawnMissionEntityDefinitions.Length != 0)
			{
				mission.MissionFailed(instance, player, MissionFailReason.Disconnect);
			}
		}
	}

	private void OnEnable()
	{
		PositionGenerator[] array = positionGenerators;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].CacheDistanceValues();
		}
	}

	public bool TryGetPositionGenerator(string identifier, out PositionGenerator positionGenerator)
	{
		if (positionGeneratorMap == null)
		{
			positionGeneratorMap = new Dictionary<string, PositionGenerator>();
			PositionGenerator[] array = positionGenerators;
			foreach (PositionGenerator positionGenerator2 in array)
			{
				positionGeneratorMap.Add(positionGenerator2.identifier, positionGenerator2);
			}
		}
		positionGenerator = null;
		return positionGeneratorMap.TryGetValue(identifier, out positionGenerator);
	}

	public List<RewardsList> GetRewardChoices()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Invalid comparison between Unknown and I4
		if ((int)ConVar.Server.Era == 0)
		{
			return defaultRewardChoices;
		}
		if (eraSpecificRewardChoices != null)
		{
			foreach (EraSpecificRewards eraSpecificRewardChoice in eraSpecificRewardChoices)
			{
				if (eraSpecificRewardChoice.eras == null)
				{
					continue;
				}
				Era[] eras = eraSpecificRewardChoice.eras;
				foreach (Era val in eras)
				{
					if ((val == ConVar.Server.Era || (int)val == 1) && eraSpecificRewardChoice.rewardChoices != null)
					{
						return eraSpecificRewardChoice.rewardChoices;
					}
				}
			}
		}
		return defaultRewardChoices;
	}

	public bool HasRewards()
	{
		List<RewardsList> rewardChoices = GetRewardChoices();
		for (int i = 0; i < rewardChoices.Count; i++)
		{
			if (rewardChoices[i].rewards.Count > 0)
			{
				return true;
			}
		}
		return false;
	}

	public bool TryGetRewardsForChoice(int choice, out List<MissionReward> rewards)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Invalid comparison between Unknown and I4
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		rewards = null;
		if ((int)ConVar.Server.Era == 0)
		{
			return TryGetDefaultRewardsForChoice(choice, out rewards);
		}
		if (eraSpecificRewardChoices != null)
		{
			foreach (EraSpecificRewards eraSpecificRewardChoice in eraSpecificRewardChoices)
			{
				if (eraSpecificRewardChoice.eras == null)
				{
					continue;
				}
				Era[] eras = eraSpecificRewardChoice.eras;
				foreach (Era val in eras)
				{
					if ((val == ConVar.Server.Era || (int)val == 1) && eraSpecificRewardChoice.rewardChoices != null)
					{
						if (choice < 0 || choice >= eraSpecificRewardChoice.rewardChoices.Count)
						{
							Debug.LogError((object)$"Cannot retrieve {val} era mission rewards from mission {((Object)this).name} for choice ({choice}) as this is out of bounds of choices count ({eraSpecificRewardChoice.rewardChoices.Count})", (Object)(object)this);
							return false;
						}
						rewards = eraSpecificRewardChoice.rewardChoices[choice].rewards;
						return rewards != null && rewards.Count > 0;
					}
				}
			}
		}
		return TryGetDefaultRewardsForChoice(choice, out rewards);
	}

	private bool TryGetDefaultRewardsForChoice(int choice, out List<MissionReward> rewards)
	{
		rewards = null;
		if (defaultRewardChoices == null || defaultRewardChoices.Count == 0)
		{
			return false;
		}
		if (choice < 0 || choice >= defaultRewardChoices.Count)
		{
			Debug.LogError((object)$"Cannot retrieve mission rewards from mission {((Object)this).name} for choice ({choice}) as this is out of bounds of choices count ({defaultRewardChoices.Count})", (Object)(object)this);
			return false;
		}
		rewards = defaultRewardChoices[choice].rewards;
		if (rewards != null)
		{
			return rewards.Count > 0;
		}
		return false;
	}

	public void Server_UpdateMissionValidState(NetworkableId providerNetId, out bool isValid)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseMission.Server_IsMissionValid", 0);
		try
		{
			MissionIdentifierData missionIdentifierData = new MissionIdentifierData(this, providerNetId);
			validStatesToProcess.Remove(missionIdentifierData);
			if (server_missionInstanceValidStates.TryGetValue(missionIdentifierData, out var value))
			{
				if (value.lastUpdateFrame == Time.frameCount)
				{
					isValid = value.isValid;
					return;
				}
				Pool.Free<MissionInstance>(ref value.missionInstance);
			}
			MissionInstance missionInstance = Pool.Get<MissionInstance>();
			missionInstance.providerID = new NetworkableId(providerNetId.Value);
			missionInstance.missionID = id;
			missionInstance.status = MissionStatus.Pending;
			server_missionInstanceValidStates[missionIdentifierData] = new MissionValidStateData(missionInstance, isValid: false, Time.frameCount);
			isValid = false;
			if (!missionsenabled)
			{
				return;
			}
			TimeWarning val2 = TimeWarning.New("BaseMission.Server_IsMissionValid - gamemode", 0);
			try
			{
				BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
				if ((Object)(object)activeGameMode != (Object)null && (activeGameMode.HasBlockedMission(this) || (requiredGameModeTags.Length != 0 && !activeGameMode.HasAnyGameModeTag(requiredGameModeTags))))
				{
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("BaseMission.Server_IsMissionValid - positionGenerators", 0);
			try
			{
				PositionGenerator[] array = positionGenerators;
				foreach (PositionGenerator positionGenerator in array)
				{
					if (!positionGenerator.TryGetPosition(missionInstance, out var outPosition))
					{
						blockedPoints.Remove(missionInstance);
						return;
					}
					missionInstance.missionPoints.Add(positionGenerator.identifier, outPosition);
					if (positionGenerator.positionsAreExclusive)
					{
						AddPositionBlocker(missionInstance, outPosition);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("BaseMission.Server_IsMissionValid - objectives", 0);
			try
			{
				for (int j = 0; j < objectives.Length; j++)
				{
					if (!objectives[j].Get().IsObjectiveValid(j, missionInstance))
					{
						blockedPoints.Remove(missionInstance);
						return;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			server_missionInstanceValidStates[missionIdentifierData] = new MissionValidStateData(missionInstance, isValid: true, Time.frameCount);
			isValid = true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void AddPositionBlocker(MissionInstance missionInstance, Vector3 point)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (missionInstance.status != MissionStatus.Pending && !missionInstance.IsActive())
		{
			Debug.LogError((object)$"Cannot add point {point} for mission {((Object)missionInstance.GetMission()).name} to blocked points due to status being: {missionInstance.status}", (Object)(object)missionInstance.GetMission());
			return;
		}
		if (!blockedPoints.TryGetValue(missionInstance, out var value) || value == null)
		{
			blockedPoints[missionInstance] = Pool.Get<ListHashSet<Vector3>>();
		}
		blockedPoints[missionInstance].TryAdd(point);
	}

	public static void RemovePositionBlockers(MissionInstance missionInstance)
	{
		if (blockedPoints.TryGetValue(missionInstance, out var value))
		{
			Pool.FreeUnmanaged<Vector3>(ref value);
			blockedPoints.Remove(missionInstance);
		}
	}

	public static void DoMissionEffect(string effectString, BasePlayer assignee)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Effect effect = new Effect();
		effect.Init(Effect.Type.Generic, assignee, StringPool.Get("head"), Vector3.zero, Vector3.forward);
		effect.pooledString = effectString;
		EffectNetwork.Send(effect, assignee.net.connection);
	}

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", (object)this, (object)instance, (object)assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = spawnMissionEntityDefinitions;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetSpawnedMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		Interface.CallHook("OnMissionStarted", (object)this, (object)instance, (object)assignee);
	}

	public void CheckObjectives(MissionInstance instance, BasePlayer assignee)
	{
		if (instance.status != MissionStatus.Active)
		{
			return;
		}
		bool flag = true;
		for (int i = 0; i < objectives.Length; i++)
		{
			if (instance.objectiveStatuses[i].failed && objectives[i].isRequired)
			{
				MissionFailed(instance, assignee, MissionFailReason.ObjectiveFailed);
				break;
			}
			if (flag && objectives[i].isRequired && (!instance.objectiveStatuses[i].completed || instance.objectiveStatuses[i].failed))
			{
				flag = false;
			}
		}
		if (flag)
		{
			MissionSuccess(instance, assignee);
		}
	}

	public virtual void ServerThink(MissionInstance instance, BasePlayer assignee, float timeSinceLastThink)
	{
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().ServerThink(i, instance, assignee, timeSinceLastThink);
		}
		CheckObjectives(instance, assignee);
		assignee.SaveMissionsIfDirty();
	}

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", (object)this, (object)instance, (object)assignee);
	}

	public virtual void MissionComplete(MissionInstance instance, BasePlayer assignee)
	{
		DoMissionEffect(victoryEffect.resourcePath, assignee);
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have completed the mission : " + missionName.english);
		}
		BaseMission mission = instance.GetMission();
		if (mission != null)
		{
			if (mission.GetRewardChoices().Count == 1)
			{
				DispenseRewards(instance, assignee, 0);
			}
			for (int i = 0; i < objectives.Length; i++)
			{
				MissionObjectiveEntry missionObjectiveEntry = objectives[i];
				MissionInstance.ObjectiveStatus objectiveStatus = instance.objectiveStatuses[i];
				if (missionObjectiveEntry.isRequired || missionObjectiveEntry.bonusRewards == null || objectiveStatus.failed)
				{
					continue;
				}
				foreach (MissionBonusReward bonusReward in missionObjectiveEntry.bonusRewards)
				{
					if (bonusReward.isIncremental && objectiveStatus.progressCurrent > 0f && objectiveStatus.progressTarget > 0f)
					{
						int num = Mathf.FloorToInt(objectiveStatus.progressCurrent);
						for (int j = 0; j < num; j++)
						{
							DispenseReward(assignee, bonusReward);
						}
					}
					else if (instance.objectiveStatuses[i].completed)
					{
						DispenseReward(assignee, bonusReward);
					}
				}
			}
		}
		Analytics.Azure.OnMissionComplete(assignee, this, null);
		instance.status = MissionStatus.Completed;
		assignee.SetActiveMissionIndex(-1);
		assignee.MissionsDirty(saveImmediately: true);
		if (followupMission != null)
		{
			IMissionProvider missionProvider = instance.GetMissionProvider();
			if (missionProvider == null)
			{
				Debug.LogError((object)("Failed to retrieve mission provider on instance for mission " + ((Object)instance.GetMission()).name));
			}
			else
			{
				assignee.RegisterFollowupMission(followupMission, missionProvider);
			}
		}
		if (GameInfo.HasAchievements && mission != null && !(mission is TutorialMission))
		{
			assignee.stats.Add("missions_completed", 1, Stats.All);
			assignee.stats.Save(forceSteamSave: true);
		}
		if (assignee.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null && currentTutorialIsland.FinalMission == this)
			{
				currentTutorialIsland.StartEndingCinematic(assignee);
			}
		}
		if (!completeSilently)
		{
			assignee.ClientRPC(RpcTarget.Player("Client_MissionComplete", assignee), id);
		}
	}

	public virtual void DispenseRewards(MissionInstance instance, BasePlayer assignee, int choice)
	{
		MissionStatus status = instance.status;
		bool flag = status == MissionStatus.Accomplished || status == MissionStatus.Completed;
		if (instance.hasDispensedRewards || !flag)
		{
			return;
		}
		instance.hasDispensedRewards = true;
		assignee.MissionsDirty();
		if (TryGetRewardsForChoice(choice, out var rewards))
		{
			for (int i = 0; i < rewards.Count; i++)
			{
				MissionReward reward = rewards[i];
				DispenseReward(assignee, reward);
			}
		}
	}

	private void DispenseReward(BasePlayer assignee, MissionReward reward)
	{
		switch (reward.RewardType)
		{
		case RewardType.Item:
			GiveItemReward(assignee, reward.Item);
			break;
		case RewardType.Other:
		{
			if (reward.NonItem.RewardType != NonItemRewardType.SafeZoneRespawnUnlock)
			{
				break;
			}
			using HashSet<StaticRespawnArea>.Enumerator enumerator = StaticRespawnArea.staticRespawnAreas.GetEnumerator();
			if (enumerator.MoveNext())
			{
				enumerator.Current.Authorize(assignee.userID);
				assignee.SendRespawnOptions();
			}
			break;
		}
		}
	}

	private void GiveItemReward(BasePlayer player, ItemAmount reward)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)reward.itemDef == (Object)null || reward.amount == 0f)
		{
			Debug.LogError((object)"BIG REWARD SCREWUP, NULL ITEM DEF");
			return;
		}
		if (!reward.itemDef.IsAllowed((EraRestriction)8))
		{
			Debug.LogError((object)$"Blocking mission reward '{reward.itemDef.shortname}' not allowed in era '{ConVar.Server.Era}'");
			return;
		}
		Item item = (reward.isBP ? ItemManager.Create(ItemManager.blueprintBaseDef, Mathf.CeilToInt(reward.amount), 0uL) : ItemManager.Create(reward.itemDef, Mathf.CeilToInt(reward.amount), 0uL));
		if (item == null)
		{
			return;
		}
		if (reward.isBP)
		{
			item.blueprintTarget = reward.itemDef.itemid;
		}
		int num = item.MaxStackable();
		if (num > 0)
		{
			while (item.amount > num)
			{
				Item item2 = item.SplitItem(item.MaxStackable());
				if (item2 == null)
				{
					break;
				}
				item2.SetItemOwnership(player, ItemOwnershipPhrases.MissionRewardPhrase);
				player.GiveItem(item2, BaseEntity.GiveItemReason.PickedUp);
			}
		}
		item.SetItemOwnership(player, ItemOwnershipPhrases.MissionRewardPhrase);
		player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
	}

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason, bool saveImmediately = true)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.Server_SendMissionFailed(instance.missionID, failReason);
			if (failReason != MissionFailReason.ResetPlayerState)
			{
				DoMissionEffect(failedEffect.resourcePath, assignee);
			}
		}
		Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", (object)this, (object)instance, (object)assignee, (object)failReason);
		assignee.MissionsDirty(saveImmediately);
	}

	public virtual void MissionEnded(MissionInstance instance, BasePlayer assignee)
	{
		instance.endTimeUtcSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
		if (instance.spawnedMissionEntities != null)
		{
			List<MissionEntity> list = Pool.Get<List<MissionEntity>>();
			foreach (MissionEntity value in instance.spawnedMissionEntities.Values)
			{
				if (!((Object)(object)value == (Object)null))
				{
					list.Add(value);
				}
			}
			for (int i = 0; i < list.Count; i++)
			{
				list[i].MissionEnded(assignee, instance);
			}
			Pool.FreeUnmanaged<MissionEntity>(ref list);
		}
		RemovePositionBlockers(instance);
		assignee.SetActiveMissionIndex(-1);
	}

	public void OnObjectiveCompleted(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		if (objectiveIndex < 0 || objectiveIndex >= objectives.Length)
		{
			Debug.LogError((object)$"Objective index {objectiveIndex} is invalid, mission {((Object)this).name} has {objectives.Length} objectives");
			return;
		}
		MissionObjectiveEntry missionObjectiveEntry = objectives[objectiveIndex];
		if (missionObjectiveEntry.autoCompleteOtherObjectives.Length != 0)
		{
			for (int i = 0; i < missionObjectiveEntry.autoCompleteOtherObjectives.Length; i++)
			{
				int num = missionObjectiveEntry.autoCompleteOtherObjectives[i];
				MissionObjectiveEntry missionObjectiveEntry2 = objectives[num];
				MissionInstance.ObjectiveStatus objectiveStatus = instance.objectiveStatuses[num];
				objectiveStatus.blockReset = true;
				if (!objectiveStatus.completed)
				{
					missionObjectiveEntry2.objective.CompleteObjective(num, instance, playerFor);
				}
			}
		}
		CheckObjectives(instance, playerFor);
	}

	public void OnObjectiveFailed(int objectiveIndex, MissionInstance instance, BasePlayer playerFor)
	{
		CheckObjectives(instance, playerFor);
	}

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (!missionsenabled)
		{
			return false;
		}
		if (!assignee.Server_CanAcceptMission(provider.ProviderID(), mission))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", (object)assignee, (object)mission, (object)provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!server_missionInstanceValidStates.TryGetValue(new MissionIdentifierData(mission, provider.ProviderID()), out var value))
		{
			return false;
		}
		MissionInstance missionInstance = null;
		int num = -1;
		for (int i = 0; i < assignee.acceptedMissions.Count; i++)
		{
			MissionInstance missionInstance2 = assignee.acceptedMissions[i];
			if (mission.id == missionInstance2.missionID)
			{
				num = i;
				break;
			}
		}
		int activeMissionIndex;
		if (num >= 0)
		{
			missionInstance = assignee.acceptedMissions[num];
			activeMissionIndex = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMissionIndex = assignee.acceptedMissions.Count;
			assignee.acceptedMissions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTimeUtcSeconds = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		foreach (KeyValuePair<string, Vector3> missionPoint in value.missionInstance.missionPoints)
		{
			string key = missionPoint.Key;
			Vector3 value2 = missionPoint.Value;
			missionInstance.missionPoints.Add(key, value2);
			if (mission.TryGetPositionGenerator(key, out var positionGenerator) && positionGenerator.positionsAreExclusive)
			{
				AddPositionBlocker(missionInstance, value2);
			}
		}
		mission.Server_UpdateMissionValidState(provider.ProviderID(), out var _);
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			MissionInstance.ObjectiveStatus objectiveStatus = Pool.Get<MissionInstance.ObjectiveStatus>();
			missionInstance.objectiveStatuses.Add(objectiveStatus);
		}
		if (missionInstance.objectiveStatuses.Count != mission.objectives.Length)
		{
			Debug.LogError((object)$"New mission instance for {((Object)mission).name} has {missionInstance.objectiveStatuses.Count} objective statuses but mission has {mission.objectives.Length} objectives", (Object)(object)mission);
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMissionIndex(activeMissionIndex);
		assignee.MissionsDirty(saveImmediately: true);
		Interface.CallHook("OnMissionAssigned", (object)mission, (object)provider, (object)assignee);
		return true;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class MissionInstance : IPooled
{
	[Serializable]
	public class ObjectiveStatus : IPooled
	{
		public bool started;

		public bool softCompleted;

		public bool blockReset;

		public bool completed;

		public bool failed;

		public float progressTarget;

		public float progressCurrent;

		public Vector3 worldLocation;

		public RealTimeSince sinceLastThink;

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
		}

		public void Reset()
		{
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			started = false;
			softCompleted = false;
			blockReset = false;
			completed = false;
			failed = false;
			progressTarget = 0f;
			progressCurrent = 0f;
			worldLocation = default(Vector3);
			sinceLastThink = default(RealTimeSince);
		}

		public bool IsObjectiveActive()
		{
			if (started && !completed)
			{
				return !failed;
			}
			return false;
		}

		public bool IsWorldPositionValid()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			return worldLocation != default(Vector3);
		}
	}

	private IMissionProvider _cachedProvider;

	private BaseMission _cachedMission;

	public NetworkableId providerID;

	public uint missionID;

	public MissionStatus status;

	public long startTimeUtcSeconds;

	public long endTimeUtcSeconds;

	public float timePassed;

	public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

	public Dictionary<string, MissionEntity> spawnedMissionEntities = new Dictionary<string, MissionEntity>();

	public ListHashSet<BaseEntity> persistentMissionEntities = new ListHashSet<BaseEntity>();

	public bool hasDispensedRewards;

	private int playerInputCounter;

	public BufferList<ObjectiveStatus> objectiveStatuses = new BufferList<ObjectiveStatus>();

	public IMissionProvider GetMissionProvider()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (_cachedProvider == null)
		{
			_cachedProvider = BaseNetworkable.serverEntities.Find(providerID) as IMissionProvider;
		}
		return _cachedProvider;
	}

	public BaseMission GetMission()
	{
		TimeWarning val = TimeWarning.New("MissionInstance.GetMission", 0);
		try
		{
			if (_cachedMission == null)
			{
				_cachedMission = MissionManifest.GetFromID(missionID);
			}
			return _cachedMission;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool NeedsPlayerInput()
	{
		return playerInputCounter > 0;
	}

	public void EnablePlayerInput()
	{
		playerInputCounter++;
	}

	public void DisablePlayerInput()
	{
		playerInputCounter--;
		if (playerInputCounter < 0)
		{
			playerInputCounter = 0;
		}
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, MissionEventPayload payload, float amount)
	{
		if (status == MissionStatus.Active)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, payload, amount);
			}
		}
	}

	public void ServerThink(BasePlayer assignee, float timeSinceLastThink)
	{
		MissionStatus missionStatus = status;
		if (missionStatus != 0 && missionStatus != MissionStatus.Failed && missionStatus != MissionStatus.Completed)
		{
			BaseMission mission = GetMission();
			timePassed = (float)(DateTimeOffset.UtcNow.ToUnixTimeSeconds() - startTimeUtcSeconds) * Time.missiontimerscale;
			mission.ServerThink(this, assignee, timeSinceLastThink);
			if (mission.timeLimitSeconds > 0 && timePassed >= (float)mission.timeLimitSeconds)
			{
				mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
			}
		}
	}

	public bool TryGetMissionPoint(string identifier, out Vector3 point, int depth = 0)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MissionInstance.TryGetMissionPoint", 0);
		try
		{
			if (identifier == null)
			{
				identifier = string.Empty;
			}
			if (missionPoints.TryGetValue(identifier, out point))
			{
				return true;
			}
			BaseMission mission = GetMission();
			point = Vector3.zero;
			if (!mission.TryGetPositionGenerator(identifier, out var positionGenerator))
			{
				Debug.LogError((object)("Failure in TryGetMissionPoint on mission instance for " + ((Object)GetMission()).name + ", cannot find position generator for '" + identifier + "'"), (Object)(object)GetMission());
				return false;
			}
			if (!positionGenerator.TryGetPosition(this, out point, depth))
			{
				return false;
			}
			missionPoints.Add(identifier, point);
			if (positionGenerator.positionsAreExclusive)
			{
				AddPositionBlocker(this, point);
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public MissionEntity GetSpawnedMissionEntity(string identifier, BasePlayer playerFor)
	{
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		if (identifier == null)
		{
			identifier = "";
		}
		MissionEntity value = null;
		if (spawnedMissionEntities.TryGetValue(identifier, out value))
		{
			return value;
		}
		MissionEntityEntry missionEntityEntry = List.FindWith<MissionEntityEntry, string>((IReadOnlyCollection<MissionEntityEntry>)(object)GetMission().spawnMissionEntityDefinitions, (Func<MissionEntityEntry, string>)((MissionEntityEntry e) => e.identifier), identifier, (IEqualityComparer<string>)null);
		Vector3 point;
		if (missionEntityEntry == null)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' not found in mission ID {missionID}");
			value = null;
		}
		else if (!missionEntityEntry.entityRef.isValid)
		{
			Debug.LogError((object)$"Cannot spawn mission entity, identifier '{identifier}' has no entity set in mission ID {missionID}");
			value = null;
		}
		else if (TryGetMissionPoint(missionEntityEntry.spawnPositionToUse, out point))
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, point, Quaternion.identity);
			MissionEntity missionEntity = default(MissionEntity);
			value = (((Component)baseEntity).gameObject.TryGetComponent<MissionEntity>(ref missionEntity) ? missionEntity : ((Component)baseEntity).gameObject.AddComponent<MissionEntity>());
			value.Setup(playerFor, this, identifier, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
			baseEntity.Spawn();
			if (baseEntity is LootContainer lootContainer && missionEntityEntry.overrideLootOnItem != null && missionEntityEntry.overrideLootOnItem.Length != 0)
			{
				lootContainer.inventory.Clear();
				ItemAmount[] overrideLootOnItem = missionEntityEntry.overrideLootOnItem;
				foreach (ItemAmount itemAmount in overrideLootOnItem)
				{
					lootContainer.inventory.AddItem(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
				}
			}
		}
		if ((Object)(object)value != (Object)null)
		{
			spawnedMissionEntities.Add(identifier, value);
			value.MissionStarted(playerFor, this);
		}
		return value;
	}

	public void PostServerLoad(BasePlayer player)
	{
		BaseMission mission = GetMission();
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			if (i >= 0 && i < objectiveStatuses.Count)
			{
				mission.objectives[i].objective.PostServerLoad(i, this, player);
			}
		}
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
	}

	public void Reset()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		RemovePositionBlockers(this);
		providerID = default(NetworkableId);
		missionID = 0u;
		status = MissionStatus.Undefined;
		startTimeUtcSeconds = long.MinValue;
		endTimeUtcSeconds = long.MinValue;
		_cachedMission = null;
		_cachedProvider = null;
		timePassed = 0f;
		missionPoints.Clear();
		spawnedMissionEntities.Clear();
		persistentMissionEntities.Clear();
		for (int i = 0; i < objectiveStatuses.Count; i++)
		{
			ObjectiveStatus objectiveStatus = objectiveStatuses[i];
			Pool.Free<ObjectiveStatus>(ref objectiveStatus);
		}
		objectiveStatuses.Clear();
		hasDispensedRewards = false;
	}

	public bool IsActive()
	{
		MissionStatus missionStatus = status;
		return missionStatus == MissionStatus.Accomplished || missionStatus == MissionStatus.Active;
	}

	public bool TryGetTotalRequiredRewardItemSlots(out int requiredSlots)
	{
		requiredSlots = 0;
		BaseMission mission = GetMission();
		int count = objectiveStatuses.Count;
		int num = mission.objectives.Length;
		if (count != num)
		{
			Debug.LogError((object)$"Mission instance for mission {((Object)mission).name} contains data for {count} objectives but mission has {num} objectives", (Object)(object)mission);
			return false;
		}
		int num2 = 0;
		for (int i = 0; i < num; i++)
		{
			MissionObjectiveEntry missionObjectiveEntry = mission.objectives[i];
			if (missionObjectiveEntry.bonusRewards == null)
			{
				continue;
			}
			ObjectiveStatus objectiveStatus = objectiveStatuses[i];
			if (missionObjectiveEntry.isRequired || !objectiveStatus.completed)
			{
				continue;
			}
			foreach (MissionBonusReward bonusReward in missionObjectiveEntry.bonusRewards)
			{
				if (bonusReward.RewardType == RewardType.Item)
				{
					num2 += bonusReward.GetRequiredInventorySlots();
				}
			}
		}
		int num3 = 0;
		mission.TryGetRewardsForChoice(0, out var rewards);
		if (rewards != null)
		{
			foreach (MissionReward item in rewards)
			{
				if (item.RewardType == RewardType.Item)
				{
					num3 += item.GetRequiredInventorySlots();
				}
			}
		}
		requiredSlots = num3 + num2;
		return true;
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class ObjectiveStatus : IPooled
{
	public bool started;

	public bool softCompleted;

	public bool blockReset;

	public bool completed;

	public bool failed;

	public float progressTarget;

	public float progressCurrent;

	public Vector3 worldLocation;

	public RealTimeSince sinceLastThink;

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
	}

	public void Reset()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		started = false;
		softCompleted = false;
		blockReset = false;
		completed = false;
		failed = false;
		progressTarget = 0f;
		progressCurrent = 0f;
		worldLocation = default(Vector3);
		sinceLastThink = default(RealTimeSince);
	}

	public bool IsObjectiveActive()
	{
		if (started && !completed)
		{
			return !failed;
		}
		return false;
	}

	public bool IsWorldPositionValid()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return worldLocation != default(Vector3);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Serializable]
public class PositionGenerator
{
	public enum RelativeType
	{
		Player,
		Provider,
		Position
	}

	public enum PositionType
	{
		MissionPoint,
		WorldPositionGenerator,
		DungeonPoint,
		Radius,
		UnderwaterLab,
		UnderwaterLabWithBoomboxes
	}

	public class PositionPointAttribute : PropertyAttribute
	{
	}

	public string identifier;

	public float minDistForMovePoint;

	public float maxDistForMovePoint = 25f;

	public bool allowDoubleDistanceIfNoOptionsAreFound;

	public bool positionsAreExclusive = true;

	public RelativeType relativeTo;

	public PositionType positionType;

	[PositionPoint]
	public string centerOnPositionIdentifier = "";

	[InspectorFlags]
	public MissionPoint.MissionPointEnum Flags = (MissionPoint.MissionPointEnum)(-1);

	[InspectorFlags]
	public MissionPoint.MissionPointEnum ExclusionFlags;

	public WorldPositionGenerator worldPositionGenerator;

	private float minDistForMovePoint_2x;

	private float maxDistForMovePoint_2x;

	private float minDistForMovePoint_sqr;

	private float maxDistForMovePoint_sqr;

	private float maxDistForMovePoint_2x_sqr;

	public void CacheDistanceValues()
	{
		minDistForMovePoint_2x = minDistForMovePoint * 2f;
		maxDistForMovePoint_2x = maxDistForMovePoint * 2f;
		minDistForMovePoint_sqr = minDistForMovePoint * minDistForMovePoint;
		maxDistForMovePoint_sqr = maxDistForMovePoint * maxDistForMovePoint;
		maxDistForMovePoint_2x_sqr = maxDistForMovePoint_2x * maxDistForMovePoint_2x;
	}

	public bool TryGetPosition(MissionInstance instance, out Vector3 outPosition, int depth = 0)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_048c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_049c: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PositionGenerator.TryGetPosition", 0);
		try
		{
			if (depth > 10)
			{
				Debug.Log((object)$"Exceeded max depth while calculating position, mission: {((Object)instance.GetMission()).name} missionID: {instance.missionID}, identifier: {identifier}");
				outPosition = Vector3.zero;
				return false;
			}
			Vector3 point;
			bool num = TryGetRelativeToPosition(instance, depth, out point);
			outPosition = point;
			if (!num)
			{
				Debug.LogError((object)("Failed to get relative to position for mission " + ((Object)instance.GetMission()).name), (Object)(object)instance.GetMission());
				return false;
			}
			switch (positionType)
			{
			case PositionType.MissionPoint:
			{
				List<Vector3> points = Pool.Get<List<Vector3>>();
				bool missionPoints = MissionPoint.GetMissionPoints(ref points, point, minDistForMovePoint_sqr, maxDistForMovePoint_sqr, (int)Flags, (int)ExclusionFlags);
				if (!missionPoints && allowDoubleDistanceIfNoOptionsAreFound)
				{
					points.Clear();
					missionPoints = MissionPoint.GetMissionPoints(ref points, point, minDistForMovePoint_sqr, maxDistForMovePoint_2x_sqr, (int)Flags, (int)ExclusionFlags);
				}
				if (missionPoints)
				{
					outPosition = points[Random.Range(0, points.Count)];
				}
				Pool.FreeUnmanaged<Vector3>(ref points);
				return missionPoints;
			}
			case PositionType.WorldPositionGenerator:
				if ((Object)(object)worldPositionGenerator != (Object)null)
				{
					for (int n = 0; n < 10; n++)
					{
						if (worldPositionGenerator.TrySample(point, minDistForMovePoint, maxDistForMovePoint, minDistForMovePoint_2x, maxDistForMovePoint_2x, checkBlockedPoints: true, out var position3) && TryAlignToGround(position3, out var correctedPosition2))
						{
							outPosition = correctedPosition2;
							return true;
						}
					}
					return false;
				}
				goto default;
			case PositionType.DungeonPoint:
				outPosition = DynamicDungeon.GetNextDungeonPoint();
				return true;
			case PositionType.Radius:
			{
				for (int m = 0; m < 10; m++)
				{
					Vector3 onUnitSphere = Random.onUnitSphere;
					onUnitSphere.y = 0f;
					((Vector3)(ref onUnitSphere)).Normalize();
					Vector3 val6 = point + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
					val6.y = WaterLevel.GetWaterOrTerrainSurface(val6, waves: false, volumes: false);
					if (TryAlignToGround(val6, out var correctedPosition))
					{
						outPosition = correctedPosition;
						return true;
					}
				}
				return false;
			}
			case PositionType.UnderwaterLab:
			{
				List<DungeonBaseInfo> dungeonBaseEntrances2 = TerrainMeta.Path.DungeonBaseEntrances;
				if (dungeonBaseEntrances2.Count > 0)
				{
					int index2 = Random.Range(0, dungeonBaseEntrances2.Count);
					outPosition = ((Component)dungeonBaseEntrances2[index2]).transform.position;
					return true;
				}
				return false;
			}
			case PositionType.UnderwaterLabWithBoomboxes:
			{
				List<DungeonBaseInfo> dungeonBaseEntrances = TerrainMeta.Path.DungeonBaseEntrances;
				int count = dungeonBaseEntrances.Count;
				if (count <= 0)
				{
					return false;
				}
				BaseMission mission = instance.GetMission();
				if (mission == null)
				{
					Debug.LogError((object)$"Failed to retrieve mission from mission instance with ID {instance.missionID}");
					return false;
				}
				MissionObjective_UnderwaterLabsBoomboxBonus missionObjective_UnderwaterLabsBoomboxBonus = null;
				for (int i = 0; i < mission.objectives.Length; i++)
				{
					if (mission.objectives[i].Get() is MissionObjective_UnderwaterLabsBoomboxBonus missionObjective_UnderwaterLabsBoomboxBonus2)
					{
						missionObjective_UnderwaterLabsBoomboxBonus = missionObjective_UnderwaterLabsBoomboxBonus2;
						break;
					}
				}
				if ((Object)(object)missionObjective_UnderwaterLabsBoomboxBonus == (Object)null)
				{
					Debug.LogError((object)("Failed to find lab boombox objective in mission " + ((Object)mission).name), (Object)(object)mission);
					return false;
				}
				int num2 = 0;
				if (string.IsNullOrWhiteSpace(missionObjective_UnderwaterLabsBoomboxBonus.requireProximityToPosition))
				{
					TimeWarning val2 = TimeWarning.New("PositionGenerator.TryGetPosition.UnderwaterLabWithBoomboxes.GetValidLabDistanceIrrespective", 0);
					try
					{
						for (int j = 0; j < DeployableBoomBox.ServerStaticInstances.Count; j++)
						{
							DeployableBoomBox deployableBoomBox = DeployableBoomBox.ServerStaticInstances[j];
							if (!((Object)(object)deployableBoomBox == (Object)null))
							{
								if (EnvironmentManager.Check(((Component)deployableBoomBox).transform.position, EnvironmentType.UnderwaterLab))
								{
									num2++;
								}
								if (num2 >= 2)
								{
									int index = Random.Range(0, count);
									outPosition = ((Component)dungeonBaseEntrances[index]).transform.position;
									return true;
								}
							}
						}
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				else
				{
					TimeWarning val3 = TimeWarning.New("PositionGenerator.TryGetPosition.UnderwaterLabWithBoomboxes.GetValidLab", 0);
					try
					{
						ListHashSet<Vector3> val4 = Pool.Get<ListHashSet<Vector3>>();
						for (int k = 0; k < count; k++)
						{
							val4.Add(((Component)dungeonBaseEntrances[k]).transform.position);
						}
						while (val4.Count > 0)
						{
							int num3 = Random.Range(0, val4.Count);
							Vector3 position = ((Component)dungeonBaseEntrances[num3]).transform.position;
							for (int l = 0; l < DeployableBoomBox.ServerStaticInstances.Count; l++)
							{
								TimeWarning val5 = TimeWarning.New("PositionGenerator.TryGetPosition.UnderwaterLabWithBoomboxes.CheckBoombox", 0);
								try
								{
									DeployableBoomBox deployableBoomBox2 = DeployableBoomBox.ServerStaticInstances[l];
									if ((Object)(object)deployableBoomBox2 == (Object)null)
									{
										continue;
									}
									Vector3 position2 = ((Component)deployableBoomBox2).transform.position;
									float sqrMinimumDistanceToMissionPoint = missionObjective_UnderwaterLabsBoomboxBonus.sqrMinimumDistanceToMissionPoint;
									if (!(Vector3.SqrMagnitude(position - position2) > sqrMinimumDistanceToMissionPoint))
									{
										if (EnvironmentManager.Check(((Component)deployableBoomBox2).transform.position, EnvironmentType.UnderwaterLab))
										{
											num2++;
										}
										if (num2 >= 2)
										{
											outPosition = position;
											Pool.FreeUnmanaged<Vector3>(ref val4);
											return true;
										}
									}
								}
								finally
								{
									((IDisposable)val5)?.Dispose();
								}
							}
							num2 = 0;
							val4.RemoveAt(num3);
						}
						Pool.FreeUnmanaged<Vector3>(ref val4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				return false;
			}
			default:
				Debug.LogError((object)$"Unhandled position generator type ({positionType}), defaulting to use {PositionType.Radius}");
				goto case PositionType.Radius;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryGetRelativeToPosition(MissionInstance instance, int depth, out Vector3 point)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PositionGenerator.TryGetRelativeToPosition", 0);
		try
		{
			switch (relativeTo)
			{
			case RelativeType.Position:
				if (instance.TryGetMissionPoint(centerOnPositionIdentifier, out point, depth + 1))
				{
					return true;
				}
				break;
			case RelativeType.Provider:
			{
				IMissionProvider missionProvider = instance.GetMissionProvider();
				if (missionProvider != null)
				{
					point = missionProvider.ProviderPosition();
					return true;
				}
				break;
			}
			}
			point = Vector3.zero;
			Debug.LogError((object)string.Format("Failed to get point for {0} {1}, outputting {2} as a fallback", "RelativeType", relativeTo, point));
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool TryAlignToGround(Vector3 wishPosition, out Vector3 correctedPosition)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WorldPositionGenerator.TryAlignToGround", 0);
		try
		{
			Vector3 val2 = Vector3Ex.WithY(wishPosition, wishPosition.y + 50f);
			RaycastHit hit = default(RaycastHit);
			if (!Physics.Raycast(new Ray(val2, Vector3.down), ref hit, 50f, 1218652417, (QueryTriggerInteraction)1))
			{
				correctedPosition = wishPosition;
				return true;
			}
			if ((Object)(object)hit.GetEntity() != (Object)null)
			{
				correctedPosition = wishPosition;
				return false;
			}
			correctedPosition = ((RaycastHit)(ref hit)).point;
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum RelativeType
{
	Player,
	Provider,
	Position
}


public enum PositionType
{
	MissionPoint,
	WorldPositionGenerator,
	DungeonPoint,
	Radius,
	UnderwaterLab,
	UnderwaterLabWithBoomboxes
}


using UnityEngine;

public class PositionPointAttribute : PropertyAttribute
{
}


using System;
using UnityEngine.Serialization;

[Serializable]
public class MissionDependancy
{
	[FormerlySerializedAs("targetMission")]
	public BaseMission mission;

	[FormerlySerializedAs("targetMissionDesiredStatus")]
	[FilteredEnum(0, 4)]
	public MissionStatus desiredStatus;

	public uint missionID
	{
		get
		{
			if (!(mission == null))
			{
				return mission.id;
			}
			return 0u;
		}
	}
}


public enum MissionStatus
{
	Undefined,
	Active,
	Accomplished,
	Failed,
	Completed,
	Pending
}


public enum MissionEventType
{
	CUSTOM,
	HARVEST,
	CONVERSATION,
	KILL_ENTITY,
	ACQUIRE_ITEM,
	FREE_CRATE,
	MOUNT_ENTITY,
	HURT_ENTITY,
	PLAYER_TICK,
	CRAFT_ITEM,
	DEPLOY,
	HEAL,
	CLOTHINGCHANGED,
	STARTOVEN,
	CONSUME,
	ACQUITE_ITEM_STACK,
	OPEN_STORAGE,
	COOK,
	ENTER_TRIGGER,
	UPGRADE_BUILDING_GRADE,
	RESPAWN,
	METAL_DETECTOR_FIND,
	LONG_USE_OBJECT,
	PLAY_BOOMBOX
}


using System;
using System.Collections.Generic;

[Serializable]
public class MissionObjectiveEntry
{
	public Phrase description;

	public bool startAfterPriorObjectives;

	public int[] startAfterCompletedObjectives;

	public int[] autoCompleteOtherObjectives;

	public bool onlyProgressIfStarted = true;

	public bool isRequired = true;

	public MissionObjective objective;

	public string[] requiredEntities;

	public List<MissionBonusReward> bonusRewards;

	public MissionObjective Get()
	{
		return objective;
	}
}


using UnityEngine;

public struct MissionEventPayload
{
	public NetworkableId NetworkIdentifier;

	public uint UintIdentifier;

	public int IntIdentifier;

	public Vector3 WorldPosition;

	public string StringIdentifier;
}


using System;

public struct MissionIdentifierData : IEquatable<MissionIdentifierData>
{
	public BaseMission mission;

	public NetworkableId missionProviderNetId;

	public MissionIdentifierData(BaseMission mission, NetworkableId missionProviderNetId)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.mission = mission;
		this.missionProviderNetId = missionProviderNetId;
	}

	public bool Equals(MissionIdentifierData other)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (mission.id == other.mission.id)
		{
			return missionProviderNetId == other.missionProviderNetId;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is MissionIdentifierData other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(mission.id, missionProviderNetId.Value);
	}
}


public struct MissionValidStateData
{
	public MissionInstance missionInstance;

	public bool isValid;

	public int lastUpdateFrame;

	public MissionValidStateData(MissionInstance missionInstance, bool isValid, int lastUpdateFrame)
	{
		this.missionInstance = missionInstance;
		this.isValid = isValid;
		this.lastUpdateFrame = lastUpdateFrame;
	}
}


using System;
using UnityEngine.Serialization;

[Serializable]
public class MissionEntityEntry
{
	[FormerlySerializedAs("entityIdentifier")]
	public string identifier;

	public GameObjectRef entityRef;

	[PositionGenerator.PositionPoint]
	public string spawnPositionToUse;

	public bool spawnOnMissionStart = true;

	public bool cleanupOnMissionFailed;

	public bool cleanupOnMissionSuccess;

	public ItemAmount[] overrideLootOnItem;
}


using System;
using UnityEngine;

[Serializable]
public class MissionReward
{
	public RewardType RewardType;

	public ItemAmount Item;

	public NonItemReward NonItem;

	public int GetRequiredInventorySlots()
	{
		return Mathf.CeilToInt(Item.GetAmount() / (float)Item.itemDef.stackable);
	}
}


using System;
using UnityEngine;

[Serializable]
public class MissionBonusReward : MissionReward
{
	[Tooltip("If enabled, this reward will be dispensed for each amount the player got towards the target. Otherwise, this reward will only be dispensed once if the objective is fully complete.\nExample: if player achieved 2/3 for this bonus objective, then this reward will be dispensed 2 times.")]
	public bool isIncremental;
}


using System;
using System.Collections.Generic;

[Serializable]
public class RewardsList
{
	public List<MissionReward> rewards = new List<MissionReward>();
}


using System;
using System.Collections.Generic;
using Rust;

[Serializable]
public class EraSpecificRewards
{
	public Era[] eras;

	public List<RewardsList> rewardChoices = new List<RewardsList>();
}


using System;
using UnityEngine;

[Serializable]
public class NonItemReward
{
	public Phrase DisplayPhrase;

	public Sprite DisplaySprite;

	public NonItemRewardType RewardType;
}


public enum NonItemRewardType
{
	None,
	SafeZoneRespawnUnlock
}


public enum RewardType
{
	Item,
	Other
}


public enum MissionFailReason
{
	TimeOut,
	Disconnect,
	ResetPlayerState,
	Abandon,
	ObjectiveFailed,
	DeepSeaClosed
}


public class UpdateMissionValidStateWorkQueue : ObjectWorkQueue<MissionIdentifierData>
{
	protected override void RunJob(MissionIdentifierData missionIdentifierData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		missionIdentifierData.mission.Server_UpdateMissionValidState(missionIdentifierData.missionProviderNetId, out var _);
	}
}


public class DebugWorldPosition : ListComponent<DebugWorldPosition>
{
	public WorldPositionGenerator GeneratorToFake;
}


public interface IMissionEntityListener
{
	void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance);

	void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance);
}


using System;
using ConVar;
using UnityEngine;

public interface IMissionProvider
{
	NetworkableId ProviderID();

	Vector3 ProviderPosition();

	BaseEntity Entity();

	BufferList<BaseMission> GetAllMissions();

	bool TryGetMission(uint missionId, out BaseMission mission)
	{
		BufferList<BaseMission> allMissions = GetAllMissions();
		for (int i = 0; i < allMissions.Count; i++)
		{
			mission = allMissions[i];
			if (!(mission == null) && mission.id == missionId)
			{
				return true;
			}
		}
		mission = null;
		return false;
	}

	bool HasPlayerRecentlyCompletedMission(BasePlayer player)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < player.acceptedMissions.Count; i++)
		{
			BaseMission.MissionInstance missionInstance = player.acceptedMissions[i];
			if (missionInstance.status == BaseMission.MissionStatus.Completed && missionInstance.providerID == ProviderID() && missionInstance.endTimeUtcSeconds != long.MinValue && (float)(DateTimeOffset.UtcNow.ToUnixTimeSeconds() - missionInstance.endTimeUtcSeconds) * Time.missiontimerscale < 5f)
			{
				return true;
			}
		}
		return false;
	}

	bool Server_HasMissionAvailable(BasePlayer player);
}


using UnityEngine;

public class MissionEntity : BaseMonoBehaviour, IOnParentDestroying
{
	public string identifier;

	public bool cleanupOnMissionSuccess = true;

	public bool cleanupOnMissionFailed = true;

	public void OnParentDestroying()
	{
		Object.Destroy((Object)(object)this);
	}

	public virtual void Setup(BasePlayer assignee, BaseMission.MissionInstance instance, string identifier, bool wantsSuccessCleanup, bool wantsFailedCleanup)
	{
		this.identifier = identifier;
		cleanupOnMissionFailed = wantsFailedCleanup;
		cleanupOnMissionSuccess = wantsSuccessCleanup;
		BaseEntity entity = GetEntity();
		if (Object.op_Implicit((Object)(object)entity))
		{
			((Component)entity).SendMessage("MissionSetupPlayer", (object)assignee, (SendMessageOptions)1);
		}
	}

	public virtual void MissionStarted(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		IMissionEntityListener[] componentsInChildren = ((Component)this).GetComponentsInChildren<IMissionEntityListener>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MissionStarted(assignee, instance);
		}
	}

	public virtual void MissionEnded(BasePlayer assignee, BaseMission.MissionInstance instance)
	{
		IMissionEntityListener[] componentsInChildren = ((Component)this).GetComponentsInChildren<IMissionEntityListener>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].MissionEnded(assignee, instance);
		}
		instance.spawnedMissionEntities.Remove(identifier);
		if ((cleanupOnMissionSuccess && (instance.status == BaseMission.MissionStatus.Completed || instance.status == BaseMission.MissionStatus.Accomplished)) || (cleanupOnMissionFailed && instance.status == BaseMission.MissionStatus.Failed))
		{
			BaseEntity entity = GetEntity();
			if (Object.op_Implicit((Object)(object)entity))
			{
				entity.Kill();
			}
		}
	}

	public BaseEntity GetEntity()
	{
		return ((Component)this).GetComponent<BaseEntity>();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MissionIconsConfig")]
public class MissionIconsConfig : BaseScriptableObject
{
	public enum IconType
	{
		Undefined,
		Generic,
		NPC
	}

	[Serializable]
	public class Data
	{
		[FilteredEnum(0, 1)]
		public IconType iconType;

		public Sprite icon;
	}

	private static MissionIconsConfig _instance;

	public List<Data> entries = new List<Data>();

	public static MissionIconsConfig Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<MissionIconsConfig>("assets/prefabs/missions/missioniconsconfig/missioniconsconfig.asset", true);
			}
			if (_instance == null)
			{
				Debug.LogError((object)"Failed to load MissionIconsConfig");
			}
			return _instance;
		}
	}

	public Sprite GetIcon(IconType iconType)
	{
		if (iconType == IconType.Undefined)
		{
			Debug.LogError((object)"Icon type is undefined, unable to retrieve icon");
			return null;
		}
		for (int i = 0; i < entries.Count; i++)
		{
			Data data = entries[i];
			if (data != null && iconType == data.iconType)
			{
				return data.icon;
			}
		}
		Debug.LogError((object)$"Failed to find icon for icon type {iconType}");
		return null;
	}
}


public enum IconType
{
	Undefined,
	Generic,
	NPC
}


using System;
using UnityEngine;

[Serializable]
public class Data
{
	[FilteredEnum(0, 1)]
	public IconType iconType;

	public Sprite icon;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MissionManifest")]
public class MissionManifest : ScriptableObject
{
	public ScriptableObjectRef[] missionList;

	public WorldPositionGenerator[] positionGenerators;

	public static MissionManifest instance;

	private static Dictionary<uint, BaseMission> idToMissionCache = new Dictionary<uint, BaseMission>();

	private static Dictionary<string, BaseMission> shortnameToMissionCache = new Dictionary<string, BaseMission>();

	public static MissionManifest Get()
	{
		TimeWarning val = TimeWarning.New("MissionManifest.Get", 0);
		try
		{
			if ((Object)(object)instance != (Object)null)
			{
				return instance;
			}
			TimeWarning val2 = TimeWarning.New("MissionManifest.Get.ResourcesLoadManifest", 0);
			try
			{
				instance = Resources.Load<MissionManifest>("MissionManifest");
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("MissionManifest.Get.PositionGeneratorLoop", 0);
			try
			{
				WorldPositionGenerator[] array = instance.positionGenerators;
				foreach (WorldPositionGenerator worldPositionGenerator in array)
				{
					if (!((Object)(object)worldPositionGenerator == (Object)null))
					{
						worldPositionGenerator.PrecalculatePositions();
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			return instance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static BaseMission GetFromShortName(string shortname)
	{
		TimeWarning val = TimeWarning.New("MissionManifest.GetFromShortName", 0);
		try
		{
			MissionManifest missionManifest = Get();
			if (missionManifest.missionList == null)
			{
				return null;
			}
			if (shortnameToMissionCache.TryGetValue(shortname, out var value))
			{
				return value;
			}
			ScriptableObjectRef[] array = missionManifest.missionList;
			foreach (ScriptableObjectRef scriptableObjectRef in array)
			{
				if (!(scriptableObjectRef.Get() is BaseMission baseMission))
				{
					Debug.LogError((object)("Mission manifest is holding reference to a " + ((object)scriptableObjectRef.Get()).GetType().Name + " with guid " + scriptableObjectRef.guid));
				}
				else if (baseMission.shortname == shortname)
				{
					shortnameToMissionCache[shortname] = baseMission;
					return baseMission;
				}
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static BaseMission GetFromID(uint id)
	{
		TimeWarning val = TimeWarning.New("MissionManifest.GetFromID", 0);
		try
		{
			MissionManifest missionManifest = Get();
			if (missionManifest.missionList == null)
			{
				return null;
			}
			if (idToMissionCache.TryGetValue(id, out var value))
			{
				return value;
			}
			ScriptableObjectRef[] array = missionManifest.missionList;
			foreach (ScriptableObjectRef scriptableObjectRef in array)
			{
				if (!(scriptableObjectRef.Get() is BaseMission baseMission))
				{
					Debug.LogError((object)("Mission manifest is holding reference to a " + ((object)scriptableObjectRef.Get()).GetType().Name + " with guid " + scriptableObjectRef.guid));
				}
				else if (baseMission.id == id)
				{
					idToMissionCache[id] = baseMission;
					return baseMission;
				}
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool TryGetFromID(uint id, out BaseMission mission)
	{
		mission = GetFromID(id);
		return mission != null;
	}
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MissionPoint : MonoBehaviour
{
	public enum MissionPointEnum
	{
		EasyMonument = 1,
		MediumMonument = 2,
		HardMonument = 4,
		Item_Hidespot = 8,
		Underwater = 0x80,
		Tutorial_Bear = 0x100,
		AtmosphereSensor = 0x200,
		SafeZoneMonument = 0x400,
		OilRigMonument = 0x800,
		OilRigCCTVRoom = 0x1000,
		FloatingCity = 0x2000
	}

	public bool dropToGround = true;

	private const float BLOCK_DISTANCE_THRESHOLD = 3f;

	private const float BLOCK_DISTANCE_THRESHOLD_SQUARED = 9f;

	public const int EVERYTHING = -1;

	public const int NOTHING = 0;

	public const int EASY_MONUMENT = 1;

	public const int MED_MONUMENT = 2;

	public const int HARD_MONUMENT = 4;

	public const int ITEM_HIDESPOT = 8;

	public const int UNDERWATER = 128;

	public const int TUTORIAL_BEAR = 256;

	public const int ATMOSPHERE_SENSOR = 512;

	public const int SAFE_ZONE_MONUMENT = 1024;

	public const int OILRIG_MONUMENT = 2048;

	public const int OILRIG_CCTVROOM = 4096;

	public const int FLOATINGCITY = 8192;

	public const int EASY_MONUMENT_IDX = 0;

	public const int MED_MONUMENT_IDX = 1;

	public const int HARD_MONUMENT_IDX = 2;

	public const int ITEM_HIDESPOT_IDX = 3;

	public const int FOREST_IDX = 4;

	public const int ROADSIDE_IDX = 5;

	public const int BEACH = 6;

	public const int UNDERWATER_IDX = 7;

	public const int TUTORIAL_BEAR_IDX = 8;

	public const int ATMOSPHERE_SENSOR_IDX = 9;

	public const int SAFE_ZONE_MONUMENT_IDX = 10;

	public const int OILRIG_MONUMENT_IDX = 11;

	public const int OILRIG_CCTVROOM_IDX = 12;

	public const int FLOATINGCITY_IDX = 13;

	private static Dictionary<int, int> type2index = new Dictionary<int, int>
	{
		{ 1, 0 },
		{ 2, 1 },
		{ 4, 2 },
		{ 8, 3 },
		{ 128, 7 },
		{ 256, 8 },
		{ 512, 9 },
		{ 1024, 10 },
		{ 2048, 11 },
		{ 4096, 12 },
		{ 8192, 13 }
	};

	[InspectorFlags]
	public MissionPointEnum Flags = (MissionPointEnum)(-1);

	public static ListHashSet<MissionPoint> server_allMissionPoints = new ListHashSet<MissionPoint>();

	public static int TypeToIndex(int id)
	{
		return type2index[id];
	}

	public static int IndexToType(int idx)
	{
		return 1 << idx;
	}

	public void OnEnable()
	{
		server_allMissionPoints.TryAdd(this);
	}

	private void Start()
	{
		if (dropToGround)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DropToGround, 0.5f);
		}
	}

	private void DropToGround()
	{
		if (Object.op_Implicit((Object)(object)this))
		{
			if (Application.isLoading)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)DropToGround, 0.5f);
			}
			else
			{
				((Component)this).transform.DropToGround();
			}
		}
	}

	public void OnDisable()
	{
		server_allMissionPoints.Remove(this);
	}

	public static bool GetMissionPoints(ref List<Vector3> points, Vector3 near, float minDistanceSqr, float maxDistanceSqr, int flags, int exclusionFlags)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("MissionPoint.GetMissionPoints", 0);
		try
		{
			bool result = false;
			for (int i = 0; i < server_allMissionPoints.Count; i++)
			{
				MissionPoint missionPoint = server_allMissionPoints[i];
				MissionPointEnum flags2 = missionPoint.Flags;
				Vector3 position = ((Component)missionPoint).transform.position;
				if (((uint)flags2 & (uint)flags) != (uint)flags || (exclusionFlags != 0 && ((uint)flags2 & (uint)exclusionFlags) != 0))
				{
					continue;
				}
				float num = Vector3.SqrMagnitude(position - near);
				if (!(num <= maxDistanceSqr) || !(num > minDistanceSqr))
				{
					continue;
				}
				if (BaseMission.blockedPoints.Count > 0)
				{
					bool flag = false;
					foreach (ListHashSet<Vector3> value in BaseMission.blockedPoints.Values)
					{
						for (int j = 0; j < value.Count; j++)
						{
							if (Vector3.SqrMagnitude(value[j] - position) < 9f)
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					if (flag)
					{
						continue;
					}
				}
				points.Add(position);
				result = true;
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum MissionPointEnum
{
	EasyMonument = 1,
	MediumMonument = 2,
	HardMonument = 4,
	Item_Hidespot = 8,
	Underwater = 0x80,
	Tutorial_Bear = 0x100,
	AtmosphereSensor = 0x200,
	SafeZoneMonument = 0x400,
	OilRigMonument = 0x800,
	OilRigCCTVRoom = 0x1000,
	FloatingCity = 0x2000
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/Move Mission")]
public class MoveMission : BaseMission
{
	public float minDistForMovePoint = 20f;

	public float maxDistForMovePoint = 25f;

	private float minDistFromLocation = 3f;

	public override void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 onUnitSphere = Random.onUnitSphere;
		onUnitSphere.y = 0f;
		((Vector3)(ref onUnitSphere)).Normalize();
		Vector3 val = ((Component)assignee).transform.position + onUnitSphere * Random.Range(minDistForMovePoint, maxDistForMovePoint);
		val.y = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		instance.objectiveStatuses[0].worldLocation = val;
		base.MissionStart(instance, assignee);
	}

	public override void ServerThink(MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(instance.objectiveStatuses[0].worldLocation, ((Component)assignee).transform.position);
		if (instance.status == MissionStatus.Active && num <= minDistFromLocation)
		{
			MissionSuccess(instance, assignee);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(instance.providerID);
			if (Object.op_Implicit((Object)(object)baseNetworkable))
			{
				instance.objectiveStatuses[0].worldLocation = ((Component)baseNetworkable).transform.position;
			}
		}
		else
		{
			if (instance.status == MissionStatus.Accomplished)
			{
				_ = minDistFromLocation;
			}
			base.ServerThink(instance, assignee, delta);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/Tutorial Mission")]
public class TutorialMission : BaseMission
{
	public BasePlayer.TutorialItemAllowance AllowedTutorialItems;

	public override void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		base.MissionStart(instance, assignee);
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
	}
}


using Rust.UI;
using UnityEngine;

public class MissionUIPanel : MonoBehaviour
{
	public GameObject activeMissionParent;

	public RustText missionTitleText;

	public RustText missionDescText;

	public GameObject rewardsParent;

	public VirtualItemIcon[] rewardIcons;

	public GameObject bonusRewardsParent;

	public VirtualItemIcon[] bonusIcons;

	public Phrase noMissionText;

	public GameObject abandonButton;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public abstract class MissionObjective : ScriptableObject
{
	public virtual BasePlayer.PingType PingType => BasePlayer.PingType.GoTo;

	public virtual void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
	}

	public virtual void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		BaseMission mission = instance.GetMission();
		if (mission == null)
		{
			return;
		}
		int count = instance.objectiveStatuses.Count;
		int num = mission.objectives.Length;
		if (count != num)
		{
			Debug.LogError((object)$"Mission instance for mission {((Object)mission).name} contains data for {count} objectives but mission has {num} objectives", (Object)(object)mission);
			return;
		}
		instance.objectiveStatuses[index].started = true;
		if (mission.objectives[index].requiredEntities != null)
		{
			string[] requiredEntities = mission.objectives[index].requiredEntities;
			foreach (string identifier in requiredEntities)
			{
				instance.GetSpawnedMissionEntity(identifier, playerFor);
			}
		}
		playerFor.MissionsDirty();
	}

	public virtual void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
	}

	public virtual void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
	}

	public void ResetObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor, bool resetStartedStatus = false, bool resetSoftCompletedStatus = true, float newProgressCurrent = 0f)
	{
		BaseMission.MissionInstance.ObjectiveStatus objectiveStatus = instance.objectiveStatuses[index];
		if (resetStartedStatus)
		{
			objectiveStatus.started = false;
		}
		if (resetSoftCompletedStatus)
		{
			objectiveStatus.softCompleted = false;
		}
		objectiveStatus.completed = false;
		objectiveStatus.failed = false;
		objectiveStatus.progressCurrent = newProgressCurrent;
		playerFor.MissionsDirty(saveImmediately: true);
	}

	public void ResetFollowupObjectives(int fromIndex, BaseMission.MissionInstance instance, BasePlayer playerFor, bool resetStartedStatus)
	{
		for (int i = fromIndex + 1; i < instance.objectiveStatuses.Count; i++)
		{
			ResetObjective(i, instance, playerFor, resetStartedStatus);
		}
	}

	public void ClearSoftCompletedStatus(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		instance.objectiveStatuses[index].softCompleted = false;
		playerFor.MissionsDirty(saveImmediately: true);
	}

	public void SoftCompleteObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		instance.objectiveStatuses[index].softCompleted = true;
		playerFor.MissionsDirty(saveImmediately: true);
	}

	public void CompleteObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (!instance.objectiveStatuses[index].completed && !instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].completed = true;
			instance.GetMission().OnObjectiveCompleted(index, instance, playerFor);
			ObjectiveCompleted(playerFor, index, instance);
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}

	public void FailObjective(int index, BaseMission.MissionInstance instance, BasePlayer playerFor)
	{
		if (!instance.objectiveStatuses[index].completed && !instance.objectiveStatuses[index].failed)
		{
			instance.objectiveStatuses[index].failed = true;
			instance.GetMission().OnObjectiveFailed(index, instance, playerFor);
			ObjectiveFailed(playerFor, index, instance);
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}

	public void FailMission(BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)
	{
		instance.GetMission().MissionFailed(instance, assignee, failReason);
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
	}

	public void ServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float timeSinceLastThink)
	{
		if (ArePrerequisiteObjectivesMet(index, instance) && !IsStarted(index, instance))
		{
			ServerObjectiveStarted(assignee, index, instance);
		}
		DoServerThink(index, instance, assignee, timeSinceLastThink);
	}

	protected virtual void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float timeSinceLastThink)
	{
	}

	protected bool TryFindNearby<T>(Vector3 origin, Func<T, bool> filter, out T entity, float radius = 20f) where T : BaseEntity
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		List<T> list = Pool.Get<List<T>>();
		Vis.Entities(origin, radius, list, -1, (QueryTriggerInteraction)2);
		int num = -1;
		float num2 = float.PositiveInfinity;
		for (int i = 0; i < list.Count; i++)
		{
			T val = list[i];
			if (filter == null || filter(val))
			{
				float num3 = Vector3.SqrMagnitude(((Component)val).transform.position - origin);
				if (num3 < num2)
				{
					num = i;
					num2 = num3;
				}
			}
		}
		bool flag = num != -1;
		entity = (flag ? list[num] : null);
		Pool.FreeUnmanaged<T>(ref list);
		return flag;
	}

	public virtual void PostServerLoad(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
	}

	public void SetObjectiveWorldLocation(int index, BaseMission.MissionInstance instance, Vector3 worldLocation)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		instance.objectiveStatuses[index].worldLocation = worldLocation;
	}

	public bool ArePrerequisiteObjectivesMet(int index, BaseMission.MissionInstance instance)
	{
		BaseMission mission = instance.GetMission();
		if (index < 0 || index >= mission.objectives.Length)
		{
			Debug.LogError((object)$"Objective index {index} is invalid, mission {((Object)mission).name} has {mission.objectives.Length} objectives");
			return false;
		}
		BaseMission.MissionObjectiveEntry missionObjectiveEntry = mission.objectives[index];
		if (missionObjectiveEntry.startAfterPriorObjectives)
		{
			for (int i = 0; i < index; i++)
			{
				if (!IsCompleted(i, instance) && mission.objectives[i].isRequired)
				{
					return false;
				}
			}
			return true;
		}
		for (int j = 0; j < missionObjectiveEntry.startAfterCompletedObjectives.Length; j++)
		{
			int num = missionObjectiveEntry.startAfterCompletedObjectives[j];
			if (!IsCompleted(num, instance) && mission.objectives[num].isRequired)
			{
				return false;
			}
		}
		return true;
	}

	public bool CanProgress(int index, BaseMission.MissionInstance instance)
	{
		if (instance.GetMission().objectives[index].onlyProgressIfStarted)
		{
			return IsStarted(index, instance);
		}
		return true;
	}

	public bool IsStarted(int index, BaseMission.MissionInstance instance)
	{
		if (instance == null || instance.objectiveStatuses == null)
		{
			return false;
		}
		if (index < 0 || index >= instance.objectiveStatuses.Count)
		{
			return false;
		}
		if (instance.objectiveStatuses[index] == null)
		{
			return false;
		}
		return instance.objectiveStatuses[index].started;
	}

	public bool IsCompleted(int index, BaseMission.MissionInstance instance)
	{
		if (!instance.objectiveStatuses[index].completed)
		{
			return instance.objectiveStatuses[index].failed;
		}
		return true;
	}

	public bool IsObjectiveActive(int index, BaseMission.MissionInstance instance)
	{
		if (instance.objectiveStatuses[index].IsObjectiveActive())
		{
			return instance.IsActive();
		}
		return false;
	}

	public Vector3 GetObjectiveWorldLocation(int index, BaseMission.MissionInstance instance)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (index < 0 || index >= instance.objectiveStatuses.Count)
		{
			Debug.LogError((object)$"Failed to retrieve a world location for objective {((Object)this).name} index {index} on instance for mission {((Object)instance.GetMission()).name} as it is out of range of objectiveStatuses count {instance.objectiveStatuses.Count}");
			return Vector3.zero;
		}
		return instance.objectiveStatuses[index].worldLocation;
	}

	public virtual bool IsObjectiveValid(int index, BaseMission.MissionInstance instance)
	{
		return true;
	}
}


using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/AcquireItem")]
public class MissionObjective_AcquireItem : MissionObjective
{
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public bool allowStackEvents;

	public bool showResourcePings;

	public bool acceptExistingItems;

	[BaseMission.PositionGenerator.PositionPoint]
	[FormerlySerializedAs("requireProximityToPosition")]
	public string position;

	[Tooltip("If true, objective progress will reset upon no longer having the required item.")]
	public bool canBeReset;

	public bool shouldHideCompassMarkerWhenClose;

	[Min(0f)]
	[Tooltip("If \"Should Hide Compass Marker When Close\" is enabled and \"Require Proximity To Position\" is set and player is within this distance of the mission point then hide the compass marker, else the compass marker is visible.")]
	public float hideCompassMarkerDistance = 20f;

	private float sqrDistanceToHideCompassMarker;

	private void OnEnable()
	{
		CacheSqrDistanceForCompletion();
	}

	private void CacheSqrDistanceForCompletion()
	{
		sqrDistanceToHideCompassMarker = hideCompassMarkerDistance * hideCompassMarkerDistance;
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
		if (showResourcePings && forPlayer.IsInTutorial)
		{
			forPlayer.EnableResourcePings(targetItem, BasePlayer.PingType.GoTo);
		}
		if (!string.IsNullOrWhiteSpace(position) && instance.TryGetMissionPoint(position, out var point))
		{
			SetObjectiveWorldLocation(index, instance, point);
		}
		if (acceptExistingItems)
		{
			int amount = forPlayer.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(forPlayer, instance, index, BaseMission.MissionEventType.ACQUIRE_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (((type != BaseMission.MissionEventType.ACQUITE_ITEM_STACK || !allowStackEvents) && type != BaseMission.MissionEventType.ACQUIRE_ITEM) || IsCompleted(index, instance) || !CanProgress(index, instance) || targetItem.itemid != payload.IntIdentifier)
		{
			return;
		}
		instance.objectiveStatuses[index].progressCurrent += (int)amount;
		if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
		{
			CompleteObjective(index, instance, playerFor);
			if (canBeReset)
			{
				instance.objectiveStatuses[index].softCompleted = true;
			}
		}
		if (showResourcePings)
		{
			playerFor.DisableResourcePings(targetItem, BasePlayer.PingType.GoTo);
		}
		playerFor.MissionsDirty(saveImmediately: true);
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float timeSinceLastThink)
	{
		base.DoServerThink(index, instance, assignee, timeSinceLastThink);
		if (canBeReset && CanProgress(index, instance) && !((Object)(object)targetItem == (Object)null) && (!IsCompleted(index, instance) || !instance.objectiveStatuses[index].blockReset))
		{
			int amount = assignee.inventory.GetAmount(targetItem.itemid);
			bool completed = instance.objectiveStatuses[index].completed;
			bool flag = amount >= targetItemAmount;
			if (completed && !flag)
			{
				ResetObjective(index, instance, assignee, resetStartedStatus: false, resetSoftCompletedStatus: false);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Activate Long Use Object")]
public class MissionObjective_ActivateLongUseObject : MissionObjective
{
	public BaseEntity RequiredEntity;

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.LONG_USE_OBJECT && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(payload.NetworkIdentifier);
			if ((Object)(object)baseNetworkable != (Object)null && (Object)(object)RequiredEntity != (Object)null && RequiredEntity.prefabID == baseNetworkable.prefabID)
			{
				CompleteObjective(index, instance, playerFor);
				playerFor.MissionsDirty(saveImmediately: true);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Consume")]
public class MissionObjective_Consume : MissionObjective
{
	public ItemDefinition TargetItem;

	public int RequiredAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.CONSUME && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier == TargetItem.itemid)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/CookItem")]
public class MissionObjective_CookItem : MissionObjective
{
	[Tooltip("The cooked result that this objective is looking for (eg cooked chicken, not raw)")]
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	[SerializeField]
	private BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool checkExistingInventory;

	public override BasePlayer.PingType PingType => pingType;

	private bool HasPings
	{
		get
		{
			if (pingEntitiesOnTutorialIsland != null)
			{
				return pingEntitiesOnTutorialIsland.Length != 0;
			}
			return false;
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		if (HasPings)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
				BaseEntityRef[] array = pingEntitiesOnTutorialIsland;
				foreach (BaseEntityRef baseEntityRef in array)
				{
					list.Clear();
					currentTutorialIsland.GetBuildTargets(list, baseEntityRef.Get().prefabID);
					if (list.Count > 0)
					{
						List<BaseOven> list2 = Pool.Get<List<BaseOven>>();
						Vis.Entities(((Component)list[0]).transform.position, 0.25f, list2, 153092352, (QueryTriggerInteraction)2);
						if (list2.Count > 0)
						{
							playerFor.RegisterPingedEntity(list2[0], pingType);
						}
						Pool.FreeUnmanaged<BaseOven>(ref list2);
						break;
					}
				}
				Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
			}
		}
		if (checkExistingInventory)
		{
			int amount = playerFor.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.COOK || IsCompleted(index, instance) || !CanProgress(index, instance) || targetItem.itemid != payload.IntIdentifier)
		{
			return;
		}
		instance.objectiveStatuses[index].progressCurrent += (int)amount;
		if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
		{
			CompleteObjective(index, instance, playerFor);
			if (HasPings)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, pingType);
			}
		}
		playerFor.MissionsDirty(saveImmediately: true);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Craft")]
public class MissionObjective_Craft : MissionObjective
{
	[ItemSelector]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public bool checkExistingInventory;

	public override BasePlayer.PingType PingType => BasePlayer.PingType.Build;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CRAFT_ITEM || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		foreach (ItemDefinition itemDefinition in array)
		{
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(payload.IntIdentifier);
			bool flag = (Object)(object)itemDefinition2 != (Object)null && (Object)(object)itemDefinition2.isRedirectOf != (Object)null && itemDefinition2.isRedirectOf.itemid == itemDefinition.itemid;
			if (itemDefinition.itemid == payload.IntIdentifier || flag)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionsDirty(saveImmediately: true);
				break;
			}
		}
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		if (checkExistingInventory)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			if (num > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CRAFT_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItems[0].itemid
				}, num);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Deploy")]
public class MissionObjective_DeployItem : MissionObjective
{
	public BaseEntity[] PossibleOptions = new BaseEntity[0];

	public ItemDefinition[] PossibleItems = new ItemDefinition[0];

	public int RequiredAmount = 1;

	public bool PingTutorialTargets;

	public override BasePlayer.PingType PingType => BasePlayer.PingType.Build;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.DEPLOY && Matches(payload))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (PingTutorialTargets)
			{
				UpdatePings(playerFor);
			}
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}

	private bool Matches(BaseMission.MissionEventPayload payload)
	{
		BaseEntity[] possibleOptions = PossibleOptions;
		for (int i = 0; i < possibleOptions.Length; i++)
		{
			if (possibleOptions[i].prefabID == payload.UintIdentifier)
			{
				return true;
			}
		}
		ItemDefinition itemDefinition = null;
		ItemDefinition[] possibleItems = PossibleItems;
		foreach (ItemDefinition itemDefinition2 in possibleItems)
		{
			if (itemDefinition2.itemid == payload.IntIdentifier)
			{
				return true;
			}
			if ((Object)(object)itemDefinition == (Object)null)
			{
				itemDefinition = ItemManager.FindItemDefinition(payload.IntIdentifier);
			}
			if ((Object)(object)itemDefinition != (Object)null && (Object)(object)itemDefinition.isRedirectOf == (Object)(object)itemDefinition2)
			{
				return true;
			}
		}
		return false;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		if (PingTutorialTargets)
		{
			UpdatePings(playerFor);
		}
	}

	private void UpdatePings(BasePlayer playerFor)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
		BaseEntity[] possibleOptions = PossibleOptions;
		foreach (BaseEntity baseEntity in possibleOptions)
		{
			currentTutorialIsland.GetBuildTargets(list, baseEntity.prefabID);
		}
		foreach (TutorialBuildTarget item in list)
		{
			item.UpdateActive(playerFor);
			if (((Component)item).gameObject.activeSelf)
			{
				playerFor.AddPingAtLocation(PingType, ((Component)item).transform.position, 86400f, currentTutorialIsland.net.ID);
			}
			else
			{
				playerFor.RemovePingAtLocation(PingType, ((Component)item).transform.position, 0.5f, currentTutorialIsland.net.ID);
			}
		}
		Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
	}
}


using UnityEngine;

public class MissionObjective_EnterTrigger : MissionObjective
{
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	[SerializeField]
	private BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override BasePlayer.PingType PingType => pingType;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.TryGetMissionPoint(positionName, out var point);
		SetObjectiveWorldLocation(index, instance, point);
		playerFor.MissionsDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, GetObjectiveWorldLocation(index, instance), 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (IsCompleted(index, instance) || type != BaseMission.MissionEventType.ENTER_TRIGGER || ((Object)(object)requiredMountable != (Object)null && (!playerFor.isMounted || playerFor.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		CompleteObjective(index, instance, playerFor);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.RemovePingAtLocation(pingType, GetObjectiveWorldLocation(index, instance), float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Equip Clothing")]
public class MissionObjective_EquipClothing : MissionObjective
{
	public ItemDefinition[] RequiredItems = new ItemDefinition[0];

	public bool CheckExistingClothingOnStart = true;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		if (CheckExistingClothingOnStart)
		{
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CLOTHINGCHANGED, default(BaseMission.MissionEventPayload), 0f);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (IsCompleted(index, instance) || !CanProgress(index, instance) || type != BaseMission.MissionEventType.CLOTHINGCHANGED)
		{
			return;
		}
		ItemDefinition[] requiredItems = RequiredItems;
		foreach (ItemDefinition searchFor in requiredItems)
		{
			if (!playerFor.inventory.containerWear.HasItem(searchFor))
			{
				return;
			}
		}
		CompleteObjective(index, instance, playerFor);
		playerFor.MissionsDirty(saveImmediately: true);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Fill Tutorial TC")]
public class MissionObjective_FillTutorialToolCupboard : MissionObjective
{
	public int RequiredUpkeepHours = 24;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredUpkeepHours;
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		if (!IsStarted(index, instance))
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = assignee.GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null))
		{
			return;
		}
		int num = Mathf.RoundToInt(buildingPrivilege.GetProtectedMinutes() / 60f);
		if (num != Mathf.RoundToInt(instance.objectiveStatuses[index].progressCurrent))
		{
			instance.objectiveStatuses[index].progressCurrent = num;
			if (num >= RequiredUpkeepHours)
			{
				CompleteObjective(index, instance, assignee);
			}
			assignee.MissionsDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/FreeCrate")]
public class MissionObjective_FreeCrate : MissionObjective
{
	public int targetAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.FREE_CRATE && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += (int)amount;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)targetAmount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}
}


using UnityEngine;

public class MissionObjective_GoToDeepSea : MissionObjective
{
	[Tooltip("Time in seconds from deep sea wipe in which this objective will be considered as valid. If current time to wipe is less than this, then the mission cannot be started. If value <= 0, then this value is ignored.")]
	[InspectorName("Maximum Time To Wipe (s)")]
	public int maximumTimeToDeepSeaWipe;

	[Tooltip("Should fail mission when deep sea closes.")]
	public bool shouldFailMissionWhenDeepSeaCloses;

	public override bool IsObjectiveValid(int index, BaseMission.MissionInstance instance)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null && PointEntity<DeepSeaManager>.ServerInstance.IsOpen())
		{
			if (maximumTimeToDeepSeaWipe > 0)
			{
				return PointEntity<DeepSeaManager>.ServerInstance.GetTimeToWipe() > (float)maximumTimeToDeepSeaWipe;
			}
			return true;
		}
		return false;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			Debug.LogError((object)("Mission instance for " + ((Object)instance.GetMission()).name + " failed to retrieve server instance for DeepSeaManager"), (Object)(object)instance.GetMission());
			return;
		}
		SetObjectiveWorldLocation(index, instance, ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).center);
		playerFor.MissionsDirty();
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			return;
		}
		if (shouldFailMissionWhenDeepSeaCloses && !PointEntity<DeepSeaManager>.ServerInstance.IsOpen())
		{
			FailMission(instance, assignee, BaseMission.MissionFailReason.DeepSeaClosed);
		}
		if (!CanProgress(index, instance) || (IsCompleted(index, instance) && instance.objectiveStatuses[index].blockReset))
		{
			return;
		}
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = DeepSeaManager.IsInsideDeepSea((BaseNetworkable)assignee);
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else
			{
				ResetObjective(index, instance, assignee);
			}
		}
	}
}


using UnityEngine;

public class MissionObjective_GoToDeepSeaIsland : MissionObjective
{
	private const float ISLAND_PLAYER_DISTANCE_THRESHOLD = 150f;

	private const float ISLAND_PLAYER_DISTANCE_THRESHOLD_SQR = 22500f;

	public override bool IsObjectiveValid(int index, BaseMission.MissionInstance instance)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			return false;
		}
		if (!PointEntity<DeepSeaManager>.ServerInstance.IsOpen())
		{
			return false;
		}
		for (int i = 0; i < DeepSeaManager.ServerIslands.Count; i++)
		{
			if ((Object)(object)DeepSeaManager.ServerIslands[i] != (Object)null)
			{
				return true;
			}
		}
		return false;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			Debug.LogError((object)("Mission instance for " + ((Object)instance.GetMission()).name + " failed to retrieve server instance for DeepSeaManager"), (Object)(object)instance.GetMission());
		}
		else
		{
			SetObjectiveWorldLocation(index, instance, ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).center);
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (!CanProgress(index, instance) || (IsCompleted(index, instance) && instance.objectiveStatuses[index].blockReset))
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		if (DeepSeaManager.IsInsideDeepSea((BaseNetworkable)assignee))
		{
			for (int i = 0; i < DeepSeaManager.ServerIslands.Count; i++)
			{
				DeepSeaIsland deepSeaIsland = DeepSeaManager.ServerIslands[i];
				if (!((Object)(object)deepSeaIsland == (Object)null) && !(Vector3.SqrMagnitude(((Component)deepSeaIsland).transform.position - ((Component)assignee).transform.position) > 22500f))
				{
					flag2 = true;
					if (assignee.IsStandingOnEntity(deepSeaIsland, 8388608))
					{
						flag = true;
						break;
					}
				}
			}
		}
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag3 = flag;
		if (completed != flag3)
		{
			if (flag3)
			{
				CompleteObjective(index, instance, assignee);
			}
			else if (!flag2)
			{
				ResetObjective(index, instance, assignee);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MissionObjective_GoToFloatingCity : MissionObjective
{
	[InspectorName("Distance For Completion (m)")]
	[Tooltip("Distance threshold to player for objective to complete (if distance is less that this value).")]
	public float distanceForCompletion = 50f;

	[Tooltip("Distance threshold to player for objective to reset (if distance is greater than this value).")]
	[InspectorName("Distance For Reset (m)")]
	public float distanceForReset = 50f;

	[Tooltip("If true, disregards distance on the y-plane.")]
	public bool use2DDistance = true;

	private float sqrDistanceForCompletion;

	private float sqrDistanceForReset;

	private void OnEnable()
	{
		CacheSqrDistanceForCompletion();
	}

	private void CacheSqrDistanceForCompletion()
	{
		sqrDistanceForCompletion = distanceForCompletion * distanceForCompletion;
		sqrDistanceForReset = distanceForReset * distanceForReset;
	}

	public override bool IsObjectiveValid(int index, BaseMission.MissionInstance instance)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			return false;
		}
		if (!PointEntity<DeepSeaManager>.ServerInstance.IsOpen())
		{
			return false;
		}
		for (int i = 0; i < DeepSeaManager.ServerFloatingCities.Count; i++)
		{
			if ((Object)(object)DeepSeaManager.ServerFloatingCities[i] != (Object)null)
			{
				return true;
			}
		}
		return false;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		DeepSeaFloatingCity deepSeaFloatingCity = null;
		int count = DeepSeaManager.ServerFloatingCities.Count;
		PooledList<int> val = Pool.Get<PooledList<int>>();
		try
		{
			((List<int>)(object)val).Capacity = count;
			for (int i = 0; i < count; i++)
			{
				((List<int>)(object)val).Add(i);
			}
			for (int j = 0; j < count; j++)
			{
				int num = Random.Range(j, count);
				int index2 = j;
				PooledList<int> val2 = val;
				int index3 = num;
				int num2 = ((List<int>)(object)val)[num];
				int num3 = ((List<int>)(object)val)[j];
				int num5 = (((List<int>)(object)val)[index2] = num2);
				num5 = (((List<int>)(object)val2)[index3] = num3);
				int num7 = ((List<int>)(object)val)[num];
				DeepSeaFloatingCity deepSeaFloatingCity2 = DeepSeaManager.ServerFloatingCities[num7];
				if ((Object)(object)deepSeaFloatingCity2 != (Object)null)
				{
					deepSeaFloatingCity = deepSeaFloatingCity2;
					break;
				}
			}
			if ((Object)(object)deepSeaFloatingCity == (Object)null)
			{
				Debug.LogError((object)("Mission " + ((Object)instance.GetMission()).name + " failed to find a floating city"), (Object)(object)instance.GetMission());
				return;
			}
			SetObjectiveWorldLocation(index, instance, ((Component)deepSeaFloatingCity).transform.position);
			playerFor.MissionsDirty();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!CanProgress(index, instance) || (IsCompleted(index, instance) && instance.objectiveStatuses[index].blockReset))
		{
			return;
		}
		Vector3 objectiveWorldLocation = GetObjectiveWorldLocation(index, instance);
		float num = (use2DDistance ? Vector3Ex.SqrMagnitude2D(objectiveWorldLocation - ((Component)assignee).transform.position) : Vector3.SqrMagnitude(objectiveWorldLocation - ((Component)assignee).transform.position));
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = num <= sqrDistanceForCompletion;
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else if (num >= sqrDistanceForReset)
			{
				ResetObjective(index, instance, assignee);
			}
		}
	}
}


using UnityEngine;

public class MissionObjective_GoToUnderwaterLab : MissionObjective
{
	[BaseMission.PositionGenerator.PositionPoint]
	public string position;

	[Min(0f)]
	[Tooltip("Player must be within underwater labs environment volume and within this distance of the mission point for the objective to complete.")]
	public float minimumDistanceToPosition = 100f;

	public bool shouldHideCompassMarkerWhenClose;

	[Min(0f)]
	[Tooltip("If \"Should Hide Compass Marker When Close\" is enabled and player is within this distance of the mission point then hide the compass marker, else the compass marker is visible.")]
	public float hideCompassMarkerDistance = 50f;

	private float sqrMinimumDistanceToPosition;

	private float sqrDistanceToHideCompassMarker;

	private void OnEnable()
	{
		CacheSqrDistanceForCompletion();
	}

	private void CacheSqrDistanceForCompletion()
	{
		sqrMinimumDistanceToPosition = minimumDistanceToPosition * minimumDistanceToPosition;
		sqrDistanceToHideCompassMarker = hideCompassMarkerDistance * hideCompassMarkerDistance;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.TryGetMissionPoint(position, out var point);
		SetObjectiveWorldLocation(index, instance, point);
		playerFor.MissionsDirty();
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (!CanProgress(index, instance) || (IsCompleted(index, instance) && instance.objectiveStatuses[index].blockReset))
		{
			return;
		}
		float num = Vector3.SqrMagnitude(GetObjectiveWorldLocation(index, instance) - ((Component)assignee).transform.position);
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = num < sqrMinimumDistanceToPosition && EnvironmentManager.Check(((Component)assignee).transform.position, EnvironmentType.UnderwaterLab);
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else
			{
				ResetObjective(index, instance, assignee);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Harvest")]
public class MissionObjective_Harvest : MissionObjective
{
	[ItemSelector]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public ItemDefinition[] pingResourceDispensers;

	[SerializeField]
	private BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool countExisting;

	public override BasePlayer.PingType PingType => pingType;

	public override void PostServerLoad(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.PostServerLoad(index, instance, forPlayer);
		if (instance.objectiveStatuses[index].IsObjectiveActive())
		{
			InitialiseResourcePings(forPlayer);
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		InitialiseResourcePings(playerFor);
		if (countExisting && targetItems.Length != 0)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.HARVEST, new BaseMission.MissionEventPayload
			{
				IntIdentifier = targetItems[0].itemid
			}, num);
		}
	}

	private void InitialiseResourcePings(BasePlayer forPlayer)
	{
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				forPlayer.EnableResourcePings(forItem, pingType);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HARVEST || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == payload.IntIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionsDirty(saveImmediately: true);
				break;
			}
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				playerFor.DisableResourcePings(forItem, pingType);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HaveItem")]
public class MissionObjective_HaveItem : MissionObjective
{
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	[Tooltip("If true, this objective will no longer be marked as completed if the objective criteria are no longer met.")]
	public bool canBeReset = true;

	[Tooltip("If true and canBeReset is enabled, then all objectives after this one will also be reset if this objective criteria is no longer met.")]
	public bool resetFollowupObjectives = true;

	[Header("Tutorial")]
	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		if (!CanProgress(index, instance) || (Object)(object)targetItem == (Object)null || (IsCompleted(index, instance) && canBeReset && instance.objectiveStatuses[index].blockReset) || (IsCompleted(index, instance) && !canBeReset))
		{
			return;
		}
		int amount = assignee.inventory.GetAmount(targetItem.itemid);
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = amount >= targetItemAmount;
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else
			{
				ResetObjective(index, instance, assignee);
				if (resetFollowupObjectives)
				{
					ResetFollowupObjectives(index, instance, assignee, resetStartedStatus: true);
				}
			}
		}
		if (amount != (int)instance.objectiveStatuses[index].progressCurrent)
		{
			instance.objectiveStatuses[index].progressCurrent = amount;
			assignee.MissionsDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Heal")]
public class MissionObjective_Heal : MissionObjective
{
	[Range(0f, 1f)]
	public float RequiredHealthNormalised = 0.5f;

	public BaseEntityRef RequireHealSource;

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!IsCompleted(index, instance) && CanProgress(index, instance) && type == BaseMission.MissionEventType.HEAL && (RequireHealSource == null || RequireHealSource.Get().prefabID == payload.UintIdentifier) && playerFor.healthFraction >= RequiredHealthNormalised)
		{
			CompleteObjective(index, instance, playerFor);
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtEntityType")]
public class MissionObjective_HurtEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (!baseCombatEntity.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == baseCombatEntity.prefabID)
			{
				instance.objectiveStatuses[index].progressCurrent += amount;
				if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionsDirty(saveImmediately: true);
				break;
			}
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			SetObjectiveWorldLocation(index, instance, ((Component)entity).transform.position);
			assignee.MissionsDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtMissionEntity")]
public class MissionObjective_HurtMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity spawnedMissionEntity = instance.GetSpawnedMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)spawnedMissionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = spawnedMissionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (baseCombatEntity.IsValid() && baseCombatEntity.EqualNetID((BaseNetworkable)entity))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity spawnedMissionEntity = instance.GetSpawnedMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)spawnedMissionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)spawnedMissionEntity).transform.position;
			if (position != GetObjectiveWorldLocation(index, instance))
			{
				SetObjectiveWorldLocation(index, instance, position);
				assignee.MissionsDirty();
			}
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Ignite Oven")]
public class MissionObjective_IgniteOven : MissionObjective
{
	public BaseEntityRef TargetOven;

	public bool PingTarget;

	[FormerlySerializedAs("PingType")]
	[SerializeField]
	private BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	private Func<BaseCombatEntity, bool> searchFilter;

	public override BasePlayer.PingType PingType => pingType;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => e.IsAlive() && e.prefabID == TargetOven.resourceID;
		}
		if (PingTarget && TryFindNearby(((Component)forPlayer).transform.position, searchFilter, out var entity, 200f))
		{
			SetObjectiveWorldLocation(index, instance, ((Component)entity).transform.position);
			forPlayer.RegisterPingedEntity(entity, PingType);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.STARTOVEN || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		if (TargetOven.resourceID == payload.UintIdentifier)
		{
			CompleteObjective(index, instance, playerFor);
			if (PingTarget)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
		playerFor.MissionsDirty(saveImmediately: true);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Kill")]
public class MissionObjective_KillEntity : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToKill;

	public bool shouldUpdateMissionLocation;

	public bool pingTargets;

	public bool doKillsFromTeamMembersCount;

	[Tooltip("If enabled, the player must be within the defined distance threshold of the team member which initiated the kill for the objective to progress.")]
	public bool enableDistanceThresholdForTeamkills;

	public float teamkillDistanceThreshold = 50f;

	public Enum mustBeInBiome = (Enum)(-1);

	private bool isInitialized;

	private uint[] targetPrefabIDs;

	private float teamkillDistanceThresholdSqr;

	private Func<BaseCombatEntity, bool> searchFilter;

	public override BasePlayer.PingType PingType => BasePlayer.PingType.Hostile;

	private void CacheSqrDistanceForCompletion()
	{
		teamkillDistanceThresholdSqr = teamkillDistanceThreshold * teamkillDistanceThreshold;
	}

	private void EnsureInitialized()
	{
		if (!isInitialized)
		{
			CacheSqrDistanceForCompletion();
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
			isInitialized = true;
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = numToKill;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Invalid comparison between Unknown and I4
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.KILL_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		NetworkableId networkIdentifier = payload.NetworkIdentifier;
		uint uintIdentifier = payload.UintIdentifier;
		int intIdentifier = payload.IntIdentifier;
		bool flag = playerFor.net.ID == networkIdentifier;
		if (doKillsFromTeamMembersCount)
		{
			if (!flag)
			{
				if (!(BaseNetworkable.serverEntities.Find(networkIdentifier) is BasePlayer { Team: not null } basePlayer))
				{
					return;
				}
				bool flag2 = false;
				foreach (ulong member in basePlayer.Team.members)
				{
					if (member == (ulong)playerFor.userID)
					{
						flag2 = true;
						break;
					}
				}
				if (!flag2 || (enableDistanceThresholdForTeamkills && Vector3.SqrMagnitude(((Component)basePlayer).transform.position - ((Component)playerFor).transform.position) > teamkillDistanceThresholdSqr))
				{
					return;
				}
			}
		}
		else if (!flag)
		{
			return;
		}
		if ((int)mustBeInBiome != -1 && ((((Object)(object)TerrainMeta.BiomeMap == (Object)null) ? 2 : TerrainMeta.BiomeMap.GetBiomeMaxType(payload.WorldPosition)) & mustBeInBiome) == 0)
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == uintIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += intIdentifier;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToKill)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
				playerFor.MissionsDirty(saveImmediately: true);
				break;
			}
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		EnsureInitialized();
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (IsCompleted(index, instance))
		{
			return;
		}
		assignee.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity, pingTargets ? 200f : 20f))
		{
			SetObjectiveWorldLocation(index, instance, ((Component)entity).transform.position);
			assignee.MissionsDirty();
			if (pingTargets)
			{
				assignee.RegisterPingedEntity(entity, BasePlayer.PingType.Hostile);
			}
		}
	}
}


using UnityEngine;

public class MissionObjective_MetalDetectorDeepSeaTreasure : MissionObjective
{
	public GameObjectRef treasurePrefab;

	public Phrase notePhrase;

	[Tooltip("Player must have dug this many metal detector sources already for the treasure to spawn.")]
	[Min(0f)]
	public int minimumDigAttempts;

	[Min(0f)]
	[Tooltip("After this many dug up metal detector sources treasure spawn is guaranteed.")]
	public int maximumDigAttempts;

	[Tooltip("Random chance of treasure spawning after Minimum Dig Attempts.")]
	[Range(0f, 1f)]
	public float successfulDigChange = 0.33f;

	public override bool IsObjectiveValid(int index, BaseMission.MissionInstance instance)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			return false;
		}
		for (int i = 0; i < DeepSeaManager.ServerIslands.Count; i++)
		{
			if ((Object)(object)DeepSeaManager.ServerIslands[i] != (Object)null)
			{
				return true;
			}
		}
		return false;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			Debug.LogError((object)("Mission instance for " + ((Object)instance.GetMission()).name + " failed to retrieve server instance for DeepSeaManager"), (Object)(object)instance.GetMission());
		}
		else
		{
			SetObjectiveWorldLocation(index, instance, ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).center);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!IsObjectiveActive(index, instance))
		{
			return;
		}
		switch (type)
		{
		case BaseMission.MissionEventType.KILL_ENTITY:
			if (payload.UintIdentifier == treasurePrefab.resourceID)
			{
				ClearSoftCompletedStatus(index, instance, playerFor);
			}
			break;
		case BaseMission.MissionEventType.METAL_DETECTOR_FIND:
			if (payload.UintIdentifier == treasurePrefab.resourceID)
			{
				instance.objectiveStatuses[index].progressCurrent = float.PositiveInfinity;
				SoftCompleteObjective(index, instance, playerFor);
			}
			else if (DeepSeaManager.IsInsideDeepSea(payload.WorldPosition) && !FloatEx.IsInfinity(instance.objectiveStatuses[index].progressCurrent))
			{
				instance.objectiveStatuses[index].progressCurrent += 1f;
			}
			break;
		case BaseMission.MissionEventType.OPEN_STORAGE:
			if (payload.UintIdentifier == treasurePrefab.resourceID)
			{
				CompleteObjective(index, instance, playerFor);
			}
			break;
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Metal Detector")]
public class MissionObjective_MetalDetectorFind : MissionObjective
{
	public int RequiredFinds = 3;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredFinds;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.METAL_DETECTOR_FIND && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionsDirty(saveImmediately: true);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountEntityType")]
public class MissionObjective_MountEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToMount = 1;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		if (numToMount > 1)
		{
			instance.objectiveStatuses[index].progressTarget = numToMount;
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (!baseMountable.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		foreach (uint num in array)
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (num == baseMountable.prefabID || (!((Object)(object)baseVehicle == (Object)null) && num == baseVehicle.prefabID))
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToMount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionsDirty(saveImmediately: true);
				break;
			}
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue;
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			SetObjectiveWorldLocation(index, instance, ((Component)entity).transform.position);
			assignee.MissionsDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountMissionEntity")]
public class MissionObjective_MountMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public bool shouldUpdateMissionLocation = true;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.GetSpawnedMissionEntity(targetIdentifier, playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity spawnedMissionEntity = instance.GetSpawnedMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)spawnedMissionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = spawnedMissionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (baseMountable.IsValid())
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (baseMountable.EqualNetID((BaseNetworkable)entity) || ((Object)(object)baseVehicle != (Object)null && baseVehicle.EqualNetID((BaseNetworkable)entity)))
			{
				CompleteObjective(index, instance, playerFor);
			}
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity spawnedMissionEntity = instance.GetSpawnedMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)spawnedMissionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)spawnedMissionEntity).transform.position;
			if (position != GetObjectiveWorldLocation(index, instance))
			{
				SetObjectiveWorldLocation(index, instance, position);
				assignee.MissionsDirty();
			}
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Move")]
public class MissionObjective_Move : MissionObjective
{
	[BaseMission.PositionGenerator.PositionPoint]
	public string positionName = "default";

	[Tooltip("Distance threshold to player for objective to complete.")]
	[InspectorName("Distance For Completion (m)")]
	public float distForCompletion = 3f;

	[Tooltip("If true, this objective will no longer be marked as completed if the objective criteria are no longer met.")]
	public bool canBeReset;

	[InspectorName("Distance For Reset (m)")]
	[Tooltip("If \"Can Be Reset\" is true, then distance ")]
	public float distanceForReset = 3f;

	[FormerlySerializedAs("use2D")]
	[Tooltip("If true, disregards distance on the y-plane.")]
	public bool use2DDistance;

	[Tooltip("If set, player must be mounted on this mountable for objective to complete.")]
	public BaseMountable requiredMountable;

	[InspectorName("Should Ping (Tutorial Only)")]
	[Tooltip("If true, displays a UI objective marker for this objective. Only works if at Tutorial Island.")]
	public bool shouldPing;

	[Tooltip("Ping type for when shouldPing is enabled.")]
	[SerializeField]
	private BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	private float sqrDistanceForCompletion;

	private float sqrDistanceForReset;

	public override BasePlayer.PingType PingType => pingType;

	private void OnEnable()
	{
		CacheSqrDistances();
	}

	private void CacheSqrDistances()
	{
		sqrDistanceForCompletion = distForCompletion * distForCompletion;
		sqrDistanceForReset = distanceForReset * distanceForReset;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.TryGetMissionPoint(positionName, out var point);
		SetObjectiveWorldLocation(index, instance, point);
		playerFor.MissionsDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, GetObjectiveWorldLocation(index, instance), 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	protected override void DoServerThink(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		if (!CanProgress(index, instance) || (IsCompleted(index, instance) && canBeReset && instance.objectiveStatuses[index].blockReset) || (IsCompleted(index, instance) && !canBeReset) || ((Object)(object)requiredMountable != (Object)null && (!assignee.isMounted || assignee.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		instance.TryGetMissionPoint(positionName, out var point);
		float num = (use2DDistance ? Vector3Ex.SqrMagnitude2D(point - ((Component)assignee).transform.position) : Vector3.SqrMagnitude(point - ((Component)assignee).transform.position));
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = num <= sqrDistanceForCompletion;
		if (completed == flag)
		{
			return;
		}
		if (flag)
		{
			CompleteObjective(index, instance, assignee);
			if (shouldPing)
			{
				TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
				if ((Object)(object)currentTutorialIsland != (Object)null)
				{
					assignee.RemovePingAtLocation(pingType, GetObjectiveWorldLocation(index, instance), float.MaxValue, currentTutorialIsland.net.ID);
				}
			}
		}
		else if (canBeReset && num >= sqrDistanceForReset)
		{
			ResetObjective(index, instance, assignee);
		}
	}
}


using UnityEngine;

public class MissionObjective_OpenStorageContainer : MissionObjective
{
	public BaseEntity TargetEntity;

	[BaseMission.PositionGenerator.PositionPoint]
	[Tooltip("The opened container must be nearby this mission point for the objective to complete.")]
	public string RequireProximityToPosition;

	[Min(0f)]
	[Tooltip("If RequireProximityToPosition is set, this defines the minimum proximity between the opened storage container and the mission point.")]
	public float MinimumDistanceToMissionPoint;

	private float sqrDistanceToMissionPoint;

	private void OnEnable()
	{
		CacheSqrDistanceForCompletion();
	}

	private void CacheSqrDistanceForCompletion()
	{
		sqrDistanceToMissionPoint = MinimumDistanceToMissionPoint * MinimumDistanceToMissionPoint;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.OPEN_STORAGE || IsCompleted(index, instance) || !CanProgress(index, instance) || TargetEntity.prefabID != payload.UintIdentifier)
		{
			return;
		}
		if (!BaseNetworkable.serverEntities.TryGetEntity(payload.NetworkIdentifier, out var entity))
		{
			Debug.LogError((object)$"Failed to find {payload.NetworkIdentifier} in server entities", (Object)(object)this);
			return;
		}
		if (!string.IsNullOrWhiteSpace(RequireProximityToPosition))
		{
			instance.TryGetMissionPoint(RequireProximityToPosition, out var point);
			if (Vector3.SqrMagnitude(point - ((Component)entity).transform.position) > sqrDistanceToMissionPoint)
			{
				return;
			}
		}
		CompleteObjective(index, instance, playerFor);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Open Tutorial Storage")]
public class MissionObjective_OpenTutorialStorageContainer : MissionObjective
{
	public ItemAmount[] Items;

	public BaseEntity TargetEntity;

	public override BasePlayer.PingType PingType => BasePlayer.PingType.Loot;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			currentTutorialIsland.TutorialContainer.LoadStorage(Items);
		}
		playerFor.RegisterPingedEntity(currentTutorialIsland.TutorialContainer, BasePlayer.PingType.Loot);
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	private void DeregisterPing(BasePlayer playerFor)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			playerFor.DeregisterPingedEntity(currentTutorialIsland.TutorialContainer.net.ID, BasePlayer.PingType.Loot);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.OPEN_STORAGE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.UintIdentifier == TargetEntity.prefabID)
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

public class MissionObjective_PlayBoomboxStation : MissionObjective
{
	public string targetRadioIp;

	[Tooltip("If true, the boombox must be a static environment boombox for this objective to complete.")]
	public bool boomboxMustBeStatic;

	[Tooltip("The boombox must be nearby this mission point for the objective to complete.")]
	[BaseMission.PositionGenerator.PositionPoint]
	public string requireProximityToPosition;

	[Min(0f)]
	[Tooltip("If RequireProximityToPosition is set, this defines the minimum proximity between the boombox and the mission point.")]
	public float minimumDistanceToMissionPoint;

	public bool shouldHideCompassMarkerWhenClose;

	[Tooltip("If \"Should Hide Compass Marker When Close\" is enabled and player is within this distance of the mission point then hide the compass marker, else the compass marker is visible.")]
	[Min(0f)]
	public float hideCompassMarkerDistance = 50f;

	private float sqrDistanceToMissionPoint;

	private float sqrDistanceToHideCompassMarker;

	private void OnEnable()
	{
		CacheSqrDistanceForCompletion();
	}

	private void CacheSqrDistanceForCompletion()
	{
		sqrDistanceToMissionPoint = minimumDistanceToMissionPoint * minimumDistanceToMissionPoint;
		sqrDistanceToHideCompassMarker = hideCompassMarkerDistance * hideCompassMarkerDistance;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.TryGetMissionPoint(requireProximityToPosition, out var point);
		SetObjectiveWorldLocation(index, instance, point);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.PLAY_BOOMBOX || IsCompleted(index, instance) || !CanProgress(index, instance) || (boomboxMustBeStatic && !Mathf.Approximately(1f, amount)) || string.IsNullOrWhiteSpace(payload.StringIdentifier) || payload.StringIdentifier != targetRadioIp)
		{
			return;
		}
		if (!string.IsNullOrWhiteSpace(requireProximityToPosition))
		{
			instance.TryGetMissionPoint(requireProximityToPosition, out var point);
			if (Vector3.SqrMagnitude(point - payload.WorldPosition) > sqrDistanceToMissionPoint)
			{
				return;
			}
		}
		if (BaseNetworkable.serverEntities.TryGetEntity(payload.NetworkIdentifier, out var entity))
		{
			instance.persistentMissionEntities.Add(entity);
		}
		else
		{
			Debug.LogError((object)("Failed to find a server entity with network ID " + ((object)(NetworkableId)(ref payload.NetworkIdentifier)/*cast due to .constrained prefix*/).ToString()));
		}
		CompleteObjective(index, instance, playerFor);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/PlayerInput")]
public class MissionObjective_PlayerInput : MissionObjective
{
	public BUTTON requiredButton;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.EnablePlayerInput();
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.PLAYER_TICK && !IsCompleted(index, instance) && CanProgress(index, instance) && playerFor.serverInput.IsDown(requiredButton))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Respawn")]
public class MissionObjective_Respawn : MissionObjective
{
	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.RESPAWN && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Retrieve Items from corpse")]
public class MissionObjective_RetrieveItemsFromCorpse : MissionObjective
{
	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		if (playerFor.ServerCurrentDeathNote == null)
		{
			return;
		}
		List<PlayerCorpse> list = Pool.Get<List<PlayerCorpse>>();
		Vis.Entities(playerFor.ServerCurrentDeathNote.worldPosition, 3f, list, 512, (QueryTriggerInteraction)2);
		foreach (PlayerCorpse item in list)
		{
			if ((Object)(object)item != (Object)null && item.isServer)
			{
				playerFor.RegisterPingedEntity(item, BasePlayer.PingType.Loot);
				break;
			}
		}
		Pool.FreeUnmanaged<PlayerCorpse>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.OPEN_STORAGE || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(payload.NetworkIdentifier);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			bool flag = baseNetworkable is PlayerCorpse playerCorpse && playerCorpse.playerSteamID == (ulong)playerFor.userID;
			if (!flag && baseNetworkable is DroppedItemContainer droppedItemContainer && droppedItemContainer.playerSteamID == (ulong)playerFor.userID)
			{
				flag = true;
			}
			if (flag)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, BasePlayer.PingType.Loot);
				CompleteObjective(index, instance, playerFor);
			}
		}
	}
}


using System;
using ConVar;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/SpeakWith")]
public class MissionObjective_SpeakWith : MissionObjective
{
	public ItemAmount[] requiredReturnItems = Array.Empty<ItemAmount>();

	public bool destroyReturnItems;

	public bool showPing;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		IMissionProvider missionProvider = instance.GetMissionProvider();
		if (missionProvider != null)
		{
			SetObjectiveWorldLocation(index, instance, missionProvider.ProviderPosition());
			if (showPing && playerFor.IsInTutorial)
			{
				playerFor.RegisterPingedEntity(missionProvider.Entity(), BasePlayer.PingType.GoTo);
			}
			playerFor.MissionsDirty();
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CONVERSATION)
		{
			return;
		}
		BaseMission mission = instance.GetMission();
		if (mission == null)
		{
			Debug.LogError((object)$"Failed to retrieve mission from mission instance ID {instance.missionID}");
			return;
		}
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} instance IsCompleted:{IsCompleted(index, instance)} CanProgress:{CanProgress(index, instance)}, amount: {amount}");
		}
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		IMissionProvider missionProvider = instance.GetMissionProvider();
		if (missionProvider == null)
		{
			if (Debugging.printMissionSpeakInfo)
			{
				Debug.Log((object)("[MissionSpeakInfo] objective " + ((Object)this).name + " on " + ((Object)mission).name + " failed to find a provider entity attached to this mission instance"));
			}
			return;
		}
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} looking for provider: {instance.providerID.Value}/{((Object)missionProvider.Entity()).name} Supplied NPC:{payload.NetworkIdentifier}");
		}
		if (missionProvider.ProviderID() == payload.NetworkIdentifier && Mathf.Approximately(amount, 1f))
		{
			bool flag = true;
			ItemAmount[] array = requiredReturnItems;
			foreach (ItemAmount itemAmount in array)
			{
				if ((float)playerFor.inventory.GetAmount(itemAmount.itemDef.itemid) < itemAmount.amount)
				{
					flag = false;
					break;
				}
			}
			if (mission.HasRewards())
			{
				if (Debugging.printMissionSpeakInfo)
				{
					Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} CheckRewardsSpace: {playerFor.HasSpaceForMissionRewards(instance)}");
				}
				if (flag && destroyReturnItems)
				{
					if (!playerFor.HasSpaceForMissionRewards(instance, showToastOnFailure: true))
					{
						return;
					}
					array = requiredReturnItems;
					foreach (ItemAmount itemAmount2 in array)
					{
						playerFor.inventory.Take(null, itemAmount2.itemDef.itemid, (int)itemAmount2.amount);
					}
				}
				if (Debugging.printMissionSpeakInfo)
				{
					Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} CheckRewardsSpace: {playerFor.HasSpaceForMissionRewards(instance)}");
				}
				if (!playerFor.HasSpaceForMissionRewards(instance, showToastOnFailure: true))
				{
					return;
				}
			}
			if (Debugging.printMissionSpeakInfo)
			{
				Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} requiredReturnItems == null: {requiredReturnItems == null}, requiredReturnItems.Length: {requiredReturnItems.Length}, hasAllReturnItems: {flag}");
			}
			if (requiredReturnItems == null || requiredReturnItems.Length == 0 || flag)
			{
				CompleteObjective(index, instance, playerFor);
			}
		}
		else if (Debugging.printMissionSpeakInfo)
		{
			if (missionProvider.ProviderID() != payload.NetworkIdentifier)
			{
				Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} failed to match supplied network ID {payload.NetworkIdentifier} with instance missionProvider.ProviderID(): {missionProvider.ProviderID()}. ProviderID() should match instance.providerID: {instance.providerID}");
			}
			if (!Mathf.Approximately(amount, 1f))
			{
				Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} supplied amount {amount} is not approximately 1f");
			}
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}

	private static void DeregisterPing(BasePlayer playerFor, BaseMission.MissionInstance instance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		IMissionProvider missionProvider = instance.GetMissionProvider();
		if (missionProvider != null)
		{
			playerFor.DeregisterPingedEntity(missionProvider.ProviderID(), BasePlayer.PingType.GoTo);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}
}


using System;
using ConVar;
using UnityEngine;

public class MissionObjective_SpeakWithTargetNPC : MissionObjective
{
	public ItemAmount[] requiredReturnItems = Array.Empty<ItemAmount>();

	public BaseEntityRef TargetNPC;

	[Tooltip("The target NPC must be nearby this mission point for the objective to complete.")]
	[BaseMission.PositionGenerator.PositionPoint]
	public string RequireProximityToPosition;

	[Tooltip("This defines the minimum proximity between the target NPC and the mission point.")]
	[Min(0f)]
	public float MinimumDistanceToMissionPoint;

	public bool destroyReturnItems;

	public bool showPing;

	private Func<BaseEntity, bool> searchFilter;

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		if (string.IsNullOrWhiteSpace(RequireProximityToPosition))
		{
			Debug.LogError((object)("RequireProximityToPosition is not set on objective " + ((Object)this).name), (Object)(object)this);
			return;
		}
		if (!instance.missionPoints.TryGetValue(RequireProximityToPosition, out var value))
		{
			Debug.LogError((object)("No mission point found for " + RequireProximityToPosition + " on objective " + ((Object)this).name), (Object)(object)this);
			return;
		}
		if (searchFilter == null)
		{
			searchFilter = (BaseEntity entity) => TargetNPC.isValid && (Object)(object)TargetNPC.Get() != (Object)null && TargetNPC.Get().prefabID == entity.prefabID;
		}
		if (TryFindNearby(value, searchFilter, out var entity2, 100f))
		{
			SetObjectiveWorldLocation(index, instance, ((Component)entity2).transform.position);
			if (showPing && playerFor.IsInTutorial)
			{
				playerFor.RegisterPingedEntity(entity2, PingType);
			}
		}
		else
		{
			Debug.LogError((object)("Failed to find an entity for " + TargetNPC.resourcePath + " on objective " + ((Object)this).name), (Object)(object)this);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CONVERSATION)
		{
			return;
		}
		BaseMission mission = instance.GetMission();
		if (mission == null)
		{
			Debug.LogError((object)$"Failed to retrieve mission from mission instance ID {instance.missionID}");
			return;
		}
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} instance IsCompleted:{IsCompleted(index, instance)} CanProgress:{CanProgress(index, instance)}, amount: {amount}");
		}
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		if (!BaseNetworkable.serverEntities.TryGetEntity(payload.NetworkIdentifier, out var entity))
		{
			if (Debugging.printMissionSpeakInfo)
			{
				Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} failed to find a entity from payload NetworkIdentifier: {payload.NetworkIdentifier}");
			}
			return;
		}
		if (entity.prefabID != TargetNPC.Get().prefabID)
		{
			if (Debugging.printMissionSpeakInfo)
			{
				Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} entity {((Object)entity).name} provided from payload NetworkIdentifier: {payload.NetworkIdentifier} has prefabID: {entity.prefabID} which does not match target prefabID: {TargetNPC.Get().prefabID}", (Object)(object)entity);
			}
			return;
		}
		if (!string.IsNullOrWhiteSpace(RequireProximityToPosition))
		{
			if (!instance.missionPoints.TryGetValue(RequireProximityToPosition, out var value))
			{
				if (Debugging.printMissionSpeakInfo)
				{
					Debug.Log((object)("[MissionSpeakInfo] objective " + ((Object)this).name + " on " + ((Object)mission).name + " failed to find mission point for " + RequireProximityToPosition));
				}
				return;
			}
			float num = Vector3.SqrMagnitude(value - ((Component)entity).transform.position);
			float num2 = MinimumDistanceToMissionPoint * MinimumDistanceToMissionPoint;
			if (num > num2)
			{
				if (Debugging.printMissionSpeakInfo)
				{
					Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} entity {((Object)entity).name} provided from payload NetworkIdentifier: {payload.NetworkIdentifier} is {num} square distance away from point {value}, minimum square distance is {num2}", (Object)(object)entity);
				}
				return;
			}
		}
		if (Mathf.Approximately(amount, 1f))
		{
			bool flag = true;
			ItemAmount[] array = requiredReturnItems;
			foreach (ItemAmount itemAmount in array)
			{
				if ((float)playerFor.inventory.GetAmount(itemAmount.itemDef.itemid) < itemAmount.amount)
				{
					flag = false;
					break;
				}
			}
			if (mission.HasRewards())
			{
				if (Debugging.printMissionSpeakInfo)
				{
					Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} CheckRewardsSpace: {playerFor.HasSpaceForMissionRewards(instance)}");
				}
				if (flag && destroyReturnItems)
				{
					if (!playerFor.HasSpaceForMissionRewards(instance, showToastOnFailure: true))
					{
						return;
					}
					array = requiredReturnItems;
					foreach (ItemAmount itemAmount2 in array)
					{
						playerFor.inventory.Take(null, itemAmount2.itemDef.itemid, (int)itemAmount2.amount);
					}
				}
				if (Debugging.printMissionSpeakInfo)
				{
					Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} CheckRewardsSpace: {playerFor.HasSpaceForMissionRewards(instance)}");
				}
				if (!playerFor.HasSpaceForMissionRewards(instance, showToastOnFailure: true))
				{
					return;
				}
			}
			if (Debugging.printMissionSpeakInfo)
			{
				Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} requiredReturnItems == null: {requiredReturnItems == null}, requiredReturnItems.Length: {requiredReturnItems.Length}, hasAllReturnItems: {flag}");
			}
			if (requiredReturnItems == null || requiredReturnItems.Length == 0 || flag)
			{
				CompleteObjective(index, instance, playerFor);
			}
		}
		else if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"[MissionSpeakInfo] objective {((Object)this).name} on {((Object)mission).name} supplied amount {amount} is not approximately 1f");
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}

	private static void DeregisterPing(BasePlayer playerFor, BaseMission.MissionInstance instance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		IMissionProvider missionProvider = instance.GetMissionProvider();
		if (missionProvider != null)
		{
			playerFor.DeregisterPingedEntity(missionProvider.ProviderID(), BasePlayer.PingType.GoTo);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}
}


using UnityEngine;

public class MissionObjective_UnderwaterLabsBoomboxBonus : MissionObjective
{
	public string targetRadioIp;

	[Tooltip("The boombox must be nearby this mission point for the objective to complete.")]
	[BaseMission.PositionGenerator.PositionPoint]
	public string requireProximityToPosition;

	[Tooltip("If RequireProximityToPosition is set, this defines the minimum proximity between the boombox and the mission point.")]
	[Min(0f)]
	public float minimumDistanceToMissionPoint;

	public bool shouldHideCompassMarkerWhenClose;

	[Tooltip("If \"Should Hide Compass Marker When Close\" is enabled and player is within this distance of the mission point then hide the compass marker, else the compass marker is visible.")]
	[Min(0f)]
	public float hideCompassMarkerDistance = 50f;

	private float sqrDistanceToHideCompassMarker;

	public float sqrMinimumDistanceToMissionPoint { get; private set; }

	private void OnEnable()
	{
		CacheSqrDistanceForCompletion();
	}

	private void CacheSqrDistanceForCompletion()
	{
		sqrMinimumDistanceToMissionPoint = minimumDistanceToMissionPoint * minimumDistanceToMissionPoint;
		sqrDistanceToHideCompassMarker = hideCompassMarkerDistance * hideCompassMarkerDistance;
	}

	public override void ServerObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerObjectiveStarted(playerFor, index, instance);
		instance.TryGetMissionPoint(requireProximityToPosition, out var point);
		SetObjectiveWorldLocation(index, instance, point);
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		int num = 0;
		for (int i = 0; i < DeployableBoomBox.ServerStaticInstances.Count; i++)
		{
			DeployableBoomBox deployableBoomBox = DeployableBoomBox.ServerStaticInstances[i];
			if ((Object)(object)deployableBoomBox == (Object)null)
			{
				Debug.LogWarning((object)string.Format("Null boombox at index {0} in {1}", i, "ServerStaticInstances"));
			}
			else if (IsBoomboxPositionValid(((Component)deployableBoomBox).transform.position, forPlayer, instance))
			{
				num++;
			}
		}
		int num2 = num - 1;
		if (num2 <= 0)
		{
			CompleteObjective(index, instance, forPlayer);
			return;
		}
		instance.objectiveStatuses[index].progressTarget = 0f;
		instance.objectiveStatuses[index].progressTarget = num2;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.PLAY_BOOMBOX || !Mathf.Approximately(amount, 1f) || IsCompleted(index, instance) || !CanProgress(index, instance) || string.IsNullOrWhiteSpace(payload.StringIdentifier) || payload.StringIdentifier != targetRadioIp || !IsBoomboxPositionValid(payload.WorldPosition, playerFor, instance))
		{
			return;
		}
		if (!BaseNetworkable.serverEntities.TryGetEntity(payload.NetworkIdentifier, out var entity))
		{
			Debug.LogError((object)("Failed to find a server entity with network ID " + ((object)(NetworkableId)(ref payload.NetworkIdentifier)/*cast due to .constrained prefix*/).ToString()));
			return;
		}
		for (int i = 0; i < instance.persistentMissionEntities.Count; i++)
		{
			if ((Object)(object)instance.persistentMissionEntities[i] == (Object)(object)entity)
			{
				return;
			}
		}
		instance.persistentMissionEntities.Add(entity);
		BaseMission.MissionInstance.ObjectiveStatus objectiveStatus = instance.objectiveStatuses[index];
		objectiveStatus.progressCurrent += 1f;
		if (objectiveStatus.progressCurrent >= objectiveStatus.progressTarget)
		{
			CompleteObjective(index, instance, playerFor);
		}
		playerFor.MissionsDirty(saveImmediately: true);
	}

	private bool IsBoomboxPositionValid(Vector3 boomboxWorldPosition, BasePlayer playerFor, BaseMission.MissionInstance instance)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!string.IsNullOrWhiteSpace(requireProximityToPosition) && (!instance.TryGetMissionPoint(requireProximityToPosition, out var point) || Vector3.SqrMagnitude(point - boomboxWorldPosition) > sqrMinimumDistanceToMissionPoint))
		{
			return false;
		}
		if (!EnvironmentManager.Check(boomboxWorldPosition, EnvironmentType.UnderwaterLab))
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Upgrade Building Block")]
public class MissionObjective_UpgradeBuildingBlock : MissionObjective
{
	public bool ShouldPingBlocksLessThanTargetGrade;

	[SerializeField]
	[FormerlySerializedAs("PingType")]
	private BasePlayer.PingType pingType;

	public BuildingGrade.Enum TargetGrade;

	public int RequiredCount = 6;

	public override BasePlayer.PingType PingType => pingType;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredCount;
		if (!ShouldPingBlocksLessThanTargetGrade)
		{
			return;
		}
		TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		Vector3 worldPosOfBuildTarget = currentTutorialIsland.GetWorldPosOfBuildTarget(0);
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(worldPosOfBuildTarget, 32f, list, 2097152, (QueryTriggerInteraction)2);
		if (list.Count != RequiredCount)
		{
			Debug.LogWarning((object)("Non matching building block count, check RequiredCount on " + ((Object)this).name));
		}
		foreach (BuildingBlock item in list)
		{
			forPlayer.RegisterPingedEntity(item, pingType);
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier >= (int)TargetGrade)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)RequiredCount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionsDirty(saveImmediately: true);
			if (ShouldPingBlocksLessThanTargetGrade)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, pingType);
			}
		}
	}
}


using UnityEngine;

public class PVPMissionManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using UnityEngine;

public class TriggerMission : TriggerBase
{
	private BasePlayer cachedPlayer;

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent.ToPlayer() != (Object)null)
		{
			cachedPlayer = ent.ToPlayer();
			((FacepunchBehaviour)this).Invoke((Action)DelayedEntityCallback, 0f);
		}
	}

	private void DelayedEntityCallback()
	{
		if ((Object)(object)cachedPlayer != (Object)null)
		{
			cachedPlayer.ProcessMissionEvent(BaseMission.MissionEventType.ENTER_TRIGGER, 0, 0f);
		}
		cachedPlayer = null;
	}
}


using System;
using System.Threading.Tasks;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/WorldPositionGenerator")]
public class WorldPositionGenerator : ScriptableObject
{
	public SpawnFilter Filter = new SpawnFilter();

	public float FilterCutoff;

	public bool aboveWater;

	public float MaxSlopeRadius;

	public float MaxSlopeDegrees = 90f;

	public float CheckSphereRadius;

	public LayerMask CheckSphereMask;

	private Vector3 _origin;

	private Vector3 _area;

	private ByteQuadtree _quadtree;

	public bool TrySample(Vector3 origin, float minDist, float maxDist, float minDist_2x, float maxDist_2x, bool checkBlockedPoints, out Vector3 position)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WorldPositionGenerator.TrySample", 0);
		Rect inclusion;
		Rect exclusion;
		BufferList<Rect> blockedRects;
		BufferList<ByteQuadtree.Element> candidates;
		try
		{
			if (_quadtree == null)
			{
				PrecalculatePositions();
			}
			inclusion = new Rect(origin.x - maxDist, origin.z - maxDist, maxDist_2x, maxDist_2x);
			exclusion = new Rect(origin.x - minDist, origin.z - minDist, minDist_2x, minDist_2x);
			blockedRects = Pool.Get<BufferList<Rect>>();
			if (checkBlockedPoints)
			{
				Rect val3 = default(Rect);
				foreach (ListHashSet<Vector3> value in BaseMission.blockedPoints.Values)
				{
					for (int i = 0; i < value.Count; i++)
					{
						Vector3 val2 = value[i];
						((Rect)(ref val3))..ctor(val2.x - 10f, val2.z - 10f, 20f, 20f);
						blockedRects.Add(val3);
					}
				}
			}
			candidates = Pool.Get<BufferList<ByteQuadtree.Element>>();
			candidates.Add(_quadtree.Root);
			for (int j = 0; j < candidates.Count; j++)
			{
				ByteQuadtree.Element element2 = candidates[j];
				if (!element2.IsLeaf)
				{
					candidates.RemoveUnordered(j--);
					EvaluateCandidate(element2.Child1);
					EvaluateCandidate(element2.Child2);
					EvaluateCandidate(element2.Child3);
					EvaluateCandidate(element2.Child4);
				}
			}
			if (candidates.Count == 0)
			{
				position = origin;
				Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
				Pool.FreeUnmanaged<Rect>(ref blockedRects);
				return false;
			}
			Vector3 val5;
			if (CheckSphereRadius <= float.Epsilon)
			{
				ByteQuadtree.Element element3 = candidates[Random.Range(0, candidates.Count)];
				Rect val4 = GetElementRect(element3);
				val5 = Vector3Ex.XZ3D(((Rect)(ref val4)).min + ((Rect)(ref val4)).size * new Vector2(Random.value, Random.value));
			}
			else
			{
				Vector3 val7;
				while (true)
				{
					if (candidates.Count == 0)
					{
						position = Vector3.zero;
						return false;
					}
					int num = Random.Range(0, candidates.Count);
					ByteQuadtree.Element element4 = candidates[num];
					Rect val6 = GetElementRect(element4);
					val7 = Vector3Ex.XZ3D(((Rect)(ref val6)).center);
					val7.y = TerrainMeta.HeightMap.GetHeight(val7);
					if (!Physics.CheckSphere(val7, CheckSphereRadius, ((LayerMask)(ref CheckSphereMask)).value))
					{
						break;
					}
					candidates.RemoveAt(num);
				}
				val5 = val7;
			}
			position = Vector3Ex.WithY(val5, aboveWater ? WaterLevel.GetWaterOrTerrainSurface(val5, waves: false, volumes: false) : TerrainMeta.HeightMap.GetHeight(val5));
			Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
			Pool.FreeUnmanaged<Rect>(ref blockedRects);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		void EvaluateCandidate(ByteQuadtree.Element child)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			if (child.Value != 0)
			{
				Rect val8 = GetElementRect(child);
				if (((Rect)(ref val8)).Overlaps(inclusion) && (!((Rect)(ref exclusion)).Contains(((Rect)(ref val8)).min) || !((Rect)(ref exclusion)).Contains(((Rect)(ref val8)).max)))
				{
					if (blockedRects.Count > 0)
					{
						for (int k = 0; k < blockedRects.Count; k++)
						{
							Rect val9 = blockedRects[k];
							if (((Rect)(ref val9)).Contains(((Rect)(ref val8)).min) && ((Rect)(ref val9)).Contains(((Rect)(ref val8)).max))
							{
								return;
							}
						}
					}
					candidates.Add(child);
				}
			}
		}
		Rect GetElementRect(ByteQuadtree.Element element)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			int num2 = 1 << element.Depth;
			float num3 = 1f / (float)num2;
			Vector2 val10 = element.Coords * num3;
			return new Rect(_origin.x + val10.x * _area.x, _origin.z + val10.y * _area.z, _area.x * num3, _area.z * num3);
		}
	}

	public void PrecalculatePositions()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		int res = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.25f));
		byte[] map = new byte[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = ((float)i + 0.5f) / (float)res;
				float normZ = ((float)z + 0.5f) / (float)res;
				float factor = Filter.GetFactor(normX, normZ);
				if (factor > 0f && MaxSlopeRadius > 0f)
				{
					TerrainMeta.HeightMap.ForEach(normX, normZ, MaxSlopeRadius / (float)res, delegate(int slopeX, int slopeZ)
					{
						if (TerrainMeta.HeightMap.GetSlope(slopeX, slopeZ) > MaxSlopeDegrees)
						{
							factor = 0f;
						}
					});
				}
				map[z * res + i] = (byte)((factor >= FilterCutoff) ? (255f * factor) : 0f);
			}
		});
		_origin = TerrainMeta.Position;
		_area = TerrainMeta.Size;
		_quadtree = new ByteQuadtree();
		_quadtree.UpdateValues(map);
	}
}


using UnityEngine;

public class DelayedEnable : MonoBehaviour, IClientComponent
{
	public GameObject Target;
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CargoShipContainer : BaseEntity
{
	public GameObject[] DressingVariants;

	public const Flags Descending = Flags.Reserved1;

	public const Flags Targeted = Flags.Reserved2;

	private int dressingVariant;

	public override float AntiHackVelocity()
	{
		return 1f;
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		AssignVariant();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		UpdateDressingVariant();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateDressingVariant();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.cargoShipContainer = Pool.Get<CargoShipContainer>();
		info.msg.cargoShipContainer.dressingVariant = dressingVariant;
	}

	private void AssignVariant()
	{
		dressingVariant = Random.Range(0, DressingVariants.Length);
	}

	public void ToggleHurtCollider(bool state)
	{
		SetFlag(Flags.Reserved1, state);
	}

	public void SetTargeted(bool state)
	{
		SetFlag(Flags.Reserved2, state);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.cargoShipContainer != null)
		{
			dressingVariant = info.msg.cargoShipContainer.dressingVariant;
		}
		UpdateDressingVariant();
	}

	private void UpdateDressingVariant()
	{
		for (int i = 0; i < DressingVariants.Length; i++)
		{
			DressingVariants[i].SetActive(dressingVariant == i);
		}
	}
}


public class CargoShipContainerSounds : FacepunchBehaviour, IClientComponent
{
	public SoundDefinition liftDef;

	public SoundDefinition dropDef;
}


using UnityEngine;

public class HarborBridgeSounds : MonoBehaviour, IClientComponent
{
	public HarborProximityEntity bridge;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;
}


using UnityEngine;

public class HarborCrane : HarborProximityEntity
{
	public Transform CraneGrab;

	public Transform ArmRoot;

	public Transform ArmSupportLower;

	public Transform ArmSupportUpper;

	public TransformLineRenderer[] LineRenderers;

	protected void UpdateArmSupports(Vector3 fwd)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ArmSupportUpper == (Object)null) && !((Object)(object)ArmSupportLower == (Object)null))
		{
			Vector3 val = ArmSupportUpper.position - ArmSupportLower.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			ArmSupportLower.rotation = Quaternion.LookRotation(fwd, normalized);
			ArmSupportUpper.rotation = Quaternion.LookRotation(fwd, normalized);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneContainerPickup : HarborCrane
{
	public struct ContainerStack
	{
		public Transform RootPoint;

		public int MaxStackSize;

		public int CurrentStackSize { get; set; }
	}

	private struct QueuedMove
	{
		public EntityRef<CargoShipContainer> TargetEntity;

		public Vector3 TargetWorldPosition;

		public Quaternion TargetWorldRotation;

		public bool HasTarget;
	}

	private enum PickupState
	{
		RotateToFace,
		Lift,
		RotateToTarget,
		Drop,
		Reset
	}

	public Transform ServerTowerGrab;

	public float LockTime = 5f;

	public float MaxMoveDistance = 32f;

	public float PickedUpObjectRotationSpeed = 30f;

	private List<ContainerStack> Stacks;

	public GameObjectRef ContainerPrefab;

	private const float ContainerSize = 3f;

	public int MaxContainerStackSize = 3;

	public bool DebugContainerSpawns;

	public bool DebugContainerDestinations;

	private Vector3 grabOffset = new Vector3(0f, 19f, 0f);

	public static ListHashSet<HarborCraneContainerPickup> AllCranes = new ListHashSet<HarborCraneContainerPickup>();

	private Vector3 startForward;

	private List<QueuedMove> movesToMake = new List<QueuedMove>();

	private QueuedMove? moveInProcess;

	private EntityRef<CargoShip> toParent;

	private float moveDelay;

	private PickupState currentPickupState;

	private float lockOnTime;

	private float maxTargetHeight;

	public override void ServerInit()
	{
		base.ServerInit();
		AllCranes.Add(this);
		List<HarborCraneContainerSpawnPoint> list = Pool.Get<List<HarborCraneContainerSpawnPoint>>();
		FindNearbyContainerSpawns(list);
		Stacks = new List<ContainerStack>();
		foreach (HarborCraneContainerSpawnPoint item in list)
		{
			Stacks.Add(new ContainerStack
			{
				RootPoint = ((Component)item).transform,
				MaxStackSize = item.MaxStackSize
			});
		}
		Pool.FreeUnmanaged<HarborCraneContainerSpawnPoint>(ref list);
		UpdateArm();
		SendNetworkUpdate();
	}

	public override void PostMapEntitySpawn()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		startForward = ((Component)this).transform.forward;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		AllCranes.Remove(this);
	}

	private void FindNearbyContainerSpawns(List<HarborCraneContainerSpawnPoint> foundPoints)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Components<HarborCraneContainerSpawnPoint>(((Component)this).transform.position, MaxMoveDistance, foundPoints, 1218652417, (QueryTriggerInteraction)2);
	}

	private void ReplenishContainers(int totalContainers)
	{
		for (int i = 0; i < Stacks.Count; i++)
		{
			ContainerStack value = Stacks[i];
			value.CurrentStackSize = 0;
			Stacks[i] = value;
		}
		maxTargetHeight = 0f;
		int count = Stacks.Count;
		if (count == 0)
		{
			return;
		}
		int num = Random.Range(0, count);
		int num2 = 0;
		while (totalContainers > 0 && num2 < 50)
		{
			num2++;
			num++;
			if (num >= count)
			{
				num = 0;
			}
			ContainerStack containerStack = Stacks[num];
			if (SpawnContainerOnStack(containerStack))
			{
				containerStack.CurrentStackSize++;
				totalContainers--;
				Stacks[num] = containerStack;
			}
		}
		movesToMake.Reverse();
		bool SpawnContainerOnStack(ContainerStack stack)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			if (stack.CurrentStackSize >= MaxContainerStackSize || stack.CurrentStackSize >= stack.MaxStackSize)
			{
				return false;
			}
			if (CargoShip.docking_debug)
			{
				Debug.Log((object)$"Spawning container on stack {stack.RootPoint.position}");
			}
			Vector3 position = stack.RootPoint.position;
			position.y += (float)stack.CurrentStackSize * 3f;
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vis.Entities(new OBB(position, stack.RootPoint.rotation, new Bounds(new Vector3(0f, 1.5f, 0f), new Vector3(4.5f, 1.5f, 1.5f) * 0.8f)), list, 1218685185, (QueryTriggerInteraction)2);
			bool num3 = list.Count == 0;
			if (!num3 && CargoShip.docking_debug)
			{
				Debug.Log((object)("Container spawn blocked by " + ((Object)((Component)list[0]).gameObject).name), (Object)(object)list[0]);
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
			if (!num3)
			{
				return false;
			}
			CargoShipContainer cargoShipContainer = GameManager.server.CreateEntity(ContainerPrefab.resourcePath, position, stack.RootPoint.rotation) as CargoShipContainer;
			cargoShipContainer.Spawn();
			QueuedMove item = default(QueuedMove);
			item.TargetEntity.Set(cargoShipContainer);
			item.HasTarget = false;
			movesToMake.Add(item);
			return true;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = ServerTowerGrab.localPosition.z;
		info.msg.harborCrane.height = ServerTowerGrab.localPosition.y;
		info.msg.harborCrane.time = GetNetworkTime();
		info.msg.harborCrane.maxMoveHeight = maxTargetHeight;
		info.msg.harborCrane.toParent = toParent.uid;
		info.msg.harborCrane.startForward = startForward;
		info.msg.harborCrane.moveDelay = moveDelay;
		if (moveInProcess.HasValue)
		{
			info.msg.harborCrane.currentMove = Pool.Get<QueuedMove>();
			CreateMove(moveInProcess.Value, info.msg.harborCrane.currentMove);
		}
		if (movesToMake.Count > 0)
		{
			info.msg.harborCrane.queuedMoves = Pool.Get<List<QueuedMove>>();
			foreach (QueuedMove item in movesToMake)
			{
				QueuedMove val = Pool.Get<QueuedMove>();
				CreateMove(item, val);
				info.msg.harborCrane.queuedMoves.Add(val);
			}
		}
		info.msg.harborCrane.currentPickupState = (int)currentPickupState;
	}

	private QueuedMove CreateMove(QueuedMove from)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		QueuedMove result = default(QueuedMove);
		result.TargetEntity = new EntityRef<CargoShipContainer>(from.targetEntity);
		result.TargetWorldPosition = from.targetWorldPosition;
		result.TargetWorldRotation = new Quaternion(from.targetWorldRotation.x, from.targetWorldRotation.y, from.targetWorldRotation.z, from.targetWorldRotation.w);
		result.HasTarget = from.hasTarget;
		return result;
	}

	private void CreateMove(QueuedMove move, QueuedMove target)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		target.hasTarget = move.HasTarget;
		target.targetEntity = move.TargetEntity.uid;
		target.targetWorldPosition = move.TargetWorldPosition;
		target.targetWorldRotation = new Vector4(move.TargetWorldRotation.x, move.TargetWorldRotation.y, move.TargetWorldRotation.z, move.TargetWorldRotation.w);
	}

	private void CountdownDelay()
	{
		moveDelay -= Time.deltaTime;
		if (moveDelay <= 0f)
		{
			moveDelay = 0f;
			((FacepunchBehaviour)this).CancelInvoke((Action)CountdownDelay);
			CheckMoveQueue();
		}
	}

	private void CheckMoveQueue()
	{
		if (moveDelay > 0f && movesToMake.Count > 0 && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		else if (movesToMake.Count > 0 && !IsBusy() && movesToMake[0].HasTarget)
		{
			moveInProcess = movesToMake[0];
			movesToMake.RemoveAt(0);
			currentPickupState = PickupState.RotateToFace;
			lockOnTime = 0f;
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
	}

	private void ProcessCraneMovement()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0467: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_059b: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_05af: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0601: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_061a: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		if (!moveInProcess.HasValue)
		{
			return;
		}
		QueuedMove value = moveInProcess.Value;
		CargoShipContainer cargoShipContainer = value.TargetEntity.Get(serverside: true);
		if ((Object)(object)cargoShipContainer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Max(15.585f, Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight));
		float num2 = num;
		Vector3 val = ((Component)cargoShipContainer).transform.position;
		Vector3 val2 = Vector3Ex.WithY(val, position.y) - position;
		float num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
		Vector3 localPosition = ServerTowerGrab.localPosition;
		bool flag = false;
		float num4 = 0f;
		switch (currentPickupState)
		{
		case PickupState.RotateToFace:
			cargoShipContainer.SetTargeted(state: true);
			if (!(num3 < 2f))
			{
				break;
			}
			num2 = ((Component)this).transform.InverseTransformPoint(new Vector3(0f, ((Component)cargoShipContainer).transform.position.y + ((Bounds)(ref cargoShipContainer.bounds)).max.y, 0f)).y;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Lift;
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Lift:
			flag = true;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				currentPickupState = PickupState.RotateToTarget;
			}
			break;
		case PickupState.RotateToTarget:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (num3 < 0.1f)
			{
				currentPickupState = PickupState.Drop;
			}
			break;
		case PickupState.Drop:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num2 = ((Component)this).transform.InverseTransformPoint(value.TargetWorldPosition).y + ((Bounds)(ref cargoShipContainer.bounds)).size.y;
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Reset;
					((Component)cargoShipContainer).transform.SetPositionAndRotation(value.TargetWorldPosition, (PickedUpObjectRotationSpeed > 0f) ? value.TargetWorldRotation : ((Component)cargoShipContainer).transform.rotation);
					cargoShipContainer.SetParent(toParent.Get(serverside: true), worldPositionStays: true);
					cargoShipContainer.SetTargeted(state: false);
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Reset:
			num2 = num;
			val = ((Component)this).transform.position + startForward * 26f;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			if (num3 < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > 5f)
				{
					lockOnTime = 0f;
					SetFlag(Flags.Busy, b: false);
					((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
					CheckMoveQueue();
				}
			}
			break;
		}
		cargoShipContainer.ToggleHurtCollider(currentPickupState == PickupState.Drop);
		Quaternion val3 = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, val3, 5f * Time.deltaTime);
		float num5 = ((num4 > 0f) ? num4 : Vector3.Distance(Vector3Ex.WithY(val, position.y), position));
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		localPosition = Vector3.MoveTowards(localPosition, val4, Time.deltaTime * 2f);
		ServerTowerGrab.localPosition = localPosition;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		if (flag)
		{
			((Component)cargoShipContainer).transform.position = ServerTowerGrab.position - Vector3.up * ((Bounds)(ref cargoShipContainer.bounds)).size.y;
		}
		UpdateArm();
		SendNetworkUpdate();
		CargoShip cargoShip = toParent.Get(serverside: true);
		if (!((Object)(object)cargoShip != (Object)null) || cargoShip.HasFlag(Flags.Reserved1))
		{
			return;
		}
		foreach (QueuedMove item in movesToMake)
		{
			item.TargetEntity.Get(serverside: true).Kill();
		}
		if ((Object)(object)cargoShipContainer != (Object)null && currentPickupState != PickupState.Reset)
		{
			cargoShipContainer.Kill();
		}
		val = ((Component)this).transform.position + startForward * 26f;
		val2 = Vector3Ex.WithY(val, position.y) - position;
		num2 = num;
		num5 = Vector3.Distance(Vector3Ex.WithY(val, position.y), position);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		ServerTowerGrab.localPosition = val4;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		UpdateArm();
		SendNetworkUpdate();
		SetFlag(Flags.Busy, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
	}

	public void ReplenishContainers()
	{
		ReplenishContainers(Random.Range(2, 4));
	}

	public void AssignDestination(List<Transform> destinations, CargoShip targetShip, float delay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (startForward == Vector3.zero)
		{
			startForward = ((Component)targetShip).transform.forward;
		}
		toParent.Set(targetShip);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < movesToMake.Count; i++)
		{
			QueuedMove value = movesToMake[i];
			Transform val = destinations[num];
			value.TargetWorldRotation = val.rotation;
			value.TargetWorldPosition = val.position + Vector3.up * ((float)num2 * 3f);
			maxTargetHeight = Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight);
			value.HasTarget = true;
			movesToMake[i] = value;
			num++;
			if (num >= destinations.Count)
			{
				num = 0;
				num2++;
			}
		}
		moveDelay = delay;
		CheckMoveQueue();
	}

	public bool IsDestinationValidForCrane(CargoShipContainerDestination destination)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = Vector3Ex.WithY(((Component)destination).transform.position, position.y);
		Vector3 val2 = position;
		return Vector3.Distance(val, val2) < MaxMoveDistance - 2f;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!base.isServer)
		{
			return;
		}
		startForward = info.msg.harborCrane.startForward;
		ServerTowerGrab.localPosition = new Vector3(0f, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		toParent.uid = info.msg.harborCrane.toParent;
		moveDelay = info.msg.harborCrane.moveDelay;
		if (moveDelay > 0f && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		if (info.msg.harborCrane.currentMove != null)
		{
			moveInProcess = CreateMove(info.msg.harborCrane.currentMove);
		}
		movesToMake.Clear();
		if (info.msg.harborCrane.queuedMoves != null)
		{
			foreach (QueuedMove queuedMove in info.msg.harborCrane.queuedMoves)
			{
				movesToMake.Add(CreateMove(queuedMove));
			}
			Pool.Free<QueuedMove>(ref info.msg.harborCrane.queuedMoves, false);
		}
		currentPickupState = (PickupState)info.msg.harborCrane.currentPickupState;
		if (IsBusy() && !((FacepunchBehaviour)this).IsInvoking((Action)ProcessCraneMovement))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
		maxTargetHeight = info.msg.harborCrane.maxMoveHeight;
	}

	private void UpdateArm()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ArmRoot != (Object)null && (Object)(object)CraneGrab != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 position2 = CraneGrab.position;
			float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
			if (num < MaxMoveDistance + 2f)
			{
				float num2 = Mathf.Acos(num / (MaxMoveDistance + 3f));
				ArmRoot.localEulerAngles = new Vector3(0f - num2 * 57.29578f, 90f, 0f);
			}
		}
		UpdateArmSupports(((Component)this).transform.right);
	}
}


using UnityEngine;

public struct ContainerStack
{
	public Transform RootPoint;

	public int MaxStackSize;

	public int CurrentStackSize { get; set; }
}


using UnityEngine;

private struct QueuedMove
{
	public EntityRef<CargoShipContainer> TargetEntity;

	public Vector3 TargetWorldPosition;

	public Quaternion TargetWorldRotation;

	public bool HasTarget;
}


private enum PickupState
{
	RotateToFace,
	Lift,
	RotateToTarget,
	Drop,
	Reset
}


using UnityEngine;

public class HarborCraneContainerSpawnPoint : MonoBehaviour
{
	public int MaxStackSize = 1;
}


using UnityEngine;

public class HarborCraneSounds : MonoBehaviour, IClientComponent
{
	public HarborCrane crane;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;

	public SoundDefinition armRotationLoopDef;

	public SoundDefinition armRotationStartDef;

	public SoundDefinition armRotationStopDef;

	public Transform grabSoundPosition;

	public SoundDefinition grabMoveLoopDef;

	public SoundDefinition grabMoveStartDef;

	public SoundDefinition grabMoveStopDef;
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneStatic : HarborCrane
{
	public float StartingDepth;

	public float StartingHeight;

	public float StartingAngle;

	public Transform HangingLadder;

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		SetArmPos(StartingAngle, StartingHeight, StartingDepth);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = CraneGrab.localPosition.x;
		info.msg.harborCrane.height = CraneGrab.localPosition.y;
		info.msg.harborCrane.yaw = ArmRoot.localEulerAngles.z;
	}

	private void SetArmPos(float angle, float height, float depth)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		ArmRoot.localEulerAngles = new Vector3(0f, 0f, angle);
		CraneGrab.localPosition = new Vector3(depth, height, 0f);
		HangingLadder.rotation = Quaternion.LookRotation(((Component)this).transform.right, Vector3.up);
		UpdateArmSupports(((Component)this).transform.forward);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.harborCrane != null)
		{
			SetArmPos(info.msg.harborCrane.yaw, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		}
	}
}


using System;
using UnityEngine;

public class HarborProximityEntity : BaseEntity
{
	public bool SupportChildDeployables;

	public const Flags IsMoving = Flags.Reserved1;

	private static ListHashSet<HarborProximityEntity> harborEntities = new ListHashSet<HarborProximityEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		harborEntities.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		harborEntities.Remove(this);
	}

	public static HarborProximityEntity GetEntity(Vector3 worldPos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<HarborProximityEntity> enumerator = harborEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				HarborProximityEntity current = enumerator.Current;
				if (Vector3.Distance(Vector3Ex.WithY(((Component)current).transform.position, worldPos.y), worldPos) < 3f)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void NotifyStart()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void NotifyEnd()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override bool SupportsChildDeployables()
	{
		return SupportChildDeployables;
	}
}


using System;
using UnityEngine;

public class HarborProximityManager : MonoBehaviour, IServerComponent
{
	[Serializable]
	public class MoveToMake
	{
		public Transform EntityReferencePoint;

		public Transform MinimumPoint;

		public Transform MaximumPoint;

		public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		public bool UseToggleMode;

		public float ToggleSpeed = 1f;

		private float toggleState;

		private BaseEntity cachedEntity;

		private bool isMoving;

		public void Apply(float normalisedTime)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)cachedEntity == (Object)null)
			{
				cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
			}
			if ((Object)(object)cachedEntity == (Object)null)
			{
				return;
			}
			EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
			if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
			{
				if (!isMoving)
				{
					isMoving = true;
					if (cachedEntity is HarborProximityEntity harborProximityEntity)
					{
						harborProximityEntity.NotifyStart();
					}
				}
				((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
			}
			else if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity2)
				{
					harborProximityEntity2.NotifyEnd();
				}
			}
		}

		public void OnDockingEnded()
		{
			if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyEnd();
				}
			}
		}

		public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			float num = Animation.Evaluate(normalisedTime);
			if (UseToggleMode)
			{
				if (Application.isPlaying)
				{
					toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
				}
				else
				{
					toggleState = num;
				}
				num = toggleState;
			}
			rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
			posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
		}
	}

	public MoveToMake[] Moves;

	public bool DebugCargo;

	[Range(0f, 1f)]
	public float DebugVisPoint;

	private float localNormalisedState;

	public void StartMovement()
	{
		localNormalisedState = 0f;
		Apply(0f);
	}

	public void UpdateNormalisedState(float f)
	{
		localNormalisedState = Mathf.Max(localNormalisedState, f);
		localNormalisedState = f;
		Apply(localNormalisedState);
	}

	public void EndMovement()
	{
		Apply(0f);
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].OnDockingEnded();
		}
	}

	private void Apply(float f)
	{
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].Apply(f);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MoveToMake
{
	public Transform EntityReferencePoint;

	public Transform MinimumPoint;

	public Transform MaximumPoint;

	public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public bool UseToggleMode;

	public float ToggleSpeed = 1f;

	private float toggleState;

	private BaseEntity cachedEntity;

	private bool isMoving;

	public void Apply(float normalisedTime)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedEntity == (Object)null)
		{
			cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
		}
		if ((Object)(object)cachedEntity == (Object)null)
		{
			return;
		}
		EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
		if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
		{
			if (!isMoving)
			{
				isMoving = true;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyStart();
				}
			}
			((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
		}
		else if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity2)
			{
				harborProximityEntity2.NotifyEnd();
			}
		}
	}

	public void OnDockingEnded()
	{
		if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity)
			{
				harborProximityEntity.NotifyEnd();
			}
		}
	}

	public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = Animation.Evaluate(normalisedTime);
		if (UseToggleMode)
		{
			if (Application.isPlaying)
			{
				toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
			}
			else
			{
				toggleState = num;
			}
			num = toggleState;
		}
		rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
		posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/MonumentNotificationSoundConfig")]
public class MonumentNotificationSoundConfig : BaseScriptableObject
{
	public enum MonumentType
	{
		Undefined,
		Excavator,
		SmallOilRig,
		LargeOilRig,
		CargoShip
	}

	[Serializable]
	public class Data
	{
		[HideInInspector]
		public MonumentType MonumentType;

		public SoundDefinition NotificationSound;
	}

	private static MonumentNotificationSoundConfig _instance;

	public List<Data> entries = new List<Data>();

	public static MonumentNotificationSoundConfig instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<MonumentNotificationSoundConfig>("assets/content/sound/monuments/monumentnotificationsoundconfig.asset", true);
			}
			if (_instance == null)
			{
				Debug.LogError((object)"Failed to load MonumentNotificationSoundConfig");
			}
			return _instance;
		}
	}
}


public enum MonumentType
{
	Undefined,
	Excavator,
	SmallOilRig,
	LargeOilRig,
	CargoShip
}


using System;
using UnityEngine;

[Serializable]
public class Data
{
	[HideInInspector]
	public MonumentType MonumentType;

	public SoundDefinition NotificationSound;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ScientistBoatOilrigManager : BaseEntity
{
	private BoatGroupSpawner _spawner;

	private HashSet<RHIB> _spawnedBoats = new HashSet<RHIB>();

	public void AIDestroyed(RHIB rhib)
	{
		_spawnedBoats.Remove(rhib);
	}

	public void OnPuzzleReset()
	{
		if (_spawnedBoats == null)
		{
			_spawnedBoats = new HashSet<RHIB>();
		}
		if (_spawnedBoats.Count > 0)
		{
			PooledList<RHIB> val = Pool.Get<PooledList<RHIB>>();
			try
			{
				((List<RHIB>)(object)val).AddRange((IEnumerable<RHIB>)_spawnedBoats);
				foreach (RHIB item in (List<RHIB>)(object)val)
				{
					if ((Object)(object)item != (Object)null && !item.IsDestroyed)
					{
						item.AdminKillNoLoot();
					}
				}
				_spawnedBoats.Clear();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if ((Object)(object)_spawner == (Object)null)
		{
			_spawner = ((Component)this).GetComponent<BoatGroupSpawner>();
		}
		_spawner.SpawnBoatGroup(_spawnedBoats, BoatAI.AILoadMode.KillBoat, spawnsPT: false, this);
	}
}


using UnityEngine;

public class MovementSounds : MonoBehaviour
{
	public SoundDefinition waterMovementDef;

	public float waterMovementFadeInSpeed = 1f;

	public float waterMovementFadeOutSpeed = 1f;

	public SoundDefinition enterWaterSmall;

	public SoundDefinition enterWaterMedium;

	public SoundDefinition enterWaterLarge;

	private Sound waterMovement;

	private SoundModulation.Modulator waterGainMod;

	public bool inWater;

	public float waterLevel;

	public bool mute;
}


using UnityEngine;

public class MoveOverTime : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float speed = 1f;

	public Vector3 position;

	public Vector3 rotation;

	public Vector3 scale;

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		Quaternion val = ((Component)this).transform.rotation;
		transform.rotation = Quaternion.Euler(((Quaternion)(ref val)).eulerAngles + rotation * speed * Time.deltaTime);
		Transform transform2 = ((Component)this).transform;
		transform2.localScale += scale * speed * Time.deltaTime;
		Transform transform3 = ((Component)this).transform;
		transform3.localPosition += position * speed * Time.deltaTime;
	}
}


public enum GlobalNetworkBehavior
{
	Default,
	MainIsland,
	DeepSea
}


using System;
using Network;

public abstract class NetworkCryptography : INetworkCryptography
{
	private byte[] buffer = new byte[8388608];

	public unsafe ArraySegment<byte> EncryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		EncryptionHandler(connection, src, ref dst);
		return dst;
	}

	public unsafe ArraySegment<byte> DecryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		DecryptionHandler(connection, src, ref dst);
		return dst;
	}

	public void Encrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		EncryptionHandler(connection, src, ref dst);
		data = dst;
	}

	public void Decrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		DecryptionHandler(connection, src, ref dst);
		data = dst;
	}

	protected abstract void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);

	protected abstract void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);
}


using System;
using Network;

public class NetworkCryptographyServer : NetworkCryptography
{
	protected override void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Encrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2621u, src, ref dst);
		}
	}

	protected override void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Decrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2621u, src, ref dst);
		}
	}
}


using System;
using ConVar;
using Network;
using UnityEngine;

public static class NetworkProfiler
{
	private static void SetupProfile()
	{
		PacketProfiler.enabled = true;
		PacketProfiler.detailedProfiling = true;
		PacketProfiler.Reset();
	}

	private static void ExportProfile()
	{
		Export.ToFile(Export.CreateSnapshot());
		PacketProfiler.enabled = false;
		PacketProfiler.detailedProfiling = false;
		PacketProfiler.Reset();
	}

	[ServerVar(Help = "networkprofiler.serverprofile [time to profile(in seconds), min(0.1), max(1000), float]", ServerAdmin = true)]
	public static void ServerProfile(Arg arg)
	{
		float @float = arg.GetFloat(0, 0f);
		@float = Mathf.Clamp(@float, 0.1f, 1000f);
		SetupProfile();
		Chat.Broadcast($"Server is taking a network snapshot for {@float} seconds...", "SERVER", "#eee", 0uL);
		InvokeHandler.Invoke((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, (Action)delegate
		{
			Chat.Broadcast("Done!", "SERVER", "#eee", 0uL);
			ExportProfile();
		}, @float);
	}
}


using System;
using ConVar;
using Network;
using Network.Visibility;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

public class NetworkVisibilityGrid : MonoBehaviour, Provider
{
	public const int overworldLayer = 0;

	public const int cavesLayer = 1;

	public const int tunnelsLayer = 2;

	public const int tutorialsLayer = 3;

	public const int deepSeaLayer = 4;

	public const int dynamicDungeonsFirstLayer = 10;

	public const int GlobalId = 0;

	public const int LimboId = 1;

	public const int MainIslandId = 2;

	public const int DeepSeaId = 3;

	public const int TutorialNetworkGroupStart = 100;

	public const int TutorialNetworkGroupEnd = 1000;

	public int startID = 1024;

	public int gridSize = 100;

	public int cellCount = 32;

	[FormerlySerializedAs("visibilityRadius")]
	public int visibilityRadiusFar = 2;

	public int visibilityRadiusNear = 1;

	public float switchTolerance = 20f;

	public static float cavesThreshold = -5f;

	public static float tunnelsThreshold = -50f;

	public float dynamicDungeonsThreshold = 1000f;

	public float dynamicDungeonsInterval = 100f;

	private float halfGridSize;

	private float cellSize;

	private float halfCellSize;

	private int numIDsPerLayer;

	public static void ResetUndergroundThresholds()
	{
		cavesThreshold = -5f;
		tunnelsThreshold = -50f;
	}

	public static void RegisterEnvironmentVolume(EnvironmentVolume volume)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((volume.NetworkType & NetworkGroupType.Canyon) == NetworkGroupType.Canyon)
		{
			tunnelsThreshold = Mathf.Min(tunnelsThreshold, ((Component)volume).transform.position.y + volume.Center.y - volume.Size.y * 0.5f);
		}
	}

	private void Awake()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		Debug.Assert(Net.sv != null, "Network.Net.sv is NULL when creating Visibility Grid");
		Debug.Assert(Net.sv.visibility == null, "Network.Net.sv.visibility is being set multiple times");
		Net.sv.visibility = new Manager((Provider)(object)this);
	}

	public void OnEnable()
	{
		halfGridSize = (float)gridSize / 2f;
		cellSize = (float)gridSize / (float)cellCount;
		halfCellSize = cellSize / 2f;
		numIDsPerLayer = cellCount * cellCount;
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && Net.sv != null && Net.sv.visibility != null)
		{
			Net.sv.visibility.Dispose();
			Net.sv.visibility = null;
		}
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.blue;
		Vector3 position = ((Component)this).transform.position;
		for (int i = 0; i <= cellCount; i++)
		{
			float num = 0f - halfGridSize + (float)i * cellSize - halfCellSize;
			Gizmos.DrawLine(new Vector3(halfGridSize, position.y, num), new Vector3(0f - halfGridSize, position.y, num));
			Gizmos.DrawLine(new Vector3(num, position.y, halfGridSize), new Vector3(num, position.y, 0f - halfGridSize));
		}
	}

	private int PositionToGrid(float value)
	{
		return Mathf.Clamp(Mathf.RoundToInt((value + halfGridSize) / cellSize), 0, cellCount - 1);
	}

	private float GridToPosition(int value)
	{
		return (float)value * cellSize - halfGridSize;
	}

	private int PositionToLayer(float x, float y, float z)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (DeepSeaManager.IsInsideDeepSea(new Vector3(x, 0f, z)))
		{
			return 4;
		}
		if (y < tunnelsThreshold)
		{
			return 2;
		}
		if (y < cavesThreshold)
		{
			return 1;
		}
		if (y >= dynamicDungeonsThreshold)
		{
			return 10 + Mathf.FloorToInt((y - dynamicDungeonsThreshold) / dynamicDungeonsInterval);
		}
		if (TerrainMeta.IsPointWithinTutorialBounds(new Vector3(x, 0f, z)))
		{
			return 3;
		}
		return 0;
	}

	private uint CoordToID(int x, int y, int layer)
	{
		return (uint)(layer * numIDsPerLayer + (x * cellCount + y) + startID);
	}

	private uint GetID(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		int num = PositionToGrid(vPos.x);
		int num2 = PositionToGrid(vPos.z);
		int num3 = PositionToLayer(vPos.x, vPos.y, vPos.z);
		if (num3 == 3)
		{
			Enumerator<TutorialIsland.IslandBounds> enumerator = TutorialIsland.BoundsListServer.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					TutorialIsland.IslandBounds current = enumerator.Current;
					if (current.Contains(vPos))
					{
						return current.Id;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		uint num4 = CoordToID(num, num2, num3);
		if (num4 < startID)
		{
			Debug.LogError((object)$"NetworkVisibilityGrid.GetID - group is below range {num} {num2} {num3} {num4} {cellCount}");
		}
		return num4;
	}

	public (int x, int y, int layer) DeconstructGroupId(int groupId)
	{
		groupId -= startID;
		int result;
		int item = Math.DivRem(groupId, numIDsPerLayer, out result);
		int result2;
		return (x: Math.DivRem(result, cellCount, out result2), y: result2, layer: item);
	}

	private Bounds GetBounds(uint uid)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		var (value, value2, num) = DeconstructGroupId((int)uid);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(GridToPosition(value) - halfCellSize, 0f, GridToPosition(value2) - halfCellSize);
		Vector3 max = default(Vector3);
		((Vector3)(ref max))..ctor(val.x + cellSize, 0f, val.z + cellSize);
		if (num == 4)
		{
			val.y = ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).min.y;
			max.y = dynamicDungeonsThreshold;
		}
		else if (num == 0 || num == 3)
		{
			val.y = cavesThreshold;
			max.y = dynamicDungeonsThreshold;
		}
		else if (num == 1)
		{
			val.y = tunnelsThreshold;
			max.y = cavesThreshold - float.Epsilon;
		}
		else if (num == 2)
		{
			val.y = -10000f;
			max.y = tunnelsThreshold - float.Epsilon;
		}
		else if (num >= 10)
		{
			int num2 = num - 10;
			val.y = dynamicDungeonsThreshold + (float)num2 * dynamicDungeonsInterval + float.Epsilon;
			max.y = val.y + dynamicDungeonsInterval;
		}
		else
		{
			Debug.LogError((object)$"Cannot get bounds for unknown layer {num}!", (Object)(object)this);
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result)).min = val;
		((Bounds)(ref result)).max = max;
		return result;
	}

	public void OnGroupAdded(Group group)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (!group.restricted)
		{
			group.bounds = GetBounds(group.ID);
		}
	}

	public bool IsInside(Group group, Vector3 vPos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false || group.ID == 0 || ((Bounds)(ref group.bounds)).Contains(vPos);
		if (!group.restricted)
		{
			flag = flag || ((Bounds)(ref group.bounds)).SqrDistance(vPos) < switchTolerance;
		}
		return flag;
	}

	public bool IsVisibleFromFar(Group from, Group to)
	{
		int visibilityRadiusFarOverride = Net.visibilityRadiusFarOverride;
		int radius = ((visibilityRadiusFarOverride > 0) ? visibilityRadiusFarOverride : visibilityRadiusFar);
		return IsVisibleFrom(from, to, radius);
	}

	public bool IsVisibleFromNear(Group from, Group to)
	{
		int visibilityRadiusNearOverride = Net.visibilityRadiusNearOverride;
		int radius = ((visibilityRadiusNearOverride > 0) ? visibilityRadiusNearOverride : visibilityRadiusNear);
		return IsVisibleFrom(from, to, radius);
	}

	private bool IsVisibleFrom(Group from, Group to, int radius)
	{
		if (to.isGlobal)
		{
			return true;
		}
		if (from.ID < startID)
		{
			if (from.restricted)
			{
				return from == to;
			}
			return false;
		}
		var (num, num2, num3) = DeconstructGroupId((int)from.ID);
		if (num3 == 4)
		{
			if (to.ID == 3)
			{
				return true;
			}
		}
		else if (to.ID == 2)
		{
			return true;
		}
		if (from.restricted)
		{
			return from == to;
		}
		(int x, int y, int layer) tuple2 = DeconstructGroupId((int)to.ID);
		int item = tuple2.x;
		int item2 = tuple2.y;
		int item3 = tuple2.layer;
		int num4 = Math.Abs(item - num);
		int num5 = Math.Abs(item2 - num2);
		if (num4 > radius || num5 > radius)
		{
			return false;
		}
		if (num3 == item3)
		{
			return true;
		}
		switch (num3)
		{
		case 0:
			if (item3 == 1)
			{
				return true;
			}
			break;
		case 1:
			if (item3 == 2 || item3 == 0)
			{
				return true;
			}
			break;
		case 2:
			if (item3 == 1)
			{
				return true;
			}
			break;
		}
		return false;
	}

	public Group GetGroup(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		uint iD = GetID(vPos);
		if (iD == 0)
		{
			return null;
		}
		Group val = Net.sv.visibility.Get(iD);
		if (Net.network_group_debug && !IsInside(val, vPos))
		{
			float num = ((Bounds)(ref val.bounds)).SqrDistance(vPos);
			string[] obj = new string[6]
			{
				"Group is inside is all fucked ",
				iD.ToString(),
				"/",
				num.ToString(),
				"/",
				null
			};
			Vector3 val2 = vPos;
			obj[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
			Debug.Log((object)string.Concat(obj));
		}
		return val;
	}

	public void GetVisibleFromFar(Group group, ListHashSet<Group> groups)
	{
		int num = Net.visibilityRadiusFarOverride;
		if (DeconstructGroupId((int)group.ID).layer == 4 && Net.visibilityRadiusDeepSea > num)
		{
			num = Net.visibilityRadiusDeepSea;
		}
		int radius = ((num > 0) ? num : visibilityRadiusFar);
		GetVisibleFrom(group, groups, radius);
	}

	public void GetVisibleFromNear(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusNearOverride = Net.visibilityRadiusNearOverride;
		int radius = ((visibilityRadiusNearOverride > 0) ? visibilityRadiusNearOverride : visibilityRadiusNear);
		GetVisibleFrom(group, groups, radius);
	}

	private void GetGlobalNetworkGroups(Group group, ListHashSet<Group> groups)
	{
		groups.Add(Net.sv.visibility.Get(0u));
		if (group.ID >= startID)
		{
			if (DeconstructGroupId((int)group.ID).layer == 4)
			{
				groups.Add(BaseNetworkable.DeepSeaGroup);
			}
			else
			{
				groups.Add(BaseNetworkable.MainIslandGroup);
			}
		}
	}

	private void GetVisibleFrom(Group group, ListHashSet<Group> groups, int radius)
	{
		if (Interface.CallHook("OnNetworkSubscriptionsGather", (object)this, (object)group, (object)groups, (object)radius) != null)
		{
			return;
		}
		ListHashSet<Group> groups2 = groups;
		GetGlobalNetworkGroups(group, groups2);
		if (group.restricted)
		{
			groups2.Add(group);
			return;
		}
		int iD = (int)group.ID;
		if (iD < startID)
		{
			return;
		}
		var (num, num2, groupLayer2) = DeconstructGroupId(iD);
		AddLayers(num, num2, groupLayer2);
		for (int i = 1; i <= radius; i++)
		{
			AddLayers(num - i, num2, groupLayer2);
			AddLayers(num + i, num2, groupLayer2);
			AddLayers(num, num2 - i, groupLayer2);
			AddLayers(num, num2 + i, groupLayer2);
			for (int j = 1; j < i; j++)
			{
				AddLayers(num - i, num2 - j, groupLayer2);
				AddLayers(num - i, num2 + j, groupLayer2);
				AddLayers(num + i, num2 - j, groupLayer2);
				AddLayers(num + i, num2 + j, groupLayer2);
				AddLayers(num - j, num2 - i, groupLayer2);
				AddLayers(num + j, num2 - i, groupLayer2);
				AddLayers(num - j, num2 + i, groupLayer2);
				AddLayers(num + j, num2 + i, groupLayer2);
			}
			AddLayers(num - i, num2 - i, groupLayer2);
			AddLayers(num - i, num2 + i, groupLayer2);
			AddLayers(num + i, num2 - i, groupLayer2);
			AddLayers(num + i, num2 + i, groupLayer2);
		}
		void Add(int groupX, int groupY, int groupLayer)
		{
			groups2.Add(Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));
		}
		void AddLayers(int groupX, int groupY, int groupLayer)
		{
			Add(groupX, groupY, groupLayer);
			if (groupLayer == 0)
			{
				Add(groupX, groupY, 1);
			}
			if (groupLayer == 1)
			{
				Add(groupX, groupY, 2);
				Add(groupX, groupY, 0);
			}
			if (groupLayer == 2)
			{
				Add(groupX, groupY, 1);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Network.Visibility;
using ServerOcclusionJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public static class ServerOcclusion
{
	public class Group : ListHashSet<BaseNetworkable>, IPooled
	{
		void IPooled.EnterPool()
		{
			base.Clear();
		}

		void IPooled.LeavePool()
		{
		}
	}

	public readonly struct Grid : IEquatable<Grid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 16f;

		public const float HalfResolution = 8f;

		public Grid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public static Grid FromIndex(int index)
		{
			int num = index / (ChunkCountX * ChunkCountY);
			index -= num * (ChunkCountX * ChunkCountY);
			int num2 = index / ChunkCountX;
			index -= num2 * ChunkCountX;
			return new Grid(index, num2, num);
		}

		public static int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 16f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
		}

		public override string ToString()
		{
			return $"(x: {x}, y: {y}, z: {z})";
		}

		public bool Equals(Grid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
		}

		public int GetIndex()
		{
			return GetGridIndex(x, y, z);
		}
	}

	public readonly struct SubGrid : IEquatable<SubGrid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 2f;

		public const float HalfResolution = 1f;

		public SubGrid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public SubGrid(int3 p)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			x = p.x;
			y = p.y;
			z = p.z;
		}

		public static int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 2f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
		}

		public override string ToString()
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
		}

		public bool Equals(SubGrid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			Vector3[] gridOffsets;
			if (OcclusionIncludeRocks)
			{
				bool flag = true;
				gridOffsets = GridOffsets;
				foreach (Vector3 val in gridOffsets)
				{
					if (!flag)
					{
						break;
					}
					Vector3 pos = GetCenterPoint() + val;
					flag &= AntiHack.IsInsideMesh(pos);
					if (flag)
					{
						GameObject gameObject = ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject;
						flag &= gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
					}
				}
				if (flag)
				{
					return true;
				}
			}
			gridOffsets = GridOffsets;
			foreach (Vector3 val2 in gridOffsets)
			{
				if (AntiHack.TestInsideTerrain(GetCenterPoint() + val2))
				{
					return true;
				}
			}
			return false;
		}

		public int GetIndex()
		{
			return GetSubGridIndex(x, y, z);
		}

		public int GetDistance(SubGrid other)
		{
			return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
		}
	}

	public const int CacheVersion = 3;

	public static int MaxY = 200;

	public static int ChunkCountX;

	public static int ChunkCountY;

	public static int ChunkCountZ;

	public static int SubChunkCountX;

	public static int SubChunkCountY;

	public static int SubChunkCountZ;

	public static float AxisX;

	public static float AxisY;

	public static float AxisZ;

	public static LimitDictionary<(int, int), bool> OcclusionCache = new LimitDictionary<(int, int), bool>(32768);

	public static NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public static NativeReference<bool> ReturnHolder;

	public const int OcclusionChunkSize = 16;

	public const int OcclusionChunkResolution = 8;

	public static Dictionary<Group, Group> Occludees = new Dictionary<Group, Group>();

	public static readonly Vector3[] GridOffsets = (Vector3[])(object)new Vector3[2]
	{
		new Vector3(0f, 0f, 0f),
		new Vector3(0f, 1f, 0f)
	};

	public static readonly (int, int, int)[] neighbours = new(int, int, int)[6]
	{
		(1, 0, 0),
		(-1, 0, 0),
		(0, 1, 0),
		(0, -1, 0),
		(0, 0, 1),
		(0, 0, -1)
	};

	public static bool OcclusionEnabled { get; set; } = true;

	public static bool OcclusionIncludeRocks { get; set; } = true;

	public static float OcclusionPollRate => 2f;

	public static int MinOcclusionDistance => 25;

	public static bool DisableNewOcclusionGroups { get; set; } = true;

	public static string SubGridFilePath
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return string.Format("{0}/{1}_occlusion_{2}.dat", Server.rootFolder, World.MapFileName.Replace(".map", ""), 3);
		}
	}

	public static int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCountX * ChunkCountY + y * ChunkCountX + x;
	}

	public static int GetSubGridIndex(int x, int y, int z)
	{
		return z * SubChunkCountX * SubChunkCountY + y * SubChunkCountX + x;
	}

	public static int GetGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 16f + axis / 16f);
	}

	public static Grid GetGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int grid = GetGrid(position.x, AxisX);
		int grid2 = GetGrid(position.y, AxisY);
		int grid3 = GetGrid(position.z, AxisZ);
		if (IsValidGrid(grid, grid2, grid3))
		{
			return new Grid(grid, grid2, grid3);
		}
		return default(Grid);
	}

	public static int GetSubGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 2f + axis / 2f);
	}

	public static SubGrid GetSubGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int subGrid = GetSubGrid(position.x, AxisX);
		int subGrid2 = GetSubGrid(position.y, AxisY);
		int subGrid3 = GetSubGrid(position.z, AxisZ);
		if (IsValidSubGrid(subGrid, subGrid2, subGrid3))
		{
			return new SubGrid(subGrid, subGrid2, subGrid3);
		}
		return default(SubGrid);
	}

	public static bool IsBlocked(int x, int y, int z)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int x2 = Math.DivRem(x, 8, out result);
		int result2;
		int y2 = Math.DivRem(y, 8, out result2);
		int result3;
		int z2 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(x2, y2, z2);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(x2, y2, z2) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num);
		}
		return false;
	}

	public static bool IsBlocked(SubGrid sub)
	{
		return IsBlocked(sub.x, sub.y, sub.z);
	}

	public static bool IsValidGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= ChunkCountX || y >= ChunkCountY || z >= ChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidSubGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= SubChunkCountX || y >= SubChunkCountY || z >= SubChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static void CalculatePathBetweenGrids(SubGrid grid1, SubGrid grid2, out bool pathBlocked)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		pathBlocked = false;
		NativeReference<bool> returnHolder = ReturnHolder;
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob = default(CalculatePathBetweenGridsJob);
		calculatePathBetweenGridsJob.From = grid1;
		calculatePathBetweenGridsJob.To = grid2;
		calculatePathBetweenGridsJob.PathBlocked = returnHolder;
		calculatePathBetweenGridsJob.Grid = new GridDefinition
		{
			OcclusionSubGridBlocked = OcclusionSubGridBlocked.AsReadOnly(),
			ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ),
			SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ)
		};
		calculatePathBetweenGridsJob.BlockedGridThreshold = ConVar.AntiHack.server_occlusion_blocked_grid_threshold;
		calculatePathBetweenGridsJob.NeighbourThreshold = ConVar.AntiHack.server_occlusion_neighbour_threshold;
		calculatePathBetweenGridsJob.UseNeighbourThresholds = ConVar.AntiHack.server_occlusion_use_neighbour_thresholds;
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob2 = calculatePathBetweenGridsJob;
		IJobExtensions.RunByRef<CalculatePathBetweenGridsJob>(ref calculatePathBetweenGridsJob2);
		pathBlocked = returnHolder.Value;
	}

	public static JobHandle CalculatePathsBetweenGridsJob(ReadOnly<(SubGrid from, SubGrid to)> paths, NativeArray<bool> pathsBlocked)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		CalculatePathsBetweenGridsJob calculatePathsBetweenGridsJob = default(CalculatePathsBetweenGridsJob);
		calculatePathsBetweenGridsJob.Paths = paths;
		calculatePathsBetweenGridsJob.PathsBlocked = pathsBlocked;
		calculatePathsBetweenGridsJob.Grid = new GridDefinition
		{
			OcclusionSubGridBlocked = OcclusionSubGridBlocked.AsReadOnly(),
			ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ),
			SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ)
		};
		calculatePathsBetweenGridsJob.BlockedGridThreshold = ConVar.AntiHack.server_occlusion_blocked_grid_threshold;
		calculatePathsBetweenGridsJob.NeighbourThreshold = ConVar.AntiHack.server_occlusion_neighbour_threshold;
		calculatePathsBetweenGridsJob.UseNeighbourThresholds = ConVar.AntiHack.server_occlusion_use_neighbour_thresholds;
		CalculatePathsBetweenGridsJob calculatePathsBetweenGridsJob2 = calculatePathsBetweenGridsJob;
		return IJobParallelForBatchExtensions.ScheduleBatchByRef<CalculatePathsBetweenGridsJob>(ref calculatePathsBetweenGridsJob2, paths.Length, 64, default(JobHandle));
	}

	public static void SetupGrid()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 size = TerrainMeta.Size;
		ChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 16f), 1);
		ChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 16f), 1);
		ChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 16f), 1);
		SubChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 2f), 1);
		SubChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 2f), 1);
		SubChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 2f), 1);
		AxisX = TerrainMeta.Size.x / 2f;
		AxisY = MaxY / 2;
		AxisZ = TerrainMeta.Size.z / 2f;
		NativeReferenceEx.SafeDispose(ref ReturnHolder);
		ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
		bool server_occlusion_save_grid = ConVar.AntiHack.server_occlusion_save_grid;
		if (!server_occlusion_save_grid || !ReadGridFromFile(SubGridFilePath))
		{
			GenerateOcclusionGrid();
			if (server_occlusion_save_grid)
			{
				WriteGridToFile(ChunkCountX * ChunkCountY * ChunkCountZ, OcclusionSubGridBlocked);
			}
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (!OcclusionEnabled || !allPlayer.SupportsServerOcclusion())
			{
				continue;
			}
			allPlayer.SubGrid = GetSubGrid(allPlayer.GetOcclusionOffset());
			if (DisableNewOcclusionGroups)
			{
				ListHashSet<Group> val = Pool.Get<ListHashSet<Group>>();
				Net.sv.visibility.GetVisibleFromFar(allPlayer.net.group, val);
				allPlayer.OcclusionSubscribedTo(allPlayer.net.group);
				for (int i = 0; i < val.Count; i++)
				{
					allPlayer.OcclusionSubscribedTo(val[i]);
				}
				Pool.FreeUnmanaged<Group>(ref val);
			}
		}
	}

	public static void Dispose()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (OcclusionSubGridBlocked.IsCreated)
		{
			for (int i = 0; i < OcclusionSubGridBlocked.Length; i++)
			{
				NativeBitArray val = OcclusionSubGridBlocked[i];
				if (((NativeBitArray)(ref val)).IsCreated)
				{
					((NativeBitArray)(ref val)).Dispose();
				}
			}
			OcclusionSubGridBlocked.Dispose();
		}
		if (ReturnHolder.IsCreated)
		{
			ReturnHolder.Dispose();
		}
	}

	private static void WriteGridToFile(int length, NativeArray<NativeBitArray> data)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			using BinaryWriter binaryWriter = new BinaryWriter(File.Open(SubGridFilePath, FileMode.Create));
			binaryWriter.Write(length);
			binaryWriter.Write(OcclusionIncludeRocks);
			Enumerator<NativeBitArray> enumerator = data.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					NativeBitArray current = enumerator.Current;
					if (!((NativeBitArray)(ref current)).IsCreated)
					{
						binaryWriter.Write(0);
						continue;
					}
					binaryWriter.Write(((NativeBitArray)(ref current)).Length);
					byte[] array = new byte[(((NativeBitArray)(ref current)).Length + 7) / 8];
					((NativeBitArray)(ref current)).AsNativeArray<byte>().CopyTo(array);
					binaryWriter.Write(array);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public static bool ReadGridFromFile(string path)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (!File.Exists(path))
			{
				return false;
			}
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			using (BinaryReader binaryReader = new BinaryReader(File.Open(path, FileMode.Open)))
			{
				int num = binaryReader.ReadInt32();
				if (binaryReader.ReadBoolean() != OcclusionIncludeRocks)
				{
					Debug.LogWarning((object)"Grid file and occlusion parameters don't match, rebuilding grid");
					binaryReader.Close();
					File.Delete(path);
					return false;
				}
				OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(num, (Allocator)4, (NativeArrayOptions)1);
				for (int i = 0; i < num; i++)
				{
					int num2 = binaryReader.ReadInt32();
					if (num2 != 0)
					{
						byte[] array = binaryReader.ReadBytes((num2 + 7) / 8);
						OcclusionSubGridBlocked[i] = new NativeBitArray(num2, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
						NativeBitArray val = OcclusionSubGridBlocked[i];
						((NativeBitArray)(ref val)).AsNativeArray<byte>().CopyFrom(array);
					}
				}
				Debug.Log((object)$"Loaded {num} occlusion sub-chunks from file - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
			}
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
			return false;
		}
	}

	[ServerVar(Help = "Tests occlusion visibility between two positions")]
	public static string serverocclusiondebug(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = arg.GetVector3(0, default(Vector3)) + PlayerEyes.EyeOffset;
		Vector3 val2 = arg.GetVector3(1, default(Vector3)) + PlayerEyes.EyeOffset;
		SubGrid subGrid = GetSubGrid(val);
		SubGrid subGrid2 = GetSubGrid(val2);
		if (subGrid.Equals(default(SubGrid)) || subGrid2.Equals(default(SubGrid)))
		{
			return "Path not blocked due to one of positions being outside of grid";
		}
		NativeList<(int3, Color)> cells = default(NativeList<(int3, Color)>);
		cells..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		bool flag = DebugPath(val, val2, cells);
		cells.Dispose();
		return $"Grid 1: {subGrid}, Grid 2: {subGrid2}\nPath blocked: {flag}";
	}

	[ServerVar]
	public static void OcclusionValidateGroups(Arg arg)
	{
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		if (!OcclusionEnabled)
		{
			arg.ReplyWith("ServerOcclusion disabled");
			return;
		}
		if (DisableNewOcclusionGroups)
		{
			arg.ReplyWith("New OcclusionGroups logic disabled, can't validate");
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		foreach (var (arg2, group2) in Occludees)
		{
			if (stringBuilder.Length > 1024)
			{
				break;
			}
			if (((ICollection<BaseNetworkable>)group2).IsEmpty())
			{
				stringBuilder.AppendLine($"Occlusion group for {arg2} is empty - it should've been cleaned up!");
				continue;
			}
			Enumerator<BaseNetworkable> enumerator2 = ((ListHashSet<BaseNetworkable>)group2).GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BaseNetworkable current = enumerator2.Current;
					if (stringBuilder.Length > 1024)
					{
						break;
					}
					if ((Object)(object)current == (Object)null)
					{
						stringBuilder.AppendLine($"Occlusion group for {arg2} has a null networkable!");
						continue;
					}
					if (!current.SupportsServerOcclusion())
					{
						stringBuilder.AppendLine($"Occlusion group for {arg2} has a {current} that doesn't support server occlusion!");
						continue;
					}
					Enumerator<BaseNetworkable> enumerator3 = current.OcclusionGroupRefs.GetEnumerator();
					try
					{
						while (enumerator3.MoveNext())
						{
							BaseNetworkable current2 = enumerator3.Current;
							if (stringBuilder.Length > 1024)
							{
								break;
							}
							if ((Object)(object)current2 == (Object)null)
							{
								stringBuilder.AppendLine($"Occlusion group for {current} had a null referrer!");
							}
							else if (!((ListHashSet<BaseNetworkable>)current2.OcclusionGroup).Contains(current))
							{
								stringBuilder.AppendLine($"Occlusion group for referrer-{current2} of {current} was desynced!");
							}
						}
					}
					finally
					{
						((IDisposable)enumerator3/*cast due to .constrained prefix*/).Dispose();
					}
					Group occlusionGroup = current.OcclusionGroup;
					if (current.net.connection == null)
					{
						if (((ListHashSet<BaseNetworkable>)occlusionGroup).Count != 1 || !((ListHashSet<BaseNetworkable>)occlusionGroup).Contains(current))
						{
							stringBuilder.AppendLine($"Occlusion group for sleeper-{current} has other participants!");
						}
						continue;
					}
					bool flag = false;
					enumerator3 = ((ListHashSet<BaseNetworkable>)occlusionGroup).GetEnumerator();
					try
					{
						while (enumerator3.MoveNext())
						{
							BaseNetworkable current3 = enumerator3.Current;
							if (stringBuilder.Length > 1024)
							{
								break;
							}
							if ((Object)(object)current3 == (Object)null)
							{
								stringBuilder.AppendLine($"Occlusion group for {current} has a null!");
							}
							else if ((Object)(object)current3 == (Object)(object)current)
							{
								flag = true;
							}
							else if (!current.net.subscriber.IsSubscribed(current3.net.group))
							{
								stringBuilder.AppendLine($"Occlusion group for {current} has a stale participant!");
							}
						}
					}
					finally
					{
						((IDisposable)enumerator3/*cast due to .constrained prefix*/).Dispose();
					}
					if (!flag)
					{
						stringBuilder.AppendLine($"Occlusion group for {current} doesn't have an owner!");
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Enumerator<BasePlayer> enumerator4 = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator4.MoveNext())
			{
				BasePlayer current4 = enumerator4.Current;
				if (stringBuilder.Length > 1024)
				{
					break;
				}
				if (!((Object)(object)current4 == (Object)null))
				{
					bool flag2 = current4.SupportsServerOcclusion();
					bool flag3 = current4.OcclusionGroup != null;
					if (flag2 != flag3)
					{
						stringBuilder.AppendLine($"Active {current4} SupportsServerOcclusion:{flag2} but hasLocalGroup: {flag3}");
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator4/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator4 = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator4.MoveNext())
			{
				BasePlayer current5 = enumerator4.Current;
				if (stringBuilder.Length > 1024)
				{
					break;
				}
				if (!((Object)(object)current5 == (Object)null))
				{
					bool flag4 = current5.SupportsServerOcclusion();
					bool flag5 = current5.OcclusionGroup != null;
					if (flag4 != flag5)
					{
						stringBuilder.AppendLine($"Sleeper {current5} SupportsServerOcclusion:{flag4} but hasLocalGroup: {flag5}");
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator4/*cast due to .constrained prefix*/).Dispose();
		}
		if (stringBuilder.Length > 0)
		{
			arg.ReplyWith(stringBuilder.ToString());
		}
		else
		{
			arg.ReplyWith($"All {Occludees.Count} server occlusion groups are valid");
		}
	}

	public static bool DebugPath(Vector3 p1, Vector3 p2, NativeList<(int3, Color)> cells)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		SubGrid subGrid = GetSubGrid(p1);
		SubGrid subGrid2 = GetSubGrid(p2);
		GridDefinition gridDefinition = default(GridDefinition);
		gridDefinition.OcclusionSubGridBlocked = OcclusionSubGridBlocked.AsReadOnly();
		gridDefinition.ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ);
		gridDefinition.SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ);
		GridDefinition gridDef = gridDefinition;
		int3 from = new int3(subGrid.x, subGrid.y, subGrid.z);
		int3 to = default(int3);
		((int3)(ref to))..ctor(subGrid2.x, subGrid2.y, subGrid2.z);
		return Algorithm.Gather(blockedGridThreshold: ConVar.AntiHack.server_occlusion_blocked_grid_threshold, neighbourThreshold: ConVar.AntiHack.server_occlusion_neighbour_threshold, useNeighbourThresholds: ConVar.AntiHack.server_occlusion_use_neighbour_thresholds, from: from, to: to, gridDef: in gridDef, cells: cells);
	}

	public static bool GetCachedVisibility(SubGrid from, SubGrid to, out bool isVisible)
	{
		int num = from.GetIndex();
		int num2 = to.GetIndex();
		if (num > num2)
		{
			int num3 = num2;
			int num4 = num;
			num = num3;
			num2 = num4;
		}
		return ((Dictionary<(int, int), bool>)(object)OcclusionCache).TryGetValue((num, num2), out isVisible);
	}

	public static void CacheVisibility(SubGrid from, SubGrid to, bool isVisible)
	{
		int num = from.GetIndex();
		int num2 = to.GetIndex();
		if (num > num2)
		{
			int num3 = num2;
			int num4 = num;
			num = num3;
			num2 = num4;
		}
		OcclusionCache.TryAdd((num, num2), isVisible);
	}

	private static void GenerateOcclusionGrid()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		int num = ChunkCountX * ChunkCountY * ChunkCountZ;
		OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(num, (Allocator)4, (NativeArrayOptions)1);
		Debug.Log((object)$"Preparing Occlusion Grid ({SubChunkCountX}, {SubChunkCountY}, {SubChunkCountZ})");
		NativeList<int> cellsToCheck = default(NativeList<int>);
		cellsToCheck..ctor(1024, AllocatorHandle.op_Implicit((Allocator)3));
		GenerateOcclusionBroadPhase(cellsToCheck, num);
		int num2 = (cellsToCheck.Length + 32000 - 1) / 32000;
		NativeList<SubGrid> subGridCells = default(NativeList<SubGrid>);
		subGridCells..ctor(16384000, AllocatorHandle.op_Implicit((Allocator)3));
		Debug.Log((object)$"Processing {num2} batches({cellsToCheck.Length} broadphase cells total)...");
		for (int i = 0; i < num2; i++)
		{
			_ = stopwatch.Elapsed.TotalSeconds;
			subGridCells.Clear();
			int num3 = i * 32000;
			int num4 = Math.Min(num3 + 32000, cellsToCheck.Length);
			for (int j = num3; j < num4; j++)
			{
				Grid grid = Grid.FromIndex(cellsToCheck[j]);
				int num5 = grid.x * 8;
				int num6 = grid.y * 8;
				int num7 = grid.z * 8;
				for (int k = 0; k < 8; k++)
				{
					for (int l = 0; l < 8; l++)
					{
						for (int m = 0; m < 8; m++)
						{
							SubGrid subGrid = new SubGrid(m + num5, l + num6, k + num7);
							subGridCells.AddNoResize(subGrid);
						}
					}
				}
			}
			GenerateOcclusionNarrowPhase(subGridCells);
		}
		subGridCells.Dispose();
		cellsToCheck.Dispose();
		Debug.Log((object)$"Initialized {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks - took {stopwatch.Elapsed.TotalSeconds}s");
	}

	private static void GenerateOcclusionBroadPhase(NativeList<int> cellsToCheck, int chunkTotalCount)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<Vector3> val = default(NativeArray<Vector3>);
		val..ctor(chunkTotalCount, (Allocator)3, (NativeArrayOptions)0);
		NativeArray<Vector3> val2 = default(NativeArray<Vector3>);
		val2..ctor(chunkTotalCount, (Allocator)3, (NativeArrayOptions)0);
		NativeArray<int> val3 = default(NativeArray<int>);
		val3..ctor(chunkTotalCount, (Allocator)3, (NativeArrayOptions)0);
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor(8f, 8f, 8f);
		for (int i = 0; i < chunkTotalCount; i++)
		{
			val[i] = Grid.FromIndex(i).GetCenterPoint();
			val2[i] = val4;
			val3[i] = 8388608;
		}
		NativeArray<bool> results = default(NativeArray<bool>);
		results..ctor(chunkTotalCount, (Allocator)3, (NativeArrayOptions)0);
		GamePhysics.CheckBounds(val.AsReadOnly(), val2.AsReadOnly(), val3.AsReadOnly(), results, (QueryTriggerInteraction)1, GamePhysics.MasksToValidate.Terrain);
		val3.Dispose();
		val2.Dispose();
		val.Dispose();
		for (int j = 0; j < results.Length; j++)
		{
			Grid grid = Grid.FromIndex(j);
			bool num = results[j];
			bool flag = false;
			if (grid.y < ChunkCountY - 1)
			{
				int index = new Grid(grid.x, grid.y + 1, grid.z).GetIndex();
				flag = results[index];
			}
			NativeBitArray val5 = OcclusionSubGridBlocked[j];
			if (((NativeBitArray)(ref val5)).IsCreated)
			{
				val5 = OcclusionSubGridBlocked[j];
				((NativeBitArray)(ref val5)).Dispose();
			}
			if (num || flag)
			{
				OcclusionSubGridBlocked[j] = new NativeBitArray(512, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				cellsToCheck.Add(ref j);
			}
		}
		results.Dispose();
	}

	private static void GenerateOcclusionNarrowPhase(NativeList<SubGrid> subGridCells)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		int num = GridOffsets.Length;
		NativeArray<Vector3> posi = default(NativeArray<Vector3>);
		posi..ctor(subGridCells.Length * num, (Allocator)3, (NativeArrayOptions)0);
		NativeArray<Vector3> val = default(NativeArray<Vector3>);
		val..ctor(GridOffsets, (Allocator)3);
		NativeBitArray val3;
		if (!subGridCells.IsEmpty)
		{
			CalculateSubGridSamplePointsJob calculateSubGridSamplePointsJob = default(CalculateSubGridSamplePointsJob);
			calculateSubGridSamplePointsJob.Posi = posi;
			calculateSubGridSamplePointsJob.SubGridCells = subGridCells.AsReadOnly();
			calculateSubGridSamplePointsJob.GridOffsets = val.AsReadOnly();
			calculateSubGridSamplePointsJob.CellOffset = new Vector3((float)SubGrid.GetOffset(TerrainMeta.Size.x), (float)SubGrid.GetOffset(MaxY), (float)SubGrid.GetOffset(TerrainMeta.Size.z));
			CalculateSubGridSamplePointsJob calculateSubGridSamplePointsJob2 = calculateSubGridSamplePointsJob;
			int batchSize = GamePhysics.GetBatchSize(subGridCells.Length);
			int length = subGridCells.Length;
			JobHandle val2 = default(JobHandle);
			val2 = IJobForExtensions.ScheduleParallel<CalculateSubGridSamplePointsJob>(calculateSubGridSamplePointsJob2, length, batchSize, val2);
			((JobHandle)(ref val2)).Complete();
			NativeArray<bool> results = default(NativeArray<bool>);
			results..ctor(posi.Length, (Allocator)3, (NativeArrayOptions)0);
			AntiHack.TestInsideTerrain(posi.AsReadOnly(), results);
			int num2 = 0;
			for (int i = 0; i < subGridCells.Length; i++)
			{
				SubGrid subGrid = subGridCells[i];
				bool flag = true;
				for (int j = 0; j < num; j++)
				{
					int num3 = i * num + j;
					flag &= results[num3];
				}
				if (flag)
				{
					int result;
					int x = Math.DivRem(subGrid.x, 8, out result);
					int result2;
					int y = Math.DivRem(subGrid.y, 8, out result2);
					int result3;
					int z = Math.DivRem(subGrid.z, 8, out result3);
					int gridIndex = GetGridIndex(x, y, z);
					int num4 = result3 * 8 * 8 + result2 * 8 + result;
					val3 = OcclusionSubGridBlocked[gridIndex];
					((NativeBitArray)(ref val3)).Set(num4, true);
				}
				else
				{
					int num5 = num2++;
					subGridCells[num5] = subGrid;
					for (int k = 0; k < num; k++)
					{
						posi[num5 * num + k] = posi[i * num + k];
					}
				}
			}
			subGridCells.ResizeUninitialized(num2);
			results.Dispose();
		}
		if (OcclusionIncludeRocks && !subGridCells.IsEmpty)
		{
			NativeArray<Vector3> subArray = posi.GetSubArray(0, subGridCells.Length * num);
			NativeArray<RaycastHit> hits = default(NativeArray<RaycastHit>);
			hits..ctor(subArray.Length, (Allocator)3, (NativeArrayOptions)0);
			AntiHack.AreInsideMesh(subArray.AsReadOnly(), hits);
			Span<int> span = stackalloc int[num];
			int num6 = 0;
			for (int l = 0; l < subGridCells.Length; l++)
			{
				bool flag2 = true;
				for (int m = 0; m < num; m++)
				{
					RaycastHit val4 = hits[l * num + m];
					int colliderInstanceID = ((RaycastHit)(ref val4)).colliderInstanceID;
					flag2 = flag2 && colliderInstanceID != 0;
					if (!flag2)
					{
						break;
					}
					bool flag3 = false;
					for (int n = 0; n < num6; n++)
					{
						if (span[n] == colliderInstanceID)
						{
							flag3 = true;
							break;
						}
					}
					if (!flag3)
					{
						GameObject gameObject = ((Component)((RaycastHit)(ref val4)).collider).gameObject;
						flag2 &= gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
						if (!flag2)
						{
							break;
						}
						span[num6++] = colliderInstanceID;
					}
				}
				num6 = 0;
				if (flag2)
				{
					SubGrid subGrid2 = subGridCells[l];
					int result4;
					int x2 = Math.DivRem(subGrid2.x, 8, out result4);
					int result5;
					int y2 = Math.DivRem(subGrid2.y, 8, out result5);
					int result6;
					int z2 = Math.DivRem(subGrid2.z, 8, out result6);
					int gridIndex2 = GetGridIndex(x2, y2, z2);
					int num7 = result6 * 8 * 8 + result5 * 8 + result4;
					val3 = OcclusionSubGridBlocked[gridIndex2];
					((NativeBitArray)(ref val3)).Set(num7, true);
				}
			}
			hits.Dispose();
		}
		val.Dispose();
		posi.Dispose();
	}
}


using Facepunch;

public class Group : ListHashSet<BaseNetworkable>, IPooled
{
	void IPooled.EnterPool()
	{
		base.Clear();
	}

	void IPooled.LeavePool()
	{
	}
}


using System;
using UnityEngine;

public readonly struct Grid : IEquatable<Grid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 16f;

	public const float HalfResolution = 8f;

	public Grid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public static Grid FromIndex(int index)
	{
		int num = index / (ChunkCountX * ChunkCountY);
		index -= num * (ChunkCountX * ChunkCountY);
		int num2 = index / ChunkCountX;
		index -= num2 * ChunkCountX;
		return new Grid(index, num2, num);
	}

	public static int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 16f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
	}

	public override string ToString()
	{
		return $"(x: {x}, y: {y}, z: {z})";
	}

	public bool Equals(Grid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
	}

	public int GetIndex()
	{
		return GetGridIndex(x, y, z);
	}
}


using System;
using Unity.Mathematics;
using UnityEngine;

public readonly struct SubGrid : IEquatable<SubGrid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 2f;

	public const float HalfResolution = 1f;

	public SubGrid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public SubGrid(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		x = p.x;
		y = p.y;
		z = p.z;
	}

	public static int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 2f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
	}

	public override string ToString()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
	}

	public bool Equals(SubGrid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] gridOffsets;
		if (OcclusionIncludeRocks)
		{
			bool flag = true;
			gridOffsets = GridOffsets;
			foreach (Vector3 val in gridOffsets)
			{
				if (!flag)
				{
					break;
				}
				Vector3 pos = GetCenterPoint() + val;
				flag &= AntiHack.IsInsideMesh(pos);
				if (flag)
				{
					GameObject gameObject = ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject;
					flag &= gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
				}
			}
			if (flag)
			{
				return true;
			}
		}
		gridOffsets = GridOffsets;
		foreach (Vector3 val2 in gridOffsets)
		{
			if (AntiHack.TestInsideTerrain(GetCenterPoint() + val2))
			{
				return true;
			}
		}
		return false;
	}

	public int GetIndex()
	{
		return GetSubGridIndex(x, y, z);
	}

	public int GetDistance(SubGrid other)
	{
		return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
	}
}


using System;

[AttributeUsage(AttributeTargets.Property)]
public class SyncAttribute : Attribute
{
	public bool Pack { get; set; } = true;

	public bool Autosave { get; set; }

	public bool RequireChange { get; set; } = true;

	public bool InvalidateCache { get; set; } = true;
}


using System;
using ConVar;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(fileName = "NewConversation", menuName = "Rust/ConversationData", order = 1)]
public class ConversationData : ScriptableObject
{
	[Serializable]
	public class ResponseNode
	{
		public enum ActionType
		{
			Custom,
			None,
			AssignMission
		}

		public Phrase responseTextLocalized;

		public ConversationCondition[] conditions = Array.Empty<ConversationCondition>();

		public ActionType actionType;

		public string actionString = string.Empty;

		public BaseMission actionMission;

		public string resultingSpeechNode;

		public bool PassesConditions(BasePlayer player, IConversationProvider provider)
		{
			ConversationCondition[] array = conditions;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].Passes(player, provider))
				{
					return false;
				}
			}
			return true;
		}

		public string GetFailedSpeechNode(BasePlayer player, IConversationProvider provider)
		{
			ConversationCondition[] array = conditions;
			foreach (ConversationCondition conversationCondition in array)
			{
				if (!conversationCondition.Passes(player, provider))
				{
					return conversationCondition.failedSpeechNode;
				}
			}
			return "";
		}

		public string GetActionString()
		{
			switch (actionType)
			{
			case ActionType.None:
				return "";
			case ActionType.Custom:
				return actionString ?? "";
			case ActionType.AssignMission:
				if (!(actionMission != null) || string.IsNullOrWhiteSpace(actionMission.shortname))
				{
					return "";
				}
				return "assignmission " + actionMission.shortname;
			default:
				Debug.LogWarning((object)$"Cannot get conversation action string! Unhandled action type: {actionType}");
				return "";
			}
		}
	}

	[Serializable]
	public abstract class AbstractConversationNodeData : ISerializationCallbackReceiver
	{
		public Vector2 nodePosition;

		[field: SerializeField]
		public string Guid { get; private set; }

		void ISerializationCallbackReceiver.OnBeforeSerialize()
		{
			GenerateNewGuidIfEmpty();
		}

		void ISerializationCallbackReceiver.OnAfterDeserialize()
		{
			GenerateNewGuidIfEmpty();
		}

		public void GenerateNewGuidIfEmpty()
		{
			if (string.IsNullOrWhiteSpace(Guid))
			{
				Guid = System.Guid.NewGuid().ToString();
			}
		}
	}

	[Serializable]
	public abstract class AbstractSpeechNodeData : AbstractConversationNodeData
	{
		public ResponseNode[] responses = Array.Empty<ResponseNode>();

		public abstract string StatementTranslated { get; }
	}

	[Serializable]
	public abstract class AbstractActionEventNodeData : AbstractConversationNodeData
	{
		public string resultingNode;
	}

	[Serializable]
	public class EntryNodeData : AbstractConversationNodeData
	{
		public string resultingNode;
	}

	[Serializable]
	public class SpeechNodeData : AbstractSpeechNodeData
	{
		public string shortname;

		[FormerlySerializedAs("statementLocalized")]
		public Phrase statement;

		public override string StatementTranslated => statement.translated;
	}

	[Serializable]
	public class MissionListSpeechNodeData : AbstractSpeechNodeData
	{
		public Phrase statement;

		public MissionListNodeOptionData[] resultingNodeOptions = Array.Empty<MissionListNodeOptionData>();

		[FormerlySerializedAs("resultingNode")]
		public string defaultResultingNode;

		public override string StatementTranslated => statement.translated;
	}

	[Serializable]
	public class MissionListNodeOptionData
	{
		public BaseMission selectedMission;

		public string resultingNode;
	}

	[Serializable]
	public class MissionPreviewSpeechNodeData : AbstractSpeechNodeData
	{
		public override string StatementTranslated => string.Empty;
	}

	[Serializable]
	public class BranchNodeData : AbstractConversationNodeData
	{
		public ConversationCondition condition = new ConversationCondition();

		public string trueResultingNode;

		public string falseResultingNode;

		public string GetConditionalResultingNode(BasePlayer player, IConversationProvider provider)
		{
			if (!condition.Passes(player, provider))
			{
				return falseResultingNode;
			}
			return trueResultingNode;
		}
	}

	[Serializable]
	public class ActionEventOtherPlayerInvokedData : AbstractActionEventNodeData
	{
	}

	[Serializable]
	public class ActionEventPlayerTooPoorNodeData : AbstractActionEventNodeData
	{
	}

	[Serializable]
	public class ActionEventMissionCompletedNodeData : AbstractActionEventNodeData
	{
		public MissionListNodeOptionData[] resultingNodeOptions = Array.Empty<MissionListNodeOptionData>();

		public string GetResultingNodeForMission(uint missionId)
		{
			for (int i = 0; i < resultingNodeOptions.Length; i++)
			{
				if (missionId == resultingNodeOptions[i].selectedMission.id)
				{
					return resultingNodeOptions[i].resultingNode;
				}
			}
			return resultingNode;
		}
	}

	public class DisplayGraphViewButtonAttribute : PropertyAttribute
	{
	}

	[Serializable]
	public class ConversationCondition
	{
		public enum ConditionType
		{
			None,
			HasHealth,
			HasScrap,
			ProviderBusy,
			MissionComplete,
			MissionAttempted,
			PlayerCanAcceptMission,
			ConVar,
			ProviderHasMissionAvailable,
			PlayerHasAnyMissionActive,
			PlayerHasRecentlyCompletedMission,
			PlayerHasPaidFoodToll,
			IsNPCInDeepSea
		}

		public ConditionType conditionType;

		public uint conditionAmount;

		public string conditionString = "";

		public BaseMission conditionMission;

		public bool inverse;

		public string failedSpeechNode;

		public bool Passes(BasePlayer player, IConversationProvider provider)
		{
			bool flag = false;
			switch (conditionType)
			{
			case ConditionType.HasScrap:
				flag = player.inventory.GetAmount(ItemManager.FindItemDefinition("scrap").itemid) >= conditionAmount;
				break;
			case ConditionType.HasHealth:
				flag = player.health >= (float)conditionAmount;
				break;
			case ConditionType.ProviderBusy:
				flag = provider.ProviderBusy();
				break;
			case ConditionType.MissionComplete:
				flag = player.HasCompletedMission(MissionID());
				break;
			case ConditionType.MissionAttempted:
				flag = player.HasAttemptedMission(MissionID());
				break;
			case ConditionType.PlayerCanAcceptMission:
				flag = player.Server_CanAcceptMission(provider as IMissionProvider, MissionID());
				break;
			case ConditionType.ConVar:
				flag = GetNPCConvar(conditionString);
				break;
			case ConditionType.ProviderHasMissionAvailable:
				flag = provider is IMissionProvider missionProvider2 && missionProvider2.Server_HasMissionAvailable(player);
				break;
			case ConditionType.PlayerHasAnyMissionActive:
				flag = player.IsAnyMissionActive();
				break;
			case ConditionType.PlayerHasRecentlyCompletedMission:
				flag = provider is IMissionProvider missionProvider && missionProvider.HasPlayerRecentlyCompletedMission(player);
				break;
			case ConditionType.PlayerHasPaidFoodToll:
			{
				DeepSeaManager deepSeaManager = DeepSeaManager.Get(player.isServer);
				if ((Object)(object)deepSeaManager != (Object)null)
				{
					flag = deepSeaManager.HasPaidFoodToll(player);
				}
				break;
			}
			case ConditionType.IsNPCInDeepSea:
				flag = (Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null && DeepSeaManager.IsInsideDeepSea((BaseNetworkable)provider.Entity());
				break;
			}
			if (!inverse)
			{
				return flag;
			}
			return !flag;
		}

		private static bool GetNPCConvar(string convarString)
		{
			return convarString switch
			{
				"vendor_minicopter_enabled" => NPC_ConVars.vendor_minicopter_enabled, 
				"vendor_attack_heli_enabled" => NPC_ConVars.vendor_attack_heli_enabled, 
				"vendor_scrap_heli_enabled" => NPC_ConVars.vendor_scrap_heli_enabled, 
				"vendor_hab_enabled" => NPC_ConVars.vendor_hab_enabled, 
				"vendor_rowboat_enabled" => NPC_ConVars.vendor_rowboat_enabled, 
				"vendor_rhib_enabled" => NPC_ConVars.vendor_rhib_enabled, 
				"vendor_sub_solo_enabled" => NPC_ConVars.vendor_sub_solo_enabled, 
				"vendor_sub_duo_enabled" => NPC_ConVars.vendor_sub_duo_enabled, 
				_ => false, 
			};
		}

		private uint MissionID()
		{
			if (!(conditionMission != null))
			{
				return conditionAmount;
			}
			return conditionMission.id;
		}
	}

	public string shortname;

	public Sprite providerIcon;

	public bool canBeCancelled = true;

	public EntryNodeData entryPoint;

	[SerializeReference]
	public AbstractSpeechNodeData[] speechNodes = Array.Empty<AbstractSpeechNodeData>();

	[SerializeReference]
	public AbstractConversationNodeData[] controlNodes = Array.Empty<AbstractConversationNodeData>();

	public int GetSpeechNodeIndex(string guid)
	{
		for (int i = 0; i < speechNodes.Length; i++)
		{
			if (speechNodes[i].Guid == guid)
			{
				return i;
			}
		}
		return -1;
	}

	public int GetControlNodeIndex(string guid)
	{
		for (int i = 0; i < controlNodes.Length; i++)
		{
			if (controlNodes[i].Guid == guid)
			{
				return i;
			}
		}
		return -1;
	}

	public AbstractSpeechNodeData GetSpeechNodeData(int index)
	{
		if (index < 0)
		{
			return null;
		}
		if (speechNodes != null && index < speechNodes.Length)
		{
			return speechNodes[index];
		}
		return null;
	}

	public AbstractSpeechNodeData GetFirstSpeechNodeFrom(BasePlayer player, IConversationProvider provider, string guid, out int nodeIndex)
	{
		AbstractConversationNodeData nodeData = GetNodeData(guid);
		nodeIndex = -1;
		while (nodeData is BranchNodeData branchNodeData)
		{
			guid = branchNodeData.GetConditionalResultingNode(player, provider);
			nodeData = GetNodeData(guid);
		}
		if (nodeData is AbstractSpeechNodeData abstractSpeechNodeData)
		{
			nodeIndex = GetSpeechNodeIndex(abstractSpeechNodeData.Guid);
			return abstractSpeechNodeData;
		}
		return null;
	}

	public bool TryGetNodeData(string nodeGuid, out AbstractConversationNodeData nodeData)
	{
		nodeData = GetNodeData(nodeGuid);
		return nodeData != null;
	}

	public AbstractConversationNodeData GetNodeData(string nodeGuid)
	{
		if (string.IsNullOrWhiteSpace(nodeGuid))
		{
			return null;
		}
		if (entryPoint.Guid == nodeGuid)
		{
			return entryPoint;
		}
		AbstractSpeechNodeData[] array = speechNodes;
		foreach (AbstractSpeechNodeData abstractSpeechNodeData in array)
		{
			if (abstractSpeechNodeData.Guid == nodeGuid)
			{
				return abstractSpeechNodeData;
			}
		}
		AbstractConversationNodeData[] array2 = controlNodes;
		foreach (AbstractConversationNodeData abstractConversationNodeData in array2)
		{
			if (abstractConversationNodeData.Guid == nodeGuid)
			{
				return abstractConversationNodeData;
			}
		}
		return null;
	}

	public void FindAllMissionAssignments(BufferList<BaseMission> results)
	{
		AbstractSpeechNodeData[] array = speechNodes;
		foreach (AbstractSpeechNodeData abstractSpeechNodeData in array)
		{
			if (abstractSpeechNodeData is MissionListSpeechNodeData)
			{
				continue;
			}
			ResponseNode[] array2 = null;
			if (abstractSpeechNodeData is SpeechNodeData speechNodeData)
			{
				array2 = speechNodeData.responses;
			}
			else if (abstractSpeechNodeData is MissionPreviewSpeechNodeData missionPreviewSpeechNodeData)
			{
				array2 = missionPreviewSpeechNodeData.responses;
			}
			ResponseNode[] array3 = array2;
			foreach (ResponseNode responseNode in array3)
			{
				if (responseNode.actionType == ResponseNode.ActionType.AssignMission && responseNode.actionMission != null)
				{
					results.Add(responseNode.actionMission);
				}
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResponseNode
{
	public enum ActionType
	{
		Custom,
		None,
		AssignMission
	}

	public Phrase responseTextLocalized;

	public ConversationCondition[] conditions = Array.Empty<ConversationCondition>();

	public ActionType actionType;

	public string actionString = string.Empty;

	public BaseMission actionMission;

	public string resultingSpeechNode;

	public bool PassesConditions(BasePlayer player, IConversationProvider provider)
	{
		ConversationCondition[] array = conditions;
		for (int i = 0; i < array.Length; i++)
		{
			if (!array[i].Passes(player, provider))
			{
				return false;
			}
		}
		return true;
	}

	public string GetFailedSpeechNode(BasePlayer player, IConversationProvider provider)
	{
		ConversationCondition[] array = conditions;
		foreach (ConversationCondition conversationCondition in array)
		{
			if (!conversationCondition.Passes(player, provider))
			{
				return conversationCondition.failedSpeechNode;
			}
		}
		return "";
	}

	public string GetActionString()
	{
		switch (actionType)
		{
		case ActionType.None:
			return "";
		case ActionType.Custom:
			return actionString ?? "";
		case ActionType.AssignMission:
			if (!(actionMission != null) || string.IsNullOrWhiteSpace(actionMission.shortname))
			{
				return "";
			}
			return "assignmission " + actionMission.shortname;
		default:
			Debug.LogWarning((object)$"Cannot get conversation action string! Unhandled action type: {actionType}");
			return "";
		}
	}
}


public enum ActionType
{
	Custom,
	None,
	AssignMission
}


using System;
using UnityEngine;

[Serializable]
public abstract class AbstractConversationNodeData : ISerializationCallbackReceiver
{
	public Vector2 nodePosition;

	[field: SerializeField]
	public string Guid { get; private set; }

	void ISerializationCallbackReceiver.OnBeforeSerialize()
	{
		GenerateNewGuidIfEmpty();
	}

	void ISerializationCallbackReceiver.OnAfterDeserialize()
	{
		GenerateNewGuidIfEmpty();
	}

	public void GenerateNewGuidIfEmpty()
	{
		if (string.IsNullOrWhiteSpace(Guid))
		{
			Guid = System.Guid.NewGuid().ToString();
		}
	}
}


using System;

[Serializable]
public abstract class AbstractSpeechNodeData : AbstractConversationNodeData
{
	public ResponseNode[] responses = Array.Empty<ResponseNode>();

	public abstract string StatementTranslated { get; }
}


using System;

[Serializable]
public abstract class AbstractActionEventNodeData : AbstractConversationNodeData
{
	public string resultingNode;
}


using System;

[Serializable]
public class EntryNodeData : AbstractConversationNodeData
{
	public string resultingNode;
}


using System;
using UnityEngine.Serialization;

[Serializable]
public class SpeechNodeData : AbstractSpeechNodeData
{
	public string shortname;

	[FormerlySerializedAs("statementLocalized")]
	public Phrase statement;

	public override string StatementTranslated => statement.translated;
}


using System;
using UnityEngine.Serialization;

[Serializable]
public class MissionListSpeechNodeData : AbstractSpeechNodeData
{
	public Phrase statement;

	public MissionListNodeOptionData[] resultingNodeOptions = Array.Empty<MissionListNodeOptionData>();

	[FormerlySerializedAs("resultingNode")]
	public string defaultResultingNode;

	public override string StatementTranslated => statement.translated;
}


using System;

[Serializable]
public class MissionListNodeOptionData
{
	public BaseMission selectedMission;

	public string resultingNode;
}


using System;

[Serializable]
public class MissionPreviewSpeechNodeData : AbstractSpeechNodeData
{
	public override string StatementTranslated => string.Empty;
}


using System;

[Serializable]
public class BranchNodeData : AbstractConversationNodeData
{
	public ConversationCondition condition = new ConversationCondition();

	public string trueResultingNode;

	public string falseResultingNode;

	public string GetConditionalResultingNode(BasePlayer player, IConversationProvider provider)
	{
		if (!condition.Passes(player, provider))
		{
			return falseResultingNode;
		}
		return trueResultingNode;
	}
}


using System;

[Serializable]
public class ActionEventOtherPlayerInvokedData : AbstractActionEventNodeData
{
}


using System;

[Serializable]
public class ActionEventPlayerTooPoorNodeData : AbstractActionEventNodeData
{
}


using System;

[Serializable]
public class ActionEventMissionCompletedNodeData : AbstractActionEventNodeData
{
	public MissionListNodeOptionData[] resultingNodeOptions = Array.Empty<MissionListNodeOptionData>();

	public string GetResultingNodeForMission(uint missionId)
	{
		for (int i = 0; i < resultingNodeOptions.Length; i++)
		{
			if (missionId == resultingNodeOptions[i].selectedMission.id)
			{
				return resultingNodeOptions[i].resultingNode;
			}
		}
		return resultingNode;
	}
}


using UnityEngine;

public class DisplayGraphViewButtonAttribute : PropertyAttribute
{
}


using System;
using ConVar;
using UnityEngine;

[Serializable]
public class ConversationCondition
{
	public enum ConditionType
	{
		None,
		HasHealth,
		HasScrap,
		ProviderBusy,
		MissionComplete,
		MissionAttempted,
		PlayerCanAcceptMission,
		ConVar,
		ProviderHasMissionAvailable,
		PlayerHasAnyMissionActive,
		PlayerHasRecentlyCompletedMission,
		PlayerHasPaidFoodToll,
		IsNPCInDeepSea
	}

	public ConditionType conditionType;

	public uint conditionAmount;

	public string conditionString = "";

	public BaseMission conditionMission;

	public bool inverse;

	public string failedSpeechNode;

	public bool Passes(BasePlayer player, IConversationProvider provider)
	{
		bool flag = false;
		switch (conditionType)
		{
		case ConditionType.HasScrap:
			flag = player.inventory.GetAmount(ItemManager.FindItemDefinition("scrap").itemid) >= conditionAmount;
			break;
		case ConditionType.HasHealth:
			flag = player.health >= (float)conditionAmount;
			break;
		case ConditionType.ProviderBusy:
			flag = provider.ProviderBusy();
			break;
		case ConditionType.MissionComplete:
			flag = player.HasCompletedMission(MissionID());
			break;
		case ConditionType.MissionAttempted:
			flag = player.HasAttemptedMission(MissionID());
			break;
		case ConditionType.PlayerCanAcceptMission:
			flag = player.Server_CanAcceptMission(provider as IMissionProvider, MissionID());
			break;
		case ConditionType.ConVar:
			flag = GetNPCConvar(conditionString);
			break;
		case ConditionType.ProviderHasMissionAvailable:
			flag = provider is IMissionProvider missionProvider2 && missionProvider2.Server_HasMissionAvailable(player);
			break;
		case ConditionType.PlayerHasAnyMissionActive:
			flag = player.IsAnyMissionActive();
			break;
		case ConditionType.PlayerHasRecentlyCompletedMission:
			flag = provider is IMissionProvider missionProvider && missionProvider.HasPlayerRecentlyCompletedMission(player);
			break;
		case ConditionType.PlayerHasPaidFoodToll:
		{
			DeepSeaManager deepSeaManager = DeepSeaManager.Get(player.isServer);
			if ((Object)(object)deepSeaManager != (Object)null)
			{
				flag = deepSeaManager.HasPaidFoodToll(player);
			}
			break;
		}
		case ConditionType.IsNPCInDeepSea:
			flag = (Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null && DeepSeaManager.IsInsideDeepSea((BaseNetworkable)provider.Entity());
			break;
		}
		if (!inverse)
		{
			return flag;
		}
		return !flag;
	}

	private static bool GetNPCConvar(string convarString)
	{
		return convarString switch
		{
			"vendor_minicopter_enabled" => NPC_ConVars.vendor_minicopter_enabled, 
			"vendor_attack_heli_enabled" => NPC_ConVars.vendor_attack_heli_enabled, 
			"vendor_scrap_heli_enabled" => NPC_ConVars.vendor_scrap_heli_enabled, 
			"vendor_hab_enabled" => NPC_ConVars.vendor_hab_enabled, 
			"vendor_rowboat_enabled" => NPC_ConVars.vendor_rowboat_enabled, 
			"vendor_rhib_enabled" => NPC_ConVars.vendor_rhib_enabled, 
			"vendor_sub_solo_enabled" => NPC_ConVars.vendor_sub_solo_enabled, 
			"vendor_sub_duo_enabled" => NPC_ConVars.vendor_sub_duo_enabled, 
			_ => false, 
		};
	}

	private uint MissionID()
	{
		if (!(conditionMission != null))
		{
			return conditionAmount;
		}
		return conditionMission.id;
	}
}


public enum ConditionType
{
	None,
	HasHealth,
	HasScrap,
	ProviderBusy,
	MissionComplete,
	MissionAttempted,
	PlayerCanAcceptMission,
	ConVar,
	ProviderHasMissionAvailable,
	PlayerHasAnyMissionActive,
	PlayerHasRecentlyCompletedMission,
	PlayerHasPaidFoodToll,
	IsNPCInDeepSea
}


using UnityEngine;

public class DisableIfDlssNotSupported : MonoBehaviour
{
	private void OnEnable()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


using UnityEngine;

public class NVidiaReflex : MonoBehaviour
{
}


using System;
using UnityEngine;

[Serializable]
public class PIDController
{
	[SerializeField]
	public float p;

	[SerializeField]
	public float i;

	[SerializeField]
	public float d;

	private float oldError;

	private float integralSum;

	public float Update(float dt, float current, float target)
	{
		float num = target - current;
		float num2 = p * num;
		float num3 = (num - oldError) / dt;
		oldError = num;
		float num4 = d * num3;
		integralSum += num * dt;
		float num5 = i * integralSum;
		return num2 + num5 + num4;
	}
}


public enum BlurType
{
	StandardGauss,
	SgxGauss
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlurTypeParameter : ParameterOverride<BlurType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class FixedIntParameter : ParameterOverride<int>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(BlurOptimizedRenderer), PostProcessEvent.AfterStack, "Custom/BlurOptimized", true)]
public class BlurOptimized : PostProcessEffectSettings
{
	[Range(0f, 2f)]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};

	public BlurTypeParameter blurType = new BlurTypeParameter
	{
		value = BlurType.StandardGauss
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class BlurOptimizedRenderer : PostProcessEffectRenderer<BlurOptimized>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private Shader blurShader;

	public override void Init()
	{
		base.Init();
		blurShader = Shader.Find("Hidden/PostProcessing/BlurOptimized");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("BlurOptimized");
		int value = base.settings.downsample.value;
		float value2 = base.settings.fadeToBlurDistance.value;
		float value3 = base.settings.blurSize.value;
		int value4 = base.settings.blurIterations.value;
		BlurType value5 = base.settings.blurType.value;
		float num = 1f / (1f * (float)(1 << value));
		float num2 = 1f / Mathf.Clamp(value2, 0.001f, 10000f);
		PropertySheet propertySheet = context.propertySheets.Get(blurShader);
		propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num, (0f - value3) * num, num2, 0f));
		int num3 = context.width >> value;
		int num4 = context.height >> value;
		int num5 = Shader.PropertyToID("_BlurRT1");
		int num6 = Shader.PropertyToID("_BlurRT2");
		command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
		int num7 = ((value5 != 0) ? 2 : 0);
		for (int i = 0; i < value4; i++)
		{
			float num8 = (float)i * 1f;
			propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num + num8, (0f - value3) * num - num8, num2, 0f));
			command.GetTemporaryRT(num6, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 2 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num6);
		}
		if (value2 <= 0f)
		{
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, clear: false, null);
		}
		else
		{
			command.SetGlobalTexture("_Source", context.source);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, propertySheet, 5, clear: false, null);
		}
		command.ReleaseTemporaryRT(num5);
		command.EndSample("BlurOptimized");
	}
}


using UnityEngine;

[CreateAssetMenu]
public class CustomPostEffectsResources : ScriptableObject
{
	public Shader[] shaders;
}


public enum DOFBlurSampleCount
{
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class DOFBlurSampleCountParameter : ParameterOverride<DOFBlurSampleCount>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DepthOfFieldEffectRenderer), "Unity/Depth of Field (Custom)", false)]
public class DepthOfFieldEffect : PostProcessEffectSettings
{
	public FloatParameter focalLength = new FloatParameter
	{
		value = 10f
	};

	public FloatParameter focalSize = new FloatParameter
	{
		value = 0.05f
	};

	public FloatParameter aperture = new FloatParameter
	{
		value = 11.5f
	};

	[Range(0f, 3f)]
	public FloatParameter anamorphicSqueeze = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter anamorphicBarrel = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter maxBlurSize = new FloatParameter
	{
		value = 2f
	};

	public BoolParameter highResolution = new BoolParameter
	{
		value = true
	};

	public DOFBlurSampleCountParameter blurSampleCount = new DOFBlurSampleCountParameter
	{
		value = DOFBlurSampleCount.Low
	};

	public Transform focalTransform;
}


using ConVar;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DepthOfFieldEffectRenderer : PostProcessEffectRenderer<DepthOfFieldEffect>
{
	private float focalDistance01 = 10f;

	private float internalBlurWidth = 1f;

	private Shader dofShader;

	public override void Init()
	{
		dofShader = Shader.Find("Hidden/PostProcessing/DepthOfFieldEffect");
	}

	private float FocalDistance01(Camera cam, float worldDist)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		return cam.WorldToViewportPoint((worldDist - cam.nearClipPlane) * ((Component)cam).transform.forward + ((Component)cam).transform.position).z / (cam.farClipPlane - cam.nearClipPlane);
	}

	private void WriteCoc(PostProcessRenderContext context, PropertySheet sheet)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		RenderTargetIdentifier source = context.source;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		float num = 1f;
		int num2 = context.width / 2;
		int num3 = context.height / 2;
		int num4 = Shader.PropertyToID("DOFtemp1");
		int num5 = Shader.PropertyToID("DOFtemp2");
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num5), sheet, 1, clear: false, null);
		float num6 = internalBlurWidth * num;
		sheet.properties.SetVector("_Offsets", new Vector4(0f, num6, 0f, num6));
		command.GetTemporaryRT(num4, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num5);
		sheet.properties.SetVector("_Offsets", new Vector4(num6, 0f, 0f, num6));
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.SetGlobalTexture("_FgOverlap", RenderTargetIdentifier.op_Implicit(num5));
		command.BlitFullscreenTriangle(source, source, sheet, 3, (RenderBufferLoadAction)0, null);
		command.ReleaseTemporaryRT(num5);
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(dofShader);
		CommandBuffer command = context.command;
		int width = context.width;
		int height = context.height;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		bool value = base.settings.highResolution.value;
		DOFBlurSampleCountParameter blurSampleCount = base.settings.blurSampleCount;
		float value2 = base.settings.focalSize.value;
		float value3 = base.settings.focalLength.value;
		float value4 = base.settings.aperture.value;
		float value5 = base.settings.maxBlurSize.value;
		int num = Shader.PropertyToID("DOFrtLow");
		int num2 = Shader.PropertyToID("DOFrtLow2");
		value4 = Mathf.Clamp(value4, 1f, 32f);
		value5 = Mathf.Clamp(value5, 0.1f, 32f * ((float)context.height / 1080f));
		value2 = Mathf.Clamp(value2, 0f, 2f);
		internalBlurWidth = Mathf.Max(value5, 0f);
		focalDistance01 = FocalDistance01(context.camera, value3);
		propertySheet.properties.SetVector("_CurveParams", new Vector4(1f, value2, value4 / 10f, focalDistance01));
		propertySheet.properties.SetVector("_DistortionParams", new Vector4((float)base.settings.anamorphicSqueeze, (float)base.settings.anamorphicBarrel * 2f, 0f, 0f));
		if (value)
		{
			internalBlurWidth *= 2f;
		}
		WriteCoc(context, propertySheet);
		if (Graphics.dof_debug)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, clear: false, null);
			return;
		}
		command.GetTemporaryRT(num, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		command.GetTemporaryRT(num2, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		int pass = 2;
		if ((float)base.settings.anamorphicSqueeze > 0f || (float)base.settings.anamorphicBarrel > 0f)
		{
			command.EnableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		else
		{
			command.DisableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		propertySheet.properties.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
		propertySheet.properties.SetInt("_BlurCountMode", (int)blurSampleCount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, pass, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.ReleaseTemporaryRT(num2);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DoubleVisionRenderer), PostProcessEvent.AfterStack, "Custom/DoubleVision", true)]
public class DoubleVision : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public Vector2Parameter displace = new Vector2Parameter
	{
		value = Vector2.zero
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DoubleVisionRenderer : PostProcessEffectRenderer<DoubleVision>
{
	private int displaceProperty = Shader.PropertyToID("_displace");

	private int amountProperty = Shader.PropertyToID("_amount");

	private Shader doubleVisionShader;

	public override void Init()
	{
		base.Init();
		doubleVisionShader = Shader.Find("Hidden/PostProcessing/DoubleVision");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("DoubleVision");
		PropertySheet propertySheet = context.propertySheets.Get(doubleVisionShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(displaceProperty, Vector4.op_Implicit(base.settings.displace.value));
		propertySheet.properties.SetFloat(amountProperty, base.settings.amount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("DoubleVision");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FlashbangEffectRenderer), PostProcessEvent.AfterStack, "Custom/FlashbangEffect", false)]
public class FlashbangEffect : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter burnIntensity = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter whiteoutIntensity = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangEffectRenderer : PostProcessEffectRenderer<FlashbangEffect>
{
	public static bool needsCapture;

	private Shader flashbangEffectShader;

	private RenderTexture screenRT;

	public override void Init()
	{
		base.Init();
		flashbangEffectShader = Shader.Find("Hidden/PostProcessing/FlashbangEffect");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isPlaying)
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		CommandBuffer command = context.command;
		CheckCreateRenderTexture(ref screenRT, "Flashbang", context.width, context.height, context.sourceFormat);
		command.BeginSample("FlashbangEffect");
		if (needsCapture)
		{
			command.CopyTexture(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)screenRT));
			needsCapture = false;
		}
		PropertySheet propertySheet = context.propertySheets.Get(flashbangEffectShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat("_BurnIntensity", base.settings.burnIntensity.value);
		propertySheet.properties.SetFloat("_WhiteoutIntensity", base.settings.whiteoutIntensity.value);
		if (Object.op_Implicit((Object)(object)screenRT))
		{
			propertySheet.properties.SetTexture("_BurnOverlay", (Texture)(object)screenRT);
		}
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("FlashbangEffect");
	}

	public override void Release()
	{
		base.Release();
		SafeDestroyRenderTexture(ref screenRT);
	}

	private static void CheckCreateRenderTexture(ref RenderTexture rt, string name, int width, int height, RenderTextureFormat format)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected O, but got Unknown
		if ((Object)(object)rt == (Object)null || ((Texture)rt).width != width || ((Texture)rt).height != height)
		{
			SafeDestroyRenderTexture(ref rt);
			rt = new RenderTexture(width, height, 0, format)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).wrapMode = (TextureWrapMode)1;
			rt.Create();
		}
	}

	private static void SafeDestroyRenderTexture(ref RenderTexture rt)
	{
		if ((Object)(object)rt != (Object)null)
		{
			rt.Release();
			Object.DestroyImmediate((Object)(object)rt);
			rt = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FrostRenderer), PostProcessEvent.AfterStack, "Custom/Frost", true)]
public class Frost : PostProcessEffectSettings
{
	[Range(0f, 16f)]
	public FloatParameter scale = new FloatParameter
	{
		value = 0f
	};

	public BoolParameter enableVignette = new BoolParameter
	{
		value = true
	};

	[Range(0f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FrostRenderer : PostProcessEffectRenderer<Frost>
{
	private int scaleProperty = Shader.PropertyToID("_scale");

	private int sharpnessProperty = Shader.PropertyToID("_sharpness");

	private int darknessProperty = Shader.PropertyToID("_darkness");

	private Shader frostShader;

	public override void Init()
	{
		base.Init();
		frostShader = Shader.Find("Hidden/PostProcessing/Frost");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Frost");
		PropertySheet propertySheet = context.propertySheets.Get(frostShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		propertySheet.properties.SetFloat(sharpnessProperty, base.settings.sharpness.value * 0.01f);
		propertySheet.properties.SetFloat(darknessProperty, base.settings.darkness.value * 0.02f);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.enableVignette.value ? 1 : 0, clear: false, null);
		command.EndSample("Frost");
	}
}


public enum BlendModeType
{
	Screen,
	Add
}


public enum ResolutionType
{
	Low,
	Normal,
	High
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlendModeTypeParameter : ParameterOverride<BlendModeType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ResolutionTypeParameter : ParameterOverride<ResolutionType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GodRaysRenderer), PostProcessEvent.BeforeStack, "Custom/GodRays", true)]
public class GodRays : PostProcessEffectSettings
{
	public BoolParameter UseDepth = new BoolParameter
	{
		value = true
	};

	public BlendModeTypeParameter BlendMode = new BlendModeTypeParameter
	{
		value = BlendModeType.Screen
	};

	public FloatParameter Intensity = new FloatParameter
	{
		value = 0f
	};

	public ResolutionTypeParameter Resolution = new ResolutionTypeParameter
	{
		value = ResolutionType.High
	};

	public IntParameter BlurIterations = new IntParameter
	{
		value = 2
	};

	public FloatParameter BlurRadius = new FloatParameter
	{
		value = 2f
	};

	public FloatParameter MaxRadius = new FloatParameter
	{
		value = 0.5f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GodRaysRenderer : PostProcessEffectRenderer<GodRays>
{
	private const int PASS_SCREEN = 0;

	private const int PASS_ADD = 1;

	public Shader GodRayShader;

	public Shader ScreenClearShader;

	public Shader SkyMaskShader;

	public override void Init()
	{
		if (!Object.op_Implicit((Object)(object)GodRayShader))
		{
			GodRayShader = Shader.Find("Hidden/PostProcessing/GodRays");
		}
		if (!Object.op_Implicit((Object)(object)ScreenClearShader))
		{
			ScreenClearShader = Shader.Find("Hidden/PostProcessing/ScreenClear");
		}
		if (!Object.op_Implicit((Object)(object)SkyMaskShader))
		{
			SkyMaskShader = Shader.Find("Hidden/PostProcessing/SkyMask");
		}
	}

	private void DrawBorder(PostProcessRenderContext context, RenderTargetIdentifier buffer1)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(ScreenClearShader);
		Rect value = default(Rect);
		((Rect)(ref value))..ctor(0f, (float)(context.height - 1), (float)context.width, 1f);
		Rect value2 = default(Rect);
		((Rect)(ref value2))..ctor(0f, 0f, (float)context.width, 1f);
		Rect value3 = default(Rect);
		((Rect)(ref value3))..ctor(0f, 0f, 1f, (float)context.height);
		Rect value4 = default(Rect);
		((Rect)(ref value4))..ctor((float)(context.width - 1), 0f, 1f, (float)context.height);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value2);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value3);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value4);
	}

	private int GetSkyMask(PostProcessRenderContext context, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Invalid comparison between Unknown and I4
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		Camera camera = context.camera;
		PropertySheet propertySheet = context.propertySheets.Get(SkyMaskShader);
		command.BeginSample("GodRays");
		int num;
		int num2;
		int num3;
		switch (resolution)
		{
		case ResolutionType.High:
			num = context.screenWidth;
			num2 = context.screenHeight;
			num3 = 0;
			break;
		case ResolutionType.Normal:
			num = context.screenWidth / 2;
			num2 = context.screenHeight / 2;
			num3 = 0;
			break;
		default:
			num = context.screenWidth / 4;
			num2 = context.screenHeight / 4;
			num3 = 0;
			break;
		}
		int num4 = Shader.PropertyToID("buffer1");
		int num5 = Shader.PropertyToID("buffer2");
		command.GetTemporaryRT(num4, num, num2, num3);
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * blurRadius);
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		if ((camera.depthTextureMode & 1) != 0)
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 2, clear: false, null);
		}
		if ((int)camera.stereoActiveEye == 2)
		{
			DrawBorder(context, RenderTargetIdentifier.op_Implicit(num4));
		}
		float num6 = blurRadius * 0.0013020834f;
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		for (int i = 0; i < blurIterations; i++)
		{
			command.GetTemporaryRT(num5, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num4);
			num6 = blurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
			command.GetTemporaryRT(num4, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			num6 = blurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		}
		command.EndSample("GodRays");
		return num4;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		TOD_Sky instance = TOD_Sky.Instance;
		if (!((Object)(object)instance == (Object)null))
		{
			Vector3 val = camera.WorldToViewportPoint(instance.Components.LightTransform.position);
			CommandBuffer command = context.command;
			PropertySheet propertySheet = context.propertySheets.Get(GodRayShader);
			int skyMask = GetSkyMask(context, base.settings.Resolution.value, val, base.settings.BlurIterations.value, base.settings.BlurRadius.value, base.settings.MaxRadius.value);
			Color val2 = Color.black;
			if ((double)val.z >= 0.0)
			{
				val2 = ((!instance.IsDay) ? (base.settings.Intensity.value * instance.MoonVisibility * instance.MoonRayColor) : (base.settings.Intensity.value * instance.SunVisibility * instance.SunRayColor));
			}
			propertySheet.properties.SetColor("_LightColor", val2);
			command.SetGlobalTexture("_SkyMask", RenderTargetIdentifier.op_Implicit(skyMask));
			if (base.settings.BlendMode.value == BlendModeType.Screen)
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
			}
			else
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(skyMask);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GreyScaleRenderer), PostProcessEvent.AfterStack, "Custom/GreyScale", true)]
public class GreyScale : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter redLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter greenLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter blueLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[ColorUsage(false, true)]
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GreyScaleRenderer : PostProcessEffectRenderer<GreyScale>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private int colorProperty = Shader.PropertyToID("_color");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/GreyScale");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("GreyScale");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(dataProperty, new Vector4(base.settings.redLuminance.value, base.settings.greenLuminance.value, base.settings.blueLuminance.value, base.settings.amount.value));
		propertySheet.properties.SetColor(colorProperty, base.settings.color.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("GreyScale");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(LensDirtinessRenderer), PostProcessEvent.AfterStack, "Custom/LensDirtiness", true)]
public class LensDirtinessEffect : PostProcessEffectSettings
{
	public TextureParameter dirtinessTexture = new TextureParameter();

	public BoolParameter sceneTintsBloom = new BoolParameter
	{
		value = false
	};

	public FloatParameter gain = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter threshold = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter bloomSize = new FloatParameter
	{
		value = 5f
	};

	public FloatParameter dirtiness = new FloatParameter
	{
		value = 1f
	};

	public ColorParameter bloomColor = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class LensDirtinessRenderer : PostProcessEffectRenderer<LensDirtinessEffect>
{
	private enum Pass
	{
		Threshold,
		Kawase,
		Compose
	}

	private int dataProperty = Shader.PropertyToID("_data");

	private Shader lensDirtinessShader;

	public override void Init()
	{
		base.Init();
		lensDirtinessShader = Shader.Find("Hidden/PostProcessing/LensDirtiness");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		float value = base.settings.bloomSize.value;
		float value2 = base.settings.gain.value;
		float value3 = base.settings.threshold.value;
		float value4 = base.settings.dirtiness.value;
		Color value5 = base.settings.bloomColor.value;
		Texture value6 = base.settings.dirtinessTexture.value;
		bool value7 = base.settings.sceneTintsBloom.value;
		CommandBuffer command = context.command;
		command.BeginSample("LensDirtinessEffect");
		if (value7)
		{
			command.EnableShaderKeyword("_SCENE_TINTS_BLOOM");
		}
		PropertySheet propertySheet = context.propertySheets.Get(lensDirtinessShader);
		RenderTargetIdentifier source = context.source;
		RenderTargetIdentifier destination = context.destination;
		int width = context.width;
		int height = context.height;
		int num = Shader.PropertyToID("_RTT_BloomThreshold");
		int num2 = Shader.PropertyToID("_RTT_1");
		int num3 = Shader.PropertyToID("_RTT_2");
		int num4 = Shader.PropertyToID("_RTT_3");
		int num5 = Shader.PropertyToID("_RTT_4");
		int num6 = Shader.PropertyToID("_RTT_Bloom_1");
		int num7 = Shader.PropertyToID("_RTT_Bloom_2");
		propertySheet.properties.SetFloat("_Gain", value2);
		propertySheet.properties.SetFloat("_Threshold", value3);
		command.GetTemporaryRT(num, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num), propertySheet, 0, clear: false, null);
		propertySheet.properties.SetVector("_Offset", new Vector4(1f / (float)width, 1f / (float)height, 0f, 0f) * 2f);
		command.GetTemporaryRT(num2, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num), RenderTargetIdentifier.op_Implicit(num2), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.GetTemporaryRT(num3, width / 4, height / 4, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num2), RenderTargetIdentifier.op_Implicit(num3), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num2);
		command.GetTemporaryRT(num4, width / 8, height / 8, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num3), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num3);
		command.GetTemporaryRT(num5, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.GetTemporaryRT(num6, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.GetTemporaryRT(num7, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), clear: false, null);
		command.ReleaseTemporaryRT(num5);
		for (int i = 1; i <= 8; i++)
		{
			float num8 = value * (float)i / (float)width;
			float num9 = value * (float)i / (float)height;
			propertySheet.properties.SetVector("_Offset", new Vector4(num8, num9, 0f, 0f));
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num7), propertySheet, 1, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num7), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1, clear: false, null);
		}
		command.SetGlobalTexture("_Bloom", RenderTargetIdentifier.op_Implicit(num7));
		propertySheet.properties.SetFloat("_Dirtiness", value4);
		propertySheet.properties.SetColor("_BloomColor", value5);
		propertySheet.properties.SetTexture("_DirtinessTexture", value6);
		command.BlitFullscreenTriangle(source, destination, propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(num6);
		command.ReleaseTemporaryRT(num7);
		command.EndSample("LensDirtinessEffect");
	}
}


private enum Pass
{
	Threshold,
	Kawase,
	Compose
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(NightLightEffectRenderer), PostProcessEvent.BeforeStack, "Custom/NightLight", true)]
public class NightLightEffect : PostProcessEffectSettings
{
	[Range(0f, 25f)]
	public FloatParameter distance = new FloatParameter
	{
		value = 5f
	};

	[Range(0f, 1f)]
	public FloatParameter fadeFraction = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter brightness = new FloatParameter
	{
		value = 0.1f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class NightLightEffectRenderer : PostProcessEffectRenderer<NightLightEffect>
{
	private int distanceProperty = Shader.PropertyToID("_distance");

	private int fadeFractionProperty = Shader.PropertyToID("_fadefraction");

	private int brightnessProperty = Shader.PropertyToID("_brightness");

	private Shader nightlightShader;

	public override void Init()
	{
		base.Init();
		nightlightShader = Shader.Find("Hidden/PostProcessing/NightLightShader");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("NightLight");
		PropertySheet propertySheet = context.propertySheets.Get(nightlightShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(distanceProperty, base.settings.distance.value);
		propertySheet.properties.SetFloat(fadeFractionProperty, base.settings.fadeFraction.value);
		propertySheet.properties.SetFloat(brightnessProperty, base.settings.brightness.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("NightLight");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(PhotoFilterRenderer), PostProcessEvent.AfterStack, "Custom/PhotoFilter", true)]
public class PhotoFilter : PostProcessEffectSettings
{
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};

	[Range(0f, 1f)]
	public FloatParameter density = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class PhotoFilterRenderer : PostProcessEffectRenderer<PhotoFilter>
{
	private int rgbProperty = Shader.PropertyToID("_rgb");

	private int densityProperty = Shader.PropertyToID("_density");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/PhotoFilter");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("PhotoFilter");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetColor(rgbProperty, base.settings.color.value);
		propertySheet.properties.SetFloat(densityProperty, base.settings.density.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("PhotoFilter");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RadialBlurRenderer), PostProcessEvent.AfterStack, "Custom/RadialBlur", true)]
public class RadialBlur : PostProcessEffectSettings
{
	[Header("Radial Controls")]
	public Vector2Parameter center = new Vector2Parameter
	{
		value = new Vector2(0.5f, 0.5f)
	};

	[Range(0.1f, 2f)]
	public FloatParameter start = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 2f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 3f)]
	[Header("Blur Quality")]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 1
	};

	[Range(1f, 4f)]
	public FixedIntParameter iterations = new FixedIntParameter
	{
		value = 2
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class RadialBlurRenderer : PostProcessEffectRenderer<RadialBlur>
{
	private Shader shader;

	private int rt1ID = Shader.PropertyToID("_BlurRT1");

	private int rt2ID = Shader.PropertyToID("_BlurRT2");

	private int paramsID = Shader.PropertyToID("_Params");

	public override void Init()
	{
		base.Init();
		shader = Shader.Find("Hidden/PostProcessing/RadialBlur");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("RadialBlur");
		if (Mathf.Approximately((float)base.settings.start, 1f) && Mathf.Approximately((float)base.settings.amount, 0f))
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		else
		{
			PropertySheet propertySheet = context.propertySheets.Get(shader);
			propertySheet.properties.SetVector(paramsID, new Vector4(base.settings.center.value.x, base.settings.center.value.y, (float)base.settings.start, (float)base.settings.amount));
			int num = context.width >> (int)base.settings.downsample;
			int num2 = context.height >> (int)base.settings.downsample;
			int num3 = (int)base.settings.iterations / 2;
			int num4 = (int)base.settings.iterations % 2;
			command.GetTemporaryRT(rt1ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.GetTemporaryRT(rt2ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 0, clear: false, null);
			if ((int)base.settings.iterations > 1)
			{
				for (int i = 0; i < num3; i++)
				{
					command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), RenderTargetIdentifier.op_Implicit(rt2ID), propertySheet, 1, clear: false, null);
					if (i == num3 - 1 && num4 == 0)
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), context.destination, propertySheet, 1, clear: false, null);
					}
					else
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 1, clear: false, null);
					}
				}
			}
			if (num4 > 0)
			{
				command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(rt1ID);
			command.ReleaseTemporaryRT(rt2ID);
		}
		command.EndSample("RadialBlur");
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RustTemporalAntialiasingRenderer), PostProcessEvent.BeforeStack, "Custom/RustTemporalAntialiasing", false)]
public sealed class RustTemporalAntialiasing : PostProcessEffectSettings
{
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class Jitter
{
	private readonly Vector2[] haltonSequence = (Vector2[])(object)new Vector2[16]
	{
		new Vector2(0.5f, 0.333333f),
		new Vector2(0.25f, 0.666667f),
		new Vector2(0.75f, 0.111111f),
		new Vector2(0.125f, 0.444444f),
		new Vector2(0.625f, 0.777778f),
		new Vector2(0.375f, 0.222222f),
		new Vector2(0.875f, 0.555556f),
		new Vector2(0.0625f, 0.888889f),
		new Vector2(0.5625f, 0.037037f),
		new Vector2(0.3125f, 0.37037f),
		new Vector2(0.8125f, 0.703704f),
		new Vector2(0.1875f, 0.148148f),
		new Vector2(0.6875f, 0.481481f),
		new Vector2(0.4375f, 0.814815f),
		new Vector2(0.9375f, 0.259259f),
		new Vector2(1f / 32f, 0.592593f)
	};

	public int SampleIndex { get; private set; }

	public int SampleCount { get; private set; } = 8;

	public Vector2 Offset { get; private set; } = Vector2.zero;

	public Vector2 TexelOffset { get; private set; } = Vector2.zero;

	public Jitter()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		SampleCount = haltonSequence.Length;
	}

	private Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		Offset = haltonSequence[++SampleIndex % 8] - new Vector2(0.5f, 0.5f);
		TexelOffset = new Vector2(Offset.x / (float)camera.pixelWidth, Offset.y / (float)camera.pixelHeight);
		return RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, Offset);
	}

	public void ConfigureCameraJitter(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
		camera.projectionMatrix = GetJitteredProjectionMatrix(camera);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public sealed class RustTemporalAntialiasingRenderer : PostProcessEffectRenderer<RustTemporalAntialiasing>
{
	private const string BUFFER_NAME = "RustTemporalAntiAliasing";

	private static readonly int historyTextureId = Shader.PropertyToID("_HistoryTex");

	private static readonly int jitterTexelOffsetId = Shader.PropertyToID("_JitterTexelOffset");

	public readonly Jitter JitterSettings = new Jitter();

	private RenderTexture[] historyTextures = (RenderTexture[])(object)new RenderTexture[2];

	private readonly RenderTargetIdentifier[] multipleRenderTargets = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2];

	private int pingPongValue;

	private Shader postProcessShader;

	public static RustTemporalAntialiasingRenderer Instance { get; private set; }

	public override void Init()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		postProcessShader = Shader.Find("Hidden/PostProcessing/RustTemporalAntialiasing");
		if ((Object)(object)postProcessShader == (Object)null)
		{
			Debug.LogError((object)"Failed to initialize RustTemporalAntialiasing as the shader couldn't be found!");
		}
	}

	private bool IsValid()
	{
		return (Object)(object)postProcessShader != (Object)null;
	}

	private RenderTexture ConvertTextureToMatchCamera(RenderTexture texture, PostProcessRenderContext context)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null || ((Texture)texture).width != context.width || ((Texture)texture).height != context.height)
		{
			if (texture != null)
			{
				texture.Release();
			}
			texture = new RenderTexture(context.width, context.height, 0, context.sourceFormat);
		}
		return texture;
	}

	private void RecreateRenderTexturesIfNeeded(PostProcessRenderContext context)
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			historyTextures[i] = ConvertTextureToMatchCamera(historyTextures[i], context);
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!IsValid())
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		Camera camera = context.camera;
		camera.depthTextureMode = (DepthTextureMode)(camera.depthTextureMode | 5);
		JitterSettings.ConfigureCameraJitter(context);
		RecreateRenderTexturesIfNeeded(context);
		PropertySheet propertySheet = context.propertySheets.Get(postProcessShader);
		CommandBuffer command = context.command;
		RenderTexture val = historyTextures[pingPongValue++ % 2];
		RenderTexture val2 = historyTextures[pingPongValue++ % 2];
		pingPongValue++;
		multipleRenderTargets[0] = context.destination;
		multipleRenderTargets[1] = RenderTargetIdentifier.op_Implicit((Texture)(object)val);
		command.BeginSample("RustTemporalAntiAliasing");
		command.SetGlobalVector(jitterTexelOffsetId, Vector4.op_Implicit(JitterSettings.TexelOffset));
		command.SetGlobalTexture(historyTextureId, RenderTargetIdentifier.op_Implicit((Texture)(object)val2));
		command.BlitFullscreenTriangle(context.source, multipleRenderTargets, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet, 0, clear: false, null);
		command.EndSample("RustTemporalAntiAliasing");
	}

	public override void Release()
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			RenderTexture obj = historyTextures[i];
			if (obj != null)
			{
				obj.Release();
			}
			historyTextures[i] = null;
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RustTemporalAntialiasingOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


public enum OverlayBlendMode
{
	Additive,
	ScreenBlend,
	Multiply,
	Overlay,
	AlphaBlend,
	AdditiveNonLit,
	AlpbaBlendConst
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class OverlayBlendModeParameter : ParameterOverride<OverlayBlendMode>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ScreenOverlayRenderer), PostProcessEvent.AfterStack, "Custom/ScreenOverlay", true)]
public class ScreenOverlay : PostProcessEffectSettings
{
	public OverlayBlendModeParameter blendMode = new OverlayBlendModeParameter
	{
		value = OverlayBlendMode.Multiply
	};

	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	public TextureParameter texture = new TextureParameter
	{
		value = null
	};

	public TextureParameter normals = new TextureParameter
	{
		value = null
	};

	public BoolParameter respectUseLightingConvar = new BoolParameter
	{
		value = false
	};
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ScreenOverlayRenderer : PostProcessEffectRenderer<ScreenOverlay>
{
	private Shader overlayShader;

	public override void Init()
	{
		base.Init();
		overlayShader = Shader.Find("Hidden/PostProcessing/ScreenOverlay");
	}

	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(SharpenAndVignetteRenderer), PostProcessEvent.AfterStack, "Custom/SharpenAndVignette", true)]
public class SharpenAndVignette : PostProcessEffectSettings
{
	[Header("Sharpen")]
	public BoolParameter applySharpen = new BoolParameter
	{
		value = true
	};

	[Range(0f, 5f)]
	public FloatParameter strength = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter clamp = new FloatParameter
	{
		value = 1f
	};

	[Header("Vignette")]
	public BoolParameter applyVignette = new BoolParameter
	{
		value = true
	};

	[Range(-100f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteRenderer : PostProcessEffectRenderer<SharpenAndVignette>
{
	private Shader sharpenAndVigenetteShader;

	public override void Init()
	{
		base.Init();
		sharpenAndVigenetteShader = Shader.Find("Hidden/PostProcessing/SharpenAndVignette");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("SharpenAndVignette");
		PropertySheet propertySheet = context.propertySheets.Get(sharpenAndVigenetteShader);
		propertySheet.properties.Clear();
		bool value = base.settings.applySharpen.value;
		bool value2 = base.settings.applyVignette.value;
		if (value)
		{
			propertySheet.properties.SetFloat("_px", 1f / (float)Screen.width);
			propertySheet.properties.SetFloat("_py", 1f / (float)Screen.height);
			propertySheet.properties.SetFloat("_strength", base.settings.strength.value);
			propertySheet.properties.SetFloat("_clamp", base.settings.clamp.value);
		}
		if (value2)
		{
			propertySheet.properties.SetFloat("_sharpness", base.settings.sharpness.value * 0.01f);
			propertySheet.properties.SetFloat("_darkness", base.settings.darkness.value * 0.02f);
		}
		if (value && !value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		else if (value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
		}
		else if (!value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		command.EndSample("SharpenAndVignette");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(UnderWaterEffectRenderer), PostProcessEvent.AfterStack, "Custom/UnderWaterEffect", false)]
public class UnderwaterPostEffect : PostProcessEffectSettings
{
	[Header("Wiggle")]
	public BoolParameter wiggle = new BoolParameter();

	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};

	[Header("Water Line")]
	public ColorParameter waterLineColor = new ColorParameter();

	[Range(1f, 4f)]
	public FixedIntParameter waterLineBlurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter waterLineBlurSize = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 2f)]
	[Header("Blur")]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine.Rendering.PostProcessing;

public class UnderWaterEffectRenderer : PostProcessEffectRenderer<UnderwaterPostEffect>
{
	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(WiggleRenderer), PostProcessEvent.AfterStack, "Custom/Wiggle", true)]
public class Wiggle : PostProcessEffectSettings
{
	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class WiggleRenderer : PostProcessEffectRenderer<Wiggle>
{
	private int timerProperty = Shader.PropertyToID("_timer");

	private int scaleProperty = Shader.PropertyToID("_scale");

	private Shader wiggleShader;

	private float timer;

	public override void Init()
	{
		base.Init();
		wiggleShader = Shader.Find("Hidden/PostProcessing/Wiggle");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Wiggle");
		timer += base.settings.speed.value * Time.deltaTime;
		PropertySheet propertySheet = context.propertySheets.Get(wiggleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(timerProperty, timer);
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("Wiggle");
	}
}


using UnityEngine;

public class PostProcessVolumeLOD : MonoBehaviour, ILOD, IClientComponent
{
	public float distance;
}


using System;

public class BoundsCheck : PrefabAttribute
{
	public enum BlockType
	{
		Tree
	}

	public BlockType IsType;

	protected override Type GetIndexedType()
	{
		return typeof(BoundsCheck);
	}
}


public enum BlockType
{
	Tree
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class BoundsCheckEx
{
	public static bool ApplyBoundsChecks(this BaseEntity entity, BoundsCheck[] bounds, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (bounds.Length == 0 && LayerMask.op_Implicit(rejectOnLayer) == 0)
		{
			return true;
		}
		OBB obb = new OBB(pos + rot * Vector3.Scale(((Bounds)(ref entity.bounds)).center, scale), Vector3.Scale(((Bounds)(ref entity.bounds)).extents, scale), rot);
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, 0x40000 | LayerMask.op_Implicit(rejectOnLayer), (QueryTriggerInteraction)2);
		SpawnableBoundsBlocker spawnableBoundsBlocker = default(SpawnableBoundsBlocker);
		foreach (Collider item in list)
		{
			if (!item.isTrigger && (((Component)item).gameObject.layer & LayerMask.op_Implicit(rejectOnLayer)) != 0)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
			if (!((Component)item).TryGetComponent<SpawnableBoundsBlocker>(ref spawnableBoundsBlocker))
			{
				continue;
			}
			foreach (BoundsCheck boundsCheck in bounds)
			{
				if (spawnableBoundsBlocker.BlockType == boundsCheck.IsType)
				{
					Pool.FreeUnmanaged<Collider>(ref list);
					return false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SpawnableBoundsBlocker : MonoBehaviour
{
	public BoundsCheck.BlockType BlockType;

	public BoxCollider BoxCollider;

	[Button("Clear Trees")]
	public void ClearTrees()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
		if ((Object)(object)BoxCollider != (Object)null)
		{
			GamePhysics.OverlapOBB<TreeEntity>(new OBB(((Component)this).transform.TransformPoint(BoxCollider.center), BoxCollider.size + Vector3.one, ((Component)this).transform.rotation), list, 1073741824, (QueryTriggerInteraction)2);
		}
		foreach (TreeEntity item in list)
		{
			BoundsCheck boundsCheck = PrefabAttribute.server.Find<BoundsCheck>(item.prefabID);
			if (boundsCheck != null && boundsCheck.IsType == BlockType)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<TreeEntity>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ByteMap
{
	[SerializeField]
	private int size;

	[SerializeField]
	private int bytes;

	[SerializeField]
	private byte[] values;

	public int Size => size;

	public uint this[int x, int y]
	{
		get
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				return values[num];
			case 2:
			{
				byte num7 = values[num];
				uint num3 = values[num + 1];
				return (uint)(num7 << 8) | num3;
			}
			case 3:
			{
				byte num6 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				return (uint)(num6 << 16) | (num3 << 8) | num4;
			}
			default:
			{
				byte num2 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				uint num5 = values[num + 3];
				return (uint)(num2 << 24) | (num3 << 16) | (num4 << 8) | num5;
			}
			}
		}
		set
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				values[num] = (byte)(value & 0xFF);
				break;
			case 2:
				values[num] = (byte)((value >> 8) & 0xFF);
				values[num + 1] = (byte)(value & 0xFF);
				break;
			case 3:
				values[num] = (byte)((value >> 16) & 0xFF);
				values[num + 1] = (byte)((value >> 8) & 0xFF);
				values[num + 2] = (byte)(value & 0xFF);
				break;
			default:
				values[num] = (byte)((value >> 24) & 0xFF);
				values[num + 1] = (byte)((value >> 16) & 0xFF);
				values[num + 2] = (byte)((value >> 8) & 0xFF);
				values[num + 3] = (byte)(value & 0xFF);
				break;
			}
		}
	}

	public ByteMap(int size, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		values = new byte[bytes * size * size];
	}

	public ByteMap(int size, byte[] values, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		this.values = values;
	}
}


using System;
using UnityEngine;

[Serializable]
public sealed class ByteQuadtree
{
	public struct Element
	{
		private ByteQuadtree source;

		private int x;

		private int y;

		private int level;

		public bool IsLeaf => level == 0;

		public bool IsRoot => level == source.levels - 1;

		public int ByteMap => level;

		public uint Value => source.values[level][x, y];

		public Vector2 Coords => new Vector2((float)x, (float)y);

		public int Depth => source.levels - level - 1;

		public Element Parent
		{
			get
			{
				if (IsRoot)
				{
					throw new Exception("Element is the root and therefore has no parent.");
				}
				return new Element(source, x / 2, y / 2, level + 1);
			}
		}

		public Element Child1
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2, level - 1);
			}
		}

		public Element Child2
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2, level - 1);
			}
		}

		public Element Child3
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2 + 1, level - 1);
			}
		}

		public Element Child4
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
			}
		}

		public Element MaxChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				if (value >= value2 && value >= value3 && value >= value4)
				{
					return child;
				}
				if (value2 >= value3 && value2 >= value4)
				{
					return child2;
				}
				if (value3 >= value4)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element RandChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				float num = value + value2 + value3 + value4;
				float value5 = Random.value;
				if ((float)value / num >= value5)
				{
					return child;
				}
				if ((float)(value + value2) / num >= value5)
				{
					return child2;
				}
				if ((float)(value + value2 + value3) / num >= value5)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element(ByteQuadtree source, int x, int y, int level)
		{
			this.source = source;
			this.x = x;
			this.y = y;
			this.level = level;
		}
	}

	[SerializeField]
	private int size;

	[SerializeField]
	private int levels;

	[SerializeField]
	private ByteMap[] values;

	public int Size => size;

	public Element Root => new Element(this, 0, 0, levels - 1);

	public void UpdateValues(byte[] baseValues)
	{
		size = Mathf.RoundToInt(Mathf.Sqrt((float)baseValues.Length));
		levels = Mathf.RoundToInt(Mathf.Max(Mathf.Log((float)size, 2f), 0f)) + 1;
		values = new ByteMap[levels];
		values[0] = new ByteMap(size, baseValues);
		for (int i = 1; i < levels; i++)
		{
			ByteMap byteMap = values[i - 1];
			ByteMap byteMap2 = (values[i] = CreateLevel(i));
			for (int j = 0; j < byteMap2.Size; j++)
			{
				for (int k = 0; k < byteMap2.Size; k++)
				{
					byteMap2[k, j] = byteMap[2 * k, 2 * j] + byteMap[2 * k + 1, 2 * j] + byteMap[2 * k, 2 * j + 1] + byteMap[2 * k + 1, 2 * j + 1];
				}
			}
		}
	}

	private ByteMap CreateLevel(int level)
	{
		int num = 1 << levels - level - 1;
		int bytes = 1 + (level + 3) / 4;
		return new ByteMap(num, bytes);
	}
}


using System;
using UnityEngine;

public struct Element
{
	private ByteQuadtree source;

	private int x;

	private int y;

	private int level;

	public bool IsLeaf => level == 0;

	public bool IsRoot => level == source.levels - 1;

	public int ByteMap => level;

	public uint Value => source.values[level][x, y];

	public Vector2 Coords => new Vector2((float)x, (float)y);

	public int Depth => source.levels - level - 1;

	public Element Parent
	{
		get
		{
			if (IsRoot)
			{
				throw new Exception("Element is the root and therefore has no parent.");
			}
			return new Element(source, x / 2, y / 2, level + 1);
		}
	}

	public Element Child1
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2, level - 1);
		}
	}

	public Element Child2
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2, level - 1);
		}
	}

	public Element Child3
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2 + 1, level - 1);
		}
	}

	public Element Child4
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
		}
	}

	public Element MaxChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			if (value >= value2 && value >= value3 && value >= value4)
			{
				return child;
			}
			if (value2 >= value3 && value2 >= value4)
			{
				return child2;
			}
			if (value3 >= value4)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element RandChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			float num = value + value2 + value3 + value4;
			float value5 = Random.value;
			if ((float)value / num >= value5)
			{
				return child;
			}
			if ((float)(value + value2) / num >= value5)
			{
				return child2;
			}
			if ((float)(value + value2 + value3) / num >= value5)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element(ByteQuadtree source, int x, int y, int level)
	{
		this.source = source;
		this.x = x;
		this.y = y;
		this.level = level;
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Unity.Collections;
using UnityEngine;

public static class ImageProcessing
{
	private static byte[] signaturePNG = new byte[8] { 137, 80, 78, 71, 13, 10, 26, 10 };

	private static byte[] signatureIHDR = new byte[8] { 0, 0, 0, 13, 73, 72, 68, 82 };

	public static void GaussianBlur2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] array = data;
		float[] array2 = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			for (int j = 0; j < len1; j++)
			{
				int num = Mathf.Max(0, j - 1);
				int num2 = Mathf.Min(len1 - 1, j + 1);
				for (int k = 0; k < len2; k++)
				{
					int num3 = Mathf.Max(0, k - 1);
					int num4 = Mathf.Min(len2 - 1, k + 1);
					float num5 = array[j * len2 + k] * 4f + array[j * len2 + num3] + array[j * len2 + num4] + array[num * len2 + k] + array[num2 * len2 + k];
					array2[j * len2 + k] = num5 * 0.125f;
				}
			}
			GenericsUtil.Swap<float[]>(ref array, ref array2);
		}
		if (array != data)
		{
			Buffer.BlockCopy(array, 0, data, 0, data.Length * 4);
		}
	}

	public static void GaussianBlur2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] * 4f + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.125f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					float num5 = src[x * len2 + j] + src[x * len2 + num3] + src[x * len2 + num4] + src[num * len2 + j] + src[num2 * len2 + j];
					dst[x * len2 + j] = num5 * 0.2f;
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.2f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, float[] dst, int dstlen1, int dstlen2)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2)
		{
			return;
		}
		Parallel.For(0, srclen1, delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				float num5 = src[x * srclen2 + i] * 6f;
				float num6 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num3];
				dst[2 * x * dstlen2 + 2 * i] = num6 * 0.125f;
				float num7 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num3];
				dst[(2 * x + 1) * dstlen2 + 2 * i] = num7 * 0.125f;
				float num8 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num4];
				dst[2 * x * dstlen2 + (2 * i + 1)] = num8 * 0.125f;
				float num9 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num4];
				dst[(2 * x + 1) * dstlen2 + (2 * i + 1)] = num9 * 0.125f;
			}
		});
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, int srclen3, float[] dst, int dstlen1, int dstlen2, int dstlen3)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2 || srclen3 != dstlen3)
		{
			return;
		}
		Parallel.For(0, srclen1, delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				for (int j = 0; j < srclen3; j++)
				{
					float num5 = src[(x * srclen2 + i) * srclen3 + j] * 6f;
					float num6 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[(2 * x * dstlen2 + 2 * i) * dstlen3 + j] = num6 * 0.125f;
					float num7 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + 2 * i) * dstlen3 + j] = num7 * 0.125f;
					float num8 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[(2 * x * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num8 * 0.125f;
					float num9 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num9 * 0.125f;
				}
			}
		});
	}

	public static void Dilate2D(NativeArray<int> src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Parallel.For(0, len1, delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void Dilate2D(int[] src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		Parallel.For(0, len1, delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void FloodFill2D(int x, int y, int[] data, int len1, int len2, int mask_any, int mask_not, Func<int, int> action)
	{
		Stack<KeyValuePair<int, int>> stack = new Stack<KeyValuePair<int, int>>();
		stack.Push(new KeyValuePair<int, int>(x, y));
		while (stack.Count > 0)
		{
			KeyValuePair<int, int> keyValuePair = stack.Pop();
			x = keyValuePair.Key;
			y = keyValuePair.Value;
			int num;
			for (num = y; num >= 0; num--)
			{
				int num2 = data[x * len2 + num];
				if ((num2 & mask_any) == 0 || (num2 & mask_not) != 0)
				{
					break;
				}
			}
			num++;
			bool flag;
			bool flag2 = (flag = false);
			for (; num < len2; num++)
			{
				int num3 = data[x * len2 + num];
				if ((num3 & mask_any) == 0 || (num3 & mask_not) != 0)
				{
					break;
				}
				data[x * len2 + num] = action(num3);
				if (x > 0)
				{
					int num4 = data[(x - 1) * len2 + num];
					bool flag3 = (num4 & mask_any) != 0 && (num4 & mask_not) == 0;
					if (!flag2 && flag3)
					{
						stack.Push(new KeyValuePair<int, int>(x - 1, num));
						flag2 = true;
					}
					else if (flag2 && !flag3)
					{
						flag2 = false;
					}
				}
				if (x < len1 - 1)
				{
					int num5 = data[(x + 1) * len2 + num];
					bool flag4 = (num5 & mask_any) != 0 && (num5 & mask_not) == 0;
					if (!flag && flag4)
					{
						stack.Push(new KeyValuePair<int, int>(x + 1, num));
						flag = true;
					}
					else if (flag && !flag4)
					{
						flag = false;
					}
				}
			}
		}
	}

	public static bool IsValidPNG(byte[] data, int maxSizeSquare)
	{
		return IsValidPNG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidPNG(byte[] data, int maxWidth, int maxHeight)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (data == null || data.Length < 29)
		{
			return false;
		}
		if (data.Length > 29 + maxWidth * maxHeight * 4)
		{
			return false;
		}
		for (int i = 0; i < signaturePNG.Length; i++)
		{
			if (data[i] != signaturePNG[i])
			{
				return false;
			}
		}
		for (int j = 0; j < signatureIHDR.Length; j++)
		{
			if (data[8 + j] != signatureIHDR[j])
			{
				return false;
			}
		}
		Union32 val = default(Union32);
		val.b4 = data[16];
		val.b3 = data[17];
		val.b2 = data[18];
		val.b1 = data[19];
		if (val.i < 1 || val.i > maxWidth)
		{
			return false;
		}
		Union32 val2 = default(Union32);
		val2.b4 = data[20];
		val2.b3 = data[21];
		val2.b2 = data[22];
		val2.b1 = data[23];
		if (val2.i < 1 || val2.i > maxHeight)
		{
			return false;
		}
		byte b = data[24];
		if (b != 8 && b != 16)
		{
			return false;
		}
		byte b2 = data[25];
		if (b2 != 2 && b2 != 6)
		{
			return false;
		}
		if (data[26] != 0)
		{
			return false;
		}
		if (data[27] != 0)
		{
			return false;
		}
		if (data[28] != 0)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidJPG(byte[] data, int maxSizeSquare)
	{
		return IsValidJPG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidJPG(byte[] data, int maxWidth, int maxHeight)
	{
		if (data.Length < 30)
		{
			return false;
		}
		if (data.Length > 30 + maxWidth * maxHeight)
		{
			return false;
		}
		try
		{
			if (data[0] != byte.MaxValue || data[1] != 216)
			{
				return false;
			}
			if (data[2] != byte.MaxValue || data[3] != 224)
			{
				return false;
			}
			if (data[6] != 74 || data[7] != 70 || data[8] != 73 || data[9] != 70 || data[10] != 0)
			{
				return false;
			}
			if (data[13] != 0)
			{
				return false;
			}
			if (data[14] != data[16] || data[15] != data[17])
			{
				return false;
			}
			int num = 4;
			int num2 = (data[num] << 8) | data[num + 1];
			while (num < data.Length)
			{
				num += num2;
				if (num >= data.Length)
				{
					return false;
				}
				if (data[num] != byte.MaxValue)
				{
					return false;
				}
				if (data[num + 1] == 192 || data[num + 1] == 193 || data[num + 1] == 194)
				{
					int num3 = (data[num + 5] << 8) | data[num + 6];
					return ((data[num + 7] << 8) | data[num + 8]) <= maxWidth && num3 <= maxHeight;
				}
				num += 2;
				num2 = (data[num] << 8) | data[num + 1];
			}
			return false;
		}
		catch
		{
			return false;
		}
	}

	public static bool IsClear(Color32[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (data[i].a > 5)
			{
				return false;
			}
		}
		return true;
	}
}


public static class ManagedNoise
{
	private static readonly int[] hash = new int[512]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
		90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
		7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
		37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
		234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
		117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
		56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
		74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
		158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
		220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
		143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
		209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
		135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
		173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
		5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
		207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
		28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
		44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
		172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
		79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
		97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
		191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
		239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
		184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
		150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
		24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
		156, 180
	};

	private const int hashMask = 255;

	private const double sqrt2 = 1.4142135623730951;

	private const double rsqrt2 = 0.7071067811865476;

	private const double squaresToTriangles = 0.2113248654051871;

	private const double trianglesToSquares = 0.36602540378443865;

	private const double simplexScale1D = 2.4074074074074074;

	private const double simplexScale2D = 32.99077398303956;

	private const double gradientScale2D = 4.0;

	private static double[] gradients1D = new double[2] { 1.0, -1.0 };

	private const int gradientsMask1D = 1;

	private static double[] gradients2Dx = new double[8] { 1.0, -1.0, 0.0, 0.0, 0.7071067811865476, -0.7071067811865476, 0.7071067811865476, -0.7071067811865476 };

	private static double[] gradients2Dy = new double[8] { 0.0, 0.0, 1.0, -1.0, 0.7071067811865476, 0.7071067811865476, -0.7071067811865476, -0.7071067811865476 };

	private const int gradientsMask2D = 7;

	public static double Simplex1D(double x)
	{
		double num = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8] * num4;
			num += num9 * num7;
		}
		int num10 = num3 + 1;
		double num11 = x - (double)num10;
		double num12 = 1.0 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[num10 & 0xFF] & 1;
			double num16 = gradients1D[num15] * num11;
			num += num16 * num14;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex1D(double x, out double dx)
	{
		double num = 0.0;
		dx = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8];
			double num10 = num9 * num4;
			double num11 = num10 * 6.0 * num6;
			dx += num9 * num7 - num11 * num4;
			num += num10 * num7;
		}
		int num12 = num3 + 1;
		double num13 = x - (double)num12;
		double num14 = 1.0 - num13 * num13;
		if (num14 > 0.0)
		{
			double num15 = num14 * num14;
			double num16 = num14 * num15;
			int num17 = hash[num12 & 0xFF] & 1;
			double num18 = gradients1D[num17];
			double num19 = num18 * num13;
			double num20 = num19 * 6.0 * num15;
			dx += num18 * num16 - num20 * num13;
			num += num19 * num16;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex2D(double x, double y)
	{
		double num = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			num += num18 * num14;
		}
		int num19 = num5 + 1;
		int num20 = num6 + 1;
		double num21 = (double)(num19 + num20) * 0.2113248654051871;
		double num22 = x - (double)num19 + num21;
		double num23 = y - (double)num20 + num21;
		double num24 = 0.5 - num22 * num22 - num23 * num23;
		if (num24 > 0.0)
		{
			double num25 = num24 * num24;
			double num26 = num24 * num25;
			int num27 = hash[(hash[num19 & 0xFF] + num20) & 0xFF] & 7;
			double num28 = gradients2Dx[num27];
			double num29 = gradients2Dy[num27];
			double num30 = num28 * num22 + num29 * num23;
			num += num30 * num26;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num31 = num5 + 1;
			int num32 = num6;
			double num33 = (double)(num31 + num32) * 0.2113248654051871;
			double num34 = x - (double)num31 + num33;
			double num35 = y - (double)num32 + num33;
			double num36 = 0.5 - num34 * num34 - num35 * num35;
			if (num36 > 0.0)
			{
				double num37 = num36 * num36;
				double num38 = num36 * num37;
				int num39 = hash[(hash[num31 & 0xFF] + num32) & 0xFF] & 7;
				double num40 = gradients2Dx[num39];
				double num41 = gradients2Dy[num39];
				double num42 = num40 * num34 + num41 * num35;
				num += num42 * num38;
			}
		}
		else
		{
			int num43 = num5;
			int num44 = num6 + 1;
			double num45 = (double)(num43 + num44) * 0.2113248654051871;
			double num46 = x - (double)num43 + num45;
			double num47 = y - (double)num44 + num45;
			double num48 = 0.5 - num46 * num46 - num47 * num47;
			if (num48 > 0.0)
			{
				double num49 = num48 * num48;
				double num50 = num48 * num49;
				int num51 = hash[(hash[num43 & 0xFF] + num44) & 0xFF] & 7;
				double num52 = gradients2Dx[num51];
				double num53 = gradients2Dy[num51];
				double num54 = num52 * num46 + num53 * num47;
				num += num54 * num50;
			}
		}
		return num * 32.99077398303956;
	}

	public static double Simplex2D(double x, double y, out double dx, out double dy)
	{
		double num = 0.0;
		dx = 0.0;
		dy = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			double num19 = num18 * 6.0 * num13;
			dx += num16 * num14 - num19 * num10;
			dy += num17 * num14 - num19 * num11;
			num += num18 * num14;
		}
		int num20 = num5 + 1;
		int num21 = num6 + 1;
		double num22 = (double)(num20 + num21) * 0.2113248654051871;
		double num23 = x - (double)num20 + num22;
		double num24 = y - (double)num21 + num22;
		double num25 = 0.5 - num23 * num23 - num24 * num24;
		if (num25 > 0.0)
		{
			double num26 = num25 * num25;
			double num27 = num25 * num26;
			int num28 = hash[(hash[num20 & 0xFF] + num21) & 0xFF] & 7;
			double num29 = gradients2Dx[num28];
			double num30 = gradients2Dy[num28];
			double num31 = num29 * num23 + num30 * num24;
			double num32 = num31 * 6.0 * num26;
			dx += num29 * num27 - num32 * num23;
			dy += num30 * num27 - num32 * num24;
			num += num31 * num27;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num33 = num5 + 1;
			int num34 = num6;
			double num35 = (double)(num33 + num34) * 0.2113248654051871;
			double num36 = x - (double)num33 + num35;
			double num37 = y - (double)num34 + num35;
			double num38 = 0.5 - num36 * num36 - num37 * num37;
			if (num38 > 0.0)
			{
				double num39 = num38 * num38;
				double num40 = num38 * num39;
				int num41 = hash[(hash[num33 & 0xFF] + num34) & 0xFF] & 7;
				double num42 = gradients2Dx[num41];
				double num43 = gradients2Dy[num41];
				double num44 = num42 * num36 + num43 * num37;
				double num45 = num44 * 6.0 * num39;
				dx += num42 * num40 - num45 * num36;
				dy += num43 * num40 - num45 * num37;
				num += num44 * num40;
			}
		}
		else
		{
			int num46 = num5;
			int num47 = num6 + 1;
			double num48 = (double)(num46 + num47) * 0.2113248654051871;
			double num49 = x - (double)num46 + num48;
			double num50 = y - (double)num47 + num48;
			double num51 = 0.5 - num49 * num49 - num50 * num50;
			if (num51 > 0.0)
			{
				double num52 = num51 * num51;
				double num53 = num51 * num52;
				int num54 = hash[(hash[num46 & 0xFF] + num47) & 0xFF] & 7;
				double num55 = gradients2Dx[num54];
				double num56 = gradients2Dy[num54];
				double num57 = num55 * num49 + num56 * num50;
				double num58 = num57 * 6.0 * num52;
				dx += num55 * num53 - num58 * num49;
				dy += num56 * num53 - num58 * num50;
				num += num57 * num53;
			}
		}
		dx *= 4.0;
		dy *= 4.0;
		return num * 32.99077398303956;
	}

	public static double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * num4;
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * Abs(x2);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * (1.0 - Abs(x2));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * (num4 * num4);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * num6 / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * Abs(x2) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (1.0 - Abs(x2)) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (num6 * num6) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * num6;
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * Abs(num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (1.0 - Abs(num6));
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (num6 * num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		double num8 = num2 * gain;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num9 = Simplex2D(x * num3 + num4, y * num3 + num5, out dx, out dy);
			double num10 = num9 * num9;
			double num11 = dx * num9;
			double num12 = dy * num9;
			num += num8 * num10;
			num4 += warp * num11;
			num5 += warp * num12;
			num6 += damp * num11;
			num7 += damp * num12;
			num3 *= lacunarity;
			num2 *= gain;
			num8 = num2 * (1.0 - damp_scale / (1.0 + (num6 * num6 + num7 * num7)));
		}
		return num * amplitude;
	}

	private static int Floor(double x)
	{
		if (!(x >= 0.0))
		{
			return (int)x - 1;
		}
		return (int)x;
	}

	private static double Abs(double x)
	{
		if (!(x >= 0.0))
		{
			return 0.0 - x;
		}
		return x;
	}

	private static double Saturate(double x)
	{
		if (!(x > 1.0))
		{
			if (!(x < 0.0))
			{
				return x;
			}
			return 0.0;
		}
		return 1.0;
	}
}


using System.Runtime.InteropServices;
using System.Security;

[SuppressUnmanagedCodeSecurity]
public static class NativeNoise
{
	[DllImport("RustNative", EntryPoint = "snoise1_32")]
	public static extern float Simplex1D(float x);

	[DllImport("RustNative", EntryPoint = "sdnoise1_32")]
	public static extern float Simplex1D(float x, out float dx);

	[DllImport("RustNative", EntryPoint = "snoise2_32")]
	public static extern float Simplex2D(float x, float y);

	[DllImport("RustNative", EntryPoint = "sdnoise2_32")]
	public static extern float Simplex2D(float x, float y, out float dx, out float dy);

	[DllImport("RustNative", EntryPoint = "turbulence_32")]
	public static extern float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_32")]
	public static extern float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_32")]
	public static extern float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_32")]
	public static extern float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_iq_32")]
	public static extern float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_iq_32")]
	public static extern float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_iq_32")]
	public static extern float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_iq_32")]
	public static extern float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_warp_32")]
	public static extern float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "billow_warp_32")]
	public static extern float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "ridge_warp_32")]
	public static extern float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "sharp_warp_32")]
	public static extern float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "jordan_32")]
	public static extern float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale);
}


public static class Noise
{
	public const float MIN = -1000000f;

	public const float MAX = 1000000f;

	public static float SimplexSigned(float x)
	{
		return NativeNoise.Simplex1D(x);
	}

	public static float SimplexSigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y);
	}

	public static float SimplexUnsigned(float x)
	{
		return NativeNoise.Simplex1D(x) * 0.5f + 1f;
	}

	public static float SimplexUnsigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y) * 0.5f + 1f;
	}

	public static float Turbulence(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Turbulence(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Billow(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Billow(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Ridge(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Ridge(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Sharp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Sharp(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.TurbulenceIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float BillowIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.BillowIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float RidgeIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.RidgeIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float SharpIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.SharpIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.TurbulenceWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float BillowWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.BillowWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float RidgeWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.RidgeWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float SharpWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.SharpWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float Jordan(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 1f, float damp = 1f, float damp_scale = 1f)
	{
		return NativeNoise.Jordan(x, y, octaves, frequency, amplitude, lacunarity, gain, warp, damp, damp_scale);
	}
}


using System;

[Serializable]
public struct NoiseParameters
{
	public int Octaves;

	public float Frequency;

	public float Amplitude;

	public float Offset;

	public NoiseParameters(int octaves, float frequency, float amplitude, float offset)
	{
		Octaves = octaves;
		Frequency = frequency;
		Amplitude = amplitude;
		Offset = offset;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PathList
{
	public enum Side
	{
		Both,
		Left,
		Right,
		Any
	}

	public enum Placement
	{
		Center,
		Side
	}

	public enum Alignment
	{
		None,
		Neighbor,
		Forward,
		Inward
	}

	[Serializable]
	public class BasicObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Placement Placement;

		public bool AlignToNormal = true;

		public bool HeightToTerrain = true;

		public float Offset;
	}

	[Serializable]
	public class SideObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Side Side;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 25f;

		public float Offset = 2f;
	}

	[Serializable]
	public class PathObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 5f;

		public float Dithering = 5f;
	}

	[Serializable]
	public class BridgeObject
	{
		public string Folder;

		public float Distance = 10f;
	}

	public class MeshObject
	{
		public Vector3 Position;

		public Mesh[] Meshes;

		public MeshObject(Vector3 meshPivot, MeshData[] meshData)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0031: Expected O, but got Unknown
			Position = meshPivot;
			Meshes = (Mesh[])(object)new Mesh[meshData.Length];
			for (int i = 0; i < Meshes.Length; i++)
			{
				MeshData obj = meshData[i];
				Mesh[] meshes = Meshes;
				int num = i;
				Mesh val = new Mesh();
				Mesh val2 = val;
				meshes[num] = val;
				Mesh val3 = val2;
				obj.Apply(val3);
				val3.RecalculateUVDistributionMetrics(1E-09f);
			}
		}
	}

	private struct WeldVertex : IEquatable<WeldVertex>
	{
		private const float EPSILON = 0.001f;

		private const float INV_EPSILON = 999.99994f;

		public float x;

		public float y;

		public float z;

		public float alwaysUnderwater;

		public float topSurface;

		public override bool Equals(object other)
		{
			if (other is WeldVertex)
			{
				return Equals((WeldVertex)other);
			}
			return false;
		}

		public bool Equals(WeldVertex other)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
			{
				return topSurface == other.topSurface;
			}
			return false;
		}

		public override int GetHashCode()
		{
			int value = Mathf.RoundToInt(x * 999.99994f);
			int value2 = Mathf.RoundToInt(y * 999.99994f);
			int value3 = Mathf.RoundToInt(z * 999.99994f);
			return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
		}
	}

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rot180 = Quaternion.Euler(0f, 180f, 0f);

	private static Quaternion rot270 = Quaternion.Euler(0f, 270f, 0f);

	public const float EndWidthScale = 3f;

	public const float EndScaleDistance = 100f;

	public const float LengthWidthScale = 8f;

	public const float LengthDepthScale = 3f;

	public const float LengthScaleDistance = 1000f;

	public string Name;

	public PathInterpolator Path;

	public bool Spline;

	public bool Start;

	public bool End;

	public float Width;

	public float InnerPadding;

	public float OuterPadding;

	public float InnerFade;

	public float OuterFade;

	public float RandomScale;

	public float MeshOffset;

	public float TerrainOffset;

	public int Topology;

	public int Splat;

	public int Hierarchy;

	public PathFinder.Node ProcgenStartNode;

	public PathFinder.Node ProcgenEndNode;

	public const float StepSize = 1f;

	private static float[] placements = new float[3] { 0f, -1f, 1f };

	public PathList(string name, Vector3[] points)
	{
		Name = name;
		Path = new PathInterpolator(points);
	}

	private void SpawnObjectsNeighborAligned(ref uint seed, Prefab[] prefabs, List<Vector3> positions, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Count < 2)
		{
			return;
		}
		List<Prefab> list = Pool.Get<List<Prefab>>();
		for (int i = 0; i < positions.Count; i++)
		{
			int index = Mathf.Max(i - 1, 0);
			int index2 = Mathf.Min(i + 1, positions.Count - 1);
			Vector3 position = positions[i];
			Quaternion rotation = Quaternion.LookRotation(Vector3Ex.XZ3D(positions[index2] - positions[index]));
			SpawnObject(ref seed, prefabs, position, rotation, list, out var spawned, positions.Count, i, filter);
			if (spawned != null)
			{
				list.Add(spawned);
			}
		}
		Pool.FreeUnmanaged<Prefab>(ref list);
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Prefab random = prefabs.GetRandom(ref seed);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = random.Object.transform.localScale;
		random.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!random.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, random, pos, rot, scale);
		return true;
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, List<Prefab> previousSpawns, out Prefab spawned, int pathLength, int index, SpawnFilter filter = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		spawned = null;
		Prefab replacement = prefabs.GetRandom(ref seed);
		replacement.ApplySequenceReplacement(previousSpawns, ref replacement, prefabs, pathLength, index, position);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = replacement.Object.transform.localScale;
		replacement.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!replacement.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, replacement, pos, rot, scale);
		spawned = replacement;
		return true;
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		foreach (Prefab obj in prefabs)
		{
			Vector3 pos = position;
			Vector3 localScale = obj.Object.transform.localScale;
			if (!obj.ApplyTerrainAnchors(ref pos, rotation, localScale, filter))
			{
				return false;
			}
		}
		return true;
	}

	private void SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (SpawnObject(ref seed, prefabs, val3, rotation, filter))
				{
					break;
				}
			}
		}
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (CheckObjects(prefabs, val3, rotation, filter))
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SpawnSide(ref uint seed, SideObject obj)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Side side = obj.Side;
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float num = Width * 0.5f + obj.Offset;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		float[] array2 = new float[2]
		{
			0f - num,
			num
		};
		int num2 = 0;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num3 = distance * 0.25f;
		float num4 = distance * 0.5f;
		float num5 = Path.StartOffset + num4;
		float num6 = Path.Length - Path.EndOffset - num4;
		for (float num7 = num5; num7 <= num6; num7 += num3)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num7) : Path.GetPoint(num7));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num7);
			Vector3 val4 = rot90 * tangent;
			for (int i = 0; i < array2.Length; i++)
			{
				int num8 = (num2 + i) % array2.Length;
				if ((side == Side.Left && num8 != 0) || (side == Side.Right && num8 != 1))
				{
					continue;
				}
				float num9 = array2[num8];
				Vector3 val5 = val2;
				val5.x += val4.x * num9;
				val5.z += val4.z * num9;
				float normX = TerrainMeta.NormalizeX(val5.x);
				float normZ = TerrainMeta.NormalizeZ(val5.z);
				if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
				{
					continue;
				}
				if (density >= SeedRandom.Value(ref seed))
				{
					val5.y = heightMap.GetHeight(normX, normZ);
					if (obj.Alignment == Alignment.None)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(Vector3.zero), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Forward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Inward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9) * rot270, filter))
						{
							continue;
						}
					}
					else
					{
						list.Add(val5);
					}
				}
				num2 = num8;
				val = val2;
				if (side == Side.Any)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnAlong(ref uint seed, PathObject obj)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float dithering = obj.Dithering;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num = distance * 0.25f;
		float num2 = distance * 0.5f;
		float num3 = Path.StartOffset + num2;
		float num4 = Path.Length - Path.EndOffset - num2;
		for (float num5 = num3; num5 <= num4; num5 += num)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num5) : Path.GetPoint(num5));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num5);
			Vector3 val4 = rot90 * tangent;
			Vector3 val5 = val2;
			val5.x += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			val5.z += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			float normX = TerrainMeta.NormalizeX(val5.x);
			float normZ = TerrainMeta.NormalizeZ(val5.z);
			if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
			{
				continue;
			}
			if (density >= SeedRandom.Value(ref seed))
			{
				val5.y = heightMap.GetHeight(normX, normZ);
				if (obj.Alignment == Alignment.None)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.identity, filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Forward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent), filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Inward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(val4), filter))
					{
						continue;
					}
				}
				else
				{
					list.Add(val5);
				}
			}
			val = val2;
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnBridge(ref uint seed, BridgeObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 val = Path.GetEndPoint() - startPoint;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = val / magnitude;
		float num = magnitude / obj.Distance;
		int num2 = Mathf.RoundToInt(num);
		float num3 = 0.5f * (num - (float)num2);
		Vector3 val3 = obj.Distance * val2;
		Vector3 val4 = startPoint + (0.5f + num3) * val3;
		Quaternion rotation = Quaternion.LookRotation(val2);
		for (int i = 0; i < num2; i++)
		{
			float num4 = WaterLevel.GetWaterOrTerrainSurface(val4, waves: false, volumes: false) - 1f;
			if (val4.y > num4)
			{
				SpawnObject(ref seed, array, val4, rotation);
			}
			val4 += val3;
		}
	}

	public void SpawnStart(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (Start && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 startPoint = Path.GetStartPoint();
			Vector3 startTangent = Path.GetStartTangent();
			SpawnObject(ref seed, array, startPoint, startTangent, obj);
		}
	}

	public void SpawnEnd(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (End && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 endPoint = Path.GetEndPoint();
			Vector3 dir = -Path.GetEndTangent();
			SpawnObject(ref seed, array, endPoint, dir, obj);
		}
	}

	public void TrimStart(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!Start || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MinIndex + i];
			Vector3 dir = tangents[Path.MinIndex + i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MinIndex += i;
				break;
			}
		}
	}

	public void TrimEnd(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!End || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MaxIndex - i];
			Vector3 dir = -tangents[Path.MaxIndex - i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MaxIndex -= i;
				break;
			}
		}
	}

	public void TrimTopology(int topology)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] points = Path.Points;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 worldPos = points[Path.MinIndex + i];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos, topology))
			{
				Path.MinIndex += i;
				break;
			}
		}
		for (int j = 0; j < num; j++)
		{
			Vector3 worldPos2 = points[Path.MaxIndex - j];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos2, topology))
			{
				Path.MaxIndex -= j;
				break;
			}
		}
	}

	public void ResetTrims()
	{
		Path.MinIndex = Path.DefaultMinIndex;
		Path.MaxIndex = Path.DefaultMaxIndex;
	}

	public void AdjustTerrainHeight(float intensity = 1f, float fade = 1f, bool scaleWidthWithLength = false)
	{
		AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => fade, scaleWidthWithLength);
	}

	public void AdjustTerrainHeight(Func<float, float, float> intensity, Func<float, float, float> fade, bool scaleWidthWithLength = false)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		_ = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float outerFade = OuterFade;
		float innerFade = InnerFade;
		float terrainOffset = TerrainOffset;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 val3 = startPoint;
		Line prev_line = new Line(startPoint, startPoint + startTangent * num);
		Vector3 val4 = startPoint - val2 * (num2 + outerPadding + outerFade);
		Vector3 val5 = startPoint + val2 * (num2 + outerPadding + outerFade);
		Vector3 val6 = val3;
		Vector3 val7 = startTangent;
		Line cur_line = prev_line;
		Vector3 val8 = val4;
		Vector3 val9 = val5;
		float num3 = Path.Length + num;
		for (float d = 0f; d < num3; d += num)
		{
			Vector3 val10 = (Spline ? Path.GetPointCubicHermite(d + num) : Path.GetPoint(d + num));
			Vector3 tangent = Path.GetTangent(d + num);
			Line next_line = new Line(val10, val10 + tangent * num);
			float opacity = 1f;
			float radius = GetRadius(d, Path.Length, num2, randomScale, scaleWidthWithLength);
			float depth = GetDepth(d, Path.Length, terrainOffset, randomScale, scaleWidthWithLength);
			float offset01 = depth * TerrainMeta.OneOverSize.y;
			if (!Path.Circular)
			{
				float num4 = Vector3Ex.Magnitude2D(startPoint - val6);
				float num5 = Vector3Ex.Magnitude2D(endPoint - val6);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num4, num5));
			}
			val = Vector3Ex.XZ3D(val7);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			val8 = val6 - val2 * (radius + outerPadding + outerFade);
			val9 = val6 + val2 * (radius + outerPadding + outerFade);
			float yn = TerrainMeta.NormalizeY((val6.y + val3.y) * 0.5f);
			heightmap.ForEach(val4, val5, val8, val9, delegate(int x, int z)
			{
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0031: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_0054: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_0079: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_0088: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_01af: Unknown result type (might be due to invalid IL or missing references)
				float num6 = heightmap.Coordinate(x);
				float num7 = heightmap.Coordinate(z);
				Vector3 val11 = TerrainMeta.Denormalize(new Vector3(num6, yn, num7));
				Vector3 val12 = ((Line)(ref prev_line)).ClosestPoint2D(val11);
				Vector3 val13 = ((Line)(ref cur_line)).ClosestPoint2D(val11);
				Vector3 val14 = ((Line)(ref next_line)).ClosestPoint2D(val11);
				float num8 = Vector3Ex.Magnitude2D(val11 - val12);
				float num9 = Vector3Ex.Magnitude2D(val11 - val13);
				float num10 = Vector3Ex.Magnitude2D(val11 - val14);
				float num11 = num9;
				Vector3 val15 = val13;
				if (!(num9 <= num8) || !(num9 <= num10))
				{
					if (num8 <= num10)
					{
						num11 = num8;
						val15 = val12;
					}
					else
					{
						num11 = num10;
						val15 = val14;
					}
				}
				float num12 = Mathf.InverseLerp(radius + outerPadding + outerFade * fade(num6, num7), radius + outerPadding, num11);
				float num13 = intensity(num6, num7) * opacity * num12;
				if (num13 > 0f)
				{
					float num14 = (scaleWidthWithLength ? Mathf.Lerp(0.3f, 1f, d / 1000f) : 1f);
					float num15 = Mathf.InverseLerp(radius - innerPadding * num14, radius - innerPadding * num14 - innerFade * num14, num11);
					float num16 = TerrainMeta.NormalizeY(val15.y);
					float num17 = Mathf.SmoothStep(0f, offset01, num15);
					heightmap.SetHeight(x, z, num16 + num17, num13);
				}
			});
			val3 = val6;
			val4 = val8;
			val5 = val9;
			prev_line = cur_line;
			val6 = val10;
			val7 = tangent;
			cur_line = next_line;
		}
	}

	public void AdjustTerrainTexture(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Splat == 0)
		{
			return;
		}
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			splatmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = splatmap.Coordinate(x);
				float num8 = splatmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				float num10 = Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9);
				splatmap.SetSplat(x, z, Splat, num10 * opacity);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainWaterFlow(bool scaleWidthWithLength = false)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		TerrainWaterFlowMap flowMap = TerrainMeta.WaterFlowMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 dir = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(dir);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			dir = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(dir);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			flowMap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				float normX = flowMap.Coordinate(x);
				float normZ = flowMap.Coordinate(z);
				flowMap.SetFlowDirection(normX, normZ, dir);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainTopology(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Topology == 0)
		{
			return;
		}
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			topomap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = topomap.Coordinate(x);
				float num8 = topomap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				if (Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9) * opacity > 0.3f)
				{
					topomap.AddTopology(x, z, Topology);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustPlacementMap(float width)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		TerrainPlacementMap placementmap = TerrainMeta.PlacementMap;
		float num = 1f;
		float radius = width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * radius;
		Vector3 v2 = startPoint + val2 * radius;
		float num2 = Path.Length + num;
		for (float num3 = 0f; num3 < num2; num3 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num3) : Path.GetPoint(num3));
			startTangent = Path.GetTangent(num3);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * radius;
			Vector3 val5 = val3 + val2 * radius;
			float yn = TerrainMeta.NormalizeY(val3.y);
			placementmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num4 = placementmap.Coordinate(x);
				float num5 = placementmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num4, yn, num5));
				Vector3 val7 = ray.ClosestPoint(val6);
				if (Vector3Ex.Magnitude2D(val6 - val7) <= radius)
				{
					placementmap.SetBlocked(x, z);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public List<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, bool scaleWidthWithLength = false, bool topAligned = false, int roundVertices = 0)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		MeshData[] array2 = new MeshData[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
			array2[i] = new MeshData();
		}
		MeshData[] array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].AllocMinimal();
		}
		Bounds bounds = meshes[^1].bounds;
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		List<MeshObject> list = new List<MeshObject>();
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		_ = array[0].vertices.Length;
		_ = array[0].triangles.Length;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val12 = default(Vector3);
		for (int k = 0; k < num2; k += num3)
		{
			float distance = (float)k * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int l = 0; l < num3 && k + l < num2; l++)
			{
				float num5 = (float)(k + l) * num4;
				for (int m = 0; m < meshes.Length; m++)
				{
					MeshCache.Data data = array[m];
					MeshData meshData = array2[m];
					int count = meshData.vertices.Count;
					for (int n = 0; n < data.vertices.Length; n++)
					{
						Vector2 item = data.uv[n];
						Vector3 val2 = data.vertices[n];
						Vector3 val3 = data.normals[n];
						Vector4 val4 = data.tangents[n];
						float num6 = (val2.x - min.x) / size.x;
						float num7 = val2.y - min.y;
						if (topAligned)
						{
							num7 -= size.y;
						}
						float num8 = (val2.z - min.z) / size.z;
						float num9 = num5 + num8 * num4;
						Vector3 val5 = (Spline ? Path.GetPointCubicHermite(num9) : Path.GetPoint(num9));
						Vector3 tangent = Path.GetTangent(num9);
						Vector3 val6 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val6)).normalized;
						Vector3 val7 = rot90 * normalized;
						Vector3 val8 = Vector3.Cross(tangent, val7);
						Quaternion val9 = Quaternion.LookRotation(normalized, val8);
						float radius = GetRadius(num9, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val10 = val5 - val7 * radius;
						Vector3 val11 = val5 + val7 * radius;
						if (snapToTerrain)
						{
							val10.y = heightMap.GetHeight(val10);
							val11.y = heightMap.GetHeight(val11);
						}
						val10 += val8 * meshOffset;
						val11 += val8 * meshOffset;
						val2 = Vector3.Lerp(val10, val11, num6);
						if ((snapStartToTerrain && num9 < 0.1f) || (snapEndToTerrain && num9 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num7;
						}
						val2 -= val;
						val3 = val9 * val3;
						((Vector3)(ref val12))..ctor(val4.x, val4.y, val4.z);
						val12 = val9 * val12;
						((Vector4)(ref val4)).Set(val12.x, val12.y, val12.z, val4.w);
						if (normalSmoothing > 0f)
						{
							val3 = Vector3.Slerp(val3, Vector3.up, normalSmoothing);
						}
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData.vertices.Add(val2);
						meshData.normals.Add(val3);
						meshData.tangents.Add(val4);
						meshData.uv.Add(item);
					}
					for (int num10 = 0; num10 < data.triangles.Length; num10++)
					{
						int num11 = data.triangles[num10];
						meshData.triangles.Add(count + num11);
					}
				}
			}
			list.Add(new MeshObject(val, array2));
			array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				array3[j].Clear();
			}
		}
		array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].Free();
		}
		return list;
	}

	public List<MeshObject> CreateMeshRiverInterior(Mesh[] meshes, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, Bounds bounds, bool scaleWidthWithLength = false, int roundVertices = 0)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0571: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
		}
		MeshData meshData = new MeshData();
		meshData.vertices = Pool.Get<List<Vector3>>();
		meshData.triangles = Pool.Get<List<int>>();
		meshData.uv = Pool.Get<List<Vector2>>();
		MeshData meshData2 = new MeshData();
		meshData2.vertices = Pool.Get<List<Vector3>>();
		meshData2.triangles = Pool.Get<List<int>>();
		meshData2.uv = Pool.Get<List<Vector2>>();
		Dictionary<WeldVertex, int> dictionary = new Dictionary<WeldVertex, int>();
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		List<MeshObject> list = new List<MeshObject>();
		for (int j = 0; j < num2; j += num3)
		{
			float distance = (float)j * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int k = 0; k < num3 && j + k < num2; k++)
			{
				float num5 = (float)(j + k) * num4;
				bool flag = j == 0;
				bool flag2 = k == 0;
				bool flag3 = j == num2 - 1;
				bool flag4 = k == num3 - 1 || j + k == num2 - 1;
				int num6 = (flag2 ? 4 : 3);
				for (int l = 0; l < num6; l++)
				{
					int num7 = l;
					MeshCache.Data data = array[num7];
					MeshData meshData3 = meshData;
					int count = meshData3.vertices.Count;
					float num8 = ((num7 == 2 && !(flag4 && flag3)) ? 1f : ((!(num7 == 3 && flag2) || flag) ? 0f : 1f));
					float num9 = ((num7 == 0) ? 1f : 0f);
					for (int m = 0; m < data.vertices.Length; m++)
					{
						Vector3 val2 = data.vertices[m];
						float num10 = (val2.x - min.x) / size.x;
						float num11 = val2.y - min.y;
						float num12 = (val2.z - min.z) / size.z;
						float num13 = num5 + num12 * num4;
						Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num13) : Path.GetPoint(num13));
						Vector3 tangent = Path.GetTangent(num13);
						Vector3 val4 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val4)).normalized;
						Vector3 val5 = rot90 * normalized;
						Vector3 val6 = Vector3.Cross(tangent, val5);
						float radius = GetRadius(num13, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val7 = val3 - val5 * radius;
						Vector3 val8 = val3 + val5 * radius;
						if (snapToTerrain)
						{
							val7.y = heightMap.GetHeight(val7);
							val8.y = heightMap.GetHeight(val8);
						}
						val7 += val6 * meshOffset;
						val8 += val6 * meshOffset;
						val2 = Vector3.Lerp(val7, val8, num10);
						if ((snapStartToTerrain && num13 < 0.1f) || (snapEndToTerrain && num13 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num11;
						}
						val2 -= val;
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData3.vertices.Add(val2);
						meshData3.uv.Add(new Vector2(num8, num9));
					}
					for (int n = 0; n < data.triangles.Length; n++)
					{
						int num14 = data.triangles[n];
						meshData3.triangles.Add(count + num14);
					}
				}
			}
			for (int num15 = 0; num15 < meshData.triangles.Count; num15++)
			{
				int index = meshData.triangles[num15];
				Vector3 val9 = meshData.vertices[index];
				Vector2 item = meshData.uv[index];
				WeldVertex key = default(WeldVertex);
				key.x = val9.x;
				key.y = val9.y;
				key.z = val9.z;
				key.alwaysUnderwater = meshData.uv[index].x;
				key.topSurface = meshData.uv[index].y;
				if (!dictionary.TryGetValue(key, out var value))
				{
					value = meshData2.vertices.Count;
					dictionary.Add(key, value);
					meshData2.vertices.Add(val9);
					meshData2.uv.Add(item);
				}
				meshData2.triangles.Add(value);
			}
			list.Add(new MeshObject(val, new MeshData[1] { meshData2 }));
			meshData.Clear();
			meshData2.Clear();
			dictionary.Clear();
		}
		meshData.Free();
		meshData2.Free();
		return list;
	}

	public static float GetRadius(float distance, float length, float baseRadius, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = Mathf.Sqrt(Mathf.Max(0f, length - distance) / 100f);
			float num2 = ((length > 0f) ? Mathf.Lerp(3f, 1f, num) : 1f);
			float num3 = distance / 1000f;
			float num4 = Mathf.Lerp(1f, 8f, num3);
			baseRadius = baseRadius * num4 * num2;
		}
		return Mathf.Lerp(baseRadius, baseRadius * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}

	public static float GetDepth(float distance, float length, float baseDepth, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = distance / 1000f;
			float num2 = Mathf.Lerp(1f, 3f, num);
			baseDepth *= num2;
		}
		return Mathf.Lerp(baseDepth, baseDepth * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}
}


public enum Side
{
	Both,
	Left,
	Right,
	Any
}


public enum Placement
{
	Center,
	Side
}


public enum Alignment
{
	None,
	Neighbor,
	Forward,
	Inward
}


using System;

[Serializable]
public class BasicObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Placement Placement;

	public bool AlignToNormal = true;

	public bool HeightToTerrain = true;

	public float Offset;
}


using System;

[Serializable]
public class SideObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Side Side;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 25f;

	public float Offset = 2f;
}


using System;

[Serializable]
public class PathObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 5f;

	public float Dithering = 5f;
}


using System;

[Serializable]
public class BridgeObject
{
	public string Folder;

	public float Distance = 10f;
}


using UnityEngine;

public class MeshObject
{
	public Vector3 Position;

	public Mesh[] Meshes;

	public MeshObject(Vector3 meshPivot, MeshData[] meshData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Expected O, but got Unknown
		//IL_0031: Expected O, but got Unknown
		Position = meshPivot;
		Meshes = (Mesh[])(object)new Mesh[meshData.Length];
		for (int i = 0; i < Meshes.Length; i++)
		{
			MeshData obj = meshData[i];
			Mesh[] meshes = Meshes;
			int num = i;
			Mesh val = new Mesh();
			Mesh val2 = val;
			meshes[num] = val;
			Mesh val3 = val2;
			obj.Apply(val3);
			val3.RecalculateUVDistributionMetrics(1E-09f);
		}
	}
}


using System;
using UnityEngine;

private struct WeldVertex : IEquatable<WeldVertex>
{
	private const float EPSILON = 0.001f;

	private const float INV_EPSILON = 999.99994f;

	public float x;

	public float y;

	public float z;

	public float alwaysUnderwater;

	public float topSurface;

	public override bool Equals(object other)
	{
		if (other is WeldVertex)
		{
			return Equals((WeldVertex)other);
		}
		return false;
	}

	public bool Equals(WeldVertex other)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
		{
			return topSurface == other.topSurface;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int value = Mathf.RoundToInt(x * 999.99994f);
		int value2 = Mathf.RoundToInt(y * 999.99994f);
		int value3 = Mathf.RoundToInt(z * 999.99994f);
		return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
	}
}


using System;
using UnityEngine;

[Serializable]
public class SpawnFilter
{
	[InspectorFlags]
	public Enum SplatType = (Enum)(-1);

	[InspectorFlags]
	public Enum BiomeType = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAny = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAll;

	[InspectorFlags]
	public Enum TopologyNot;

	public bool Test(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetFactor(worldPos) > 0.5f;
	}

	public bool Test(float normX, float normZ)
	{
		return GetFactor(normX, normZ) > 0.5f;
	}

	public float GetFactor(Vector3 worldPos, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFactor(normX, normZ, checkPlacementMap, checkTopologyRadius);
	}

	public float GetFactor(float normX, float normZ, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected I4, but got Unknown
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected I4, but got Unknown
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected I4, but got Unknown
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected I4, but got Unknown
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected I4, but got Unknown
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return 0f;
		}
		if (checkPlacementMap && (Object)(object)TerrainMeta.PlacementMap != (Object)null && TerrainMeta.PlacementMap.GetBlocked(normX, normZ))
		{
			return 0f;
		}
		int num = (int)SplatType;
		int num2 = (int)BiomeType;
		int num3 = (int)TopologyAny;
		int num4 = (int)TopologyAll;
		int num5 = (int)TopologyNot;
		if (num3 == 0)
		{
			Debug.LogError((object)"Empty topology filter is invalid.");
		}
		else if (num3 != -1 || num4 != 0 || num5 != 0)
		{
			int num6 = ((checkTopologyRadius > 0f) ? TerrainMeta.TopologyMap.GetTopology(normX, normZ, checkTopologyRadius) : TerrainMeta.TopologyMap.GetTopology(normX, normZ));
			if (num3 != -1 && (num6 & num3) == 0)
			{
				return 0f;
			}
			if (num5 != 0 && (num6 & num5) != 0)
			{
				return 0f;
			}
			if (num4 != 0 && (num6 & num4) != num4)
			{
				return 0f;
			}
		}
		switch (num2)
		{
		case 0:
			Debug.LogError((object)"Empty biome filter is invalid.");
			break;
		default:
			if ((TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ) & num2) == 0)
			{
				return 0f;
			}
			break;
		case -1:
			break;
		}
		switch (num)
		{
		case 0:
			Debug.LogError((object)"Empty splat filter is invalid.");
			break;
		default:
			return TerrainMeta.SplatMap.GetSplat(normX, normZ, num);
		case -1:
			break;
		}
		return 1f;
	}
}


public enum SpawnFilterMode
{
	PivotPoint = 1,
	TerrainAnchorPoints = 2,
	TerrainCheckPoints = 4
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Terrain Config")]
public class TerrainConfig : BaseScriptableObject
{
	[Serializable]
	public class SplatOverlay
	{
		public Color Color = new Color(1f, 1f, 1f, 0f);

		[Range(0f, 1f)]
		public float Smoothness;

		[Range(0f, 1f)]
		public float NormalIntensity = 1f;

		[Range(0f, 8f)]
		public float BlendFactor = 0.5f;

		[Range(0.01f, 32f)]
		public float BlendFalloff = 0.5f;
	}

	[Serializable]
	public class SplatType
	{
		public string Name = "";

		[FormerlySerializedAs("WarmColor")]
		public Color AridColor = Color.white;

		public SplatOverlay AridOverlay = new SplatOverlay();

		[FormerlySerializedAs("Color")]
		public Color TemperateColor = Color.white;

		public SplatOverlay TemperateOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color TundraColor = Color.white;

		public SplatOverlay TundraOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color ArcticColor = Color.white;

		public SplatOverlay ArcticOverlay = new SplatOverlay();

		public Color JungleColor = Color.white;

		public SplatOverlay JungleOverlay = new SplatOverlay();

		public PhysicMaterial Material;

		public float SplatTiling = 5f;

		[Range(0f, 1f)]
		public float UVMIXMult = 0.15f;

		public float UVMIXStart;

		public float UVMIXDist = 100f;
	}

	public enum GroundType
	{
		None,
		HardSurface,
		Grass,
		Sand,
		Snow,
		Dirt,
		Gravel
	}

	public bool CastShadows = true;

	public LayerMask GroundMask = LayerMask.op_Implicit(0);

	public LayerMask WaterMask = LayerMask.op_Implicit(0);

	public PhysicMaterial GenericMaterial;

	public PhysicMaterial WaterMaterial;

	public Material Material;

	public Material MarginMaterial;

	public Texture[] AlbedoArrays = (Texture[])(object)new Texture[3];

	public Texture[] NormalArrays = (Texture[])(object)new Texture[3];

	public float HeightMapErrorMin = 5f;

	public float HeightMapErrorMax = 100f;

	public float BaseMapDistanceMin = 100f;

	public float BaseMapDistanceMax = 500f;

	public float ShaderLodMin = 100f;

	public float ShaderLodMax = 600f;

	public SplatType[] Splats = new SplatType[8];

	private string snowMatName;

	private string grassMatName;

	private string sandMatName;

	private List<string> dirtMatNames;

	private List<string> stoneyMatNames;

	private int snowMatID;

	private int grassMatID;

	private int sandMatID;

	private List<int> dirtMatIds;

	private List<int> stoneyMatIds;

	public Texture AlbedoArray => AlbedoArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public Texture NormalArray => NormalArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public PhysicMaterial[] GetPhysicMaterials()
	{
		PhysicMaterial[] array = (PhysicMaterial[])(object)new PhysicMaterial[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].Material;
		}
		return array;
	}

	public Color[] GetAridColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].AridColor;
		}
		return array;
	}

	public void GetAridOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay aridOverlay = Splats[i].AridOverlay;
			color[i] = ((Color)(ref aridOverlay.Color)).linear;
			param[i] = new Vector4(aridOverlay.Smoothness, aridOverlay.NormalIntensity, aridOverlay.BlendFactor, aridOverlay.BlendFalloff);
		}
	}

	public Color[] GetTemperateColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TemperateColor;
		}
		return array;
	}

	public void GetTemperateOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay temperateOverlay = Splats[i].TemperateOverlay;
			color[i] = ((Color)(ref temperateOverlay.Color)).linear;
			param[i] = new Vector4(temperateOverlay.Smoothness, temperateOverlay.NormalIntensity, temperateOverlay.BlendFactor, temperateOverlay.BlendFalloff);
		}
	}

	public Color[] GetTundraColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TundraColor;
		}
		return array;
	}

	public void GetTundraOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay tundraOverlay = Splats[i].TundraOverlay;
			color[i] = ((Color)(ref tundraOverlay.Color)).linear;
			param[i] = new Vector4(tundraOverlay.Smoothness, tundraOverlay.NormalIntensity, tundraOverlay.BlendFactor, tundraOverlay.BlendFalloff);
		}
	}

	public Color[] GetArcticColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].ArcticColor;
		}
		return array;
	}

	public void GetArcticOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay arcticOverlay = Splats[i].ArcticOverlay;
			color[i] = ((Color)(ref arcticOverlay.Color)).linear;
			param[i] = new Vector4(arcticOverlay.Smoothness, arcticOverlay.NormalIntensity, arcticOverlay.BlendFactor, arcticOverlay.BlendFalloff);
		}
	}

	public Color[] GetJungleColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].JungleColor;
		}
		return array;
	}

	public void GetJungleOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay jungleOverlay = Splats[i].JungleOverlay;
			color[i] = ((Color)(ref jungleOverlay.Color)).linear;
			param[i] = new Vector4(jungleOverlay.Smoothness, jungleOverlay.NormalIntensity, jungleOverlay.BlendFactor, jungleOverlay.BlendFalloff);
		}
	}

	public float[] GetSplatTiling()
	{
		float[] array = new float[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].SplatTiling;
		}
		return array;
	}

	public float GetMaxSplatTiling()
	{
		float num = float.MinValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling > num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public float GetMinSplatTiling()
	{
		float num = float.MaxValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling < num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public Vector3[] GetPackedUVMIX()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = new Vector3(Splats[i].UVMIXMult, Splats[i].UVMIXStart, Splats[i].UVMIXDist);
		}
		return array;
	}

	[Obsolete("Use GetCurrentGroundTypeNoAlloc instead")]
	public GroundType GetCurrentGroundType(bool isGrounded, RaycastHit hit)
	{
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundType", 0);
		try
		{
			if (string.IsNullOrEmpty(grassMatName))
			{
				dirtMatNames = new List<string>();
				stoneyMatNames = new List<string>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					string text = obj.Name.ToLower();
					string name = ((Object)obj.Material).name;
					switch (text)
					{
					case "grass":
						grassMatName = name;
						break;
					case "snow":
						snowMatName = name;
						break;
					case "sand":
						sandMatName = name;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatNames.Add(name);
						break;
					case "stones":
					case "gravel":
						stoneyMatNames.Add(name);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			string name2 = ((Object)materialAt).name;
			if (name2 == grassMatName)
			{
				return GroundType.Grass;
			}
			if (name2 == sandMatName)
			{
				return GroundType.Sand;
			}
			if (name2 == snowMatName)
			{
				return GroundType.Snow;
			}
			for (int j = 0; j < dirtMatNames.Count; j++)
			{
				if (dirtMatNames[j] == name2)
				{
					return GroundType.Dirt;
				}
			}
			for (int k = 0; k < stoneyMatNames.Count; k++)
			{
				if (stoneyMatNames[k] == name2)
				{
					return GroundType.Gravel;
				}
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public GroundType GetCurrentGroundTypeNoAlloc(bool isGrounded, RaycastHit hit)
	{
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundTypeNoAlloc", 0);
		try
		{
			if (grassMatID == 0)
			{
				dirtMatIds = new List<int>();
				stoneyMatIds = new List<int>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					int instanceID = ((Object)obj.Material).GetInstanceID();
					switch (obj.Name.ToLower())
					{
					case "grass":
						grassMatID = instanceID;
						break;
					case "snow":
						snowMatID = instanceID;
						break;
					case "sand":
						sandMatID = instanceID;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatIds.Add(instanceID);
						break;
					case "stones":
					case "gravel":
						stoneyMatIds.Add(instanceID);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			int instanceID2 = ((Object)materialAt).GetInstanceID();
			if (instanceID2 == grassMatID)
			{
				return GroundType.Grass;
			}
			if (instanceID2 == sandMatID)
			{
				return GroundType.Sand;
			}
			if (instanceID2 == snowMatID)
			{
				return GroundType.Snow;
			}
			if (dirtMatIds.Contains(instanceID2))
			{
				return GroundType.Dirt;
			}
			if (stoneyMatIds.Contains(instanceID2))
			{
				return GroundType.Gravel;
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SplatOverlay
{
	public Color Color = new Color(1f, 1f, 1f, 0f);

	[Range(0f, 1f)]
	public float Smoothness;

	[Range(0f, 1f)]
	public float NormalIntensity = 1f;

	[Range(0f, 8f)]
	public float BlendFactor = 0.5f;

	[Range(0.01f, 32f)]
	public float BlendFalloff = 0.5f;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class SplatType
{
	public string Name = "";

	[FormerlySerializedAs("WarmColor")]
	public Color AridColor = Color.white;

	public SplatOverlay AridOverlay = new SplatOverlay();

	[FormerlySerializedAs("Color")]
	public Color TemperateColor = Color.white;

	public SplatOverlay TemperateOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color TundraColor = Color.white;

	public SplatOverlay TundraOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color ArcticColor = Color.white;

	public SplatOverlay ArcticOverlay = new SplatOverlay();

	public Color JungleColor = Color.white;

	public SplatOverlay JungleOverlay = new SplatOverlay();

	public PhysicMaterial Material;

	public float SplatTiling = 5f;

	[Range(0f, 1f)]
	public float UVMIXMult = 0.15f;

	public float UVMIXStart;

	public float UVMIXDist = 100f;
}


public enum GroundType
{
	None,
	HardSurface,
	Grass,
	Sand,
	Snow,
	Dirt,
	Gravel
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.AI;

public class AsyncTerrainNavMeshBake : CustomYieldInstruction
{
	private List<int> indices;

	private List<Vector3> vertices;

	private List<Vector3> normals;

	private List<int> triangles;

	private Vector3 pivot;

	private int width;

	private int height;

	private bool normal;

	private bool alpha;

	private Action worker;

	public override bool keepWaiting => worker != null;

	public bool isDone => worker == null;

	public Mesh mesh
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Mesh val = new Mesh();
			if (vertices != null)
			{
				val.SetVertices(vertices);
				Pool.FreeUnmanaged<Vector3>(ref vertices);
			}
			if (normals != null)
			{
				val.SetNormals(normals);
				Pool.FreeUnmanaged<Vector3>(ref normals);
			}
			if (triangles != null)
			{
				val.SetTriangles(triangles, 0);
				Pool.FreeUnmanaged<int>(ref triangles);
			}
			if (indices != null)
			{
				Pool.FreeUnmanaged<int>(ref indices);
			}
			return val;
		}
	}

	public NavMeshBuildSource CreateNavMeshBuildSource()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = default(NavMeshBuildSource);
		((NavMeshBuildSource)(ref result)).transform = Matrix4x4.TRS(pivot, Quaternion.identity, Vector3.one);
		((NavMeshBuildSource)(ref result)).shape = (NavMeshBuildSourceShape)0;
		((NavMeshBuildSource)(ref result)).sourceObject = (Object)(object)mesh;
		return result;
	}

	public NavMeshBuildSource CreateNavMeshBuildSource(int area)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = CreateNavMeshBuildSource();
		((NavMeshBuildSource)(ref result)).area = area;
		return result;
	}

	public AsyncTerrainNavMeshBake(Vector3 pivot, int width, int height, bool normal, bool alpha)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		this.pivot = pivot;
		this.width = width;
		this.height = height;
		this.normal = normal;
		this.alpha = alpha;
		indices = Pool.Get<List<int>>();
		vertices = Pool.Get<List<Vector3>>();
		normals = (normal ? Pool.Get<List<Vector3>>() : null);
		triangles = Pool.Get<List<int>>();
		Invoke();
	}

	private void DoWork()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)(width / 2), 0f, (float)(height / 2));
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(pivot.x - val.x, 0f, pivot.z - val.z);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainAlphaMap alphaMap = TerrainMeta.AlphaMap;
		int num = 0;
		for (int i = 0; i <= height; i++)
		{
			int num2 = 0;
			while (num2 <= width)
			{
				Vector3 worldPos = new Vector3((float)num2, 0f, (float)i) + val2;
				Vector3 item = new Vector3((float)num2, 0f, (float)i) - val;
				float num3 = heightMap.GetHeight(worldPos);
				if (num3 < -1f)
				{
					indices.Add(-1);
				}
				else if (alpha && alphaMap.GetAlpha(worldPos) < 0.1f)
				{
					indices.Add(-1);
				}
				else
				{
					if (normal)
					{
						Vector3 item2 = heightMap.GetNormal(worldPos);
						normals.Add(item2);
					}
					worldPos.y = (item.y = num3 - pivot.y);
					indices.Add(vertices.Count);
					vertices.Add(item);
				}
				num2++;
				num++;
			}
		}
		int num4 = 0;
		int num5 = 0;
		while (num5 < height)
		{
			int num6 = 0;
			while (num6 < width)
			{
				int num7 = indices[num4];
				int num8 = indices[num4 + width + 1];
				int num9 = indices[num4 + 1];
				int num10 = indices[num4 + 1];
				int num11 = indices[num4 + width + 1];
				int num12 = indices[num4 + width + 2];
				if (num7 != -1 && num8 != -1 && num9 != -1)
				{
					triangles.Add(num7);
					triangles.Add(num8);
					triangles.Add(num9);
				}
				if (num10 != -1 && num11 != -1 && num12 != -1)
				{
					triangles.Add(num10);
					triangles.Add(num11);
					triangles.Add(num12);
				}
				num6++;
				num4++;
			}
			num5++;
			num4++;
		}
	}

	private void Invoke()
	{
		worker = DoWork;
		worker.BeginInvoke(Callback, null);
	}

	private void Callback(IAsyncResult result)
	{
		worker.EndInvoke(result);
		worker = null;
	}
}


using UnityEngine;

public struct TextureData
{
	public int width;

	public int height;

	public Color32[] colors;

	public TextureData(Texture2D tex)
	{
		if ((Object)(object)tex != (Object)null)
		{
			width = ((Texture)tex).width;
			height = ((Texture)tex).height;
			colors = tex.GetPixels32();
		}
		else
		{
			width = 0;
			height = 0;
			colors = null;
		}
	}

	public Color32 GetColor(int x, int y)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return colors[y * width + x];
	}

	public int GetShort(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeShort(GetColor(x, y));
	}

	public int GetInt(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeInt(GetColor(x, y));
	}

	public float GetFloat(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeFloat(GetColor(x, y));
	}

	public float GetHalf(int x, int y)
	{
		return BitUtility.Short2Float(GetShort(x, y));
	}

	public Vector4 GetVector(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeVector(GetColor(x, y));
	}

	public Vector3 GetNormal(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeNormal(Color32.op_Implicit(GetColor(x, y)));
	}

	public Color32 GetInterpolatedColor(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Color val = Color32.op_Implicit(GetColor(num3, num4));
		Color val2 = Color32.op_Implicit(GetColor(x2, num4));
		Color val3 = Color32.op_Implicit(GetColor(num3, y2));
		Color val4 = Color32.op_Implicit(GetColor(x2, y2));
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Color val5 = Color.Lerp(val, val2, num5);
		Color val6 = Color.Lerp(val3, val4, num5);
		return Color32.op_Implicit(Color.Lerp(val5, val6, num6));
	}

	public int GetInterpolatedInt(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetInt(x2, y2);
	}

	public int GetInterpolatedShort(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetShort(x2, y2);
	}

	public float GetInterpolatedFloat(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float @float = GetFloat(num3, num4);
		float float2 = GetFloat(x2, num4);
		float float3 = GetFloat(num3, y2);
		float float4 = GetFloat(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(@float, float2, num5);
		float num8 = Mathf.Lerp(float3, float4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public float GetInterpolatedHalf(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float half = GetHalf(num3, num4);
		float half2 = GetHalf(x2, num4);
		float half3 = GetHalf(num3, y2);
		float half4 = GetHalf(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(half, half2, num5);
		float num8 = Mathf.Lerp(half3, half4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public Vector4 GetInterpolatedVector(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector4 vector = GetVector(num3, num4);
		Vector4 vector2 = GetVector(x2, num4);
		Vector4 vector3 = GetVector(num3, y2);
		Vector4 vector4 = GetVector(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector4 val = Vector4.Lerp(vector, vector2, num5);
		Vector4 val2 = Vector4.Lerp(vector3, vector4, num5);
		return Vector4.Lerp(val, val2, num6);
	}

	public Vector3 GetInterpolatedNormal(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector3 normal = GetNormal(num3, num4);
		Vector3 normal2 = GetNormal(x2, num4);
		Vector3 normal3 = GetNormal(num3, y2);
		Vector3 normal4 = GetNormal(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector3 val = Vector3.Lerp(normal, normal2, num5);
		Vector3 val2 = Vector3.Lerp(normal3, normal4, num5);
		return Vector3.Lerp(val, val2, num6);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using ConVar;
using Development.Attributes;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

[ResetStaticFields]
public static class World
{
	public struct SpawnTiming
	{
		public string category;

		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public TimeSpan time;
	}

	private static uint _size;

	public static readonly Dictionary<string, HashSet<GameObject>> SpawnedPrefabs = new Dictionary<string, HashSet<GameObject>>(StringComparer.OrdinalIgnoreCase);

	private static Stopwatch spawnTimer = new Stopwatch();

	private static List<SpawnTiming> spawnTimings = new List<SpawnTiming>();

	public static uint Seed { get; set; }

	public static uint Salt { get; set; }

	public static uint Size
	{
		get
		{
			return _size;
		}
		set
		{
			_size = value;
		}
	}

	public static string Checksum { get; set; }

	public static long Timestamp { get; set; }

	public static string Url { get; set; }

	public static bool Procedural { get; set; }

	public static bool Cached { get; set; }

	public static bool Networked { get; set; }

	public static bool Receiving { get; set; }

	public static bool Transfer { get; set; }

	public static bool Nexus => NexusServer.Started;

	public static bool LoadedFromSave { get; set; }

	public static int SpawnIndex { get; set; }

	public static WorldSerialization Serialization { get; set; }

	public static WorldConfig Config { get; set; }

	public static string Name
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalName;
			}
			if (CanLoadFromUrl())
			{
				return Path.GetFileNameWithoutExtension(WWW.UnEscapeURL(Url));
			}
			return Application.loadedLevelName;
		}
	}

	public static string MapFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalMapFileName;
			}
			if (CanLoadFromUrl())
			{
				return $"{Name}_{MurmurHashEx.MurmurHashUnsigned(Url)}.map";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 281 + ".map";
		}
	}

	public static string MapFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	public static string SaveFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalSaveFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + "." + 281 + ".sav";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 281 + ".sav";
		}
	}

	public static string SaveFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static string GetServerBrowserMapName()
	{
		if (MapUploader.IsUploaded)
		{
			return Name;
		}
		if (!CanLoadFromUrl())
		{
			return Name;
		}
		if (Name.StartsWith("proceduralmap."))
		{
			return "Procedural Map";
		}
		return "Custom Map";
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromUrl()
	{
		return !string.IsNullOrEmpty(Url);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromDisk()
	{
		return File.Exists(MapFolderName + "/" + MapFileName);
	}

	public static void CleanupOldFiles()
	{
		if (!Directory.Exists(MapFolderName))
		{
			return;
		}
		Regex regex1 = new Regex("proceduralmap\\.[0-9]+\\.[0-9]+\\.[0-9]+(_occlusion)*\\.(map|dat)");
		Regex regex2 = new Regex("\\.[0-9]+\\.[0-9]+\\." + 281 + "+(_occlusion)*\\.(map|dat)");
		foreach (string item in new string[2] { "*.map", "*.dat" }.SelectMany((string ext) => from path in Directory.GetFiles(MapFolderName, ext)
			where regex1.IsMatch(path) && !regex2.IsMatch(path)
			select path))
		{
			try
			{
				File.Delete(item);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex.Message);
			}
		}
	}

	public static void InitSeed(int seed)
	{
		InitSeed((uint)seed);
	}

	public static void InitSeed(uint seed)
	{
		if (seed == 0)
		{
			seed = MurmurHashEx.MurmurHashUnsigned(SeedIdentifier()) % int.MaxValue;
		}
		if (seed == 0)
		{
			seed = 123456u;
		}
		Seed = seed;
		Server.seed = (int)seed;
	}

	private static string SeedIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_" + 281 + "_" + Server.identity;
	}

	public static void InitSalt(int salt)
	{
		InitSalt((uint)salt);
	}

	public static void InitSalt(uint salt)
	{
		if (salt == 0)
		{
			salt = MurmurHashEx.MurmurHashUnsigned(SaltIdentifier()) % int.MaxValue;
		}
		if (salt == 0)
		{
			salt = 654321u;
		}
		Salt = salt;
		Server.salt = (int)salt;
	}

	private static string SaltIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_salt";
	}

	public static void InitSize(int size)
	{
		InitSize((uint)size);
	}

	public static void InitSize(uint size)
	{
		if (size == 0)
		{
			size = 4500u;
		}
		if (size < 1000)
		{
			size = 1000u;
		}
		if (size > 6000)
		{
			size = 6000u;
		}
		Size = size;
		Server.worldsize = (int)size;
	}

	public static byte[] GetMap(string name)
	{
		return Serialization.GetMap(name)?.data;
	}

	public static int GetCachedHeightMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("height").Length / 2)));
	}

	public static int GetCachedSplatMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("splat").Length / 8)));
	}

	public static void AddMap(string name, byte[] data)
	{
		Serialization.AddMap(name, data);
	}

	public static void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Serialization.AddPrefab(category, prefab.ID, position, rotation, scale);
		if (!Cached)
		{
			rotation = Quaternion.Euler(((Quaternion)(ref rotation)).eulerAngles);
			SpawnPrefab(category, prefab, position, rotation, scale);
		}
	}

	public static PathData PathListToPathData(PathList src)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Expected O, but got Unknown
		return new PathData
		{
			name = src.Name,
			spline = src.Spline,
			start = src.Start,
			end = src.End,
			width = src.Width,
			innerPadding = src.InnerPadding,
			outerPadding = src.OuterPadding,
			innerFade = src.InnerFade,
			outerFade = src.OuterFade,
			randomScale = src.RandomScale,
			meshOffset = src.MeshOffset,
			terrainOffset = src.TerrainOffset,
			splat = src.Splat,
			topology = src.Topology,
			hierarchy = src.Hierarchy,
			nodes = VectorArrayToList(src.Path.Points)
		};
	}

	public static PathList PathDataToPathList(PathData src)
	{
		PathList pathList = new PathList(src.name, VectorListToArray(src.nodes));
		pathList.Spline = src.spline;
		pathList.Start = src.start;
		pathList.End = src.end;
		pathList.Width = src.width;
		pathList.InnerPadding = src.innerPadding;
		pathList.OuterPadding = src.outerPadding;
		pathList.InnerFade = src.innerFade;
		pathList.OuterFade = src.outerFade;
		pathList.RandomScale = src.randomScale;
		pathList.MeshOffset = src.meshOffset;
		pathList.TerrainOffset = src.terrainOffset;
		pathList.Splat = src.splat;
		pathList.Topology = src.topology;
		pathList.Hierarchy = src.hierarchy;
		pathList.Path.RecalculateTangents();
		return pathList;
	}

	public static Vector3[] VectorListToArray(List<VectorData> src)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[src.Count];
		for (int i = 0; i < array.Length; i++)
		{
			VectorData val = src[i];
			Vector3 val2 = default(Vector3);
			val2.x = val.x;
			val2.y = val.y;
			val2.z = val.z;
			array[i] = val2;
		}
		return array;
	}

	public static List<VectorData> VectorArrayToList(Vector3[] src)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		List<VectorData> list = new List<VectorData>(src.Length);
		foreach (Vector3 val in src)
		{
			VectorData item = default(VectorData);
			item.x = val.x;
			item.y = val.y;
			item.z = val.z;
			list.Add(item);
		}
		return list;
	}

	public static IEnumerable<PathList> GetPaths(string name)
	{
		return from p in Serialization.GetPaths(name)
			select PathDataToPathList(p);
	}

	public static void AddPaths(IEnumerable<PathList> paths)
	{
		foreach (PathList path in paths)
		{
			AddPath(path);
		}
	}

	public static void AddPath(PathList path)
	{
		Serialization.AddPath(PathListToPathData(path));
	}

	public static IEnumerator Spawn(float deltaTime, Action<string> statusFunction = null, CancellationToken ct = default(CancellationToken))
	{
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (assetBundleBackend != null)
		{
			HashSet<string> hashSet = Serialization.world.prefabs.Select((PrefabData p) => StringPool.Get(p.id)).ToHashSet<string>(StringComparer.OrdinalIgnoreCase);
			List<string> requiredAssetScenes = assetBundleBackend.GetRequiredAssetScenesForPrefabs((IEnumerable<string>)hashSet);
			IEnumerator loading = assetBundleBackend.LoadAssetScenes(requiredAssetScenes);
			bool wantsCancel = false;
			float lastProgress = 0f;
			while (loading.MoveNext())
			{
				if (!wantsCancel && ct.IsCancellationRequested)
				{
					wantsCancel = true;
					Debug.LogWarning((object)"Cancel was requested but must wait for asset scenes to finish loading");
				}
				float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress(requiredAssetScenes);
				if (!Mathf.Approximately(assetSceneProgress, lastProgress))
				{
					lastProgress = assetSceneProgress;
					Status(statusFunction, $"Loading World Prefabs {assetSceneProgress * 100f:0.0}%");
				}
				yield return loading.Current;
			}
		}
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			if (ct.IsCancellationRequested)
			{
				break;
			}
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == Serialization.world.prefabs.Count - 1)
			{
				Status(statusFunction, "Spawning World ({0}/{1})", i + 1, Serialization.world.prefabs.Count);
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn(Bounds? prefabBounds)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (prefabBounds.HasValue)
			{
				Bounds value = prefabBounds.Value;
				if (!((Bounds)(ref value)).Contains(VectorData.op_Implicit(val.position)))
				{
					continue;
				}
			}
			SpawnPrefabData(val);
		}
	}

	public static void Spawn(string category, string folder = null)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (string.IsNullOrEmpty(folder) || text.StartsWith(folder))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	public static void Spawn(string category, string[] folders)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (folders == null || StringEx.StartsWithAny(text, folders))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	private static void SpawnPrefabData(PrefabData prefab)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		StringPool.Get(prefab.id);
		uint id = prefab.id;
		SpawnPrefab(prefab.category, Prefab.Load(id), VectorData.op_Implicit(prefab.position), VectorData.op_Implicit(prefab.rotation), VectorData.op_Implicit(prefab.scale));
	}

	private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (prefab != null && Object.op_Implicit((Object)(object)prefab.Object))
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject val = prefab.Spawn(position, rotation, scale);
			TrackSpawnedPrefab(category, val);
			Interface.CallHook("OnWorldPrefabSpawned", (object)val, (object)category);
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

	public static void TrackSpawnedPrefab(string category, GameObject instance)
	{
		if (!string.IsNullOrEmpty(category) && !((Object)(object)instance == (Object)null))
		{
			if (!SpawnedPrefabs.TryGetValue(category, out var value))
			{
				value = new HashSet<GameObject>();
				SpawnedPrefabs[category] = value;
			}
			value.Add(instance);
		}
	}

	private static void Status(Action<string> statusFunction, string status, object obj1)
	{
		statusFunction?.Invoke(string.Format(status, obj1));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2, object obj3)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2, obj3));
	}

	private static void Status(Action<string> statusFunction, string status, params object[] objs)
	{
		statusFunction?.Invoke(string.Format(status, objs));
	}

	public static IEnumerable<SpawnTiming> GetSpawnTimings()
	{
		return spawnTimings;
	}

	public static void ResetTiming()
	{
		spawnTimings.Clear();
	}
}


using System;
using UnityEngine;

public struct SpawnTiming
{
	public string category;

	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public TimeSpan time;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using UnityEngine;

[JsonModel]
public class WorldConfig
{
	public string JsonString = string.Empty;

	public float PercentageTier0 = 0.3f;

	public float PercentageTier1 = 0.3f;

	public float PercentageTier2 = 0.4f;

	public float PercentageBiomeArid = 0.4f;

	public float PercentageBiomeTemperate = 0.15f;

	public float PercentageBiomeTundra = 0.15f;

	public float PercentageBiomeArctic = 0.3f;

	public float PercentageBiomeJungle = 0.5f;

	public bool MainRoads = true;

	public bool SideRoads = true;

	public bool Trails = true;

	public bool Rivers = true;

	public bool Powerlines = true;

	public bool AboveGroundRails = true;

	public bool BelowGroundRails = true;

	public bool UnderwaterLabs = true;

	public List<string> PrefabBlacklist = new List<string>();

	public List<string> PrefabWhitelist = new List<string>();

	public bool IsPrefabAllowed(string name)
	{
		if (PrefabBlacklist.Count > 0)
		{
			foreach (string item in PrefabBlacklist)
			{
				if (name.Contains(item))
				{
					return false;
				}
			}
		}
		if (PrefabWhitelist.Count > 0)
		{
			foreach (string item2 in PrefabWhitelist)
			{
				if (name.Contains(item2))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void LoadFromJsonFile(string fileName)
	{
		try
		{
			LoadFromJsonString(File.ReadAllText(fileName));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromJsonString(string data)
	{
		try
		{
			LoadFromWorldConfig(JsonConvert.DeserializeObject<WorldConfig>(JsonString = data));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromWorldConfig(WorldConfig data)
	{
		float num = data.PercentageTier0 + data.PercentageTier1 + data.PercentageTier2;
		if (num > 0f)
		{
			PercentageTier0 = data.PercentageTier0 / num;
			PercentageTier1 = data.PercentageTier1 / num;
			PercentageTier2 = data.PercentageTier2 / num;
		}
		else
		{
			PercentageTier0 = 0f;
			PercentageTier1 = 1f;
			PercentageTier2 = 0f;
		}
		float num2 = data.PercentageBiomeArid + data.PercentageBiomeTemperate + data.PercentageBiomeTundra + data.PercentageBiomeArctic;
		if (num2 > 0f)
		{
			PercentageBiomeArid = data.PercentageBiomeArid / num2;
			PercentageBiomeTemperate = data.PercentageBiomeTemperate / num2;
			PercentageBiomeTundra = data.PercentageBiomeTundra / num2;
			PercentageBiomeArctic = data.PercentageBiomeArctic / num2;
		}
		else
		{
			PercentageBiomeArid = 0f;
			PercentageBiomeTemperate = 1f;
			PercentageBiomeTundra = 0f;
			PercentageBiomeArctic = 0f;
		}
		MainRoads = data.MainRoads;
		SideRoads = data.SideRoads;
		Trails = data.Trails;
		Rivers = data.Rivers;
		Powerlines = data.Powerlines;
		AboveGroundRails = data.AboveGroundRails;
		BelowGroundRails = data.BelowGroundRails;
		UnderwaterLabs = data.UnderwaterLabs;
		PrefabBlacklist.Clear();
		if (data.PrefabBlacklist != null && data.PrefabBlacklist.Count > 0)
		{
			PrefabBlacklist.AddRange(data.PrefabBlacklist);
		}
		PrefabWhitelist.Clear();
		if (data.PrefabWhitelist != null && data.PrefabWhitelist.Count > 0)
		{
			PrefabWhitelist.AddRange(data.PrefabWhitelist);
		}
	}

	public void LoadScriptableConfigs()
	{
		ScriptableWorldConfig[] array = Resources.LoadAll<ScriptableWorldConfig>("");
		bool flag = false;
		ScriptableWorldConfig[] array2 = array;
		foreach (ScriptableWorldConfig scriptableWorldConfig in array2)
		{
			if (scriptableWorldConfig.GameModes != null && scriptableWorldConfig.GameModes.Contains(Server.gamemode))
			{
				MergeScriptableConfig(scriptableWorldConfig);
				flag = true;
			}
		}
		if (flag)
		{
			JsonString = JsonConvert.SerializeObject((object)this);
		}
	}

	private void MergeScriptableConfig(ScriptableWorldConfig config)
	{
		UnderwaterLabs &= config.UnderwaterLabs;
		BelowGroundRails &= config.UndergroundTrains;
		if (PrefabBlacklist == null)
		{
			PrefabBlacklist = new List<string>();
		}
		if (config.BlacklistedPrefabs != null)
		{
			PrefabBlacklist.AddRange(config.BlacklistedPrefabs);
		}
	}
}


using System;
using UnityEngine;

public abstract class DecorComponent : PrefabAttribute
{
	internal bool isRoot;

	public abstract void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isRoot = (Object)(object)rootObj == (Object)(object)((Component)this).gameObject;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecorComponent);
	}
}


using UnityEngine;

public static class DecorComponentEx
{
	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components, ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		foreach (DecorComponent decorComponent in components)
		{
			if (!decorComponent.isRoot)
			{
				break;
			}
			decorComponent.Apply(ref pos, ref rot, ref scale);
		}
	}

	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.position = pos;
		transform.rotation = rot;
		transform.localScale = scale;
	}

	public static void ApplyDecorComponentsScaleOnly(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.localScale = scale;
	}
}


using UnityEngine;

public class DecorAlign : DecorComponent
{
	public float NormalAlignment = 1f;

	public float GradientAlignment = 1f;

	public Vector3 SlopeOffset = Vector3.zero;

	public Vector3 SlopeScale = Vector3.one;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = TerrainMeta.HeightMap.GetNormal(pos);
		Vector3 val = ((normal == Vector3.up) ? Vector3.forward : Vector3.Cross(normal, Vector3.up));
		Vector3 val2 = Vector3.Cross(normal, val);
		if (SlopeOffset != Vector3.zero || SlopeScale != Vector3.one)
		{
			float slope = TerrainMeta.HeightMap.GetSlope01(pos);
			if (SlopeOffset != Vector3.zero)
			{
				Vector3 val3 = SlopeOffset * slope;
				pos += val3.x * val;
				pos += val3.y * normal;
				pos -= val3.z * val2;
			}
			if (SlopeScale != Vector3.one)
			{
				Vector3 val4 = Vector3.Lerp(Vector3.one, Vector3.one + Quaternion.Inverse(rot) * (SlopeScale - Vector3.one), slope);
				scale.x *= val4.x;
				scale.y *= val4.y;
				scale.z *= val4.z;
			}
		}
		Vector3 up = Vector3.Lerp(rot * Vector3.up, normal, NormalAlignment);
		Vector3 forward = Vector3.Lerp(rot * Vector3.forward, val2, GradientAlignment);
		rot = QuaternionEx.LookRotationForcedUp(forward, up);
	}
}


using UnityEngine;

public class DecorFlip : DecorComponent
{
	public enum AxisType
	{
		X,
		Y,
		Z
	}

	public AxisType FlipAxis = AxisType.Y;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 4;
		if (!(SeedRandom.Value(ref num) > 0.5f))
		{
			switch (FlipAxis)
			{
			case AxisType.X:
			case AxisType.Z:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.up) * rot;
				break;
			case AxisType.Y:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.forward) * rot;
				break;
			}
		}
	}
}


public enum AxisType
{
	X,
	Y,
	Z
}


using UnityEngine;

public class DecorOffset : DecorComponent
{
	public Vector3 MinOffset = new Vector3(0f, 0f, 0f);

	public Vector3 MaxOffset = new Vector3(0f, 0f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 1;
		pos.x += scale.x * SeedRandom.Range(ref num, MinOffset.x, MaxOffset.x);
		pos.y += scale.y * SeedRandom.Range(ref num, MinOffset.y, MaxOffset.y);
		pos.z += scale.z * SeedRandom.Range(ref num, MinOffset.z, MaxOffset.z);
	}
}


using UnityEngine;

public class DecorRotate : DecorComponent
{
	public Vector3 MinRotation = new Vector3(0f, -180f, 0f);

	public Vector3 MaxRotation = new Vector3(0f, 180f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 2;
		float num2 = SeedRandom.Range(ref num, MinRotation.x, MaxRotation.x);
		float num3 = SeedRandom.Range(ref num, MinRotation.y, MaxRotation.y);
		float num4 = SeedRandom.Range(ref num, MinRotation.z, MaxRotation.z);
		rot = Quaternion.Euler(num2, num3, num4) * rot;
	}
}


using UnityEngine;

public class DecorScale : DecorComponent
{
	public Vector3 MinScale = new Vector3(1f, 1f, 1f);

	public Vector3 MaxScale = new Vector3(2f, 2f, 2f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 3;
		float num2 = SeedRandom.Value(ref num);
		scale.x *= Mathf.Lerp(MinScale.x, MaxScale.x, num2);
		scale.y *= Mathf.Lerp(MinScale.y, MaxScale.y, num2);
		scale.z *= Mathf.Lerp(MinScale.z, MaxScale.z, num2);
	}
}


using System;
using UnityEngine;

public class DecorSocketFemale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketFemale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(1f, 0.5f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using System;
using UnityEngine;

public class DecorSocketMale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketMale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 1f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using UnityEngine;

public class DecorSwim : DecorComponent
{
	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		pos.y = WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
		if (pos.y <= TerrainMeta.Position.y + 1f)
		{
			pos.y = 0f;
		}
	}
}


using UnityEngine;

public class DecorTransform : DecorComponent
{
	public Vector3 Position = new Vector3(0f, 0f, 0f);

	public Vector3 Rotation = new Vector3(0f, 0f, 0f);

	public Vector3 Scale = new Vector3(1f, 1f, 1f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		pos += rot * Vector3.Scale(scale, Position);
		rot = Quaternion.Euler(Rotation) * rot;
		scale = Vector3.Scale(scale, Scale);
	}
}


public class DecorPatch
{
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class DecorSpawn : MonoBehaviour, IClientComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public uint Seed;

	public float ObjectCutoff = 0.2f;

	public float ObjectTapering = 0.2f;

	public int ObjectsPerPatch = 10;

	public float ClusterRadius = 2f;

	public int ClusterSizeMin = 1;

	public int ClusterSizeMax = 10;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public bool LOD = true;
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseInfo : LandmarkInfo
{
	public List<GameObject> Links = new List<GameObject>();

	public List<DungeonBaseFloor> Floors = new List<DungeonBaseFloor>();

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public void Add(DungeonBaseLink link)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Links.Add(((Component)link).gameObject);
		if (link.Type == DungeonBaseLinkType.End)
		{
			return;
		}
		DungeonBaseFloor dungeonBaseFloor = null;
		float num = float.MaxValue;
		for (int i = 0; i < Floors.Count; i++)
		{
			DungeonBaseFloor dungeonBaseFloor2 = Floors[i];
			float num2 = dungeonBaseFloor2.Distance(((Component)link).transform.position);
			if (!(num2 >= 1f) && !(num2 >= num))
			{
				dungeonBaseFloor = dungeonBaseFloor2;
				num = num2;
			}
		}
		if (dungeonBaseFloor == null)
		{
			dungeonBaseFloor = new DungeonBaseFloor();
			dungeonBaseFloor.Links.Add(link);
			Floors.Add(dungeonBaseFloor);
			Floors.Sort((DungeonBaseFloor l, DungeonBaseFloor r) => l.SignedDistance(((Component)this).transform.position).CompareTo(r.SignedDistance(((Component)this).transform.position)));
		}
		else
		{
			dungeonBaseFloor.Links.Add(link);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseEntrances.Add(this);
		}
	}

	protected void Start()
	{
		World.TrackSpawnedPrefab("DungeonBase", ((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class DungeonBaseFloor
{
	public List<DungeonBaseLink> Links = new List<DungeonBaseLink>();

	public float Distance(Vector3 position)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Abs(((Component)Links[0]).transform.position.y - position.y);
	}

	public float SignedDistance(Vector3 position)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)Links[0]).transform.position.y - position.y;
	}
}


using UnityEngine;

[RequireComponent(typeof(DungeonBaseLink))]
public class DungeonBaseLandmarkInfo : LandmarkInfo
{
	private DungeonBaseLink baseLink;

	private MapLayer? layer;

	public override MapLayer MapLayer
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (layer.HasValue)
			{
				return layer.Value;
			}
			DungeonBaseInfo dungeonBaseInfo = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonBaseEntrances, ((Component)baseLink).transform.position);
			if ((Object)(object)dungeonBaseInfo == (Object)null)
			{
				Debug.LogWarning((object)"Couldn't determine which underwater lab a DungeonBaseLandmarkInfo belongs to", (Object)(object)this);
				shouldDisplayOnMap = false;
				layer = MapLayer.Overworld;
				return layer.Value;
			}
			int num = -1;
			for (int i = 0; i < dungeonBaseInfo.Floors.Count; i++)
			{
				if (dungeonBaseInfo.Floors[i].Links.Contains(baseLink))
				{
					num = i;
				}
			}
			if (num >= 0)
			{
				layer = (MapLayer)(1 + num);
			}
			else
			{
				Debug.LogWarning((object)"Couldn't determine the floor of a DungeonBaseLandmarkInfo", (Object)(object)this);
				shouldDisplayOnMap = false;
				layer = MapLayer.Overworld;
			}
			return layer.Value;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		baseLink = ((Component)this).GetComponent<DungeonBaseLink>();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseLink : MonoBehaviour
{
	public DungeonBaseLinkType Type;

	public int Cost = 1;

	public int MaxFloor = -1;

	public int MaxCountLocal = -1;

	public int MaxCountGlobal = -1;

	[Tooltip("If set to a positive number, all segments with the same MaxCountIdentifier are counted towards MaxCountLocal and MaxCountGlobal")]
	public int MaxCountIdentifier = -1;

	public DungeonBaseInfo Dungeon;

	public RendererLOD[] MapRendererLods = new RendererLOD[0];

	private List<DungeonBaseSocket> sockets;

	private List<DungeonVolume> volumes;

	internal List<DungeonBaseSocket> Sockets
	{
		get
		{
			if (sockets == null)
			{
				sockets = new List<DungeonBaseSocket>();
				((Component)this).GetComponentsInChildren<DungeonBaseSocket>(true, sockets);
			}
			return sockets;
		}
	}

	internal List<DungeonVolume> Volumes
	{
		get
		{
			if (volumes == null)
			{
				volumes = new List<DungeonVolume>();
				((Component)this).GetComponentsInChildren<DungeonVolume>(true, volumes);
			}
			return volumes;
		}
	}

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseLinks.Add(this);
		}
	}

	internal void Initialize()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)TerrainMeta.Path == (Object)null))
		{
			Dungeon = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonBaseEntrances, ((Component)this).transform.position);
			if (!((Object)(object)Dungeon == (Object)null))
			{
				Dungeon.Add(this);
			}
		}
	}
}


public enum DungeonBaseLinkType
{
	Room,
	Corridor,
	End
}


using UnityEngine;

public class DungeonBaseSocket : MonoBehaviour
{
	public DungeonBaseSocketType Type;

	public bool Male = true;

	public bool Female = true;
}


public enum DungeonBaseSocketType
{
	Horizontal,
	Vertical,
	Pillar
}


using UnityEngine;

public class DungeonBaseTransition : MonoBehaviour
{
	public DungeonBaseSocketType Type;

	public DungeonBaseLinkType Neighbour1;

	public DungeonBaseLinkType Neighbour2;
}


using UnityEngine;

public class DungeonConditionalModel : MonoBehaviour
{
	public MapLayer Layer;

	private void Start()
	{
		foreach (Transform child in ((Component)this).transform.GetChildren())
		{
			((Component)child).gameObject.SetActive(World.Config != null && !World.Config.BelowGroundRails);
		}
	}
}


using UnityEngine;

public class DungeonGridCell : MonoBehaviour
{
	public DungeonGridConnectionType North;

	public DungeonGridConnectionType South;

	public DungeonGridConnectionType West;

	public DungeonGridConnectionType East;

	public DungeonGridConnectionVariant NorthVariant;

	public DungeonGridConnectionVariant SouthVariant;

	public DungeonGridConnectionVariant WestVariant;

	public DungeonGridConnectionVariant EastVariant;

	public GameObjectRef[] AvoidNeighbours;

	public RendererLOD[] MapRendererLods;

	public bool Replaceable;

	public bool ShouldAvoid(uint id)
	{
		GameObjectRef[] avoidNeighbours = AvoidNeighbours;
		for (int i = 0; i < avoidNeighbours.Length; i++)
		{
			if (avoidNeighbours[i].resourceID == id)
			{
				return true;
			}
		}
		return false;
	}

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonGridCells.Add(this);
		}
	}
}


public enum DungeonGridConnectionType
{
	None,
	TrainTunnel
}


public enum DungeonGridConnectionVariant
{
	A,
	B
}


public struct DungeonGridConnectionHash
{
	public bool North;

	public bool South;

	public bool West;

	public bool East;

	public int Value => (North ? 1 : 0) | (South ? 2 : 0) | (West ? 4 : 0) | (East ? 8 : 0);
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonGridInfo : LandmarkInfo
{
	[Header("DungeonGridInfo")]
	public int CellSize = 216;

	public float LinkHeight = 1.5f;

	public float LinkRadius = 3f;

	internal List<GameObject> Links = new List<GameObject>();

	public float MinDistance => (float)CellSize * 2.5f;

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public bool IsValidSpawnPosition(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		OBB bounds = ((Component)this).GetComponentInChildren<DungeonVolume>().GetBounds(position, Quaternion.identity);
		Vector3 val = WorldSpaceGrid.ClosestGridCell(bounds.position, TerrainMeta.Size.x, (float)CellSize, (RoundingMode)1);
		Vector3 val2 = bounds.position - val;
		if (!(Mathf.Abs(val2.x) > 3f))
		{
			return Mathf.Abs(val2.z) > 3f;
		}
		return true;
	}

	public Vector3 SnapPosition(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		pos.x = (float)Mathf.RoundToInt(pos.x / LinkRadius) * LinkRadius;
		pos.y = (float)Mathf.CeilToInt(pos.y / LinkHeight) * LinkHeight;
		pos.z = (float)Mathf.RoundToInt(pos.z / LinkRadius) * LinkRadius;
		return pos;
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonGridEntrances.Add(this);
		}
	}

	protected void Start()
	{
		World.TrackSpawnedPrefab("Dungeon", ((Component)this).gameObject);
	}
}


using UnityEngine;

public class DungeonGridLink : MonoBehaviour
{
	public Transform UpSocket;

	public Transform DownSocket;

	public DungeonGridLinkType UpType;

	public DungeonGridLinkType DownType;

	public int Priority;

	public int Rotation;

	protected void Start()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)TerrainMeta.Path == (Object)null))
		{
			DungeonGridInfo dungeonGridInfo = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonGridEntrances, ((Component)this).transform.position);
			if (!((Object)(object)dungeonGridInfo == (Object)null))
			{
				dungeonGridInfo.Links.Add(((Component)this).gameObject);
			}
		}
	}
}


public enum DungeonGridLinkType
{
	Default,
	Elevator,
	Transition
}


using UnityEngine;

public class DungeonVolume : MonoBehaviour
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public OBB GetBounds(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (((Component)this).transform.localRotation * ((Bounds)(ref bounds)).center + ((Component)this).transform.localPosition);
		return new OBB(position, ((Bounds)(ref bounds)).size, rotation * ((Component)this).transform.localRotation);
	}

	public OBB GetBounds(Vector3 position, Quaternion rotation, Vector3 extrude)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (((Component)this).transform.localRotation * ((Bounds)(ref bounds)).center + ((Component)this).transform.localPosition);
		return new OBB(position, ((Bounds)(ref bounds)).size + extrude, rotation * ((Component)this).transform.localRotation);
	}
}


using System;
using UnityEngine;

public class EnvironmentVolumeCheck : PrefabAttribute
{
	[InspectorFlags]
	public EnvironmentType Type = EnvironmentType.Underground | EnvironmentType.TrainTunnels;

	public Vector3 Center = Vector3.zero;

	public Vector3 Size = Vector3.one;

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(0f, 0f, 0.5f, 1f);
		Gizmos.DrawWireCube(Center, Size);
	}

	public bool Check(OBB obb)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return !EnvironmentManager.Check(obb, Type);
	}

	protected override Type GetIndexedType()
	{
		return typeof(EnvironmentVolumeCheck);
	}
}


using UnityEngine;

public static class EnvironmentVolumeCheckEx
{
	public static bool ApplyEnvironmentVolumeChecks(this Transform transform, EnvironmentVolumeCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		OBB obb = default(OBB);
		foreach (EnvironmentVolumeCheck environmentVolumeCheck in anchors)
		{
			Vector3 val = environmentVolumeCheck.worldPosition + environmentVolumeCheck.worldRotation * environmentVolumeCheck.Center;
			Vector3 val2 = rot * Vector3.Scale(val, scale);
			((OBB)(ref obb))..ctor(pos + val2, Vector3.Scale(environmentVolumeCheck.Size, scale), rot);
			if (!environmentVolumeCheck.Check(obb))
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using UnityEngine;

public class BiomeVisuals : MonoBehaviour
{
	[Serializable]
	public class EnvironmentVolumeOverride
	{
		public EnvironmentType Environment;

		public Enum Biome;
	}

	public GameObject Arid;

	public GameObject Temperate;

	public GameObject Tundra;

	public GameObject Arctic;

	public bool OverrideBiome;

	public Enum ToOverride;

	[Horizontal(2, -1)]
	public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;

	private bool _supportsPooling;

	private GameObject _defaultSelection;

	protected void Awake()
	{
		_supportsPooling = ((Component)this).gameObject.SupportsPoolingInParent();
		if (Object.op_Implicit((Object)(object)Arid) && Arid.activeSelf)
		{
			_defaultSelection = Arid;
		}
		else if (Object.op_Implicit((Object)(object)Temperate) && Temperate.activeSelf)
		{
			_defaultSelection = Temperate;
		}
		else if (Object.op_Implicit((Object)(object)Tundra) && Tundra.activeSelf)
		{
			_defaultSelection = Tundra;
		}
		else if (Object.op_Implicit((Object)(object)Arctic) && Arctic.activeSelf)
		{
			_defaultSelection = Arctic;
		}
	}

	protected void OnEnable()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected I4, but got Unknown
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Expected I4, but got Unknown
		int num = (((Object)(object)TerrainMeta.BiomeMap != (Object)null) ? TerrainMeta.BiomeMap.GetBiomeMaxType(((Component)this).transform.position) : 2);
		if (OverrideBiome)
		{
			num = (int)ToOverride;
		}
		else if (EnvironmentVolumeOverrides.Length != 0)
		{
			EnvironmentType environmentType = EnvironmentManager.Get(((Component)this).transform.position);
			EnvironmentVolumeOverride[] environmentVolumeOverrides = EnvironmentVolumeOverrides;
			foreach (EnvironmentVolumeOverride environmentVolumeOverride in environmentVolumeOverrides)
			{
				if ((environmentType & environmentVolumeOverride.Environment) != 0)
				{
					num = (int)environmentVolumeOverride.Biome;
					break;
				}
			}
		}
		switch (num)
		{
		case 1:
			SetChoice(Arid);
			break;
		case 2:
			SetChoice(Temperate);
			break;
		case 4:
			SetChoice(Tundra);
			break;
		case 8:
			SetChoice(Arctic);
			break;
		default:
			SetChoice(_defaultSelection);
			break;
		}
	}

	private void SetChoice(GameObject selection)
	{
		bool flag = !_supportsPooling;
		ApplyChoice(selection, Arid, flag);
		ApplyChoice(selection, Temperate, flag);
		ApplyChoice(selection, Tundra, flag);
		ApplyChoice(selection, Arctic, flag);
		if ((Object)(object)selection != (Object)null)
		{
			selection.SetActive(true);
		}
		if (flag)
		{
			GameManager.Destroy((Component)(object)this);
		}
	}

	private void ApplyChoice(GameObject selection, GameObject target, bool shouldDestroy)
	{
		if ((Object)(object)target != (Object)null && (Object)(object)target != (Object)(object)selection)
		{
			if (shouldDestroy)
			{
				GameManager.Destroy(target);
			}
			else
			{
				target.SetActive(false);
			}
		}
	}
}


using System;

[Serializable]
public class EnvironmentVolumeOverride
{
	public EnvironmentType Environment;

	public Enum Biome;
}


using UnityEngine;

public class RandomDestroy : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref num) > Probability)
		{
			GameManager.Destroy((Component)(object)this);
		}
		else
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
	}
}


using UnityEngine;

public class RandomDynamicObject : MonoBehaviour, IClientComponent, ILOD
{
	public uint Seed;

	public float Distance = 100f;

	public float Probability = 0.5f;

	public GameObject[] Candidates;
}


using UnityEngine;

public class RandomDynamicPrefab : MonoBehaviour, IClientComponent, ILOD
{
	public uint Seed;

	public float Distance = 100f;

	public float Probability = 0.5f;

	public string ResourceFolder = string.Empty;
}


using UnityEngine;

public class RandomStaticObject : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	public GameObject[] Candidates;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref num) > Probability)
		{
			for (int i = 0; i < Candidates.Length; i++)
			{
				GameManager.Destroy(Candidates[i]);
			}
			GameManager.Destroy((Component)(object)this);
			return;
		}
		int num2 = SeedRandom.Range(num, 0, ((Component)this).transform.childCount);
		for (int j = 0; j < Candidates.Length; j++)
		{
			GameObject val = Candidates[j];
			if (j == num2)
			{
				val.SetActive(true);
			}
			else
			{
				GameManager.Destroy(val);
			}
		}
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class RandomStaticPrefab : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	public string ResourceFolder = string.Empty;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint seed = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref seed) > Probability)
		{
			GameManager.Destroy((Component)(object)this);
			return;
		}
		Prefab.LoadRandom("assets/bundled/prefabs/autospawn/" + ResourceFolder, ref seed).Spawn(((Component)this).transform);
		GameManager.Destroy((Component)(object)this);
	}
}


public class ParticlePatch
{
}


using UnityEngine;

public class ParticleSpawn : SingletonComponent<ParticleSpawn>, IClientComponent
{
	public GameObjectRef[] Prefabs;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public Vector3 Origin { get; private set; }
}


using UnityEngine;

public class PowerlineNode : MonoBehaviour
{
	public GameObjectRef WirePrefab;

	public float MaxDistance = 50f;

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.AddWire(this);
		}
	}
}


using UnityEngine;

public class RemoveChildObjectsAlongPath : MonoBehaviour, IEditorComponent
{
	public Transform Node1;

	public Transform Node2;

	public float Distance;
}


using System.Collections.Generic;
using UnityEngine;

public class TerrainPathChildObjects : MonoBehaviour
{
	public bool Spline = true;

	public float Width;

	public float Offset;

	public float Fade;

	[InspectorFlags]
	public Enum Splat = (Enum)1;

	[InspectorFlags]
	public Enum Topology = (Enum)2048;

	public InfrastructureType Type;

	protected void Awake()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Expected I4, but got Unknown
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Expected I4, but got Unknown
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Expected I4, but got Unknown
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Expected I4, but got Unknown
		if (!World.Cached && !World.Networked)
		{
			List<Vector3> list = new List<Vector3>();
			foreach (Transform item in ((Component)this).transform)
			{
				Transform val = item;
				list.Add(val.position);
			}
			if (list.Count >= 2)
			{
				switch (Type)
				{
				case InfrastructureType.Road:
				{
					PathList pathList2 = new PathList("Road " + TerrainMeta.Path.Roads.Count, list.ToArray());
					pathList2.Width = Width;
					pathList2.InnerFade = Fade * 0.5f;
					pathList2.OuterFade = Fade * 0.5f;
					pathList2.MeshOffset = Offset * 0.3f;
					pathList2.TerrainOffset = Offset;
					pathList2.Topology = (int)Topology;
					pathList2.Splat = (int)Splat;
					pathList2.Spline = Spline;
					pathList2.Path.RecalculateTangents();
					TerrainMeta.Path.Roads.Add(pathList2);
					break;
				}
				case InfrastructureType.Power:
				{
					PathList pathList = new PathList("Powerline " + TerrainMeta.Path.Powerlines.Count, list.ToArray());
					pathList.Width = Width;
					pathList.InnerFade = Fade * 0.5f;
					pathList.OuterFade = Fade * 0.5f;
					pathList.MeshOffset = Offset * 0.3f;
					pathList.TerrainOffset = Offset;
					pathList.Topology = (int)Topology;
					pathList.Splat = (int)Splat;
					pathList.Spline = Spline;
					pathList.Path.RecalculateTangents();
					TerrainMeta.Path.Powerlines.Add(pathList);
					break;
				}
				}
			}
		}
		GameManager.Destroy(((Component)this).gameObject);
	}

	protected void OnDrawGizmos()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		Vector3 a = Vector3.zero;
		foreach (Transform item in ((Component)this).transform)
		{
			Vector3 position = item.position;
			if (flag)
			{
				Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
				GizmosUtil.DrawWirePath(a, position, 0.5f * Width);
			}
			a = position;
			flag = true;
		}
	}
}


using UnityEngine;

public class TerrainPathConnect : MonoBehaviour
{
	public InfrastructureType Type;

	public PathFinder.Point GetPathFinderPoint(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return PathFinder.GetPoint(((Component)this).transform.position, res);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathSequence : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(PathSequence);
	}

	public virtual void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
	}
}


using System.Collections.Generic;
using UnityEngine;

public class PathSequencePowerline : PathSequence
{
	public enum SequenceRule
	{
		PowerlinePlatform,
		Powerline
	}

	public SequenceRule Rule;

	private const int RegularPowerlineSpacing = 2;

	public override void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
		bool flag = false;
		if (Rule == SequenceRule.Powerline)
		{
			if (pathLength >= 3)
			{
				flag = sequence.Count == 0 || pathIndex == pathLength - 1;
				if (!flag)
				{
					flag = GetIndexCountToRule(sequence, SequenceRule.PowerlinePlatform) >= 2;
				}
			}
		}
		else if (Rule == SequenceRule.PowerlinePlatform)
		{
			flag = pathLength < 3;
			if (!flag)
			{
				int indexCountToRule = GetIndexCountToRule(sequence, SequenceRule.PowerlinePlatform);
				flag = indexCountToRule < 2 && indexCountToRule != sequence.Count && pathIndex < pathLength - 1;
			}
		}
		if (flag)
		{
			Prefab prefabOfType = GetPrefabOfType(possibleReplacements, (Rule == SequenceRule.PowerlinePlatform) ? SequenceRule.Powerline : SequenceRule.PowerlinePlatform);
			if (prefabOfType != null)
			{
				replacement = prefabOfType;
			}
		}
	}

	private Prefab GetPrefabOfType(Prefab[] options, SequenceRule ruleToFind)
	{
		for (int i = 0; i < options.Length; i++)
		{
			PathSequencePowerline pathSequencePowerline = options[i].Attribute.Find<PathSequence>(options[i].ID) as PathSequencePowerline;
			if (pathSequencePowerline == null || pathSequencePowerline.Rule == ruleToFind)
			{
				return options[i];
			}
		}
		return null;
	}

	private int GetIndexCountToRule(List<Prefab> sequence, SequenceRule rule)
	{
		int num = 0;
		for (int num2 = sequence.Count - 1; num2 >= 0; num2--)
		{
			PathSequencePowerline pathSequencePowerline = sequence[num2].Attribute.Find<PathSequence>(sequence[num2].ID) as PathSequencePowerline;
			if (pathSequencePowerline != null)
			{
				if (pathSequencePowerline.Rule == rule)
				{
					break;
				}
				num++;
			}
		}
		return num;
	}
}


public enum SequenceRule
{
	PowerlinePlatform,
	Powerline
}


using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Procedural/Mega Wire")]
public class PowerLineWire : MonoBehaviour
{
	public List<Transform> poles = new List<Transform>();

	public List<PowerLineWireConnectionDef> connections = new List<PowerLineWireConnectionDef>();

	public List<PowerLineWireSpan> spans = new List<PowerLineWireSpan>();

	public void Copy(PowerLineWire from, PowerLineWireConnectionHelper helper)
	{
		connections.Clear();
		if (Object.op_Implicit((Object)(object)helper))
		{
			for (int i = 0; i < helper.connections.Count; i++)
			{
				connections.Add(new PowerLineWireConnectionDef(helper.connections[i]));
			}
		}
		else
		{
			for (int j = 0; j < from.connections.Count; j++)
			{
				connections.Add(new PowerLineWireConnectionDef(from.connections[j]));
			}
		}
	}

	public static PowerLineWire Create(PowerLineWire wire, List<GameObject> objs, GameObjectRef wirePrefab, string name, PowerLineWire copyfrom, float wiresize, float str)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Expected O, but got Unknown
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (objs != null && objs.Count > 1)
		{
			GameObject val = null;
			if ((Object)(object)wire == (Object)null)
			{
				val = new GameObject();
				((Object)val).name = name;
				wire = val.AddComponent<PowerLineWire>();
			}
			else
			{
				val = ((Component)wire).gameObject;
			}
			wire.poles.Clear();
			wire.spans.Clear();
			wire.connections.Clear();
			wire.poles.Add(objs[0].transform);
			for (int i = 0; i < objs.Count - 1; i++)
			{
				GameObject val2 = new GameObject
				{
					name = name + " Span Mesh " + i
				};
				val2.transform.parent = val.transform;
				PowerLineWireSpan powerLineWireSpan = val2.AddComponent<PowerLineWireSpan>();
				powerLineWireSpan.wirePrefab = wirePrefab;
				powerLineWireSpan.start = objs[i].transform;
				powerLineWireSpan.end = objs[i + 1].transform;
				wire.spans.Add(powerLineWireSpan);
				wire.poles.Add(objs[i + 1].transform);
			}
			PowerLineWireConnectionHelper component = objs[0].GetComponent<PowerLineWireConnectionHelper>();
			if (Object.op_Implicit((Object)(object)copyfrom))
			{
				wire.Copy(copyfrom, component);
			}
			else if (Object.op_Implicit((Object)(object)component))
			{
				wire.Copy(wire, component);
			}
			else
			{
				PowerLineWireConnectionDef item = new PowerLineWireConnectionDef();
				wire.connections.Add(item);
			}
			if (wiresize != 1f)
			{
				for (int j = 0; j < wire.connections.Count; j++)
				{
					wire.connections[j].radius *= wiresize;
				}
			}
			wire.Init();
		}
		return wire;
	}

	public void Init()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < spans.Count; i++)
		{
			PowerLineWireSpan powerLineWireSpan = spans[i];
			powerLineWireSpan.connections.Clear();
			for (int j = 0; j < connections.Count; j++)
			{
				PowerLineWireConnection powerLineWireConnection = new PowerLineWireConnection
				{
					start = powerLineWireSpan.start,
					end = powerLineWireSpan.end,
					inOffset = connections[j].inOffset,
					outOffset = connections[j].outOffset,
					radius = connections[j].radius
				};
				PowerLineWireConnectionHelper component = ((Component)powerLineWireSpan.start).GetComponent<PowerLineWireConnectionHelper>();
				PowerLineWireConnectionHelper component2 = ((Component)powerLineWireSpan.end).GetComponent<PowerLineWireConnectionHelper>();
				powerLineWireConnection.inOffset = component2.connections[j].inOffset;
				powerLineWireConnection.outOffset = component.connections[j].outOffset;
				if (!component.connections[j].hidden && !component2.connections[j].hidden)
				{
					powerLineWireSpan.connections.Add(powerLineWireConnection);
				}
			}
			powerLineWireSpan.Init(this);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class PowerLineWireConnectionDef
{
	public Vector3 inOffset = Vector3.zero;

	public Vector3 outOffset = Vector3.zero;

	public float radius = 0.01f;

	public bool hidden;

	public PowerLineWireConnectionDef()
	{
	}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
	//IL_0006: Unknown result type (might be due to invalid IL or missing references)
	//IL_000c: Unknown result type (might be due to invalid IL or missing references)
	//IL_0011: Unknown result type (might be due to invalid IL or missing references)


	public PowerLineWireConnectionDef(PowerLineWireConnectionDef src)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		inOffset = src.inOffset;
		outOffset = src.outOffset;
		radius = src.radius;
	}
}


using System;
using UnityEngine;

[Serializable]
public class PowerLineWireConnection
{
	public Vector3 inOffset = Vector3.zero;

	public Vector3 outOffset = Vector3.zero;

	public float radius = 0.01f;

	public Transform start;

	public Transform end;
}


using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Mega Wire/Connection Helper")]
public class PowerLineWireConnectionHelper : MonoBehaviour
{
	public List<PowerLineWireConnectionDef> connections = new List<PowerLineWireConnectionDef>();

	public bool showgizmo;
}


using System.Collections.Generic;
using UnityEngine;

public class PowerLineWireSpan : MonoBehaviour
{
	public GameObjectRef wirePrefab;

	public Transform start;

	public Transform end;

	public float WireLength;

	public List<PowerLineWireConnection> connections = new List<PowerLineWireConnection>();

	public void Init(PowerLineWire wire)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)start) && Object.op_Implicit((Object)(object)end))
		{
			WireLength = Vector3.Distance(start.position, end.position);
			for (int i = 0; i < connections.Count; i++)
			{
				Vector3 val = start.TransformPoint(connections[i].outOffset);
				Vector3 val2 = end.TransformPoint(connections[i].inOffset);
				Vector3 val3 = val - val2;
				WireLength = ((Vector3)(ref val3)).magnitude;
				GameObject obj = wirePrefab.Instantiate(((Component)this).transform);
				((Object)obj).name = "WIRE";
				obj.transform.position = Vector3.Lerp(val, val2, 0.5f);
				obj.transform.LookAt(val2);
				obj.transform.localScale = new Vector3(1f, 1f, Vector3.Distance(val, val2));
				obj.SetActive(true);
			}
		}
	}
}


using UnityEngine;

public class ApplyTerrainAnchors : MonoBehaviour
{
	protected void Awake()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		TerrainAnchor[] anchors = null;
		if (component.isServer)
		{
			anchors = PrefabAttribute.server.FindAll<TerrainAnchor>(component.prefabID);
		}
		((Component)this).transform.ApplyTerrainAnchors(anchors);
		GameManager.Destroy((Component)(object)this);
	}
}


using System;
using UnityEngine;

public class TerrainAnchor : PrefabAttribute
{
	public float Extents = 1f;

	public float Offset;

	public float Radius;

	public float SlopeScale;

	public void Apply(out float height, out float min, out float max, Vector3 pos, Vector3 scale, Quaternion rotation)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f + SlopeScale * Mathf.InverseLerp(0f, 90f, Vector3.Angle(Vector3.up, rotation * Vector3.up));
		float num2 = Extents * scale.y * num;
		float num3 = Offset * scale.y * num;
		height = TerrainMeta.HeightMap.GetHeight(pos);
		min = height - num3 - num2;
		max = height - num3 + num2;
		if (!(Radius > 0f))
		{
			return;
		}
		int num4 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(pos.x - Radius));
		int num5 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(pos.x + Radius));
		int num6 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(pos.z - Radius));
		int num7 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(pos.z + Radius));
		for (int i = num6; i <= num7; i++)
		{
			if (max < min)
			{
				break;
			}
			for (int j = num4; j <= num5; j++)
			{
				if (max < min)
				{
					break;
				}
				float height2 = TerrainMeta.HeightMap.GetHeight(j, i);
				min = Mathf.Max(min, height2 - num3 - num2);
				max = Mathf.Min(max, height2 - num3 + num2);
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainAnchor);
	}
}


public enum TerrainAnchorMode
{
	MinimizeError,
	MinimizeMovement,
	MaximizeHeight
}


using UnityEngine;

public static class TerrainAnchorEx
{
	public static bool ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors, ref Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return transform.ApplyTerrainAnchors(anchors, ref pos, rot, scale, TerrainAnchorMode.MinimizeError, filter);
	}

	public static bool ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors, ref Vector3 pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter = null)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		float num = 0f;
		float num2 = float.MinValue;
		float num3 = float.MaxValue;
		foreach (TerrainAnchor terrainAnchor in anchors)
		{
			Vector3 val = Vector3.Scale(terrainAnchor.worldPosition, scale);
			val = rot * val;
			Vector3 val2 = pos + val;
			if (filter != null && filter.GetFactor(val2) == 0f)
			{
				return false;
			}
			terrainAnchor.Apply(out var height, out var min, out var max, val2, scale, rot);
			num += height - val.y;
			num2 = Mathf.Max(num2, min - val.y);
			num3 = Mathf.Min(num3, max - val.y);
			if (num3 < num2)
			{
				return false;
			}
		}
		if (num3 > 1f && num2 < 1f)
		{
			num2 = 1f;
		}
		switch (mode)
		{
		case TerrainAnchorMode.MinimizeError:
			pos.y = Mathf.Clamp(num / (float)anchors.Length, num2, num3);
			break;
		case TerrainAnchorMode.MinimizeMovement:
			pos.y = Mathf.Clamp(pos.y, num2, num3);
			break;
		default:
			pos.y = num3;
			break;
		}
		return true;
	}

	public static void ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		transform.ApplyTerrainAnchors(anchors, ref pos, transform.rotation, transform.lossyScale);
		transform.position = pos;
	}
}


using UnityEngine;

public class TerrainAnchorGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementPadding;

	public float PlacementFade = 16f;

	public float PlacementDistance = 8f;

	public float AnchorExtentsMin = 8f;

	public float AnchorExtentsMax = 16f;

	public float AnchorOffsetMin;

	public float AnchorOffsetMax;
}


using System;
using UnityEngine;

public class TerrainCheck : PrefabAttribute
{
	public bool Rotate = true;

	public float Extents = 1f;

	public bool Check(Vector3 pos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float extents = Extents;
		float height = TerrainMeta.HeightMap.GetHeight(pos);
		float num = pos.y - extents;
		float num2 = pos.y + extents;
		if (num > height)
		{
			return false;
		}
		if (num2 < height)
		{
			return false;
		}
		return true;
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainCheck);
	}
}


using UnityEngine;

public static class TerrainCheckEx
{
	public static bool ApplyTerrainChecks(this Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		foreach (TerrainCheck terrainCheck in anchors)
		{
			Vector3 val = Vector3.Scale(terrainCheck.worldPosition, scale);
			if (terrainCheck.Rotate)
			{
				val = rot * val;
			}
			Vector3 val2 = pos + val;
			if (filter != null && filter.GetFactor(val2) == 0f)
			{
				return false;
			}
			if (!terrainCheck.Check(val2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class TerrainCheckGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementPadding;

	public float PlacementFade = 16f;

	public float PlacementDistance = 8f;

	public float CheckExtentsMin = 8f;

	public float CheckExtentsMax = 16f;

	public bool CheckRotate = true;
}


using UnityEngine;

public class TerrainCheckGeneratorVolumes : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius;

	public float PlacementOffset;

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, PlacementRadius);
	}
}


using System;

public interface ICoarseQueryGridProvider : IDisposable
{
	CoarseQueryGrid GetQueryGrid();
}


using System;
using CoarseQueryGridJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[GenerateTestsForBurstCompatibility]
public struct CoarseQueryGrid : IDisposable
{
	public struct RefCountedSpatialArray : IDisposable
	{
		private NativeArray<byte> _array;

		public NativeArray<byte> RawArray => _array;

		public int Length => _array.Length;

		public static RefCountedSpatialArray Init(int length)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			RefCountedSpatialArray result = default(RefCountedSpatialArray);
			result._array = new NativeArray<byte>(length, (Allocator)4, (NativeArrayOptions)1);
			return result;
		}

		public void Add(int index)
		{
			Debug.Assert(_array[index] != byte.MaxValue);
			ref NativeArray<byte> array = ref _array;
			byte b = array[index];
			array[index] = (byte)(b + 1);
		}

		public void Remove(int index)
		{
			Debug.Assert(_array[index] != 0);
			ref NativeArray<byte> array = ref _array;
			byte b = array[index];
			array[index] = (byte)(b - 1);
		}

		public bool Get(int index)
		{
			return _array[index] > 0;
		}

		public void Dispose()
		{
			_array.Dispose();
		}
	}

	private const float StaticBoundsInflation = 0.1f;

	private readonly int _cellXZDimensionCount;

	private readonly Vector2 _gridCentre;

	private readonly float _yCutoff;

	private readonly int _cellSize;

	private readonly int _cellClampLimit;

	private NativeReference<bool> _result;

	private bool _hasDisposed;

	private NativeList<Bounds> _dynamicBounds;

	private RefCountedSpatialArray _upperStaticSpatialArray;

	private RefCountedSpatialArray _lowerStaticSpatialArray;

	public CoarseQueryGrid(int cellSize, int maxWorldSizeXZ, float yCutoff)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		_cellSize = cellSize;
		_cellXZDimensionCount = (int)((float)(maxWorldSizeXZ / cellSize) + 0.5f);
		_gridCentre = new Vector2((float)maxWorldSizeXZ * 0.5f, (float)maxWorldSizeXZ * 0.5f);
		_yCutoff = yCutoff;
		_hasDisposed = false;
		_result = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
		_upperStaticSpatialArray = RefCountedSpatialArray.Init(_cellXZDimensionCount * _cellXZDimensionCount);
		_lowerStaticSpatialArray = RefCountedSpatialArray.Init(_cellXZDimensionCount * _cellXZDimensionCount);
		_dynamicBounds = new NativeList<Bounds>(AllocatorHandle.op_Implicit((Allocator)4));
		_cellClampLimit = _upperStaticSpatialArray.Length - 1;
	}

	private bool TouchesUpperSpatial(Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref bounds)).max.y >= _yCutoff;
	}

	private bool TouchesUpperSpatial(Vector3 pos, float r)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return pos.y + r >= _yCutoff;
	}

	private bool TouchesLowerSpatial(Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref bounds)).min.y <= _yCutoff;
	}

	private bool TouchesLowerSpatial(Vector3 pos, float r)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return pos.y - r <= _yCutoff;
	}

	public void PrepareForDynamicPopulate(int dynamicCount)
	{
		if (!_hasDisposed)
		{
			_dynamicBounds.Clear();
			if (_dynamicBounds.Capacity < dynamicCount)
			{
				_dynamicBounds.SetCapacity(dynamicCount);
			}
		}
	}

	private bool CheckStateAdd()
	{
		if (_hasDisposed)
		{
			Debug.LogError((object)"Adding bounds to disposed CoarseQueryGrid");
		}
		return _hasDisposed;
	}

	public void AddDynamic(Bounds bounds)
	{
		if (!CheckStateAdd())
		{
			_dynamicBounds.Add(ref bounds);
		}
	}

	public void AddStatic(Bounds bounds)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckStateAdd())
		{
			((Bounds)(ref bounds)).Expand(0.1f);
			Vector2i min = WorldPosToStaticGrid(((Bounds)(ref bounds)).min);
			Vector2i max = WorldPosToStaticGrid(((Bounds)(ref bounds)).max);
			if (TouchesUpperSpatial(bounds))
			{
				AddStatic(min, max, _upperStaticSpatialArray);
			}
			if (TouchesLowerSpatial(bounds))
			{
				AddStatic(min, max, _lowerStaticSpatialArray);
			}
		}
	}

	private void AddStatic(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				spatial.Add(index);
			}
		}
	}

	public void RemoveStatic(Bounds bounds)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!_hasDisposed)
		{
			((Bounds)(ref bounds)).Expand(0.1f);
			Vector2i min = WorldPosToStaticGrid(((Bounds)(ref bounds)).min);
			Vector2i max = WorldPosToStaticGrid(((Bounds)(ref bounds)).max);
			if (TouchesUpperSpatial(bounds))
			{
				RemoveStatic(min, max, _upperStaticSpatialArray);
			}
			if (TouchesLowerSpatial(bounds))
			{
				RemoveStatic(min, max, _lowerStaticSpatialArray);
			}
		}
	}

	private void RemoveStatic(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				spatial.Remove(index);
			}
		}
	}

	public bool CheckJob(Bounds checkBounds)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		CheckBoundsJob checkBoundsJob = default(CheckBoundsJob);
		checkBoundsJob.Grid = this;
		checkBoundsJob.CheckBounds = checkBounds;
		checkBoundsJob.Result = _result;
		CheckBoundsJob checkBoundsJob2 = checkBoundsJob;
		IJobExtensions.RunByRef<CheckBoundsJob>(ref checkBoundsJob2);
		return _result.Value;
	}

	public bool Check(Bounds checkBounds)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector2i min = WorldPosToStaticGrid(((Bounds)(ref checkBounds)).min);
		Vector2i max = WorldPosToStaticGrid(((Bounds)(ref checkBounds)).max);
		if (TouchesUpperSpatial(checkBounds) && Check(min, max, _upperStaticSpatialArray))
		{
			return true;
		}
		if (TouchesLowerSpatial(checkBounds) && Check(min, max, _lowerStaticSpatialArray))
		{
			return true;
		}
		Enumerator<Bounds> enumerator = _dynamicBounds.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Bounds current = enumerator.Current;
				if (((Bounds)(ref current)).Intersects(checkBounds))
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	private bool Check(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				if (spatial.Get(index))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool CheckJob(Vector3 worldPosition, float radius)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		CheckPosRadJob checkPosRadJob = default(CheckPosRadJob);
		checkPosRadJob.Grid = this;
		checkPosRadJob.CheckPos = worldPosition;
		checkPosRadJob.CheckRad = radius;
		checkPosRadJob.Result = _result;
		CheckPosRadJob checkPosRadJob2 = checkPosRadJob;
		IJobExtensions.RunByRef<CheckPosRadJob>(ref checkPosRadJob2);
		return _result.Value;
	}

	public JobHandle CheckJob(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckPosRadBatchJob checkPosRadBatchJob = default(CheckPosRadBatchJob);
		checkPosRadBatchJob.Grid = this;
		checkPosRadBatchJob.Pos = worldPositions;
		checkPosRadBatchJob.Radii = radii;
		checkPosRadBatchJob.OverlapIndices = overlapIndices;
		CheckPosRadBatchJob checkPosRadBatchJob2 = checkPosRadBatchJob;
		return IJobExtensions.ScheduleByRef<CheckPosRadBatchJob>(ref checkPosRadBatchJob2, default(JobHandle));
	}

	public JobHandle CheckJobIndirect(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckPosRadBatchJobIndirect checkPosRadBatchJobIndirect = default(CheckPosRadBatchJobIndirect);
		checkPosRadBatchJobIndirect.Grid = this;
		checkPosRadBatchJobIndirect.Pos = worldPositions;
		checkPosRadBatchJobIndirect.Radii = radii;
		checkPosRadBatchJobIndirect.OverlapIndices = overlapIndices;
		checkPosRadBatchJobIndirect.Indices = indices;
		CheckPosRadBatchJobIndirect checkPosRadBatchJobIndirect2 = checkPosRadBatchJobIndirect;
		return IJobExtensions.ScheduleByRef<CheckPosRadBatchJobIndirect>(ref checkPosRadBatchJobIndirect2, default(JobHandle));
	}

	public bool Check(Vector3 worldPosition, float radius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector2i min = WorldPosToStaticGrid(worldPosition - Vector3.one * radius);
		Vector2i max = WorldPosToStaticGrid(worldPosition + Vector3.one * radius);
		if (TouchesUpperSpatial(worldPosition, radius) && Check(min, max, _upperStaticSpatialArray))
		{
			return true;
		}
		if (TouchesLowerSpatial(worldPosition, radius) && Check(min, max, _lowerStaticSpatialArray))
		{
			return true;
		}
		float num = radius * radius;
		Enumerator<Bounds> enumerator = _dynamicBounds.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Bounds current = enumerator.Current;
				if (Vector3.SqrMagnitude(((Bounds)(ref current)).ClosestPoint(worldPosition) - worldPosition) <= num)
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	public bool CheckJob(Vector3 start, Vector3 end, float radius)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector3 val = Vector3.one * radius;
		Vector3 val2 = Vector3.Min(start, end) - val;
		Vector3 val3 = Vector3.Max(start, end) + val;
		Bounds checkBounds = default(Bounds);
		((Bounds)(ref checkBounds))..ctor((val3 + val2) * 0.5f, val3 - val2);
		return CheckJob(checkBounds);
	}

	public JobHandle CheckJobIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckBoundsJobIndirect checkBoundsJobIndirect = default(CheckBoundsJobIndirect);
		checkBoundsJobIndirect.Grid = this;
		checkBoundsJobIndirect.Starts = starts;
		checkBoundsJobIndirect.Ends = ends;
		checkBoundsJobIndirect.Radii = radii;
		checkBoundsJobIndirect.OverlapIndices = overlapIndices;
		checkBoundsJobIndirect.Indices = indices;
		CheckBoundsJobIndirect checkBoundsJobIndirect2 = checkBoundsJobIndirect;
		return IJobExtensions.ScheduleByRef<CheckBoundsJobIndirect>(ref checkBoundsJobIndirect2, default(JobHandle));
	}

	public bool Check(Vector3 start, Vector3 end, float radius)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector3 val = Vector3.one * radius;
		Vector3 val2 = Vector3.Min(start, end) - val;
		Vector3 val3 = Vector3.Max(start, end) + val;
		Bounds checkBounds = default(Bounds);
		((Bounds)(ref checkBounds))..ctor((val3 + val2) * 0.5f, val3 - val2);
		return Check(checkBounds);
	}

	private Vector2i WorldPosToStaticGrid(Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)((worldPosition.x + _gridCentre.x) / (float)_cellSize), (int)((worldPosition.z + _gridCentre.y) / (float)_cellSize));
	}

	private int GridToStaticIndex(Vector2i gridPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return math.clamp(gridPosition.x + gridPosition.y * _cellXZDimensionCount, 0, _cellClampLimit);
	}

	public void Dispose()
	{
		_hasDisposed = true;
		_result.Dispose();
		_dynamicBounds.Dispose();
		_upperStaticSpatialArray.Dispose();
		_lowerStaticSpatialArray.Dispose();
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public struct RefCountedSpatialArray : IDisposable
{
	private NativeArray<byte> _array;

	public NativeArray<byte> RawArray => _array;

	public int Length => _array.Length;

	public static RefCountedSpatialArray Init(int length)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		RefCountedSpatialArray result = default(RefCountedSpatialArray);
		result._array = new NativeArray<byte>(length, (Allocator)4, (NativeArrayOptions)1);
		return result;
	}

	public void Add(int index)
	{
		Debug.Assert(_array[index] != byte.MaxValue);
		ref NativeArray<byte> array = ref _array;
		byte b = array[index];
		array[index] = (byte)(b + 1);
	}

	public void Remove(int index)
	{
		Debug.Assert(_array[index] != 0);
		ref NativeArray<byte> array = ref _array;
		byte b = array[index];
		array[index] = (byte)(b - 1);
	}

	public bool Get(int index)
	{
		return _array[index] > 0;
	}

	public void Dispose()
	{
		_array.Dispose();
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Terrain Atlas Set")]
public class TerrainAtlasSet : ScriptableObject
{
	public enum SourceType
	{
		ALBEDO,
		NORMAL,
		PACKED,
		COUNT
	}

	[Serializable]
	public class SourceMapSet
	{
		public Texture2D[] maps;

		internal void CheckReset()
		{
			if (maps == null)
			{
				maps = (Texture2D[])(object)new Texture2D[8];
			}
			else if (maps.Length != 8)
			{
				Array.Resize(ref maps, 8);
			}
		}
	}

	public const int SplatCount = 8;

	public const int SplatSize = 2048;

	public const int MaxSplatSize = 2047;

	public const int SplatPadding = 256;

	public const int AtlasSize = 8192;

	public const int RegionSize = 2560;

	public const int SplatsPerLine = 3;

	public const int SourceTypeCount = 3;

	public const int AtlasMipCount = 10;

	public static string[] sourceTypeNames = new string[3] { "Albedo", "Normal", "Packed" };

	public static string[] sourceTypeNamesExt = new string[3] { "Albedo (rgb)", "Normal (rgb)", "Metal[ignored]_Height_AO_Gloss (rgba)" };

	public static string[] sourceTypePostfix = new string[3] { "_albedo", "_normal", "_metal_hm_ao_gloss" };

	public string[] splatNames;

	public bool[] albedoHighpass;

	public string[] albedoPaths;

	public Color[] defaultValues;

	public SourceMapSet[] sourceMaps;

	public bool highQualityCompression = true;

	public bool generateTextureAtlases = true;

	public bool generateTextureArrays;

	public string splatSearchPrefix = "terrain_";

	public string splatSearchFolder = "Assets/Content/Nature/Terrain";

	public string albedoAtlasSavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_albedo_atlas";

	public string normalAtlasSavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_normal_atlas";

	public string albedoArraySavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_albedo_array";

	public string normalArraySavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_normal_array";

	public void CheckReset()
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (splatNames == null)
		{
			splatNames = new string[8] { "Dirt", "Snow", "Sand", "Rock", "Grass", "Forest", "Stones", "Gravel" };
		}
		else if (splatNames.Length != 8)
		{
			Array.Resize(ref splatNames, 8);
		}
		if (albedoHighpass == null)
		{
			albedoHighpass = new bool[8];
		}
		else if (albedoHighpass.Length != 8)
		{
			Array.Resize(ref albedoHighpass, 8);
		}
		if (albedoPaths == null)
		{
			albedoPaths = new string[8];
		}
		else if (albedoPaths.Length != 8)
		{
			Array.Resize(ref albedoPaths, 8);
		}
		if (defaultValues == null)
		{
			defaultValues = (Color[])(object)new Color[3]
			{
				new Color(1f, 1f, 1f, 0.5f),
				new Color(0.5f, 0.5f, 1f, 0f),
				new Color(0f, 0f, 1f, 0.5f)
			};
		}
		else if (defaultValues.Length != 3)
		{
			Array.Resize(ref defaultValues, 3);
		}
		if (sourceMaps == null)
		{
			sourceMaps = new SourceMapSet[3];
		}
		else if (sourceMaps.Length != 3)
		{
			Array.Resize(ref sourceMaps, 3);
		}
		for (int i = 0; i < 3; i++)
		{
			sourceMaps[i] = ((sourceMaps[i] != null) ? sourceMaps[i] : new SourceMapSet());
			sourceMaps[i].CheckReset();
		}
	}
}


public enum SourceType
{
	ALBEDO,
	NORMAL,
	PACKED,
	COUNT
}


using System;
using UnityEngine;

[Serializable]
public class SourceMapSet
{
	public Texture2D[] maps;

	internal void CheckReset()
	{
		if (maps == null)
		{
			maps = (Texture2D[])(object)new Texture2D[8];
		}
		else if (maps.Length != 8)
		{
			Array.Resize(ref maps, 8);
		}
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public class TerrainCollision : TerrainExtension
{
	public TerrainIgnoreGrid TerrainIgnoreGrid;

	public ListDictionary<Collider, List<Collider>> ignoredColliders;

	public TerrainCollider terrainCollider;

	public const float IgnoreRadius = 0.01f;

	public override void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		terrainCollider = ((Component)terrain).GetComponent<TerrainCollider>();
		TerrainIgnoreGrid = new TerrainIgnoreGrid();
	}

	private void OnDestroy()
	{
		TerrainIgnoreGrid.Dispose();
	}

	public void Clear()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)terrainCollider))
		{
			return;
		}
		Enumerator<Collider> enumerator = ignoredColliders.Keys.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Physics.IgnoreCollision(enumerator.Current, (Collider)(object)terrainCollider, false);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if (Object.op_Implicit((Object)(object)terrainCollider) && Object.op_Implicit((Object)(object)collider))
		{
			Physics.IgnoreCollision(collider, (Collider)(object)terrainCollider, false);
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			if (TerrainIgnoreGrid != null && !TerrainIgnoreGrid.Check(pos, radius))
			{
				return false;
			}
			return GamePhysics.CheckSphere<TerrainCollisionTrigger>(pos, radius, 262144, (QueryTriggerInteraction)2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetIgnore(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> val2 = new NativeList<int>(positions.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val3;
			if (TerrainIgnoreGrid != null)
			{
				val3 = TerrainIgnoreGrid.Check(positions, radii, val2);
			}
			else
			{
				GenerateAscSeqListJob generateAscSeqListJob = default(GenerateAscSeqListJob);
				generateAscSeqListJob.Values = val2;
				generateAscSeqListJob.Start = 0;
				generateAscSeqListJob.Step = 1;
				generateAscSeqListJob.Count = positions.Length;
				val3 = IJobExtensions.Schedule<GenerateAscSeqListJob>(generateAscSeqListJob, default(JobHandle));
			}
			((JobHandle)(ref val3)).Complete();
			if (!val2.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = positions;
				gatherJob.Indices = val2.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = val2.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				new QueryParameters(262144, false, (QueryTriggerInteraction)2, false);
				GamePhysics.CheckSpheres<TerrainCollisionTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref results), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				Span<bool> values2 = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = val2.AsReadOnly();
				CollectionUtil.ScatterOutInplace(values2, ReadOnly<int>.op_Implicit(ref val4), defValue: false);
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(RaycastHit hit)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			if (!(((RaycastHit)(ref hit)).collider is TerrainCollider))
			{
				return false;
			}
			if (!TerrainIgnoreGrid.Check(((RaycastHit)(ref hit)).point))
			{
				return false;
			}
			return ((RaycastHit)(ref hit)).collider is TerrainCollider && GetIgnore(((RaycastHit)(ref hit)).point);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(Collider collider)
	{
		if (!Object.op_Implicit((Object)(object)terrainCollider) || !Object.op_Implicit((Object)(object)collider))
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (!Object.op_Implicit((Object)(object)terrainCollider) || !Object.op_Implicit((Object)(object)collider))
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> list = new List<Collider> { trigger };
				Physics.IgnoreCollision(collider, (Collider)(object)terrainCollider, true);
				ignoredColliders.Add(collider, list);
			}
			return;
		}
		List<Collider> list2 = ignoredColliders[collider];
		if (ignore)
		{
			if (!list2.Contains(trigger))
			{
				list2.Add(trigger);
			}
		}
		else if (list2.Contains(trigger))
		{
			list2.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if ((Object)(object)key == (Object)null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				Physics.IgnoreCollision(key, (Collider)(object)terrainCollider, false);
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}


using UnityEngine;

public class TerrainCollisionProxy : MonoBehaviour, IServerComponent
{
	public WheelCollider[] colliders;
}


using Rust;
using UnityEngine;

public class TerrainCollisionTrigger : EnvironmentVolumeTrigger
{
	protected override void OnVolumeTriggerUpdate()
	{
		TerrainMeta.Collision.TerrainIgnoreGrid.AddTrigger(this);
	}

	private void OnDisable()
	{
		if (!Application.isUnloadingWorld)
		{
			TerrainMeta.Collision.TerrainIgnoreGrid.RemoveTrigger(this);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !other.isTrigger)
		{
			UpdateCollider(other, state: true);
		}
	}

	protected void OnTriggerExit(Collider other)
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !other.isTrigger)
		{
			UpdateCollider(other, state: false);
		}
	}

	private void UpdateCollider(Collider other, bool state)
	{
		TerrainMeta.Collision.SetIgnore(other, base.volume.trigger, state);
		TerrainCollisionProxy component = ((Component)other).GetComponent<TerrainCollisionProxy>();
		if (Object.op_Implicit((Object)(object)component))
		{
			for (int i = 0; i < component.colliders.Length; i++)
			{
				TerrainMeta.Collision.SetIgnore((Collider)(object)component.colliders[i], base.volume.trigger, state);
			}
		}
	}
}


using UnityEngine;

public class TerrainColors : TerrainExtension
{
	private TerrainSplatMap splatMap;

	private TerrainBiomeMap biomeMap;

	public override void Setup()
	{
		splatMap = ((Component)terrain).GetComponent<TerrainSplatMap>();
		biomeMap = ((Component)terrain).GetComponent<TerrainBiomeMap>();
	}

	public Color GetColor(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetColor(normX, normZ, mask);
	}

	public Color GetColor(float normX, float normZ, int mask = -1)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		float biome = biomeMap.GetBiome(normX, normZ, 1);
		float biome2 = biomeMap.GetBiome(normX, normZ, 2);
		float biome3 = biomeMap.GetBiome(normX, normZ, 4);
		float biome4 = biomeMap.GetBiome(normX, normZ, 8);
		int num = TerrainSplat.TypeToIndex(splatMap.GetSplatMaxType(normX, normZ, mask));
		TerrainConfig.SplatType splatType = config.Splats[num];
		return biome * splatType.AridColor + biome2 * splatType.TemperateColor + biome3 * splatType.TundraColor + biome4 * splatType.ArcticColor;
	}
}


using System;
using Facepunch.Extend;
using UnityEngine;

[RequireComponent(typeof(TerrainMeta))]
public abstract class TerrainExtension : MonoBehaviour
{
	[NonSerialized]
	public bool isInitialized;

	internal Terrain terrain;

	internal TerrainConfig config;

	public void Init(Terrain terrain, TerrainConfig config)
	{
		this.terrain = terrain;
		this.config = config;
	}

	public virtual void Setup()
	{
	}

	public virtual void PostSetup()
	{
	}

	public void LogSize(object obj, ulong size)
	{
		Debug.Log((object)(obj.GetType()?.ToString() + " allocated: " + NumberExtensions.FormatBytes<ulong>(size, false)));
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainIgnoreGrid : ICoarseQueryGridProvider, IDisposable
{
	private CoarseQueryGrid _queryGrid;

	private const int CellSize = 8;

	public TerrainIgnoreGrid()
	{
		_queryGrid = new CoarseQueryGrid(8, (int)(World.Size + 1000), -5f);
	}

	public CoarseQueryGrid GetQueryGrid()
	{
		return _queryGrid;
	}

	public void AddTrigger(TerrainCollisionTrigger trigger)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.AddStatic(trigger.volume.trigger.bounds);
	}

	public void RemoveTrigger(TerrainCollisionTrigger trigger)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.RemoveStatic(trigger.volume.trigger.bounds);
	}

	public bool Check(Vector3 pos, float radius)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainIgnoreGrid.Check(pos,rad)", 0);
		try
		{
			return _queryGrid.CheckJob(pos, radius);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public JobHandle Check(ReadOnly<Vector3> starts, ReadOnly<float> radii, NativeList<int> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return _queryGrid.CheckJob(starts, radii, results);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return _queryGrid.CheckJobIndirect(pos, radii, indices, results);
	}

	public bool Check(Vector3 pos)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerraingIgnoreGrid.Check(pos)", 0);
		try
		{
			return _queryGrid.CheckJob(pos, 0f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Dispose()
	{
		_queryGrid.Dispose();
	}
}


using System;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Serialization;

public class TerrainAlphaMap : TerrainMap<byte>
{
	[FormerlySerializedAs("ColorTexture")]
	public Texture2D AlphaTexture;

	private bool _generatedAlphaTexture;

	public override void Setup()
	{
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				dst[i * res + j] = byte.MaxValue;
			}
		}
		if (!((Object)(object)AlphaTexture != (Object)null))
		{
			return;
		}
		if (((Texture)AlphaTexture).width == ((Texture)AlphaTexture).height && ((Texture)AlphaTexture).width == res)
		{
			Color32[] pixels = AlphaTexture.GetPixels32();
			int k = 0;
			int num = 0;
			for (; k < res; k++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					dst[k * res + num2] = pixels[num].a;
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid alpha texture: " + ((Object)AlphaTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedAlphaTexture && (Object)(object)AlphaTexture != (Object)null)
		{
			Object.Destroy((Object)(object)AlphaTexture);
			AlphaTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		AlphaTexture = new Texture2D(res, res, (TextureFormat)1, false, true);
		((Object)AlphaTexture).name = "AlphaTexture";
		((Texture)AlphaTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				byte b = src[z * res + i];
				col[z * res + i] = new Color32(b, b, b, b);
			}
		});
		AlphaTexture.SetPixels32(col);
		_generatedAlphaTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		AlphaTexture.Apply(true, false);
		AlphaTexture.Compress(false);
		AlphaTexture.Apply(false, true);
	}

	public float GetAlpha(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetAlpha(normX, normZ);
	}

	public float GetAlpha(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetAlpha(num4, num5), GetAlpha(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetAlpha(num4, z), GetAlpha(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetAlpha(int x, int z)
	{
		return BitUtility.Byte2Float((int)src[z * res + x]);
	}

	public void SetAlpha(Vector3 worldPos, float a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a);
	}

	public void SetAlpha(float normX, float normZ, float a)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetAlpha(x, z, a);
	}

	public void SetAlpha(int x, int z, float a)
	{
		dst[z * res + x] = BitUtility.Float2Byte(a);
	}

	public void SetAlpha(int x, int z, float a, float opacity)
	{
		SetAlpha(x, z, Mathf.Lerp(GetAlpha(x, z), a, opacity));
	}

	public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a, opacity, radius, fade);
	}

	public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			lerp *= opacity;
			if (lerp > 0f)
			{
				SetAlpha(x, z, a, lerp);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System.Threading.Tasks;
using Unity.Collections;
using UnityEngine;

public class TerrainBiomeMap : TerrainMap<byte>
{
	public Texture2D BiomeTexture;

	private bool _generatedBiomeTexture;

	internal int num;

	public override void Setup()
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		this.num = 5;
		InitArrays(this.num * res * res);
		if (!((Object)(object)BiomeTexture != (Object)null))
		{
			return;
		}
		if (((Texture)BiomeTexture).width == ((Texture)BiomeTexture).height && ((Texture)BiomeTexture).width == res)
		{
			Color32[] pixels = BiomeTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					ref NativeArray<byte> reference = ref dst;
					_ = res;
					reference[(0 + i) * res + num2] = val.r;
					dst[(res + i) * res + num2] = val.g;
					dst[(2 * res + i) * res + num2] = val.b;
					dst[(3 * res + i) * res + num2] = val.a;
					dst[(4 * res + i) * res + num2] = (byte)(255 - val.r - val.g - val.b - val.a);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid biome texture: " + ((Object)BiomeTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedBiomeTexture && (Object)(object)BiomeTexture != (Object)null)
		{
			Object.Destroy((Object)(object)BiomeTexture);
			BiomeTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		BiomeTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)BiomeTexture).name = "BiomeTexture";
		((Texture)BiomeTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				ref NativeArray<byte> reference = ref src;
				_ = res;
				byte b = reference[(0 + z) * res + i];
				byte b2 = src[(res + z) * res + i];
				byte b3 = src[(2 * res + z) * res + i];
				byte b4 = src[(3 * res + z) * res + i];
				col[z * res + i] = new Color32(b, b2, b3, b4);
			}
		});
		BiomeTexture.SetPixels32(col);
		_generatedBiomeTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		BiomeTexture.Apply(true, false);
		BiomeTexture.Compress(false);
		BiomeTexture.Apply(false, true);
	}

	public float GetBiomeMax(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (DeepSeaManager.IsInsideDeepSea(worldPos))
		{
			if ((mask & 0x20) == 0)
			{
				return 0f;
			}
			return 1f;
		}
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMax(normX, normZ, mask);
	}

	public float GetBiomeMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMax(x, z, mask);
	}

	public float GetBiomeMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return (int)b;
	}

	public int GetBiomeMaxIndex(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (DeepSeaManager.IsInsideDeepSea(worldPos))
		{
			if ((mask & 0x20) == 0)
			{
				return 0;
			}
			return 5;
		}
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMaxIndex(normX, normZ, mask);
	}

	public int GetBiomeMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMaxIndex(x, z, mask);
	}

	public int GetBiomeMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetBiomeMaxType(Vector3 worldPos, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(worldPos, mask));
	}

	public int GetBiomeMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(normX, normZ, mask));
	}

	public int GetBiomeMaxType(int x, int z, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(x, z, mask));
	}

	public float GetBiome(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (DeepSeaManager.IsInsideDeepSea(worldPos))
		{
			if ((mask & 0x20) == 0)
			{
				return 0f;
			}
			return 1f;
		}
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiome(normX, normZ, mask);
	}

	public float GetBiome(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiome(x, z, mask);
	}

	public float GetBiome(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			if (mask == 32)
			{
				return 0f;
			}
			return BitUtility.Byte2Float((int)src[(TerrainBiome.TypeToIndex(mask) * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	public void SetBiome(Vector3 worldPos, int id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id);
	}

	public void SetBiome(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id);
	}

	public void SetBiome(int x, int z, int id)
	{
		int num = TerrainBiome.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = byte.MaxValue;
			}
			else
			{
				dst[(i * res + z) * res + x] = 0;
			}
		}
	}

	public void SetBiome(Vector3 worldPos, int id, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id, v);
	}

	public void SetBiome(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id, v);
	}

	public void SetBiome(int x, int z, int id, float v)
	{
		SetBiome(x, z, id, GetBiome(x, z, id), v);
	}

	public void SetBiomeRaw(int x, int z, float biome0, float biome1, float biome2, float biome3, float biome4, float opacity)
	{
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(biome0 + biome1 + biome2 + biome3 + biome4);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				ref NativeArray<byte> reference = ref dst;
				_ = res;
				reference[(0 + z) * res + x] = BitUtility.Float2Byte(biome0);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(biome1);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(biome2);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(biome3);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(biome4);
			}
			else
			{
				ref NativeArray<byte> reference2 = ref dst;
				_ = res;
				int num3 = (0 + z) * res + x;
				ref NativeArray<byte> reference3 = ref src;
				_ = res;
				reference2[num3] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)reference3[(0 + z) * res + x]) * num2 + biome0 * opacity);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(res + z) * res + x]) * num2 + biome1 * opacity);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(2 * res + z) * res + x]) * num2 + biome2 * opacity);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(3 * res + z) * res + x]) * num2 + biome3 * opacity);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(4 * res + z) * res + x]) * num2 + biome4 * opacity);
			}
		}
	}

	private void SetBiome(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainBiome.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(new_val);
			}
			else
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(num2 * BitUtility.Byte2Float((int)dst[(i * res + z) * res + x]));
			}
		}
	}
}


using System;
using System.Threading.Tasks;
using UnityEngine;

public class TerrainBlendMap : TerrainMap<byte>
{
	public Texture2D BlendTexture;

	public override void Setup()
	{
		if ((Object)(object)BlendTexture != (Object)null)
		{
			if (((Texture)BlendTexture).width == ((Texture)BlendTexture).height)
			{
				res = ((Texture)BlendTexture).width;
				InitArrays(res * res);
				Color32[] pixels = BlendTexture.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						dst[i * res + num2] = pixels[num].a;
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError((object)("Invalid alpha texture: " + ((Object)BlendTexture).name));
			}
			return;
		}
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		for (int j = 0; j < res; j++)
		{
			for (int k = 0; k < res; k++)
			{
				dst[j * res + k] = 0;
			}
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		BlendTexture = new Texture2D(res, res, (TextureFormat)1, true, true);
		((Object)BlendTexture).name = "BlendTexture";
		((Texture)BlendTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				byte b = src[z * res + i];
				col[z * res + i] = new Color32(b, b, b, b);
			}
		});
		BlendTexture.SetPixels32(col);
	}

	public void ApplyTextures()
	{
		BlendTexture.Apply(true, false);
		BlendTexture.Compress(false);
		BlendTexture.Apply(false, true);
	}

	public float GetAlpha(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetAlpha(normX, normZ);
	}

	public float GetAlpha(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetAlpha(num4, num5), GetAlpha(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetAlpha(num4, z), GetAlpha(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetAlpha(int x, int z)
	{
		return BitUtility.Byte2Float((int)src[z * res + x]);
	}

	public void SetAlpha(Vector3 worldPos, float a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a);
	}

	public void SetAlpha(float normX, float normZ, float a)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetAlpha(x, z, a);
	}

	public void SetAlpha(int x, int z, float a)
	{
		dst[z * res + x] = BitUtility.Float2Byte(a);
	}

	public void SetAlpha(int x, int z, float a, float opacity)
	{
		SetAlpha(x, z, Mathf.Lerp(GetAlpha(x, z), a, opacity));
	}

	public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a, opacity, radius, fade);
	}

	public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			lerp *= opacity;
			if (lerp > 0f)
			{
				SetAlpha(x, z, a, lerp);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System.Threading.Tasks;
using Unity.Collections;
using UnityEngine;

public class TerrainDistanceMap : TerrainMap<byte>
{
	public Texture2D DistanceTexture;

	public override void Setup()
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(4 * res * res);
		if (!((Object)(object)DistanceTexture != (Object)null))
		{
			return;
		}
		if (((Texture)DistanceTexture).width == ((Texture)DistanceTexture).height && ((Texture)DistanceTexture).width == res)
		{
			Color32[] pixels = DistanceTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					SetDistance(num2, i, BitUtility.DecodeVector2i(pixels[num]));
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid distance texture: " + ((Object)DistanceTexture).name), (Object)(object)DistanceTexture);
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		DistanceTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)DistanceTexture).name = "DistanceTexture";
		((Texture)DistanceTexture).wrapMode = (TextureWrapMode)1;
		Color32[] cols = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				cols[z * res + i] = BitUtility.EncodeVector2i(GetDistance(i, z));
			}
		});
		DistanceTexture.SetPixels32(cols);
	}

	public void ApplyTextures()
	{
		DistanceTexture.Apply(true, true);
	}

	public Vector2i GetDistance(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetDistance(normX, normZ);
	}

	public Vector2i GetDistance(float normX, float normZ)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x = Mathf.Clamp(Mathf.RoundToInt(normX * (float)num), 0, num);
		int z = Mathf.Clamp(Mathf.RoundToInt(normZ * (float)num), 0, num);
		return GetDistance(x, z);
	}

	public Vector2i GetDistance(int x, int z)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<byte> reference = ref src;
		_ = res;
		byte b = reference[(0 + z) * res + x];
		byte b2 = src[(res + z) * res + x];
		byte b3 = src[(2 * res + z) * res + x];
		byte b4 = src[(3 * res + z) * res + x];
		if (b == byte.MaxValue && b2 == byte.MaxValue && b3 == byte.MaxValue && b4 == byte.MaxValue)
		{
			return new Vector2i(256, 256);
		}
		return new Vector2i(b - b2, b3 - b4);
	}

	public void SetDistance(int x, int z, Vector2i v)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<byte> reference = ref dst;
		_ = res;
		reference[(0 + z) * res + x] = (byte)Mathf.Clamp(v.x, 0, 255);
		dst[(res + z) * res + x] = (byte)Mathf.Clamp(-v.x, 0, 255);
		dst[(2 * res + z) * res + x] = (byte)Mathf.Clamp(v.y, 0, 255);
		dst[(3 * res + z) * res + x] = (byte)Mathf.Clamp(-v.y, 0, 255);
	}
}


using System;
using System.Threading.Tasks;
using TerrainHeightMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;

public class TerrainHeightMap : TerrainMap<short>
{
	public struct HeightMapQueryStructure
	{
		public ReadOnly<short> Data;

		public int Res;

		public Vector3 TerrainPosition;

		public Vector3 TerrainSize;

		public Vector3 TerrainOneOverSize;

		public readonly float GetHeightFast(Vector2 uv)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			int num = Res - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? Res : 0);
			int num10 = num5 * Res + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = (float)Data[num10] * 3.051944E-05f;
			float num15 = (float)Data[num11] * 3.051944E-05f;
			float num16 = (float)Data[num12] * 3.051944E-05f;
			float num17 = (float)Data[num13] * 3.051944E-05f;
			float num18 = (num15 - num14) * num6 + num14;
			float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
			return TerrainPosition.y + num19 * TerrainSize.y;
		}
	}

	public Texture2D HeightTexture;

	public Texture2D NormalTexture;

	public float normY;

	private bool _generatedHeightTexture;

	private bool _generatedNormalTexture;

	public NativeArray<short> deepSeaHeights;

	public override void Setup()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
		deepSeaHeights = new NativeArray<short>(res * res, (Allocator)4, (NativeArrayOptions)1);
		ResetDeepSeaToFloor();
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
		if (!((Object)(object)HeightTexture != (Object)null))
		{
			return;
		}
		if (((Texture)HeightTexture).width == ((Texture)HeightTexture).height && ((Texture)HeightTexture).width == res)
		{
			Color32[] pixels = HeightTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					dst[i * res + num2] = BitUtility.DecodeShort(val);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid height texture: " + ((Object)HeightTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		NativeArrayEx.SafeDispose(ref deepSeaHeights);
		if (_generatedHeightTexture && (Object)(object)HeightTexture != (Object)null)
		{
			Object.Destroy((Object)(object)HeightTexture);
			HeightTexture = null;
		}
		if (_generatedNormalTexture && (Object)(object)NormalTexture != (Object)null)
		{
			Object.Destroy((Object)(object)NormalTexture);
			NormalTexture = null;
		}
	}

	public void ResetDeepSeaToFloor()
	{
		short num = BitUtility.Float2Short(TerrainMeta.NormalizeY(DeepSeaManager.SeaFloorDepth));
		for (int i = 0; i < res * res; i++)
		{
			deepSeaHeights[i] = num;
		}
	}

	public void ApplyToTerrain()
	{
		float[,] heights = terrain.terrainData.GetHeights(0, 0, res, res);
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				heights[z, i] = GetHeight01(i, z);
			}
		});
		terrain.terrainData.SetHeights(0, 0, heights);
		TerrainCollider component = ((Component)terrain).GetComponent<TerrainCollider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Collider)component).enabled = false;
			((Collider)component).enabled = true;
		}
	}

	public void GenerateTextures(bool heightTexture = true, bool normalTexture = true)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Expected O, but got Unknown
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		if (heightTexture)
		{
			Color32[] heights = (Color32[])(object)new Color32[res * res];
			Parallel.For(0, res, delegate(int z)
			{
				//IL_0038: Unknown result type (might be due to invalid IL or missing references)
				//IL_003d: Unknown result type (might be due to invalid IL or missing references)
				for (int i = 0; i < res; i++)
				{
					heights[z * res + i] = BitUtility.EncodeShort(src[z * res + i]);
				}
			});
			HeightTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
			((Object)HeightTexture).name = "HeightTexture";
			((Texture)HeightTexture).wrapMode = (TextureWrapMode)1;
			HeightTexture.SetPixels32(heights);
			HeightTexture.ignoreMipmapLimit = true;
			_generatedHeightTexture = Application.isPlaying;
		}
		if (!normalTexture)
		{
			return;
		}
		int normalres = (res - 1) / 2;
		Color32[] normals = (Color32[])(object)new Color32[normalres * normalres];
		Parallel.For(0, normalres, delegate(int z)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			float normZ = ((float)z + 0.5f) / (float)normalres;
			for (int j = 0; j < normalres; j++)
			{
				float normX = ((float)j + 0.5f) / (float)normalres;
				Vector3 normal = GetNormal(normX, normZ);
				float num = Vector3.Angle(Vector3.up, normal);
				float num2 = Mathf.InverseLerp(50f, 70f, num);
				normal = Vector3.Slerp(normal, Vector3.up, num2);
				normals[z * normalres + j] = Color32.op_Implicit(BitUtility.EncodeNormal(normal));
			}
		});
		NormalTexture = new Texture2D(normalres, normalres, (TextureFormat)4, false, true);
		((Object)NormalTexture).name = "NormalTexture";
		((Texture)NormalTexture).wrapMode = (TextureWrapMode)1;
		NormalTexture.SetPixels32(normals);
		_generatedNormalTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		HeightTexture.Apply(true, false);
		NormalTexture.Apply(true, false);
		NormalTexture.Compress(false);
		HeightTexture.Apply(false, true);
		NormalTexture.Apply(false, true);
	}

	public float GetHeight(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		float num;
		if (DeepSeaManager.IsInsideDeepSea(worldPos))
		{
			float normX = DeepSeaManager.NormalizeX(worldPos.x);
			float normZ = DeepSeaManager.NormalizeZ(worldPos.z);
			num = GetDeepSeaHeight01(normX, normZ);
		}
		else
		{
			float normX2 = TerrainMeta.NormalizeX(worldPos.x);
			float normZ2 = TerrainMeta.NormalizeZ(worldPos.z);
			num = GetHeight01(normX2, normZ2);
		}
		return TerrainMeta.Position.y + num * TerrainMeta.Size.y;
	}

	public JobHandle GetHeights(ReadOnly<Vector3> worldPos, NativeArray<float> results, JobHandle inputDeps = default(JobHandle))
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsJob getHeightsJob = default(GetHeightsJob);
		getHeightsJob.Heights = results;
		getHeightsJob.Pos = worldPos;
		getHeightsJob.Data = src.AsReadOnly();
		getHeightsJob.DeepSeaData = deepSeaHeights.AsReadOnly();
		getHeightsJob.DeepSeaBounds = DeepSeaManager.DeepSeaBounds;
		getHeightsJob.Res = res;
		getHeightsJob.TerrainPos = TerrainMeta.Position;
		getHeightsJob.TerrainScale = TerrainMeta.Size.y;
		getHeightsJob.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
		GetHeightsJob jobData = getHeightsJob;
		return ParallelJobEx.ScheduleParallel<GetHeightsJob>(ref jobData, worldPos.Length, inputDeps);
	}

	public void GetHeightsIndirect(ReadOnly<Vector3> worldPos, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsJobIndirect getHeightsJobIndirect = default(GetHeightsJobIndirect);
		getHeightsJobIndirect.Heights = results;
		getHeightsJobIndirect.Pos = worldPos;
		getHeightsJobIndirect.Data = src.AsReadOnly();
		getHeightsJobIndirect.Res = res;
		getHeightsJobIndirect.TerrainPos = TerrainMeta.Position;
		getHeightsJobIndirect.TerrainScale = TerrainMeta.Size.y;
		getHeightsJobIndirect.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
		getHeightsJobIndirect.Indices = indices;
		GetHeightsJobIndirect getHeightsJobIndirect2 = getHeightsJobIndirect;
		IJobExtensions.RunByRef<GetHeightsJobIndirect>(ref getHeightsJobIndirect2);
	}

	public float GetHeight(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public HeightMapQueryStructure GetQueryStructure()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		HeightMapQueryStructure result = default(HeightMapQueryStructure);
		result.Data = src.AsReadOnly();
		result.Res = res;
		result.TerrainPosition = TerrainMeta.Position;
		result.TerrainSize = TerrainMeta.Size;
		result.TerrainOneOverSize = TerrainMeta.OneOverSize;
		return result;
	}

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainMeta.Position.y + num19 * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public void GetHeightsFastIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsFastJobIndirect getHeightsFastJobIndirect = default(GetHeightsFastJobIndirect);
		getHeightsFastJobIndirect.Heights = results;
		getHeightsFastJobIndirect.UVs = uvs;
		getHeightsFastJobIndirect.Indices = indices;
		getHeightsFastJobIndirect.Data = src.AsReadOnly();
		getHeightsFastJobIndirect.Res = res;
		getHeightsFastJobIndirect.TerrainPos = TerrainMeta.Position.y;
		getHeightsFastJobIndirect.TerrainScale = TerrainMeta.Size.y;
		GetHeightsFastJobIndirect getHeightsFastJobIndirect2 = getHeightsFastJobIndirect;
		IJobExtensions.RunByRef<GetHeightsFastJobIndirect>(ref getHeightsFastJobIndirect2);
	}

	public float GetDeepSeaHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float deepSeaHeight = GetDeepSeaHeight01(num4, num5);
		float deepSeaHeight2 = GetDeepSeaHeight01(x, num5);
		float deepSeaHeight3 = GetDeepSeaHeight01(num4, z);
		float deepSeaHeight4 = GetDeepSeaHeight01(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		float num8 = Mathf.Lerp(deepSeaHeight, deepSeaHeight2, num6);
		float num9 = Mathf.Lerp(deepSeaHeight3, deepSeaHeight4, num6);
		return Mathf.Lerp(num8, num9, num7);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float height = GetHeight01(num4, num5);
		float height2 = GetHeight01(x, num5);
		float height3 = GetHeight01(num4, z);
		float height4 = GetHeight01(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		float num8 = Mathf.Lerp(height, height2, num6);
		float num9 = Mathf.Lerp(height3, height4, num6);
		return Mathf.Lerp(num8, num9, num7);
	}

	public float GetHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	public float GetDeepSeaHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)deepSeaHeights[z * res + x]);
	}

	private float GetSrcHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	private float GetDstHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)dst[z * res + x]);
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		Vector3 normal = GetNormal(num4, num5);
		Vector3 normal2 = GetNormal(x, num5);
		Vector3 normal3 = GetNormal(num4, z);
		Vector3 normal4 = GetNormal(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		Vector3 val = Vector3.Slerp(normal, normal2, num6);
		Vector3 val2 = Vector3.Slerp(normal3, normal4, num6);
		Vector3 val3 = Vector3.Slerp(val, val2, num7);
		return ((Vector3)(ref val3)).normalized;
	}

	public Vector3 GetNormal(int x, int z)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = (GetHeight01(x3, z2) - GetHeight01(x2, z2)) * 0.5f;
		float num3 = (GetHeight01(x2, z3) - GetHeight01(x2, z2)) * 0.5f;
		Vector3 val = new Vector3(0f - num2, normY, 0f - num3);
		return ((Vector3)(ref val)).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z * res + x] = BitUtility.Float2Short(height);
	}

	public void SetHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height, opacity);
	}

	public void SetHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height, opacity);
	}

	public void SetHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity);
		SetHeight(x, z, height2);
	}

	public void AddHeight(Vector3 worldPos, float delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddHeight(normX, normZ, delta);
	}

	public void AddHeight(float normX, float normZ, float delta)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddHeight(x, z, delta);
	}

	public void AddHeight(int x, int z, float delta)
	{
		float height = Mathf.Clamp01(GetDstHeight01(x, z) + delta);
		SetHeight(x, z, height);
	}

	public void LowerHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		LowerHeight(normX, normZ, height, opacity);
	}

	public void LowerHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		LowerHeight(x, z, height, opacity);
	}

	public void LowerHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.Min(GetDstHeight01(x, z), Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity));
		SetHeight(x, z, height2);
	}

	public void RaiseHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RaiseHeight(normX, normZ, height, opacity);
	}

	public void RaiseHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		RaiseHeight(x, z, height, opacity);
	}

	public void RaiseHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.Max(GetDstHeight01(x, z), Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity));
		SetHeight(x, z, height2);
	}

	public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		SetHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				SetHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		LowerHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				LowerHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		RaiseHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				RaiseHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddHeight(Vector3 worldPos, float delta, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddHeight(normX, normZ, delta, radius, fade);
	}

	public void AddHeight(float normX, float normZ, float delta, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				AddHeight(x, z, lerp * delta);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using Unity.Collections;
using UnityEngine;

public struct HeightMapQueryStructure
{
	public ReadOnly<short> Data;

	public int Res;

	public Vector3 TerrainPosition;

	public Vector3 TerrainSize;

	public Vector3 TerrainOneOverSize;

	public readonly float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? Res : 0);
		int num10 = num5 * Res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)Data[num10] * 3.051944E-05f;
		float num15 = (float)Data[num11] * 3.051944E-05f;
		float num16 = (float)Data[num12] * 3.051944E-05f;
		float num17 = (float)Data[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainPosition.y + num19 * TerrainSize.y;
	}
}


using System;
using UnityEngine;

public abstract class TerrainMap : TerrainExtension
{
	internal int res;

	public void ApplyFilter(float normX, float normZ, float radius, float fade, Action<int, int, float> action)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		float num2 = TerrainMeta.OneOverSize.x * fade;
		float num3 = (float)res * (num - num2);
		float num4 = (float)res * num;
		float num5 = normX * (float)res;
		float num6 = normZ * (float)res;
		int num7 = Index(normX - num);
		int num8 = Index(normX + num);
		int num9 = Index(normZ - num);
		int num10 = Index(normZ + num);
		Vector2 val;
		if (num3 != num4)
		{
			for (int i = num9; i <= num10; i++)
			{
				for (int j = num7; j <= num8; j++)
				{
					val = new Vector2((float)j + 0.5f - num5, (float)i + 0.5f - num6);
					float magnitude = ((Vector2)(ref val)).magnitude;
					float arg = Mathf.InverseLerp(num4, num3, magnitude);
					action(j, i, arg);
				}
			}
			return;
		}
		for (int k = num9; k <= num10; k++)
		{
			for (int l = num7; l <= num8; l++)
			{
				val = new Vector2((float)l + 0.5f - num5, (float)k + 0.5f - num6);
				float arg2 = ((((Vector2)(ref val)).magnitude < num4) ? 1 : 0);
				action(l, k, arg2);
			}
		}
	}

	public void ForEach(Vector3 worldPos, float radius, Action<int, int> action)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(TerrainMeta.NormalizeX(worldPos.x - radius));
		int num2 = Index(TerrainMeta.NormalizeX(worldPos.x + radius));
		int num3 = Index(TerrainMeta.NormalizeZ(worldPos.z - radius));
		int num4 = Index(TerrainMeta.NormalizeZ(worldPos.z + radius));
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num; j <= num2; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEach(float normX, float normZ, float normRadius, Action<int, int> action)
	{
		int num = Index(normX - normRadius);
		int num2 = Index(normX + normRadius);
		int num3 = Index(normZ - normRadius);
		int num4 = Index(normZ + normRadius);
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num; j <= num2; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v3 = default(Vector2i);
		((Vector2i)(ref v3))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		ForEachParallel(v3, v4, v5, action);
	}

	public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathx.Min(v0.x, v1.x, v2.x);
		int num2 = Mathx.Max(v0.x, v1.x, v2.x);
		int num3 = Mathx.Min(v0.y, v1.y, v2.y);
		int num4 = Mathx.Max(v0.y, v1.y, v2.y);
		Vector2i base_min = new Vector2i(num, num3);
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num2, num4);
		Vector2i base_count = val - base_min + Vector2i.one;
		ParallelEx.Call((Action<int, int>)delegate(int thread_id, int thread_count)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			Vector2i min = base_min + base_count * thread_id / thread_count;
			Vector2i max = base_min + base_count * (thread_id + 1) / thread_count - Vector2i.one;
			ForEachInternal(v0, v1, v2, action, min, max);
		});
	}

	public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v3 = default(Vector2i);
		((Vector2i)(ref v3))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		ForEach(v3, v4, v5, action);
	}

	public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector2i min = default(Vector2i);
		((Vector2i)(ref min))..ctor(int.MinValue, int.MinValue);
		Vector2i max = default(Vector2i);
		((Vector2i)(ref max))..ctor(int.MaxValue, int.MaxValue);
		ForEachInternal(v0, v1, v2, action, min, max);
	}

	private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action, Vector2i min, Vector2i max)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.Max(min.x, Mathx.Min(v0.x, v1.x, v2.x));
		int num2 = Mathf.Min(max.x, Mathx.Max(v0.x, v1.x, v2.x));
		int num3 = Mathf.Max(min.y, Mathx.Min(v0.y, v1.y, v2.y));
		int num4 = Mathf.Min(max.y, Mathx.Max(v0.y, v1.y, v2.y));
		int num5 = v0.y - v1.y;
		int num6 = v1.x - v0.x;
		int num7 = v1.y - v2.y;
		int num8 = v2.x - v1.x;
		int num9 = v2.y - v0.y;
		int num10 = v0.x - v2.x;
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num, num3);
		int num11 = (v2.x - v1.x) * (val.y - v1.y) - (v2.y - v1.y) * (val.x - v1.x);
		int num12 = (v0.x - v2.x) * (val.y - v2.y) - (v0.y - v2.y) * (val.x - v2.x);
		int num13 = (v1.x - v0.x) * (val.y - v0.y) - (v1.y - v0.y) * (val.x - v0.x);
		val.y = num3;
		while (val.y <= num4)
		{
			int num14 = num11;
			int num15 = num12;
			int num16 = num13;
			val.x = num;
			while (val.x <= num2)
			{
				if ((num14 | num15 | num16) >= 0)
				{
					action(val.x, val.y);
				}
				num14 += num7;
				num15 += num9;
				num16 += num5;
				val.x++;
			}
			num11 += num8;
			num12 += num10;
			num13 += num6;
			val.y++;
		}
	}

	public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v6 = default(Vector2i);
		((Vector2i)(ref v6))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		Vector2i v7 = default(Vector2i);
		((Vector2i)(ref v7))..ctor(Index(TerrainMeta.NormalizeX(v3.x)), Index(TerrainMeta.NormalizeZ(v3.z)));
		ForEachParallel(v4, v5, v6, v7, action);
	}

	public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathx.Min(v0.x, v1.x, v2.x, v3.x);
		int num2 = Mathx.Max(v0.x, v1.x, v2.x, v3.x);
		int num3 = Mathx.Min(v0.y, v1.y, v2.y, v3.y);
		int num4 = Mathx.Max(v0.y, v1.y, v2.y, v3.y);
		Vector2i base_min = new Vector2i(num, num3);
		Vector2i val = new Vector2i(num2, num4) - base_min + Vector2i.one;
		Vector2i size_x = new Vector2i(val.x, 0);
		Vector2i size_y = new Vector2i(0, val.y);
		ParallelEx.Call((Action<int, int>)delegate(int thread_id, int thread_count)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			Vector2i min = base_min + size_y * thread_id / thread_count;
			Vector2i max = base_min + size_y * (thread_id + 1) / thread_count + size_x - Vector2i.one;
			ForEachInternal(v0, v1, v2, v3, action, min, max);
		});
	}

	public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v6 = default(Vector2i);
		((Vector2i)(ref v6))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		Vector2i v7 = default(Vector2i);
		((Vector2i)(ref v7))..ctor(Index(TerrainMeta.NormalizeX(v3.x)), Index(TerrainMeta.NormalizeZ(v3.z)));
		ForEach(v4, v5, v6, v7, action);
	}

	public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Vector2i min = default(Vector2i);
		((Vector2i)(ref min))..ctor(int.MinValue, int.MinValue);
		Vector2i max = default(Vector2i);
		((Vector2i)(ref max))..ctor(int.MaxValue, int.MaxValue);
		ForEachInternal(v0, v1, v2, v3, action, min, max);
	}

	private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action, Vector2i min, Vector2i max)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.Max(min.x, Mathx.Min(v0.x, v1.x, v2.x, v3.x));
		int num2 = Mathf.Min(max.x, Mathx.Max(v0.x, v1.x, v2.x, v3.x));
		int num3 = Mathf.Max(min.y, Mathx.Min(v0.y, v1.y, v2.y, v3.y));
		int num4 = Mathf.Min(max.y, Mathx.Max(v0.y, v1.y, v2.y, v3.y));
		int num5 = v0.y - v1.y;
		int num6 = v1.x - v0.x;
		int num7 = v1.y - v2.y;
		int num8 = v2.x - v1.x;
		int num9 = v2.y - v0.y;
		int num10 = v0.x - v2.x;
		int num11 = v3.y - v2.y;
		int num12 = v2.x - v3.x;
		int num13 = v2.y - v1.y;
		int num14 = v1.x - v2.x;
		int num15 = v1.y - v3.y;
		int num16 = v3.x - v1.x;
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num, num3);
		int num17 = (v2.x - v1.x) * (val.y - v1.y) - (v2.y - v1.y) * (val.x - v1.x);
		int num18 = (v0.x - v2.x) * (val.y - v2.y) - (v0.y - v2.y) * (val.x - v2.x);
		int num19 = (v1.x - v0.x) * (val.y - v0.y) - (v1.y - v0.y) * (val.x - v0.x);
		int num20 = (v1.x - v2.x) * (val.y - v2.y) - (v1.y - v2.y) * (val.x - v2.x);
		int num21 = (v3.x - v1.x) * (val.y - v1.y) - (v3.y - v1.y) * (val.x - v1.x);
		int num22 = (v2.x - v3.x) * (val.y - v3.y) - (v2.y - v3.y) * (val.x - v3.x);
		val.y = num3;
		while (val.y <= num4)
		{
			int num23 = num17;
			int num24 = num18;
			int num25 = num19;
			int num26 = num20;
			int num27 = num21;
			int num28 = num22;
			val.x = num;
			while (val.x <= num2)
			{
				if ((num23 | num24 | num25) >= 0 || (num26 | num27 | num28) >= 0)
				{
					action(val.x, val.y);
				}
				num23 += num7;
				num24 += num9;
				num25 += num5;
				num26 += num13;
				num27 += num15;
				num28 += num11;
				val.x++;
			}
			num17 += num8;
			num18 += num10;
			num19 += num6;
			num20 += num14;
			num21 += num16;
			num22 += num12;
			val.y++;
		}
	}

	public void ForEach(int x_min, int x_max, int z_min, int z_max, Action<int, int> action)
	{
		for (int i = z_min; i <= z_max; i++)
		{
			for (int j = x_min; j <= x_max; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEach(Action<int, int> action)
	{
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				action(j, i);
			}
		}
	}

	public int Index(float normalized)
	{
		int num = (int)(normalized * (float)res);
		if (num >= 0)
		{
			if (num <= res - 1)
			{
				return num;
			}
			return res - 1;
		}
		return 0;
	}

	public float Coordinate(int index)
	{
		return ((float)index + 0.5f) / (float)res;
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public abstract class TerrainMap<T> : TerrainMap, IDisposable where T : unmanaged
{
	internal NativeArray<T> src;

	internal NativeArray<T> dst;

	public void InitArrays(int size)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		src = (dst = new NativeArray<T>(size, (Allocator)4, (NativeArrayOptions)1));
	}

	public void Push()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!(src != dst))
		{
			Debug.Assert(src == dst);
			dst = new NativeArray<T>(src, (Allocator)4);
		}
	}

	public void Pop()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!(src == dst))
		{
			Debug.Assert(src.IsCreated);
			Debug.Assert(dst.IsCreated);
			src.CopyFrom(dst);
			Debug.Assert(src != dst);
			dst.Dispose();
			dst = src;
		}
	}

	public IEnumerable<T> ToEnumerable()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerable<T>)(object)src;
	}

	public int BytesPerElement()
	{
		return UnsafeUtility.SizeOf<T>();
	}

	public long GetMemoryUsage()
	{
		return (long)BytesPerElement() * (long)src.Length;
	}

	public byte[] ToByteArray()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return src.Reinterpret<byte>(UnsafeUtility.SizeOf<T>()).ToArray();
	}

	public void FromByteArray(byte[] dat)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (dat == null)
		{
			throw new ArgumentNullException("dat");
		}
		if (!dst.IsCreated)
		{
			throw new InvalidOperationException("Destination NativeArray is not created");
		}
		int num = UnsafeUtility.SizeOf<T>();
		NativeSlice<byte> val = default(NativeSlice<byte>);
		val..ctor(dst.Reinterpret<byte>(num), 0, dat.Length);
		val.CopyFrom(dat);
	}

	public void OnDestroy()
	{
		Dispose();
	}

	public virtual void Dispose()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (src != dst)
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
			if (dst.IsCreated)
			{
				dst.Dispose();
			}
		}
		else if (src.IsCreated)
		{
			src.Dispose();
		}
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainPlacementMap : TerrainMap<bool>
{
	private bool isEnabled;

	public override void Setup()
	{
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		Enable();
	}

	public override void PostSetup()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		res = 0;
		if (src == dst)
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
		}
		else
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
			if (dst.IsCreated)
			{
				dst.Dispose();
			}
		}
		src = default(NativeArray<bool>);
		dst = default(NativeArray<bool>);
		Disable();
	}

	public void Enable()
	{
		isEnabled = true;
	}

	public void Disable()
	{
		isEnabled = false;
	}

	public void Reset()
	{
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				dst[i * res + j] = false;
			}
		}
	}

	public bool GetBlocked(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBlocked(normX, normZ);
	}

	public bool GetBlocked(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBlocked(x, z);
	}

	public bool GetBlocked(int x, int z)
	{
		if (!isEnabled || res <= 0)
		{
			return false;
		}
		return src[z * res + x];
	}

	public void SetBlocked(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBlocked(normX, normZ);
	}

	public void SetBlocked(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBlocked(x, z);
	}

	public void SetBlocked(int x, int z)
	{
		dst[z * res + x] = true;
	}

	public bool GetBlocked(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBlocked(normX, normZ, radius);
	}

	public bool GetBlocked(float normX, float normZ, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		int num2 = Index(normX - num);
		int num3 = Index(normX + num);
		int num4 = Index(normZ - num);
		int num5 = Index(normZ + num);
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				if (src[i * res + j])
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SetBlocked(Vector3 worldPos, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBlocked(normX, normZ, radius, fade);
	}

	public void SetBlocked(float normX, float normZ, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				dst[z * res + x] = true;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using System.Threading.Tasks;
using Unity.Collections;
using UnityEngine;

public class TerrainSplatMap : TerrainMap<byte>
{
	public Texture2D SplatTexture0;

	public Texture2D SplatTexture1;

	private bool _generatedSplatTexture0;

	private bool _generatedSplatTexture1;

	internal int num;

	public override void Setup()
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		this.num = config.Splats.Length;
		InitArrays(this.num * res * res);
		if ((Object)(object)SplatTexture0 != (Object)null)
		{
			if (((Texture)SplatTexture0).width == ((Texture)SplatTexture0).height && ((Texture)SplatTexture0).width == res)
			{
				Color32[] pixels = SplatTexture0.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						Color32 val = pixels[num];
						if (this.num > 0)
						{
							ref NativeArray<byte> reference = ref dst;
							_ = res;
							reference[(0 + i) * res + num2] = val.r;
						}
						if (this.num > 1)
						{
							dst[(res + i) * res + num2] = val.g;
						}
						if (this.num > 2)
						{
							dst[(2 * res + i) * res + num2] = val.b;
						}
						if (this.num > 3)
						{
							dst[(3 * res + i) * res + num2] = val.a;
						}
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError((object)("Invalid splat texture: " + ((Object)SplatTexture0).name), (Object)(object)SplatTexture0);
			}
		}
		if (!((Object)(object)SplatTexture1 != (Object)null))
		{
			return;
		}
		if (((Texture)SplatTexture1).width == ((Texture)SplatTexture1).height && ((Texture)SplatTexture1).width == res && this.num > 5)
		{
			Color32[] pixels2 = SplatTexture1.GetPixels32();
			int j = 0;
			int num3 = 0;
			for (; j < res; j++)
			{
				int num4 = 0;
				while (num4 < res)
				{
					Color32 val2 = pixels2[num3];
					if (this.num > 4)
					{
						dst[(4 * res + j) * res + num4] = val2.r;
					}
					if (this.num > 5)
					{
						dst[(5 * res + j) * res + num4] = val2.g;
					}
					if (this.num > 6)
					{
						dst[(6 * res + j) * res + num4] = val2.b;
					}
					if (this.num > 7)
					{
						dst[(7 * res + j) * res + num4] = val2.a;
					}
					num4++;
					num3++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid splat texture: " + ((Object)SplatTexture1).name), (Object)(object)SplatTexture1);
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedSplatTexture0 && (Object)(object)SplatTexture0 != (Object)null)
		{
			Object.Destroy((Object)(object)SplatTexture0);
			SplatTexture0 = null;
		}
		if (_generatedSplatTexture1 && (Object)(object)SplatTexture1 != (Object)null)
		{
			Object.Destroy((Object)(object)SplatTexture1);
			SplatTexture1 = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		SplatTexture0 = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)SplatTexture0).name = "SplatTexture0";
		((Texture)SplatTexture0).wrapMode = (TextureWrapMode)1;
		Color32[] cols = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				int num;
				if (this.num <= 0)
				{
					num = 0;
				}
				else
				{
					ref NativeArray<byte> reference = ref src;
					_ = res;
					num = reference[(0 + z) * res + i];
				}
				byte b = (byte)num;
				byte b2 = (byte)((this.num > 1) ? src[(res + z) * res + i] : 0);
				byte b3 = (byte)((this.num > 2) ? src[(2 * res + z) * res + i] : 0);
				byte b4 = (byte)((this.num > 3) ? src[(3 * res + z) * res + i] : 0);
				cols[z * res + i] = new Color32(b, b2, b3, b4);
			}
		});
		SplatTexture0.SetPixels32(cols);
		_generatedSplatTexture0 = Application.isPlaying;
		SplatTexture1 = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)SplatTexture1).name = "SplatTexture1";
		((Texture)SplatTexture1).wrapMode = (TextureWrapMode)1;
		Color32[] cols2 = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			for (int j = 0; j < res; j++)
			{
				byte b5 = (byte)((num > 4) ? src[(4 * res + z) * res + j] : 0);
				byte b6 = (byte)((num > 5) ? src[(5 * res + z) * res + j] : 0);
				byte b7 = (byte)((num > 6) ? src[(6 * res + z) * res + j] : 0);
				byte b8 = (byte)((num > 7) ? src[(7 * res + z) * res + j] : 0);
				cols2[z * res + j] = new Color32(b5, b6, b7, b8);
			}
		});
		SplatTexture1.SetPixels32(cols2);
		_generatedSplatTexture1 = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		SplatTexture0.Apply(true, true);
		SplatTexture1.Apply(true, true);
	}

	public float GetSplatMax(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplatMax(normX, normZ, mask);
	}

	public float GetSplatMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetSplatMax(x, z, mask);
	}

	public float GetSplatMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return BitUtility.Byte2Float((int)b);
	}

	public int GetSplatMaxIndex(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplatMaxIndex(normX, normZ, mask);
	}

	public int GetSplatMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetSplatMaxIndex(x, z, mask);
	}

	public int GetSplatMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetSplatMaxType(Vector3 worldPos, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TerrainSplat.IndexToType(GetSplatMaxIndex(worldPos, mask));
	}

	public int GetSplatMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainSplat.IndexToType(GetSplatMaxIndex(normX, normZ, mask));
	}

	public int GetSplatMaxType(int x, int z, int mask = -1)
	{
		return TerrainSplat.IndexToType(GetSplatMaxIndex(x, z, mask));
	}

	public float GetSplat(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplat(normX, normZ, mask);
	}

	public float GetSplat(float normX, float normZ, int mask)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetSplat(num4, num5, mask), GetSplat(x, num5, mask), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetSplat(num4, z, mask), GetSplat(x, z, mask), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetSplat(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(TerrainSplat.TypeToIndex(mask) * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	public void SetSplat(Vector3 worldPos, int id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id);
	}

	public void SetSplat(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetSplat(x, z, id);
	}

	public void SetSplat(int x, int z, int id)
	{
		int num = TerrainSplat.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = byte.MaxValue;
			}
			else
			{
				dst[(i * res + z) * res + x] = 0;
			}
		}
	}

	public void SetSplat(Vector3 worldPos, int id, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id, v);
	}

	public void SetSplat(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetSplat(x, z, id, v);
	}

	public void SetSplat(int x, int z, int id, float v)
	{
		SetSplat(x, z, id, GetSplat(x, z, id), v);
	}

	public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				ref NativeArray<byte> reference = ref dst;
				_ = res;
				reference[(0 + z) * res + x] = BitUtility.Float2Byte(v1.x);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(v1.y);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(v1.z);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(v1.w);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(v2.x);
				dst[(5 * res + z) * res + x] = BitUtility.Float2Byte(v2.y);
				dst[(6 * res + z) * res + x] = BitUtility.Float2Byte(v2.z);
				dst[(7 * res + z) * res + x] = BitUtility.Float2Byte(v2.w);
			}
			else
			{
				ref NativeArray<byte> reference2 = ref dst;
				_ = res;
				int num3 = (0 + z) * res + x;
				ref NativeArray<byte> reference3 = ref src;
				_ = res;
				reference2[num3] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)reference3[(0 + z) * res + x]) * num2 + v1.x * opacity);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(res + z) * res + x]) * num2 + v1.y * opacity);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(2 * res + z) * res + x]) * num2 + v1.z * opacity);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(3 * res + z) * res + x]) * num2 + v1.w * opacity);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(4 * res + z) * res + x]) * num2 + v2.x * opacity);
				dst[(5 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(5 * res + z) * res + x]) * num2 + v2.y * opacity);
				dst[(6 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(6 * res + z) * res + x]) * num2 + v2.z * opacity);
				dst[(7 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(7 * res + z) * res + x]) * num2 + v2.w * opacity);
			}
		}
	}

	public void AddSplat(Vector3 worldPos, int id, float d)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddSplat(normX, normZ, id, d);
	}

	public void AddSplat(float normX, float normZ, int id, float d)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddSplat(x, z, id, d);
	}

	public void AddSplat(int x, int z, int id, float d)
	{
		float splat = GetSplat(x, z, id);
		SetSplat(x, z, id, splat, Mathf.Clamp01(splat + d));
	}

	public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id, opacity, radius, fade);
	}

	public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade = 0f)
	{
		int idx = TerrainSplat.TypeToIndex(id);
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				float num = BitUtility.Byte2Float((int)dst[(idx * res + z) * res + x]);
				float new_val = Mathf.Lerp(num, 1f, lerp * opacity);
				SetSplat(x, z, id, num, new_val);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddSplat(normX, normZ, id, delta, radius, fade);
	}

	public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade = 0f)
	{
		int idx = TerrainSplat.TypeToIndex(id);
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				float num = BitUtility.Byte2Float((int)dst[(idx * res + z) * res + x]);
				float new_val = Mathf.Clamp01(num + lerp * delta);
				SetSplat(x, z, id, num, new_val);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void RemoveSplat(Vector3 worldPos, int id, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RemoveSplat(normX, normZ, id, opacity, radius, fade);
	}

	public void RemoveSplat(float normX, float normZ, int id, float opacity, float radius, float fade = 0f)
	{
		int a_idx = TerrainSplat.TypeToIndex(id);
		int b_idx = 0;
		switch (TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ))
		{
		case 1:
			b_idx = TerrainSplat.TypeToIndex(4);
			break;
		case 2:
			b_idx = TerrainSplat.TypeToIndex(16);
			break;
		case 4:
			b_idx = TerrainSplat.TypeToIndex(16);
			break;
		case 8:
			b_idx = TerrainSplat.TypeToIndex(2);
			break;
		}
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				int num = (a_idx * res + z) * res + x;
				int num2 = (b_idx * res + z) * res + x;
				float num3 = BitUtility.Byte2Float((int)dst[num]);
				float num4 = BitUtility.Byte2Float((int)dst[num2]);
				float num5 = lerp * opacity * num3;
				float num6 = Mathf.Clamp01(num3 - num5);
				float num7 = Mathf.Clamp01(num4 + num5);
				dst[num] = BitUtility.Float2Byte(num6);
				dst[num2] = BitUtility.Float2Byte(num7);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	private void SetSplat(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainSplat.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(new_val);
			}
			else
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(num2 * BitUtility.Byte2Float((int)dst[(i * res + z) * res + x]));
			}
		}
	}
}


using System;
using System.Threading;
using System.Threading.Tasks;
using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;

public class TerrainTopologyMap : TerrainMap<int>
{
	public struct TopologyQueryStructure
	{
		public ReadOnly<int> source;

		public int res;

		[BurstCompile]
		public readonly int GetTopologyFast(Vector2 uv)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			if (Hint.Unlikely(!source.IsCreated))
			{
				return 0;
			}
			int num = res - 1;
			int num2 = (int)(uv.x * (float)res);
			int num3 = (int)(uv.y * (float)res);
			num2 = ((num2 >= 0) ? num2 : 0);
			num3 = ((num3 >= 0) ? num3 : 0);
			num2 = ((num2 <= num) ? num2 : num);
			num3 = ((num3 <= num) ? num3 : num);
			return source[num3 * res + num2];
		}

		public readonly bool GetTopology(float normX, float normZ, int mask)
		{
			int x = Index(normX);
			int z = Index(normZ);
			return GetTopology(x, z, mask);
		}

		public readonly int Index(float normalized)
		{
			int num = (int)(normalized * (float)res);
			if (num >= 0)
			{
				if (num <= res - 1)
				{
					return num;
				}
				return res - 1;
			}
			return 0;
		}

		public readonly bool GetTopology(int x, int z, int mask)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return (source[z * res + x] & mask) != 0;
		}
	}

	public Texture2D TopologyTexture;

	private bool _generatedTopologyTexture;

	private ThreadLocal<NativeReference<int>> topoNative = new ThreadLocal<NativeReference<int>>(() => new NativeReference<int>(0, AllocatorHandle.op_Implicit((Allocator)4)), trackAllValues: true);

	public override void Setup()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		if (!((Object)(object)TopologyTexture != (Object)null))
		{
			return;
		}
		if (((Texture)TopologyTexture).width == ((Texture)TopologyTexture).height && ((Texture)TopologyTexture).width == res)
		{
			Color32[] pixels = TopologyTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					dst[i * res + num2] = BitUtility.DecodeInt(pixels[num]);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid topology texture: " + ((Object)TopologyTexture).name));
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		TopologyTexture = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)TopologyTexture).name = "TopologyTexture";
		((Texture)TopologyTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				col[z * res + i] = BitUtility.EncodeInt(src[z * res + i]);
			}
		});
		TopologyTexture.SetPixels32(col);
		_generatedTopologyTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		TopologyTexture.Apply(false, true);
	}

	public bool GetTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ, mask);
	}

	public bool GetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z, mask);
	}

	public bool GetTopology(int x, int z, int mask)
	{
		return (src[z * res + x] & mask) != 0;
	}

	public int GetTopology(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ);
	}

	public int GetTopology(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z);
	}

	public int GetTopologyFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int num2 = (int)(uv.x * (float)res);
		int num3 = (int)(uv.y * (float)res);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		return src[num3 * res + num2];
	}

	public TopologyQueryStructure GetQueryStructure()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		TopologyQueryStructure result = default(TopologyQueryStructure);
		result.source = src.AsReadOnly();
		result.res = res;
		return result;
	}

	public int GetTopology(int x, int z)
	{
		return src[z * res + x];
	}

	public void GetTopologies(NativeArray<Vector3> worldPos, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByPosJob getTopologyByPosJob = default(GetTopologyByPosJob);
		getTopologyByPosJob.Topologies = results;
		getTopologyByPosJob.Pos = worldPos;
		getTopologyByPosJob.Data = src;
		getTopologyByPosJob.Res = res;
		getTopologyByPosJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		getTopologyByPosJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		GetTopologyByPosJob getTopologyByPosJob2 = getTopologyByPosJob;
		IJobExtensions.RunByRef<GetTopologyByPosJob>(ref getTopologyByPosJob2);
	}

	public void GetTopologies(NativeArray<Vector2> uvs, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByUVJob getTopologyByUVJob = default(GetTopologyByUVJob);
		getTopologyByUVJob.Topologies = results;
		getTopologyByUVJob.UV = uvs;
		getTopologyByUVJob.Data = src;
		getTopologyByUVJob.Res = res;
		GetTopologyByUVJob getTopologyByUVJob2 = getTopologyByUVJob;
		IJobExtensions.RunByRef<GetTopologyByUVJob>(ref getTopologyByUVJob2);
	}

	public void GetTopologies(NativeArray<Vector2i> indices, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByIndexJob getTopologyByIndexJob = default(GetTopologyByIndexJob);
		getTopologyByIndexJob.Topologies = results;
		getTopologyByIndexJob.Indices = indices;
		getTopologyByIndexJob.Data = src;
		getTopologyByIndexJob.Res = res;
		GetTopologyByIndexJob getTopologyByIndexJob2 = getTopologyByIndexJob;
		IJobExtensions.RunByRef<GetTopologyByIndexJob>(ref getTopologyByIndexJob2);
	}

	public void GetTopologiesIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByUVJobIndirect getTopologyByUVJobIndirect = default(GetTopologyByUVJobIndirect);
		getTopologyByUVJobIndirect.Topologies = results;
		getTopologyByUVJobIndirect.UV = uvs;
		getTopologyByUVJobIndirect.Indices = indices;
		getTopologyByUVJobIndirect.Data = src.AsReadOnly();
		getTopologyByUVJobIndirect.Res = res;
		GetTopologyByUVJobIndirect getTopologyByUVJobIndirect2 = getTopologyByUVJobIndirect;
		IJobExtensions.RunByRef<GetTopologyByUVJobIndirect>(ref getTopologyByUVJobIndirect2);
	}

	public JobHandle GetTopologiesIndirect(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, NativeArray<int> results, JobHandle inputDeps = default(JobHandle))
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyRadiusJobIndirect getTopologyRadiusJobIndirect = default(GetTopologyRadiusJobIndirect);
		getTopologyRadiusJobIndirect.WorldX = TerrainMeta.Position.x;
		getTopologyRadiusJobIndirect.WorldZ = TerrainMeta.Position.z;
		getTopologyRadiusJobIndirect.OneOverSizeX = TerrainMeta.OneOverSize.x;
		getTopologyRadiusJobIndirect.OneOverSizeZ = TerrainMeta.OneOverSize.z;
		getTopologyRadiusJobIndirect.Src = src.AsReadOnly();
		getTopologyRadiusJobIndirect.Res = res;
		getTopologyRadiusJobIndirect.WorldPositions = worldPositions;
		getTopologyRadiusJobIndirect.Radii = radii;
		getTopologyRadiusJobIndirect.Topologies = results;
		GetTopologyRadiusJobIndirect jobData = getTopologyRadiusJobIndirect;
		return ParallelJobEx.ScheduleParallelByRef<GetTopologyRadiusJobIndirect>(ref jobData, worldPositions.Length, inputDeps);
	}

	public void GetTopologiesIndirect(ReadOnly<Vector2> normalizedCoords, ReadOnly<float> radii, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyRadiusNormalizedJobIndirect getTopologyRadiusNormalizedJobIndirect = default(GetTopologyRadiusNormalizedJobIndirect);
		getTopologyRadiusNormalizedJobIndirect.OneOverSizeX = TerrainMeta.OneOverSize.x;
		getTopologyRadiusNormalizedJobIndirect.Src = src.AsReadOnly();
		getTopologyRadiusNormalizedJobIndirect.Res = res;
		getTopologyRadiusNormalizedJobIndirect.WorldNXZ = normalizedCoords;
		getTopologyRadiusNormalizedJobIndirect.Radii = radii;
		getTopologyRadiusNormalizedJobIndirect.Topologies = results;
		GetTopologyRadiusNormalizedJobIndirect jobData = getTopologyRadiusNormalizedJobIndirect;
		int length = normalizedCoords.Length;
		JobHandle dependsOn = default(JobHandle);
		dependsOn = ParallelJobEx.ScheduleParallelByRef<GetTopologyRadiusNormalizedJobIndirect>(ref jobData, length, dependsOn);
		((JobHandle)(ref dependsOn)).Complete();
	}

	public void SetTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetTopology(normX, normZ, mask);
	}

	public void SetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetTopology(x, z, mask);
	}

	public void SetTopology(int x, int z, int mask)
	{
		dst[z * res + x] = mask;
	}

	public void AddTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddTopology(normX, normZ, mask);
	}

	public void AddTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddTopology(x, z, mask);
	}

	public void AddTopology(int x, int z, int mask)
	{
		ref NativeArray<int> reference = ref dst;
		int num = z * res + x;
		reference[num] |= mask;
	}

	public void RemoveTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RemoveTopology(normX, normZ, mask);
	}

	public void RemoveTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		RemoveTopology(x, z, mask);
	}

	public void RemoveTopology(int x, int z, int mask)
	{
		ref NativeArray<int> reference = ref dst;
		int num = z * res + x;
		reference[num] &= ~mask;
	}

	public int GetTopology(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ, radius);
	}

	public int GetTopologyJob(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopologyJob(normX, normZ, radius);
	}

	public int GetTopologyJob(float normX, float normZ, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		int x_mid = Index(normX);
		int z_mid = Index(normZ);
		int x_min = Index(normX - num);
		int x_max = Index(normX + num);
		int z_min = Index(normZ - num);
		int z_max = Index(normZ + num);
		NativeReference<int> value = topoNative.Value;
		GetTopologyRadiusJob getTopologyRadiusJob = default(GetTopologyRadiusJob);
		getTopologyRadiusJob.Res = res;
		getTopologyRadiusJob.Src = src.AsReadOnly();
		getTopologyRadiusJob.Topo = value;
		getTopologyRadiusJob.radius = radius;
		getTopologyRadiusJob.x_mid = x_mid;
		getTopologyRadiusJob.z_mid = z_mid;
		getTopologyRadiusJob.x_min = x_min;
		getTopologyRadiusJob.x_max = x_max;
		getTopologyRadiusJob.z_min = z_min;
		getTopologyRadiusJob.z_max = z_max;
		GetTopologyRadiusJob getTopologyRadiusJob2 = getTopologyRadiusJob;
		IJobExtensions.RunByRef<GetTopologyRadiusJob>(ref getTopologyRadiusJob2);
		return value.Value;
	}

	public int GetTopology(float normX, float normZ, float radius)
	{
		return GetTopologyJob(normX, normZ, radius);
	}

	public void SetTopology(Vector3 worldPos, int mask, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetTopology(normX, normZ, mask, radius, fade);
	}

	public void SetTopology(float normX, float normZ, int mask, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				dst[z * res + x] = mask;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddTopology(Vector3 worldPos, int mask, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddTopology(normX, normZ, mask, radius, fade);
	}

	public void AddTopology(float normX, float normZ, int mask, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				ref NativeArray<int> reference = ref dst;
				int num = z * res + x;
				reference[num] |= mask;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public override void Dispose()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.Dispose();
		if (_generatedTopologyTexture && (Object)(object)TopologyTexture != (Object)null)
		{
			Object.Destroy((Object)(object)TopologyTexture);
			TopologyTexture = null;
		}
		foreach (NativeReference<int> value in topoNative.Values)
		{
			if (value.IsCreated)
			{
				value.Dispose();
			}
		}
	}
}


using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using UnityEngine;

public struct TopologyQueryStructure
{
	public ReadOnly<int> source;

	public int res;

	[BurstCompile]
	public readonly int GetTopologyFast(Vector2 uv)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (Hint.Unlikely(!source.IsCreated))
		{
			return 0;
		}
		int num = res - 1;
		int num2 = (int)(uv.x * (float)res);
		int num3 = (int)(uv.y * (float)res);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		return source[num3 * res + num2];
	}

	public readonly bool GetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z, mask);
	}

	public readonly int Index(float normalized)
	{
		int num = (int)(normalized * (float)res);
		if (num >= 0)
		{
			if (num <= res - 1)
			{
				return num;
			}
			return res - 1;
		}
		return 0;
	}

	public readonly bool GetTopology(int x, int z, int mask)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return (source[z * res + x] & mask) != 0;
	}
}


using System;
using System.Threading.Tasks;
using Facepunch;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class TerrainWaterFlowMap : TerrainMap<byte>
{
	private const float TwoPi = MathF.PI * 2f;

	public override void Setup()
	{
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
	}

	public override void PostSetup()
	{
		TimeWarning val = TimeWarning.New("TerrainWaterFlowMap.PostSetup", 0);
		try
		{
			WriteWaterFlowFromShoreVectors();
			WriteWaterFlowFromRivers();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void WriteWaterFlowFromShoreVectors()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<Vector2> normalizedCoords = new NativeArray<Vector2>(res * res, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<float> radii = new NativeArray<float>(res * res, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<int> topologies = new NativeArray<int>(res * res, (Allocator)3, (NativeArrayOptions)1);
		Parallel.For(0, res, delegate(int z)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			float num = Coordinate(z);
			for (int i = 0; i < res; i++)
			{
				float num2 = Coordinate(i);
				normalizedCoords[z * res + i] = new Vector2(num2, num);
				radii[z * res + i] = 16f;
			}
		});
		TerrainMeta.TopologyMap.GetTopologiesIndirect(normalizedCoords.AsReadOnly(), radii.AsReadOnly(), topologies);
		TerrainTexturing.ShoreData shoreMap = TerrainTexturing.Instance.GetMap(isDeepSea: false);
		Parallel.For(0, res, delegate(int z)
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			float num3 = Coordinate(z);
			Vector3 flow = default(Vector3);
			for (int j = 0; j < res; j++)
			{
				float num4 = Coordinate(j);
				int num5 = topologies[z * res + j];
				Vector4 rawShoreVector = shoreMap.GetRawShoreVector(new Vector2(num4, num3));
				((Vector3)(ref flow))..ctor(rawShoreVector.x, 0f, rawShoreVector.y);
				if ((num5 & 0x14080) != 0)
				{
					SetFlowDirection(num4, num3, flow);
				}
			}
		});
		normalizedCoords.Dispose(default(JobHandle));
		radii.Dispose(default(JobHandle));
		topologies.Dispose(default(JobHandle));
	}

	private void WriteWaterFlowFromRivers()
	{
		foreach (PathList river in TerrainMeta.Path.Rivers)
		{
			river.AdjustTerrainWaterFlow(scaleWidthWithLength: true);
		}
	}

	public Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFlowDirection(normX, normZ);
	}

	public Vector3 GetFlowDirection(Vector2 worldPos2D)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos2D.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos2D.y);
		return GetFlowDirection(normX, normZ);
	}

	public Vector3 GetFlowDirection(float normX, float normZ)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(normX);
		int num2 = Index(normZ);
		float num3 = ByteToAngle(src[num2 * res + num]);
		return new Vector3(Mathf.Sin(num3), 0f, Mathf.Cos(num3));
	}

	public void SetFlowDirection(Vector3 worldPos, Vector3 flow)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetFlowDirection(normX, normZ, flow);
	}

	public void SetFlowDirection(float normX, float normZ, Vector3 flow)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(normX);
		int num2 = Index(normZ);
		Vector3 val = Vector3Extensions.XZ(flow, 0f);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		byte b = AngleToByte(Mathf.Atan2(normalized.x, normalized.z));
		src[num2 * res + num] = b;
	}

	public static float ByteToAngle(byte b)
	{
		return (float)(int)b / 255f * (MathF.PI * 2f) - MathF.PI;
	}

	private static byte AngleToByte(float a)
	{
		a = Mathf.Clamp(a, -MathF.PI, MathF.PI);
		return (byte)Mathf.RoundToInt((a + MathF.PI) / (MathF.PI * 2f) * 255f);
	}

	public NativeArray<float3> GetFlowDirections(NativeArray<Vector3> positions3D, Allocator allocator)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<float3> results = default(NativeArray<float3>);
		results..ctor(positions3D.Length, allocator, (NativeArrayOptions)1);
		TerrainWaterFlowMapBurst.GetFlowDirections(in positions3D, ref results, in src, in res);
		return results;
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
public static class TerrainWaterFlowMapBurst
{
	internal delegate void GetFlowDirections_00006212$PostfixBurstDelegate(in NativeArray<Vector3> positions3D, ref NativeArray<float3> results, in NativeArray<byte> source, in int res);

	internal static class GetFlowDirections_00006212$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(GetFlowDirections_00006212$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static GetFlowDirections_00006212$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in NativeArray<Vector3> positions3D, ref NativeArray<float3> results, in NativeArray<byte> source, in int res)
		{
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref NativeArray<Vector3>, ref NativeArray<float3>, ref NativeArray<byte>, ref int, void>)functionPointer)(ref positions3D, ref results, ref source, ref res);
					return;
				}
			}
			GetFlowDirections$BurstManaged(in positions3D, ref results, in source, in res);
		}
	}

	[BurstCompile]
	public static void GetFlowDirections(in NativeArray<Vector3> positions3D, ref NativeArray<float3> results, in NativeArray<byte> source, in int res)
	{
		GetFlowDirections_00006212$BurstDirectCall.Invoke(in positions3D, ref results, in source, in res);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void GetFlowDirections$BurstManaged(in NativeArray<Vector3> positions3D, ref NativeArray<float3> results, in NativeArray<byte> source, in int res)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		TerrainMeta.BurstData data = TerrainMeta.sharedBurstData.Data;
		Vector3 position = data.Position;
		Vector3 oneOverSize = data.OneOverSize;
		for (int i = 0; i < positions3D.Length; i++)
		{
			Vector3 val = positions3D[i];
			float num = (val.x - position.x) * oneOverSize.x;
			float num2 = (val.z - position.z) * oneOverSize.z;
			int num3 = (int)(num * (float)(res - 1));
			int num4 = (int)(num2 * (float)(res - 1));
			num3 = math.clamp(num3, 0, res - 1);
			num4 = math.clamp(num4, 0, res - 1);
			float num5 = TerrainWaterFlowMap.ByteToAngle(source[num4 * res + num3]);
			results[i] = new float3(math.sin(num5), 0f, math.cos(num5));
		}
	}
}


using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

internal delegate void GetFlowDirections_00006212$PostfixBurstDelegate(in NativeArray<Vector3> positions3D, ref NativeArray<float3> results, in NativeArray<byte> source, in int res);


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

internal static class GetFlowDirections_00006212$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(GetFlowDirections_00006212$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static GetFlowDirections_00006212$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in NativeArray<Vector3> positions3D, ref NativeArray<float3> results, in NativeArray<byte> source, in int res)
	{
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref NativeArray<Vector3>, ref NativeArray<float3>, ref NativeArray<byte>, ref int, void>)functionPointer)(ref positions3D, ref results, ref source, ref res);
				return;
			}
		}
		GetFlowDirections$BurstManaged(in positions3D, ref results, in source, in res);
	}
}


using System.Threading.Tasks;
using TerrainWaterMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainWaterMap : TerrainMap<short>
{
	public struct WaterMapQueryStructure
	{
		public ReadOnly<short> src;

		public int res;

		public Vector2 Position;

		public Vector2 Size;

		public float GetHeightFast(Vector2 uv, bool isDeepSea)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (isDeepSea)
			{
				return -50f;
			}
			int num = res - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? res : 0);
			int num10 = num5 * res + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = (float)src[num10] * 3.051944E-05f;
			float num15 = (float)src[num11] * 3.051944E-05f;
			float num16 = (float)src[num12] * 3.051944E-05f;
			float num17 = (float)src[num13] * 3.051944E-05f;
			float num18 = (num15 - num14) * num6 + num14;
			float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
			return Position.y + num19 * Size.y;
		}
	}

	public Texture2D WaterTexture;

	private bool _generatedWaterTexture;

	private float normY;

	public override void Setup()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
		if (!((Object)(object)WaterTexture != (Object)null))
		{
			return;
		}
		if (((Texture)WaterTexture).width == ((Texture)WaterTexture).height && ((Texture)WaterTexture).width == res)
		{
			Color32[] pixels = WaterTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					dst[i * res + num2] = BitUtility.DecodeShort(val);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid water texture: " + ((Object)WaterTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedWaterTexture && (Object)(object)WaterTexture != (Object)null)
		{
			Object.Destroy((Object)(object)WaterTexture);
			WaterTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Expected O, but got Unknown
		Color32[] heights = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				heights[z * res + i] = BitUtility.EncodeShort(src[z * res + i]);
			}
		});
		WaterTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)WaterTexture).name = "WaterTexture";
		((Texture)WaterTexture).wrapMode = (TextureWrapMode)1;
		WaterTexture.SetPixels32(heights);
		_generatedWaterTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		WaterTexture.Apply(true, true);
	}

	private float DeepSeaDepth()
	{
		return DeepSeaManager.SeaFloorDepth;
	}

	public float GetHeight(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (DeepSeaManager.IsInsideDeepSea(worldPos))
		{
			return DeepSeaDepth();
		}
		return TerrainMeta.Position.y + GetHeight01(worldPos) * TerrainMeta.Size.y;
	}

	public float GetHeight(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public float GetHeightFast(Vector2 uv, bool isDeepSea)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		if (isDeepSea)
		{
			return DeepSeaDepth();
		}
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainMeta.Position.y + num19 * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public void GetHeights(NativeArray<Vector3> worldPos, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByPosJob getHeightByPosJob = default(GetHeightByPosJob);
		getHeightByPosJob.Heights = results;
		getHeightByPosJob.Pos = worldPos;
		getHeightByPosJob.Data = src;
		getHeightByPosJob.Res = res;
		getHeightByPosJob.Offset = TerrainMeta.Position.y;
		getHeightByPosJob.Scale = TerrainMeta.Size.y;
		getHeightByPosJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		getHeightByPosJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		GetHeightByPosJob getHeightByPosJob2 = getHeightByPosJob;
		IJobExtensions.RunByRef<GetHeightByPosJob>(ref getHeightByPosJob2);
	}

	public WaterMapQueryStructure GetQueryStructure()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		WaterMapQueryStructure result = default(WaterMapQueryStructure);
		result.res = res;
		result.Position = Vector2.op_Implicit(TerrainMeta.Position);
		result.Size = Vector2.op_Implicit(TerrainMeta.Size);
		result.src = src.AsReadOnly();
		return result;
	}

	public GetHeightByUVJob FetchUVsHeightsJob(NativeArray<Vector2> uvs, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJob result = default(GetHeightByUVJob);
		result.Heights = results;
		result.UV = uvs;
		result.Data = src;
		result.Res = res;
		result.Offset = TerrainMeta.Position.y;
		result.Scale = TerrainMeta.Size.y;
		return result;
	}

	public void GetHeights(NativeArray<Vector2> uvs, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJob getHeightByUVJob = default(GetHeightByUVJob);
		getHeightByUVJob.Heights = results;
		getHeightByUVJob.UV = uvs;
		getHeightByUVJob.Data = src;
		getHeightByUVJob.Res = res;
		getHeightByUVJob.Offset = TerrainMeta.Position.y;
		getHeightByUVJob.Scale = TerrainMeta.Size.y;
		GetHeightByUVJob getHeightByUVJob2 = getHeightByUVJob;
		IJobExtensions.RunByRef<GetHeightByUVJob>(ref getHeightByUVJob2);
	}

	public void GetHeightsIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJobIndirect getHeightByUVJobIndirect = default(GetHeightByUVJobIndirect);
		getHeightByUVJobIndirect.Heights = results;
		getHeightByUVJobIndirect.UV = uvs;
		getHeightByUVJobIndirect.Indices = indices;
		getHeightByUVJobIndirect.Data = src.AsReadOnly();
		getHeightByUVJobIndirect.Res = res;
		getHeightByUVJobIndirect.Offset = TerrainMeta.Position.y;
		getHeightByUVJobIndirect.Scale = TerrainMeta.Size.y;
		GetHeightByUVJobIndirect getHeightByUVJobIndirect2 = getHeightByUVJobIndirect;
		IJobExtensions.RunByRef<GetHeightByUVJobIndirect>(ref getHeightByUVJobIndirect2);
	}

	public void GetHeights(NativeArray<Vector2i> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByIndexJob getHeightByIndexJob = default(GetHeightByIndexJob);
		getHeightByIndexJob.Heights = results;
		getHeightByIndexJob.Indices = indices;
		getHeightByIndexJob.Data = src;
		getHeightByIndexJob.Res = res;
		getHeightByIndexJob.Offset = TerrainMeta.Position.y;
		getHeightByIndexJob.Scale = TerrainMeta.Size.y;
		GetHeightByIndexJob getHeightByIndexJob2 = getHeightByIndexJob;
		IJobExtensions.RunByRef<GetHeightByIndexJob>(ref getHeightByIndexJob2);
	}

	public float GetHeight01(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetHeight01(normX, normZ);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetHeight01(num4, num5), GetHeight01(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetHeight01(num4, z), GetHeight01(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = GetHeight01(x, num5) - GetHeight01(num4, num5);
		float num7 = GetHeight01(num4, z) - GetHeight01(num4, num5);
		Vector3 val = new Vector3(0f - num6, normY, 0f - num7);
		return ((Vector3)(ref val)).normalized;
	}

	public Vector3 GetNormalFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int num2 = (int)(uv.x * (float)num);
		int num3 = (int)(uv.y * (float)num);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		int num4 = ((num2 < num) ? 1 : 0);
		int num5 = ((num3 < num) ? res : 0);
		int num6 = num3 * res + num2;
		int num7 = num6 + num4;
		int num8 = num6 + num5;
		short num9 = src[num6];
		short num10 = src[num7];
		short num11 = src[num8];
		float num12 = (float)(num10 - num9) * 3.051944E-05f;
		float num13 = (float)(num11 - num9) * 3.051944E-05f;
		return new Vector3(0f - num12, normY, 0f - num13);
	}

	public Vector3 GetNormal(int x, int z)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = (GetHeight01(x3, z2) - GetHeight01(x2, z2)) * 0.5f;
		float num3 = (GetHeight01(x2, z3) - GetHeight01(x2, z2)) * 0.5f;
		Vector3 val = new Vector3(0f - num2, normY, 0f - num3);
		return ((Vector3)(ref val)).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public float GetDepth(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetHeight(worldPos) - TerrainMeta.HeightMap.GetHeight(worldPos);
	}

	public float GetDepth(float normX, float normZ)
	{
		return GetHeight(normX, normZ) - TerrainMeta.HeightMap.GetHeight(normX, normZ);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z * res + x] = BitUtility.Float2Short(height);
	}
}


using Unity.Collections;
using UnityEngine;

public struct WaterMapQueryStructure
{
	public ReadOnly<short> src;

	public int res;

	public Vector2 Position;

	public Vector2 Size;

	public float GetHeightFast(Vector2 uv, bool isDeepSea)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (isDeepSea)
		{
			return -50f;
		}
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return Position.y + num19 * Size.y;
	}
}


using UnityEngine;

public class TerrainMargin
{
	private static MaterialPropertyBlock materialPropertyBlock;

	public static void Create()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		Material marginMaterial = TerrainMeta.Config.MarginMaterial;
		Vector3 center = TerrainMeta.Center;
		Vector3 size = TerrainMeta.Size;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(size.x, 0f, 0f);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(0f, 0f, size.z);
		center.y = TerrainMeta.HeightMap.GetHeight(0, 0);
		Create(center - val2, size, marginMaterial);
		Create(center - val2 - val, size, marginMaterial);
		Create(center - val2 + val, size, marginMaterial);
		Create(center - val, size, marginMaterial);
		Create(center + val, size, marginMaterial);
		Create(center + val2, size, marginMaterial);
		Create(center + val2 - val, size, marginMaterial);
		Create(center + val2 + val, size, marginMaterial);
	}

	private static void Create(Vector3 position, Vector3 size, Material material)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = GameObject.CreatePrimitive((PrimitiveType)4);
		((Object)obj).name = "TerrainMargin";
		obj.layer = 16;
		obj.transform.position = position;
		obj.transform.localScale = size * 0.1f;
		Object.Destroy((Object)(object)obj.GetComponent<MeshRenderer>());
		Object.Destroy((Object)(object)obj.GetComponent<MeshFilter>());
	}
}


