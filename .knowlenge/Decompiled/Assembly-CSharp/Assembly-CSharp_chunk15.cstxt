using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Unity.Burst;
using UnityEngine;

[ExecuteInEditMode]
public class TerrainMeta : SingletonComponent<TerrainMeta>
{
	public enum PaintMode
	{
		None,
		Splats,
		Biomes,
		Alpha,
		Blend,
		Field,
		Cliff,
		Summit,
		Beachside,
		Beach,
		Forest,
		Forestside,
		Ocean,
		Oceanside,
		Decor,
		Monument,
		Road,
		Roadside,
		Swamp,
		River,
		Riverside,
		Lake,
		Lakeside,
		Offshore,
		Rail,
		Railside,
		Building,
		Cliffside,
		Mountain,
		Clutter,
		Alt,
		Tier0,
		Tier1,
		Tier2,
		Mainland,
		Hilltop
	}

	public struct BurstData
	{
		public Vector3 Position;

		public Vector3 Size;

		public Vector3 OneOverSize;
	}

	public Terrain terrain;

	public TerrainConfig config;

	public PaintMode paint;

	[HideInInspector]
	public PaintMode currentPaintMode;

	public static readonly SharedStatic<BurstData> sharedBurstData = SharedStatic<BurstData>.GetOrCreateUnsafe(0u, 5411825963348367585L, -2546176521858529784L);

	public static TerrainConfig Config { get; private set; }

	public static Terrain Terrain { get; private set; }

	public static Transform Transform { get; private set; }

	public static Vector3 Position { get; private set; }

	public static Vector3 Size { get; private set; }

	public static Vector3 Center => Position + Size * 0.5f;

	public static Vector3 Max => Position + Size;

	public static Vector3 OneOverSize { get; private set; }

	public static Vector3 HighestPoint { get; set; }

	public static Vector3 LowestPoint { get; set; }

	public static float LootAxisAngle { get; private set; }

	public static float BiomeAxisAngle { get; private set; }

	public static TerrainData Data { get; private set; }

	public static TerrainCollider Collider { get; private set; }

	public static TerrainCollision Collision { get; private set; }

	public static TerrainPhysics Physics { get; private set; }

	public static TerrainColors Colors { get; private set; }

	public static TerrainQuality Quality { get; private set; }

	public static TerrainPath Path { get; private set; }

	public static TerrainBiomeMap BiomeMap { get; private set; }

	public static TerrainAlphaMap AlphaMap { get; private set; }

	public static TerrainBlendMap BlendMap { get; private set; }

	public static TerrainHeightMap HeightMap { get; private set; }

	public static TerrainSplatMap SplatMap { get; private set; }

	public static TerrainTopologyMap TopologyMap { get; private set; }

	public static TerrainWaterMap WaterMap { get; private set; }

	public static TerrainWaterFlowMap WaterFlowMap { get; private set; }

	public static TerrainDistanceMap DistanceMap { get; private set; }

	public static TerrainPlacementMap PlacementMap { get; private set; }

	public static TerrainTexturing Texturing { get; private set; }

	public static Vector3 MarginSize => Size * 3f;

	public static bool OutOfBounds(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x)
		{
			return true;
		}
		if (worldPos.z < Position.z)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfBoundsBurst(Vector3 worldPos)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		BurstData data = sharedBurstData.Data;
		Vector3 position = data.Position;
		Vector3 size = data.Size;
		if (worldPos.x < position.x)
		{
			return true;
		}
		if (worldPos.z < position.z)
		{
			return true;
		}
		if (worldPos.x > position.x + size.x)
		{
			return true;
		}
		if (worldPos.z > position.z + size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfMargin(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x - Size.x)
		{
			return true;
		}
		if (worldPos.z < Position.z - Size.z)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x + Size.x)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z + Size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfMarginPlusTutorialBounds(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x - Size.x - TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.z < Position.z - Size.z - TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x + Size.x + TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z + Size.z + TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		return false;
	}

	public static float InnerDistToEdge2D(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		float num = Position.x - Size.x;
		float num2 = Position.x + Size.x + Size.x;
		float num3 = Position.z - Size.z;
		float num4 = Position.z + Size.z + Size.z;
		float num5 = Mathf.Abs(worldPos.x - num);
		float num6 = Mathf.Abs(worldPos.x - num2);
		float num7 = Mathf.Abs(worldPos.z - num3);
		float num8 = Mathf.Abs(worldPos.z - num4);
		return Mathf.Min(num5, Mathf.Min(num6, Mathf.Min(num7, num8)));
	}

	public static bool IsPointWithinTutorialBounds(Vector3 worldPos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		float tutorialBoundsSize = TutorialIsland.TutorialBoundsSize;
		float maximumPointTutorial = ValidBounds.GetMaximumPointTutorial();
		float num = 0f - maximumPointTutorial + tutorialBoundsSize;
		float num2 = maximumPointTutorial - tutorialBoundsSize;
		float num3 = 0f - maximumPointTutorial + tutorialBoundsSize;
		float num4 = maximumPointTutorial - tutorialBoundsSize;
		if (!(worldPos.x < num) && !(worldPos.x > num2) && !(worldPos.z < num3))
		{
			return worldPos.z > num4;
		}
		return true;
	}

	public static bool RandomWaterPointInAnnulus(Vector3 centre, float minRadius, float maxRadius, out Vector3 randomPoint)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 100; i++)
		{
			Vector3 val = Vector2.op_Implicit(Random.insideUnitCircle);
			float num = Random.Range(minRadius, maxRadius);
			Vector3 val2 = centre + new Vector3(val.x, 0f, val.y) * num;
			float height = HeightMap.GetHeight(val2);
			float height2 = WaterMap.GetHeight(val2);
			if (height <= height2)
			{
				randomPoint = val2;
				return true;
			}
		}
		randomPoint = Vector3.zero;
		return false;
	}

	public static Vector3 RandomPointOffshore(bool avoidDeepSeaPortal = false, bool avoidDeepSea = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		float num = Random.Range(-1f, 1f);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Min(Size.x, 4000f) - 100f, 0f, Mathf.Min(Size.z, 4000f) - 100f);
		avoidDeepSeaPortal = avoidDeepSeaPortal && (Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null && PointEntity<DeepSeaManager>.ServerInstance.IsOpen();
		avoidDeepSea = avoidDeepSea && (Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null;
		List<CardinalDirection> list = Pool.Get<List<CardinalDirection>>();
		list.Add(CardinalDirection.North);
		list.Add(CardinalDirection.East);
		list.Add(CardinalDirection.South);
		list.Add(CardinalDirection.West);
		if (avoidDeepSeaPortal)
		{
			CardinalDirection entrancePortalDirection = PointEntity<DeepSeaManager>.ServerInstance.EntrancePortalDirection;
			list.Remove(entrancePortalDirection);
		}
		if (avoidDeepSea)
		{
			list.Remove(CardinalDirection.West);
		}
		Vector3 result = (Vector3)(ListEx.GetRandom<CardinalDirection>(list) switch
		{
			CardinalDirection.West => Center + new Vector3(0f - val.x, 0f, num * val.z), 
			CardinalDirection.East => Center + new Vector3(val.x, 0f, num * val.z), 
			CardinalDirection.South => Center + new Vector3(num * val.x, 0f, 0f - val.z), 
			_ => Center + new Vector3(num * val.x, 0f, val.z), 
		});
		Pool.FreeUnmanaged<CardinalDirection>(ref list);
		return result;
	}

	public static Vector3 RandomPoint(bool excludeWater = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		while (((Vector3)(ref val)).Equals(default(Vector3)) || (excludeWater && WaterLevel.Test(val, waves: true, volumes: true)))
		{
			float num = Random.Range(0f, Terrain.terrainData.size.x);
			float num2 = Random.Range(0f, Terrain.terrainData.size.z);
			float height = HeightMap.GetHeight(new Vector3(num, 0f, num2));
			((Vector3)(ref val))..ctor(num, height, num2);
		}
		return val;
	}

	public static Vector3 Normalize(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = (worldPos.x - Position.x) * OneOverSize.x;
		float num2 = (worldPos.y - Position.y) * OneOverSize.y;
		float num3 = (worldPos.z - Position.z) * OneOverSize.z;
		return new Vector3(num, num2, num3);
	}

	public static float NormalizeX(float x)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (x - Position.x) * OneOverSize.x;
	}

	public static float NormalizeY(float y)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (y - Position.y) * OneOverSize.y;
	}

	public static float NormalizeZ(float z)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (z - Position.z) * OneOverSize.z;
	}

	public static Vector3 Denormalize(Vector3 normPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = Position.x + normPos.x * Size.x;
		float num2 = Position.y + normPos.y * Size.y;
		float num3 = Position.z + normPos.z * Size.z;
		return new Vector3(num, num2, num3);
	}

	public static float DenormalizeX(float normX)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.x + normX * Size.x;
	}

	public static float DenormalizeY(float normY)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.y + normY * Size.y;
	}

	public static float DenormalizeZ(float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.z + normZ * Size.z;
	}

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		if (Application.isPlaying)
		{
			Shader.DisableKeyword("TERRAIN_PAINTING");
		}
	}

	public void Init(Terrain terrainOverride = null, TerrainConfig configOverride = null)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)terrainOverride != (Object)null)
		{
			terrain = terrainOverride;
		}
		if (configOverride != null)
		{
			config = configOverride;
		}
		Terrain = terrain;
		Config = config;
		Transform = ((Component)terrain).transform;
		Data = terrain.terrainData;
		Size = terrain.terrainData.size;
		OneOverSize = Vector3Ex.Inverse(Size);
		Position = terrain.GetPosition();
		Collider = ((Component)terrain).GetComponent<TerrainCollider>();
		Collision = ((Component)terrain).GetComponent<TerrainCollision>();
		Physics = ((Component)terrain).GetComponent<TerrainPhysics>();
		Colors = ((Component)terrain).GetComponent<TerrainColors>();
		Quality = ((Component)terrain).GetComponent<TerrainQuality>();
		Path = ((Component)terrain).GetComponent<TerrainPath>();
		BiomeMap = ((Component)terrain).GetComponent<TerrainBiomeMap>();
		AlphaMap = ((Component)terrain).GetComponent<TerrainAlphaMap>();
		BlendMap = ((Component)terrain).GetComponent<TerrainBlendMap>();
		HeightMap = ((Component)terrain).GetComponent<TerrainHeightMap>();
		SplatMap = ((Component)terrain).GetComponent<TerrainSplatMap>();
		TopologyMap = ((Component)terrain).GetComponent<TerrainTopologyMap>();
		WaterMap = ((Component)terrain).GetComponent<TerrainWaterMap>();
		WaterFlowMap = ((Component)terrain).GetComponent<TerrainWaterFlowMap>();
		DistanceMap = ((Component)terrain).GetComponent<TerrainDistanceMap>();
		PlacementMap = ((Component)terrain).GetComponent<TerrainPlacementMap>();
		Texturing = ((Component)terrain).GetComponent<TerrainTexturing>();
		terrain.drawInstanced = false;
		HighestPoint = new Vector3(Position.x, Position.y + Size.y, Position.z);
		LowestPoint = new Vector3(Position.x, Position.y, Position.z);
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].Init(terrain, config);
		}
		uint seed = World.Seed;
		int num = SeedRandom.Range(ref seed, 0, 4) * 90;
		int num2 = SeedRandom.Range(ref seed, -45, 46);
		int num3 = SeedRandom.Sign(ref seed);
		LootAxisAngle = num;
		BiomeAxisAngle = num + num2 + num3 * 90;
		InitBurstData();
	}

	private static void InitBurstData()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		sharedBurstData.Data = new BurstData
		{
			Position = Position,
			Size = Size,
			OneOverSize = OneOverSize
		};
	}

	public static void InitNoTerrain(bool createPath = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Size = new Vector3(4096f, 4096f, 4096f);
		OneOverSize = Vector3Ex.Inverse(Size);
		Position = -0.5f * Size;
		InitBurstData();
	}

	public void SetupComponents()
	{
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		foreach (TerrainExtension obj in components)
		{
			obj.Setup();
			obj.isInitialized = true;
		}
	}

	public void PostSetupComponents()
	{
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

	public void BindShaderProperties()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0514: Unknown result type (might be due to invalid IL or missing references)
		//IL_0523: Unknown result type (might be due to invalid IL or missing references)
		//IL_0528: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)config))
		{
			Shader.SetGlobalTexture("Terrain_AlbedoArray", config.AlbedoArray);
			Shader.SetGlobalTexture("Terrain_NormalArray", config.NormalArray);
			Shader.SetGlobalVector("Terrain_TexelSize", Vector4.op_Implicit(new Vector2(1f / config.GetMinSplatTiling(), 1f / config.GetMinSplatTiling())));
			Shader.SetGlobalVector("Terrain_TexelSize0", new Vector4(1f / config.Splats[0].SplatTiling, 1f / config.Splats[1].SplatTiling, 1f / config.Splats[2].SplatTiling, 1f / config.Splats[3].SplatTiling));
			Shader.SetGlobalVector("Terrain_TexelSize1", new Vector4(1f / config.Splats[4].SplatTiling, 1f / config.Splats[5].SplatTiling, 1f / config.Splats[6].SplatTiling, 1f / config.Splats[7].SplatTiling));
			Shader.SetGlobalVector("Splat0_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[0].UVMIXMult, config.Splats[0].UVMIXStart, 1f / config.Splats[0].UVMIXDist)));
			Shader.SetGlobalVector("Splat1_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[1].UVMIXMult, config.Splats[1].UVMIXStart, 1f / config.Splats[1].UVMIXDist)));
			Shader.SetGlobalVector("Splat2_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[2].UVMIXMult, config.Splats[2].UVMIXStart, 1f / config.Splats[2].UVMIXDist)));
			Shader.SetGlobalVector("Splat3_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[3].UVMIXMult, config.Splats[3].UVMIXStart, 1f / config.Splats[3].UVMIXDist)));
			Shader.SetGlobalVector("Splat4_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[4].UVMIXMult, config.Splats[4].UVMIXStart, 1f / config.Splats[4].UVMIXDist)));
			Shader.SetGlobalVector("Splat5_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[5].UVMIXMult, config.Splats[5].UVMIXStart, 1f / config.Splats[5].UVMIXDist)));
			Shader.SetGlobalVector("Splat6_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[6].UVMIXMult, config.Splats[6].UVMIXStart, 1f / config.Splats[6].UVMIXDist)));
			Shader.SetGlobalVector("Splat7_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[7].UVMIXMult, config.Splats[7].UVMIXStart, 1f / config.Splats[7].UVMIXDist)));
		}
		if (Object.op_Implicit((Object)(object)HeightMap))
		{
			Shader.SetGlobalVector("_Terrain_HeightParams", new Vector4(Position.y, Size.y, OneOverSize.y, 0f));
			Shader.SetGlobalTexture("Terrain_Normal", (Texture)(object)HeightMap.NormalTexture);
		}
		if (Object.op_Implicit((Object)(object)AlphaMap))
		{
			Shader.SetGlobalTexture("Terrain_Alpha", (Texture)(object)AlphaMap.AlphaTexture);
		}
		if (Object.op_Implicit((Object)(object)BiomeMap))
		{
			Shader.SetGlobalTexture("Terrain_Biome", (Texture)(object)BiomeMap.BiomeTexture);
		}
		if (Object.op_Implicit((Object)(object)SplatMap))
		{
			Shader.SetGlobalTexture("Terrain_Control0", (Texture)(object)SplatMap.SplatTexture0);
			Shader.SetGlobalTexture("Terrain_Control1", (Texture)(object)SplatMap.SplatTexture1);
		}
		Object.op_Implicit((Object)(object)WaterMap);
		Object.op_Implicit((Object)(object)DistanceMap);
		if (!Object.op_Implicit((Object)(object)terrain))
		{
			return;
		}
		Shader.SetGlobalVector("Terrain_Position", Vector4.op_Implicit(Position));
		Shader.SetGlobalVector("Terrain_Size", Vector4.op_Implicit(Size));
		Shader.SetGlobalVector("Terrain_RcpSize", Vector4.op_Implicit(OneOverSize));
		Shader.SetGlobalVector("Terrain_Global_Position", Vector4.op_Implicit(Position));
		Shader.SetGlobalVector("Terrain_Global_Size", Vector4.op_Implicit(Size));
		Shader.SetGlobalVector("Terrain_Global_RcpSize", Vector4.op_Implicit(OneOverSize));
		if (Object.op_Implicit((Object)(object)terrain.materialTemplate))
		{
			if (terrain.materialTemplate.IsKeywordEnabled("_TERRAIN_BLEND_LINEAR"))
			{
				terrain.materialTemplate.DisableKeyword("_TERRAIN_BLEND_LINEAR");
			}
			if (terrain.materialTemplate.IsKeywordEnabled("_TERRAIN_VERTEX_NORMALS"))
			{
				terrain.materialTemplate.DisableKeyword("_TERRAIN_VERTEX_NORMALS");
			}
		}
	}
}


public enum PaintMode
{
	None,
	Splats,
	Biomes,
	Alpha,
	Blend,
	Field,
	Cliff,
	Summit,
	Beachside,
	Beach,
	Forest,
	Forestside,
	Ocean,
	Oceanside,
	Decor,
	Monument,
	Road,
	Roadside,
	Swamp,
	River,
	Riverside,
	Lake,
	Lakeside,
	Offshore,
	Rail,
	Railside,
	Building,
	Cliffside,
	Mountain,
	Clutter,
	Alt,
	Tier0,
	Tier1,
	Tier2,
	Mainland,
	Hilltop
}


using UnityEngine;

public struct BurstData
{
	public Vector3 Position;

	public Vector3 Size;

	public Vector3 OneOverSize;
}


using UnityEngine;

[ExecuteInEditMode]
public class TerrainPaint : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TerrainPath : TerrainExtension
{
	public List<PathList> Roads = new List<PathList>();

	public List<PathList> MainRoads = new List<PathList>();

	public List<PathList> SideRoads = new List<PathList>();

	public List<PathList> TrailRoads = new List<PathList>();

	public List<PathList> Rails = new List<PathList>();

	public List<PathList> Rivers = new List<PathList>();

	public List<PathList> Powerlines = new List<PathList>();

	public List<LandmarkInfo> Landmarks = new List<LandmarkInfo>();

	public List<MonumentInfo> Monuments = new List<MonumentInfo>();

	public List<RiverInfo> RiverObjs = new List<RiverInfo>();

	public List<LakeInfo> LakeObjs = new List<LakeInfo>();

	public List<DungeonGridInfo> DungeonGridEntrances = new List<DungeonGridInfo>();

	public List<DungeonGridCell> DungeonGridCells = new List<DungeonGridCell>();

	public List<DungeonBaseInfo> DungeonBaseEntrances = new List<DungeonBaseInfo>();

	public List<DungeonBaseLink> DungeonBaseLinks = new List<DungeonBaseLink>();

	public List<Vector3> OceanPatrolClose = new List<Vector3>();

	public List<Vector3> OceanPatrolFar = new List<Vector3>();

	public Dictionary<string, List<PowerlineNode>> wires = new Dictionary<string, List<PowerlineNode>>();

	public override void PostSetup()
	{
		foreach (PathList road in Roads)
		{
			road.ProcgenStartNode = null;
			road.ProcgenEndNode = null;
		}
		foreach (PathList rail in Rails)
		{
			rail.ProcgenStartNode = null;
			rail.ProcgenEndNode = null;
		}
		foreach (PathList river in Rivers)
		{
			river.ProcgenStartNode = null;
			river.ProcgenEndNode = null;
		}
		foreach (PathList powerline in Powerlines)
		{
			powerline.ProcgenStartNode = null;
			powerline.ProcgenEndNode = null;
		}
	}

	public void Clear()
	{
		Roads.Clear();
		Rails.Clear();
		Rivers.Clear();
		Powerlines.Clear();
	}

	public T FindClosest<T>(List<T> list, Vector3 pos) where T : MonoBehaviour
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		T result = default(T);
		float num = float.MaxValue;
		foreach (T item in list)
		{
			if (!((Object)(object)item == (Object)null))
			{
				float num2 = Vector3Ex.Distance2D(((Component)(object)item).transform.position, pos);
				if (!(num2 >= num))
				{
					result = item;
					num = num2;
				}
			}
		}
		return result;
	}

	public static int[,] CreatePowerlineCostmap(ref uint seed)
	{
		float radius = 5f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int num2 = 10683780;
				int num3 = 1628160;
				int num4 = 514;
				if ((topology & num2) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num3) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 2500;
				}
				else if ((topology & num4) != 0)
				{
					array[j, i] = 1000;
				}
				else
				{
					array[j, i] = 1 + (int)(slope * slope * 10f);
				}
			}
		}
		return array;
	}

	public static int[,] CreateRoadCostmap(ref uint seed, bool trail = false)
	{
		float radius = 5f;
		float radius2 = 15f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				int num2 = SeedRandom.Range(ref seed, 100, 200);
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int topology2 = topologyMap.GetTopology(normX, normZ, radius2);
				int num3 = 196996;
				int num4 = 10487296;
				int num5 = 2;
				int num6 = 49152;
				if (slope > 20f || (topology & num3) != 0 || (topology2 & num4) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num6) != 0)
				{
					array[j, i] = (trail ? int.MaxValue : 5000);
				}
				else if ((topology & num5) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 5000;
				}
				else
				{
					array[j, i] = 1 + (int)(slope * slope * 10f) + num2;
				}
			}
		}
		return array;
	}

	public static int[,] CreateRailCostmap(ref uint seed)
	{
		float radius = 5f;
		float radius2 = 25f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int topology2 = topologyMap.GetTopology(normX, normZ, radius2);
				int num2 = 196996;
				int num3 = 10487296;
				int num4 = 2;
				int num5 = 49152;
				if (slope > 30f || (topology & num2) != 0 || (topology2 & num3) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num5) != 0)
				{
					array[j, i] = 5000;
				}
				else if (slope > 20f || (topology & num4) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 5000;
				}
				else if (slope > 10f)
				{
					array[j, i] = 1500;
				}
				else
				{
					array[j, i] = 1000;
				}
			}
		}
		return array;
	}

	public static int[,] CreateBoatCostmap(float depth)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)((float)World.Size / 7.5f);
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				if (WaterLevel.GetOverallWaterDepth(new Vector3(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ)), waves: false, volumes: false) < depth)
				{
					array[j, i] = int.MaxValue;
				}
				else
				{
					array[j, i] = 1;
				}
			}
		}
		return array;
	}

	public void AddWire(PowerlineNode node)
	{
		string name = ((Object)((Component)node).transform.root).name;
		if (!wires.ContainsKey(name))
		{
			wires.Add(name, new List<PowerlineNode>());
		}
		wires[name].Add(node);
	}

	public void CreateWires()
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		List<GameObject> list = new List<GameObject>();
		int num = 0;
		GameObjectRef gameObjectRef = null;
		foreach (KeyValuePair<string, List<PowerlineNode>> wire2 in wires)
		{
			KeyValuePair<string, List<PowerlineNode>> wire = wire2;
			GameObject rootGO = null;
			foreach (PowerlineNode item in wire.Value)
			{
				PowerLineWireConnectionHelper component = ((Component)item).GetComponent<PowerLineWireConnectionHelper>();
				if (!Object.op_Implicit((Object)(object)component))
				{
					continue;
				}
				if (list.Count == 0)
				{
					gameObjectRef = item.WirePrefab;
					num = component.connections.Count;
				}
				else
				{
					GameObject val = list[list.Count - 1];
					if (!(item.WirePrefab.guid != gameObjectRef?.guid) && component.connections.Count == num)
					{
						Vector3 val2 = val.transform.position - ((Component)item).transform.position;
						if (!(((Vector3)(ref val2)).sqrMagnitude > item.MaxDistance * item.MaxDistance))
						{
							goto IL_010f;
						}
					}
					CreateWire(list, gameObjectRef);
					list.Clear();
				}
				goto IL_010f;
				IL_010f:
				list.Add(((Component)item).gameObject);
			}
			CreateWire(list, gameObjectRef);
			list.Clear();
			void CreateWire(List<GameObject> objects, GameObjectRef wirePrefab)
			{
				//IL_0057: Unknown result type (might be due to invalid IL or missing references)
				//IL_0061: Expected O, but got Unknown
				if (objects.Count >= 3 && wirePrefab != null && wirePrefab.isValid)
				{
					PowerLineWire powerLineWire = PowerLineWire.Create(null, objects, wirePrefab, "Powerline Wires", null, 1f, 0.1f);
					if (Object.op_Implicit((Object)(object)powerLineWire))
					{
						((Behaviour)powerLineWire).enabled = false;
						if ((Object)(object)rootGO == (Object)null)
						{
							rootGO = new GameObject(wire.Key);
						}
						((Component)powerLineWire).transform.SetParent(rootGO.transform, true);
					}
				}
			}
		}
	}

	public MonumentInfo FindMonumentWithBoundsOverlap(Vector3 position, MonumentType[] types = null)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in Monuments)
		{
			if ((Object)(object)monument != (Object)null && (types == null || Array.IndexOf(types, monument.Type) != -1) && monument.IsInBounds(position))
			{
				return monument;
			}
		}
		return null;
	}

	public void AddRoad(List<PathList> newRoadList, bool addToMaster = true)
	{
		foreach (PathList newRoad in newRoadList)
		{
			AddRoad(newRoad, addToMaster);
		}
	}

	public void AddRoad(PathList newRoad, bool addToMaster = true)
	{
		switch (newRoad?.Hierarchy)
		{
		case 0:
			MainRoads.Add(newRoad);
			break;
		case 1:
			SideRoads.Add(newRoad);
			break;
		case 2:
			TrailRoads.Add(newRoad);
			break;
		default:
			MainRoads.Add(newRoad);
			break;
		}
		if (addToMaster && newRoad != null)
		{
			Roads.Add(newRoad);
		}
	}
}


public enum InfrastructureType
{
	Road,
	Power,
	Trail,
	Tunnel,
	UnderwaterLab,
	Boat,
	Rail
}


using UnityEngine;

public class TerrainPhysics : TerrainExtension
{
	private TerrainSplatMap splat;

	private PhysicMaterial[] materials;

	public override void Setup()
	{
		splat = ((Component)terrain).GetComponent<TerrainSplatMap>();
		materials = config.GetPhysicMaterials();
	}

	public PhysicMaterial GetMaterial(Vector3 worldPos)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)splat == (Object)null || materials.Length == 0)
		{
			return null;
		}
		return materials[splat.GetSplatMaxIndex(worldPos)];
	}
}


public class TerrainQuality : TerrainExtension
{
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Rust;
using TerrainTexturingJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;

[ExecuteInEditMode]
public class TerrainTexturing : TerrainExtension
{
	public struct ShoreData : IDisposable
	{
		public int ShoreMapSize;

		public float ShoreDistanceScale;

		public Vector3 Position;

		public Vector3 Size;

		public Vector3 OneOverSize;

		[ReadOnly]
		public NativeArray<float> ShoreDistances;

		[ReadOnly]
		public NativeArray<Vector4> ShoreVectors;

		public Vector4 DefaultVector;

		public float DefaultDistance;

		public int Len => ShoreMapSize * ShoreMapSize;

		public void FillWithDefault()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			FillJob<float> fillJob = default(FillJob<float>);
			fillJob.Value = DefaultDistance;
			fillJob.Values = ShoreDistances;
			IJobExtensions.Run<FillJob<float>>(fillJob);
			FillJob<Vector4> fillJob2 = default(FillJob<Vector4>);
			fillJob2.Value = DefaultVector;
			fillJob2.Values = ShoreVectors;
			IJobExtensions.Run<FillJob<Vector4>>(fillJob2);
		}

		[BurstDiscard]
		public Texture2D CreateTexture(string name)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Expected O, but got Unknown
			Texture2D val = new Texture2D(ShoreMapSize, ShoreMapSize, (TextureFormat)17, false, true, true)
			{
				name = name,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1
			};
			NativeArray<half4> val2 = default(NativeArray<half4>);
			val2..ctor(Len, (Allocator)3, (NativeArrayOptions)1);
			PopulateTextureDataJob jobData = new PopulateTextureDataJob
			{
				colors = val2,
				vectors = ShoreVectors.AsReadOnly(),
				distances = ShoreDistances.AsReadOnly()
			};
			int length = val2.Length;
			JobHandle val3 = default(JobHandle);
			val3 = ParallelJobEx.ScheduleParallel<PopulateTextureDataJob>(ref jobData, length, val3);
			((JobHandle)(ref val3)).Complete();
			val.SetPixelData<half4>(val2, 0, 0);
			val.Apply(false, true);
			val3 = default(JobHandle);
			val2.Dispose(val3);
			return val;
		}

		public float GetCoarseDistanceToShore(Vector3 pos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			Vector2 uv = default(Vector2);
			uv.x = (pos.x - Position.x) * OneOverSize.x;
			uv.y = (pos.z - Position.z) * OneOverSize.z;
			return GetCoarseDistanceToShore(uv);
		}

		public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector3 pos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			Vector2 uv = default(Vector2);
			uv.x = (pos.x - Position.x) * OneOverSize.x;
			uv.y = (pos.z - Position.z) * OneOverSize.z;
			return GetCoarseVectorToShore(uv);
		}

		public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector2 uv)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
			int shoreMapSize = ShoreMapSize;
			int num = shoreMapSize - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
			int num10 = num5 * shoreMapSize + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			Vector3 val = Vector4.op_Implicit(ShoreVectors[num10]);
			Vector3 val2 = Vector4.op_Implicit(ShoreVectors[num11]);
			Vector3 val3 = Vector4.op_Implicit(ShoreVectors[num12]);
			Vector3 val4 = Vector4.op_Implicit(ShoreVectors[num13]);
			Vector3 val5 = default(Vector3);
			val5.x = (val2.x - val.x) * num6 + val.x;
			val5.y = (val2.y - val.y) * num6 + val.y;
			val5.z = (val2.z - val.z) * num6 + val.z;
			Vector3 val6 = default(Vector3);
			val6.x = (val4.x - val3.x) * num6 + val3.x;
			val6.y = (val4.y - val3.y) * num6 + val3.y;
			val6.z = (val4.z - val3.z) * num6 + val3.z;
			float num14 = (val6.x - val5.x) * num7 + val5.x;
			float num15 = (val6.y - val5.y) * num7 + val5.y;
			return new ValueTuple<Vector3, float>(item2: ((val6.z - val5.z) * num7 + val5.z) * ShoreDistanceScale, item1: new Vector3(num14, 0f, num15));
		}

		public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(float normX, float normY)
		{
			//IL_0003: Unknown result type (might be due to invalid IL or missing references)
			return this.GetCoarseVectorToShore(new Vector2(normX, normY));
		}

		public Vector4 GetRawShoreVector(Vector3 pos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			Vector2 uv = default(Vector2);
			uv.x = (pos.x - Position.x) * OneOverSize.x;
			uv.y = (pos.z - Position.z) * OneOverSize.z;
			return GetRawShoreVector(uv);
		}

		public Vector4 GetRawShoreVector(Vector2 uv)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			int shoreMapSize = ShoreMapSize;
			int num = shoreMapSize - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			return ShoreVectors[num5 * shoreMapSize + num4];
		}

		public readonly float GetCoarseDistanceToShore(Vector2 uv)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			int shoreMapSize = ShoreMapSize;
			int num = shoreMapSize - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
			int num10 = num5 * shoreMapSize + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = ShoreDistances[num10];
			float num15 = ShoreDistances[num11];
			float num16 = ShoreDistances[num12];
			float num17 = ShoreDistances[num13];
			float num18 = (num15 - num14) * num6 + num14;
			return (((num17 - num16) * num6 + num16 - num18) * num7 + num18) * ShoreDistanceScale;
		}

		public void Dispose()
		{
			NativeArrayEx.SafeDispose(ref ShoreDistances);
			ShoreVectors.SafeDispose<Vector4>();
		}
	}

	public struct ShoreVectorQueryStructure
	{
		private ShoreData mainlandData;

		private ShoreData deepSeaData;

		private Bounds deepSeaBounds;

		internal ShoreVectorQueryStructure(ShoreData mainlandData, ShoreData deepSeaData, Bounds deepSeaBounds)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.mainlandData = mainlandData;
			this.deepSeaData = deepSeaData;
			this.deepSeaBounds = deepSeaBounds;
		}

		public float GetCoarseDistanceToShore(Vector3 pos)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			return (((Bounds)(ref deepSeaBounds)).Contains(pos) ? deepSeaData : mainlandData).GetCoarseDistanceToShore(pos);
		}
	}

	public bool debugFoliageDisplacement;

	private bool initialized;

	private static TerrainTexturing instance;

	private int afCached;

	private int globalTextureMipmapLimitCached;

	private int anisotropicFilteringCached;

	private bool streamingMipmapsActiveCached;

	private bool billboardsFaceCameraPositionCached;

	public const int ShoreVectorDownscale = 1;

	private const int ShoreVectorBlurPasses = 1;

	private float terrainSize;

	private float deepSeaSize;

	private ShoreData MainlandShoreData;

	private ShoreData DeepSeaShoreData;

	private bool deepSeaShoreDataDirty;

	private List<(BakedShoreVectors data, Transform t)> deepSeaPostGenApplication;

	public static TerrainTexturing Instance => instance;

	public bool TexturesInitialized => initialized;

	private void ReleaseBasePyramid()
	{
	}

	private void UpdateBasePyramid()
	{
	}

	private void InitializeCoarseHeightSlope()
	{
	}

	private void ReleaseCoarseHeightSlope()
	{
	}

	private void UpdateCoarseHeightSlope()
	{
	}

	private void CheckInstance()
	{
		instance = (((Object)(object)instance != (Object)null) ? instance : this);
	}

	private void Awake()
	{
		CheckInstance();
	}

	public override void Setup()
	{
		CheckInstance();
		InitializeShoreVector();
	}

	public override void PostSetup()
	{
		TerrainMeta component = ((Component)this).GetComponent<TerrainMeta>();
		if ((Object)(object)component == (Object)null || component.config == null)
		{
			Debug.LogError((object)"[TerrainTexturing] Missing TerrainMeta or TerrainConfig not assigned.");
			return;
		}
		Shutdown();
		InitializeCoarseHeightSlope();
		GenerateShoreVector();
		InitializeWaterHeight();
		initialized = true;
	}

	private void Shutdown()
	{
		ReleaseBasePyramid();
		ReleaseCoarseHeightSlope();
		ReleaseShoreVector();
		ReleaseWaterHeight();
		initialized = false;
	}

	public void OnEnable()
	{
		CheckInstance();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Shutdown();
		}
	}

	private void Update()
	{
		if (initialized)
		{
			UpdateBasePyramid();
			UpdateCoarseHeightSlope();
			UpdateWaterHeight();
			UpdateDeepSeaShoreVectorTexture();
		}
	}

	internal ShoreData GetMap(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if (!DeepSeaManager.IsInsideDeepSea(position))
		{
			return MainlandShoreData;
		}
		return DeepSeaShoreData;
	}

	internal ShoreData GetMap(bool isDeepSea)
	{
		if (!isDeepSea)
		{
			return MainlandShoreData;
		}
		return DeepSeaShoreData;
	}

	private void InitializeShoreVector()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.ClosestPowerOfTwo(terrain.terrainData.heightmapResolution) >> 1;
		terrainSize = Mathf.Max(terrain.terrainData.size.x, terrain.terrainData.size.z);
		deepSeaSize = Vector3Ex.Max(Vector3Ex.XZ2D(((Bounds)(ref DeepSeaManager.DeepSeaBounds)).size));
		MainlandShoreData = new ShoreData
		{
			ShoreMapSize = num,
			ShoreDistanceScale = terrainSize / (float)num,
			ShoreDistances = new NativeArray<float>(num * num, (Allocator)4, (NativeArrayOptions)0),
			ShoreVectors = new NativeArray<Vector4>(num * num, (Allocator)4, (NativeArrayOptions)0),
			Position = TerrainMeta.Position,
			Size = TerrainMeta.Size,
			OneOverSize = TerrainMeta.OneOverSize,
			DefaultDistance = 10000f,
			DefaultVector = new Vector4(1f, 1f, 1f, 0f)
		};
		MainlandShoreData.FillWithDefault();
		int num2 = MainlandShoreData.ShoreMapSize >> 1;
		DeepSeaShoreData = new ShoreData
		{
			ShoreMapSize = num2,
			ShoreDistanceScale = deepSeaSize / (float)num2,
			ShoreDistances = new NativeArray<float>(num2 * num2, (Allocator)4, (NativeArrayOptions)0),
			ShoreVectors = new NativeArray<Vector4>(num2 * num2, (Allocator)4, (NativeArrayOptions)0),
			Position = ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).min,
			Size = ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).size,
			OneOverSize = Vector3Ex.Inverse(((Bounds)(ref DeepSeaManager.DeepSeaBounds)).size),
			DefaultDistance = 10000f,
			DefaultVector = new Vector4(1f, 1f, 1f, 1f)
		};
		DeepSeaShoreData.FillWithDefault();
		deepSeaShoreDataDirty = true;
		deepSeaPostGenApplication = new List<(BakedShoreVectors, Transform)>();
	}

	private void GenerateShoreVector()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GenerateShoreVector", 500);
		try
		{
			GenerateShoreVector(out var distances, out var vectors);
			MainlandShoreData.ShoreDistances = distances;
			MainlandShoreData.ShoreVectors = vectors;
			if (!DeepSeaShoreData.ShoreDistances.IsCreated)
			{
				DeepSeaShoreData.ShoreDistances = new NativeArray<float>(DeepSeaShoreData.Len, (Allocator)4, (NativeArrayOptions)1);
			}
			if (!DeepSeaShoreData.ShoreVectors.IsCreated)
			{
				DeepSeaShoreData.ShoreVectors = new NativeArray<Vector4>(DeepSeaShoreData.Len, (Allocator)4, (NativeArrayOptions)1);
			}
			DeepSeaShoreData.FillWithDefault();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateDeepSeaShoreVectorTexture()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("UpdateDeepSeaShoreVectorTexture", 0);
		try
		{
			if (!deepSeaShoreDataDirty)
			{
				return;
			}
			deepSeaShoreDataDirty = false;
			GenerateShoreVector(out var distances, out var vectors, genDeepSea: true);
			NativeArrayEx.SafeDispose(ref DeepSeaShoreData.ShoreDistances);
			DeepSeaShoreData.ShoreDistances = distances;
			DeepSeaShoreData.ShoreVectors.SafeDispose<Vector4>();
			DeepSeaShoreData.ShoreVectors = vectors;
			Bounds deepSeaBounds = DeepSeaManager.DeepSeaBounds;
			Vector3 min = ((Bounds)(ref deepSeaBounds)).min;
			Vector3 val2 = Vector3Ex.Inverse(((Bounds)(ref deepSeaBounds)).size);
			NativeArray<float> deepSeaShoreDistances = DeepSeaShoreData.ShoreDistances;
			NativeArray<Vector4> deepSeaShoreVectors = DeepSeaShoreData.ShoreVectors;
			Vector3 val3 = default(Vector3);
			Quaternion val4 = default(Quaternion);
			foreach (var item3 in deepSeaPostGenApplication)
			{
				BakedShoreVectors item = item3.data;
				Transform item2 = item3.t;
				if (!item || !Object.op_Implicit((Object)(object)item2))
				{
					continue;
				}
				ShoreVectorData shoreVectorData = item.ShoreVectorData;
				item2.GetPositionAndRotation(ref val3, ref val4);
				float y = ((Quaternion)(ref val4)).eulerAngles.y;
				float normX = (val3.x - min.x) * val2.x;
				float normZ = (val3.z - min.z) * val2.z;
				float worldSize = shoreVectorData.WorldSize;
				int shoreMapSize = DeepSeaShoreData.ShoreMapSize;
				float[] srcDistances = shoreVectorData.Distances;
				Vector4[] srcVectors = shoreVectorData.Vectors;
				Quaternion quat = Quaternion.Euler(0f, y, 0f);
				BlitBakedData(worldSize, shoreVectorData.ShoreVectorDimension, deepSeaBounds, shoreMapSize, normX, normZ, y, delegate(int si, int di)
				{
					//IL_003d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0042: Unknown result type (might be due to invalid IL or missing references)
					//IL_0045: Unknown result type (might be due to invalid IL or missing references)
					//IL_0050: Unknown result type (might be due to invalid IL or missing references)
					//IL_005c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0061: Unknown result type (might be due to invalid IL or missing references)
					//IL_0062: Unknown result type (might be due to invalid IL or missing references)
					//IL_0067: Unknown result type (might be due to invalid IL or missing references)
					//IL_006a: Unknown result type (might be due to invalid IL or missing references)
					//IL_0070: Unknown result type (might be due to invalid IL or missing references)
					//IL_0076: Unknown result type (might be due to invalid IL or missing references)
					//IL_007c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0093: Unknown result type (might be due to invalid IL or missing references)
					float num = srcDistances[si];
					float num2 = deepSeaShoreDistances[di];
					if (num < num2)
					{
						deepSeaShoreDistances[di] = srcDistances[si];
						Vector4 val5 = srcVectors[si];
						Vector3 val6 = default(Vector3);
						((Vector3)(ref val6))..ctor(val5.x, 0f, val5.y);
						val6 = quat * val6;
						((Vector4)(ref val5))..ctor(val6.x, val6.z, val5.z, val5.w);
						deepSeaShoreVectors[di] = val5;
					}
				});
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void OnDestroy()
	{
		ReleaseShoreVector();
	}

	private void ReleaseShoreVector()
	{
		MainlandShoreData.Dispose();
		DeepSeaShoreData.Dispose();
	}

	public void GenerateShoreVector(out NativeArray<float> distances, out NativeArray<Vector4> vectors, bool genDeepSea = false)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GenerateShoreVector", 0);
		try
		{
			int size;
			float shoreDistanceScale;
			Vector3 position;
			if (genDeepSea)
			{
				size = DeepSeaShoreData.ShoreMapSize;
				shoreDistanceScale = DeepSeaShoreData.ShoreDistanceScale;
				position = DeepSeaShoreData.Position;
			}
			else
			{
				size = MainlandShoreData.ShoreMapSize;
				shoreDistanceScale = MainlandShoreData.ShoreDistanceScale;
				position = MainlandShoreData.Position;
			}
			NativeArray<Vector3> positions = new NativeArray<Vector3>(size * size, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<float> val2 = new NativeArray<float>(size * size, (Allocator)3, (NativeArrayOptions)1);
			NativeArray<byte> bitmap = new NativeArray<byte>(size * size, (Allocator)3, (NativeArrayOptions)1);
			distances = new NativeArray<float>(size * size, (Allocator)4, (NativeArrayOptions)1);
			vectors = new NativeArray<Vector4>(size * size, (Allocator)4, (NativeArrayOptions)1);
			TimeWarning val3 = TimeWarning.New("WaterDepth", 0);
			JobHandle val5;
			try
			{
				NativeArray<int> indices = default(NativeArray<int>);
				indices..ctor(size * size, (Allocator)3, (NativeArrayOptions)1);
				NativeArray<float> heights = default(NativeArray<float>);
				heights..ctor(size * size, (Allocator)3, (NativeArrayOptions)1);
				GenSamplePoints genSamplePoints = default(GenSamplePoints);
				genSamplePoints.indices = indices;
				genSamplePoints.positions = positions;
				genSamplePoints.shoreMapSize = size;
				genSamplePoints.terrainPosition = position;
				genSamplePoints.upscaleCoords = shoreDistanceScale;
				GenSamplePoints genSamplePoints2 = genSamplePoints;
				IJobExtensions.RunByRef<GenSamplePoints>(ref genSamplePoints2);
				JobHandle val4 = default(JobHandle);
				if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) && TerrainMeta.HeightMap.isInitialized)
				{
					val4 = TerrainMeta.HeightMap.GetHeights(positions.AsReadOnly(), val2);
				}
				else
				{
					FillJob<float> fillJob = default(FillJob<float>);
					fillJob.Value = 0f;
					fillJob.Values = val2;
					val4 = IJobExtensions.Schedule<FillJob<float>>(fillJob, val4);
				}
				WaterLevel.GetWaterLevels(positions.AsReadOnly(), indices.AsReadOnly(), waves: false, heights);
				GenShoreVecBitMapJob genShoreVecBitMapJob = default(GenShoreVecBitMapJob);
				genShoreVecBitMapJob.bitmap = bitmap;
				genShoreVecBitMapJob.terrainHeights = val2.AsReadOnly();
				genShoreVecBitMapJob.waterHeights = heights.AsReadOnly();
				GenShoreVecBitMapJob jobData = genShoreVecBitMapJob;
				val5 = ParallelJobEx.ScheduleParallel<GenShoreVecBitMapJob>(ref jobData, bitmap.Length, val4);
				indices.Dispose(val5);
				heights.Dispose(val5);
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			val3 = TimeWarning.New("DistanceField.XXX", 0);
			try
			{
				JobHandle val6 = val5;
				val6 = DistanceField.GenerateNative(in size, (byte)127, bitmap.AsReadOnly(), in distances, val6);
				val6 = DistanceField.ApplyGaussianBlurNative(size, distances, 1, val6);
				val6 = DistanceField.GenerateVectorsNative(in size, distances.AsReadOnly(), vectors, val6);
				bitmap.Dispose(val6);
				((JobHandle)(ref val6)).Complete();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
			val3 = TimeWarning.New("Topology Mask", 0);
			try
			{
				if (!((Object)(object)TerrainMeta.TopologyMap != (Object)null) || !TerrainMeta.TopologyMap.isInitialized || !((Object)(object)TerrainMeta.HeightMap != (Object)null) || !TerrainMeta.HeightMap.isInitialized)
				{
					for (int i = 0; i < vectors.Length; i++)
					{
						Vector4 val7 = vectors[i];
						val7.w = -1f;
						vectors[i] = val7;
					}
					positions.Dispose(default(JobHandle));
					val2.Dispose(default(JobHandle));
					return;
				}
				JobHandle val8 = default(JobHandle);
				if (genDeepSea)
				{
					FillAsOceanTopologyJob fillAsOceanTopologyJob = default(FillAsOceanTopologyJob);
					fillAsOceanTopologyJob.vectors = vectors;
					FillAsOceanTopologyJob jobData2 = fillAsOceanTopologyJob;
					val8 = ParallelJobEx.ScheduleParallel<FillAsOceanTopologyJob>(ref jobData2, vectors.Length, val8);
				}
				else
				{
					NativeArray<float> radii = default(NativeArray<float>);
					radii..ctor(size * size, (Allocator)3, (NativeArrayOptions)1);
					NativeArray<int> results = default(NativeArray<int>);
					results..ctor(size * size, (Allocator)3, (NativeArrayOptions)1);
					GenTopologyRadiiJob genTopologyRadiiJob = default(GenTopologyRadiiJob);
					genTopologyRadiiJob.heights = val2.AsReadOnly();
					genTopologyRadiiJob.radii = radii;
					GenTopologyRadiiJob jobData3 = genTopologyRadiiJob;
					val8 = ParallelJobEx.ScheduleParallel<GenTopologyRadiiJob>(ref jobData3, radii.Length, val8);
					val8 = TerrainMeta.TopologyMap.GetTopologiesIndirect(positions.AsReadOnly(), radii.AsReadOnly(), results, val8);
					ProcessTopologyJob processTopologyJob = default(ProcessTopologyJob);
					processTopologyJob.topologies = results.AsReadOnly();
					processTopologyJob.vectors = vectors;
					ProcessTopologyJob jobData4 = processTopologyJob;
					val8 = ParallelJobEx.ScheduleParallel<ProcessTopologyJob>(ref jobData4, vectors.Length, val8);
					radii.Dispose(val8);
					results.Dispose(val8);
				}
				positions.Dispose(val8);
				val2.Dispose(val8);
				((JobHandle)(ref val8)).Complete();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetCoarseDistanceToShore(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return GetMap(pos).GetCoarseDistanceToShore(pos);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return GetMap(pos).GetCoarseVectorToShore(pos);
	}

	public (Vector3 shoreDir, float shoreDist) GetMainlandCoarseVectorToShore(float normX, float normY)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return MainlandShoreData.GetCoarseVectorToShore(new Vector2(normX, normY));
	}

	public Vector4 GetRawShoreVector(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetMap(pos).GetRawShoreVector(pos);
	}

	public ShoreVectorQueryStructure GetShoreVectorQueryStructure()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new ShoreVectorQueryStructure(MainlandShoreData, DeepSeaShoreData, DeepSeaManager.DeepSeaBounds);
	}

	public void GetCoarseDistancesToShoreIndirect(ReadOnly<Vector3> positions, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		GetCoarseDistsToShoreJobIndirect getCoarseDistsToShoreJobIndirect = default(GetCoarseDistsToShoreJobIndirect);
		getCoarseDistsToShoreJobIndirect.Dists = results;
		getCoarseDistsToShoreJobIndirect.Positions = positions;
		getCoarseDistsToShoreJobIndirect.Indices = indices;
		getCoarseDistsToShoreJobIndirect.QueryStructure = GetShoreVectorQueryStructure();
		GetCoarseDistsToShoreJobIndirect getCoarseDistsToShoreJobIndirect2 = getCoarseDistsToShoreJobIndirect;
		IJobExtensions.RunByRef<GetCoarseDistsToShoreJobIndirect>(ref getCoarseDistsToShoreJobIndirect2);
	}

	public void ApplyBakedDeepSeaVectors(BakedShoreVectors bakedShoreVectors, Transform t)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ApplyBakedDeepSeaVectors", 0);
		try
		{
			if (bakedShoreVectors.ShoreVectorData == null || bakedShoreVectors.ShoreVectorData.Distances == null)
			{
				return;
			}
			ShoreVectorData shoreVectorData = bakedShoreVectors.ShoreVectorData;
			Vector3 val2 = default(Vector3);
			Quaternion val3 = default(Quaternion);
			t.GetPositionAndRotation(ref val2, ref val3);
			if (bakedShoreVectors.OnlyBakeShoreVectors)
			{
				deepSeaPostGenApplication.Add((bakedShoreVectors, t));
			}
			float y = ((Quaternion)(ref val3)).eulerAngles.y;
			Bounds deepSeaBounds = DeepSeaManager.DeepSeaBounds;
			Vector3 min = ((Bounds)(ref deepSeaBounds)).min;
			Vector3 val4 = Vector3Ex.Inverse(((Bounds)(ref deepSeaBounds)).size);
			float normX = (val2.x - min.x) * val4.x;
			float normZ = (val2.z - min.z) * val4.z;
			float worldSize = shoreVectorData.WorldSize;
			short[] srcHeightData = shoreVectorData.HeightData;
			short[] array = srcHeightData;
			if (array != null && array.Length != 0)
			{
				float srcPositionY = shoreVectorData.HeightInfo.x;
				float srcSizeY = shoreVectorData.HeightInfo.y;
				BlitBakedData(worldSize, shoreVectorData.HeightDimension, deepSeaBounds, TerrainMeta.HeightMap.res, normX, normZ, y, delegate(int si, int di)
				{
					float num = BitUtility.Short2Float((int)srcHeightData[si]);
					short num2 = BitUtility.Float2Short(TerrainMeta.NormalizeY(srcPositionY + num * srcSizeY));
					short num3 = TerrainMeta.HeightMap.deepSeaHeights[di];
					if (num2 > num3)
					{
						TerrainMeta.HeightMap.deepSeaHeights[di] = num2;
					}
				});
			}
			deepSeaShoreDataDirty = true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void BlitBakedData(float worldSize, int dimension, Bounds deepSeaBounds, int dstMapSize, float normX, float normZ, float yaw, Action<int, int> action)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BlitBakedData", 0);
		try
		{
			float scaleMod = worldSize / (float)dimension / (Vector3Ex.Max(Vector3Ex.XZ2D(((Bounds)(ref deepSeaBounds)).size)) / (float)dstMapSize);
			Vector2 destCenterPx = new Vector2(normX * (float)dstMapSize, normZ * (float)dstMapSize);
			Vector2 val2 = new Vector2((float)dimension * scaleMod, (float)dimension * scaleMod);
			float num = yaw * (MathF.PI / 180f);
			float cosA = Mathf.Cos(num);
			float sinA = Mathf.Sin(num);
			Vector2 val3 = val2 * 0.5f;
			float num2 = Mathf.Abs(cosA);
			float num3 = Mathf.Abs(sinA);
			float num4 = num2 * val3.x + num3 * val3.y;
			float num5 = num3 * val3.x + num2 * val3.y;
			int left = Mathf.FloorToInt(destCenterPx.x - num4);
			int right = Mathf.CeilToInt(destCenterPx.x + num4);
			int num6 = Mathf.FloorToInt(destCenterPx.y - num5);
			int num7 = Mathf.CeilToInt(destCenterPx.y + num5);
			if (right < 0 || left >= dstMapSize || num7 < 0 || num6 >= dstMapSize)
			{
				return;
			}
			left = Mathf.Clamp(left, 0, dstMapSize - 1);
			right = Mathf.Clamp(right, 0, dstMapSize - 1);
			num6 = Mathf.Clamp(num6, 0, dstMapSize - 1);
			num7 = Mathf.Clamp(num7, 0, dstMapSize - 1);
			Vector2 srcPivotPx = new Vector2((float)dimension * 0.5f, (float)dimension * 0.5f);
			Parallel.For(num6, num7 + 1, delegate(int z)
			{
				for (int i = left; i <= right; i++)
				{
					float num8 = (float)i + 0.5f - destCenterPx.x;
					float num9 = (float)z + 0.5f - destCenterPx.y;
					float num10 = (cosA * num8 - sinA * num9) / scaleMod;
					float num11 = (sinA * num8 + cosA * num9) / scaleMod;
					int num12 = (int)(srcPivotPx.x + num10);
					int num13 = (int)(srcPivotPx.y + num11);
					if (num12 >= 0 && num12 <= dimension - 1 && num13 >= 0 && num13 <= dimension - 1)
					{
						int arg = z * dstMapSize + i;
						int arg2 = num13 * dimension + num12;
						action(arg2, arg);
					}
				}
			});
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ClearDeepSeaData()
	{
		DeepSeaShoreData.FillWithDefault();
		deepSeaShoreDataDirty = true;
	}

	private void InitializeWaterHeight()
	{
	}

	private void ReleaseWaterHeight()
	{
	}

	private void UpdateWaterHeight()
	{
	}
}


using System;
using TerrainTexturingJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;

public struct ShoreData : IDisposable
{
	public int ShoreMapSize;

	public float ShoreDistanceScale;

	public Vector3 Position;

	public Vector3 Size;

	public Vector3 OneOverSize;

	[ReadOnly]
	public NativeArray<float> ShoreDistances;

	[ReadOnly]
	public NativeArray<Vector4> ShoreVectors;

	public Vector4 DefaultVector;

	public float DefaultDistance;

	public int Len => ShoreMapSize * ShoreMapSize;

	public void FillWithDefault()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		FillJob<float> fillJob = default(FillJob<float>);
		fillJob.Value = DefaultDistance;
		fillJob.Values = ShoreDistances;
		IJobExtensions.Run<FillJob<float>>(fillJob);
		FillJob<Vector4> fillJob2 = default(FillJob<Vector4>);
		fillJob2.Value = DefaultVector;
		fillJob2.Values = ShoreVectors;
		IJobExtensions.Run<FillJob<Vector4>>(fillJob2);
	}

	[BurstDiscard]
	public Texture2D CreateTexture(string name)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Expected O, but got Unknown
		Texture2D val = new Texture2D(ShoreMapSize, ShoreMapSize, (TextureFormat)17, false, true, true)
		{
			name = name,
			filterMode = (FilterMode)1,
			wrapMode = (TextureWrapMode)1
		};
		NativeArray<half4> val2 = default(NativeArray<half4>);
		val2..ctor(Len, (Allocator)3, (NativeArrayOptions)1);
		PopulateTextureDataJob jobData = new PopulateTextureDataJob
		{
			colors = val2,
			vectors = ShoreVectors.AsReadOnly(),
			distances = ShoreDistances.AsReadOnly()
		};
		int length = val2.Length;
		JobHandle val3 = default(JobHandle);
		val3 = ParallelJobEx.ScheduleParallel<PopulateTextureDataJob>(ref jobData, length, val3);
		((JobHandle)(ref val3)).Complete();
		val.SetPixelData<half4>(val2, 0, 0);
		val.Apply(false, true);
		val3 = default(JobHandle);
		val2.Dispose(val3);
		return val;
	}

	public float GetCoarseDistanceToShore(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - Position.x) * OneOverSize.x;
		uv.y = (pos.z - Position.z) * OneOverSize.z;
		return GetCoarseDistanceToShore(uv);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - Position.x) * OneOverSize.x;
		uv.y = (pos.z - Position.z) * OneOverSize.z;
		return GetCoarseVectorToShore(uv);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		int shoreMapSize = ShoreMapSize;
		int num = shoreMapSize - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
		int num10 = num5 * shoreMapSize + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		Vector3 val = Vector4.op_Implicit(ShoreVectors[num10]);
		Vector3 val2 = Vector4.op_Implicit(ShoreVectors[num11]);
		Vector3 val3 = Vector4.op_Implicit(ShoreVectors[num12]);
		Vector3 val4 = Vector4.op_Implicit(ShoreVectors[num13]);
		Vector3 val5 = default(Vector3);
		val5.x = (val2.x - val.x) * num6 + val.x;
		val5.y = (val2.y - val.y) * num6 + val.y;
		val5.z = (val2.z - val.z) * num6 + val.z;
		Vector3 val6 = default(Vector3);
		val6.x = (val4.x - val3.x) * num6 + val3.x;
		val6.y = (val4.y - val3.y) * num6 + val3.y;
		val6.z = (val4.z - val3.z) * num6 + val3.z;
		float num14 = (val6.x - val5.x) * num7 + val5.x;
		float num15 = (val6.y - val5.y) * num7 + val5.y;
		return new ValueTuple<Vector3, float>(item2: ((val6.z - val5.z) * num7 + val5.z) * ShoreDistanceScale, item1: new Vector3(num14, 0f, num15));
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(float normX, float normY)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return this.GetCoarseVectorToShore(new Vector2(normX, normY));
	}

	public Vector4 GetRawShoreVector(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - Position.x) * OneOverSize.x;
		uv.y = (pos.z - Position.z) * OneOverSize.z;
		return GetRawShoreVector(uv);
	}

	public Vector4 GetRawShoreVector(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		int shoreMapSize = ShoreMapSize;
		int num = shoreMapSize - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		return ShoreVectors[num5 * shoreMapSize + num4];
	}

	public readonly float GetCoarseDistanceToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		int shoreMapSize = ShoreMapSize;
		int num = shoreMapSize - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
		int num10 = num5 * shoreMapSize + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = ShoreDistances[num10];
		float num15 = ShoreDistances[num11];
		float num16 = ShoreDistances[num12];
		float num17 = ShoreDistances[num13];
		float num18 = (num15 - num14) * num6 + num14;
		return (((num17 - num16) * num6 + num16 - num18) * num7 + num18) * ShoreDistanceScale;
	}

	public void Dispose()
	{
		NativeArrayEx.SafeDispose(ref ShoreDistances);
		ShoreVectors.SafeDispose<Vector4>();
	}
}


using UnityEngine;

public struct ShoreVectorQueryStructure
{
	private ShoreData mainlandData;

	private ShoreData deepSeaData;

	private Bounds deepSeaBounds;

	internal ShoreVectorQueryStructure(ShoreData mainlandData, ShoreData deepSeaData, Bounds deepSeaBounds)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.mainlandData = mainlandData;
		this.deepSeaData = deepSeaData;
		this.deepSeaBounds = deepSeaBounds;
	}

	public float GetCoarseDistanceToShore(Vector3 pos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return (((Bounds)(ref deepSeaBounds)).Contains(pos) ? deepSeaData : mainlandData).GetCoarseDistanceToShore(pos);
	}
}


internal enum TextureCacheState
{
	Initializing,
	Uncached,
	CachedRaw,
	CachedCompressed
}


using UnityEngine;

public class TerrainTreeBatch : MonoBehaviour
{
}


using UnityEngine;

public class TreeMesh : MonoBehaviour
{
}


using System;
using UnityEngine;

public class TerrainFilter : PrefabAttribute
{
	public SpawnFilter Filter;

	public bool CheckPlacementMap = true;

	public bool CheckTerrainBounds;

	public float CheckTopologyRadius;

	public bool Check(Vector3 pos)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (CheckTerrainBounds && TerrainMeta.OutOfBounds(pos))
		{
			return false;
		}
		return Filter.GetFactor(pos, CheckPlacementMap, CheckTopologyRadius) > 0f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainFilter);
	}
}


using UnityEngine;

public static class TerrainFilterEx
{
	public static bool ApplyTerrainFilters(this Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (filters.Length == 0)
		{
			return true;
		}
		foreach (TerrainFilter terrainFilter in filters)
		{
			Vector3 val = Vector3.Scale(terrainFilter.worldPosition, scale);
			val = rot * val;
			Vector3 val2 = pos + val;
			if (globalFilter != null && globalFilter.GetFactor(val2) == 0f)
			{
				return false;
			}
			if (!terrainFilter.Check(val2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class TerrainFilterGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementDistance = 8f;

	public SpawnFilter Filter;

	public bool CheckPlacementMap = true;
}


using UnityEngine;

public class CollateTrainTracks : ProceduralComponent
{
	private const float MAX_NODE_DIST = 0.1f;

	private const float MAX_NODE_DIST_SQR = 0.010000001f;

	private const float MAX_NODE_ANGLE = 10f;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline[] array = Object.FindObjectsOfType<TrainTrackSpline>();
		TrainTrackSpline[] array2;
		for (int num = array.Length - 1; num >= 0; num--)
		{
			TrainTrackSpline ourSpline = array[num];
			if (ourSpline.dataIndex < 0 && ourSpline.points.Length > 3)
			{
				int nodeIndex;
				for (nodeIndex = ourSpline.points.Length - 2; nodeIndex >= 1; nodeIndex--)
				{
					Vector3 ourPos2 = ourSpline.points[nodeIndex];
					Vector3 ourTangent2 = ourSpline.tangents[nodeIndex];
					array2 = array;
					foreach (TrainTrackSpline trainTrackSpline in array2)
					{
						if (!((Object)(object)ourSpline == (Object)(object)trainTrackSpline))
						{
							Vector3 startPointWorld = trainTrackSpline.GetStartPointWorld();
							Vector3 endPointWorld = trainTrackSpline.GetEndPointWorld();
							Vector3 startTangentWorld = trainTrackSpline.GetStartTangentWorld();
							Vector3 endTangentWorld = trainTrackSpline.GetEndTangentWorld();
							if (!CompareNodes(startPointWorld, startTangentWorld) && !CompareNodes(endPointWorld, endTangentWorld) && !CompareNodes(startPointWorld, -startTangentWorld))
							{
								CompareNodes(endPointWorld, -endTangentWorld);
							}
						}
					}
					bool CompareNodes(Vector3 theirPos, Vector3 theirTangent)
					{
						//IL_0002: Unknown result type (might be due to invalid IL or missing references)
						//IL_0007: Unknown result type (might be due to invalid IL or missing references)
						//IL_000a: Unknown result type (might be due to invalid IL or missing references)
						//IL_000f: Unknown result type (might be due to invalid IL or missing references)
						//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
						//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
						//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
						//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
						//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
						//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
						//IL_0113: Unknown result type (might be due to invalid IL or missing references)
						//IL_0118: Unknown result type (might be due to invalid IL or missing references)
						if (NodesConnect(ourPos2, theirPos, ourTangent2, theirTangent))
						{
							TrainTrackSpline trainTrackSpline2 = ((Component)ourSpline).gameObject.AddComponent<TrainTrackSpline>();
							Vector3[] array4 = (Vector3[])(object)new Vector3[ourSpline.points.Length - nodeIndex];
							Vector3[] array5 = (Vector3[])(object)new Vector3[ourSpline.points.Length - nodeIndex];
							Vector3[] array6 = (Vector3[])(object)new Vector3[nodeIndex + 1];
							Vector3[] array7 = (Vector3[])(object)new Vector3[nodeIndex + 1];
							for (int num2 = ourSpline.points.Length - 1; num2 >= 0; num2--)
							{
								if (num2 >= nodeIndex)
								{
									array4[num2 - nodeIndex] = ourSpline.points[num2];
									array5[num2 - nodeIndex] = ourSpline.tangents[num2];
								}
								if (num2 <= nodeIndex)
								{
									array6[num2] = ourSpline.points[num2];
									array7[num2] = ourSpline.tangents[num2];
								}
							}
							ourSpline.SetAll(array6, array7, ourSpline);
							trainTrackSpline2.SetAll(array4, array5, ourSpline);
							nodeIndex--;
							return true;
						}
						return false;
					}
				}
			}
		}
		array = Object.FindObjectsOfType<TrainTrackSpline>();
		array2 = array;
		foreach (TrainTrackSpline ourSpline2 in array2)
		{
			Vector3 ourStartPos = ourSpline2.GetStartPointWorld();
			Vector3 ourEndPos = ourSpline2.GetEndPointWorld();
			Vector3 ourStartTangent = ourSpline2.GetStartTangentWorld();
			Vector3 ourEndTangent = ourSpline2.GetEndTangentWorld();
			if (NodesConnect(ourStartPos, ourEndPos, ourStartTangent, ourEndTangent))
			{
				ourSpline2.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Next, TrainTrackSpline.TrackOrientation.Same);
				ourSpline2.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Prev, TrainTrackSpline.TrackOrientation.Same);
				continue;
			}
			TrainTrackSpline[] array3 = array;
			foreach (TrainTrackSpline otherSpline in array3)
			{
				Vector3 theirStartPos;
				Vector3 theirEndPos;
				Vector3 theirStartTangent;
				Vector3 theirEndTangent;
				if (!((Object)(object)ourSpline2 == (Object)(object)otherSpline))
				{
					theirStartPos = otherSpline.GetStartPointWorld();
					theirEndPos = otherSpline.GetEndPointWorld();
					theirStartTangent = otherSpline.GetStartTangentWorld();
					theirEndTangent = otherSpline.GetEndTangentWorld();
					if (!CompareNodes(ourStart: false, theirStart: true) && !CompareNodes(ourStart: false, theirStart: false) && !CompareNodes(ourStart: true, theirStart: true))
					{
						CompareNodes(ourStart: true, theirStart: false);
					}
				}
				bool CompareNodes(bool ourStart, bool theirStart)
				{
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0004: Unknown result type (might be due to invalid IL or missing references)
					//IL_001d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0015: Unknown result type (might be due to invalid IL or missing references)
					//IL_0022: Unknown result type (might be due to invalid IL or missing references)
					//IL_0031: Unknown result type (might be due to invalid IL or missing references)
					//IL_0028: Unknown result type (might be due to invalid IL or missing references)
					//IL_0036: Unknown result type (might be due to invalid IL or missing references)
					//IL_0045: Unknown result type (might be due to invalid IL or missing references)
					//IL_003c: Unknown result type (might be due to invalid IL or missing references)
					//IL_004a: Unknown result type (might be due to invalid IL or missing references)
					//IL_005b: Unknown result type (might be due to invalid IL or missing references)
					//IL_005c: Unknown result type (might be due to invalid IL or missing references)
					//IL_005d: Unknown result type (might be due to invalid IL or missing references)
					//IL_004f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0055: Unknown result type (might be due to invalid IL or missing references)
					//IL_005a: Unknown result type (might be due to invalid IL or missing references)
					Vector3 ourPos3 = (ourStart ? ourStartPos : ourEndPos);
					Vector3 ourTangent3 = (ourStart ? ourStartTangent : ourEndTangent);
					Vector3 theirPos2 = (theirStart ? theirStartPos : theirEndPos);
					Vector3 val = (theirStart ? theirStartTangent : theirEndTangent);
					if (ourStart == theirStart)
					{
						val *= -1f;
					}
					if (NodesConnect(ourPos3, theirPos2, ourTangent3, val))
					{
						if (ourStart)
						{
							ourSpline2.AddTrackConnection(otherSpline, TrainTrackSpline.TrackPosition.Prev, theirStart ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						else
						{
							ourSpline2.AddTrackConnection(otherSpline, TrainTrackSpline.TrackPosition.Next, (!theirStart) ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						if (theirStart)
						{
							otherSpline.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Prev, ourStart ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						else
						{
							otherSpline.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Next, (!ourStart) ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						return true;
					}
					return false;
				}
			}
		}
		static bool NodesConnect(Vector3 ourPos, Vector3 theirPos, Vector3 ourTangent, Vector3 theirTangent)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.SqrMagnitude(ourPos - theirPos) < 0.010000001f)
			{
				return Vector3.Angle(ourTangent, theirTangent) < 10f;
			}
			return false;
		}
	}
}


using UnityEngine;

public class MonumentNode : MonoBehaviour
{
	public string ResourceFolder = string.Empty;

	protected void Awake()
	{
		if (!((Object)(object)SingletonComponent<WorldSetup>.Instance == (Object)null))
		{
			if (SingletonComponent<WorldSetup>.Instance.MonumentNodes == null)
			{
				Debug.LogError((object)"WorldSetup.Instance.MonumentNodes is null.", (Object)(object)this);
			}
			else
			{
				SingletonComponent<WorldSetup>.Instance.MonumentNodes.Add(this);
			}
		}
	}

	public void Process(ref uint seed)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Monument", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		Prefab<MonumentInfo>[] array = Prefab.Load<MonumentInfo>("assets/bundled/prefabs/autospawn/" + ResourceFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
		if (array != null && array.Length != 0)
		{
			Prefab<MonumentInfo> random = array.GetRandom(ref seed);
			float height = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
			Vector3 pos = default(Vector3);
			((Vector3)(ref pos))..ctor(((Component)this).transform.position.x, height, ((Component)this).transform.position.z);
			Quaternion rot = random.Object.transform.localRotation;
			Vector3 scale = random.Object.transform.localScale;
			random.ApplyDecorComponents(ref pos, ref rot, ref scale);
			World.AddPrefab("Monument", random, pos, rot, scale);
		}
	}
}


using UnityEngine;

public abstract class ProceduralComponent : MonoBehaviour
{
	public enum Realm
	{
		Client = 1,
		Server
	}

	[InspectorFlags]
	public Realm Mode = (Realm)(-1);

	public string Description = "Procedural Component";

	public virtual bool RunOnCache => false;

	public bool ShouldRun()
	{
		if (World.Cached && !RunOnCache)
		{
			return false;
		}
		if ((Mode & Realm.Server) != 0)
		{
			return true;
		}
		return false;
	}

	public abstract void Process(uint seed);
}


public enum Realm
{
	Client = 1,
	Server
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateBiome : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_biome")]
	public unsafe static extern void Native_GenerateBiome(byte* nativeArrayPtr, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, float biomeJungle, short* heightmap, int heightres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		byte* unsafePtr = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.dst);
		int res = TerrainMeta.BiomeMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		Native_GenerateBiome(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic, World.Config.PercentageBiomeJungle, unsafePtr2, res2);
	}
}


using System.Threading.Tasks;
using UnityEngine;

public class GenerateCliffSplat : ProceduralComponent
{
	private const int filter = 8389632;

	public static void Process(int x, int z)
	{
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		float normZ = splatMap.Coordinate(z);
		float normX = splatMap.Coordinate(x);
		if ((TerrainMeta.TopologyMap.GetTopology(normX, normZ) & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			if (slope > 30f)
			{
				splatMap.SetSplat(x, z, 8, Mathf.InverseLerp(30f, 50f, slope));
			}
		}
	}

	public override void Process(uint seed)
	{
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		int splatres = splatMap.res;
		Parallel.For(0, splatres, delegate(int z)
		{
			for (int i = 0; i < splatres; i++)
			{
				Process(i, z);
			}
		});
	}
}


using System.Threading.Tasks;
using Unity.Collections;

public class GenerateCliffTopology : ProceduralComponent
{
	public bool KeepExisting = true;

	private const float slopeCutoff = 30f;

	private const float splatCutoff = 0.4f;

	private const int filter = 8389632;

	public static void Process(int x, int z)
	{
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		float normZ = topologyMap.Coordinate(z);
		float normX = topologyMap.Coordinate(x);
		if ((topologyMap.GetTopology(x, z) & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			float splat = TerrainMeta.SplatMap.GetSplat(normX, normZ, 8);
			if (slope > 30f || splat > 0.4f)
			{
				topologyMap.AddTopology(x, z, 2);
			}
			else
			{
				topologyMap.RemoveTopology(x, z, 2);
			}
		}
	}

	private static void Process(int x, int z, bool keepExisting)
	{
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		float normZ = topologyMap.Coordinate(z);
		float normX = topologyMap.Coordinate(x);
		int topology = topologyMap.GetTopology(x, z);
		if (!World.Procedural || (topology & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			float splat = TerrainMeta.SplatMap.GetSplat(normX, normZ, 8);
			if (slope > 30f || splat > 0.4f)
			{
				topologyMap.AddTopology(x, z, 2);
			}
			else if (!keepExisting)
			{
				topologyMap.RemoveTopology(x, z, 2);
			}
		}
	}

	public override void Process(uint seed)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<int> map = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				Process(i, z, KeepExisting);
			}
		});
		ImageProcessing.Dilate2D(map, res, res, 4194306, 1, delegate(int x, int y)
		{
			if ((map[x * res + y] & 2) == 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x400000;
			}
		});
	}
}


using Unity.Collections;

public class GenerateClutterTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<int> map = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		ImageProcessing.Dilate2D(map, res, res, 16777728, 3, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x200) == 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x1000000;
			}
		});
	}
}


using System.Threading.Tasks;

public class GenerateDecorTopology : ProceduralComponent
{
	public bool KeepExisting = true;

	public override void Process(uint seed)
	{
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		int topores = topomap.res;
		Parallel.For(0, topores, delegate(int z)
		{
			for (int i = 0; i < topores; i++)
			{
				if (topomap.GetTopology(i, z, 4194306))
				{
					topomap.AddTopology(i, z, 512);
				}
				else if (!KeepExisting)
				{
					topomap.RemoveTopology(i, z, 512);
				}
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateDungeonBase : ProceduralComponent
{
	private class DungeonSegment
	{
		public Vector3 position;

		public Quaternion rotation;

		public Prefab prefab;

		public DungeonBaseLink link;

		public int score;

		public int cost;

		public int floor;
	}

	public string EntranceFolder = string.Empty;

	public string LinkFolder = string.Empty;

	public string EndFolder = string.Empty;

	public string TransitionFolder = string.Empty;

	public InfrastructureType ConnectionType = InfrastructureType.UnderwaterLab;

	private static Vector3 VolumeExtrudePositive = Vector3.one * 0.01f;

	private static Vector3 VolumeExtrudeNegative = Vector3.one * -0.01f;

	private const int MaxCount = int.MaxValue;

	private const int MaxDepth = 3;

	private const int MaxFloor = 2;

	private List<DungeonSegment> segmentsTotal = new List<DungeonSegment>();

	private Quaternion[] horizontalRotations = (Quaternion[])(object)new Quaternion[1] { Quaternion.Euler(0f, 0f, 0f) };

	private Quaternion[] pillarRotations = (Quaternion[])(object)new Quaternion[4]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 270f, 0f)
	};

	private Quaternion[] verticalRotations = (Quaternion[])(object)new Quaternion[8]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 45f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 135f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 225f, 0f),
		Quaternion.Euler(0f, 270f, 0f),
		Quaternion.Euler(0f, 315f, 0f)
	};

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		if (World.Cached)
		{
			return;
		}
		if (World.Networked)
		{
			World.Spawn("DungeonBase");
		}
		else
		{
			if (ConnectionType == InfrastructureType.UnderwaterLab && !World.Config.UnderwaterLabs)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + EntranceFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array == null)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array2 = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + LinkFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array2 == null)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array3 = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + EndFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array3 == null)
			{
				return;
			}
			Prefab<DungeonBaseTransition>[] array4 = Prefab.Load<DungeonBaseTransition>("assets/bundled/prefabs/autospawn/" + TransitionFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array4 == null)
			{
				return;
			}
			foreach (DungeonBaseInfo item in Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.DungeonBaseEntrances : null)
			{
				TerrainPathConnect[] componentsInChildren = ((Component)item).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect obj in componentsInChildren)
				{
					if (obj.Type != ConnectionType)
					{
						continue;
					}
					uint seed2 = seed++;
					List<DungeonSegment> list = new List<DungeonSegment>();
					DungeonSegment segmentStart = new DungeonSegment();
					int num = 0;
					segmentStart.position = ((Component)item).transform.position;
					segmentStart.rotation = ((Component)item).transform.rotation;
					segmentStart.link = ((Component)item).GetComponentInChildren<DungeonBaseLink>();
					segmentStart.cost = 0;
					segmentStart.floor = 0;
					for (int j = 0; j < 25; j++)
					{
						List<DungeonSegment> list2 = new List<DungeonSegment>();
						list2.Add(segmentStart);
						PlaceSegments(ref seed2, int.MaxValue, 3, 2, attachToFemale: true, attachToMale: false, list2, array2);
						int num2 = list2.Count((DungeonSegment x) => x.link.MaxCountLocal != -1);
						if (num2 > num || (num2 == num && list2.Count > list.Count))
						{
							list = list2;
							num = num2;
						}
					}
					if (list.Count > 5)
					{
						list = list.OrderByDescending((DungeonSegment x) => Vector3Ex.SqrMagnitude2D(x.position - segmentStart.position)).ToList();
						PlaceSegments(ref seed2, 1, 4, 2, attachToFemale: true, attachToMale: false, list, array);
					}
					if (list.Count > 25)
					{
						DungeonSegment segmentEnd = list[list.Count - 1];
						list = list.OrderByDescending((DungeonSegment x) => Mathf.Min(Vector3Ex.SqrMagnitude2D(x.position - segmentStart.position), Vector3Ex.SqrMagnitude2D(x.position - segmentEnd.position))).ToList();
						PlaceSegments(ref seed2, 1, 5, 2, attachToFemale: true, attachToMale: false, list, array);
					}
					bool flag = true;
					while (flag)
					{
						flag = false;
						for (int k = 0; k < list.Count; k++)
						{
							DungeonSegment dungeonSegment = list[k];
							if (dungeonSegment.link.Cost <= 0 && !IsFullyOccupied(list, dungeonSegment))
							{
								list.RemoveAt(k--);
								flag = true;
							}
						}
					}
					PlaceSegments(ref seed2, int.MaxValue, int.MaxValue, 3, attachToFemale: true, attachToMale: true, list, array3);
					PlaceTransitions(ref seed2, list, array4);
					segmentsTotal.AddRange(list);
				}
			}
			foreach (DungeonSegment item2 in segmentsTotal)
			{
				if (item2.prefab != null)
				{
					World.AddPrefab("DungeonBase", item2.prefab, item2.position, item2.rotation, Vector3.one);
				}
			}
		}
	}

	private Quaternion[] GetRotationList(DungeonBaseSocketType type)
	{
		return type switch
		{
			DungeonBaseSocketType.Horizontal => horizontalRotations, 
			DungeonBaseSocketType.Vertical => verticalRotations, 
			DungeonBaseSocketType.Pillar => pillarRotations, 
			_ => null, 
		};
	}

	private int GetSocketFloor(DungeonBaseSocketType type)
	{
		if (type != DungeonBaseSocketType.Vertical)
		{
			return 0;
		}
		return 1;
	}

	private bool IsFullyOccupied(List<DungeonSegment> segments, DungeonSegment segment)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return SocketMatches(segments, segment.link, segment.position, segment.rotation) == segment.link.Sockets.Count;
	}

	private bool NeighbourMatches(List<DungeonSegment> segments, DungeonBaseTransition transition, Vector3 transitionPos, Quaternion transitionRot)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		bool flag2 = false;
		foreach (DungeonSegment segment in segments)
		{
			Vector3 val;
			if ((Object)(object)segment.link == (Object)null)
			{
				val = segment.position - transitionPos;
				if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
				{
					flag = false;
					flag2 = false;
				}
				continue;
			}
			foreach (DungeonBaseSocket socket in segment.link.Sockets)
			{
				val = segment.position + segment.rotation * ((Component)socket).transform.localPosition - transitionPos;
				if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
				{
					if (!flag && segment.link.Type == transition.Neighbour1)
					{
						flag = true;
					}
					else if (!flag2 && segment.link.Type == transition.Neighbour2)
					{
						flag2 = true;
					}
				}
			}
		}
		return flag && flag2;
	}

	private int SocketMatches(List<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (DungeonSegment segment in segments)
		{
			foreach (DungeonBaseSocket socket in segment.link.Sockets)
			{
				Vector3 val = segment.position + segment.rotation * ((Component)socket).transform.localPosition;
				foreach (DungeonBaseSocket socket2 in link.Sockets)
				{
					if (!((Object)(object)socket == (Object)(object)socket2))
					{
						Vector3 val2 = linkPos + linkRot * ((Component)socket2).transform.localPosition;
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							num++;
						}
					}
				}
			}
		}
		return num;
	}

	private bool IsOccupied(List<DungeonSegment> segments, DungeonBaseSocket socket, Vector3 socketPos, Quaternion socketRot)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		foreach (DungeonSegment segment in segments)
		{
			foreach (DungeonBaseSocket socket2 in segment.link.Sockets)
			{
				if (!((Object)(object)socket2 == (Object)(object)socket))
				{
					Vector3 val = segment.position + segment.rotation * ((Component)socket2).transform.localPosition - socketPos;
					if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private int CountLocal(List<DungeonSegment> segments, DungeonBaseLink link)
	{
		int num = 0;
		if ((Object)(object)link == (Object)null)
		{
			return num;
		}
		foreach (DungeonSegment segment in segments)
		{
			if (!((Object)(object)segment.link == (Object)null))
			{
				if ((Object)(object)segment.link == (Object)(object)link)
				{
					num++;
				}
				else if (segment.link.MaxCountIdentifier >= 0 && segment.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		return num;
	}

	private int CountGlobal(List<DungeonSegment> segments, DungeonBaseLink link)
	{
		int num = 0;
		if ((Object)(object)link == (Object)null)
		{
			return num;
		}
		foreach (DungeonSegment segment in segments)
		{
			if (!((Object)(object)segment.link == (Object)null))
			{
				if ((Object)(object)segment.link == (Object)(object)link)
				{
					num++;
				}
				else if (segment.link.MaxCountIdentifier >= 0 && segment.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		foreach (DungeonSegment item in segmentsTotal)
		{
			if (!((Object)(object)item.link == (Object)null))
			{
				if ((Object)(object)item.link == (Object)(object)link)
				{
					num++;
				}
				else if (item.link.MaxCountIdentifier >= 0 && item.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		return num;
	}

	private bool IsBlocked(List<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3;
		foreach (DungeonVolume volume in link.Volumes)
		{
			OBB bounds = volume.GetBounds(linkPos, linkRot, VolumeExtrudeNegative);
			OBB bounds2 = volume.GetBounds(linkPos, linkRot, VolumeExtrudePositive);
			foreach (DungeonSegment segment in segments)
			{
				foreach (DungeonVolume volume2 in segment.link.Volumes)
				{
					OBB bounds3 = volume2.GetBounds(segment.position, segment.rotation, VolumeExtrudeNegative);
					if (((OBB)(ref bounds)).Intersects(bounds3))
					{
						return true;
					}
				}
				foreach (DungeonBaseSocket socket in segment.link.Sockets)
				{
					Vector3 val = segment.position + segment.rotation * ((Component)socket).transform.localPosition;
					if (!((OBB)(ref bounds2)).Contains(val))
					{
						continue;
					}
					bool flag = false;
					foreach (DungeonBaseSocket socket2 in link.Sockets)
					{
						Vector3 val2 = linkPos + linkRot * ((Component)socket2).transform.localPosition;
						val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return true;
					}
				}
			}
		}
		foreach (DungeonSegment segment2 in segments)
		{
			foreach (DungeonVolume volume3 in segment2.link.Volumes)
			{
				OBB bounds4 = volume3.GetBounds(segment2.position, segment2.rotation, VolumeExtrudePositive);
				foreach (DungeonBaseSocket socket3 in link.Sockets)
				{
					Vector3 val4 = linkPos + linkRot * ((Component)socket3).transform.localPosition;
					if (!((OBB)(ref bounds4)).Contains(val4))
					{
						continue;
					}
					bool flag2 = false;
					foreach (DungeonBaseSocket socket4 in segment2.link.Sockets)
					{
						val3 = segment2.position + segment2.rotation * ((Component)socket4).transform.localPosition - val4;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							flag2 = true;
							break;
						}
					}
					if (!flag2)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private void PlaceSegments(ref uint seed, int count, int budget, int floors, bool attachToFemale, bool attachToMale, List<DungeonSegment> segments, Prefab<DungeonBaseLink>[] prefabs)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < segments.Count; i++)
		{
			DungeonSegment dungeonSegment = segments[i];
			if (dungeonSegment.cost >= budget)
			{
				continue;
			}
			int num2 = SeedRandom.Range(ref seed, 0, dungeonSegment.link.Sockets.Count);
			for (int j = 0; j < dungeonSegment.link.Sockets.Count; j++)
			{
				DungeonBaseSocket dungeonBaseSocket = dungeonSegment.link.Sockets[(j + num2) % dungeonSegment.link.Sockets.Count];
				if (!(dungeonBaseSocket.Female && attachToFemale) && !(dungeonBaseSocket.Male && attachToMale))
				{
					continue;
				}
				Vector3 val = dungeonSegment.position + dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localPosition;
				Quaternion val2 = dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localRotation;
				if (IsOccupied(segments, dungeonBaseSocket, val, val2))
				{
					continue;
				}
				prefabs.Shuffle(ref seed);
				DungeonSegment dungeonSegment2 = null;
				Quaternion[] rotationList = GetRotationList(dungeonBaseSocket.Type);
				foreach (Prefab<DungeonBaseLink> prefab in prefabs)
				{
					DungeonBaseLink component = prefab.Component;
					if (component.MaxCountLocal == 0 || component.MaxCountGlobal == 0 || (component.MaxFloor >= 0 && dungeonSegment.floor > component.MaxFloor))
					{
						continue;
					}
					int num3 = dungeonSegment.cost + component.Cost;
					if (num3 > budget)
					{
						continue;
					}
					int num4 = dungeonSegment.floor + GetSocketFloor(dungeonBaseSocket.Type);
					if (num4 > floors)
					{
						continue;
					}
					DungeonBaseSocket linkSocket = null;
					Vector3 linkPos = Vector3.zero;
					Quaternion linkRot = Quaternion.identity;
					int linkScore = 0;
					if (Place(ref seed, segments, dungeonBaseSocket, val, val2, prefab, rotationList, out linkSocket, out linkPos, out linkRot, out linkScore) && (component.MaxCountLocal <= 0 || CountLocal(segments, component) < component.MaxCountLocal) && (component.MaxCountGlobal <= 0 || CountGlobal(segments, component) < component.MaxCountGlobal))
					{
						DungeonSegment dungeonSegment3 = new DungeonSegment();
						dungeonSegment3.position = linkPos;
						dungeonSegment3.rotation = linkRot;
						dungeonSegment3.prefab = prefab;
						dungeonSegment3.link = component;
						dungeonSegment3.score = linkScore;
						dungeonSegment3.cost = num3;
						dungeonSegment3.floor = num4;
						if (dungeonSegment2 == null || dungeonSegment2.score < dungeonSegment3.score)
						{
							dungeonSegment2 = dungeonSegment3;
						}
					}
				}
				if (dungeonSegment2 != null)
				{
					segments.Add(dungeonSegment2);
					num++;
					if (num >= count)
					{
						return;
					}
				}
			}
		}
	}

	private void PlaceTransitions(ref uint seed, List<DungeonSegment> segments, Prefab<DungeonBaseTransition>[] prefabs)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		int count = segments.Count;
		for (int i = 0; i < count; i++)
		{
			DungeonSegment dungeonSegment = segments[i];
			int num = SeedRandom.Range(ref seed, 0, dungeonSegment.link.Sockets.Count);
			for (int j = 0; j < dungeonSegment.link.Sockets.Count; j++)
			{
				DungeonBaseSocket dungeonBaseSocket = dungeonSegment.link.Sockets[(j + num) % dungeonSegment.link.Sockets.Count];
				Vector3 val = dungeonSegment.position + dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localPosition;
				Quaternion val2 = dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localRotation;
				prefabs.Shuffle(ref seed);
				foreach (Prefab<DungeonBaseTransition> prefab in prefabs)
				{
					if (dungeonBaseSocket.Type == prefab.Component.Type && NeighbourMatches(segments, prefab.Component, val, val2))
					{
						DungeonSegment dungeonSegment2 = new DungeonSegment();
						dungeonSegment2.position = val;
						dungeonSegment2.rotation = val2;
						dungeonSegment2.prefab = prefab;
						dungeonSegment2.link = null;
						dungeonSegment2.score = 0;
						dungeonSegment2.cost = 0;
						dungeonSegment2.floor = 0;
						segments.Add(dungeonSegment2);
						break;
					}
				}
			}
		}
	}

	private bool Place(ref uint seed, List<DungeonSegment> segments, DungeonBaseSocket targetSocket, Vector3 targetPos, Quaternion targetRot, Prefab<DungeonBaseLink> prefab, Quaternion[] rotations, out DungeonBaseSocket linkSocket, out Vector3 linkPos, out Quaternion linkRot, out int linkScore)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		linkSocket = null;
		linkPos = Vector3.one;
		linkRot = Quaternion.identity;
		linkScore = 0;
		DungeonBaseLink component = prefab.Component;
		int num = SeedRandom.Range(ref seed, 0, component.Sockets.Count);
		for (int i = 0; i < component.Sockets.Count; i++)
		{
			DungeonBaseSocket dungeonBaseSocket = component.Sockets[(i + num) % component.Sockets.Count];
			if (dungeonBaseSocket.Type != targetSocket.Type || ((!dungeonBaseSocket.Male || !targetSocket.Female) && (!dungeonBaseSocket.Female || !targetSocket.Male)))
			{
				continue;
			}
			rotations.Shuffle(ref seed);
			foreach (Quaternion val in rotations)
			{
				Quaternion val2 = Quaternion.FromToRotation(-((Component)dungeonBaseSocket).transform.forward, targetRot * Vector3.forward);
				if (dungeonBaseSocket.Type != DungeonBaseSocketType.Vertical)
				{
					val2 = QuaternionEx.LookRotationForcedUp(val2 * Vector3.forward, Vector3.up);
				}
				Quaternion val3 = val * val2;
				Vector3 val4 = targetPos - val3 * ((Component)dungeonBaseSocket).transform.localPosition;
				if (!IsBlocked(segments, component, val4, val3))
				{
					int num2 = SocketMatches(segments, component, val4, val3);
					if (num2 > linkScore && prefab.CheckEnvironmentVolumesOutsideTerrain(val4, val3, Vector3.one, EnvironmentType.UnderwaterLab, (EnvironmentType)0, 1f))
					{
						linkSocket = dungeonBaseSocket;
						linkPos = val4;
						linkRot = val3;
						linkScore = num2;
					}
				}
			}
		}
		return linkScore > 0;
	}

	public static void SetupAI()
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Expected O, but got Unknown
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.DungeonBaseEntrances == null)
		{
			return;
		}
		foreach (DungeonBaseInfo dungeonBaseEntrance in TerrainMeta.Path.DungeonBaseEntrances)
		{
			if ((Object)(object)dungeonBaseEntrance == (Object)null)
			{
				continue;
			}
			List<AIInformationZone> list = new List<AIInformationZone>();
			int num = 0;
			AIInformationZone componentInChildren = ((Component)dungeonBaseEntrance).GetComponentInChildren<AIInformationZone>();
			if ((Object)(object)componentInChildren != (Object)null)
			{
				list.Add(componentInChildren);
				num++;
			}
			foreach (GameObject link in ((Component)dungeonBaseEntrance).GetComponent<DungeonBaseInfo>().Links)
			{
				AIInformationZone componentInChildren2 = link.GetComponentInChildren<AIInformationZone>();
				if (!((Object)(object)componentInChildren2 == (Object)null))
				{
					list.Add(componentInChildren2);
					num++;
				}
			}
			GameObject val = new GameObject("AIZ");
			val.transform.position = ((Component)dungeonBaseEntrance).gameObject.transform.position;
			AIInformationZone aIInformationZone = AIInformationZone.Merge(list, val);
			aIInformationZone.ShouldSleepAI = true;
			val.transform.SetParent(((Component)dungeonBaseEntrance).gameObject.transform);
			GameObject val2 = new GameObject("WakeTrigger");
			val2.transform.position = val.transform.position + ((Bounds)(ref aIInformationZone.bounds)).center;
			val2.transform.localScale = ((Bounds)(ref aIInformationZone.bounds)).extents + new Vector3(100f, 100f, 100f);
			((Collider)val2.AddComponent<BoxCollider>()).isTrigger = true;
			val2.layer = LayerMask.NameToLayer("Trigger");
			val2.transform.SetParent(((Component)dungeonBaseEntrance).gameObject.transform);
			TriggerWakeAIZ triggerWakeAIZ = val2.AddComponent<TriggerWakeAIZ>();
			triggerWakeAIZ.InterestLayers = LayerMask.op_Implicit(LayerMask.GetMask(new string[1] { "Player (Server)" }));
			triggerWakeAIZ.Init(aIInformationZone);
		}
	}
}


using UnityEngine;

private class DungeonSegment
{
	public Vector3 position;

	public Quaternion rotation;

	public Prefab prefab;

	public DungeonBaseLink link;

	public int score;

	public int cost;

	public int floor;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateDungeonGrid : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;
	}

	private class PathLink
	{
		public PathLinkSide downwards;

		public PathLinkSide upwards;
	}

	private class PathLinkSide
	{
		public PathLinkSegment origin;

		public List<PathLinkSegment> segments;

		public PathLinkSegment prevSegment
		{
			get
			{
				if (segments.Count <= 0)
				{
					return origin;
				}
				return segments[segments.Count - 1];
			}
		}
	}

	private class PathLinkSegment
	{
		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public Prefab<DungeonGridLink> prefab;

		public DungeonGridLink link;

		public Transform downSocket => link.DownSocket;

		public Transform upSocket => link.UpSocket;

		public DungeonGridLinkType downType => link.DownType;

		public DungeonGridLinkType upType => link.UpType;
	}

	private struct PrefabReplacement
	{
		public Vector2i gridPosition;

		public Vector3 worldPosition;

		public int distance;

		public Prefab<DungeonGridCell> prefab;
	}

	public string TunnelFolder = string.Empty;

	public string StationFolder = string.Empty;

	public string UpwardsFolder = string.Empty;

	public string TransitionFolder = string.Empty;

	public string LinkFolder = string.Empty;

	public InfrastructureType ConnectionType = InfrastructureType.Tunnel;

	public int CellSize = 216;

	public float LinkHeight = 1.5f;

	public float LinkRadius = 3f;

	public float LinkTransition = 9f;

	private const int MaxDepth = 100000;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_107f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1084: Unknown result type (might be due to invalid IL or missing references)
		//IL_1086: Unknown result type (might be due to invalid IL or missing references)
		//IL_108b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_108d: Unknown result type (might be due to invalid IL or missing references)
		//IL_108f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_1116: Unknown result type (might be due to invalid IL or missing references)
		//IL_1118: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10db: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1141: Unknown result type (might be due to invalid IL or missing references)
		//IL_1146: Unknown result type (might be due to invalid IL or missing references)
		//IL_1148: Unknown result type (might be due to invalid IL or missing references)
		//IL_114d: Unknown result type (might be due to invalid IL or missing references)
		//IL_118e: Unknown result type (might be due to invalid IL or missing references)
		//IL_119f: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_11cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_11da: Unknown result type (might be due to invalid IL or missing references)
		//IL_11e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_11f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_120f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1220: Unknown result type (might be due to invalid IL or missing references)
		//IL_1225: Unknown result type (might be due to invalid IL or missing references)
		//IL_122a: Unknown result type (might be due to invalid IL or missing references)
		//IL_122f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1234: Unknown result type (might be due to invalid IL or missing references)
		//IL_1236: Unknown result type (might be due to invalid IL or missing references)
		//IL_123b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1254: Unknown result type (might be due to invalid IL or missing references)
		//IL_1259: Unknown result type (might be due to invalid IL or missing references)
		//IL_126f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1274: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_1287: Unknown result type (might be due to invalid IL or missing references)
		//IL_128c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f25: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_12bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1300: Unknown result type (might be due to invalid IL or missing references)
		//IL_1305: Unknown result type (might be due to invalid IL or missing references)
		//IL_130a: Unknown result type (might be due to invalid IL or missing references)
		//IL_130f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1314: Unknown result type (might be due to invalid IL or missing references)
		//IL_1318: Unknown result type (might be due to invalid IL or missing references)
		//IL_1324: Unknown result type (might be due to invalid IL or missing references)
		//IL_1329: Unknown result type (might be due to invalid IL or missing references)
		//IL_132e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1820: Unknown result type (might be due to invalid IL or missing references)
		//IL_1822: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f82: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f89: Unknown result type (might be due to invalid IL or missing references)
		//IL_229f: Unknown result type (might be due to invalid IL or missing references)
		//IL_22a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_22a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_22af: Unknown result type (might be due to invalid IL or missing references)
		//IL_22b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_22b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_22b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_22bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_056f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_1837: Unknown result type (might be due to invalid IL or missing references)
		//IL_1839: Unknown result type (might be due to invalid IL or missing references)
		//IL_1840: Unknown result type (might be due to invalid IL or missing references)
		//IL_1842: Unknown result type (might be due to invalid IL or missing references)
		//IL_1849: Unknown result type (might be due to invalid IL or missing references)
		//IL_184e: Unknown result type (might be due to invalid IL or missing references)
		//IL_187d: Unknown result type (might be due to invalid IL or missing references)
		//IL_187f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1881: Unknown result type (might be due to invalid IL or missing references)
		//IL_1886: Unknown result type (might be due to invalid IL or missing references)
		//IL_2026: Unknown result type (might be due to invalid IL or missing references)
		//IL_2028: Unknown result type (might be due to invalid IL or missing references)
		//IL_202d: Unknown result type (might be due to invalid IL or missing references)
		//IL_202f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2034: Unknown result type (might be due to invalid IL or missing references)
		//IL_05de: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1890: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_138d: Unknown result type (might be due to invalid IL or missing references)
		//IL_13c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_18cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_18de: Unknown result type (might be due to invalid IL or missing references)
		//IL_18e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_18f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_18fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1902: Unknown result type (might be due to invalid IL or missing references)
		//IL_1907: Unknown result type (might be due to invalid IL or missing references)
		//IL_190c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1910: Unknown result type (might be due to invalid IL or missing references)
		//IL_191c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1921: Unknown result type (might be due to invalid IL or missing references)
		//IL_1926: Unknown result type (might be due to invalid IL or missing references)
		//IL_189e: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0634: Unknown result type (might be due to invalid IL or missing references)
		//IL_063b: Unknown result type (might be due to invalid IL or missing references)
		//IL_139e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_050a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0514: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06da: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0732: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_0748: Unknown result type (might be due to invalid IL or missing references)
		//IL_074d: Unknown result type (might be due to invalid IL or missing references)
		//IL_079f: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0666: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1404: Unknown result type (might be due to invalid IL or missing references)
		//IL_1406: Unknown result type (might be due to invalid IL or missing references)
		//IL_140f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1414: Unknown result type (might be due to invalid IL or missing references)
		//IL_1419: Unknown result type (might be due to invalid IL or missing references)
		//IL_142b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1437: Unknown result type (might be due to invalid IL or missing references)
		//IL_143c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1441: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e18: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1489: Unknown result type (might be due to invalid IL or missing references)
		//IL_148b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1494: Unknown result type (might be due to invalid IL or missing references)
		//IL_1499: Unknown result type (might be due to invalid IL or missing references)
		//IL_149e: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_14bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14da: Unknown result type (might be due to invalid IL or missing references)
		//IL_14df: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1500: Unknown result type (might be due to invalid IL or missing references)
		//IL_1502: Unknown result type (might be due to invalid IL or missing references)
		//IL_1507: Unknown result type (might be due to invalid IL or missing references)
		//IL_151b: Unknown result type (might be due to invalid IL or missing references)
		//IL_151d: Unknown result type (might be due to invalid IL or missing references)
		//IL_144d: Unknown result type (might be due to invalid IL or missing references)
		//IL_144f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e31: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e38: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e41: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e75: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e77: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e79: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1463: Unknown result type (might be due to invalid IL or missing references)
		//IL_1465: Unknown result type (might be due to invalid IL or missing references)
		//IL_1467: Unknown result type (might be due to invalid IL or missing references)
		//IL_146c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1473: Unknown result type (might be due to invalid IL or missing references)
		//IL_1475: Unknown result type (might be due to invalid IL or missing references)
		//IL_1477: Unknown result type (might be due to invalid IL or missing references)
		//IL_147c: Unknown result type (might be due to invalid IL or missing references)
		//IL_147e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1480: Unknown result type (might be due to invalid IL or missing references)
		//IL_1482: Unknown result type (might be due to invalid IL or missing references)
		//IL_1487: Unknown result type (might be due to invalid IL or missing references)
		//IL_19a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_20bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1564: Unknown result type (might be due to invalid IL or missing references)
		//IL_1570: Unknown result type (might be due to invalid IL or missing references)
		//IL_1985: Unknown result type (might be due to invalid IL or missing references)
		//IL_19ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_20da: Unknown result type (might be due to invalid IL or missing references)
		//IL_20dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_20e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1587: Unknown result type (might be due to invalid IL or missing references)
		//IL_1996: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_20fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_159a: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_19ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_19f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_19f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_19fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_19fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a07: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a11: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a23: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a34: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a39: Unknown result type (might be due to invalid IL or missing references)
		//IL_23e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_23e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_23fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2403: Unknown result type (might be due to invalid IL or missing references)
		//IL_2408: Unknown result type (might be due to invalid IL or missing references)
		//IL_2411: Unknown result type (might be due to invalid IL or missing references)
		//IL_2413: Unknown result type (might be due to invalid IL or missing references)
		//IL_2415: Unknown result type (might be due to invalid IL or missing references)
		//IL_241a: Unknown result type (might be due to invalid IL or missing references)
		//IL_241f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2118: Unknown result type (might be due to invalid IL or missing references)
		//IL_211a: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a81: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a83: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a91: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a96: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aa6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1abc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1acc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ace: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aeb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aed: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aef: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1afa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b13: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b15: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a45: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a47: Unknown result type (might be due to invalid IL or missing references)
		//IL_24fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2500: Unknown result type (might be due to invalid IL or missing references)
		//IL_2516: Unknown result type (might be due to invalid IL or missing references)
		//IL_251b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2520: Unknown result type (might be due to invalid IL or missing references)
		//IL_2529: Unknown result type (might be due to invalid IL or missing references)
		//IL_252b: Unknown result type (might be due to invalid IL or missing references)
		//IL_252d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2532: Unknown result type (might be due to invalid IL or missing references)
		//IL_2537: Unknown result type (might be due to invalid IL or missing references)
		//IL_213a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2125: Unknown result type (might be due to invalid IL or missing references)
		//IL_212e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2133: Unknown result type (might be due to invalid IL or missing references)
		//IL_2138: Unknown result type (might be due to invalid IL or missing references)
		//IL_1602: Unknown result type (might be due to invalid IL or missing references)
		//IL_160e: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_15f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a64: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a69: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a74: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a76: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a78: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2149: Unknown result type (might be due to invalid IL or missing references)
		//IL_1625: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b68: Unknown result type (might be due to invalid IL or missing references)
		//IL_2165: Unknown result type (might be due to invalid IL or missing references)
		//IL_2167: Unknown result type (might be due to invalid IL or missing references)
		//IL_216e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2170: Unknown result type (might be due to invalid IL or missing references)
		//IL_1638: Unknown result type (might be due to invalid IL or missing references)
		//IL_163f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_16f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1658: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bab: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b92: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b99: Unknown result type (might be due to invalid IL or missing references)
		//IL_16fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1669: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bce: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c06: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1742: Unknown result type (might be due to invalid IL or missing references)
		//IL_1713: Unknown result type (might be due to invalid IL or missing references)
		//IL_1680: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1801: Unknown result type (might be due to invalid IL or missing references)
		//IL_1807: Unknown result type (might be due to invalid IL or missing references)
		//IL_1809: Unknown result type (might be due to invalid IL or missing references)
		//IL_180b: Unknown result type (might be due to invalid IL or missing references)
		//IL_180d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1795: Unknown result type (might be due to invalid IL or missing references)
		//IL_1765: Unknown result type (might be due to invalid IL or missing references)
		//IL_16b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1693: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c30: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c37: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_16c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ce8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c50: Unknown result type (might be due to invalid IL or missing references)
		//IL_17eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cf6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c61: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c78: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e01: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e03: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e05: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cae: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dad: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cc1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1de3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1de5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Cached)
		{
			return;
		}
		if (World.Networked)
		{
			World.Spawn("Dungeon");
		}
		else
		{
			if (ConnectionType == InfrastructureType.Tunnel && !World.Config.BelowGroundRails)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + TunnelFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array == null || array.Length == 0)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array2 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + StationFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array2 == null || array2.Length == 0)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array3 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + UpwardsFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array3 == null)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array4 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + TransitionFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array4 == null)
			{
				return;
			}
			Prefab<DungeonGridLink>[] array5 = Prefab.Load<DungeonGridLink>("assets/bundled/prefabs/autospawn/" + LinkFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array5 == null)
			{
				return;
			}
			array5 = array5.OrderByDescending((Prefab<DungeonGridLink> x) => x.Component.Priority).ToArray();
			List<DungeonGridInfo> list = (Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.DungeonGridEntrances : null);
			WorldSpaceGrid<Prefab<DungeonGridCell>> val = new WorldSpaceGrid<Prefab<DungeonGridCell>>(TerrainMeta.Size.x, (float)CellSize, (RoundingMode)1);
			int[,] array6 = new int[val.CellCount, val.CellCount];
			DungeonGridConnectionHash[,] hashmap = new DungeonGridConnectionHash[val.CellCount, val.CellCount];
			PathFinder pathFinder = new PathFinder(array6, diagonals: false);
			int cellCount = val.CellCount;
			int num = 0;
			int num2 = val.CellCount - 1;
			for (int i = 0; i < cellCount; i++)
			{
				for (int j = 0; j < cellCount; j++)
				{
					array6[j, i] = 1;
				}
			}
			List<PathSegment> list2 = new List<PathSegment>();
			List<PathLink> list3 = new List<PathLink>();
			List<PathNode> list4 = new List<PathNode>();
			List<PathNode> unconnectedNodeList = new List<PathNode>();
			List<PathNode> secondaryNodeList = new List<PathNode>();
			List<PathFinder.Point> list5 = new List<PathFinder.Point>();
			List<PathFinder.Point> list6 = new List<PathFinder.Point>();
			List<PathFinder.Point> list7 = new List<PathFinder.Point>();
			foreach (DungeonGridInfo item3 in list)
			{
				DungeonGridInfo entrance = item3;
				TerrainPathConnect[] componentsInChildren = ((Component)entrance).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type != ConnectionType)
					{
						continue;
					}
					Vector2i val2 = val.WorldToGridCoords(((Component)terrainPathConnect).transform.position);
					if (array6[val2.x, val2.y] == int.MaxValue)
					{
						continue;
					}
					PathFinder.Node stationNode = pathFinder.FindClosestWalkable(new PathFinder.Point(val2.x, val2.y), 1);
					if (stationNode == null)
					{
						continue;
					}
					Prefab<DungeonGridCell> prefab2 = ((val2.x > num) ? val[val2.x - 1, val2.y] : null);
					Prefab<DungeonGridCell> prefab3 = ((val2.x < num2) ? val[val2.x + 1, val2.y] : null);
					Prefab<DungeonGridCell> prefab4 = ((val2.y > num) ? val[val2.x, val2.y - 1] : null);
					Prefab<DungeonGridCell> obj = ((val2.y < num2) ? val[val2.x, val2.y + 1] : null);
					DungeonGridConnectionType dungeonGridConnectionType = prefab2?.Component.East ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType2 = prefab3?.Component.West ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType3 = prefab4?.Component.North ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType4 = obj?.Component.South ?? DungeonGridConnectionType.None;
					bool flag = prefab2 != null || val2.x <= num;
					bool flag2 = prefab3 != null || val2.x >= num2;
					bool flag3 = prefab4 != null || val2.y <= num;
					bool flag4 = obj != null || val2.y >= num2;
					Prefab<DungeonGridCell> prefab5 = null;
					float num3 = float.MaxValue;
					array2.Shuffle(ref seed);
					Prefab<DungeonGridCell>[] array7 = array2;
					foreach (Prefab<DungeonGridCell> prefab6 in array7)
					{
						if ((flag && prefab6.Component.West != dungeonGridConnectionType) || (flag2 && prefab6.Component.East != dungeonGridConnectionType2) || (flag3 && prefab6.Component.South != dungeonGridConnectionType3) || (flag4 && prefab6.Component.North != dungeonGridConnectionType4))
						{
							continue;
						}
						DungeonVolume componentInChildren = prefab6.Object.GetComponentInChildren<DungeonVolume>();
						DungeonVolume componentInChildren2 = ((Component)entrance).GetComponentInChildren<DungeonVolume>();
						OBB bounds = componentInChildren.GetBounds(val.GridToWorldCoords(val2), Quaternion.identity);
						OBB bounds2 = componentInChildren2.GetBounds(((Component)entrance).transform.position, Quaternion.identity);
						if (!((OBB)(ref bounds)).Intersects2D(bounds2))
						{
							DungeonGridLink componentInChildren3 = prefab6.Object.GetComponentInChildren<DungeonGridLink>();
							Vector3 val3 = val.GridToWorldCoords(new Vector2i(val2.x, val2.y)) + componentInChildren3.UpSocket.localPosition;
							float num4 = Vector3Ex.Magnitude2D(((Component)terrainPathConnect).transform.position - val3);
							if (!(num3 < num4))
							{
								prefab5 = prefab6;
								num3 = num4;
							}
						}
					}
					bool isStartPoint;
					if (prefab5 != null)
					{
						val[val2.x, val2.y] = prefab5;
						array6[val2.x, val2.y] = int.MaxValue;
						isStartPoint = secondaryNodeList.Count == 0;
						secondaryNodeList.RemoveAll((PathNode x) => x.node.point == stationNode.point);
						unconnectedNodeList.RemoveAll((PathNode x) => x.node.point == stationNode.point);
						if (prefab5.Component.West != 0)
						{
							AddNode(val2.x - 1, val2.y);
						}
						if (prefab5.Component.East != 0)
						{
							AddNode(val2.x + 1, val2.y);
						}
						if (prefab5.Component.South != 0)
						{
							AddNode(val2.x, val2.y - 1);
						}
						if (prefab5.Component.North != 0)
						{
							AddNode(val2.x, val2.y + 1);
						}
						PathLink pathLink = new PathLink();
						DungeonGridLink componentInChildren4 = ((Component)entrance).gameObject.GetComponentInChildren<DungeonGridLink>();
						Vector3 position = ((Component)entrance).transform.position;
						Quaternion rotation = ((Component)entrance).transform.rotation;
						Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
						DungeonGridLink componentInChildren5 = prefab5.Object.GetComponentInChildren<DungeonGridLink>();
						Vector3 position2 = val.GridToWorldCoords(new Vector2i(val2.x, val2.y));
						Vector3 zero = Vector3.zero;
						pathLink.downwards = new PathLinkSide();
						pathLink.downwards.origin = new PathLinkSegment();
						pathLink.downwards.origin.position = position;
						pathLink.downwards.origin.rotation = Quaternion.Euler(eulerAngles);
						pathLink.downwards.origin.scale = Vector3.one;
						pathLink.downwards.origin.link = componentInChildren4;
						pathLink.downwards.segments = new List<PathLinkSegment>();
						pathLink.upwards = new PathLinkSide();
						pathLink.upwards.origin = new PathLinkSegment();
						pathLink.upwards.origin.position = position2;
						pathLink.upwards.origin.rotation = Quaternion.Euler(zero);
						pathLink.upwards.origin.scale = Vector3.one;
						pathLink.upwards.origin.link = componentInChildren5;
						pathLink.upwards.segments = new List<PathLinkSegment>();
						list3.Add(pathLink);
					}
					void AddNode(int x, int y)
					{
						//IL_0059: Unknown result type (might be due to invalid IL or missing references)
						PathFinder.Node node8 = pathFinder.FindClosestWalkable(new PathFinder.Point(x, y), 1);
						if (node8 != null)
						{
							PathNode item2 = new PathNode
							{
								monument = (Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.FindClosest(TerrainMeta.Path.Monuments, ((Component)entrance).transform.position) : ((Component)((Component)entrance).transform).GetComponentInParent<MonumentInfo>()),
								node = node8
							};
							if (isStartPoint)
							{
								secondaryNodeList.Add(item2);
							}
							else
							{
								unconnectedNodeList.Add(item2);
							}
							DungeonGridConnectionHash dungeonGridConnectionHash4 = hashmap[node8.point.x, node8.point.y];
							DungeonGridConnectionHash dungeonGridConnectionHash5 = hashmap[stationNode.point.x, stationNode.point.y];
							if (node8.point.x > stationNode.point.x)
							{
								dungeonGridConnectionHash4.West = true;
								dungeonGridConnectionHash5.East = true;
							}
							if (node8.point.x < stationNode.point.x)
							{
								dungeonGridConnectionHash4.East = true;
								dungeonGridConnectionHash5.West = true;
							}
							if (node8.point.y > stationNode.point.y)
							{
								dungeonGridConnectionHash4.South = true;
								dungeonGridConnectionHash5.North = true;
							}
							if (node8.point.y < stationNode.point.y)
							{
								dungeonGridConnectionHash4.North = true;
								dungeonGridConnectionHash5.South = true;
							}
							hashmap[node8.point.x, node8.point.y] = dungeonGridConnectionHash4;
							hashmap[stationNode.point.x, stationNode.point.y] = dungeonGridConnectionHash5;
						}
					}
				}
			}
			while (unconnectedNodeList.Count != 0 || secondaryNodeList.Count != 0)
			{
				if (unconnectedNodeList.Count == 0)
				{
					PathNode node = secondaryNodeList[0];
					unconnectedNodeList.AddRange(secondaryNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node.monument));
					secondaryNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node.monument);
					Vector2i val4 = val.WorldToGridCoords(((Component)node.monument).transform.position);
					pathFinder.PushPoint = new PathFinder.Point(val4.x, val4.y);
					pathFinder.PushRadius = (pathFinder.PushDistance = 2);
					pathFinder.PushMultiplier = 16;
				}
				list7.Clear();
				list7.AddRange(unconnectedNodeList.Select((PathNode x) => x.node.point));
				list6.Clear();
				list6.AddRange(list4.Select((PathNode x) => x.node.point));
				list6.AddRange(secondaryNodeList.Select((PathNode x) => x.node.point));
				list6.AddRange(list5);
				PathFinder.Node node2 = pathFinder.FindPathUndirected(list6, list7, 100000);
				if (node2 == null)
				{
					PathNode node3 = unconnectedNodeList[0];
					secondaryNodeList.AddRange(unconnectedNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument));
					unconnectedNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument);
					secondaryNodeList.Remove(node3);
					list4.Add(node3);
					continue;
				}
				PathSegment segment = new PathSegment();
				for (PathFinder.Node node4 = node2; node4 != null; node4 = node4.next)
				{
					if (node4 == node2)
					{
						segment.start = node4;
					}
					if (node4.next == null)
					{
						segment.end = node4;
					}
				}
				list2.Add(segment);
				PathNode node5 = unconnectedNodeList.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				secondaryNodeList.AddRange(unconnectedNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument));
				unconnectedNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument);
				secondaryNodeList.Remove(node5);
				list4.Add(node5);
				PathNode pathNode = secondaryNodeList.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				if (pathNode != null)
				{
					secondaryNodeList.Remove(pathNode);
					list4.Add(pathNode);
				}
				for (PathFinder.Node node6 = node2; node6 != null; node6 = node6.next)
				{
					if (node6 != node2 && node6.next != null)
					{
						list5.Add(node6.point);
					}
				}
			}
			foreach (PathSegment item4 in list2)
			{
				PathFinder.Node node7 = item4.start;
				while (node7 != null && node7.next != null)
				{
					DungeonGridConnectionHash dungeonGridConnectionHash = hashmap[node7.point.x, node7.point.y];
					DungeonGridConnectionHash dungeonGridConnectionHash2 = hashmap[node7.next.point.x, node7.next.point.y];
					if (node7.point.x > node7.next.point.x)
					{
						dungeonGridConnectionHash.West = true;
						dungeonGridConnectionHash2.East = true;
					}
					if (node7.point.x < node7.next.point.x)
					{
						dungeonGridConnectionHash.East = true;
						dungeonGridConnectionHash2.West = true;
					}
					if (node7.point.y > node7.next.point.y)
					{
						dungeonGridConnectionHash.South = true;
						dungeonGridConnectionHash2.North = true;
					}
					if (node7.point.y < node7.next.point.y)
					{
						dungeonGridConnectionHash.North = true;
						dungeonGridConnectionHash2.South = true;
					}
					hashmap[node7.point.x, node7.point.y] = dungeonGridConnectionHash;
					hashmap[node7.next.point.x, node7.next.point.y] = dungeonGridConnectionHash2;
					node7 = node7.next;
				}
			}
			for (int m = 0; m < val.CellCount; m++)
			{
				for (int n = 0; n < val.CellCount; n++)
				{
					if (array6[m, n] == int.MaxValue)
					{
						continue;
					}
					DungeonGridConnectionHash dungeonGridConnectionHash3 = hashmap[m, n];
					if (dungeonGridConnectionHash3.Value == 0)
					{
						continue;
					}
					array.Shuffle(ref seed);
					Prefab<DungeonGridCell>[] array7 = array;
					foreach (Prefab<DungeonGridCell> prefab7 in array7)
					{
						Prefab<DungeonGridCell> prefab8 = ((m > num) ? val[m - 1, n] : null);
						if (((prefab8 != null) ? ((prefab7.Component.West == prefab8.Component.East) ? 1 : 0) : (dungeonGridConnectionHash3.West ? ((int)prefab7.Component.West) : ((prefab7.Component.West == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab9 = ((m < num2) ? val[m + 1, n] : null);
						if (((prefab9 != null) ? ((prefab7.Component.East == prefab9.Component.West) ? 1 : 0) : (dungeonGridConnectionHash3.East ? ((int)prefab7.Component.East) : ((prefab7.Component.East == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab10 = ((n > num) ? val[m, n - 1] : null);
						if (((prefab10 != null) ? ((prefab7.Component.South == prefab10.Component.North) ? 1 : 0) : (dungeonGridConnectionHash3.South ? ((int)prefab7.Component.South) : ((prefab7.Component.South == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab11 = ((n < num2) ? val[m, n + 1] : null);
						if (((prefab11 != null) ? (prefab7.Component.North == prefab11.Component.South) : (dungeonGridConnectionHash3.North ? ((byte)prefab7.Component.North != 0) : (prefab7.Component.North == DungeonGridConnectionType.None))) && (prefab7.Component.West == DungeonGridConnectionType.None || prefab8 == null || !prefab7.Component.ShouldAvoid(prefab8.ID)) && (prefab7.Component.East == DungeonGridConnectionType.None || prefab9 == null || !prefab7.Component.ShouldAvoid(prefab9.ID)) && (prefab7.Component.South == DungeonGridConnectionType.None || prefab10 == null || !prefab7.Component.ShouldAvoid(prefab10.ID)) && (prefab7.Component.North == DungeonGridConnectionType.None || prefab11 == null || !prefab7.Component.ShouldAvoid(prefab11.ID)))
						{
							val[m, n] = prefab7;
							bool num5 = prefab8 == null || prefab7.Component.WestVariant == prefab8.Component.EastVariant;
							bool flag5 = prefab10 == null || prefab7.Component.SouthVariant == prefab10.Component.NorthVariant;
							if (num5 && flag5)
							{
								break;
							}
						}
					}
				}
			}
			Vector3 zero2 = Vector3.zero;
			Vector3 zero3 = Vector3.zero;
			Vector2i val5 = default(Vector2i);
			do
			{
				zero3 = zero2;
				for (int num6 = 0; num6 < val.CellCount; num6++)
				{
					for (int num7 = 0; num7 < val.CellCount; num7++)
					{
						Prefab<DungeonGridCell> prefab12 = val[num6, num7];
						if (prefab12 != null)
						{
							((Vector2i)(ref val5))..ctor(num6, num7);
							Vector3 val6 = val.GridToWorldCoords(val5);
							while (!IsValidPrefabPlacement(prefab12, zero2 + val6, Quaternion.identity, Vector3.one, EnvironmentType.Underground | EnvironmentType.Building))
							{
								zero2.y -= 3f;
							}
						}
					}
				}
			}
			while (zero2 != zero3);
			foreach (PathLink item5 in list3)
			{
				PathLinkSegment origin = item5.upwards.origin;
				origin.position += zero2;
			}
			foreach (PathLink item6 in list3)
			{
				Vector3 val7 = item6.upwards.origin.position + item6.upwards.origin.rotation * Vector3.Scale(item6.upwards.origin.upSocket.localPosition, item6.upwards.origin.scale);
				Vector3 val8 = item6.downwards.origin.position + item6.downwards.origin.rotation * Vector3.Scale(item6.downwards.origin.downSocket.localPosition, item6.downwards.origin.scale) - val7;
				Vector3[] array8 = (Vector3[])(object)new Vector3[2]
				{
					new Vector3(0f, 1f, 0f),
					new Vector3(1f, 1f, 1f)
				};
				foreach (Vector3 val9 in array8)
				{
					int num8 = 0;
					int num9 = 0;
					while (((Vector3)(ref val8)).magnitude > 1f && (num8 < 8 || num9 < 8))
					{
						bool flag6 = num8 > 2 && num9 > 2;
						bool flag7 = num8 > 4 && num9 > 4;
						Prefab<DungeonGridLink> prefab13 = null;
						Vector3 val10 = Vector3.zero;
						int num10 = int.MinValue;
						Vector3 position3 = Vector3.zero;
						Quaternion rotation2 = Quaternion.identity;
						PathLinkSegment prevSegment = item6.downwards.prevSegment;
						Vector3 val11 = prevSegment.position + prevSegment.rotation * Vector3.Scale(prevSegment.scale, prevSegment.downSocket.localPosition);
						Quaternion val12 = prevSegment.rotation * prevSegment.downSocket.localRotation;
						Prefab<DungeonGridLink>[] array9 = array5;
						foreach (Prefab<DungeonGridLink> prefab14 in array9)
						{
							float num11 = SeedRandom.Value(ref seed);
							DungeonGridLink component = prefab14.Component;
							if (prevSegment.downType != component.UpType)
							{
								continue;
							}
							switch (component.DownType)
							{
							case DungeonGridLinkType.Elevator:
								if (flag6 || val9.x != 0f || val9.z != 0f)
								{
									continue;
								}
								break;
							case DungeonGridLinkType.Transition:
								if (val9.x != 0f || val9.z != 0f)
								{
									continue;
								}
								break;
							}
							int num12 = ((!flag6) ? component.Priority : 0);
							if (num10 > num12)
							{
								continue;
							}
							Quaternion val13 = val12 * Quaternion.Inverse(component.UpSocket.localRotation);
							Quaternion val14 = val13 * component.DownSocket.localRotation;
							PathLinkSegment prevSegment2 = item6.upwards.prevSegment;
							Quaternion val15 = prevSegment2.rotation * prevSegment2.upSocket.localRotation;
							if (component.Rotation > 0)
							{
								if (Quaternion.Angle(val15, val14) > (float)component.Rotation)
								{
									continue;
								}
								Quaternion val16 = val15 * Quaternion.Inverse(val14);
								val13 *= val16;
								val14 *= val16;
							}
							Vector3 val17 = val11 - val13 * component.UpSocket.localPosition;
							Vector3 val18 = val13 * (component.DownSocket.localPosition - component.UpSocket.localPosition);
							Vector3 val19 = val8 + val10;
							Vector3 val20 = val8 + val18;
							float magnitude = ((Vector3)(ref val19)).magnitude;
							float magnitude2 = ((Vector3)(ref val20)).magnitude;
							Vector3 val21 = Vector3.Scale(val19, val9);
							Vector3 val22 = Vector3.Scale(val20, val9);
							float magnitude3 = ((Vector3)(ref val21)).magnitude;
							float magnitude4 = ((Vector3)(ref val22)).magnitude;
							if (val10 != Vector3.zero)
							{
								if (magnitude3 < magnitude4 || (magnitude3 == magnitude4 && magnitude < magnitude2) || (magnitude3 == magnitude4 && magnitude == magnitude2 && num11 < 0.5f))
								{
									continue;
								}
							}
							else if (magnitude3 <= magnitude4)
							{
								continue;
							}
							if (Mathf.Abs(val22.x) - Mathf.Abs(val21.x) > 0.01f || (Mathf.Abs(val22.x) > 0.01f && val19.x * val20.x < 0f) || Mathf.Abs(val22.y) - Mathf.Abs(val21.y) > 0.01f || (Mathf.Abs(val22.y) > 0.01f && val19.y * val20.y < 0f) || Mathf.Abs(val22.z) - Mathf.Abs(val21.z) > 0.01f || (Mathf.Abs(val22.z) > 0.01f && val19.z * val20.z < 0f) || (flag6 && val9.x == 0f && val9.z == 0f && component.DownType == DungeonGridLinkType.Default && ((Mathf.Abs(val20.x) > 0.01f && Mathf.Abs(val20.x) < LinkRadius * 2f - 0.1f) || (Mathf.Abs(val20.z) > 0.01f && Mathf.Abs(val20.z) < LinkRadius * 2f - 0.1f))))
							{
								continue;
							}
							num10 = num12;
							if (val9.x == 0f && val9.z == 0f)
							{
								if (!flag6 && Mathf.Abs(val20.y) < LinkTransition - 0.1f)
								{
									continue;
								}
							}
							else if ((!flag6 && magnitude4 > 0.01f && (Mathf.Abs(val20.x) < LinkRadius * 2f - 0.1f || Mathf.Abs(val20.z) < LinkRadius * 2f - 0.1f)) || (!flag7 && magnitude4 > 0.01f && (Mathf.Abs(val20.x) < LinkRadius * 1f - 0.1f || Mathf.Abs(val20.z) < LinkRadius * 1f - 0.1f)))
							{
								continue;
							}
							if (!flag6 || !(magnitude4 < 0.01f) || !(magnitude2 < 0.01f) || !(Quaternion.Angle(val15, val14) > 10f))
							{
								prefab13 = prefab14;
								val10 = val18;
								num10 = num12;
								position3 = val17;
								rotation2 = val13;
							}
						}
						if (val10 != Vector3.zero)
						{
							PathLinkSegment pathLinkSegment = new PathLinkSegment();
							pathLinkSegment.position = position3;
							pathLinkSegment.rotation = rotation2;
							pathLinkSegment.scale = Vector3.one;
							pathLinkSegment.prefab = prefab13;
							pathLinkSegment.link = prefab13.Component;
							item6.downwards.segments.Add(pathLinkSegment);
							val8 += val10;
						}
						else
						{
							num9++;
						}
						if (val9.x > 0f || val9.z > 0f)
						{
							Prefab<DungeonGridLink> prefab15 = null;
							Vector3 val23 = Vector3.zero;
							int num13 = int.MinValue;
							Vector3 position4 = Vector3.zero;
							Quaternion rotation3 = Quaternion.identity;
							PathLinkSegment prevSegment3 = item6.upwards.prevSegment;
							Vector3 val24 = prevSegment3.position + prevSegment3.rotation * Vector3.Scale(prevSegment3.scale, prevSegment3.upSocket.localPosition);
							Quaternion val25 = prevSegment3.rotation * prevSegment3.upSocket.localRotation;
							array9 = array5;
							foreach (Prefab<DungeonGridLink> prefab16 in array9)
							{
								float num14 = SeedRandom.Value(ref seed);
								DungeonGridLink component2 = prefab16.Component;
								if (prevSegment3.upType != component2.DownType)
								{
									continue;
								}
								switch (component2.DownType)
								{
								case DungeonGridLinkType.Elevator:
									if (flag6 || val9.x != 0f || val9.z != 0f)
									{
										continue;
									}
									break;
								case DungeonGridLinkType.Transition:
									if (val9.x != 0f || val9.z != 0f)
									{
										continue;
									}
									break;
								}
								int num15 = ((!flag6) ? component2.Priority : 0);
								if (num13 > num15)
								{
									continue;
								}
								Quaternion val26 = val25 * Quaternion.Inverse(component2.DownSocket.localRotation);
								Quaternion val27 = val26 * component2.UpSocket.localRotation;
								PathLinkSegment prevSegment4 = item6.downwards.prevSegment;
								Quaternion val28 = prevSegment4.rotation * prevSegment4.downSocket.localRotation;
								if (component2.Rotation > 0)
								{
									if (Quaternion.Angle(val28, val27) > (float)component2.Rotation)
									{
										continue;
									}
									Quaternion val29 = val28 * Quaternion.Inverse(val27);
									val26 *= val29;
									val27 *= val29;
								}
								Vector3 val30 = val24 - val26 * component2.DownSocket.localPosition;
								Vector3 val31 = val26 * (component2.UpSocket.localPosition - component2.DownSocket.localPosition);
								Vector3 val32 = val8 - val23;
								Vector3 val33 = val8 - val31;
								float magnitude5 = ((Vector3)(ref val32)).magnitude;
								float magnitude6 = ((Vector3)(ref val33)).magnitude;
								Vector3 val34 = Vector3.Scale(val32, val9);
								Vector3 val35 = Vector3.Scale(val33, val9);
								float magnitude7 = ((Vector3)(ref val34)).magnitude;
								float magnitude8 = ((Vector3)(ref val35)).magnitude;
								if (val23 != Vector3.zero)
								{
									if (magnitude7 < magnitude8 || (magnitude7 == magnitude8 && magnitude5 < magnitude6) || (magnitude7 == magnitude8 && magnitude5 == magnitude6 && num14 < 0.5f))
									{
										continue;
									}
								}
								else if (magnitude7 <= magnitude8)
								{
									continue;
								}
								if (Mathf.Abs(val35.x) - Mathf.Abs(val34.x) > 0.01f || (Mathf.Abs(val35.x) > 0.01f && val32.x * val33.x < 0f) || Mathf.Abs(val35.y) - Mathf.Abs(val34.y) > 0.01f || (Mathf.Abs(val35.y) > 0.01f && val32.y * val33.y < 0f) || Mathf.Abs(val35.z) - Mathf.Abs(val34.z) > 0.01f || (Mathf.Abs(val35.z) > 0.01f && val32.z * val33.z < 0f) || (flag6 && val9.x == 0f && val9.z == 0f && component2.UpType == DungeonGridLinkType.Default && ((Mathf.Abs(val33.x) > 0.01f && Mathf.Abs(val33.x) < LinkRadius * 2f - 0.1f) || (Mathf.Abs(val33.z) > 0.01f && Mathf.Abs(val33.z) < LinkRadius * 2f - 0.1f))))
								{
									continue;
								}
								num13 = num15;
								if (val9.x == 0f && val9.z == 0f)
								{
									if (!flag6 && Mathf.Abs(val33.y) < LinkTransition - 0.1f)
									{
										continue;
									}
								}
								else if ((!flag6 && magnitude8 > 0.01f && (Mathf.Abs(val33.x) < LinkRadius * 2f - 0.1f || Mathf.Abs(val33.z) < LinkRadius * 2f - 0.1f)) || (!flag7 && magnitude8 > 0.01f && (Mathf.Abs(val33.x) < LinkRadius * 1f - 0.1f || Mathf.Abs(val33.z) < LinkRadius * 1f - 0.1f)))
								{
									continue;
								}
								if (!flag6 || !(magnitude8 < 0.01f) || !(magnitude6 < 0.01f) || !(Quaternion.Angle(val28, val27) > 10f))
								{
									prefab15 = prefab16;
									val23 = val31;
									num13 = num15;
									position4 = val30;
									rotation3 = val26;
								}
							}
							if (val23 != Vector3.zero)
							{
								PathLinkSegment pathLinkSegment2 = new PathLinkSegment();
								pathLinkSegment2.position = position4;
								pathLinkSegment2.rotation = rotation3;
								pathLinkSegment2.scale = Vector3.one;
								pathLinkSegment2.prefab = prefab15;
								pathLinkSegment2.link = prefab15.Component;
								item6.upwards.segments.Add(pathLinkSegment2);
								val8 -= val23;
							}
							else
							{
								num8++;
							}
						}
						else
						{
							num8++;
						}
					}
				}
			}
			foreach (PathLink item7 in list3)
			{
				foreach (PathLinkSegment segment2 in item7.downwards.segments)
				{
					World.AddPrefab("Dungeon", segment2.prefab, segment2.position, segment2.rotation, segment2.scale);
				}
				foreach (PathLinkSegment segment3 in item7.upwards.segments)
				{
					World.AddPrefab("Dungeon", segment3.prefab, segment3.position, segment3.rotation, segment3.scale);
				}
			}
			if (TerrainMeta.Path.Rails.Count > 0)
			{
				List<PrefabReplacement> list8 = new List<PrefabReplacement>();
				Vector2i val36 = default(Vector2i);
				for (int num16 = 0; num16 < val.CellCount; num16++)
				{
					for (int num17 = 0; num17 < val.CellCount; num17++)
					{
						Prefab<DungeonGridCell> prefab17 = val[num16, num17];
						if (prefab17 == null || !prefab17.Component.Replaceable)
						{
							continue;
						}
						((Vector2i)(ref val36))..ctor(num16, num17);
						Vector3 val37 = val.GridToWorldCoords(val36) + zero2;
						Prefab<DungeonGridCell>[] array7 = array3;
						foreach (Prefab<DungeonGridCell> prefab18 in array7)
						{
							if (prefab17.Component.North != prefab18.Component.North || prefab17.Component.South != prefab18.Component.South || prefab17.Component.West != prefab18.Component.West || prefab17.Component.East != prefab18.Component.East || !IsValidPrefabPlacement(prefab18, val37, Quaternion.identity, Vector3.one, EnvironmentType.Underground) || !prefab18.ApplyTerrainChecks(val37, Quaternion.identity, Vector3.one) || !prefab18.ApplyTerrainFilters(val37, Quaternion.identity, Vector3.one))
							{
								continue;
							}
							MonumentInfo componentInChildren6 = prefab18.Object.GetComponentInChildren<MonumentInfo>();
							Vector3 val38 = val37;
							if (Object.op_Implicit((Object)(object)componentInChildren6))
							{
								val38 += ((Component)componentInChildren6).transform.position;
							}
							if (!(val38.y < 1f))
							{
								float distanceToAboveGroundRail = GetDistanceToAboveGroundRail(val38);
								if (!(distanceToAboveGroundRail < 200f))
								{
									PrefabReplacement item = default(PrefabReplacement);
									item.gridPosition = val36;
									item.worldPosition = val38;
									item.distance = Mathf.RoundToInt(distanceToAboveGroundRail);
									item.prefab = prefab18;
									list8.Add(item);
								}
							}
						}
					}
				}
				ListEx.Shuffle<PrefabReplacement>(list8, ref seed);
				list8.Sort((PrefabReplacement a, PrefabReplacement b) => a.distance.CompareTo(b.distance));
				int num18 = 2;
				while (num18 > 0 && list8.Count > 0)
				{
					num18--;
					PrefabReplacement replacement = list8[0];
					val[replacement.gridPosition.x, replacement.gridPosition.y] = replacement.prefab;
					list8.RemoveAll(delegate(PrefabReplacement a)
					{
						//IL_0001: Unknown result type (might be due to invalid IL or missing references)
						//IL_000c: Unknown result type (might be due to invalid IL or missing references)
						//IL_0011: Unknown result type (might be due to invalid IL or missing references)
						//IL_0016: Unknown result type (might be due to invalid IL or missing references)
						Vector3 val39 = a.worldPosition - replacement.worldPosition;
						return ((Vector3)(ref val39)).magnitude < 1500f;
					});
				}
			}
			Vector2i val40 = default(Vector2i);
			for (int num19 = 0; num19 < val.CellCount; num19++)
			{
				for (int num20 = 0; num20 < val.CellCount; num20++)
				{
					Prefab<DungeonGridCell> prefab19 = val[num19, num20];
					if (prefab19 != null)
					{
						((Vector2i)(ref val40))..ctor(num19, num20);
						Vector3 val41 = val.GridToWorldCoords(val40);
						World.AddPrefab("Dungeon", prefab19, zero2 + val41, Quaternion.identity, Vector3.one);
					}
				}
			}
			Vector2i val42 = default(Vector2i);
			Vector2i val44 = default(Vector2i);
			for (int num21 = 0; num21 < val.CellCount - 1; num21++)
			{
				for (int num22 = 0; num22 < val.CellCount - 1; num22++)
				{
					Prefab<DungeonGridCell> prefab20 = val[num21, num22];
					Prefab<DungeonGridCell> prefab21 = val[num21 + 1, num22];
					Prefab<DungeonGridCell> prefab22 = val[num21, num22 + 1];
					Prefab<DungeonGridCell>[] array7;
					if (prefab20 != null && prefab21 != null && prefab20.Component.EastVariant != prefab21.Component.WestVariant)
					{
						array4.Shuffle(ref seed);
						array7 = array4;
						foreach (Prefab<DungeonGridCell> prefab23 in array7)
						{
							if (prefab23.Component.West == prefab20.Component.East && prefab23.Component.East == prefab21.Component.West && prefab23.Component.WestVariant == prefab20.Component.EastVariant && prefab23.Component.EastVariant == prefab21.Component.WestVariant)
							{
								((Vector2i)(ref val42))..ctor(num21, num22);
								Vector3 val43 = val.GridToWorldCoords(val42) + new Vector3(val.CellSizeHalf, 0f, 0f);
								World.AddPrefab("Dungeon", prefab23, zero2 + val43, Quaternion.identity, Vector3.one);
								break;
							}
						}
					}
					if (prefab20 == null || prefab22 == null || prefab20.Component.NorthVariant == prefab22.Component.SouthVariant)
					{
						continue;
					}
					array4.Shuffle(ref seed);
					array7 = array4;
					foreach (Prefab<DungeonGridCell> prefab24 in array7)
					{
						if (prefab24.Component.South == prefab20.Component.North && prefab24.Component.North == prefab22.Component.South && prefab24.Component.SouthVariant == prefab20.Component.NorthVariant && prefab24.Component.NorthVariant == prefab22.Component.SouthVariant)
						{
							((Vector2i)(ref val44))..ctor(num21, num22);
							Vector3 val45 = val.GridToWorldCoords(val44) + new Vector3(0f, 0f, val.CellSizeHalf);
							World.AddPrefab("Dungeon", prefab24, zero2 + val45, Quaternion.identity, Vector3.one);
							break;
						}
					}
				}
			}
		}
		bool IsValidPrefabPlacement(Prefab<DungeonGridCell> prefab, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val46 = Vector3.up * 9f;
			Vector3 val47 = Vector3.up * (LinkTransition + 1f);
			if (!prefab.CheckEnvironmentVolumesBelowAltitude(pos + val46, rot, scale, EnvironmentType.Underground, EnvironmentType.Entrance) && !prefab.CheckEnvironmentVolumesInsideTerrain(pos + val46, rot, scale, EnvironmentType.TrainTunnels, EnvironmentType.Entrance))
			{
				return false;
			}
			if (prefab.CheckEnvironmentVolumes(pos + val47, rot, scale, type))
			{
				return false;
			}
			if (prefab.CheckEnvironmentVolumes(pos, rot, scale, type))
			{
				return false;
			}
			return true;
		}
	}

	private float GetDistanceToAboveGroundRail(Vector3 pos)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			foreach (PathList rail in TerrainMeta.Path.Rails)
			{
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					num = Mathf.Min(num, Vector3Ex.Distance2D(val, pos));
				}
			}
		}
		return num;
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;
}


private class PathLink
{
	public PathLinkSide downwards;

	public PathLinkSide upwards;
}


using System.Collections.Generic;

private class PathLinkSide
{
	public PathLinkSegment origin;

	public List<PathLinkSegment> segments;

	public PathLinkSegment prevSegment
	{
		get
		{
			if (segments.Count <= 0)
			{
				return origin;
			}
			return segments[segments.Count - 1];
		}
	}
}


using UnityEngine;

private class PathLinkSegment
{
	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public Prefab<DungeonGridLink> prefab;

	public DungeonGridLink link;

	public Transform downSocket => link.DownSocket;

	public Transform upSocket => link.UpSocket;

	public DungeonGridLinkType downType => link.DownType;

	public DungeonGridLinkType upType => link.UpType;
}


using UnityEngine;

private struct PrefabReplacement
{
	public Vector2i gridPosition;

	public Vector3 worldPosition;

	public int distance;

	public Prefab<DungeonGridCell> prefab;
}


using System;
using System.Threading.Tasks;
using GenerateErosionJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;

public class GenerateErosion : ProceduralComponent
{
	public struct SplatPaintingData : IDisposable
	{
		public bool IsValid;

		public readonly NativeArray<float> HeightMapDelta;

		public readonly NativeArray<float> AngleMap;

		public SplatPaintingData(NativeArray<float> heightMapDelta, NativeArray<float> angleMap)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			HeightMapDelta = heightMapDelta;
			AngleMap = angleMap;
			IsValid = true;
		}

		public void Dispose()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			IsValid = false;
			if (HeightMapDelta.IsCreated)
			{
				HeightMapDelta.Dispose();
			}
			if (AngleMap.IsCreated)
			{
				AngleMap.Dispose();
			}
		}

		public void Dispose(JobHandle inputDeps)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			IsValid = false;
			if (HeightMapDelta.IsCreated)
			{
				HeightMapDelta.Dispose(inputDeps);
			}
			if (AngleMap.IsCreated)
			{
				AngleMap.Dispose(inputDeps);
			}
		}
	}

	public static SplatPaintingData splatPaintingData;

	public override void Process(uint seed)
	{
		if (!World.Networked)
		{
			GridErosion(seed);
		}
	}

	private static int GetBatchSize(int length)
	{
		int num = length / JobsUtility.JobWorkerCount;
		if (num < 64)
		{
			return 64;
		}
		return num;
	}

	private void GridErosion(uint seed)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0461: Unknown result type (might be due to invalid IL or missing references)
		//IL_0463: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0574: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_057d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0601: Unknown result type (might be due to invalid IL or missing references)
		//IL_0608: Unknown result type (might be due to invalid IL or missing references)
		//IL_060a: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0628: Unknown result type (might be due to invalid IL or missing references)
		//IL_062d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0636: Unknown result type (might be due to invalid IL or missing references)
		//IL_063b: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_067d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0682: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_0693: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0706: Unknown result type (might be due to invalid IL or missing references)
		//IL_0717: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0741: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0764: Unknown result type (might be due to invalid IL or missing references)
		//IL_0769: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0780: Unknown result type (might be due to invalid IL or missing references)
		//IL_079e: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07db: Unknown result type (might be due to invalid IL or missing references)
		//IL_07dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0803: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_081a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GridErosion", 0);
		try
		{
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			heightMap.Push();
			NativeArray<short> src = heightMap.src;
			NativeArray<short> dst = heightMap.dst;
			NativeArray<float> minTerrainHeightMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)0);
			NativeArray<float> waterMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeList<int> val2 = new NativeList<int>(heightMap.src.Length, AllocatorHandle.op_Implicit((Allocator)4));
			NativeArray<float4> fluxMap = new NativeArray<float4>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float2> velocityMap = new NativeArray<float2>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> val3 = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> copyTarget = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> angleMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)0);
			Debug.Assert(waterMap.Length == heightMap.src.Length);
			Debug.Assert(fluxMap.Length == heightMap.src.Length);
			Debug.Assert(velocityMap.Length == heightMap.src.Length);
			Debug.Assert(val3.Length == heightMap.src.Length);
			float num = TerrainMeta.Size.x / (float)heightMap.res * TerrainMeta.Size.z / (float)heightMap.res;
			float invGridCellSquareSize = 1f / num;
			float pipeLength = 1f;
			float pipeArea = 1f;
			JobHandle val4 = default(JobHandle);
			NativeArray<float> val5 = new NativeArray<float>(src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> val6 = new NativeArray<float>(val5, (Allocator)4);
			PrepareMapJob prepareMapJob = default(PrepareMapJob);
			prepareMapJob.HeightMapAsShort = src.AsReadOnly();
			prepareMapJob.HeightMapAsFloat = val5;
			prepareMapJob.OceanIndicesWriter = val2.AsParallelWriter();
			prepareMapJob.OceanLevel = WaterSystem.OceanLevel;
			prepareMapJob.TerrainPositionY = TerrainMeta.Position.y;
			prepareMapJob.TerrainSizeY = TerrainMeta.Size.y;
			val4 = IJobParallelForBatchExtensions.Schedule<PrepareMapJob>(prepareMapJob, src.Length, GetBatchSize(src.Length), val4);
			CalcMinHeightMapJob calcMinHeightMapJob = default(CalcMinHeightMapJob);
			calcMinHeightMapJob.TerrainHeightMap = val5.AsReadOnly();
			calcMinHeightMapJob.MinTerrainHeightMap = minTerrainHeightMap;
			calcMinHeightMapJob.HeightMapRes = TerrainMeta.HeightMap.res;
			calcMinHeightMapJob.TopologyMap = TerrainMeta.TopologyMap.src.AsReadOnly();
			calcMinHeightMapJob.TopologyMapRes = TerrainMeta.TopologyMap.res;
			calcMinHeightMapJob.OceanHeight = WaterSystem.OceanLevel;
			calcMinHeightMapJob.TerrainOneOverSizeX = TerrainMeta.OneOverSize.x;
			val4 = IJobParallelForExtensions.Schedule<CalcMinHeightMapJob>(calcMinHeightMapJob, val5.Length, GetBatchSize(val5.Length), val4);
			((JobHandle)(ref val4)).Complete();
			val4 = default(JobHandle);
			NativeArray<float> copyTarget2 = new NativeArray<float>(src.Length, (Allocator)4, (NativeArrayOptions)1);
			CopyArrayJob<float> copyArrayJob = default(CopyArrayJob<float>);
			copyArrayJob.CopyTarget = copyTarget2;
			copyArrayJob.CopySource = val5;
			CopyArrayJob<float> copyArrayJob2 = copyArrayJob;
			CopyArrayJob<float> copyArrayJob3 = new CopyArrayJob<float>
			{
				CopyTarget = val6,
				CopySource = val5
			};
			val4 = JobHandle.CombineDependencies(IJobExtensions.Schedule<CopyArrayJob<float>>(copyArrayJob2, val4), IJobExtensions.Schedule<CopyArrayJob<float>>(copyArrayJob3, val4));
			int num2 = 32;
			int num3 = 32;
			int num4 = (heightMap.res + num2 - 1) / num2;
			int num5 = (heightMap.res + num3 - 1) / num3;
			int num6 = num4 * num5;
			for (int i = 0; i < 512; i++)
			{
				RefillOceanJob refillOceanJob = default(RefillOceanJob);
				refillOceanJob.OceanIndices = val2.AsReadOnly();
				refillOceanJob.HeightMap = val5.AsReadOnly();
				refillOceanJob.OceanLevel = WaterSystem.OceanLevel;
				refillOceanJob.WaterMap = waterMap;
				RefillOceanJob refillOceanJob2 = refillOceanJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<RefillOceanJob>(ref refillOceanJob2, val2.Length, GetBatchSize(val2.Length), val4);
				WaterIncrementationJob waterIncrementationJob = default(WaterIncrementationJob);
				waterIncrementationJob.WaterMap = waterMap;
				waterIncrementationJob.WaterFillRate = 0.04f;
				waterIncrementationJob.DT = 0.06f;
				WaterIncrementationJob waterIncrementationJob2 = waterIncrementationJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<WaterIncrementationJob>(ref waterIncrementationJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
				CalculateOutputFluxJob calculateOutputFluxJob = default(CalculateOutputFluxJob);
				calculateOutputFluxJob.TerrainHeightMapFloatVal = val5.AsReadOnly();
				calculateOutputFluxJob.WaterMap = waterMap.AsReadOnly();
				calculateOutputFluxJob.FluxMap = fluxMap;
				calculateOutputFluxJob.Res = heightMap.res;
				calculateOutputFluxJob.DT = 0.06f;
				calculateOutputFluxJob.GridCellSquareSize = num;
				calculateOutputFluxJob.PipeLength = pipeLength;
				calculateOutputFluxJob.PipeArea = pipeArea;
				CalculateOutputFluxJob calculateOutputFluxJob2 = calculateOutputFluxJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<CalculateOutputFluxJob>(ref calculateOutputFluxJob2, fluxMap.Length, GetBatchSize(fluxMap.Length), val4);
				AdjustWaterHeightByFluxJob adjustWaterHeightByFluxJob = default(AdjustWaterHeightByFluxJob);
				adjustWaterHeightByFluxJob.WaterMap = waterMap;
				adjustWaterHeightByFluxJob.VelocityMap = velocityMap;
				adjustWaterHeightByFluxJob.FluxMap = fluxMap.AsReadOnly();
				adjustWaterHeightByFluxJob.Res = heightMap.res;
				adjustWaterHeightByFluxJob.DT = 0.06f;
				adjustWaterHeightByFluxJob.InvGridCellSquareSize = invGridCellSquareSize;
				AdjustWaterHeightByFluxJob adjustWaterHeightByFluxJob2 = adjustWaterHeightByFluxJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<AdjustWaterHeightByFluxJob>(ref adjustWaterHeightByFluxJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
				TileCalculateAngleMap tileCalculateAngleMap = default(TileCalculateAngleMap);
				tileCalculateAngleMap.AngleMap = angleMap;
				tileCalculateAngleMap.TerrainHeightMapSrcFloat = val5.AsReadOnly();
				tileCalculateAngleMap.NormY = heightMap.normY;
				tileCalculateAngleMap.Res = heightMap.res;
				tileCalculateAngleMap.TileSizeX = num2;
				tileCalculateAngleMap.TileSizeZ = num3;
				tileCalculateAngleMap.NumXTiles = num4;
				TileCalculateAngleMap tileCalculateAngleMap2 = tileCalculateAngleMap;
				val4 = IJobParallelForExtensions.ScheduleByRef<TileCalculateAngleMap>(ref tileCalculateAngleMap2, num6, num6 / JobsUtility.JobWorkerCount, val4);
				ErosionAndDepositionJob erosionAndDepositionJob = default(ErosionAndDepositionJob);
				erosionAndDepositionJob.SedimentMap = val3;
				erosionAndDepositionJob.MinTerrainHeightMap = minTerrainHeightMap.AsReadOnly();
				erosionAndDepositionJob.TerrainHeightMapSrcFloat = val5.AsReadOnly();
				erosionAndDepositionJob.TerrainHeightMapDstFloat = val6;
				erosionAndDepositionJob.WaterMap = waterMap;
				erosionAndDepositionJob.VelocityMap = velocityMap.AsReadOnly();
				erosionAndDepositionJob.AngleMap = angleMap.AsReadOnly();
				erosionAndDepositionJob.DT = 0.06f;
				ErosionAndDepositionJob erosionAndDepositionJob2 = erosionAndDepositionJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<ErosionAndDepositionJob>(ref erosionAndDepositionJob2, val3.Length, GetBatchSize(val3.Length), val4);
				copyArrayJob = default(CopyArrayJob<float>);
				copyArrayJob.CopyTarget = copyTarget;
				copyArrayJob.CopySource = val3;
				CopyArrayJob<float> copyArrayJob4 = copyArrayJob;
				val4 = IJobExtensions.ScheduleByRef<CopyArrayJob<float>>(ref copyArrayJob4, val4);
				copyArrayJob = default(CopyArrayJob<float>);
				copyArrayJob.CopyTarget = val5;
				copyArrayJob.CopySource = val6;
				CopyArrayJob<float> copyArrayJob5 = copyArrayJob;
				TransportSedimentJob transportSedimentJob = default(TransportSedimentJob);
				transportSedimentJob.SedimentMap = val3;
				transportSedimentJob.SedimentReadOnlyMap = copyTarget.AsReadOnly();
				transportSedimentJob.VelocityMap = velocityMap.AsReadOnly();
				transportSedimentJob.Res = heightMap.res;
				transportSedimentJob.DT = 0.06f;
				TransportSedimentJob transportSedimentJob2 = transportSedimentJob;
				val4 = JobHandle.CombineDependencies(IJobExtensions.ScheduleByRef<CopyArrayJob<float>>(ref copyArrayJob5, val4), IJobParallelForExtensions.ScheduleByRef<TransportSedimentJob>(ref transportSedimentJob2, val3.Length, GetBatchSize(val3.Length), val4));
				EvaporationJob evaporationJob = default(EvaporationJob);
				evaporationJob.WaterMap = waterMap;
				evaporationJob.DT = 0.06f;
				evaporationJob.EvaporationRate = 0.015f;
				EvaporationJob evaporationJob2 = evaporationJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<EvaporationJob>(ref evaporationJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
			}
			CopyBackFloatHeightToShortHeightJob copyBackFloatHeightToShortHeightJob = default(CopyBackFloatHeightToShortHeightJob);
			copyBackFloatHeightToShortHeightJob.HeightMapAsFloat = val5.AsReadOnly();
			copyBackFloatHeightToShortHeightJob.HeightMapAsShort = dst;
			copyBackFloatHeightToShortHeightJob.TerrainOneOverSizeY = TerrainMeta.OneOverSize.y;
			copyBackFloatHeightToShortHeightJob.TerrainPositionY = TerrainMeta.Position.y;
			CopyBackFloatHeightToShortHeightJob copyBackFloatHeightToShortHeightJob2 = copyBackFloatHeightToShortHeightJob;
			val4 = IJobParallelForExtensions.ScheduleByRef<CopyBackFloatHeightToShortHeightJob>(ref copyBackFloatHeightToShortHeightJob2, val5.Length, GetBatchSize(val5.Length), val4);
			NativeArray<float> val7 = new NativeArray<float>(val5.Length, (Allocator)4, (NativeArrayOptions)1);
			PopulateDeltaHeightJob populateDeltaHeightJob = default(PopulateDeltaHeightJob);
			populateDeltaHeightJob.HeightMapOriginal = copyTarget2.AsReadOnly();
			populateDeltaHeightJob.HeightMap = val5.AsReadOnly();
			populateDeltaHeightJob.DeltaHeightMap = val7;
			PopulateDeltaHeightJob populateDeltaHeightJob2 = populateDeltaHeightJob;
			val4 = IJobParallelForExtensions.ScheduleByRef<PopulateDeltaHeightJob>(ref populateDeltaHeightJob2, val7.Length, GetBatchSize(val7.Length), val4);
			minTerrainHeightMap.Dispose(val4);
			waterMap.Dispose(val4);
			fluxMap.Dispose(val4);
			velocityMap.Dispose(val4);
			val3.Dispose(val4);
			copyTarget.Dispose(val4);
			val5.Dispose(val4);
			val6.Dispose(val4);
			val2.Dispose(val4);
			copyTarget2.Dispose(val4);
			((JobHandle)(ref val4)).Complete();
			heightMap.Pop();
			splatPaintingData = new SplatPaintingData(val7, angleMap);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void OnDestroy()
	{
		if (splatPaintingData.IsValid)
		{
			splatPaintingData.Dispose();
		}
	}

	private void OldErosion(uint seed)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		int erosion_res = heightmap.res;
		float[] erosion = new float[erosion_res * erosion_res];
		int deposit_res = splatmap.res;
		float[] deposit = new float[deposit_res * deposit_res];
		Vector3 val = default(Vector3);
		for (float num = TerrainMeta.Position.z; num < TerrainMeta.Position.z + TerrainMeta.Size.z; num += 10f)
		{
			for (float num2 = TerrainMeta.Position.x; num2 < TerrainMeta.Position.x + TerrainMeta.Size.x; num2 += 10f)
			{
				((Vector3)(ref val))..ctor(num2, 0f, num);
				float num3 = (val.y = heightmap.GetHeight(val));
				if (val.y <= 15f)
				{
					continue;
				}
				Vector3 normal = heightmap.GetNormal(val);
				if (normal.y <= 0.01f || normal.y >= 0.99f)
				{
					continue;
				}
				Vector2 val2 = Vector3Ex.XZ2D(normal);
				Vector2 normalized = ((Vector2)(ref val2)).normalized;
				Vector2 val3 = normalized;
				float num4 = 0f;
				float num5 = 0f;
				for (int i = 0; i < 300; i++)
				{
					val.x += normalized.x;
					val.z += normalized.y;
					if (Vector3.Angle(Vector2.op_Implicit(normalized), Vector2.op_Implicit(val3)) > 90f)
					{
						break;
					}
					float num6 = TerrainMeta.NormalizeX(val.x);
					float num7 = TerrainMeta.NormalizeZ(val.z);
					int topology = topologyMap.GetTopology(num6, num7);
					if ((topology & 0xB4990) != 0)
					{
						break;
					}
					float height = heightmap.GetHeight(num6, num7);
					if (height > num3 + 8f)
					{
						break;
					}
					float num8 = Mathf.Min(height, num3);
					val.y = Mathf.Lerp(val.y, num8, 0.5f);
					normal = heightmap.GetNormal(val);
					Vector2 val4 = normalized;
					val2 = Vector3Ex.XZ2D(normal);
					val2 = Vector2.Lerp(val4, ((Vector2)(ref val2)).normalized, 0.5f);
					normalized = ((Vector2)(ref val2)).normalized;
					num3 = num8;
					float num9 = 0f;
					float num10 = 0f;
					if ((topology & 0x800400) == 0)
					{
						float num11 = Vector3.Angle(Vector3.up, normal);
						num9 = Mathf.InverseLerp(5f, 15f, num11);
						num10 = 1f;
						if ((topology & 0x8000) == 0)
						{
							num10 = num9;
						}
					}
					num4 = Mathf.MoveTowards(num4, num9, 0.05f);
					num5 = Mathf.MoveTowards(num5, num10, 0.05f);
					if ((topologyMap.GetTopology(num6, num7, 10f) & 2) == 0)
					{
						int num12 = Mathf.Clamp((int)(num6 * (float)erosion_res), 0, erosion_res - 1);
						int num13 = Mathf.Clamp((int)(num7 * (float)erosion_res), 0, erosion_res - 1);
						int num14 = Mathf.Clamp((int)(num6 * (float)deposit_res), 0, deposit_res - 1);
						int num15 = Mathf.Clamp((int)(num7 * (float)deposit_res), 0, deposit_res - 1);
						erosion[num13 * erosion_res + num12] += num4;
						deposit[num15 * deposit_res + num14] += num5;
					}
				}
			}
		}
		Parallel.For(1, erosion_res - 1, delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			for (int j = 1; j < erosion_res - 1; j++)
			{
				float num16 = CalculateDelta(erosion, erosion_res, j, z, 1f, 0.8f, 0.6f);
				float delta = (0f - Mathf.Lerp(0f, 0.25f, num16)) * TerrainMeta.OneOverSize.y;
				heightmap.AddHeight(j, z, delta);
			}
		});
		Parallel.For(1, deposit_res - 1, delegate(int z)
		{
			for (int k = 1; k < deposit_res - 1; k++)
			{
				float splat = splatmap.GetSplat(k, z, 2);
				float splat2 = splatmap.GetSplat(k, z, 4);
				if (splat > 0.1f || splat2 > 0.1f)
				{
					float num17 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.4f, 0.2f);
					num17 = Mathf.InverseLerp(1f, 3f, num17);
					num17 = Mathf.Lerp(0f, 0.5f, num17);
					splatmap.AddSplat(k, z, 128, num17);
				}
				else
				{
					float num18 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.2f, 0.1f);
					float num19 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.8f, 0.4f);
					num18 = Mathf.InverseLerp(1f, 3f, num18);
					num19 = Mathf.InverseLerp(1f, 3f, num19);
					num18 = Mathf.Lerp(0f, 1f, num18);
					num19 = Mathf.Lerp(0f, 1f, num19);
					splatmap.AddSplat(k, z, 1, num19 * 0.5f);
					splatmap.AddSplat(k, z, 64, num18 * 0.7f);
					splatmap.AddSplat(k, z, 128, num18 * 0.5f);
				}
			}
		});
		static float CalculateDelta(float[] data, int res, int x, int z, float cntr, float side, float diag)
		{
			int num20 = x - 1;
			int num21 = x + 1;
			int num22 = z - 1;
			int num23 = z + 1;
			side /= 4f;
			diag /= 4f;
			float num24 = data[z * res + x];
			float num25 = data[z * res + num20] + data[z * res + num21] + data[num23 * res + x] + data[num23 * res + x];
			float num26 = data[num22 * res + num20] + data[num22 * res + num21] + data[num23 * res + num20] + data[num23 * res + num21];
			return cntr * num24 + side * num25 + diag * num26;
		}
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;

public struct SplatPaintingData : IDisposable
{
	public bool IsValid;

	public readonly NativeArray<float> HeightMapDelta;

	public readonly NativeArray<float> AngleMap;

	public SplatPaintingData(NativeArray<float> heightMapDelta, NativeArray<float> angleMap)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		HeightMapDelta = heightMapDelta;
		AngleMap = angleMap;
		IsValid = true;
	}

	public void Dispose()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		IsValid = false;
		if (HeightMapDelta.IsCreated)
		{
			HeightMapDelta.Dispose();
		}
		if (AngleMap.IsCreated)
		{
			AngleMap.Dispose();
		}
	}

	public void Dispose(JobHandle inputDeps)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		IsValid = false;
		if (HeightMapDelta.IsCreated)
		{
			HeightMapDelta.Dispose(inputDeps);
		}
		if (AngleMap.IsCreated)
		{
			AngleMap.Dispose(inputDeps);
		}
	}
}


using System.Collections.Generic;
using System.Threading.Tasks;
using GenerateErosionJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class GenerateErosionSplat : ProceduralComponent
{
	public override void Process(uint seed)
	{
		if (!World.Networked)
		{
			Debug.Assert(GenerateErosion.splatPaintingData.IsValid, "GenerateErosion.splatPaintingData is not populated, GenerateErosion likely missing from WorldSetup");
			if (GenerateErosion.splatPaintingData.IsValid)
			{
				PaintSplat();
			}
		}
	}

	private void PaintSplat()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(GenerateErosion.splatPaintingData.HeightMapDelta.IsCreated);
		Debug.Assert(GenerateErosion.splatPaintingData.AngleMap.IsCreated);
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		NativeArray<float> heightMapDelta = GenerateErosion.splatPaintingData.HeightMapDelta;
		NativeArray<float> angleMap = GenerateErosion.splatPaintingData.AngleMap;
		int res = TerrainMeta.HeightMap.res;
		Parallel.For(1, res - 1, delegate(int z)
		{
			for (int i = 1; i < res - 1; i++)
			{
				angleMap[z * res + i] = TerrainMeta.HeightMap.GetSlope(i, z);
			}
		});
		splatMap.Push();
		NativeHashMap<int, int> val = default(NativeHashMap<int, int>);
		val..ctor(splatMap.num, AllocatorHandle.op_Implicit((Allocator)3));
		foreach (var (num3, num4) in TerrainSplat.GetType2IndexDic())
		{
			val.Add(num3, num4);
		}
		JobHandle val2 = default(JobHandle);
		PaintSplatJob paintSplatJob = default(PaintSplatJob);
		paintSplatJob.HeightMapDelta = heightMapDelta.AsReadOnly();
		paintSplatJob.HeightMapRes = TerrainMeta.HeightMap.res;
		paintSplatJob.AngleMapDeg = angleMap.AsReadOnly();
		paintSplatJob.TopologyMap = TerrainMeta.TopologyMap.src.AsReadOnly();
		paintSplatJob.TopologyMapRes = TerrainMeta.TopologyMap.res;
		paintSplatJob.SplatMap = splatMap.dst;
		paintSplatJob.SplatMapRes = splatMap.res;
		paintSplatJob.SplatNum = splatMap.num;
		paintSplatJob.SplatType2Index = val.AsReadOnly();
		paintSplatJob.TerrainOneOverSizeX = TerrainMeta.OneOverSize.x;
		PaintSplatJob paintSplatJob2 = paintSplatJob;
		val2 = IJobForExtensions.ScheduleByRef<PaintSplatJob>(ref paintSplatJob2, heightMapDelta.Length, val2);
		val.Dispose(val2);
		GenerateErosion.splatPaintingData.Dispose(val2);
		((JobHandle)(ref val2)).Complete();
		splatMap.Pop();
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateHeight : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_height")]
	public unsafe static extern void Native_GenerateHeight(short* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		short* unsafePtr = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.dst);
		int res = TerrainMeta.HeightMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		Native_GenerateHeight(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic);
	}
}


using System.Threading.Tasks;
using Unity.Collections;

public class GenerateOceanTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		TerrainTopologyMap topologymap = TerrainMeta.TopologyMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		NativeArray<int> dst = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = topologymap.Coordinate(i);
				float normZ = topologymap.Coordinate(z);
				int num = dst[z * res + i];
				if (heightmap.GetHeight01(normX, normZ) <= 0.5f)
				{
					if ((num & 0x810000) == 0)
					{
						dst[z * res + i] = num | 0x80;
					}
				}
				else
				{
					dst[z * res + i] = num & -129;
				}
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GeneratePowerlineLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;
	}

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Powerlines.Clear();
			TerrainMeta.Path.Powerlines.AddRange(World.GetPaths("Powerline"));
		}
		else
		{
			if (!World.Config.Powerlines)
			{
				return;
			}
			List<PathList> list = new List<PathList>();
			List<MonumentInfo> monuments = TerrainMeta.Path.Monuments;
			int[,] array = TerrainPath.CreatePowerlineCostmap(ref seed);
			PathFinder pathFinder = new PathFinder(array);
			int length = array.GetLength(0);
			List<PathSegment> list2 = new List<PathSegment>();
			List<PathNode> list3 = new List<PathNode>();
			List<PathNode> list4 = new List<PathNode>();
			List<PathFinder.Point> list5 = new List<PathFinder.Point>();
			List<PathFinder.Point> list6 = new List<PathFinder.Point>();
			List<PathFinder.Point> list7 = new List<PathFinder.Point>();
			foreach (PathList road in TerrainMeta.Path.Roads)
			{
				if (road.ProcgenStartNode == null || road.ProcgenEndNode == null || road.Hierarchy != 0)
				{
					continue;
				}
				int num = 1;
				for (PathFinder.Node node = road.ProcgenStartNode; node != null; node = node.next)
				{
					if (num % 8 == 0)
					{
						list5.Add(node.point);
					}
					num++;
				}
			}
			foreach (MonumentInfo item in monuments)
			{
				TerrainPathConnect[] componentsInChildren = ((Component)item).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Power)
					{
						PathFinder.Point pathFinderPoint = terrainPathConnect.GetPathFinderPoint(length);
						PathFinder.Node node2 = pathFinder.FindClosestWalkable(pathFinderPoint, 100000);
						if (node2 != null)
						{
							PathNode pathNode = new PathNode();
							pathNode.monument = item;
							pathNode.node = node2;
							list4.Add(pathNode);
						}
					}
				}
			}
			while (list4.Count != 0)
			{
				list7.Clear();
				list7.AddRange(list4.Select((PathNode x) => x.node.point));
				list6.Clear();
				list6.AddRange(list3.Select((PathNode x) => x.node.point));
				list6.AddRange(list5);
				PathFinder.Node node3 = pathFinder.FindPathUndirected(list6, list7, 100000);
				if (node3 == null)
				{
					PathNode copy = list4[0];
					list3.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)copy.monument));
					list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)copy.monument);
					continue;
				}
				PathSegment segment = new PathSegment();
				for (PathFinder.Node node4 = node3; node4 != null; node4 = node4.next)
				{
					if (node4 == node3)
					{
						segment.start = node4;
					}
					if (node4.next == null)
					{
						segment.end = node4;
					}
				}
				list2.Add(segment);
				PathNode copy2 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				list3.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)copy2.monument));
				list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)copy2.monument);
				int num2 = 1;
				for (PathFinder.Node node5 = node3; node5 != null; node5 = node5.next)
				{
					if (num2 % 8 == 0)
					{
						list5.Add(node5.point);
					}
					num2++;
				}
			}
			List<Vector3> list8 = new List<Vector3>();
			foreach (PathSegment item2 in list2)
			{
				for (PathFinder.Node node6 = item2.start; node6 != null; node6 = node6.next)
				{
					float num3 = ((float)node6.point.x + 0.5f) / (float)length;
					float num4 = ((float)node6.point.y + 0.5f) / (float)length;
					float height = TerrainMeta.HeightMap.GetHeight01(num3, num4);
					list8.Add(TerrainMeta.Denormalize(new Vector3(num3, height, num4)));
				}
				if (list8.Count != 0)
				{
					if (list8.Count >= 8)
					{
						PathList pathList = new PathList("Powerline " + (TerrainMeta.Path.Powerlines.Count + list.Count), list8.ToArray());
						pathList.Start = true;
						pathList.End = true;
						pathList.ProcgenStartNode = item2.start;
						pathList.ProcgenEndNode = item2.end;
						list.Add(pathList);
					}
					list8.Clear();
				}
			}
			foreach (PathList item3 in list)
			{
				item3.Path.RecalculateTangents();
			}
			TerrainMeta.Path.Powerlines.AddRange(list);
		}
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;
}


public class GeneratePowerlineTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailBranching : ProceduralComponent
{
	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 1
		};
	}

	public override void Process(uint seed)
	{
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_0528: Unknown result type (might be due to invalid IL or missing references)
		//IL_0534: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_0588: Unknown result type (might be due to invalid IL or missing references)
		//IL_058d: Unknown result type (might be due to invalid IL or missing references)
		//IL_058f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_059f: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_060d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_063a: Unknown result type (might be due to invalid IL or missing references)
		//IL_063e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0643: Unknown result type (might be due to invalid IL or missing references)
		//IL_066f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0674: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			return;
		}
		int num = Mathf.RoundToInt(40f);
		int num2 = Mathf.RoundToInt(53.333332f);
		int num3 = Mathf.RoundToInt(40f);
		int num4 = Mathf.RoundToInt(120f);
		float num5 = 120f * 120f;
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				select target).ToArray();
			foreach (TerrainPathConnect terrainPathConnect in array2)
			{
				pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(((Component)terrainPathConnect).transform.position, length));
			}
		}
		if (pathFinder.PushPointsAdditional.Count > 0)
		{
			pathFinder.PushDistance = 10;
			pathFinder.PushMultiplier = int.MaxValue;
		}
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		foreach (PathList rail2 in TerrainMeta.Path.Rails)
		{
			foreach (PathList rail3 in TerrainMeta.Path.Rails)
			{
				if (rail2 == rail3)
				{
					continue;
				}
				Vector3[] points = rail2.Path.Points;
				foreach (Vector3 val in points)
				{
					Vector3[] points2 = rail3.Path.Points;
					foreach (Vector3 val2 in points2)
					{
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < num5)
						{
							hashSet.Add(val);
							break;
						}
					}
				}
			}
		}
		foreach (PathList rail4 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path = rail4.Path;
			Vector3[] points3 = path.Points;
			Vector3[] tangents = path.Tangents;
			int num6 = path.MinIndex + 1 + 8;
			int num7 = path.MaxIndex - 1 - 8;
			for (int l = num6; l <= num7; l++)
			{
				list2.Clear();
				list3.Clear();
				list4.Clear();
				int num8 = SeedRandom.Range(ref seed, num3, num4);
				int num9 = SeedRandom.Range(ref seed, num, num2);
				int num10 = l;
				int num11 = l + num8;
				if (num11 >= num7)
				{
					continue;
				}
				Vector3 val4 = tangents[num10];
				Vector3 val5 = tangents[num11];
				if (Vector3.Angle(val4, val5) > 30f)
				{
					continue;
				}
				Vector3 val6 = points3[num10];
				Vector3 val7 = points3[num11];
				if (hashSet.Contains(val6) || hashSet.Contains(val7))
				{
					continue;
				}
				PathFinder.Point point = PathFinder.GetPoint(val6, length);
				PathFinder.Point point2 = PathFinder.GetPoint(val7, length);
				l += num9;
				PathFinder.Node node = pathFinder.FindPath(point, point2, 250000);
				if (node == null)
				{
					continue;
				}
				PathFinder.Node node2 = null;
				PathFinder.Node node3 = null;
				PathFinder.Node node4 = node;
				while (node4 != null && node4.next != null)
				{
					if (node4 == node.next)
					{
						node2 = node4;
					}
					if (node4.next.next == null)
					{
						node3 = node4;
					}
					node4 = node4.next;
				}
				if (node2 == null || node3 == null)
				{
					continue;
				}
				node = node2;
				node3.next = null;
				for (int m = 0; m < 8; m++)
				{
					int num12 = num10 + (m + 1 - 8);
					int num13 = num11 + m;
					list2.Add(points3[num12]);
					list3.Add(points3[num13]);
				}
				list4.AddRange(list2);
				for (PathFinder.Node node5 = node2; node5 != null; node5 = node5.next)
				{
					float normX = ((float)node5.point.x + 0.5f) / (float)length;
					float normZ = ((float)node5.point.y + 0.5f) / (float)length;
					float num14 = TerrainMeta.DenormalizeX(normX);
					float num15 = TerrainMeta.DenormalizeZ(normZ);
					float num16 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
					list4.Add(new Vector3(num14, num16, num15));
				}
				list4.AddRange(list3);
				int num17 = 8;
				int num18 = list4.Count - 1 - 8;
				Vector3 val8 = Vector3.Normalize(list4[num17 + 16] - list4[num17]);
				Vector3 val9 = Vector3.Normalize(list4[num18] - list4[num18 - 16]);
				Vector3 val10 = Vector3.Normalize(points3[num10 + 16] - points3[num10]);
				Vector3 val11 = Vector3.Normalize(points3[num11] - points3[(num11 - 16 + points3.Length) % points3.Length]);
				float num19 = Vector3.SignedAngle(val10, val8, Vector3.up);
				float num20 = 0f - Vector3.SignedAngle(val11, val9, Vector3.up);
				if (Mathf.Sign(num19) != Mathf.Sign(num20) || Mathf.Abs(num19) > 60f || Mathf.Abs(num20) > 60f)
				{
					continue;
				}
				Vector3 val12 = rot90 * val10;
				Vector3 val13 = rot90 * val11;
				if (num19 < 0f)
				{
					val12 = -val12;
				}
				if (num20 < 0f)
				{
					val13 = -val13;
				}
				for (int n = 0; n < 16; n++)
				{
					int num21 = n;
					int num22 = list4.Count - n - 1;
					float num23 = Mathf.InverseLerp(0f, 8f, (float)n);
					float num24 = Mathf.SmoothStep(0f, 2f, num23) * 4f;
					List<Vector3> list5 = list4;
					int j = num21;
					list5[j] += val12 * num24;
					list5 = list4;
					j = num22;
					list5[j] += val13 * num24;
				}
				bool flag = false;
				bool flag2 = false;
				foreach (Vector3 item in list4)
				{
					bool blocked = TerrainMeta.PlacementMap.GetBlocked(item);
					if (!flag2 && !flag && !blocked)
					{
						flag = true;
					}
					if (flag && !flag2 && blocked)
					{
						flag2 = true;
					}
					if (flag && flag2 && !blocked)
					{
						list4.Clear();
						break;
					}
				}
				if (list4.Count != 0)
				{
					if (list4.Count >= 2)
					{
						int number = TerrainMeta.Path.Rails.Count + list.Count;
						PathList pathList = CreateSegment(number, list4.ToArray());
						pathList.Start = false;
						pathList.End = false;
						pathList.ProcgenStartNode = node2;
						pathList.ProcgenEndNode = node3;
						list.Add(pathList);
					}
					l += num8;
				}
			}
		}
		foreach (PathList rail in list)
		{
			Func<int, float> filter = delegate(int i)
			{
				float num25 = Mathf.InverseLerp(0f, 8f, (float)i);
				float num26 = Mathf.InverseLerp((float)rail.Path.DefaultMaxIndex, (float)(rail.Path.DefaultMaxIndex - 8), (float)i);
				return Mathf.SmoothStep(0f, 1f, Mathf.Min(num25, num26));
			};
			rail.Path.Smoothen(32, new Vector3(1f, 0f, 1f), filter);
			rail.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter);
			rail.Path.Resample(7.5f);
			rail.Path.RecalculateTangents();
			rail.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 1
		};
	}

	public override void Process(uint seed)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0506: Unknown result type (might be due to invalid IL or missing references)
		//IL_0508: Unknown result type (might be due to invalid IL or missing references)
		//IL_050a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06be: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0857: Unknown result type (might be due to invalid IL or missing references)
		//IL_0865: Unknown result type (might be due to invalid IL or missing references)
		//IL_086a: Unknown result type (might be due to invalid IL or missing references)
		//IL_086f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0874: Unknown result type (might be due to invalid IL or missing references)
		//IL_0876: Unknown result type (might be due to invalid IL or missing references)
		//IL_087b: Unknown result type (might be due to invalid IL or missing references)
		//IL_087d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0882: Unknown result type (might be due to invalid IL or missing references)
		//IL_0804: Unknown result type (might be due to invalid IL or missing references)
		//IL_0809: Unknown result type (might be due to invalid IL or missing references)
		//IL_080b: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0814: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_081b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0738: Unknown result type (might be due to invalid IL or missing references)
		//IL_073e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08da: Unknown result type (might be due to invalid IL or missing references)
		//IL_091f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_0928: Unknown result type (might be due to invalid IL or missing references)
		//IL_092d: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0f: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Rails.Clear();
			TerrainMeta.Path.Rails.AddRange(World.GetPaths("Rail"));
			{
				foreach (PathList rail in TerrainMeta.Path.Rails)
				{
					Func<int, float> filter = delegate(int i)
					{
						float num = Mathf.InverseLerp(0f, 8f, (float)i);
						float num2 = Mathf.InverseLerp((float)rail.Path.DefaultMaxIndex, (float)(rail.Path.DefaultMaxIndex - 8), (float)i);
						return Mathf.SmoothStep(0f, 1f, Mathf.Min(num, num2));
					};
					Vector3[] points = rail.Path.Points;
					for (int j = 1; j < points.Length - 1; j++)
					{
						Vector3 val = points[j];
						val.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(val), 1f);
						points[j] = val;
					}
					rail.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter);
					rail.Path.RecalculateTangents();
				}
				return;
			}
		}
		if (!World.Config.AboveGroundRails)
		{
			return;
		}
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		PathFinder pathFinder2 = new PathFinder(array);
		int length = array.GetLength(0);
		new List<PathSegment>();
		List<PathFinder.Point> list2 = new List<PathFinder.Point>();
		List<PathFinder.Point> list3 = new List<PathFinder.Point>();
		List<PathFinder.Point> list4 = new List<PathFinder.Point>();
		List<Vector3> list5 = new List<Vector3>();
		foreach (PathList rail3 in TerrainMeta.Path.Rails)
		{
			for (PathFinder.Node node = rail3.ProcgenStartNode; node != null; node = node.next)
			{
				list2.Add(node.point);
			}
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			pathFinder.PushPoint = monument.GetPathFinderPoint(length);
			pathFinder.PushRadius = (pathFinder.PushDistance = monument.GetPathFinderRadius(length));
			pathFinder.PushMultiplier = 50000;
			int num3 = int.MaxValue;
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				orderby DistanceToRail(((Component)target).transform.position)
				select target).ToArray();
			TerrainPathConnect[] array3 = array2;
			foreach (TerrainPathConnect terrainPathConnect in array3)
			{
				pathFinder.PushPointsAdditional.Clear();
				pathFinder.BlockedPointsAdditional.Clear();
				Vector3 val2 = ((Component)terrainPathConnect).transform.position;
				TerrainPathConnect[] array4 = array2;
				foreach (TerrainPathConnect terrainPathConnect2 in array4)
				{
					if (!((Object)(object)terrainPathConnect == (Object)(object)terrainPathConnect2))
					{
						Vector3 position = ((Component)terrainPathConnect2).transform.position;
						PathFinder.Point point = PathFinder.GetPoint(((Component)terrainPathConnect2).transform.position, length);
						pathFinder.PushPointsAdditional.Add(point);
						val2 += position;
					}
				}
				val2 /= (float)array2.Length;
				Vector3 val3;
				if (array2.Length <= 1)
				{
					val3 = ((Component)terrainPathConnect).transform.forward;
				}
				else
				{
					Vector3 val4 = ((Component)terrainPathConnect).transform.position - val2;
					val3 = ((Vector3)(ref val4)).normalized;
				}
				Vector3 val5 = val3;
				foreach (PathList item in list)
				{
					pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(item.Path.GetEndPoint(), length));
					PathFinder.Point point2 = PathFinder.GetPoint(item.Path.GetStartPoint(), length);
					Vector3[] points2 = item.Path.Points;
					for (int l = 0; l < points2.Length; l++)
					{
						PathFinder.Point point3 = PathFinder.GetPoint(points2[l], length);
						pathFinder.BlockedPointsAdditional.Add(point3);
						pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point3.x, point2.y));
						pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point2.x, point3.y));
						point2 = point3;
					}
					if (item.ProcgenStartNode != null)
					{
						PathFinder.Point point4 = item.ProcgenStartNode.point;
						for (PathFinder.Node node2 = item.ProcgenStartNode; node2 != null; node2 = node2.next)
						{
							PathFinder.Point point5 = node2.point;
							pathFinder.BlockedPointsAdditional.Add(point5);
							pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point5.x, point4.y));
							pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point4.x, point5.y));
							point4 = point5;
						}
					}
				}
				list5.Clear();
				Vector3 val6 = ((Component)terrainPathConnect).transform.position;
				Vector3 val7 = ((Component)terrainPathConnect).transform.forward * 7.5f;
				PathFinder.Point point6 = PathFinder.GetPoint(val6, length);
				for (int m = 0; (m < 8 && pathFinder.Heuristic(point6, list2) > 1) || (m < 16 && !pathFinder.IsWalkable(point6)); m++)
				{
					list5.Add(val6);
					val6 += val7;
					point6 = PathFinder.GetPoint(val6, length);
				}
				if (!pathFinder.IsWalkable(point6))
				{
					continue;
				}
				list3.Clear();
				list3.Add(point6);
				list4.Clear();
				list4.AddRange(list2);
				PathFinder.Node node3 = pathFinder.FindPathDirected(list3, list4, 250000);
				bool flag = false;
				if (node3 == null && list.Count > 0 && num3 != int.MaxValue)
				{
					PathList pathList = list[list.Count - 1];
					list4.Clear();
					for (int n = 0; n < pathList.Path.Points.Length; n++)
					{
						list4.Add(PathFinder.GetPoint(pathList.Path.Points[n], length));
					}
					node3 = pathFinder2.FindPathDirected(list3, list4, 250000);
					flag = true;
				}
				if (node3 == null)
				{
					continue;
				}
				PathFinder.Node node4 = null;
				PathFinder.Node node5 = null;
				PathFinder.Node node6 = node3;
				while (node6 != null && node6.next != null)
				{
					if (node6 == node3.next)
					{
						node4 = node6;
					}
					if (node6.next.next == null)
					{
						node5 = node6;
						node5.next = null;
					}
					node6 = node6.next;
				}
				for (PathFinder.Node node7 = node4; node7 != null; node7 = node7.next)
				{
					float normX = ((float)node7.point.x + 0.5f) / (float)length;
					float normZ = ((float)node7.point.y + 0.5f) / (float)length;
					float num4 = TerrainMeta.DenormalizeX(normX);
					float num5 = TerrainMeta.DenormalizeZ(normZ);
					float num6 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
					list5.Add(new Vector3(num4, num6, num5));
				}
				if (list5.Count < 1)
				{
					continue;
				}
				Vector3 val8 = list5[list5.Count - 1];
				Vector3 val9 = val5;
				PathList pathList2 = null;
				float num7 = float.MaxValue;
				int num8 = -1;
				if (!flag)
				{
					foreach (PathList rail4 in TerrainMeta.Path.Rails)
					{
						Vector3[] points3 = rail4.Path.Points;
						for (int num9 = 0; num9 < points3.Length; num9++)
						{
							float num10 = Vector3.Distance(val8, points3[num9]);
							if (num10 < num7)
							{
								num7 = num10;
								pathList2 = rail4;
								num8 = num9;
							}
						}
					}
				}
				else
				{
					foreach (PathList item2 in list)
					{
						Vector3[] points4 = item2.Path.Points;
						for (int num11 = 0; num11 < points4.Length; num11++)
						{
							float num12 = Vector3.Distance(val8, points4[num11]);
							if (num12 < num7)
							{
								num7 = num12;
								pathList2 = item2;
								num8 = num11;
							}
						}
					}
				}
				int num13 = 1;
				if (!flag)
				{
					Vector3 tangentByIndex = pathList2.Path.GetTangentByIndex(num8);
					num13 = ((Vector3.Angle(tangentByIndex, val9) < Vector3.Angle(-tangentByIndex, val9)) ? 1 : (-1));
					if (num3 != int.MaxValue)
					{
						GenericsUtil.Swap<int>(ref num3, ref num13);
						num13 = -num13;
					}
					else
					{
						num3 = num13;
					}
				}
				Vector3 val10 = Vector3.Normalize(pathList2.Path.GetPointByIndex(num8 + num13 * 8 * 2) - pathList2.Path.GetPointByIndex(num8));
				Vector3 val11 = rot90 * val10;
				if (!flag)
				{
					Vector3 val12 = Vector3.Normalize(list5[list5.Count - 1] - list5[Mathf.Max(0, list5.Count - 1 - 16)]);
					if (0f - Vector3.SignedAngle(val10, val12, Vector3.up) < 0f)
					{
						val11 = -val11;
					}
				}
				for (int num14 = 0; num14 < 8; num14++)
				{
					float num15 = Mathf.InverseLerp(7f, 0f, (float)num14);
					float num16 = Mathf.SmoothStep(0f, 2f, num15) * 4f;
					list5.Add(pathList2.Path.GetPointByIndex(num8 + num13 * num14) + val11 * num16);
				}
				if (list5.Count >= 2)
				{
					int number = TerrainMeta.Path.Rails.Count + list.Count;
					PathList rail2 = CreateSegment(number, list5.ToArray());
					rail2.Start = true;
					rail2.End = false;
					rail2.ProcgenStartNode = node4;
					rail2.ProcgenEndNode = node5;
					Func<int, float> filter2 = delegate(int i)
					{
						float num17 = Mathf.InverseLerp(0f, 8f, (float)i);
						float num18 = Mathf.InverseLerp((float)rail2.Path.DefaultMaxIndex, (float)(rail2.Path.DefaultMaxIndex - 8), (float)i);
						return Mathf.SmoothStep(0f, 1f, Mathf.Min(num17, num18));
					};
					rail2.Path.Smoothen(32, new Vector3(1f, 0f, 1f), filter2);
					rail2.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter2);
					rail2.Path.Resample(7.5f);
					rail2.Path.RecalculateTangents();
					list.Add(rail2);
				}
			}
		}
		foreach (PathList item3 in list)
		{
			item3.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
		static float DistanceToRail(Vector3 vec)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			float num19 = float.MaxValue;
			foreach (PathList rail5 in TerrainMeta.Path.Rails)
			{
				Vector3[] points5 = rail5.Path.Points;
				foreach (Vector3 val13 in points5)
				{
					num19 = Mathf.Min(num19, Vector3Ex.Magnitude2D(vec - val13));
				}
			}
			return num19;
		}
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public TerrainPathConnect target;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;

	public TerrainPathConnect origin;

	public TerrainPathConnect target;
}


using UnityEngine;

public class GenerateRailMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0f;

	public const bool SnapToTerrain = false;

	public Mesh RailMesh;

	public Mesh[] RailMeshes;

	public Material RailMaterial;

	public PhysicMaterial RailPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Expected O, but got Unknown
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Expected O, but got Unknown
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		if (RailMeshes == null || RailMeshes.Length == 0)
		{
			RailMeshes = (Mesh[])(object)new Mesh[1] { RailMesh };
		}
		foreach (PathList rail in TerrainMeta.Path.Rails)
		{
			GameObject val = new GameObject(rail.Name);
			foreach (PathList.MeshObject item in rail.CreateMesh(RailMeshes, 0f, snapToTerrain: false, !rail.Path.Circular && !rail.Start, !rail.Path.Circular && !rail.End))
			{
				GameObject val2 = new GameObject("Rail Mesh");
				val2.transform.position = item.Position;
				val2.tag = "Railway";
				TagComponentEx.SetCustomTag(val2, GameObjectTag.AllowBarricadePlacement, apply: true);
				val2.layer = 16;
				val2.transform.SetParent(val.transform, true);
				val2.SetActive(false);
				MeshCollider obj = val2.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RailPhysicMaterial;
				obj.sharedMesh = item.Meshes[0];
				val2.AddComponent<AddToHeightMap>();
				val2.SetActive(true);
			}
			AddTrackSpline(val, rail);
		}
	}

	private void AddTrackSpline(GameObject rootGO, PathList rail)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline trainTrackSpline = rootGO.AddComponent<TrainTrackSpline>();
		trainTrackSpline.aboveGroundSpawn = rail.Hierarchy == 2;
		trainTrackSpline.hierarchy = rail.Hierarchy;
		if (trainTrackSpline.aboveGroundSpawn)
		{
			TrainTrackSpline.SidingSplines.Add(trainTrackSpline);
		}
		Vector3[] array = (Vector3[])(object)new Vector3[rail.Path.Points.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = rail.Path.Points[i];
			array[i].y += 0.41f;
		}
		Vector3[] array2 = (Vector3[])(object)new Vector3[rail.Path.Tangents.Length];
		for (int j = 0; j < array.Length; j++)
		{
			array2[j] = rail.Path.Tangents[j];
		}
		trainTrackSpline.SetAll(array, array2, 0.25f);
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailRing : ProceduralComponent
{
	private class RingNode
	{
		public int attempts;

		public PathFinder.Point position;

		public PathFinder.Point direction;

		public RingNode next;

		public RingNode prev;

		public PathFinder.Node path;

		public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
		{
			position = new PathFinder.Point(pos_x, pos_y);
			direction = new PathFinder.Point(dir_x, dir_y);
			attempts = stepcount;
		}
	}

	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 250000;

	public int MinWorldSize;

	public override void Process(uint seed)
	{
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_082c: Unknown result type (might be due to invalid IL or missing references)
		//IL_093a: Unknown result type (might be due to invalid IL or missing references)
		//IL_095d: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked || World.Size < MinWorldSize || !World.Config.AboveGroundRails)
		{
			return;
		}
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		int num = length / 4;
		int num2 = 1;
		int stepcount = num / num2;
		int num3 = length / 2;
		int pos_x = num;
		int pos_x2 = length - num;
		int pos_y = num;
		int pos_y2 = length - num;
		int num4 = 0;
		int dir_x = -num2;
		int dir_x2 = num2;
		int dir_y = -num2;
		int dir_y2 = num2;
		List<RingNode> list = ((World.Size >= 5000) ? new List<RingNode>
		{
			new RingNode(num3, pos_y2, num4, dir_y, stepcount),
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, num3, dir_x, num4, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(num3, pos_y, num4, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, num3, dir_x2, num4, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		} : new List<RingNode>
		{
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		});
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				select target).ToArray();
			foreach (TerrainPathConnect terrainPathConnect in array2)
			{
				pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(((Component)terrainPathConnect).transform.position, length));
			}
		}
		if (pathFinder.PushPointsAdditional.Count > 0)
		{
			pathFinder.PushDistance = 10;
			pathFinder.PushMultiplier = int.MaxValue;
		}
		for (int j = 0; j < list.Count; j++)
		{
			RingNode ringNode = list[j];
			RingNode next = list[(j + 1) % list.Count];
			RingNode prev = list[(j - 1 + list.Count) % list.Count];
			ringNode.next = next;
			ringNode.prev = prev;
			while (!pathFinder.IsWalkableWithNeighbours(ringNode.position))
			{
				if (ringNode.attempts <= 0)
				{
					return;
				}
				ringNode.position += ringNode.direction;
				ringNode.attempts--;
			}
		}
		foreach (RingNode item in list)
		{
			item.path = pathFinder.FindPath(item.position, item.next.position, 250000);
		}
		bool flag = false;
		while (!flag)
		{
			flag = true;
			PathFinder.Point point = new PathFinder.Point(0, 0);
			foreach (RingNode item2 in list)
			{
				point += item2.position;
			}
			point /= list.Count;
			float num5 = float.MinValue;
			RingNode ringNode2 = null;
			foreach (RingNode item3 in list)
			{
				if (item3.path == null)
				{
					Vector2 val = new Vector2((float)(item3.position.x - point.x), (float)(item3.position.y - point.y));
					float num6 = ((Vector2)(ref val)).magnitude;
					if (item3.prev.path == null)
					{
						num6 *= 1.5f;
					}
					if (num6 > num5)
					{
						num5 = num6;
						ringNode2 = item3;
					}
				}
			}
			if (ringNode2 == null)
			{
				continue;
			}
			do
			{
				if (ringNode2.attempts <= 0)
				{
					return;
				}
				ringNode2.position += ringNode2.direction;
				ringNode2.attempts--;
			}
			while (!pathFinder.IsWalkableWithNeighbours(ringNode2.position));
			ringNode2.path = pathFinder.FindPath(ringNode2.position, ringNode2.next.position, 250000);
			ringNode2.prev.path = pathFinder.FindPath(ringNode2.prev.position, ringNode2.position, 250000);
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		for (int k = 0; k < list.Count; k++)
		{
			RingNode ringNode3 = list[k];
			RingNode ringNode4 = list[(k + 1) % list.Count];
			PathFinder.Node node = null;
			PathFinder.Node node2 = null;
			for (PathFinder.Node node3 = ringNode3.path; node3 != null; node3 = node3.next)
			{
				for (PathFinder.Node node4 = ringNode4.path; node4 != null; node4 = node4.next)
				{
					int num7 = Mathf.Abs(node3.point.x - node4.point.x);
					int num8 = Mathf.Abs(node3.point.y - node4.point.y);
					if (num7 <= 15 && num8 <= 15)
					{
						if (node == null || node3.cost > node.cost)
						{
							node = node3;
						}
						if (node2 == null || node4.cost < node2.cost)
						{
							node2 = node4;
						}
					}
				}
			}
			if (node != null && node2 != null)
			{
				PathFinder.Node node5 = pathFinder.FindPath(node.point, node2.point, 250000);
				if (node5 != null && node5.next != null)
				{
					node.next = node5.next;
					ringNode4.path = node2;
				}
			}
		}
		for (int l = 0; l < list.Count; l++)
		{
			RingNode ringNode5 = list[l];
			RingNode ringNode6 = list[(l + 1) % list.Count];
			PathFinder.Node node6 = null;
			PathFinder.Node node7 = null;
			for (PathFinder.Node node8 = ringNode5.path; node8 != null; node8 = node8.next)
			{
				for (PathFinder.Node node9 = ringNode6.path; node9 != null; node9 = node9.next)
				{
					int num9 = Mathf.Abs(node8.point.x - node9.point.x);
					int num10 = Mathf.Abs(node8.point.y - node9.point.y);
					if (num9 <= 1 && num10 <= 1)
					{
						if (node6 == null || node8.cost > node6.cost)
						{
							node6 = node8;
						}
						if (node7 == null || node9.cost < node7.cost)
						{
							node7 = node9;
						}
					}
				}
			}
			if (node6 != null && node7 != null)
			{
				node6.next = null;
				ringNode6.path = node7;
			}
		}
		PathFinder.Node node10 = null;
		PathFinder.Node node11 = null;
		foreach (RingNode item4 in list)
		{
			if (node10 == null)
			{
				node10 = item4.path;
				node11 = item4.path;
			}
			else
			{
				node11.next = item4.path;
			}
			while (node11.next != null)
			{
				node11 = node11.next;
			}
		}
		node11.next = new PathFinder.Node(node10.point, node10.cost, node10.heuristic);
		List<Vector3> list2 = new List<Vector3>();
		for (PathFinder.Node node12 = node10; node12 != null; node12 = node12.next)
		{
			float normX = ((float)node12.point.x + 0.5f) / (float)length;
			float normZ = ((float)node12.point.y + 0.5f) / (float)length;
			float num11 = TerrainMeta.DenormalizeX(normX);
			float num12 = TerrainMeta.DenormalizeZ(normZ);
			float num13 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
			list2.Add(new Vector3(num11, num13, num12));
		}
		if (list2.Count >= 2)
		{
			PathList pathList = new PathList("Rail " + TerrainMeta.Path.Rails.Count, list2.ToArray());
			pathList.Spline = true;
			pathList.Width = 4f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 32f;
			pathList.RandomScale = 1f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 524288;
			pathList.Splat = 128;
			pathList.Start = false;
			pathList.End = false;
			pathList.ProcgenStartNode = node10;
			pathList.ProcgenEndNode = node11;
			pathList.Path.Smoothen(32, new Vector3(1f, 0f, 1f));
			pathList.Path.Smoothen(64, new Vector3(0f, 1f, 0f));
			pathList.Path.Resample(7.5f);
			pathList.Path.RecalculateTangents();
			pathList.AdjustPlacementMap(20f);
			TerrainMeta.Path.Rails.Add(pathList);
		}
	}
}


private class RingNode
{
	public int attempts;

	public PathFinder.Point position;

	public PathFinder.Point direction;

	public RingNode next;

	public RingNode prev;

	public PathFinder.Node path;

	public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
	{
		position = new PathFinder.Point(pos_x, pos_y);
		direction = new PathFinder.Point(dir_x, dir_y);
		attempts = stepcount;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRailSiding : ProceduralComponent
{
	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rotRight = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rotLeft = Quaternion.Euler(0f, -90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 2
		};
	}

	public override void Process(uint seed)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			return;
		}
		int num = Mathf.RoundToInt(40f);
		int num2 = Mathf.RoundToInt(53.333332f);
		int num3 = Mathf.RoundToInt(13.333333f);
		int num4 = Mathf.RoundToInt(20f);
		float num5 = 16f * 16f;
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		new PathFinder(array);
		array.GetLength(0);
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		foreach (PathList rail in TerrainMeta.Path.Rails)
		{
			foreach (PathList rail2 in TerrainMeta.Path.Rails)
			{
				if (rail == rail2)
				{
					continue;
				}
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					Vector3[] points2 = rail2.Path.Points;
					foreach (Vector3 val2 in points2)
					{
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < num5)
						{
							hashSet.Add(val);
							break;
						}
					}
				}
			}
		}
		foreach (PathList rail3 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path = rail3.Path;
			Vector3[] points3 = path.Points;
			Vector3[] tangents = path.Tangents;
			int num6 = path.MinIndex + 1 + 16;
			int num7 = path.MaxIndex - 1 - 16;
			for (int k = num6; k <= num7; k++)
			{
				list2.Clear();
				list3.Clear();
				int num8 = SeedRandom.Range(ref seed, num3, num4);
				int num9 = SeedRandom.Range(ref seed, num, num2);
				int num10 = k;
				int num11 = k + num8;
				if (num11 >= num7)
				{
					continue;
				}
				Vector3 val4 = tangents[num10];
				Vector3 val5 = tangents[num11];
				if (Vector3.Angle(val4, val5) > 30f)
				{
					continue;
				}
				Vector3 val6 = tangents[num10];
				Vector3 val7 = tangents[num11];
				Vector3 val8 = Vector3.Normalize(points3[num10 + 8] - points3[num10]);
				Vector3 val9 = Vector3.Normalize(points3[num11] - points3[num11 - 8]);
				float num12 = Vector3.SignedAngle(val8, val6, Vector3.up);
				float num13 = 0f - Vector3.SignedAngle(val9, val7, Vector3.up);
				if (Mathf.Sign(num12) != Mathf.Sign(num13) || Mathf.Abs(num12) > 60f || Mathf.Abs(num13) > 60f)
				{
					continue;
				}
				float num14 = 5f;
				Quaternion val10 = ((num12 > 0f) ? rotRight : rotLeft);
				for (int l = num10 - 8; l <= num11 + 8; l++)
				{
					Vector3 val11 = points3[l];
					if (hashSet.Contains(val11))
					{
						list2.Clear();
						list3.Clear();
						break;
					}
					Vector3 val12 = tangents[l];
					Vector3 val13 = val10 * val12;
					if (l < num10 + 8)
					{
						float num15 = Mathf.InverseLerp((float)(num10 - 8), (float)num10, (float)l);
						float num16 = Mathf.SmoothStep(0f, 1f, num15) * num14;
						val11 += val13 * num16;
					}
					else if (l > num11 - 8)
					{
						float num17 = Mathf.InverseLerp((float)(num11 + 8), (float)num11, (float)l);
						float num18 = Mathf.SmoothStep(0f, 1f, num17) * num14;
						val11 += val13 * num18;
					}
					else
					{
						val11 += val13 * num14;
					}
					list2.Add(val11);
					list3.Add(val12);
				}
				if (list2.Count >= 2)
				{
					int number = TerrainMeta.Path.Rails.Count + list.Count;
					PathList pathList = CreateSegment(number, list2.ToArray());
					pathList.Start = false;
					pathList.End = false;
					list.Add(pathList);
					k += num8;
				}
				k += num9;
			}
		}
		foreach (PathList item in list)
		{
			item.Path.Resample(7.5f);
			item.Path.RecalculateTangents();
			item.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRailTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 8;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 64;

	public const int SmoothenXZ = 32;

	public const int TransitionSteps = 8;

	private float AdjustTerrainFade(float xn, float zn)
	{
		int topology = TerrainMeta.TopologyMap.GetTopology(xn, zn);
		if ((topology & 0x4000) != 0)
		{
			return 0f;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.5f;
		}
		return 1f;
	}

	private float SmoothenFilter(PathList path, int index)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float num = (path.Start ? Mathf.SmoothStep(0f, 1f, Mathf.InverseLerp(0f, 8f, (float)index)) : 1f);
		int topology = TerrainMeta.TopologyMap.GetTopology(path.Path.Points[index]);
		if ((topology & 0x4000) != 0)
		{
			return 0.1f * num;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.3f * num;
		}
		return num;
	}

	public override void Process(uint seed)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		for (int j = 0; j < 8; j++)
		{
			foreach (PathList rail in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				PathInterpolator path = rail.Path;
				Vector3[] points = path.Points;
				for (int k = 0; k < points.Length; k++)
				{
					Vector3 val = points[k];
					float num = heightMap.GetHeight(val);
					if ((topologyMap.GetTopology(val) & 0xC000) != 0)
					{
						num = Mathf.Max(num, WaterLevel.RaycastWaterColliders(val) + 2f);
					}
					if (rail.Start)
					{
						val.y = Mathf.SmoothStep(val.y, num, SmoothenFilter(rail, k));
					}
					else
					{
						val.y = num;
					}
					points[k] = val;
				}
				path.Smoothen(8, Vector3.up, (int i) => SmoothenFilter(rail, i));
				path.RecalculateTangents();
			}
			foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fademin = 0.125f;
				float fademax = Mathf.InverseLerp(8f, 0f, (float)j);
				item.AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => Mathf.Lerp(fademin, fademax, AdjustTerrainFade(xn, zn)));
				heightMap.Pop();
			}
		}
		foreach (PathList rail2 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path2 = rail2.Path;
			Vector3[] points2 = path2.Points;
			for (int l = 0; l < points2.Length; l++)
			{
				Vector3 val2 = points2[l];
				float height = heightMap.GetHeight(val2);
				if (rail2.Start)
				{
					val2.y = Mathf.SmoothStep(val2.y, height, SmoothenFilter(rail2, l));
				}
				else
				{
					val2.y = height;
				}
				points2[l] = val2;
			}
			path2.RecalculateTangents();
		}
	}
}


using System.Linq;

public class GenerateRailTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture();
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRailTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology();
		}
		MarkRailside();
		TerrainMeta.PlacementMap.Reset();
	}

	private void MarkRailside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 1572864, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x100000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverLayout : ProceduralComponent
{
	public const float Width = 8f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 16f;

	public const float OuterFade = 64f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = -0.5f;

	public const float TerrainOffset = -1.5f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_0714: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_076d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_080c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0811: Unknown result type (might be due to invalid IL or missing references)
		//IL_078b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0790: Unknown result type (might be due to invalid IL or missing references)
		//IL_0792: Unknown result type (might be due to invalid IL or missing references)
		//IL_0794: Unknown result type (might be due to invalid IL or missing references)
		//IL_0796: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_045d: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_060f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0611: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_0618: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0626: Unknown result type (might be due to invalid IL or missing references)
		//IL_0628: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		//IL_062f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0633: Unknown result type (might be due to invalid IL or missing references)
		//IL_063d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0642: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Rivers.Clear();
			TerrainMeta.Path.Rivers.AddRange(World.GetPaths("River"));
		}
		else
		{
			if (!World.Config.Rivers)
			{
				return;
			}
			List<PathList> list = new List<PathList>();
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
			TerrainBiomeMap biomeMap = TerrainMeta.BiomeMap;
			List<Vector3> list2 = new List<Vector3>();
			int num = 3;
			if (World.Size <= 4000)
			{
				num = 2;
			}
			Vector3[] array = (Vector3[])(object)new Vector3[4]
			{
				new Vector3(-1f, 0f, -1f),
				new Vector3(-1f, 0f, 1f),
				new Vector3(1f, 0f, -1f),
				new Vector3(1f, 0f, 1f)
			};
			Vector3 val2 = default(Vector3);
			Line val6 = default(Line);
			Vector3 val8 = default(Vector3);
			for (float num2 = TerrainMeta.Center.z + 250f; num2 < TerrainMeta.Max.z - 750f; num2 += 5f)
			{
				for (float num3 = TerrainMeta.Center.x + 250f; num3 < TerrainMeta.Max.x - 750f; num3 += 5f)
				{
					Vector3[] array2 = array;
					foreach (Vector3 val in array2)
					{
						((Vector3)(ref val2))..ctor(val.x * num3, 0f, val.z * num2);
						float num4 = (val2.y = heightMap.GetHeight(val2));
						if (val2.y <= 15f)
						{
							continue;
						}
						Vector3 normal = heightMap.GetNormal(val2);
						if (normal.y <= 0.01f || normal.y >= 0.99f)
						{
							continue;
						}
						bool flag = false;
						foreach (PathList item in list)
						{
							Vector3[] points = item.Path.Points;
							foreach (Vector3 val3 in points)
							{
								if (Vector3Ex.SqrMagnitude2D(val2 - val3) < 67600f)
								{
									flag = true;
									break;
								}
							}
							if (flag)
							{
								break;
							}
						}
						if (flag)
						{
							continue;
						}
						Vector2 val4 = Vector3Ex.XZ2D(normal);
						Vector2 normalized = ((Vector2)(ref val4)).normalized;
						float num5 = Vector3.Angle(Vector3.up, normal);
						list2.Add(val2);
						float baseRadius = 4f;
						int num6 = 0;
						for (int k = 0; k < 5000; k++)
						{
							int num7 = k * 4;
							Vector2 val5 = Vector2Ex.Rotate(normalized, Mathf.Sin((float)num7 * (MathF.PI / 180f) * 0.5f) * Mathf.InverseLerp(30f, 10f, num5) * 60f);
							val2.x += val5.x * 4f;
							val2.z += val5.y * 4f;
							bool flag2 = false;
							for (int l = 0; l < list2.Count - 10; l++)
							{
								((Line)(ref val6))..ctor(list2[l], list2[l + 1]);
								Vector3 val7 = ((Line)(ref val6)).ClosestPoint(val2);
								if (Vector3Ex.SqrMagnitude2D(val2 - val7) < 16900f)
								{
									flag2 = true;
									break;
								}
							}
							if (flag2)
							{
								break;
							}
							float height = heightMap.GetHeight(val2);
							if (height > num4 + 32f)
							{
								break;
							}
							float num8 = Mathf.Min(height, num4);
							float num9 = Mathf.Lerp(0.15f, 0.95f, Mathf.InverseLerp(10f, 0f, num8));
							val2.y = Mathf.Lerp(val2.y, num8, num9);
							float radius = PathList.GetRadius(num7, 0f, baseRadius, 0.75f, scaleWidthWithLength: true);
							float radius2 = PathList.GetRadius(num7, num7, baseRadius, 0.75f, scaleWidthWithLength: true);
							int num10 = Mathf.RoundToInt(radius2 / 4f);
							((Vector3)(ref val8))..ctor(val5.x, 0f, val5.y);
							Vector3 val9 = val8 * (radius * 1.5f);
							Vector3 val10 = val8 * (radius2 + 1f + 64f);
							Vector3 val11 = rot90 * val8;
							Vector3 val12 = val11 * (radius * 1.5f);
							Vector3 val13 = val11 * (radius2 + 1f + 64f);
							int topology = topologyMap.GetTopology(val2, radius + 1f + 64f);
							int num11 = topologyMap.GetTopology(val2) & topologyMap.GetTopology(val2 - val9) & topologyMap.GetTopology(val2 + val9) & topologyMap.GetTopology(val2 + val10) & topologyMap.GetTopology(val2 - val12) & topologyMap.GetTopology(val2 - val13) & topologyMap.GetTopology(val2 + val12) & topologyMap.GetTopology(val2 + val13);
							int topology2 = topologyMap.GetTopology(val2);
							int num12 = 3742724;
							int num13 = 128;
							int num14 = 128;
							if ((topology & num12) != 0)
							{
								break;
							}
							if ((num11 & num13) != 0)
							{
								list2.Add(val2);
								if (list2.Count >= 62)
								{
									PathList pathList = new PathList("River " + (TerrainMeta.Path.Rivers.Count + list.Count), list2.ToArray());
									pathList.Spline = true;
									pathList.Width = 8f;
									pathList.InnerPadding = 1f;
									pathList.OuterPadding = 1f;
									pathList.InnerFade = 16f;
									pathList.OuterFade = 64f;
									pathList.RandomScale = 0.75f;
									pathList.MeshOffset = -0.5f;
									pathList.TerrainOffset = -1.5f;
									pathList.Topology = 16384;
									pathList.Splat = 128;
									pathList.Start = true;
									pathList.End = true;
									list.Add(pathList);
								}
								break;
							}
							if ((topology2 & num14) != 0 || val2.y < 0f)
							{
								if (num6++ >= num10)
								{
									break;
								}
							}
							else if (num6 > 0)
							{
								break;
							}
							if (k % 4 == 0)
							{
								list2.Add(val2);
							}
							normal = heightMap.GetNormal(val2);
							num5 = Vector3.Angle(Vector3.up, normal);
							Vector2 val14 = normalized;
							val4 = Vector3Ex.XZ2D(normal);
							val4 = Vector2.Lerp(val14, ((Vector2)(ref val4)).normalized, 0.025f);
							normalized = ((Vector2)(ref val4)).normalized;
							num4 = num8;
						}
						list2.Clear();
					}
				}
			}
			list.Sort((PathList a, PathList b) => b.Path.Points.Length.CompareTo(a.Path.Points.Length));
			int num15 = (int)(World.Size / 16);
			bool[,] array3 = new bool[num15, num15];
			int num16 = 0;
			for (int m = 0; m < list.Count; m++)
			{
				PathList pathList2 = list[m];
				bool flag3 = biomeMap.GetBiomeMaxType(pathList2.Path.GetEndPoint()) == 16;
				if (num16 >= num && !flag3)
				{
					list.RemoveAt(m--);
					continue;
				}
				bool flag4 = false;
				for (int n = 0; n < m; n++)
				{
					PathList pathList3 = list[n];
					Vector3[] array2 = pathList2.Path.Points;
					foreach (Vector3 val15 in array2)
					{
						Vector3[] points = pathList3.Path.Points;
						foreach (Vector3 val16 in points)
						{
							Vector3 val17 = val15 - val16;
							if (((Vector3)(ref val17)).sqrMagnitude < 67600f)
							{
								list.RemoveAt(m--);
								flag4 = true;
							}
							if (flag4)
							{
								break;
							}
						}
						if (flag4)
						{
							break;
						}
					}
					if (flag4)
					{
						break;
					}
				}
				if (flag4)
				{
					continue;
				}
				for (int num17 = 0; num17 < pathList2.Path.Points.Length; num17++)
				{
					Vector3 val18 = pathList2.Path.Points[num17];
					int num18 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(val18.x) * (float)num15), 0, num15 - 1);
					int num19 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(val18.z) * (float)num15), 0, num15 - 1);
					if (array3[num19, num18])
					{
						list.RemoveAt(m--);
						flag4 = true;
						break;
					}
				}
				if (flag4)
				{
					continue;
				}
				int num20 = -1;
				int num21 = -1;
				for (int num22 = 0; num22 < pathList2.Path.Points.Length; num22++)
				{
					Vector3 val19 = pathList2.Path.Points[num22];
					int num23 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(val19.x) * (float)num15), 0, num15 - 1);
					int num24 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(val19.z) * (float)num15), 0, num15 - 1);
					if (num20 != -1)
					{
						array3[num24, num20] = true;
					}
					if (num21 != -1)
					{
						array3[num21, num23] = true;
					}
					array3[num24, num23] = true;
					num20 = num23;
					num21 = num24;
				}
				if (!flag3)
				{
					num16++;
				}
			}
			for (int num25 = 0; num25 < list.Count; num25++)
			{
				list[num25].Name = "River " + (TerrainMeta.Path.Rivers.Count + num25);
			}
			foreach (PathList item2 in list)
			{
				item2.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
				item2.Path.Smoothen(8, new Vector3(0f, 1f, 0f));
				item2.Path.Resample(7.5f);
				item2.Path.RecalculateTangents();
			}
			TerrainMeta.Path.Rivers.AddRange(list);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0.1f;

	public const bool SnapToTerrain = false;

	public Mesh RiverMesh;

	public Mesh RiverInteriorMesh;

	public Mesh RiverInteriorFrontCapMesh;

	public Mesh RiverInteriorBackCapMesh;

	public Mesh[] RiverMeshes;

	public Material RiverMaterial;

	public PhysicMaterial RiverPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		RiverMeshes = (Mesh[])(object)new Mesh[1] { RiverMesh };
		foreach (PathList river in TerrainMeta.Path.Rivers)
		{
			GameObject val = new GameObject(river.Name);
			List<PathList.MeshObject> list = river.CreateMesh(RiverMeshes, 0.1f, snapToTerrain: false, !river.Path.Circular, !river.Path.Circular, scaleWidthWithLength: true, topAligned: false, 4);
			for (int i = 0; i < list.Count; i++)
			{
				PathList.MeshObject meshObject = list[i];
				GameObject val2 = new GameObject("River Mesh");
				val2.transform.position = meshObject.Position;
				val2.tag = "River";
				val2.layer = 4;
				val2.transform.SetParent(val.transform, true);
				val2.SetActive(false);
				MeshCollider obj = val2.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RiverPhysicMaterial;
				obj.sharedMesh = meshObject.Meshes[0];
				val2.AddComponent<RiverInfo>();
				WaterBody waterBody = val2.AddComponent<WaterBody>();
				waterBody.Type = WaterBodyType.River;
				waterBody.FishingType = WaterBody.FishingTag.River;
				val2.AddComponent<AddToWaterMap>();
				val2.SetActive(true);
			}
		}
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRiverTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 1;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 8;

	public const int SmoothenXZ = 4;

	public override void Process(uint seed)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		for (int i = 0; i < 1; i++)
		{
			foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
			{
				if (!World.Networked)
				{
					PathInterpolator path = item.Path;
					path.Smoothen(8, Vector3.up);
					path.RecalculateTangents();
				}
			}
			foreach (PathList item2 in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fade = Mathf.InverseLerp(1f, 0f, (float)i);
				item2.AdjustTerrainHeight(intensity, fade, scaleWidthWithLength: true);
				heightMap.Pop();
			}
		}
	}
}


using System.Linq;

public class GenerateRiverTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture(scaleWidthWithLength: true);
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRiverTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology(scaleWidthWithLength: true);
		}
		MarkRiverside();
	}

	public void MarkRiverside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 49152, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x8000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRoadLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public InfrastructureType RoadType;

	public const float RoadWidth = 10f;

	public const float TrailWidth = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 100000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		PathList pathList = new PathList("Road " + number, points);
		if (RoadType == InfrastructureType.Road)
		{
			pathList.Spline = true;
			pathList.Width = 10f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 128;
			pathList.Hierarchy = 1;
		}
		else
		{
			float num = 0.4f;
			pathList.Spline = true;
			pathList.Width = 4f;
			pathList.InnerPadding = 1f * num;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 1;
			pathList.Hierarchy = 2;
		}
		return pathList;
	}

	public override void Process(uint seed)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0833: Unknown result type (might be due to invalid IL or missing references)
		//IL_0778: Unknown result type (might be due to invalid IL or missing references)
		//IL_0795: Unknown result type (might be due to invalid IL or missing references)
		//IL_0909: Unknown result type (might be due to invalid IL or missing references)
		//IL_092b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Roads.Clear();
			TerrainMeta.Path.Roads.AddRange(World.GetPaths("Road"));
			TerrainMeta.Path.AddRoad(TerrainMeta.Path.Roads, addToMaster: false);
			{
				foreach (PathList road in TerrainMeta.Path.Roads)
				{
					Vector3[] points = road.Path.Points;
					for (int i = 1; i < points.Length - 1; i++)
					{
						Vector3 val = points[i];
						val.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(val), 1f);
						points[i] = val;
					}
					road.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
					road.Path.RecalculateTangents();
				}
				return;
			}
		}
		if ((RoadType == InfrastructureType.Road && !World.Config.SideRoads) || (RoadType == InfrastructureType.Trail && !World.Config.Trails))
		{
			return;
		}
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRoadCostmap(ref seed, RoadType == InfrastructureType.Trail);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		List<PathSegment> list2 = new List<PathSegment>();
		List<PathNode> list3 = new List<PathNode>();
		List<PathNode> list4 = new List<PathNode>();
		List<PathNode> list5 = new List<PathNode>();
		List<PathFinder.Point> list6 = new List<PathFinder.Point>();
		List<PathFinder.Point> list7 = new List<PathFinder.Point>();
		List<PathFinder.Point> list8 = new List<PathFinder.Point>();
		foreach (PathList road2 in TerrainMeta.Path.Roads)
		{
			if (road2.ProcgenStartNode == null || road2.ProcgenEndNode == null)
			{
				continue;
			}
			int num = 1;
			for (PathFinder.Node node = road2.ProcgenStartNode; node != null; node = node.next)
			{
				if (num % 8 == 0)
				{
					list6.Add(node.point);
				}
				num++;
			}
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.Type == MonumentType.Roadside)
			{
				continue;
			}
			TerrainPathConnect[] componentsInChildren = ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true);
			foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
			{
				if (terrainPathConnect.Type == RoadType)
				{
					PathFinder.Point pathFinderPoint = terrainPathConnect.GetPathFinderPoint(length);
					PathFinder.Node node2 = pathFinder.FindClosestWalkable(pathFinderPoint, 100000);
					if (node2 != null)
					{
						PathNode pathNode = new PathNode();
						pathNode.monument = monument;
						pathNode.target = terrainPathConnect;
						pathNode.node = node2;
						list4.Add(pathNode);
					}
				}
			}
		}
		while (list4.Count != 0 || list5.Count != 0)
		{
			if (list4.Count == 0)
			{
				PathNode node3 = list5[0];
				list4.AddRange(list5.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument));
				list5.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument);
				pathFinder.PushPoint = node3.monument.GetPathFinderPoint(length);
				pathFinder.PushRadius = (pathFinder.PushDistance = node3.monument.GetPathFinderRadius(length));
				pathFinder.PushMultiplier = 50000;
			}
			list8.Clear();
			list8.AddRange(list4.Select((PathNode x) => x.node.point));
			list7.Clear();
			list7.AddRange(list3.Select((PathNode x) => x.node.point));
			list7.AddRange(list5.Select((PathNode x) => x.node.point));
			list7.AddRange(list6);
			PathFinder.Node node4 = pathFinder.FindPathUndirected(list7, list8, 100000);
			if (node4 == null)
			{
				PathNode node5 = list4[0];
				list5.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument));
				list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument);
				list5.Remove(node5);
				list3.Add(node5);
				continue;
			}
			PathSegment segment = new PathSegment();
			for (PathFinder.Node node6 = node4; node6 != null; node6 = node6.next)
			{
				if (node6 == node4)
				{
					segment.start = node6;
				}
				if (node6.next == null)
				{
					segment.end = node6;
				}
			}
			list2.Add(segment);
			PathNode node7 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			list5.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node7.monument));
			list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node7.monument);
			list5.Remove(node7);
			list3.Add(node7);
			PathNode pathNode2 = list5.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			if (pathNode2 != null)
			{
				list5.Remove(pathNode2);
				list3.Add(pathNode2);
			}
			int num2 = 1;
			for (PathFinder.Node node8 = node4; node8 != null; node8 = node8.next)
			{
				if (num2 % 8 == 0)
				{
					list6.Add(node8.point);
				}
				num2++;
			}
		}
		foreach (PathNode target in list3)
		{
			PathSegment pathSegment = list2.Find((PathSegment x) => x.start.point == target.node.point || x.end.point == target.node.point);
			if (pathSegment != null)
			{
				if (pathSegment.start.point == target.node.point)
				{
					PathFinder.Node node9 = target.node;
					PathFinder.Node start = pathFinder.Reverse(target.node);
					node9.next = pathSegment.start;
					pathSegment.start = start;
					pathSegment.origin = target.target;
				}
				else if (pathSegment.end.point == target.node.point)
				{
					pathSegment.end.next = target.node;
					pathSegment.end = pathFinder.FindEnd(target.node);
					pathSegment.target = target.target;
				}
			}
		}
		List<Vector3> list9 = new List<Vector3>();
		foreach (PathSegment item in list2)
		{
			bool start2 = false;
			bool end = false;
			for (PathFinder.Node node10 = item.start; node10 != null; node10 = node10.next)
			{
				float normX = ((float)node10.point.x + 0.5f) / (float)length;
				float normZ = ((float)node10.point.y + 0.5f) / (float)length;
				if (item.start == node10 && (Object)(object)item.origin != (Object)null)
				{
					start2 = true;
					normX = TerrainMeta.NormalizeX(((Component)item.origin).transform.position.x);
					normZ = TerrainMeta.NormalizeZ(((Component)item.origin).transform.position.z);
				}
				else if (item.end == node10 && (Object)(object)item.target != (Object)null)
				{
					end = true;
					normX = TerrainMeta.NormalizeX(((Component)item.target).transform.position.x);
					normZ = TerrainMeta.NormalizeZ(((Component)item.target).transform.position.z);
				}
				float num3 = TerrainMeta.DenormalizeX(normX);
				float num4 = TerrainMeta.DenormalizeZ(normZ);
				float num5 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
				list9.Add(new Vector3(num3, num5, num4));
			}
			if (list9.Count != 0)
			{
				if (list9.Count >= 2)
				{
					int number = TerrainMeta.Path.Roads.Count + list.Count;
					PathList pathList = CreateSegment(number, list9.ToArray());
					pathList.Start = start2;
					pathList.End = end;
					pathList.ProcgenStartNode = item.start;
					pathList.ProcgenEndNode = item.end;
					list.Add(pathList);
				}
				list9.Clear();
			}
		}
		foreach (PathList item2 in list)
		{
			item2.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
			item2.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
			item2.Path.Resample(7.5f);
			item2.Path.RecalculateTangents();
			item2.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.AddRoad(list);
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public TerrainPathConnect target;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;

	public TerrainPathConnect origin;

	public TerrainPathConnect target;
}


using UnityEngine;

public class GenerateRoadMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0f;

	public const bool SnapToTerrain = true;

	public Mesh RoadMesh;

	public Mesh[] RoadMeshes;

	public Material RoadMaterial;

	public Material RoadRingMaterial;

	public PhysicMaterial RoadPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected O, but got Unknown
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		if (RoadMeshes == null || RoadMeshes.Length == 0)
		{
			RoadMeshes = (Mesh[])(object)new Mesh[1] { RoadMesh };
		}
		foreach (PathList road in TerrainMeta.Path.Roads)
		{
			if (road.Hierarchy >= 2)
			{
				continue;
			}
			GameObject val = new GameObject(road.Name);
			foreach (PathList.MeshObject item in road.CreateMesh(RoadMeshes, 0f, snapToTerrain: true, !road.Path.Circular, !road.Path.Circular))
			{
				GameObject val2 = new GameObject("Road Mesh");
				val2.transform.position = item.Position;
				val2.layer = 16;
				val2.tag = "IgnoreCollider";
				val2.transform.SetParent(val.transform, true);
				val2.SetActive(false);
				MeshCollider obj = val2.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RoadPhysicMaterial;
				obj.sharedMesh = item.Meshes[0];
				TagComponentEx.SetCustomTag(val2, GameObjectTag.Road, apply: true);
				val2.AddComponent<AddToHeightMap>();
				val2.SetActive(true);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRoadRing : ProceduralComponent
{
	private class RingNode
	{
		public int attempts;

		public PathFinder.Point position;

		public PathFinder.Point direction;

		public RingNode next;

		public RingNode prev;

		public PathFinder.Node path;

		public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
		{
			position = new PathFinder.Point(pos_x, pos_y);
			direction = new PathFinder.Point(dir_x, dir_y);
			attempts = stepcount;
		}
	}

	public const float Width = 12f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 250000;

	public int MinWorldSize;

	public override void Process(uint seed)
	{
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0771: Unknown result type (might be due to invalid IL or missing references)
		//IL_087e: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a1: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked || World.Size < MinWorldSize || !World.Config.MainRoads)
		{
			return;
		}
		int[,] array = TerrainPath.CreateRoadCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		int num = length / 4;
		int num2 = 1;
		int stepcount = num / num2;
		int num3 = length / 2;
		int pos_x = num;
		int pos_x2 = length - num;
		int pos_y = num;
		int pos_y2 = length - num;
		int num4 = 0;
		int dir_x = -num2;
		int dir_x2 = num2;
		int dir_y = -num2;
		int dir_y2 = num2;
		List<RingNode> list = ((World.Size >= 5000) ? new List<RingNode>
		{
			new RingNode(num3, pos_y2, num4, dir_y, stepcount),
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, num3, dir_x, num4, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(num3, pos_y, num4, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, num3, dir_x2, num4, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		} : new List<RingNode>
		{
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		});
		for (int i = 0; i < list.Count; i++)
		{
			RingNode ringNode = list[i];
			RingNode next = list[(i + 1) % list.Count];
			RingNode prev = list[(i - 1 + list.Count) % list.Count];
			ringNode.next = next;
			ringNode.prev = prev;
			while (!pathFinder.IsWalkable(ringNode.position))
			{
				if (ringNode.attempts <= 0)
				{
					return;
				}
				ringNode.position += ringNode.direction;
				ringNode.attempts--;
			}
		}
		foreach (RingNode item in list)
		{
			item.path = pathFinder.FindPath(item.position, item.next.position, 250000);
		}
		bool flag = false;
		while (!flag)
		{
			flag = true;
			PathFinder.Point point = new PathFinder.Point(0, 0);
			foreach (RingNode item2 in list)
			{
				point += item2.position;
			}
			point /= list.Count;
			float num5 = float.MinValue;
			RingNode ringNode2 = null;
			foreach (RingNode item3 in list)
			{
				if (item3.path == null)
				{
					Vector2 val = new Vector2((float)(item3.position.x - point.x), (float)(item3.position.y - point.y));
					float num6 = ((Vector2)(ref val)).magnitude;
					if (item3.prev.path == null)
					{
						num6 *= 1.5f;
					}
					if (num6 > num5)
					{
						num5 = num6;
						ringNode2 = item3;
					}
				}
			}
			if (ringNode2 == null)
			{
				continue;
			}
			do
			{
				if (ringNode2.attempts <= 0)
				{
					return;
				}
				ringNode2.position += ringNode2.direction;
				ringNode2.attempts--;
			}
			while (!pathFinder.IsWalkable(ringNode2.position));
			ringNode2.path = pathFinder.FindPath(ringNode2.position, ringNode2.next.position, 250000);
			ringNode2.prev.path = pathFinder.FindPath(ringNode2.prev.position, ringNode2.position, 250000);
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		for (int j = 0; j < list.Count; j++)
		{
			RingNode ringNode3 = list[j];
			RingNode ringNode4 = list[(j + 1) % list.Count];
			PathFinder.Node node = null;
			PathFinder.Node node2 = null;
			for (PathFinder.Node node3 = ringNode3.path; node3 != null; node3 = node3.next)
			{
				for (PathFinder.Node node4 = ringNode4.path; node4 != null; node4 = node4.next)
				{
					int num7 = Mathf.Abs(node3.point.x - node4.point.x);
					int num8 = Mathf.Abs(node3.point.y - node4.point.y);
					if (num7 <= 15 && num8 <= 15)
					{
						if (node == null || node3.cost > node.cost)
						{
							node = node3;
						}
						if (node2 == null || node4.cost < node2.cost)
						{
							node2 = node4;
						}
					}
				}
			}
			if (node != null && node2 != null)
			{
				PathFinder.Node node5 = pathFinder.FindPath(node.point, node2.point, 250000);
				if (node5 != null && node5.next != null)
				{
					node.next = node5.next;
					ringNode4.path = node2;
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			RingNode ringNode5 = list[k];
			RingNode ringNode6 = list[(k + 1) % list.Count];
			PathFinder.Node node6 = null;
			PathFinder.Node node7 = null;
			for (PathFinder.Node node8 = ringNode5.path; node8 != null; node8 = node8.next)
			{
				for (PathFinder.Node node9 = ringNode6.path; node9 != null; node9 = node9.next)
				{
					int num9 = Mathf.Abs(node8.point.x - node9.point.x);
					int num10 = Mathf.Abs(node8.point.y - node9.point.y);
					if (num9 <= 1 && num10 <= 1)
					{
						if (node6 == null || node8.cost > node6.cost)
						{
							node6 = node8;
						}
						if (node7 == null || node9.cost < node7.cost)
						{
							node7 = node9;
						}
					}
				}
			}
			if (node6 != null && node7 != null)
			{
				node6.next = null;
				ringNode6.path = node7;
			}
		}
		PathFinder.Node node10 = null;
		PathFinder.Node node11 = null;
		foreach (RingNode item4 in list)
		{
			if (node10 == null)
			{
				node10 = item4.path;
				node11 = item4.path;
			}
			else
			{
				node11.next = item4.path;
			}
			while (node11.next != null)
			{
				node11 = node11.next;
			}
		}
		node11.next = new PathFinder.Node(node10.point, node10.cost, node10.heuristic);
		List<Vector3> list2 = new List<Vector3>();
		for (PathFinder.Node node12 = node10; node12 != null; node12 = node12.next)
		{
			float normX = ((float)node12.point.x + 0.5f) / (float)length;
			float normZ = ((float)node12.point.y + 0.5f) / (float)length;
			float num11 = TerrainMeta.DenormalizeX(normX);
			float num12 = TerrainMeta.DenormalizeZ(normZ);
			float num13 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
			list2.Add(new Vector3(num11, num13, num12));
		}
		if (list2.Count >= 2)
		{
			PathList pathList = new PathList("Road " + TerrainMeta.Path.Roads.Count, list2.ToArray());
			pathList.Spline = true;
			pathList.Width = 12f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 128;
			pathList.Start = false;
			pathList.End = false;
			pathList.ProcgenStartNode = node10;
			pathList.ProcgenEndNode = node11;
			pathList.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
			pathList.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
			pathList.Path.Resample(7.5f);
			pathList.Path.RecalculateTangents();
			pathList.AdjustPlacementMap(24f);
			TerrainMeta.Path.AddRoad(pathList);
		}
	}
}


private class RingNode
{
	public int attempts;

	public PathFinder.Point position;

	public PathFinder.Point direction;

	public RingNode next;

	public RingNode prev;

	public PathFinder.Node path;

	public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
	{
		position = new PathFinder.Point(pos_x, pos_y);
		direction = new PathFinder.Point(dir_x, dir_y);
		attempts = stepcount;
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRoadTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 2;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 16;

	public const int SmoothenXZ = 4;

	private float SmoothenFilter(PathList path, int index)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		int topology = TerrainMeta.TopologyMap.GetTopology(path.Path.Points[index]);
		if ((topology & 0x80400) != 0)
		{
			return 0f;
		}
		if ((topology & 0x100000) != 0)
		{
			return 0.5f;
		}
		if ((topology & 0x4000) != 0)
		{
			return 0.1f;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.3f;
		}
		return 1f;
	}

	public override void Process(uint seed)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		for (int j = 0; j < 2; j++)
		{
			foreach (PathList road in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
			{
				PathInterpolator path = road.Path;
				Vector3[] points = path.Points;
				for (int k = 0; k < points.Length; k++)
				{
					Vector3 val = points[k];
					float num = heightMap.GetHeight(val);
					if ((topologyMap.GetTopology(val) & 0xC000) != 0)
					{
						num = Mathf.Max(num, WaterLevel.RaycastWaterColliders(val) + 2f);
					}
					val.y = num;
					points[k] = val;
				}
				path.Smoothen(8, Vector3.up, (int i) => SmoothenFilter(road, i));
				path.RecalculateTangents();
			}
			foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fade = Mathf.InverseLerp(2f, 0f, (float)j);
				item.AdjustTerrainHeight(intensity, fade);
				heightMap.Pop();
			}
			foreach (PathList item2 in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity2 = 1f;
				float num2 = Mathf.InverseLerp(2f, 0f, (float)j);
				item2.AdjustTerrainHeight(intensity2, num2 / 4f);
				heightMap.Pop();
			}
		}
		foreach (PathList road2 in TerrainMeta.Path.Roads)
		{
			PathInterpolator path2 = road2.Path;
			Vector3[] points2 = path2.Points;
			for (int l = 0; l < points2.Length; l++)
			{
				Vector3 val2 = points2[l];
				val2.y = heightMap.GetHeight(val2);
				points2[l] = val2;
			}
			path2.RecalculateTangents();
		}
	}
}


using System.Linq;

public class GenerateRoadTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture();
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRoadTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology();
		}
		MarkRoadside();
		TerrainMeta.PlacementMap.Reset();
	}

	private void MarkRoadside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 6144, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x1000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public struct GenerateSpawnPoints : IJob
{
	public NativeList<PlaceEntitiesOffshore.SpawnPoint> spawnPoints;

	public int targetCount;

	public uint seed;

	public PlaceEntitiesOffshore.TerrainSpawnBounds terrainSpawnBounds;

	public float minDistanceFromOtherEntities;

	public void Execute()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		while (spawnPoints.Length < targetCount && num < 10000)
		{
			num++;
			GetSpawnPoint(ref seed, in terrainSpawnBounds, in spawnPoints, in minDistanceFromOtherEntities, out var valid, out var position, out var rotation);
			if (valid)
			{
				ref NativeList<PlaceEntitiesOffshore.SpawnPoint> reference = ref spawnPoints;
				PlaceEntitiesOffshore.SpawnPoint spawnPoint = new PlaceEntitiesOffshore.SpawnPoint
				{
					position = position,
					rotation = rotation
				};
				reference.Add(ref spawnPoint);
			}
		}
	}

	private static void GetSpawnPoint(ref uint seed, in PlaceEntitiesOffshore.TerrainSpawnBounds terrainSpawnBounds, in NativeList<PlaceEntitiesOffshore.SpawnPoint> existingSpawnPoints, in float minDistanceFromOtherEntities, out bool valid, out float3 position, out quaternion rotation)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		float num2 = 0f;
		switch (seed % 4)
		{
		case 0u:
			num = SeedRandom.Range(ref seed, terrainSpawnBounds.leftOuterX, terrainSpawnBounds.leftInnerX);
			num2 = SeedRandom.Range(ref seed, terrainSpawnBounds.bottomOuterZ, terrainSpawnBounds.topOuterZ);
			break;
		case 1u:
			num = SeedRandom.Range(ref seed, terrainSpawnBounds.rightInnerX, terrainSpawnBounds.rightOuterX);
			num2 = SeedRandom.Range(ref seed, terrainSpawnBounds.bottomOuterZ, terrainSpawnBounds.topOuterZ);
			break;
		case 2u:
			num = SeedRandom.Range(ref seed, terrainSpawnBounds.leftOuterX, terrainSpawnBounds.rightOuterX);
			num2 = SeedRandom.Range(ref seed, terrainSpawnBounds.bottomOuterZ, terrainSpawnBounds.bottomInnerZ);
			break;
		case 3u:
			num = SeedRandom.Range(ref seed, terrainSpawnBounds.leftOuterX, terrainSpawnBounds.rightOuterX);
			num2 = SeedRandom.Range(ref seed, terrainSpawnBounds.topInnerZ, terrainSpawnBounds.topOuterZ);
			break;
		}
		float num3 = SeedRandom.Range(ref seed, 0f, 360f);
		position = new float3(num, 0f, num2);
		rotation = quaternion.Euler(0f, math.radians(num3), 0f, (RotationOrder)4);
		valid = true;
		Enumerator<PlaceEntitiesOffshore.SpawnPoint> enumerator = existingSpawnPoints.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (math.distance(enumerator.Current.position, position) < minDistanceFromOtherEntities)
				{
					valid = false;
					break;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateSplat : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_splat")]
	public unsafe static extern void Native_GenerateSplat(byte* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float biomeAngle, short* heightmap, int heightres, byte* biomemap, int biomeres, int* topologymap, int topologyres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		byte* unsafePtr = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.SplatMap.dst);
		int res = TerrainMeta.SplatMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		byte* unsafePtr3 = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.src);
		int res3 = TerrainMeta.BiomeMap.res;
		int* unsafePtr4 = (int*)NativeArrayUnsafeUtility.GetUnsafePtr<int>(TerrainMeta.TopologyMap.src);
		int res4 = TerrainMeta.TopologyMap.res;
		Native_GenerateSplat(unsafePtr, res, position, size, seed, lootAxisAngle, biomeAxisAngle, unsafePtr2, res2, unsafePtr3, res3, unsafePtr4, res4);
	}
}


public class GenerateTerrainMesh : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		if (!World.Cached)
		{
			World.AddMap("terrain", TerrainMeta.HeightMap.ToByteArray());
		}
		TerrainMeta.HeightMap.ApplyToTerrain();
	}
}


public class GenerateTextures : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		if (!World.Cached)
		{
			World.AddMap("height", TerrainMeta.HeightMap.ToByteArray());
			World.AddMap("splat", TerrainMeta.SplatMap.ToByteArray());
			World.AddMap("biome", TerrainMeta.BiomeMap.ToByteArray());
			World.AddMap("topology", TerrainMeta.TopologyMap.ToByteArray());
			World.AddMap("alpha", TerrainMeta.AlphaMap.ToByteArray());
			World.AddMap("water", TerrainMeta.WaterMap.ToByteArray());
		}
		else
		{
			TerrainMeta.HeightMap.FromByteArray(World.GetMap("height"));
		}
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateTopology : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_topology")]
	public unsafe static extern void Native_GenerateTopology(int* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, short* heightmap, int heightres, byte* biomemap, int biomeres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		int* unsafePtr = (int*)NativeArrayUnsafeUtility.GetUnsafePtr<int>(TerrainMeta.TopologyMap.dst);
		int res = TerrainMeta.TopologyMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		byte* unsafePtr3 = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.src);
		int res3 = TerrainMeta.BiomeMap.res;
		Native_GenerateTopology(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic, unsafePtr2, res2, unsafePtr3, res3);
	}
}


public class GenerateWireMeshes : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		TerrainMeta.Path.CreateWires();
	}
}


using System;

public class PlaceCliffParameters : PrefabAttribute
{
	public int CutoffSlopeInitial = 10;

	public int CutoffSlopeRepeat = 10;

	public int MinTerrainHeight;

	public int MaxTerrainHeight = 500;

	public int MinCliffHeight;

	public int MaxCliffHeight = 500;

	public float MinCliffScale = 1f;

	public float MaxCliffScale = 2f;

	protected override Type GetIndexedType()
	{
		return typeof(PlaceCliffParameters);
	}
}


using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceCliffs : ProceduralComponent
{
	private class CliffPlacement
	{
		public int count;

		public int score;

		public Prefab prefab;

		public Vector3 pos = Vector3.zero;

		public Quaternion rot = Quaternion.identity;

		public Vector3 scale = Vector3.one;

		public CliffPlacement next;
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int RetryMultiplier = 1;

	[FormerlySerializedAs("CutoffSlope")]
	public int CutoffSlopeInitial = 10;

	public int CutoffSlopeRepeat = 10;

	[FormerlySerializedAs("MinHeight")]
	public int MinTerrainHeight;

	[FormerlySerializedAs("MaxHeight")]
	public int MaxTerrainHeight = 500;

	public int MinCliffHeight;

	public int MaxCliffHeight = 500;

	[FormerlySerializedAs("MinScale")]
	public float MinCliffScale = 1f;

	[FormerlySerializedAs("MaxScale")]
	public float MaxCliffScale = 2f;

	public int TargetCount = 8;

	public int TargetLength;

	public TerrainAnchorMode AnchorModeInitial = TerrainAnchorMode.MaximizeHeight;

	public TerrainAnchorMode AnchorModeRepeat = TerrainAnchorMode.MinimizeMovement;

	[InspectorFlags]
	public SpawnFilterMode FilterModeInitial = SpawnFilterMode.PivotPoint;

	[InspectorFlags]
	public SpawnFilterMode FilterModeRepeat = SpawnFilterMode.PivotPoint;

	private static float min_scale_delta = 0.1f;

	private static int max_scale_attempts = 10;

	private static int min_rotation = rotation_delta;

	private static int max_rotation = 60;

	private static int rotation_delta = 10;

	private static float offset_c = 0f;

	private static float offset_l = -0.75f;

	private static float offset_r = 0.75f;

	private static Vector3[] offsets = (Vector3[])(object)new Vector3[5]
	{
		new Vector3(offset_c, offset_c, offset_c),
		new Vector3(offset_l, offset_c, offset_c),
		new Vector3(offset_r, offset_c, offset_c),
		new Vector3(offset_c, offset_c, offset_l),
		new Vector3(offset_c, offset_c, offset_r)
	};

	public override void Process(uint seed)
	{
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Prefab[] array2 = array.Where((Prefab prefab) => (bool)prefab.Attribute.Find<DecorSocketMale>(prefab.ID) && (bool)prefab.Attribute.Find<DecorSocketFemale>(prefab.ID)).ToArray();
		if (array2 == null || array2.Length == 0)
		{
			return;
		}
		Prefab[] array3 = array.Where((Prefab prefab) => prefab.Attribute.Find<DecorSocketMale>(prefab.ID)).ToArray();
		if (array3 == null || array3.Length == 0)
		{
			return;
		}
		Prefab[] array4 = array.Where((Prefab prefab) => prefab.Attribute.Find<DecorSocketFemale>(prefab.ID)).ToArray();
		if (array4 == null || array4.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		int num3 = Mathf.RoundToInt(size.x * size.z * 0.001f * (float)RetryMultiplier);
		Vector3 val = default(Vector3);
		for (int i = 0; i < num3; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num);
			float num5 = SeedRandom.Range(ref seed, z, num2);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			Prefab random = array2.GetRandom(ref seed);
			PlaceCliffParameters placeCliffParameters = random.Attribute.Find<PlaceCliffParameters>(random.ID);
			int num7 = (placeCliffParameters ? placeCliffParameters.CutoffSlopeInitial : CutoffSlopeInitial);
			int num8 = (placeCliffParameters ? placeCliffParameters.MinTerrainHeight : MinTerrainHeight);
			int num9 = (placeCliffParameters ? placeCliffParameters.MaxTerrainHeight : MaxTerrainHeight);
			int num10 = (placeCliffParameters ? placeCliffParameters.MinCliffHeight : MinCliffHeight);
			int num11 = (placeCliffParameters ? placeCliffParameters.MaxCliffHeight : MaxCliffHeight);
			float num12 = (placeCliffParameters ? placeCliffParameters.MinCliffScale : MinCliffScale);
			float num13 = (placeCliffParameters ? placeCliffParameters.MaxCliffScale : MaxCliffScale);
			if ((FilterModeInitial & SpawnFilterMode.PivotPoint) != 0)
			{
				float factor = Filter.GetFactor(normX, normZ);
				if (factor * factor < num6)
				{
					continue;
				}
			}
			float height = heightMap.GetHeight(normX, normZ);
			if (height < (float)num8 || height > (float)num9)
			{
				continue;
			}
			Vector3 normal = heightMap.GetNormal(normX, normZ);
			if (Vector3.Angle(Vector3.up, normal) < (float)num7)
			{
				continue;
			}
			((Vector3)(ref val))..ctor(num4, height, num5);
			Quaternion val2 = QuaternionEx.LookRotationForcedUp(normal, Vector3.up);
			float num14 = Mathf.Max((num13 - num12) / (float)max_scale_attempts, min_scale_delta);
			for (float num15 = num13; num15 >= num12; num15 -= num14)
			{
				Vector3 pos = val;
				Quaternion rot = val2 * random.Object.transform.localRotation;
				Vector3 scale = num15 * random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorModeInitial, ((FilterModeInitial & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && !(pos.y < (float)num10) && !(pos.y > (float)num11) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterModeInitial & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					CliffPlacement cliffPlacement = PlaceMale(array3, ref seed, random, pos, rot, scale);
					CliffPlacement cliffPlacement2 = PlaceFemale(array4, ref seed, random, pos, rot, scale);
					World.AddPrefab("Decor", random, pos, rot, scale);
					while (cliffPlacement != null && cliffPlacement.prefab != null)
					{
						World.AddPrefab("Decor", cliffPlacement.prefab, cliffPlacement.pos, cliffPlacement.rot, cliffPlacement.scale);
						cliffPlacement = cliffPlacement.next;
						i++;
					}
					while (cliffPlacement2 != null && cliffPlacement2.prefab != null)
					{
						World.AddPrefab("Decor", cliffPlacement2.prefab, cliffPlacement2.pos, cliffPlacement2.rot, cliffPlacement2.scale);
						cliffPlacement2 = cliffPlacement2.next;
						i++;
					}
					break;
				}
			}
		}
	}

	private CliffPlacement PlaceMale(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Place<DecorSocketFemale, DecorSocketMale>(prefabs, ref seed, parentPrefab, parentPos, parentRot, parentScale);
	}

	private CliffPlacement PlaceFemale(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Place<DecorSocketMale, DecorSocketFemale>(prefabs, ref seed, parentPrefab, parentPos, parentRot, parentScale);
	}

	private CliffPlacement Place<ParentSocketType, ChildSocketType>(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale, int parentAngle = 0, int parentCount = 0, int parentScore = 0) where ParentSocketType : PrefabAttribute where ChildSocketType : PrefabAttribute
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0354: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		CliffPlacement cliffPlacement = null;
		if (parentAngle > 160 || parentAngle < -160)
		{
			return cliffPlacement;
		}
		int num = SeedRandom.Range(ref seed, 0, prefabs.Length);
		ParentSocketType val = parentPrefab.Attribute.Find<ParentSocketType>(parentPrefab.ID);
		Vector3 val2 = parentPos + parentRot * Vector3.Scale(val.worldPosition, parentScale);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		for (int i = 0; i < prefabs.Length; i++)
		{
			Prefab prefab = prefabs[(num + i) % prefabs.Length];
			if (prefab == parentPrefab)
			{
				continue;
			}
			ParentSocketType val3 = prefab.Attribute.Find<ParentSocketType>(prefab.ID);
			ChildSocketType val4 = prefab.Attribute.Find<ChildSocketType>(prefab.ID);
			bool flag = val3 != null;
			if (cliffPlacement != null && cliffPlacement.count > TargetCount && cliffPlacement.score > TargetLength && flag)
			{
				continue;
			}
			PlaceCliffParameters placeCliffParameters = prefab.Attribute.Find<PlaceCliffParameters>(prefab.ID);
			int num2 = (placeCliffParameters ? placeCliffParameters.CutoffSlopeRepeat : CutoffSlopeRepeat);
			int num3 = (placeCliffParameters ? placeCliffParameters.MinTerrainHeight : MinTerrainHeight);
			int num4 = (placeCliffParameters ? placeCliffParameters.MaxTerrainHeight : MaxTerrainHeight);
			int num5 = (placeCliffParameters ? placeCliffParameters.MinCliffHeight : MinCliffHeight);
			int num6 = (placeCliffParameters ? placeCliffParameters.MaxCliffHeight : MaxCliffHeight);
			float num7 = (placeCliffParameters ? placeCliffParameters.MinCliffScale : MinCliffScale);
			float num8 = (placeCliffParameters ? placeCliffParameters.MaxCliffScale : MaxCliffScale);
			float num9 = Mathf.Max((num8 - num7) / (float)max_scale_attempts, min_scale_delta);
			float num10 = num8;
			while (num10 >= num7)
			{
				int j;
				Vector3 scale;
				Quaternion rot;
				Vector3 pos;
				for (j = min_rotation; j <= max_rotation; j += rotation_delta)
				{
					for (int k = -1; k <= 1; k += 2)
					{
						Vector3[] array = offsets;
						foreach (Vector3 val5 in array)
						{
							scale = prefab.Object.transform.localScale * num10;
							rot = Quaternion.Euler(0f, (float)(k * j), 0f) * parentRot;
							pos = val2 - rot * (Vector3.Scale(val4.worldPosition, scale) + val5);
							float normX = TerrainMeta.NormalizeX(pos.x);
							float normZ = TerrainMeta.NormalizeZ(pos.z);
							if ((FilterModeRepeat & SpawnFilterMode.PivotPoint) != 0)
							{
								float factor = Filter.GetFactor(normX, normZ);
								if (factor * factor < 0.5f)
								{
									continue;
								}
							}
							float height = heightMap.GetHeight(normX, normZ);
							if (height < (float)num3 || height > (float)num4)
							{
								continue;
							}
							Vector3 normal = heightMap.GetNormal(normX, normZ);
							if (Vector3.Angle(Vector3.up, normal) < (float)num2)
							{
								continue;
							}
							prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
							if (!prefab.ApplyTerrainAnchors(ref pos, rot, scale, AnchorModeRepeat, ((FilterModeRepeat & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) || pos.y < (float)num5 || pos.y > (float)num6 || !prefab.ApplyTerrainChecks(pos, rot, scale, ((FilterModeRepeat & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) || !prefab.ApplyTerrainFilters(pos, rot, scale) || !prefab.ApplyWaterChecks(pos, rot, scale) || !prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale))
							{
								continue;
							}
							goto IL_0387;
						}
					}
				}
				num10 -= num9;
				continue;
				IL_0387:
				int parentAngle2 = parentAngle + j;
				int num11 = parentCount + 1;
				int num12 = parentScore + Mathf.CeilToInt(Vector3Ex.Distance2D(parentPos, pos));
				CliffPlacement cliffPlacement2 = null;
				if (flag)
				{
					cliffPlacement2 = Place<ParentSocketType, ChildSocketType>(prefabs, ref seed, prefab, pos, rot, scale, parentAngle2, num11, num12);
					if (cliffPlacement2 != null)
					{
						num11 = cliffPlacement2.count;
						num12 = cliffPlacement2.score;
					}
				}
				else
				{
					num12 *= 2;
				}
				if (cliffPlacement == null)
				{
					cliffPlacement = new CliffPlacement();
				}
				if (cliffPlacement.score < num12)
				{
					cliffPlacement.next = cliffPlacement2;
					cliffPlacement.count = num11;
					cliffPlacement.score = num12;
					cliffPlacement.prefab = prefab;
					cliffPlacement.pos = pos;
					cliffPlacement.rot = rot;
					cliffPlacement.scale = scale;
				}
				break;
			}
		}
		return cliffPlacement;
	}
}


using UnityEngine;

private class CliffPlacement
{
	public int count;

	public int score;

	public Prefab prefab;

	public Vector3 pos = Vector3.zero;

	public Quaternion rot = Quaternion.identity;

	public Vector3 scale = Vector3.one;

	public CliffPlacement next;
}


using UnityEngine;

public class PlaceCliffsUniform : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDistance = 10f;

	public float ObjectDithering = 5f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	private static int min_rotation_z = 0;

	private static int max_rotation_z = 12;

	private static int rotation_delta_z = 4;

	private static int min_rotation_x = 0;

	private static int max_rotation_x = 12;

	private static int rotation_delta_x = 2;

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (int num3 = 128; num3 > 0; num3 /= 2)
		{
			float num4 = ObjectDistance * (float)num3;
			for (float num5 = z; num5 < num2; num5 += num4)
			{
				for (float num6 = x; num6 < num; num6 += num4)
				{
					float num7 = num6 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
					float num8 = num5 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
					float normX = TerrainMeta.NormalizeX(num7);
					float normZ = TerrainMeta.NormalizeZ(num8);
					float num9 = SeedRandom.Value(ref seed);
					array.BubbleSort();
					if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
					{
						float factor = Filter.GetFactor(normX, normZ);
						if (factor * factor < num9)
						{
							continue;
						}
					}
					float height = heightMap.GetHeight(normX, normZ);
					Prefab[] array2 = array;
					foreach (Prefab prefab in array2)
					{
						((Vector3)(ref pos))..ctor(num7, height, num8);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						bool flag = false;
						Vector3 val = Vector3.zero;
						Quaternion rotation = Quaternion.identity;
						Vector3 scale2 = Vector3.zero;
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						for (int j = min_rotation_z; j <= max_rotation_z; j += rotation_delta_z)
						{
							for (int k = min_rotation_x; k <= max_rotation_x; k += rotation_delta_x)
							{
								for (int l = -1; l <= 1; l += 2)
								{
									for (int m = -1; m <= 1; m += 2)
									{
										Vector3 pos2 = pos;
										Quaternion val2 = rot * Quaternion.Euler((float)(m * k), 0f, (float)(l * j));
										Vector3 val3 = scale;
										if (prefab.ApplyTerrainFilters(pos2, val2, val3) && prefab.ApplyTerrainAnchors(ref pos2, val2, val3, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && prefab.ApplyTerrainChecks(pos2, val2, val3, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && prefab.ApplyWaterChecks(pos2, val2, val3) && prefab.ApplyEnvironmentVolumeChecks(pos2, val2, val3) && (!flag || val.y < pos2.y))
										{
											flag = true;
											val = pos2;
											rotation = val2;
											scale2 = val3;
										}
									}
								}
							}
						}
						if (flag)
						{
							prefab.SpawnedCount++;
							World.AddPrefab("Decor", prefab, val, rotation, scale2);
							break;
						}
					}
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorUniform : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDistance = 10f;

	public float ObjectDithering = 5f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (float num3 = z; num3 < num2; num3 += ObjectDistance)
		{
			for (float num4 = x; num4 < num; num4 += ObjectDistance)
			{
				float num5 = num4 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
				float num6 = num3 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
				float normX = TerrainMeta.NormalizeX(num5);
				float normZ = TerrainMeta.NormalizeZ(num6);
				float num7 = SeedRandom.Value(ref seed);
				Prefab random = array.GetRandom(ref seed);
				if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
				{
					float factor = Filter.GetFactor(normX, normZ);
					if (factor * factor < num7)
					{
						continue;
					}
				}
				float height = heightMap.GetHeight(normX, normZ);
				((Vector3)(ref pos))..ctor(num5, height, num6);
				Quaternion rot = random.Object.transform.localRotation;
				Vector3 scale = random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					World.AddPrefab("Decor", random, pos, rot, scale);
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorValueNoise : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public NoiseParameters Cluster = new NoiseParameters(2, 0.5f, 1f, 0f);

	public float ObjectDensity = 100f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		int num = Mathf.RoundToInt(ObjectDensity * size.x * size.z * 1E-06f);
		float x = position.x;
		float z = position.z;
		float num2 = position.x + size.x;
		float num3 = position.z + size.z;
		float num4 = SeedRandom.Range(ref seed, -1000000f, 1000000f);
		float num5 = SeedRandom.Range(ref seed, -1000000f, 1000000f);
		int octaves = Cluster.Octaves;
		float offset = Cluster.Offset;
		float frequency = Cluster.Frequency * 0.01f;
		float amplitude = Cluster.Amplitude;
		Vector3 pos = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num6 = SeedRandom.Range(ref seed, x, num2);
			float num7 = SeedRandom.Range(ref seed, z, num3);
			float normX = TerrainMeta.NormalizeX(num6);
			float normZ = TerrainMeta.NormalizeZ(num7);
			float num8 = SeedRandom.Value(ref seed);
			float factor = Filter.GetFactor(normX, normZ);
			Prefab random = array.GetRandom(ref seed);
			if (((FilterMode & SpawnFilterMode.PivotPoint) == 0 || !(factor <= 0f)) && !((offset + Noise.Turbulence(num4 + num6, num5 + num7, octaves, frequency, amplitude)) * factor * factor < num8))
			{
				float height = heightMap.GetHeight(normX, normZ);
				((Vector3)(ref pos))..ctor(num6, height, num7);
				Quaternion rot = random.Object.transform.localRotation;
				Vector3 scale = random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					World.AddPrefab("Decor", random, pos, rot, scale);
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorWhiteNoise : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDensity = 100f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		int num = Mathf.RoundToInt(ObjectDensity * size.x * size.z * 1E-06f);
		float x = position.x;
		float z = position.z;
		float num2 = position.x + size.x;
		float num3 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num2);
			float num5 = SeedRandom.Range(ref seed, z, num3);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			Prefab random = array.GetRandom(ref seed);
			if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
			{
				float factor = Filter.GetFactor(normX, normZ);
				if (factor * factor < num6)
				{
					continue;
				}
			}
			float height = heightMap.GetHeight(normX, normZ);
			((Vector3)(ref pos))..ctor(num4, height, num5);
			Quaternion rot = random.Object.transform.localRotation;
			Vector3 scale = random.Object.transform.localScale;
			random.ApplyDecorComponents(ref pos, ref rot, ref scale);
			if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
			{
				World.AddPrefab("Decor", random, pos, rot, scale);
			}
		}
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class PlaceEntitiesOffshore : ProceduralComponent
{
	public struct SpawnPoint
	{
		public float3 position;

		public quaternion rotation;
	}

	public struct TerrainSpawnBounds
	{
		public float leftOuterX;

		public float leftInnerX;

		public float rightInnerX;

		public float rightOuterX;

		public float bottomOuterZ;

		public float bottomInnerZ;

		public float topInnerZ;

		public float topOuterZ;
	}

	[SerializeField]
	private GameObjectRef prefab;

	[SerializeField]
	private float minWorldSize;

	[SerializeField]
	private int targetCount;

	[SerializeField]
	private float minDistanceFromTerrain = 100f;

	[SerializeField]
	private float maxDistanceFromTerrain = 500f;

	[SerializeField]
	private float minDistanceFromOtherEntities = 100f;

	public const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if ((float)World.Size < minWorldSize)
		{
			return;
		}
		GetTerrainSpawnBounds(float3.op_Implicit(TerrainMeta.Position), float3.op_Implicit(TerrainMeta.Size), in minDistanceFromTerrain, in maxDistanceFromTerrain, out var bounds);
		NativeList<SpawnPoint> spawnPoints = default(NativeList<SpawnPoint>);
		spawnPoints..ctor(targetCount, AllocatorHandle.op_Implicit((Allocator)3));
		try
		{
			GenerateSpawnPoints generateSpawnPoints = default(GenerateSpawnPoints);
			generateSpawnPoints.spawnPoints = spawnPoints;
			generateSpawnPoints.targetCount = targetCount;
			generateSpawnPoints.seed = seed;
			generateSpawnPoints.terrainSpawnBounds = bounds;
			generateSpawnPoints.minDistanceFromOtherEntities = minDistanceFromOtherEntities;
			GenerateSpawnPoints generateSpawnPoints2 = generateSpawnPoints;
			GenerateSpawnPoints generateSpawnPoints3 = generateSpawnPoints2;
			JobHandle val = default(JobHandle);
			val = IJobExtensions.Schedule<GenerateSpawnPoints>(generateSpawnPoints3, val);
			((JobHandle)(ref val)).Complete();
			PlacePrefabs(in generateSpawnPoints2.spawnPoints);
		}
		finally
		{
			((IDisposable)spawnPoints/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void GetTerrainSpawnBounds(in float3 terrainPosition, in float3 terrainSize, in float maxDistance, in float minDistance, out TerrainSpawnBounds bounds)
	{
		bounds.leftOuterX = terrainPosition.x - maxDistance;
		bounds.leftInnerX = terrainPosition.x - minDistance;
		bounds.rightInnerX = terrainPosition.x + terrainSize.x + minDistance;
		bounds.rightOuterX = terrainPosition.x + terrainSize.x + maxDistance;
		bounds.bottomOuterZ = terrainPosition.z - maxDistance;
		bounds.bottomInnerZ = terrainPosition.z - minDistance;
		bounds.topInnerZ = terrainPosition.z + terrainSize.z + minDistance;
		bounds.topOuterZ = terrainPosition.z + terrainSize.z + maxDistance;
	}

	private unsafe void PlacePrefabs(in NativeList<SpawnPoint> spawnPoints)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Expected O, but got Unknown
		int length = spawnPoints.Length;
		Span<Vector3> span = new Span<Vector3>(stackalloc Vector3[length], length);
		length = spawnPoints.Length;
		Span<Quaternion> span2 = new Span<Quaternion>(stackalloc Quaternion[length], length);
		for (int i = 0; i < spawnPoints.Length; i++)
		{
			span[i] = float3.op_Implicit(spawnPoints[i].position);
			span2[i] = quaternion.op_Implicit(spawnPoints[i].rotation);
		}
		Object.InstantiateAsync<GameObject>(new GameObject("TestEntityOffshore"), spawnPoints.Length, (ReadOnlySpan<Vector3>)span, (ReadOnlySpan<Quaternion>)span2);
	}
}


using Unity.Mathematics;

public struct SpawnPoint
{
	public float3 position;

	public quaternion rotation;
}


public struct TerrainSpawnBounds
{
	public float leftOuterX;

	public float leftInnerX;

	public float rightInnerX;

	public float rightOuterX;

	public float bottomOuterZ;

	public float bottomInnerZ;

	public float topInnerZ;

	public float topOuterZ;
}


using ConVar;
using UnityEngine;

public class PlaceJungleVines : PlaceDecorUniform
{
	public override void Process(uint seed)
	{
		if (!Server.spawnVineTrees)
		{
			Debug.LogWarning((object)"server.spawnVineTrees is disabled, skipping vine spawn...");
		}
		else
		{
			base.Process(seed);
		}
	}
}


using UnityEngine;

public class PlaceMonument : ProceduralComponent
{
	public struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public SpawnFilter Filter;

	public GameObjectRef Monument;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		if (!Monument.isValid)
		{
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		SpawnInfo spawnInfo = default(SpawnInfo);
		int num3 = int.MinValue;
		Prefab<MonumentInfo> prefab = Prefab.Load<MonumentInfo>(Monument.resourceID, (GameManager)null, (PrefabAttribute.Library)null);
		Vector3 pos = default(Vector3);
		for (int i = 0; i < 10000; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num);
			float num5 = SeedRandom.Range(ref seed, z, num2);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			float factor = Filter.GetFactor(normX, normZ);
			if (factor * factor < num6)
			{
				continue;
			}
			float height = heightMap.GetHeight(normX, normZ);
			((Vector3)(ref pos))..ctor(num4, height, num5);
			Quaternion rot = prefab.Object.transform.localRotation;
			Vector3 scale = prefab.Object.transform.localScale;
			prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
			if ((!Object.op_Implicit((Object)(object)prefab.Component) || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyTerrainFilters(pos, rot, scale) && prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) && prefab.ApplyTerrainChecks(pos, rot, scale, Filter) && prefab.ApplyWaterChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
			{
				SpawnInfo spawnInfo2 = default(SpawnInfo);
				spawnInfo2.prefab = prefab;
				spawnInfo2.position = pos;
				spawnInfo2.rotation = rot;
				spawnInfo2.scale = scale;
				int num7 = -Mathf.RoundToInt(Vector3Ex.Magnitude2D(pos));
				if (num7 > num3)
				{
					num3 = num7;
					spawnInfo = spawnInfo2;
				}
			}
		}
		if (num3 != int.MinValue)
		{
			World.AddPrefab("Monument", spawnInfo.prefab, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
		}
	}
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonuments : ProceduralComponent
{
	public struct WorldSizeInfo
	{
		public int WorldSizeMin;

		public int WorldSizeMax;

		public int TargetCount;
	}

	public struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public bool dungeonEntrance;

		public Vector3 dungeonEntrancePos;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;

		public float minDistanceDungeonEntrance;

		public float maxDistanceDungeonEntrance;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public AnimationCurve TargetCountWorldSizeMultiplier = AnimationCurve.Constant(1000f, 6000f, 1f);

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	[Tooltip("Enable to only spawn these monuments when running as a nexus")]
	public bool NexusOnly;

	public const int GroupCandidates = 8;

	public const int IndividualCandidates = 8;

	public const int Attempts = 10000;

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_043f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0603: Unknown result type (might be due to invalid IL or missing references)
		//IL_0605: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_057e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0587: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		if (NexusOnly && !World.Nexus)
		{
			return;
		}
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			PathFinder pathFinder = null;
			List<PathFinder.Point> endList = null;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!text.Contains("underwater_lab") || World.Config.UnderwaterLabs)
				{
					Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(text, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
					array3.Shuffle(ref seed);
					list.AddRange(array3);
				}
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			Vector3 position = TerrainMeta.Position;
			Vector3 size = TerrainMeta.Size;
			float x = position.x;
			float z = position.z;
			float num = position.x + size.x;
			float num2 = position.z + size.z;
			int num3 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num4 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			int num5 = Mathf.RoundToInt((float)TargetCount * TargetCountWorldSizeMultiplier.Evaluate((float)World.Size));
			Vector3 pos = default(Vector3);
			for (int j = 0; j < 8; j++)
			{
				num3 = 0;
				list2.Clear();
				Prefab<MonumentInfo>[] array5 = array4;
				foreach (Prefab<MonumentInfo> prefab in array5)
				{
					MonumentInfo component = prefab.Component;
					if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component.DungeonEntrance;
					int num6 = (int)((!Object.op_Implicit((Object)(object)prefab.Parameters)) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
					int num7 = 100000 * num6 * num6 * num6 * num6;
					int num8 = 0;
					int num9 = 0;
					SpawnInfo item = default(SpawnInfo);
					for (int k = 0; k < 10000; k++)
					{
						float num10 = SeedRandom.Range(ref seed, x, num);
						float num11 = SeedRandom.Range(ref seed, z, num2);
						float normX = TerrainMeta.NormalizeX(num10);
						float normZ = TerrainMeta.NormalizeZ(num11);
						float num12 = SeedRandom.Value(ref seed);
						float factor = Filter.GetFactor(normX, normZ);
						if (factor * factor < num12)
						{
							continue;
						}
						float height = heightMap.GetHeight(normX, normZ);
						((Vector3)(ref pos))..ctor(num10, height, num11);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						Vector3 val = pos;
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab, pos, rot, scale, val);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType || (Object.op_Implicit((Object)(object)dungeonEntrance) && distanceInfo.minDistanceDungeonEntrance < dungeonEntrance.MinDistance))
						{
							continue;
						}
						int num13 = num7;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num13 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num13 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num13 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num13 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (num13 <= num9 || !prefab.ApplyTerrainFilters(pos, rot, scale) || !prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) || !component.CheckPlacement(pos, rot, scale))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val2 = pos + rot * Vector3.Scale(scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val3 = dungeonEntrance.SnapPosition(val2);
							pos += val3 - val2;
							if (!dungeonEntrance.IsValidSpawnPosition(val3))
							{
								continue;
							}
							val = val3;
						}
						if (!prefab.ApplyTerrainChecks(pos, rot, scale, Filter) || !prefab.ApplyWaterChecks(pos, rot, scale) || !prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale) || prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							continue;
						}
						bool flag = false;
						TerrainPathConnect[] componentsInChildren = prefab.Object.GetComponentsInChildren<TerrainPathConnect>(true);
						foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
						{
							if (terrainPathConnect.Type == InfrastructureType.Boat)
							{
								if (pathFinder == null)
								{
									int[,] array6 = TerrainPath.CreateBoatCostmap(4f);
									int length = array6.GetLength(0);
									pathFinder = new PathFinder(array6);
									endList = new List<PathFinder.Point>
									{
										new PathFinder.Point(0, 0),
										new PathFinder.Point(0, length / 2),
										new PathFinder.Point(0, length - 1),
										new PathFinder.Point(length / 2, 0),
										new PathFinder.Point(length / 2, length - 1),
										new PathFinder.Point(length - 1, 0),
										new PathFinder.Point(length - 1, length / 2),
										new PathFinder.Point(length - 1, length - 1)
									};
								}
								PathFinder.Point point = PathFinder.GetPoint(pos + rot * Vector3.Scale(scale, ((Component)terrainPathConnect).transform.localPosition), pathFinder.GetResolution(0));
								if (pathFinder.FindPathUndirected(new List<PathFinder.Point> { point }, endList, 100000) == null)
								{
									flag = true;
									break;
								}
							}
						}
						if (!flag)
						{
							SpawnInfo spawnInfo = default(SpawnInfo);
							spawnInfo.prefab = prefab;
							spawnInfo.position = pos;
							spawnInfo.rotation = rot;
							spawnInfo.scale = scale;
							if (Object.op_Implicit((Object)(object)dungeonEntrance))
							{
								spawnInfo.dungeonEntrance = true;
								spawnInfo.dungeonEntrancePos = val;
							}
							num9 = num13;
							item = spawnInfo;
							num8++;
							if (num8 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num9 > 0)
					{
						list2.Add(item);
						num3 += num9;
					}
					if (num5 > 0 && list2.Count >= num5)
					{
						break;
					}
				}
				if (num3 > num4)
				{
					num4 = num3;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item2 in list3)
			{
				World.AddPrefab("Monument", item2.prefab, item2.position, item2.rotation, item2.scale);
			}
		}
	}

	public DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale, Vector3 dungeonPos)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceDungeonEntrance = float.MaxValue;
		result.maxDistanceDungeonEntrance = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num = ((OBB)(ref val2)).SqrDistance(val);
				if (spawn.prefab.Folder == prefab.Folder)
				{
					if (num < result.minDistanceSameType)
					{
						result.minDistanceSameType = num;
					}
					if (num > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num;
					}
				}
				else
				{
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			foreach (SpawnInfo spawn2 in spawns)
			{
				if (spawn2.dungeonEntrance)
				{
					Vector3 val3 = spawn2.dungeonEntrancePos - dungeonPos;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < result.minDistanceDungeonEntrance)
					{
						result.minDistanceDungeonEntrance = sqrMagnitude;
					}
					if (sqrMagnitude > result.maxDistanceDungeonEntrance)
					{
						result.maxDistanceDungeonEntrance = sqrMagnitude;
					}
				}
			}
		}
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				float num2 = monument.SqrDistance(val);
				if (num2 < result.minDistanceDifferentType)
				{
					result.minDistanceDifferentType = num2;
				}
				if (num2 > result.maxDistanceDifferentType)
				{
					result.maxDistanceDifferentType = num2;
				}
			}
			foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
			{
				float num3 = dungeonGridEntrance.SqrDistance(dungeonPos);
				if (num3 < result.minDistanceDungeonEntrance)
				{
					result.minDistanceDungeonEntrance = num3;
				}
				if (num3 > result.maxDistanceDungeonEntrance)
				{
					result.maxDistanceDungeonEntrance = num3;
				}
			}
		}
		if (result.minDistanceSameType != float.MaxValue)
		{
			result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
		}
		if (result.maxDistanceSameType != float.MinValue)
		{
			result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
		}
		if (result.minDistanceDifferentType != float.MaxValue)
		{
			result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
		}
		if (result.maxDistanceDifferentType != float.MinValue)
		{
			result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
		}
		if (result.minDistanceDungeonEntrance != float.MaxValue)
		{
			result.minDistanceDungeonEntrance = Mathf.Sqrt(result.minDistanceDungeonEntrance);
		}
		if (result.maxDistanceDungeonEntrance != float.MinValue)
		{
			result.maxDistanceDungeonEntrance = Mathf.Sqrt(result.maxDistanceDungeonEntrance);
		}
		return result;
	}
}


public struct WorldSizeInfo
{
	public int WorldSizeMin;

	public int WorldSizeMax;

	public int TargetCount;
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public bool dungeonEntrance;

	public Vector3 dungeonEntrancePos;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;

	public float minDistanceDungeonEntrance;

	public float maxDistanceDungeonEntrance;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsOffshore : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public int MinDistanceFromTerrain = 100;

	public int MaxDistanceFromTerrain = 500;

	public int DistanceBetweenMonuments = 500;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	private const int Candidates = 10;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(array2[i], (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
				array3.Shuffle(ref seed);
				list.AddRange(array3);
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			Vector3 position = TerrainMeta.Position;
			Vector3 size = TerrainMeta.Size;
			float num = position.x - (float)MaxDistanceFromTerrain;
			float num2 = position.x - (float)MinDistanceFromTerrain;
			float num3 = position.x + size.x + (float)MinDistanceFromTerrain;
			float num4 = position.x + size.x + (float)MaxDistanceFromTerrain;
			float num5 = position.z - (float)MaxDistanceFromTerrain;
			float num6 = position.z - (float)MinDistanceFromTerrain;
			float num7 = position.z + size.z + (float)MinDistanceFromTerrain;
			float num8 = position.z + size.z + (float)MaxDistanceFromTerrain;
			int num9 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num10 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			Vector3 pos = default(Vector3);
			for (int j = 0; j < 10; j++)
			{
				num9 = 0;
				list2.Clear();
				Prefab<MonumentInfo>[] array5 = array4;
				foreach (Prefab<MonumentInfo> prefab in array5)
				{
					int num11 = (int)((!Object.op_Implicit((Object)(object)prefab.Parameters)) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
					int num12 = num11 * num11 * num11 * num11;
					for (int k = 0; k < 10000; k++)
					{
						float num13 = 0f;
						float num14 = 0f;
						switch (seed % 4)
						{
						case 0u:
							num13 = SeedRandom.Range(ref seed, num, num2);
							num14 = SeedRandom.Range(ref seed, num5, num8);
							break;
						case 1u:
							num13 = SeedRandom.Range(ref seed, num3, num4);
							num14 = SeedRandom.Range(ref seed, num5, num8);
							break;
						case 2u:
							num13 = SeedRandom.Range(ref seed, num, num4);
							num14 = SeedRandom.Range(ref seed, num5, num6);
							break;
						case 3u:
							num13 = SeedRandom.Range(ref seed, num, num4);
							num14 = SeedRandom.Range(ref seed, num7, num8);
							break;
						}
						float normX = TerrainMeta.NormalizeX(num13);
						float normZ = TerrainMeta.NormalizeZ(num14);
						float height = heightMap.GetHeight(normX, normZ);
						((Vector3)(ref pos))..ctor(num13, height, num14);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						if (!CheckRadius(list2, pos, DistanceBetweenMonuments))
						{
							prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
							if ((!Object.op_Implicit((Object)(object)prefab.Component) || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
							{
								SpawnInfo item = default(SpawnInfo);
								item.prefab = prefab;
								item.position = pos;
								item.rotation = rot;
								item.scale = scale;
								list2.Add(item);
								num9 += num12;
								break;
							}
						}
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num9 > num10)
				{
					num10 = num9;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item2 in list3)
			{
				World.AddPrefab("Monument", item2.prefab, item2.position, item2.rotation, item2.scale);
			}
		}
	}

	public bool CheckRadius(List<SpawnInfo> spawns, Vector3 pos, float radius)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = radius * radius;
		foreach (SpawnInfo spawn in spawns)
		{
			Vector3 val = spawn.position - pos;
			if (((Vector3)(ref val)).sqrMagnitude < num)
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

private struct SpawnInfo
{
	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsRailside : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	private class SpawnInfoGroup
	{
		public bool processed;

		public Prefab<MonumentInfo> prefab;

		public List<SpawnInfo> candidates;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public int PositionOffset = 100;

	public int TangentInterval = 100;

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	private const int GroupCandidates = 8;

	private const int IndividualCandidates = 8;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0836: Unknown result type (might be due to invalid IL or missing references)
		//IL_083d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_051f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0622: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064f: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0354: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0671: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0705: Unknown result type (might be due to invalid IL or missing references)
		//IL_070c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0691: Unknown result type (might be due to invalid IL or missing references)
		//IL_0698: Unknown result type (might be due to invalid IL or missing references)
		//IL_069f: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06db: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0722: Unknown result type (might be due to invalid IL or missing references)
		//IL_0729: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0740: Unknown result type (might be due to invalid IL or missing references)
		//IL_0747: Unknown result type (might be due to invalid IL or missing references)
		//IL_074e: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_076c: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			_ = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(array2[i], (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
				array3.Shuffle(ref seed);
				list.AddRange(array3);
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			SpawnInfoGroup[] array5 = new SpawnInfoGroup[array4.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				Prefab<MonumentInfo> prefab = array4[j];
				SpawnInfoGroup spawnInfoGroup = null;
				for (int k = 0; k < j; k++)
				{
					SpawnInfoGroup spawnInfoGroup2 = array5[k];
					Prefab<MonumentInfo> prefab2 = spawnInfoGroup2.prefab;
					if (prefab == prefab2)
					{
						spawnInfoGroup = spawnInfoGroup2;
						break;
					}
				}
				if (spawnInfoGroup == null)
				{
					spawnInfoGroup = new SpawnInfoGroup();
					spawnInfoGroup.prefab = array4[j];
					spawnInfoGroup.candidates = new List<SpawnInfo>();
				}
				array5[j] = spawnInfoGroup;
			}
			SpawnInfoGroup[] array6 = array5;
			foreach (SpawnInfoGroup spawnInfoGroup3 in array6)
			{
				if (spawnInfoGroup3.processed)
				{
					continue;
				}
				Prefab<MonumentInfo> prefab3 = spawnInfoGroup3.prefab;
				MonumentInfo component = prefab3.Component;
				if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
				{
					continue;
				}
				int num = 0;
				Vector3 val = Vector3.zero;
				Vector3 val2 = Vector3.zero;
				Vector3 val3 = Vector3.zero;
				TerrainPathConnect[] componentsInChildren = prefab3.Object.GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Rail)
					{
						switch (num)
						{
						case 0:
							val2 = ((Component)terrainPathConnect).transform.position;
							break;
						case 1:
							val3 = ((Component)terrainPathConnect).transform.position;
							break;
						}
						val += ((Component)terrainPathConnect).transform.position;
						num++;
					}
				}
				Vector3 val4 = val3 - val2;
				Vector3 normalized = ((Vector3)(ref val4)).normalized;
				val4 = rot90 * normalized;
				Vector3 normalized2 = ((Vector3)(ref val4)).normalized;
				if (num > 1)
				{
					val /= (float)num;
				}
				foreach (PathList rail in TerrainMeta.Path.Rails)
				{
					PathInterpolator path = rail.Path;
					float num2 = TangentInterval / 2;
					float num3 = 5f;
					float num4 = 5f;
					float num5 = path.StartOffset + num4;
					float num6 = path.Length - path.EndOffset - num4;
					for (float num7 = num5; num7 <= num6; num7 += num3)
					{
						Vector3 val5 = (rail.Spline ? path.GetPointCubicHermite(num7) : path.GetPoint(num7));
						val4 = path.GetPoint(num7 + num2) - path.GetPoint(num7 - num2);
						Vector3 normalized3 = ((Vector3)(ref val4)).normalized;
						for (int m = Mathf.RoundToInt((float)PositionOffset); m <= Mathf.CeilToInt((float)PositionOffset * 1.5f); m += 25)
						{
							for (int n = -1; n <= 1; n += 2)
							{
								Quaternion val6 = Quaternion.LookRotation((float)n * Vector3Ex.XZ3D(normalized3));
								Vector3 val7 = val5;
								Quaternion val8 = val6;
								Vector3 localScale = prefab3.Object.transform.localScale;
								val8 *= Quaternion.LookRotation(normalized);
								val7 -= val8 * (val + (float)m * normalized2);
								if (!(GetDistanceToAboveGroundRail(val7) < (float)PositionOffset * 0.5f))
								{
									SpawnInfo item = default(SpawnInfo);
									item.prefab = prefab3;
									item.position = val7;
									item.rotation = val8;
									item.scale = localScale;
									spawnInfoGroup3.candidates.Add(item);
								}
							}
						}
					}
				}
				spawnInfoGroup3.processed = true;
			}
			int num8 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num9 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			for (int num10 = 0; num10 < 8; num10++)
			{
				num8 = 0;
				list2.Clear();
				array5.Shuffle(ref seed);
				array6 = array5;
				foreach (SpawnInfoGroup spawnInfoGroup4 in array6)
				{
					Prefab<MonumentInfo> prefab4 = spawnInfoGroup4.prefab;
					MonumentInfo component2 = prefab4.Component;
					if ((Object)(object)component2 == (Object)null || World.Size < component2.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component2.DungeonEntrance;
					int num11 = (int)((!Object.op_Implicit((Object)(object)prefab4.Parameters)) ? PrefabPriority.Low : (prefab4.Parameters.Priority + 1));
					int num12 = 100000 * num11 * num11 * num11 * num11;
					int num13 = 0;
					int num14 = 0;
					SpawnInfo item2 = default(SpawnInfo);
					ListEx.Shuffle<SpawnInfo>(spawnInfoGroup4.candidates, ref seed);
					for (int num15 = 0; num15 < spawnInfoGroup4.candidates.Count; num15++)
					{
						SpawnInfo spawnInfo = spawnInfoGroup4.candidates[num15];
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab4, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType)
						{
							continue;
						}
						int num16 = num12;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num16 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num16 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num16 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num16 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (!component2.CheckPlacement(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale))
						{
							num16 /= 2;
						}
						if (num16 <= num14 || !prefab4.ApplyTerrainFilters(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) || !prefab4.ApplyTerrainAnchors(ref spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val9 = spawnInfo.position + spawnInfo.rotation * Vector3.Scale(spawnInfo.scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val10 = dungeonEntrance.SnapPosition(val9);
							ref Vector3 position = ref spawnInfo.position;
							position += val10 - val9;
							if (!dungeonEntrance.IsValidSpawnPosition(val10))
							{
								continue;
							}
						}
						if (prefab4.ApplyTerrainChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) && prefab4.ApplyWaterChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && prefab4.ApplyEnvironmentVolumeChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && !prefab4.CheckEnvironmentVolumes(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							num14 = num16;
							item2 = spawnInfo;
							num13++;
							if (num13 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num14 > 0)
					{
						list2.Add(item2);
						num8 += num14;
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num8 > num9)
				{
					num9 = num8;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item3 in list3)
			{
				World.AddPrefab("Monument", item3.prefab, item3.position, item3.rotation, item3.scale);
			}
		}
	}

	private DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (!prefab.Component.HasDungeonLink || (!monument.HasDungeonLink && monument.WantsDungeonLink))
				{
					float num = monument.SqrDistance(val);
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			if (result.minDistanceDifferentType != float.MaxValue)
			{
				result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
			}
			if (result.maxDistanceDifferentType != float.MinValue)
			{
				result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
			}
		}
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num2 = ((OBB)(ref val2)).SqrDistance(val);
				if (num2 < result.minDistanceSameType)
				{
					result.minDistanceSameType = num2;
				}
				if (num2 > result.maxDistanceSameType)
				{
					result.maxDistanceSameType = num2;
				}
			}
			if (prefab.Component.HasDungeonLink)
			{
				foreach (MonumentInfo monument2 in TerrainMeta.Path.Monuments)
				{
					if (monument2.HasDungeonLink || !monument2.WantsDungeonLink)
					{
						float num3 = monument2.SqrDistance(val);
						if (num3 < result.minDistanceSameType)
						{
							result.minDistanceSameType = num3;
						}
						if (num3 > result.maxDistanceSameType)
						{
							result.maxDistanceSameType = num3;
						}
					}
				}
				foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
				{
					float num4 = dungeonGridEntrance.SqrDistance(monumentPos);
					if (num4 < result.minDistanceSameType)
					{
						result.minDistanceSameType = num4;
					}
					if (num4 > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num4;
					}
				}
			}
			if (result.minDistanceSameType != float.MaxValue)
			{
				result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
			}
			if (result.maxDistanceSameType != float.MinValue)
			{
				result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
			}
		}
		return result;
	}

	private float GetDistanceToAboveGroundRail(Vector3 pos)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			foreach (PathList rail in TerrainMeta.Path.Rails)
			{
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					num = Mathf.Min(num, Vector3Ex.Distance2D(val, pos));
				}
			}
		}
		return num;
	}
}


using UnityEngine;

private struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;

private class SpawnInfoGroup
{
	public bool processed;

	public Prefab<MonumentInfo> prefab;

	public List<SpawnInfo> candidates;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsRoadside : ProceduralComponent
{
	public struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public PathInterpolator path;

		public int pathStartIndex;

		public int pathEndIndex;
	}

	public class SpawnInfoGroup
	{
		public bool processed;

		public Prefab<MonumentInfo> prefab;

		public List<SpawnInfo> candidates;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public enum RoadMode
	{
		SideRoadOrRingRoad,
		SideRoad,
		RingRoad,
		SideRoadOrDesireTrail,
		DesireTrail
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	public RoadMode RoadType;

	public const int GroupCandidates = 8;

	public const int IndividualCandidates = 8;

	public static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0783: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0735: Unknown result type (might be due to invalid IL or missing references)
		//IL_073a: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_0748: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_074f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_0762: Unknown result type (might be due to invalid IL or missing references)
		//IL_0767: Unknown result type (might be due to invalid IL or missing references)
		//IL_076c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0773: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f1: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			_ = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!text.Contains("tunnel-entrance") || World.Config.BelowGroundRails)
				{
					Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(text, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
					array3.Shuffle(ref seed);
					list.AddRange(array3);
				}
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			SpawnInfoGroup[] array5 = new SpawnInfoGroup[array4.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				Prefab<MonumentInfo> prefab = array4[j];
				SpawnInfoGroup spawnInfoGroup = null;
				for (int k = 0; k < j; k++)
				{
					SpawnInfoGroup spawnInfoGroup2 = array5[k];
					Prefab<MonumentInfo> prefab2 = spawnInfoGroup2.prefab;
					if (prefab == prefab2)
					{
						spawnInfoGroup = spawnInfoGroup2;
						break;
					}
				}
				if (spawnInfoGroup == null)
				{
					spawnInfoGroup = new SpawnInfoGroup();
					spawnInfoGroup.prefab = array4[j];
					spawnInfoGroup.candidates = new List<SpawnInfo>();
				}
				array5[j] = spawnInfoGroup;
			}
			SpawnInfoGroup[] array6 = array5;
			foreach (SpawnInfoGroup spawnInfoGroup3 in array6)
			{
				if (spawnInfoGroup3.processed)
				{
					continue;
				}
				Prefab<MonumentInfo> prefab3 = spawnInfoGroup3.prefab;
				MonumentInfo component = prefab3.Component;
				if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
				{
					continue;
				}
				int num = 0;
				Vector3 val = Vector3.zero;
				Vector3 val2 = Vector3.zero;
				_ = Vector3.zero;
				float num2 = 0f;
				TerrainPathConnect[] componentsInChildren = prefab3.Object.GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Road)
					{
						Vector3 val3 = Vector3Ex.XZ3D(((Component)terrainPathConnect).transform.position);
						val += val3;
						num2 += ((Vector3)(ref val3)).magnitude;
						if (num == 0)
						{
							val2 += val3;
						}
						if (num == 1)
						{
							val2 -= val3;
						}
						num++;
					}
				}
				val2 = ((Vector3)(ref val2)).normalized;
				_ = rot90 * val2;
				if (num > 1)
				{
					val /= (float)num;
					num2 /= (float)num;
				}
				foreach (PathList road in TerrainMeta.Path.Roads)
				{
					bool flag = false;
					switch (RoadType)
					{
					case RoadMode.SideRoadOrRingRoad:
						flag = road.Hierarchy == 0 || road.Hierarchy == 1;
						break;
					case RoadMode.SideRoad:
						flag = road.Hierarchy == 1;
						break;
					case RoadMode.RingRoad:
						flag = road.Hierarchy == 0;
						break;
					case RoadMode.SideRoadOrDesireTrail:
						flag = road.Hierarchy == 1 || road.Hierarchy == 2;
						break;
					case RoadMode.DesireTrail:
						flag = road.Hierarchy == 2;
						break;
					}
					if (!flag)
					{
						continue;
					}
					PathInterpolator path = road.Path;
					float num3 = 5f;
					float num4 = 5f;
					float num5 = path.StartOffset + num4 + num2;
					float num6 = path.Length - path.EndOffset - num4 - num2;
					for (float num7 = num5; num7 <= num6; num7 += num3)
					{
						float distance = num7 - num2;
						float distance2 = num7 + num2;
						int prevIndex = path.GetPrevIndex(distance);
						int nextIndex = path.GetNextIndex(distance2);
						Vector3 point = path.GetPoint(prevIndex);
						Vector3 point2 = path.GetPoint(nextIndex);
						Vector3 val4 = (point + point2) * 0.5f;
						Vector3 val5 = point2 - point;
						Vector3 normalized = ((Vector3)(ref val5)).normalized;
						for (int m = -1; m <= 1; m += 2)
						{
							Quaternion val6 = Quaternion.LookRotation((float)m * Vector3Ex.XZ3D(normalized));
							Vector3 val7 = val4;
							Quaternion val8 = val6;
							Vector3 localScale = prefab3.Object.transform.localScale;
							val8 *= Quaternion.LookRotation(val2);
							val7 -= val8 * val;
							SpawnInfo item = default(SpawnInfo);
							item.prefab = prefab3;
							item.position = val7;
							item.rotation = val8;
							item.scale = localScale;
							item.path = path;
							item.pathStartIndex = prevIndex;
							item.pathEndIndex = nextIndex;
							spawnInfoGroup3.candidates.Add(item);
						}
					}
				}
				spawnInfoGroup3.processed = true;
			}
			int num8 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num9 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			for (int n = 0; n < 8; n++)
			{
				num8 = 0;
				list2.Clear();
				array5.Shuffle(ref seed);
				array6 = array5;
				foreach (SpawnInfoGroup spawnInfoGroup4 in array6)
				{
					Prefab<MonumentInfo> prefab4 = spawnInfoGroup4.prefab;
					MonumentInfo component2 = prefab4.Component;
					if ((Object)(object)component2 == (Object)null || World.Size < component2.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component2.DungeonEntrance;
					int num10 = (int)((!Object.op_Implicit((Object)(object)prefab4.Parameters)) ? PrefabPriority.Low : (prefab4.Parameters.Priority + 1));
					int num11 = 100000 * num10 * num10 * num10 * num10;
					int num12 = 0;
					int num13 = 0;
					SpawnInfo item2 = default(SpawnInfo);
					ListEx.Shuffle<SpawnInfo>(spawnInfoGroup4.candidates, ref seed);
					for (int num14 = 0; num14 < spawnInfoGroup4.candidates.Count; num14++)
					{
						SpawnInfo spawnInfo = spawnInfoGroup4.candidates[num14];
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab4, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType)
						{
							continue;
						}
						int num15 = num11;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num15 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num15 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num15 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num15 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (num15 <= num13 || !prefab4.ApplyTerrainFilters(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) || !prefab4.ApplyTerrainAnchors(ref spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) || !component2.CheckPlacement(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val9 = spawnInfo.position + spawnInfo.rotation * Vector3.Scale(spawnInfo.scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val10 = dungeonEntrance.SnapPosition(val9);
							ref Vector3 position = ref spawnInfo.position;
							position += val10 - val9;
							if (!dungeonEntrance.IsValidSpawnPosition(val10))
							{
								continue;
							}
						}
						if (prefab4.ApplyTerrainChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) && prefab4.ApplyWaterChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && prefab4.ApplyEnvironmentVolumeChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && !prefab4.CheckEnvironmentVolumes(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							num13 = num15;
							item2 = spawnInfo;
							num12++;
							if (num12 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num13 > 0)
					{
						list2.Add(item2);
						num8 += num13;
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num8 > num9)
				{
					num9 = num8;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item3 in list3)
			{
				World.AddPrefab("Monument", item3.prefab, item3.position, item3.rotation, item3.scale);
			}
			HashSet<PathInterpolator> hashSet = new HashSet<PathInterpolator>();
			foreach (SpawnInfo item4 in list3)
			{
				item4.path.Straighten(item4.pathStartIndex, item4.pathEndIndex);
				hashSet.Add(item4.path);
			}
			foreach (PathInterpolator item5 in hashSet)
			{
				item5.RecalculateLength();
			}
		}
	}

	private DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (!prefab.Component.HasDungeonLink || (!monument.HasDungeonLink && monument.WantsDungeonLink))
				{
					float num = monument.SqrDistance(val);
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			if (result.minDistanceDifferentType != float.MaxValue)
			{
				result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
			}
			if (result.maxDistanceDifferentType != float.MinValue)
			{
				result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
			}
		}
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num2 = ((OBB)(ref val2)).SqrDistance(val);
				if (num2 < result.minDistanceSameType)
				{
					result.minDistanceSameType = num2;
				}
				if (num2 > result.maxDistanceSameType)
				{
					result.maxDistanceSameType = num2;
				}
			}
			if (prefab.Component.HasDungeonLink)
			{
				foreach (MonumentInfo monument2 in TerrainMeta.Path.Monuments)
				{
					if (monument2.HasDungeonLink || !monument2.WantsDungeonLink)
					{
						float num3 = monument2.SqrDistance(val);
						if (num3 < result.minDistanceSameType)
						{
							result.minDistanceSameType = num3;
						}
						if (num3 > result.maxDistanceSameType)
						{
							result.maxDistanceSameType = num3;
						}
					}
				}
				foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
				{
					float num4 = dungeonGridEntrance.SqrDistance(monumentPos);
					if (num4 < result.minDistanceSameType)
					{
						result.minDistanceSameType = num4;
					}
					if (num4 > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num4;
					}
				}
			}
			if (result.minDistanceSameType != float.MaxValue)
			{
				result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
			}
			if (result.maxDistanceSameType != float.MinValue)
			{
				result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
			}
		}
		return result;
	}
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public PathInterpolator path;

	public int pathStartIndex;

	public int pathEndIndex;
}


using System.Collections.Generic;

public class SpawnInfoGroup
{
	public bool processed;

	public Prefab<MonumentInfo> prefab;

	public List<SpawnInfo> candidates;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


public enum RoadMode
{
	SideRoadOrRingRoad,
	SideRoad,
	RingRoad,
	SideRoadOrDesireTrail,
	DesireTrail
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlacePowerlineObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	public PathList.SideObject[] Side;

	[FormerlySerializedAs("PowerlineObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> powerlines = TerrainMeta.Path.Powerlines;
		if (World.Networked)
		{
			foreach (PathList item in powerlines)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in powerlines)
		{
			PathList.BasicObject[] start = Start;
			foreach (PathList.BasicObject obj in start)
			{
				item2.TrimStart(obj);
			}
			start = End;
			foreach (PathList.BasicObject obj2 in start)
			{
				item2.TrimEnd(obj2);
			}
			start = Start;
			foreach (PathList.BasicObject obj3 in start)
			{
				item2.SpawnStart(ref seed, obj3);
			}
			start = End;
			foreach (PathList.BasicObject obj4 in start)
			{
				item2.SpawnEnd(ref seed, obj4);
			}
			PathList.PathObject[] path = Path;
			foreach (PathList.PathObject obj5 in path)
			{
				item2.SpawnAlong(ref seed, obj5);
			}
			PathList.SideObject[] side = Side;
			foreach (PathList.SideObject obj6 in side)
			{
				item2.SpawnSide(ref seed, obj6);
			}
			item2.ResetTrims();
		}
	}
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlaceRiverObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	[FormerlySerializedAs("RiversideObjects")]
	public PathList.SideObject[] Side;

	[FormerlySerializedAs("RiverObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> rivers = TerrainMeta.Path.Rivers;
		if (World.Networked)
		{
			foreach (PathList item in rivers)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in rivers)
		{
			PathList.BasicObject[] start = Start;
			foreach (PathList.BasicObject obj in start)
			{
				item2.TrimStart(obj);
			}
			start = End;
			foreach (PathList.BasicObject obj2 in start)
			{
				item2.TrimEnd(obj2);
			}
			start = Start;
			foreach (PathList.BasicObject obj3 in start)
			{
				item2.SpawnStart(ref seed, obj3);
			}
			PathList.PathObject[] path = Path;
			foreach (PathList.PathObject obj4 in path)
			{
				item2.SpawnAlong(ref seed, obj4);
			}
			PathList.SideObject[] side = Side;
			foreach (PathList.SideObject obj5 in side)
			{
				item2.SpawnSide(ref seed, obj5);
			}
			start = End;
			foreach (PathList.BasicObject obj6 in start)
			{
				item2.SpawnEnd(ref seed, obj6);
			}
			item2.ResetTrims();
		}
	}
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlaceRoadObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	[FormerlySerializedAs("RoadsideObjects")]
	public PathList.SideObject[] Side;

	[FormerlySerializedAs("RoadObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> roads = TerrainMeta.Path.Roads;
		if (World.Networked)
		{
			foreach (PathList item in roads)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in roads)
		{
			if (item2.Hierarchy < 2)
			{
				PathList.BasicObject[] start = Start;
				foreach (PathList.BasicObject obj in start)
				{
					item2.TrimStart(obj);
				}
				start = End;
				foreach (PathList.BasicObject obj2 in start)
				{
					item2.TrimEnd(obj2);
				}
				start = Start;
				foreach (PathList.BasicObject obj3 in start)
				{
					item2.SpawnStart(ref seed, obj3);
				}
				start = End;
				foreach (PathList.BasicObject obj4 in start)
				{
					item2.SpawnEnd(ref seed, obj4);
				}
				PathList.PathObject[] path = Path;
				foreach (PathList.PathObject obj5 in path)
				{
					item2.SpawnAlong(ref seed, obj5);
				}
				PathList.SideObject[] side = Side;
				foreach (PathList.SideObject obj6 in side)
				{
					item2.SpawnSide(ref seed, obj6);
				}
				item2.ResetTrims();
			}
		}
	}
}


using System.Collections.Generic;

public class ProcessMonumentNodes : ProceduralComponent
{
	public override void Process(uint seed)
	{
		List<MonumentNode> monumentNodes = SingletonComponent<WorldSetup>.Instance.MonumentNodes;
		if (!World.Cached)
		{
			for (int i = 0; i < monumentNodes.Count; i++)
			{
				monumentNodes[i].Process(ref seed);
			}
		}
		monumentNodes.Clear();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ProcessProceduralObjects : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		List<ProceduralObject> proceduralObjects = SingletonComponent<WorldSetup>.Instance.ProceduralObjects;
		if (!World.Cached)
		{
			for (int i = 0; i < proceduralObjects.Count; i++)
			{
				ProceduralObject proceduralObject = proceduralObjects[i];
				if (Object.op_Implicit((Object)(object)proceduralObject))
				{
					proceduralObject.Process();
				}
			}
		}
		proceduralObjects.Clear();
	}
}


public class ResetPlacementMap : ProceduralComponent
{
	public override void Process(uint seed)
	{
		TerrainMeta.PlacementMap.Reset();
	}
}


using UnityEngine;

public abstract class ProceduralObject : MonoBehaviour
{
	protected void Awake()
	{
		if (!((Object)(object)SingletonComponent<WorldSetup>.Instance == (Object)null))
		{
			if (SingletonComponent<WorldSetup>.Instance.ProceduralObjects == null)
			{
				Debug.LogError((object)"WorldSetup.Instance.ProceduralObjects is null.", (Object)(object)this);
			}
			else
			{
				SingletonComponent<WorldSetup>.Instance.ProceduralObjects.Add(this);
			}
		}
	}

	public abstract void Process();
}


using UnityEngine;

public class AddToAlphaMap : ProceduralObject
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public override void Process()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(((Component)this).transform, bounds);
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		TerrainMeta.AlphaMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
		{
			TerrainMeta.AlphaMap.SetAlpha(x, z, 0f);
		});
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class AddToHeightMap : ProceduralObject
{
	public bool DestroyGameObject;

	public void Apply()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		Collider component = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component.bounds;
		int num = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.x));
		int num2 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.x));
		int num3 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.z));
		int num4 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.z));
		Vector3 val = default(Vector3);
		Ray val2 = default(Ray);
		RaycastHit val3 = default(RaycastHit);
		for (int i = num3; i <= num4; i++)
		{
			float normZ = TerrainMeta.HeightMap.Coordinate(i);
			for (int j = num; j <= num2; j++)
			{
				float normX = TerrainMeta.HeightMap.Coordinate(j);
				((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), ((Bounds)(ref bounds)).max.y, TerrainMeta.DenormalizeZ(normZ));
				((Ray)(ref val2))..ctor(val, Vector3.down);
				if (component.Raycast(val2, ref val3, ((Bounds)(ref bounds)).size.y))
				{
					float num5 = TerrainMeta.NormalizeY(((RaycastHit)(ref val3)).point.y);
					float height = TerrainMeta.HeightMap.GetHeight01(j, i);
					if (num5 > height)
					{
						TerrainMeta.HeightMap.SetHeight(j, i, num5);
					}
				}
			}
		}
	}

	public override void Process()
	{
		Apply();
		if (DestroyGameObject)
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
		else
		{
			GameManager.Destroy((Component)(object)this);
		}
	}
}


using UnityEngine;

public class AddToWaterMap : ProceduralObject
{
	public bool automaticallyAddTerrainTopology;

	public override void Process()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		WaterBody component = ((Component)this).GetComponent<WaterBody>();
		Collider component2 = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component2.bounds;
		int mask = (((Object)(object)component != (Object)null) ? component.GetTopologyMask() : 0);
		float num = TerrainMeta.NormalizeY(((Bounds)(ref bounds)).max.y);
		int num2 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.x));
		int num3 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.x));
		int num4 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.z));
		int num5 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.z));
		bool flag = component2 is BoxCollider && ((Component)this).transform.rotation == Quaternion.identity;
		Vector3 val = default(Vector3);
		Ray val2 = default(Ray);
		RaycastHit val3 = default(RaycastHit);
		for (int i = num4; i <= num5; i++)
		{
			float normZ = TerrainMeta.WaterMap.Coordinate(i);
			for (int j = num2; j <= num3; j++)
			{
				float normX = TerrainMeta.WaterMap.Coordinate(j);
				((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), ((Bounds)(ref bounds)).max.y + 1f, TerrainMeta.DenormalizeZ(normZ));
				if (!flag)
				{
					((Ray)(ref val2))..ctor(val, Vector3.down);
					if (!component2.Raycast(val2, ref val3, ((Bounds)(ref bounds)).size.y + 1f + 1f))
					{
						continue;
					}
					num = TerrainMeta.NormalizeY(((RaycastHit)(ref val3)).point.y);
				}
				float height = TerrainMeta.HeightMap.GetHeight01(normX, normZ);
				if (num < height - TerrainMeta.OneOverSize.z)
				{
					continue;
				}
				if ((Object)(object)component != (Object)null)
				{
					if (automaticallyAddTerrainTopology)
					{
						TerrainMeta.TopologyMap.AddTopology(normX, normZ, mask);
					}
					if (component.Type == WaterBodyType.Lake && !TerrainMeta.TopologyMap.GetTopology(normX, normZ, 196608))
					{
						continue;
					}
				}
				if (!(TerrainMeta.WaterMap.GetHeight01(j, i) >= num))
				{
					TerrainMeta.WaterMap.SetHeight(j, i, num);
				}
			}
		}
		GameManager.Destroy((Component)(object)this);
	}
}


using Oxide.Core;
using UnityEngine;

public class TerrainGenerator : SingletonComponent<TerrainGenerator>
{
	public TerrainConfig config;

	private const float HeightMapRes = 1f;

	private const float SplatMapRes = 0.5f;

	private const float BaseMapRes = 0.01f;

	public static int GetHeightMapRes()
	{
		return Mathf.Min(4096, Mathf.ClosestPowerOfTwo((int)((float)World.Size * 1f))) + 1;
	}

	public static int GetSplatMapRes()
	{
		return Mathf.Min(2048, Mathf.NextPowerOfTwo((int)((float)World.Size * 0.5f)));
	}

	public static int GetBaseMapRes()
	{
		return Mathf.Min(2048, Mathf.NextPowerOfTwo((int)((float)World.Size * 0.01f)));
	}

	public GameObject CreateTerrain()
	{
		return CreateTerrain(GetHeightMapRes(), GetSplatMapRes());
	}

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("OnTerrainCreate", (object)this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3((float)World.Size, 1000f, (float)World.Size)
		}).GetComponent<Terrain>();
		((Component)component).transform.position = ((Component)this).transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = (MaterialType)3;
		component.materialTemplate = config.Material;
		((Component)component).gameObject.tag = ((Component)this).gameObject.tag;
		((Component)component).gameObject.layer = ((Component)this).gameObject.layer;
		((Collider)((Component)component).gameObject.GetComponent<TerrainCollider>()).sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = ((Component)component).gameObject.AddComponent<TerrainMeta>();
		((Component)component).gameObject.AddComponent<TerrainPhysics>();
		((Component)component).gameObject.AddComponent<TerrainColors>();
		((Component)component).gameObject.AddComponent<TerrainCollision>();
		((Component)component).gameObject.AddComponent<TerrainBiomeMap>();
		((Component)component).gameObject.AddComponent<TerrainAlphaMap>();
		((Component)component).gameObject.AddComponent<TerrainHeightMap>();
		((Component)component).gameObject.AddComponent<TerrainSplatMap>();
		((Component)component).gameObject.AddComponent<TerrainTopologyMap>();
		((Component)component).gameObject.AddComponent<TerrainWaterMap>();
		((Component)component).gameObject.AddComponent<TerrainPlacementMap>();
		((Component)component).gameObject.AddComponent<TerrainPath>();
		((Component)component).gameObject.AddComponent<TerrainTexturing>();
		((Component)component).gameObject.AddComponent<TerrainWaterFlowMap>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate((Object)(object)((Component)this).gameObject);
		return ((Component)component).gameObject;
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using Facepunch.Math;
using Network;
using ProtoBuf;
using UnityEngine;

public class WorldNetworking
{
	private const int prefabsPerPacket = 100;

	private const int pathsPerPacket = 10;

	public static void OnMessageReceived(Message message)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Expected I4, but got Unknown
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		WorldSerialization serialization = World.Serialization;
		WorldMessage val = message.read.Proto<WorldMessage>((WorldMessage)null);
		try
		{
			MessageType status = val.status;
			switch (status - 1)
			{
			case 0:
				SendWorldData(message.connection);
				return;
			}
			if (val.prefabs != null)
			{
				serialization.world.prefabs.AddRange(val.prefabs);
				val.prefabs.Clear();
			}
			if (val.paths != null)
			{
				serialization.world.paths.AddRange(val.paths);
				val.paths.Clear();
			}
			if (PacketProfiler.shouldCaptureDetailedProfiling)
			{
				PacketProfiler.LogDetailedInbound((Type)24, NetworkableId.EmptyId, (string)null, (int)((Stream)(object)message.read).Length, (byte[])null, Epoch.Current, false, "");
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void SendWorldData(Connection connection)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		if (connection.hasRequestedWorld)
		{
			DebugEx.LogWarning((object)$"{connection} requested world data more than once", (StackTraceLogType)0);
			return;
		}
		connection.hasRequestedWorld = true;
		WorldSerialization serialization = World.Serialization;
		WorldMessage data = Pool.Get<WorldMessage>();
		for (int i = 0; i < serialization.world.prefabs.Count; i++)
		{
			if (data.prefabs != null && data.prefabs.Count >= 100)
			{
				data.status = (MessageType)2;
				SendWorldData(connection, ref data);
				data = Pool.Get<WorldMessage>();
			}
			if (data.prefabs == null)
			{
				data.prefabs = Pool.Get<List<PrefabData>>();
			}
			data.prefabs.Add(serialization.world.prefabs[i]);
		}
		for (int j = 0; j < serialization.world.paths.Count; j++)
		{
			if (data.paths != null && data.paths.Count >= 10)
			{
				data.status = (MessageType)2;
				SendWorldData(connection, ref data);
				data = Pool.Get<WorldMessage>();
			}
			if (data.paths == null)
			{
				data.paths = Pool.Get<List<PathData>>();
			}
			data.paths.Add(serialization.world.paths[j]);
		}
		if (data != null)
		{
			data.status = (MessageType)3;
			SendWorldData(connection, ref data);
		}
	}

	private static void SendWorldData(Connection connection, ref WorldMessage data)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
		obj.PacketID((Type)24);
		obj.Proto<WorldMessage>(data);
		obj.Send(new SendInfo(connection));
		if (data.prefabs != null)
		{
			data.prefabs.Clear();
		}
		if (data.paths != null)
		{
			data.paths.Clear();
		}
		data.Dispose();
		data = null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using ConVar;
using Rust;
using UnityEngine;
using UnityEngine.Networking;

public class WorldSetup : SingletonComponent<WorldSetup>
{
	public bool AutomaticallySetup;

	public bool BypassProceduralSpawn;

	public bool ForceGenerateOceanPatrols;

	public GameObject terrain;

	public GameObject decorPrefab;

	public GameObject grassPrefab;

	public GameObject spawnPrefab;

	private TerrainMeta terrainMeta;

	public uint EditorSeed;

	public uint EditorSalt;

	public uint EditorSize;

	public string EditorUrl = string.Empty;

	public string EditorConfigFile = string.Empty;

	[TextArea]
	public string EditorConfigString = string.Empty;

	public List<ProceduralObject> ProceduralObjects = new List<ProceduralObject>();

	internal List<MonumentNode> MonumentNodes = new List<MonumentNode>();

	public void OnValidate()
	{
		if ((Object)(object)terrain == (Object)null)
		{
			Terrain val = Object.FindObjectOfType<Terrain>();
			if ((Object)(object)val != (Object)null)
			{
				terrain = ((Component)val).gameObject;
			}
		}
	}

	protected override void Awake()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Expected O, but got Unknown
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		((SingletonComponent)this).Awake();
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/world", null, null, useProbabilities: false, useWorldConfig: false);
		foreach (Prefab prefab in array)
		{
			if ((Object)(object)prefab.Object.GetComponent<BaseEntity>() != (Object)null)
			{
				prefab.SpawnEntity(Vector3.zero, Quaternion.identity).Spawn();
			}
			else
			{
				prefab.Spawn(Vector3.zero, Quaternion.identity);
			}
		}
		SingletonComponent[] array2 = Object.FindObjectsOfType<SingletonComponent>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SingletonSetup();
		}
		if (Object.op_Implicit((Object)(object)terrain))
		{
			if (Object.op_Implicit((Object)(object)terrain.GetComponent<TerrainGenerator>()))
			{
				World.Procedural = true;
			}
			else
			{
				World.Procedural = false;
				terrainMeta = terrain.GetComponent<TerrainMeta>();
				terrainMeta.Init();
				terrainMeta.SetupComponents();
				terrainMeta.BindShaderProperties();
				terrainMeta.PostSetupComponents();
				World.InitSize(Mathf.RoundToInt(TerrainMeta.Size.x));
				CreateObject(decorPrefab);
				CreateObject(grassPrefab);
				CreateObject(spawnPrefab);
			}
		}
		World.Serialization = new WorldSerialization();
		World.Cached = false;
		World.CleanupOldFiles();
		World.SpawnedPrefabs.Clear();
		if (!string.IsNullOrEmpty(EditorConfigString))
		{
			ConVar.World.configString = EditorConfigString;
		}
		if (!string.IsNullOrEmpty(EditorConfigFile))
		{
			ConVar.World.configFile = EditorConfigFile;
		}
		if (AutomaticallySetup)
		{
			((MonoBehaviour)this).StartCoroutine(InitCoroutine());
		}
	}

	public void CreateObject(GameObject prefab)
	{
		if (!((Object)(object)prefab == (Object)null))
		{
			GameObject val = Object.Instantiate<GameObject>(prefab);
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(true);
			}
		}
	}

	public IEnumerator InitCoroutine(CancellationToken ct = default(CancellationToken))
	{
		if (World.CanLoadFromUrl())
		{
			Debug.Log((object)("Loading custom map from " + World.Url));
		}
		else
		{
			Debug.Log((object)("Generating procedural map of size " + World.Size + " with seed " + World.Seed));
		}
		World.Config = new WorldConfig();
		World.Config.LoadScriptableConfigs();
		if (!string.IsNullOrEmpty(ConVar.World.configString))
		{
			Debug.Log((object)"Loading custom world config from world.configstring convar");
			World.Config.LoadFromJsonString(ConVar.World.configString);
		}
		else if (!string.IsNullOrEmpty(ConVar.World.configFile))
		{
			string text = ConVar.Server.rootFolder + "/" + ConVar.World.configFile;
			Debug.Log((object)("Loading custom world config from world.configfile convar: " + text));
			World.Config.LoadFromJsonFile(text);
		}
		World.ResetTiming();
		ProceduralComponent[] components = ((Component)this).GetComponentsInChildren<ProceduralComponent>(true);
		int retryCount = 0;
		bool downloadedWorld = false;
		bool shouldRetry;
		do
		{
			shouldRetry = false;
			if (World.Procedural && !World.CanLoadFromDisk() && World.CanLoadFromUrl())
			{
				yield return DownloadWorld(ct);
				downloadedWorld = true;
			}
			string mapFileName = World.MapFolderName + "/" + World.MapFileName;
			Timing loadTimer = Timing.Start("Loading World");
			if (World.Procedural && !World.Cached && World.CanLoadFromDisk())
			{
				LoadingScreen.Update("LOADING WORLD");
				yield return CoroutineEx.waitForEndOfFrame;
				yield return CoroutineEx.waitForEndOfFrame;
				yield return CoroutineEx.waitForEndOfFrame;
				World.Serialization.Load(mapFileName);
				World.Cached = true;
			}
			loadTimer.End();
			if (World.Cached && 10 != World.Serialization.Version)
			{
				Debug.LogWarning((object)("World cache version mismatch: " + 10u + " != " + World.Serialization.Version));
				World.Serialization.Clear();
				World.Cached = false;
				if (World.CanLoadFromUrl())
				{
					if (retryCount != 0 || downloadedWorld || !World.Procedural || !World.CanLoadFromDisk())
					{
						goto IL_0354;
					}
					try
					{
						Debug.LogWarning((object)"Cached map had incorrect version, redownloading");
						File.Delete(mapFileName);
						retryCount++;
						shouldRetry = true;
					}
					catch (Exception arg)
					{
						Debug.LogError((object)$"Failed to delete cached map: {mapFileName}\n{arg}");
						goto IL_0354;
					}
					continue;
				}
			}
			if (World.Cached && string.IsNullOrEmpty(World.Checksum))
			{
				World.Checksum = World.Serialization.Checksum;
			}
			World.Timestamp = World.Serialization.Timestamp;
			continue;
			IL_0354:
			CancelSetup("World File Outdated: " + World.Name);
			yield break;
		}
		while (retryCount <= 1 && shouldRetry);
		if (World.Cached)
		{
			World.InitSize(World.Serialization.world.size);
		}
		if ((Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.Setup();
		}
		if (Object.op_Implicit((Object)(object)terrain))
		{
			TerrainGenerator component = terrain.GetComponent<TerrainGenerator>();
			if (Object.op_Implicit((Object)(object)component))
			{
				if (World.Cached)
				{
					int cachedHeightMapResolution = World.GetCachedHeightMapResolution();
					int cachedSplatMapResolution = World.GetCachedSplatMapResolution();
					terrain = component.CreateTerrain(cachedHeightMapResolution, cachedSplatMapResolution);
				}
				else
				{
					terrain = component.CreateTerrain();
				}
				terrainMeta = terrain.GetComponent<TerrainMeta>();
				terrainMeta.Init();
				terrainMeta.SetupComponents();
				CreateObject(decorPrefab);
				CreateObject(grassPrefab);
				CreateObject(spawnPrefab);
			}
		}
		Timing spawnTimer = Timing.Start("Spawning World");
		if (World.Cached)
		{
			LoadingScreen.Update("SPAWNING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			if (ct.IsCancellationRequested || (Object)(object)TerrainMeta.HeightMap == (Object)null)
			{
				yield break;
			}
			TerrainMeta.HeightMap.FromByteArray(World.GetMap("terrain"));
			TerrainMeta.SplatMap.FromByteArray(World.GetMap("splat"));
			TerrainMeta.BiomeMap.FromByteArray(World.GetMap("biome"));
			TerrainMeta.TopologyMap.FromByteArray(World.GetMap("topology"));
			TerrainMeta.AlphaMap.FromByteArray(World.GetMap("alpha"));
			TerrainMeta.WaterMap.FromByteArray(World.GetMap("water"));
			IEnumerator worldSpawn = World.Spawn(0.2f, LoadingScreen.Update, ct);
			while (worldSpawn.MoveNext())
			{
				if (ct.IsCancellationRequested)
				{
					yield break;
				}
				yield return worldSpawn.Current;
			}
			TerrainMeta.Path.Clear();
			TerrainMeta.Path.Roads.AddRange(World.GetPaths("Road"));
			TerrainMeta.Path.AddRoad(TerrainMeta.Path.Roads, addToMaster: false);
			TerrainMeta.Path.Rivers.AddRange(World.GetPaths("River"));
			TerrainMeta.Path.Powerlines.AddRange(World.GetPaths("Powerline"));
			TerrainMeta.Path.Rails.AddRange(World.GetPaths("Rail"));
		}
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (DungeonBaseLink dungeonBaseLink in TerrainMeta.Path.DungeonBaseLinks)
			{
				if ((Object)(object)dungeonBaseLink != (Object)null)
				{
					dungeonBaseLink.Initialize();
				}
			}
		}
		spawnTimer.End();
		Timing loadPrefabsTimer = Timing.Start("Loading Monument Prefabs");
		if (!World.Cached && World.Procedural)
		{
			FileSystemBackend backend = FileSystem.Backend;
			AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
			if (assetBundleBackend != null)
			{
				List<string> requiredAssetScenes = AssetSceneManifest.Current.MonumentScenes;
				IEnumerator worldSpawn = assetBundleBackend.LoadAssetScenes(requiredAssetScenes);
				bool wantsCancel = false;
				float lastProgress = 0f;
				while (worldSpawn.MoveNext())
				{
					if (!wantsCancel && ct.IsCancellationRequested)
					{
						wantsCancel = true;
						Debug.LogWarning((object)"Cancel was requested but must wait for asset scenes to finish loading");
					}
					float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress(requiredAssetScenes);
					if (!Mathf.Approximately(assetSceneProgress, lastProgress))
					{
						lastProgress = assetSceneProgress;
						LoadingScreen.Update($"Loading Monument Prefabs {assetSceneProgress * 100f:0.0}%");
					}
					yield return worldSpawn.Current;
				}
			}
		}
		loadPrefabsTimer.End();
		Timing procgenTimer = Timing.Start("Processing World");
		if (components.Length != 0)
		{
			for (int i = 0; i < components.Length; i++)
			{
				ProceduralComponent component2 = components[i];
				if (Object.op_Implicit((Object)(object)component2) && component2.ShouldRun())
				{
					if (ct.IsCancellationRequested)
					{
						yield break;
					}
					uint seed = (uint)(World.Seed + i);
					LoadingScreen.Update(component2.Description.ToUpper());
					yield return CoroutineEx.waitForEndOfFrame;
					yield return CoroutineEx.waitForEndOfFrame;
					yield return CoroutineEx.waitForEndOfFrame;
					Timing timing = Timing.Start(component2.Description);
					if (Object.op_Implicit((Object)(object)component2))
					{
						component2.Process(seed);
					}
					timing.End();
				}
			}
		}
		procgenTimer.End();
		Timing saveTimer = Timing.Start("Saving World");
		if (ConVar.World.cache && World.Procedural && !World.Cached)
		{
			LoadingScreen.Update("SAVING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.world.size = World.Size;
			World.AddPaths(TerrainMeta.Path.Roads);
			World.AddPaths(TerrainMeta.Path.Rivers);
			World.AddPaths(TerrainMeta.Path.Powerlines);
			World.AddPaths(TerrainMeta.Path.Rails);
			World.Serialization.Save(World.MapFolderName + "/" + World.MapFileName);
		}
		saveTimer.End();
		Timing checksumTimer = Timing.Start("Calculating Checksum");
		if (string.IsNullOrEmpty(World.Serialization.Checksum))
		{
			LoadingScreen.Update("CALCULATING CHECKSUM");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.CalculateChecksum();
		}
		checksumTimer.End();
		if (string.IsNullOrEmpty(World.Checksum))
		{
			World.Checksum = World.Serialization.Checksum;
		}
		Timing oceanTimer = Timing.Start("Ocean Patrol Paths");
		LoadingScreen.Update("OCEAN PATROL PATHS");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if ((BaseBoat.generate_paths && (Object)(object)TerrainMeta.Path != (Object)null) || ForceGenerateOceanPatrols)
		{
			TerrainMeta.Path.OceanPatrolFar = BaseBoat.GenerateOceanPatrolPath(200f);
		}
		else
		{
			Debug.Log((object)"Skipping ocean patrol paths, baseboat.generate_paths == false");
		}
		oceanTimer.End();
		Timing finalizeTimer = Timing.Start("Finalizing World");
		LoadingScreen.Update("FINALIZING WORLD");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (Object.op_Implicit((Object)(object)terrainMeta))
		{
			if (World.Procedural)
			{
				terrainMeta.BindShaderProperties();
				terrainMeta.PostSetupComponents();
			}
			TerrainMargin.Create();
		}
		finalizeTimer.End();
		Timing cleaningTimer = Timing.Start("Cleaning Up");
		LoadingScreen.Update("CLEANING UP");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		List<string> invalidAssets = FileSystem.Backend.UnloadBundles("monuments");
		FileSystemBackend backend2 = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend2 is AssetBundleBackend) ? backend2 : null);
		if (val != null)
		{
			List<string> unloadableScenes = AssetSceneManifest.Current.UnloadableScenes;
			yield return val.UnloadAssetScenes(unloadableScenes, (Action<string, Dictionary<string, GameObject>>)delegate(string sceneName, Dictionary<string, GameObject> prefabs)
			{
				foreach (var (item, _) in prefabs)
				{
					invalidAssets.Add(item);
				}
			});
		}
		foreach (string item2 in invalidAssets)
		{
			GameManager.server.preProcessed.Invalidate(item2);
			GameManifest.Invalidate(item2);
			PrefabAttribute.server.Invalidate(StringPool.Get(item2));
		}
		Resources.UnloadUnusedAssets();
		cleaningTimer.End();
		LoadingScreen.Update("DONE");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (Object.op_Implicit((Object)(object)this))
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
	}

	private IEnumerator DownloadWorld(CancellationToken ct)
	{
		if (!World.Procedural || !World.CanLoadFromUrl())
		{
			Debug.LogError((object)"Cannot download world - not procedural or no url set");
			yield break;
		}
		Timing downloadTimer = Timing.Start("Downloading World");
		LoadingScreen.Update("DOWNLOADING WORLD");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		UnityWebRequest request = UnityWebRequest.Get(World.Url);
		request.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();
		request.Send();
		float lastProgress = 0f;
		while (!request.isDone)
		{
			if (ct.IsCancellationRequested)
			{
				yield break;
			}
			float downloadProgress = request.downloadProgress;
			if (!Mathf.Approximately(downloadProgress, lastProgress))
			{
				lastProgress = downloadProgress;
				LoadingScreen.Update($"DOWNLOADING WORLD {downloadProgress * 100f:0.0}%");
			}
			yield return CoroutineEx.waitForEndOfFrame;
		}
		if (!request.isHttpError && !request.isNetworkError)
		{
			World.Serialization.Load(request.downloadHandler.data);
			World.Serialization.Save(World.MapFolderName + "/" + World.MapFileName);
			World.Cached = true;
		}
		else
		{
			CancelSetup("Couldn't Download Level: " + World.Name + " (" + request.error + ")");
		}
		downloadTimer.End();
	}

	private void CancelSetup(string msg)
	{
		Debug.LogError((object)msg);
		Application.Quit();
	}
}


using UnityEngine;

public class ApplyTerrainModifiers : MonoBehaviour
{
	protected void Awake()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		TerrainModifier[] modifiers = null;
		if (component.isServer)
		{
			modifiers = PrefabAttribute.server.FindAll<TerrainModifier>(component.prefabID);
		}
		((Component)this).transform.ApplyTerrainModifiers(modifiers);
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class TerrainCarve : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap))
		{
			TerrainMeta.AlphaMap.SetAlpha(position, 0f, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightAdd : TerrainModifier
{
	public float Delta = 1f;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			TerrainMeta.HeightMap.AddHeight(position, opacity * Delta * TerrainMeta.OneOverSize.y, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightRaise : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			TerrainMeta.HeightMap.RaiseHeight(position, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightSet : TerrainModifier
{
	public enum Mode
	{
		Set,
		Raise,
		Lower
	}

	public Mode HeightMode;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			switch (HeightMode)
			{
			case Mode.Set:
				TerrainMeta.HeightMap.SetHeight(position, opacity, radius, fade);
				break;
			case Mode.Raise:
				TerrainMeta.HeightMap.RaiseHeight(position, opacity, radius, fade);
				break;
			case Mode.Lower:
				TerrainMeta.HeightMap.LowerHeight(position, opacity, radius, fade);
				break;
			}
		}
	}
}


public enum Mode
{
	Set,
	Raise,
	Lower
}


using System;
using UnityEngine;

public abstract class TerrainModifier : PrefabAttribute
{
	public float Opacity = 1f;

	public float Radius;

	public float Fade;

	public void Apply(Vector3 pos, float scale)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		float opacity = Opacity;
		float radius = scale * Radius;
		float fade = scale * Fade;
		Apply(pos, opacity, radius, fade);
	}

	protected abstract void Apply(Vector3 position, float opacity, float radius, float fade);

	protected override Type GetIndexedType()
	{
		return typeof(TerrainModifier);
	}
}


using UnityEngine;

public static class TerrainModifierEx
{
	public static void ApplyTerrainModifiers(this Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		foreach (TerrainModifier obj in modifiers)
		{
			Vector3 val = Vector3.Scale(obj.worldPosition, scale);
			Vector3 pos2 = pos + rot * val;
			float y = scale.y;
			obj.Apply(pos2, y);
		}
	}

	public static void ApplyTerrainModifiers(this Transform transform, TerrainModifier[] modifiers)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		transform.ApplyTerrainModifiers(modifiers, transform.position, transform.rotation, transform.lossyScale);
	}
}


using UnityEngine;

public class TerrainPlacementBlocked : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.PlacementMap))
		{
			TerrainMeta.PlacementMap.SetBlocked(position, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainSplatRemove : TerrainModifier
{
	public Enum SplatType;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) && !TerrainMeta.TopologyMap.GetTopology(position, 8388608))
		{
			TerrainMeta.SplatMap.RemoveSplat(position, (int)SplatType, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainSplatSet : TerrainModifier
{
	public Enum SplatType;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap))
		{
			TerrainMeta.SplatMap.SetSplat(position, (int)SplatType, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainTopologyAdd : TerrainModifier
{
	[InspectorFlags]
	public Enum TopologyType = (Enum)512;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			TerrainMeta.TopologyMap.AddTopology(position, (int)TopologyType, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainTopologySet : TerrainModifier
{
	[InspectorFlags]
	public Enum TopologyType = (Enum)512;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			TerrainMeta.TopologyMap.SetTopology(position, (int)TopologyType, radius, fade);
		}
	}
}


using UnityEngine;

public class Monument : TerrainPlacement
{
	public float Radius;

	public float Fade = 10f;

	public bool AutoCliffSplat = true;

	public bool AutoCliffTopology = true;

	public bool RemoveExistingTopology;

	protected void OnDrawGizmosSelected()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, Radius);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, Radius - Fade);
	}

	protected override void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool useBlendMap = blendmap.isValid;
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData blenddata = new TextureData(useBlendMap ? blendmap.Get() : null);
		float num = (useBlendMap ? extents.x : Radius);
		float num2 = (useBlendMap ? extents.z : Radius);
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - num, 0f, 0f - num2));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(num, 0f, 0f - num2));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - num, 0f, num2));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(num, 0f, num2));
		TerrainMeta.HeightMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.HeightMap.Coordinate(z);
			float normX = TerrainMeta.HeightMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num3 = 1f;
			num3 = ((!useBlendMap) ? Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2)) : blenddata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z).w);
			if (num3 != 0f)
			{
				int num4 = Mathx.Min(x, z, TerrainMeta.HeightMap.res - 1 - x, TerrainMeta.HeightMap.res - 1 - z);
				if (num4 < 10)
				{
					num3 *= Mathf.SmoothStep(0f, 1f, Mathf.InverseLerp(0f, 10f, (float)num4));
				}
				if (num3 != 0f)
				{
					float num5 = TerrainMeta.NormalizeY(position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y);
					num5 = Mathf.SmoothStep(TerrainMeta.HeightMap.GetHeight01(x, z), num5, num3);
					TerrainMeta.HeightMap.SetHeight(x, z, num5);
				}
			}
		});
	}

	protected override void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool should0 = ShouldSplat(1);
		bool should1 = ShouldSplat(2);
		bool should2 = ShouldSplat(4);
		bool should3 = ShouldSplat(8);
		bool should4 = ShouldSplat(16);
		bool should5 = ShouldSplat(32);
		bool should6 = ShouldSplat(64);
		bool should7 = ShouldSplat(128);
		if (!should0 && !should1 && !should2 && !should3 && !should4 && !should5 && !should6 && !should7)
		{
			return;
		}
		TextureData splat0data = new TextureData(splatmap0.Get());
		TextureData splat1data = new TextureData(splatmap1.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.SplatMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
			if (AutoCliffSplat)
			{
				GenerateCliffSplat.Process(x, z);
			}
			float normZ = TerrainMeta.SplatMap.Coordinate(z);
			float normX = TerrainMeta.SplatMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				Vector4 interpolatedVector = splat0data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				Vector4 interpolatedVector2 = splat1data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				if (!should0)
				{
					interpolatedVector.x = 0f;
				}
				if (!should1)
				{
					interpolatedVector.y = 0f;
				}
				if (!should2)
				{
					interpolatedVector.z = 0f;
				}
				if (!should3)
				{
					interpolatedVector.w = 0f;
				}
				if (!should4)
				{
					interpolatedVector2.x = 0f;
				}
				if (!should5)
				{
					interpolatedVector2.y = 0f;
				}
				if (!should6)
				{
					interpolatedVector2.z = 0f;
				}
				if (!should7)
				{
					interpolatedVector2.w = 0f;
				}
				TerrainMeta.SplatMap.SetSplatRaw(x, z, interpolatedVector, interpolatedVector2, num);
			}
		});
	}

	protected override void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		TextureData alphadata = new TextureData(alphamap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.AlphaMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.AlphaMap.Coordinate(z);
			float normX = TerrainMeta.AlphaMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				float w = alphadata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z).w;
				TerrainMeta.AlphaMap.SetAlpha(x, z, w, num);
			}
		});
	}

	protected override void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool should0 = ShouldBiome(1);
		bool should1 = ShouldBiome(2);
		bool should2 = ShouldBiome(4);
		bool should3 = ShouldBiome(8);
		bool should4 = ShouldBiome(16);
		if (!should0 && !should1 && !should2 && !should3 && !should4)
		{
			return;
		}
		TextureData biomedata = new TextureData(biomemap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.BiomeMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.BiomeMap.Coordinate(z);
			float normX = TerrainMeta.BiomeMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				Vector4 interpolatedVector = biomedata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				float num2 = interpolatedVector.x;
				float num3 = interpolatedVector.y;
				float num4 = interpolatedVector.z;
				float num5 = interpolatedVector.w;
				float biome = 1f - num2 - num3 - num4 - num5;
				if (!should0)
				{
					num2 = 0f;
				}
				if (!should1)
				{
					num3 = 0f;
				}
				if (!should2)
				{
					num4 = 0f;
				}
				if (!should3)
				{
					num5 = 0f;
				}
				if (!should4)
				{
					biome = 0f;
				}
				TerrainMeta.BiomeMap.SetBiomeRaw(x, z, num2, num3, num4, num5, biome, num);
			}
		});
	}

	protected override void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		TextureData topologydata = new TextureData(topologymap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.TopologyMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Expected I4, but got Unknown
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Expected I4, but got Unknown
			float normZ = TerrainMeta.TopologyMap.Coordinate(z);
			float normX = TerrainMeta.TopologyMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			int interpolatedInt = topologydata.GetInterpolatedInt((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
			bool num = ShouldTopology(interpolatedInt);
			if (num && RemoveExistingTopology)
			{
				TerrainMeta.TopologyMap.RemoveTopology(x, z, (int)TopologyMask);
			}
			if (AutoCliffTopology)
			{
				GenerateCliffTopology.Process(x, z);
			}
			if (num)
			{
				TerrainMeta.TopologyMap.AddTopology(x, z, interpolatedInt & TopologyMask);
			}
		});
	}

	protected override void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}
}


using UnityEngine;

public class Mountain : TerrainPlacement
{
	public float Fade = 10f;

	public bool AutoCliffSplat;

	public bool AutoCliffTopology = true;

	protected void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.up * (0.5f * Fade);
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		Gizmos.DrawCube(((Component)this).transform.position + val, new Vector3(size.x, Fade, size.z));
		Gizmos.DrawWireCube(((Component)this).transform.position + val, new Vector3(size.x, Fade, size.z));
	}

	protected override void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.HeightMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.HeightMap.Coordinate(z);
			float normX = TerrainMeta.HeightMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				float num3 = TerrainMeta.NormalizeY(num);
				num3 = Mathx.SmoothMax(TerrainMeta.HeightMap.GetHeight01(x, z), num3, 0.1f);
				TerrainMeta.HeightMap.SetHeight(x, z, num3, num2);
			}
		});
	}

	protected override void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		bool should0 = ShouldSplat(1);
		bool should1 = ShouldSplat(2);
		bool should2 = ShouldSplat(4);
		bool should3 = ShouldSplat(8);
		bool should4 = ShouldSplat(16);
		bool should5 = ShouldSplat(32);
		bool should6 = ShouldSplat(64);
		bool should7 = ShouldSplat(128);
		if (!should0 && !should1 && !should2 && !should3 && !should4 && !should5 && !should6 && !should7)
		{
			return;
		}
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData splat0data = new TextureData(splatmap0.Get());
		TextureData splat1data = new TextureData(splatmap1.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.SplatMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0282: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			if (AutoCliffSplat)
			{
				GenerateCliffSplat.Process(x, z);
			}
			float normZ = TerrainMeta.SplatMap.Coordinate(z);
			float normX = TerrainMeta.SplatMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				Vector4 interpolatedVector = splat0data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				Vector4 interpolatedVector2 = splat1data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				if (!should0)
				{
					interpolatedVector.x = 0f;
				}
				if (!should1)
				{
					interpolatedVector.y = 0f;
				}
				if (!should2)
				{
					interpolatedVector.z = 0f;
				}
				if (!should3)
				{
					interpolatedVector.w = 0f;
				}
				if (!should4)
				{
					interpolatedVector2.x = 0f;
				}
				if (!should5)
				{
					interpolatedVector2.y = 0f;
				}
				if (!should6)
				{
					interpolatedVector2.z = 0f;
				}
				if (!should7)
				{
					interpolatedVector2.w = 0f;
				}
				TerrainMeta.SplatMap.SetSplatRaw(x, z, interpolatedVector, interpolatedVector2, num2);
			}
		});
	}

	protected override void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}

	protected override void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		bool should0 = ShouldBiome(1);
		bool should1 = ShouldBiome(2);
		bool should2 = ShouldBiome(4);
		bool should3 = ShouldBiome(8);
		bool should4 = ShouldBiome(16);
		if (!should0 && !should1 && !should2 && !should3 && !should4)
		{
			return;
		}
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData biomedata = new TextureData(biomemap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.BiomeMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.BiomeMap.Coordinate(z);
			float normX = TerrainMeta.BiomeMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				Vector4 interpolatedVector = biomedata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				float num3 = interpolatedVector.x;
				float num4 = interpolatedVector.y;
				float num5 = interpolatedVector.z;
				float num6 = interpolatedVector.w;
				float biome = 1f - num3 - num4 - num5 - num6;
				if (!should0)
				{
					num3 = 0f;
				}
				if (!should1)
				{
					num4 = 0f;
				}
				if (!should2)
				{
					num5 = 0f;
				}
				if (!should3)
				{
					num6 = 0f;
				}
				if (!should4)
				{
					biome = 0f;
				}
				TerrainMeta.BiomeMap.SetBiomeRaw(x, z, num3, num4, num5, num6, biome, num2);
			}
		});
	}

	protected override void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		TextureData topologydata = new TextureData(topologymap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.TopologyMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Expected I4, but got Unknown
			if (AutoCliffTopology)
			{
				GenerateCliffTopology.Process(x, z);
			}
			float normZ = TerrainMeta.TopologyMap.Coordinate(z);
			float normX = TerrainMeta.TopologyMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			int interpolatedInt = topologydata.GetInterpolatedInt((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
			if (ShouldTopology(interpolatedInt))
			{
				TerrainMeta.TopologyMap.AddTopology(x, z, interpolatedInt & TopologyMask);
			}
		});
	}

	protected override void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}
}


using System;
using UnityEngine;

public abstract class TerrainPlacement : PrefabAttribute
{
	[ReadOnly]
	public Vector3 size = Vector3.zero;

	[ReadOnly]
	public Vector3 extents = Vector3.zero;

	[ReadOnly]
	public Vector3 offset = Vector3.zero;

	public bool HeightMap = true;

	public bool AlphaMap = true;

	public bool WaterMap;

	[InspectorFlags]
	public Enum SplatMask;

	[InspectorFlags]
	public Enum BiomeMask;

	[InspectorFlags]
	public Enum TopologyMask;

	[HideInInspector]
	public Texture2DRef heightmap;

	[HideInInspector]
	public Texture2DRef splatmap0;

	[HideInInspector]
	public Texture2DRef splatmap1;

	[HideInInspector]
	public Texture2DRef alphamap;

	[HideInInspector]
	public Texture2DRef biomemap;

	[HideInInspector]
	public Texture2DRef topologymap;

	[HideInInspector]
	public Texture2DRef watermap;

	[HideInInspector]
	public Texture2DRef blendmap;

	public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (ShouldHeight())
		{
			ApplyHeight(localToWorld, worldToLocal);
		}
		if (ShouldSplat())
		{
			ApplySplat(localToWorld, worldToLocal);
		}
		if (ShouldAlpha())
		{
			ApplyAlpha(localToWorld, worldToLocal);
		}
		if (ShouldBiome())
		{
			ApplyBiome(localToWorld, worldToLocal);
		}
		if (ShouldTopology())
		{
			ApplyTopology(localToWorld, worldToLocal);
		}
		if (ShouldWater())
		{
			ApplyWater(localToWorld, worldToLocal);
		}
	}

	protected bool ShouldHeight()
	{
		if (heightmap.isValid)
		{
			return HeightMap;
		}
		return false;
	}

	protected bool ShouldSplat(int id = -1)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Invalid comparison between Unknown and I4
		if (splatmap0.isValid && splatmap1.isValid)
		{
			return (SplatMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldAlpha()
	{
		if (alphamap.isValid)
		{
			return AlphaMap;
		}
		return false;
	}

	protected bool ShouldBiome(int id = -1)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (biomemap.isValid)
		{
			return (BiomeMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldTopology(int id = -1)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (topologymap.isValid)
		{
			return (TopologyMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldWater()
	{
		if (watermap.isValid)
		{
			return WaterMap;
		}
		return false;
	}

	protected abstract void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected override Type GetIndexedType()
	{
		return typeof(TerrainPlacement);
	}
}


using UnityEngine;

public static class TerrainPlacementEx
{
	public static void ApplyTerrainPlacements(this Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (placements.Length != 0)
		{
			for (int i = 0; i < placements.Length; i++)
			{
				TerrainPlacement terrainPlacement = placements[i];
				Vector3 val = pos + rot * Vector3.Scale(terrainPlacement.worldPosition, scale);
				Quaternion val2 = rot * terrainPlacement.worldRotation;
				Matrix4x4 localToWorld = Matrix4x4.TRS(val, val2, scale);
				Matrix4x4 inverse = ((Matrix4x4)(ref localToWorld)).inverse;
				placements[i].Apply(localToWorld, inverse);
			}
		}
	}

	public static void ApplyTerrainPlacements(this Transform transform, TerrainPlacement[] placements)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		transform.ApplyTerrainPlacements(placements, transform.position, transform.rotation, transform.lossyScale);
	}
}


using System.IO;
using Rust.Water5;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ocean Settings", menuName = "Water5/Ocean Settings")]
public class OceanSettings : ScriptableObject
{
	[Header("Compute Shaders")]
	public ComputeShader waveSpectrumCompute;

	public ComputeShader fftCompute;

	public ComputeShader waveMergeCompute;

	public ComputeShader waveInitialSpectrum;

	[Header("Global Ocean Params")]
	public float[] octaveScales;

	public float lamda;

	public float windDirection;

	public float distanceAttenuationFactor;

	public float depthAttenuationFactor;

	[Header("Ocean Spectra")]
	public OceanSpectrumSettings[] spectrumSettings;

	[HideInInspector]
	public float[] spectrumRanges;

	public unsafe OceanDisplacementShort3[,,] LoadSimData()
	{
		OceanDisplacementShort3[,,] array = new OceanDisplacementShort3[spectrumSettings.Length, 72, 65536];
		string path = Application.streamingAssetsPath + "/" + ((Object)this).name + ".physicsdata.dat";
		if (!File.Exists(path))
		{
			Debug.Log((object)"Simulation Data not found");
			return array;
		}
		byte[] array2 = File.ReadAllBytes(path);
		fixed (byte* ptr2 = array2)
		{
			fixed (OceanDisplacementShort3* ptr = array)
			{
				UnsafeUtility.MemCpy((void*)ptr, (void*)ptr2, (long)array2.Length);
			}
		}
		return array;
	}

	internal unsafe NativeOceanDisplacementShort3 LoadNativeSimData()
	{
		NativeOceanDisplacementShort3 result = NativeOceanDisplacementShort3.Create(spectrumSettings.Length, 72, 65536);
		string path = Application.streamingAssetsPath + "/" + ((Object)this).name + ".physicsdata.dat";
		if (!File.Exists(path))
		{
			Debug.Log((object)"Simulation Data not found");
			return result;
		}
		byte[] array = File.ReadAllBytes(path);
		OceanDisplacementShort3* unsafePtr = result.GetUnsafePtr();
		fixed (byte* ptr = array)
		{
			UnsafeUtility.MemCpy((void*)unsafePtr, (void*)ptr, (long)array.Length);
		}
		return result;
	}
}


using UnityEngine;

[CreateAssetMenu(fileName = "New Ocean Variant Material", menuName = "Water5/Ocean Variant Material")]
public class OceanVariantMaterial : ScriptableObject
{
	public Color color;

	public Color specColor;

	public float smoothness;

	public Color waterColor;

	public Color waterExtinction;

	public float scatteringCoefficient;

	public Color subSurfaceColor;

	public float subSurfaceAmount;

	public float fadeInEnd;

	public float fadeInBegin;
}


public enum WaterBodyType
{
	Ocean = 1,
	River = 2,
	Lake = 4,
	Pool = 8,
	Moonpool = 0x10,
	Radioactive = 0x20
}


using System;
using UnityEngine;

[ExecuteInEditMode]
public class WaterBody : MonoBehaviour
{
	[Flags]
	public enum FishingTag
	{
		MoonPool = 1,
		River = 2,
		Ocean = 4,
		Swamp = 8
	}

	public WaterBodyType Type = WaterBodyType.Lake;

	public Renderer Renderer;

	public Collider[] Triggers;

	public bool IsOcean;

	public FishingTag FishingType;

	public Transform Transform { get; private set; }

	private void Awake()
	{
		Transform = ((Component)this).transform;
	}

	private void OnEnable()
	{
		WaterSystem.RegisterBody(this);
	}

	private void OnDisable()
	{
		WaterSystem.UnregisterBody(this);
	}

	public void OnOceanLevelChanged(float newLevel)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOcean || Triggers == null || Triggers.Length == 0)
		{
			return;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				Vector3 position = ((Component)val).transform.position;
				position.y = newLevel;
				((Component)val).transform.position = position;
			}
		}
	}

	public float MinWaterLevel()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.position.y;
		if (Triggers == null || Triggers.Length == 0)
		{
			return num;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				float num2 = num;
				Bounds bounds = val.bounds;
				num = Mathf.Min(num2, ((Bounds)(ref bounds)).max.y);
			}
		}
		return num;
	}

	public float SqrDistance(Vector3 point)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Triggers == null || Triggers.Length == 0)
		{
			return num;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				MeshCollider val2 = (MeshCollider)(object)((val is MeshCollider) ? val : null);
				Vector3 val3;
				if ((Object)(object)val2 == (Object)null || val2.convex)
				{
					float num2 = num;
					val3 = val.ClosestPoint(point) - point;
					num = Mathf.Min(num2, ((Vector3)(ref val3)).sqrMagnitude);
				}
				else
				{
					float num3 = num;
					val3 = val.ClosestPointOnBounds(point) - point;
					num = Mathf.Min(num3, ((Vector3)(ref val3)).sqrMagnitude);
				}
			}
		}
		return num;
	}

	public int GetTopologyMask()
	{
		return Type switch
		{
			WaterBodyType.Lake => 65536, 
			WaterBodyType.Ocean => 128, 
			WaterBodyType.River => 16384, 
			WaterBodyType.Moonpool => 128, 
			WaterBodyType.Pool => 65536, 
			_ => 65536, 
		};
	}
}


using System;

[Flags]
public enum FishingTag
{
	MoonPool = 1,
	River = 2,
	Ocean = 4,
	Swamp = 8
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(PostOpaqueDepth))]
public class WaterCamera : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public class WaterCollision : MonoBehaviour
{
	private ListDictionary<Collider, List<Collider>> ignoredColliders;

	private HashSet<Collider> waterColliders;

	private WaterVisibilityGrid visibilityGrid;

	public const float IgnoreRadius = 0.01f;

	private NativeList<int> indicesToCheck;

	public WaterVisibilityGrid VisibilityGrid => visibilityGrid;

	public void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		waterColliders = new HashSet<Collider>();
		if (visibilityGrid != null)
		{
			visibilityGrid.Dispose();
		}
		visibilityGrid = new WaterVisibilityGrid();
	}

	private void OnDestroy()
	{
		visibilityGrid?.Dispose();
		NativeListEx.SafeDispose(ref indicesToCheck);
	}

	public void Clear()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (waterColliders.Count == 0)
		{
			return;
		}
		HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
		while (enumerator.MoveNext())
		{
			Enumerator<Collider> enumerator2 = ignoredColliders.Keys.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					Physics.IgnoreCollision(enumerator2.Current, enumerator.Current, false);
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if (waterColliders.Count != 0 && Object.op_Implicit((Object)(object)collider))
		{
			HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Physics.IgnoreCollision(collider, enumerator.Current, false);
			}
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(pos, radius))
		{
			return false;
		}
		return GamePhysics.CheckSphere<WaterVisibilityTrigger>(pos, radius, 262144, (QueryTriggerInteraction)2);
	}

	private void PrepareIndiciesToCheckList(int length)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!indicesToCheck.IsCreated)
		{
			indicesToCheck = new NativeList<int>(length, AllocatorHandle.op_Implicit((Allocator)4));
			return;
		}
		if (length > indicesToCheck.Capacity)
		{
			indicesToCheck.Capacity = length;
		}
		indicesToCheck.Clear();
	}

	public void GetIgnore(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnore", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			PrepareIndiciesToCheckList(positions.Length);
			JobHandle val2;
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.Check(positions, radii, indicesToCheck);
			}
			else
			{
				GenerateAscSeqListJob generateAscSeqListJob = default(GenerateAscSeqListJob);
				generateAscSeqListJob.Values = indicesToCheck;
				generateAscSeqListJob.Start = 0;
				generateAscSeqListJob.Step = 1;
				generateAscSeqListJob.Count = positions.Length;
				val2 = IJobExtensions.Schedule<GenerateAscSeqListJob>(generateAscSeqListJob, default(JobHandle));
			}
			((JobHandle)(ref val2)).Complete();
			if (!indicesToCheck.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = positions;
				gatherJob.Indices = indicesToCheck.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = indicesToCheck.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				GamePhysics.CheckSpheres<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref results), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				Span<bool> values2 = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val3 = indicesToCheck.AsReadOnly();
				CollectionUtil.ScatterOutInplace(values2, ReadOnly<int>.op_Implicit(ref val3), defValue: false);
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetIgnoreIndirect(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> indices, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnoreIndirect", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			PrepareIndiciesToCheckList(indices.Length);
			JobHandle val2 = default(JobHandle);
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.CheckIndirect(pos, radii, indices, indicesToCheck);
			}
			else
			{
				indicesToCheck.CopyFrom(in indices);
			}
			((JobHandle)(ref val2)).Complete();
			if (!indicesToCheck.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = pos;
				gatherJob.Indices = indicesToCheck.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = indicesToCheck.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				NativeArray<bool> val3 = default(NativeArray<bool>);
				val3..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GamePhysics.CheckSpheres<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref val3), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				ReadOnlySpan<bool> from = NativeArray<bool>.op_Implicit(ref val3);
				Span<bool> to = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = indicesToCheck.AsReadOnly();
				CollectionUtil.ScatterTo(from, to, ReadOnly<int>.op_Implicit(ref val4));
				val3.Dispose();
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(Bounds bounds)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(bounds))
		{
			return false;
		}
		return GamePhysics.CheckBounds<WaterVisibilityTrigger>(bounds, 262144, (QueryTriggerInteraction)2);
	}

	public bool GetIgnore(Vector3 start, Vector3 end, float radius)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(start, end, radius))
		{
			return false;
		}
		return GamePhysics.CheckCapsule<WaterVisibilityTrigger>(start, end, radius, 262144, (QueryTriggerInteraction)2);
	}

	public void GetIgnoreIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnoreIndirect", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			PrepareIndiciesToCheckList(indices.Length);
			JobHandle val2 = default(JobHandle);
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.CheckIndirect(starts, ends, radii, indices, indicesToCheck);
			}
			else
			{
				indicesToCheck.CopyFrom(in indices);
			}
			((JobHandle)(ref val2)).Complete();
			if (!indicesToCheck.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = starts;
				gatherJob.Indices = indicesToCheck.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<Vector3> results3 = default(NativeArray<Vector3>);
				results3..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results3;
				gatherJob.Source = ends;
				gatherJob.Indices = indicesToCheck.AsReadOnly();
				GatherJob<Vector3> gatherJob3 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob3);
				NativeArray<float> results4 = default(NativeArray<float>);
				results4..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob4 = default(GatherJob<float>);
				gatherJob4.Results = results4;
				gatherJob4.Source = radii;
				gatherJob4.Indices = indicesToCheck.AsReadOnly();
				GatherJob<float> gatherJob5 = gatherJob4;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob5);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				NativeArray<bool> val3 = default(NativeArray<bool>);
				val3..ctor(indicesToCheck.Length, (Allocator)3, (NativeArrayOptions)0);
				GamePhysics.CheckCapsules<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), results4.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref val3), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None, mitigateSpheres: true);
				ReadOnlySpan<bool> from = NativeArray<bool>.op_Implicit(ref val3);
				Span<bool> to = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = indicesToCheck.AsReadOnly();
				CollectionUtil.ScatterTo(from, to, ReadOnly<int>.op_Implicit(ref val4));
				val3.Dispose();
				values.Dispose();
				results4.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(RaycastHit hit)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (waterColliders.Contains(((RaycastHit)(ref hit)).collider))
		{
			return GetIgnore(((RaycastHit)(ref hit)).point);
		}
		return false;
	}

	public bool GetIgnore(Collider collider)
	{
		if (waterColliders.Count == 0 || !Object.op_Implicit((Object)(object)collider))
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (waterColliders.Count == 0 || !Object.op_Implicit((Object)(object)collider))
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> list = new List<Collider> { trigger };
				HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Physics.IgnoreCollision(collider, enumerator.Current, true);
				}
				ignoredColliders.Add(collider, list);
			}
			return;
		}
		List<Collider> list2 = ignoredColliders[collider];
		if (ignore)
		{
			if (!list2.Contains(trigger))
			{
				list2.Add(trigger);
			}
		}
		else if (list2.Contains(trigger))
		{
			list2.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if ((Object)(object)key == (Object)null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Physics.IgnoreCollision(key, enumerator.Current, false);
				}
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class WaterCullingVolume : MonoBehaviour
{
	public bool isDynamic;
}


using UnityEngine;

public class WaterDepthMask : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class WaterInteraction : MonoBehaviour
{
	[SerializeField]
	private Texture2D texture;

	[Range(0f, 1f)]
	public float Displacement = 1f;

	[Range(0f, 1f)]
	public float Disturbance = 0.5f;
}


public enum WaterQuality
{
	Low,
	Medium,
	High
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Water5;
using TerrainWaterMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using WaterSystemJobs;

[ExecuteInEditMode]
public class WaterSystem : MonoBehaviour
{
	[Serializable]
	public class RenderingSettings
	{
		[Serializable]
		public class SkyProbe
		{
			public float ProbeUpdateInterval = 1f;

			public bool TimeSlicing = true;
		}

		[Serializable]
		public class SSR
		{
			public float FresnelCutoff = 0.02f;

			public float ThicknessMin = 1f;

			public float ThicknessMax = 20f;

			public float ThicknessStartDist = 40f;

			public float ThicknessEndDist = 100f;
		}

		public Vector4[] TessellationQuality;

		public SkyProbe SkyReflections;

		public SSR ScreenSpaceReflections;
	}

	private struct OceanSimulationWrapper : IDisposable
	{
		internal OceanSimulation mainlandSimulation;

		internal OceanSimulation deepSeaSimulation;

		internal static OceanSimulationWrapper Init(OceanSettings mainland, OceanSettings deepsea)
		{
			OceanSimulationWrapper result = default(OceanSimulationWrapper);
			result.mainlandSimulation = new OceanSimulation(mainland);
			result.deepSeaSimulation = new OceanSimulation(deepsea);
			return result;
		}

		public OceanSimulation GetOceanSimulation(Vector3 worldPosition)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			if (!DeepSeaManager.IsInsideDeepSea(worldPosition))
			{
				return mainlandSimulation;
			}
			return deepSeaSimulation;
		}

		public OceanSimulation GetOceanSimulation(bool isDeepSea)
		{
			if (!isDeepSea)
			{
				return mainlandSimulation;
			}
			return deepSeaSimulation;
		}

		public void Dispose()
		{
			mainlandSimulation?.Dispose();
			deepSeaSimulation?.Dispose();
		}
	}

	private static float oceanLevel = 0f;

	[Header("Ocean Settings")]
	public OceanSettings oceanSettings;

	private OceanSimulationWrapper oceanSimulationWrapper;

	public WaterQuality Quality = WaterQuality.High;

	public Material oceanMaterial;

	public RenderingSettings Rendering = new RenderingSettings();

	public ComputeShader oceanVFaceShader;

	public OceanVariantMaterial TropicalMaterial;

	public int patchSize = 100;

	public int patchCount = 4;

	public float patchScale = 1f;

	public bool forceDeepSea;

	public static WaterSystem Instance { get; private set; }

	public static WaterCollision Collision { get; private set; }

	public static WaterBody Ocean { get; private set; }

	public static Material OceanMaterial => Instance?.oceanMaterial;

	public static ListHashSet<WaterCamera> WaterCameras { get; } = new ListHashSet<WaterCamera>();

	public static HashSet<WaterBody> WaterBodies { get; } = new HashSet<WaterBody>();

	public static HashSet<WaterDepthMask> DepthMasks { get; } = new HashSet<WaterDepthMask>();

	public static float WaveTime { get; private set; }

	public static ComputeShader OceanVFaceShader => Instance?.oceanVFaceShader;

	public static bool SuspendProcessing => false;

	public static float OceanLevel
	{
		get
		{
			return oceanLevel;
		}
		set
		{
			value = Mathf.Max(value, 0f);
			if (!Mathf.Approximately(oceanLevel, value))
			{
				oceanLevel = value;
				UpdateOceanLevel();
			}
		}
	}

	public bool IsInitialized { get; private set; }

	public int Layer => ((Component)this).gameObject.layer;

	public int Reflections => Water.reflections;

	public float WindDirection => oceanSettings.windDirection;

	public float[] OctaveScales => oceanSettings.octaveScales;

	public OceanSimulation GetOceanSimulation(Vector3 worldPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return oceanSimulationWrapper.GetOceanSimulation(worldPosition);
	}

	public OceanSimulation GetOceanSimulation(bool isDeep)
	{
		return oceanSimulationWrapper.GetOceanSimulation(isDeep);
	}

	private void CheckInstance()
	{
		Instance = (((Object)(object)Instance != (Object)null) ? Instance : this);
		Collision = (((Object)(object)Collision != (Object)null) ? Collision : ((Component)this).GetComponent<WaterCollision>());
	}

	private void Awake()
	{
		CheckInstance();
	}

	private void OnEnable()
	{
		CheckInstance();
		oceanSimulationWrapper = OceanSimulationWrapper.Init(oceanSettings, oceanSettings);
		IsInitialized = true;
	}

	private void OnDisable()
	{
		if (!Application.isPlaying || !Application.isQuitting)
		{
			oceanSimulationWrapper.Dispose();
			oceanSimulationWrapper = default(OceanSimulationWrapper);
			IsInitialized = false;
			Instance = null;
		}
	}

	private void Update()
	{
		if (SuspendProcessing)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateWaves", 0);
		try
		{
			UpdateOceanSimulation();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Trace(Ray ray, out Vector3 position, float maxDist = 100f)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			position = Vector3.zero;
			return false;
		}
		if (Instance.GetOceanSimulation(((Ray)(ref ray)).origin).Trace(ray, maxDist, out position) && TerrainMeta.TopologyMap.GetTopology(position, 384))
		{
			return true;
		}
		return false;
	}

	public static bool Trace(Ray ray, out Vector3 position, out Vector3 normal, float maxDist = 100f)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			position = Vector3.zero;
			normal = Vector3.zero;
			return false;
		}
		normal = Vector3.up;
		if (Instance.GetOceanSimulation(((Ray)(ref ray)).origin).Trace(ray, maxDist, out position) && TerrainMeta.TopologyMap.GetTopology(position, 384))
		{
			return true;
		}
		return false;
	}

	public static JobHandle ScheduleTraceBatchDefer(NativeList<Ray> rays, NativeArray<float> maxDists, NativeArray<bool> hitResults, NativeArray<Vector3> hitPositions, NativeArray<Vector3> hitNormals, NativeList<int> deepIndices, NativeList<int> mainIndices, JobHandle inputDeps)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			FillFalseJobDefer fillFalseJobDefer = default(FillFalseJobDefer);
			fillFalseJobDefer.rays = rays;
			fillFalseJobDefer.HitResults = hitResults;
			inputDeps = IJobParallelForDeferExtensions.Schedule<FillFalseJobDefer, Ray>(fillFalseJobDefer, rays, 256, inputDeps);
			return inputDeps;
		}
		NativeArray<Ray> rays2 = rays.AsDeferredJobArray();
		inputDeps = Instance.oceanSimulationWrapper.mainlandSimulation.TraceBatch(mainIndices, rays2, maxDists, hitResults, hitPositions, inputDeps);
		inputDeps = Instance.oceanSimulationWrapper.deepSeaSimulation.TraceBatch(deepIndices, rays2, maxDists, hitResults, hitPositions, inputDeps);
		AdjustByTopologyJob adjustByTopologyJob = default(AdjustByTopologyJob);
		adjustByTopologyJob.rays = rays;
		adjustByTopologyJob.hitResults = hitResults;
		adjustByTopologyJob.hitNormals = hitNormals;
		adjustByTopologyJob.hitPositions = hitPositions.AsReadOnly();
		adjustByTopologyJob.TopologyData = TerrainMeta.TopologyMap.src;
		adjustByTopologyJob.TopologyRes = TerrainMeta.TopologyMap.res;
		adjustByTopologyJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		adjustByTopologyJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		inputDeps = IJobParallelForDeferExtensions.Schedule<AdjustByTopologyJob, Ray>(adjustByTopologyJob, rays, 256, inputDeps);
		return inputDeps;
	}

	private static void GetHeightArray_Native(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in bool isDeepSea)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		TerrainTexturing.ShoreData shoreData = TerrainTexturing.Instance.GetMap(isDeepSea);
		TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData = TerrainMeta.HeightMap.GetQueryStructure();
		bool hasHeightMap = (Object)(object)TerrainTexturing.Instance != (Object)null;
		bool hasWaterAndTopology = (Object)(object)Instance != (Object)null && Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap);
		bool hasTerrainTexturing = (Object)(object)TerrainTexturing.Instance != (Object)null;
		OceanSimulation oceanSimulation = Instance.GetOceanSimulation(isDeepSea);
		GetHeightByUVJob terrainWaterMap = TerrainMeta.WaterMap.FetchUVsHeightsJob(posUV, waterHeight);
		TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure = TerrainMeta.TopologyMap.GetQueryStructure();
		bool hasWaterSystem = (Object)(object)Instance != (Object)null;
		float OceanLevel = WaterSystem.OceanLevel;
		float MaxOceanLevel = oceanSimulation.MaxLevel();
		TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct = TerrainMeta.WaterMap.GetQueryStructure();
		WaterSystemBurst.GetHeightArray_Burst(in pos, in posUV, ref shore, ref terrainHeight, ref waterHeight, in shoreData, in terrainHeightMapData, ref terrainWaterMap, in isDeepSea, in DeepSeaManager.SeaFloorDepth, in hasHeightMap, in hasTerrainTexturing, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
		IJobExtensions.RunByRef<GetHeightByUVJob>(ref terrainWaterMap);
		oceanSimulation.GetHeightBatch(NativeArray<Vector2>.op_Implicit(ref pos), NativeArray<float>.op_Implicit(ref waterHeight), NativeArray<float>.op_Implicit(ref shore), NativeArray<float>.op_Implicit(ref terrainHeight));
		WaterSystemBurst.ComputeOceanSimHeight_Burst(in pos, in posUV, ref shore, ref waterHeight, in isDeepSea, in hasWaterAndTopology, in topologyQueryStructure, WaterSystem.OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
	}

	public static void GetHeightArray_Managed(Vector2[] pos, Vector2[] posUV, float[] shore, float[] terrainHeight, float[] waterHeight, bool isDeepSea)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainTexturing.Instance != (Object)null)
		{
			TerrainTexturing.ShoreData map = TerrainTexturing.Instance.GetMap(isDeepSea);
			for (int i = 0; i < posUV.Length; i++)
			{
				shore[i] = map.GetCoarseDistanceToShore(posUV[i]);
			}
		}
		else
		{
			Array.Fill(shore, 0f, 0, posUV.Length);
		}
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			if (isDeepSea)
			{
				Array.Fill(terrainHeight, DeepSeaManager.SeaFloorDepth);
			}
			else
			{
				for (int j = 0; j < posUV.Length; j++)
				{
					terrainHeight[j] = TerrainMeta.HeightMap.GetHeightFast(posUV[j]);
				}
			}
		}
		else
		{
			Array.Fill(terrainHeight, 0f, 0, posUV.Length);
		}
		if ((Object)(object)Instance != (Object)null && Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			bool flag = false;
			OceanSimulation oceanSimulation = Instance.GetOceanSimulation(isDeepSea);
			for (int k = 0; k < posUV.Length; k++)
			{
				Vector2 val = posUV[k];
				float num = TerrainMeta.WaterMap.GetHeightFast(val, isDeepSea);
				if (num < OceanLevel + oceanSimulation.MaxLevel() && (isDeepSea || TerrainMeta.TopologyMap.GetTopology(val.x, val.y, 384)))
				{
					if (!flag)
					{
						oceanSimulation.GetHeightBatch(pos, waterHeight, shore, terrainHeight);
						flag = true;
					}
					float num2 = waterHeight[k] + OceanLevel;
					num = Mathf.Max(num, num2);
				}
				waterHeight[k] = num;
			}
		}
		else if ((Object)(object)Instance != (Object)null)
		{
			Instance.GetOceanSimulation(isDeepSea).GetHeightBatch(pos, waterHeight, shore, terrainHeight);
			for (int l = 0; l < pos.Length; l++)
			{
				waterHeight[l] += OceanLevel;
			}
		}
		else
		{
			Array.Fill(waterHeight, OceanLevel, 0, pos.Length);
			Array.Fill(shore, 0f, 0, posUV.Length);
		}
	}

	public static void GetHeightArray(Vector2[] pos, Vector2[] posUV, float[] shore, float[] terrainHeight, float[] waterHeight, bool isDeepSea)
	{
		GetHeightArray_Managed(pos, posUV, shore, terrainHeight, waterHeight, isDeepSea);
	}

	public static void GetHeightArray(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, bool isDeepSea)
	{
		GetHeightArray_Native(in pos, in posUV, ref shore, ref terrainHeight, ref waterHeight, in isDeepSea);
	}

	public static void RegisterBody(WaterBody body)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (body.Type == WaterBodyType.Ocean)
		{
			if ((Object)(object)Ocean == (Object)null)
			{
				Ocean = body;
				body.Transform.position = Vector3Ex.WithY(body.Transform.position, OceanLevel);
			}
			else if ((Object)(object)Ocean != (Object)(object)body)
			{
				Debug.LogWarning((object)"[Water] Ocean body is already registered. Ignoring call because only one is allowed.");
				return;
			}
		}
		WaterBodies.Add(body);
	}

	public static void UnregisterBody(WaterBody body)
	{
		if ((Object)(object)body == (Object)(object)Ocean)
		{
			Ocean = null;
		}
		WaterBodies.Remove(body);
	}

	private static void UpdateOceanLevel()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Ocean != (Object)null)
		{
			Ocean.Transform.position = Vector3Ex.WithY(Ocean.Transform.position, OceanLevel);
		}
		foreach (WaterBody waterBody in WaterBodies)
		{
			waterBody.OnOceanLevelChanged(OceanLevel);
		}
	}

	private void UpdateOceanSimulation()
	{
		if (Water.scaled_time)
		{
			WaveTime += Time.deltaTime;
		}
		else
		{
			WaveTime = Time.realtimeSinceStartup;
		}
		if (Weather.ocean_time >= 0f)
		{
			WaveTime = Weather.ocean_time;
		}
		float beaufort = (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance) ? SingletonComponent<Climate>.Instance.WeatherState.OceanScale : 4f);
		oceanSimulationWrapper.mainlandSimulation?.Update(WaveTime, Time.deltaTime, beaufort);
		float beaufort2 = (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance) ? SingletonComponent<Climate>.Instance.DeepSeaWeatherState.OceanScale : 4f);
		oceanSimulationWrapper.deepSeaSimulation?.Update(WaveTime, Time.deltaTime, beaufort2);
	}

	public void Refresh()
	{
		oceanSimulationWrapper.Dispose();
		oceanSimulationWrapper = OceanSimulationWrapper.Init(oceanSettings, oceanSettings);
	}

	private void EditorInitialize()
	{
	}

	private void EditorShutdown()
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class RenderingSettings
{
	[Serializable]
	public class SkyProbe
	{
		public float ProbeUpdateInterval = 1f;

		public bool TimeSlicing = true;
	}

	[Serializable]
	public class SSR
	{
		public float FresnelCutoff = 0.02f;

		public float ThicknessMin = 1f;

		public float ThicknessMax = 20f;

		public float ThicknessStartDist = 40f;

		public float ThicknessEndDist = 100f;
	}

	public Vector4[] TessellationQuality;

	public SkyProbe SkyReflections;

	public SSR ScreenSpaceReflections;
}


using System;

[Serializable]
public class SkyProbe
{
	public float ProbeUpdateInterval = 1f;

	public bool TimeSlicing = true;
}


using System;

[Serializable]
public class SSR
{
	public float FresnelCutoff = 0.02f;

	public float ThicknessMin = 1f;

	public float ThicknessMax = 20f;

	public float ThicknessStartDist = 40f;

	public float ThicknessEndDist = 100f;
}


using System;
using Rust.Water5;
using UnityEngine;

private struct OceanSimulationWrapper : IDisposable
{
	internal OceanSimulation mainlandSimulation;

	internal OceanSimulation deepSeaSimulation;

	internal static OceanSimulationWrapper Init(OceanSettings mainland, OceanSettings deepsea)
	{
		OceanSimulationWrapper result = default(OceanSimulationWrapper);
		result.mainlandSimulation = new OceanSimulation(mainland);
		result.deepSeaSimulation = new OceanSimulation(deepsea);
		return result;
	}

	public OceanSimulation GetOceanSimulation(Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if (!DeepSeaManager.IsInsideDeepSea(worldPosition))
		{
			return mainlandSimulation;
		}
		return deepSeaSimulation;
	}

	public OceanSimulation GetOceanSimulation(bool isDeepSea)
	{
		if (!isDeepSea)
		{
			return mainlandSimulation;
		}
		return deepSeaSimulation;
	}

	public void Dispose()
	{
		mainlandSimulation?.Dispose();
		deepSeaSimulation?.Dispose();
	}
}


using System;
using System.Runtime.CompilerServices;
using TerrainWaterMapJobs;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

[BurstCompile]
public class WaterSystemBurst
{
	internal delegate void GetHeightArray_Burst_0000650E$PostfixBurstDelegate(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in TerrainTexturing.ShoreData shoreData, in TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData, ref GetHeightByUVJob terrainWaterMap, in bool isDeepSea, in float deepSeaFloorDepth, in bool hasHeightMap, in bool hasTerrainTexturing, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct);

	internal static class GetHeightArray_Burst_0000650E$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(GetHeightArray_Burst_0000650E$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static GetHeightArray_Burst_0000650E$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in TerrainTexturing.ShoreData shoreData, in TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData, ref GetHeightByUVJob terrainWaterMap, in bool isDeepSea, in float deepSeaFloorDepth, in bool hasHeightMap, in bool hasTerrainTexturing, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
		{
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref NativeArray<Vector2>, ref NativeArray<Vector2>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref TerrainTexturing.ShoreData, ref TerrainHeightMap.HeightMapQueryStructure, ref GetHeightByUVJob, ref bool, ref float, ref bool, ref bool, ref bool, ref TerrainTopologyMap.TopologyQueryStructure, ref float, ref float, ref bool, ref TerrainWaterMap.WaterMapQueryStructure, void>)functionPointer)(ref pos, ref posUV, ref shore, ref terrainHeight, ref waterHeight, ref shoreData, ref terrainHeightMapData, ref terrainWaterMap, ref isDeepSea, ref deepSeaFloorDepth, ref hasHeightMap, ref hasTerrainTexturing, ref hasWaterAndTopology, ref topologyQueryStructure, ref OceanLevel, ref MaxOceanLevel, ref hasWaterSystem, ref waterMapQueryStruct);
					return;
				}
			}
			GetHeightArray_Burst$BurstManaged(in pos, in posUV, ref shore, ref terrainHeight, ref waterHeight, in shoreData, in terrainHeightMapData, ref terrainWaterMap, in isDeepSea, in deepSeaFloorDepth, in hasHeightMap, in hasTerrainTexturing, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
		}
	}

	internal delegate void ComputeOceanSimHeight_Burst_0000650F$PostfixBurstDelegate(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> waterHeight, in bool isDeepSea, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct);

	internal static class ComputeOceanSimHeight_Burst_0000650F$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(ComputeOceanSimHeight_Burst_0000650F$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static ComputeOceanSimHeight_Burst_0000650F$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> waterHeight, in bool isDeepSea, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
		{
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref NativeArray<Vector2>, ref NativeArray<Vector2>, ref NativeArray<float>, ref NativeArray<float>, ref bool, ref bool, ref TerrainTopologyMap.TopologyQueryStructure, ref float, ref float, ref bool, ref TerrainWaterMap.WaterMapQueryStructure, void>)functionPointer)(ref pos, ref posUV, ref shore, ref waterHeight, ref isDeepSea, ref hasWaterAndTopology, ref topologyQueryStructure, ref OceanLevel, ref MaxOceanLevel, ref hasWaterSystem, ref waterMapQueryStruct);
					return;
				}
			}
			ComputeOceanSimHeight_Burst$BurstManaged(in pos, in posUV, ref shore, ref waterHeight, in isDeepSea, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
		}
	}

	[BurstCompile]
	public static void GetHeightArray_Burst(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in TerrainTexturing.ShoreData shoreData, in TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData, ref GetHeightByUVJob terrainWaterMap, in bool isDeepSea, in float deepSeaFloorDepth, in bool hasHeightMap, in bool hasTerrainTexturing, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
	{
		GetHeightArray_Burst_0000650E$BurstDirectCall.Invoke(in pos, in posUV, ref shore, ref terrainHeight, ref waterHeight, in shoreData, in terrainHeightMapData, ref terrainWaterMap, in isDeepSea, in deepSeaFloorDepth, in hasHeightMap, in hasTerrainTexturing, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
	}

	[BurstCompile]
	public static void ComputeOceanSimHeight_Burst(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> waterHeight, in bool isDeepSea, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
	{
		ComputeOceanSimHeight_Burst_0000650F$BurstDirectCall.Invoke(in pos, in posUV, ref shore, ref waterHeight, in isDeepSea, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void GetHeightArray_Burst$BurstManaged(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in TerrainTexturing.ShoreData shoreData, in TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData, ref GetHeightByUVJob terrainWaterMap, in bool isDeepSea, in float deepSeaFloorDepth, in bool hasHeightMap, in bool hasTerrainTexturing, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (hasTerrainTexturing)
		{
			for (int i = 0; i < posUV.Length; i++)
			{
				shore[i] = shoreData.GetCoarseDistanceToShore(posUV[i]);
			}
		}
		else
		{
			NativeArrayUtility.Fill<float>(ref shore, 0f);
		}
		if (hasHeightMap)
		{
			if (isDeepSea)
			{
				NativeArrayUtility.Fill<float>(ref terrainHeight, deepSeaFloorDepth);
				return;
			}
			for (int j = 0; j < posUV.Length; j++)
			{
				terrainHeight[j] = terrainHeightMapData.GetHeightFast(posUV[j]);
			}
		}
		else
		{
			NativeArrayUtility.Fill<float>(ref terrainHeight, 0f);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void ComputeOceanSimHeight_Burst$BurstManaged(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> waterHeight, in bool isDeepSea, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (hasWaterAndTopology)
		{
			for (int i = 0; i < posUV.Length; i++)
			{
				Vector2 val = posUV[i];
				float num = waterMapQueryStruct.GetHeightFast(val, isDeepSea);
				if (num < OceanLevel + MaxOceanLevel && (isDeepSea || topologyQueryStructure.GetTopology(val.x, val.y, 384)))
				{
					float num2 = waterHeight[i] + OceanLevel;
					num = Mathf.Max(num, num2);
				}
				waterHeight[i] = num;
			}
		}
		else if (hasWaterSystem)
		{
			for (int j = 0; j < pos.Length; j++)
			{
				int num3 = j;
				waterHeight[num3] += OceanLevel;
			}
		}
		else
		{
			NativeArrayUtility.Fill<float>(ref waterHeight, OceanLevel);
			NativeArrayUtility.Fill<float>(ref shore, 0f);
		}
	}
}


using TerrainWaterMapJobs;
using Unity.Collections;
using UnityEngine;

internal delegate void GetHeightArray_Burst_0000650E$PostfixBurstDelegate(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in TerrainTexturing.ShoreData shoreData, in TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData, ref GetHeightByUVJob terrainWaterMap, in bool isDeepSea, in float deepSeaFloorDepth, in bool hasHeightMap, in bool hasTerrainTexturing, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct);


using System;
using TerrainWaterMapJobs;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

internal static class GetHeightArray_Burst_0000650E$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(GetHeightArray_Burst_0000650E$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static GetHeightArray_Burst_0000650E$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> terrainHeight, ref NativeArray<float> waterHeight, in TerrainTexturing.ShoreData shoreData, in TerrainHeightMap.HeightMapQueryStructure terrainHeightMapData, ref GetHeightByUVJob terrainWaterMap, in bool isDeepSea, in float deepSeaFloorDepth, in bool hasHeightMap, in bool hasTerrainTexturing, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
	{
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref NativeArray<Vector2>, ref NativeArray<Vector2>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<float>, ref TerrainTexturing.ShoreData, ref TerrainHeightMap.HeightMapQueryStructure, ref GetHeightByUVJob, ref bool, ref float, ref bool, ref bool, ref bool, ref TerrainTopologyMap.TopologyQueryStructure, ref float, ref float, ref bool, ref TerrainWaterMap.WaterMapQueryStructure, void>)functionPointer)(ref pos, ref posUV, ref shore, ref terrainHeight, ref waterHeight, ref shoreData, ref terrainHeightMapData, ref terrainWaterMap, ref isDeepSea, ref deepSeaFloorDepth, ref hasHeightMap, ref hasTerrainTexturing, ref hasWaterAndTopology, ref topologyQueryStructure, ref OceanLevel, ref MaxOceanLevel, ref hasWaterSystem, ref waterMapQueryStruct);
				return;
			}
		}
		GetHeightArray_Burst$BurstManaged(in pos, in posUV, ref shore, ref terrainHeight, ref waterHeight, in shoreData, in terrainHeightMapData, ref terrainWaterMap, in isDeepSea, in deepSeaFloorDepth, in hasHeightMap, in hasTerrainTexturing, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
	}
}


using Unity.Collections;
using UnityEngine;

internal delegate void ComputeOceanSimHeight_Burst_0000650F$PostfixBurstDelegate(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> waterHeight, in bool isDeepSea, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct);


using System;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

internal static class ComputeOceanSimHeight_Burst_0000650F$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(ComputeOceanSimHeight_Burst_0000650F$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static ComputeOceanSimHeight_Burst_0000650F$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in NativeArray<Vector2> pos, in NativeArray<Vector2> posUV, ref NativeArray<float> shore, ref NativeArray<float> waterHeight, in bool isDeepSea, in bool hasWaterAndTopology, in TerrainTopologyMap.TopologyQueryStructure topologyQueryStructure, in float OceanLevel, in float MaxOceanLevel, in bool hasWaterSystem, in TerrainWaterMap.WaterMapQueryStructure waterMapQueryStruct)
	{
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref NativeArray<Vector2>, ref NativeArray<Vector2>, ref NativeArray<float>, ref NativeArray<float>, ref bool, ref bool, ref TerrainTopologyMap.TopologyQueryStructure, ref float, ref float, ref bool, ref TerrainWaterMap.WaterMapQueryStructure, void>)functionPointer)(ref pos, ref posUV, ref shore, ref waterHeight, ref isDeepSea, ref hasWaterAndTopology, ref topologyQueryStructure, ref OceanLevel, ref MaxOceanLevel, ref hasWaterSystem, ref waterMapQueryStruct);
				return;
			}
		}
		ComputeOceanSimHeight_Burst$BurstManaged(in pos, in posUV, ref shore, ref waterHeight, in isDeepSea, in hasWaterAndTopology, in topologyQueryStructure, in OceanLevel, in MaxOceanLevel, in hasWaterSystem, in waterMapQueryStruct);
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class WaterVisibilityGrid : ICoarseQueryGridProvider, IDisposable
{
	private CoarseQueryGrid _queryGrid;

	private const int CellSize = 8;

	private readonly ListHashSet<WaterVisibilityTrigger> _dynamicListSet;

	public WaterVisibilityGrid()
	{
		_queryGrid = new CoarseQueryGrid(8, (int)(World.Size + 1000), -5f);
		_dynamicListSet = new ListHashSet<WaterVisibilityTrigger>();
	}

	public CoarseQueryGrid GetQueryGrid()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.PrepareForDynamicPopulate(_dynamicListSet.Count);
		Enumerator<WaterVisibilityTrigger> enumerator = _dynamicListSet.Values.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				WaterVisibilityTrigger current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && !((Object)(object)current.volume == (Object)null) && !((Object)(object)current.volume.trigger == (Object)null))
				{
					_queryGrid.AddDynamic(current.volume.trigger.bounds);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return _queryGrid;
	}

	public void AddTrigger(WaterVisibilityTrigger trigger)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (trigger.IsDynamic)
		{
			_dynamicListSet.Add(trigger);
		}
		else
		{
			_queryGrid.AddStatic(trigger.volume.trigger.bounds);
		}
	}

	public void RemoveTrigger(WaterVisibilityTrigger trigger)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (trigger.IsDynamic)
		{
			_dynamicListSet.Remove(trigger);
		}
		else
		{
			_queryGrid.RemoveStatic(trigger.volume.trigger.bounds);
		}
	}

	public bool Check(Bounds bounds)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(bounds);
	}

	public bool Check(Vector3 worldPosition, float radius)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(worldPosition, radius);
	}

	public JobHandle Check(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(positions, radii, results);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJobIndirect(positions, radii, indices, results);
	}

	public bool Check(Vector3 start, Vector3 end, float radius)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(start, end, radius);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJobIndirect(starts, ends, radii, indices, results);
	}

	public void Dispose()
	{
		_queryGrid.Dispose();
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class WaterVisibilityTrigger : EnvironmentVolumeTrigger
{
	public bool togglePhysics = true;

	public bool toggleVisuals = true;

	public bool IsDynamic;

	private long enteredTick;

	private static long ticks = 1L;

	private static SortedList<long, WaterVisibilityTrigger> tracker = new SortedList<long, WaterVisibilityTrigger>();

	public static void ResetTrackedTriggers()
	{
		ticks = 1L;
		tracker.Clear();
	}

	protected override void OnVolumeTriggerUpdate()
	{
		WaterSystem.Collision.VisibilityGrid.AddTrigger(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			WaterSystem.Collision.VisibilityGrid.RemoveTrigger(this);
		}
	}

	protected void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			tracker.Remove(enteredTick);
		}
	}

	private void ToggleVisibility()
	{
	}

	private void ResetVisibility()
	{
	}

	private void ToggleCollision(Collider other)
	{
		if (togglePhysics && (Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.SetIgnore(other, base.volume.trigger);
		}
	}

	private void ResetCollision(Collider other)
	{
		if (togglePhysics && (Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.SetIgnore(other, base.volume.trigger, ignore: false);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		bool num = (Object)(object)((Component)other).gameObject.GetComponent<PlayerWalkMovement>() != (Object)null;
		bool flag = ((Component)other).gameObject.CompareTag("MainCamera");
		if ((num || flag) && !tracker.ContainsValue(this))
		{
			enteredTick = ticks++;
			tracker.Add(enteredTick, this);
			ToggleVisibility();
		}
		if (!flag && !other.isTrigger)
		{
			ToggleCollision(other);
		}
	}

	protected void OnTriggerExit(Collider other)
	{
		bool num = (Object)(object)((Component)other).gameObject.GetComponent<PlayerWalkMovement>() != (Object)null;
		bool flag = ((Component)other).gameObject.CompareTag("MainCamera");
		if ((num || flag) && tracker.ContainsValue(this))
		{
			tracker.Remove(enteredTick);
			if (tracker.Count > 0)
			{
				bool flag2 = false;
				foreach (WaterVisibilityTrigger value in tracker.Values)
				{
					if (value.toggleVisuals)
					{
						flag2 = true;
						break;
					}
				}
				if (flag2)
				{
					tracker.Values[tracker.Count - 1].ToggleVisibility();
				}
				else
				{
					ResetVisibility();
				}
			}
			else
			{
				ResetVisibility();
			}
		}
		if (!flag && !other.isTrigger)
		{
			ResetCollision(other);
		}
	}
}


using System;
using UnityEngine;

public class WaterCheck : PrefabAttribute
{
	public bool Rotate = true;

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0f, 0f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}

	public bool Check(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return pos.y <= WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
	}

	protected override Type GetIndexedType()
	{
		return typeof(WaterCheck);
	}
}


using UnityEngine;

public static class WaterCheckEx
{
	public static bool ApplyWaterChecks(this Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		foreach (WaterCheck obj in anchors)
		{
			Vector3 val = Vector3.Scale(obj.worldPosition, scale);
			if (obj.Rotate)
			{
				val = rot * val;
			}
			Vector3 pos2 = pos + val;
			if (!obj.Check(pos2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class WaterCheckGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementDistance = 8f;

	public bool CheckRotate = true;
}


using UnityEngine;

[ExecuteInEditMode]
public class AdaptMeshToTerrain : MonoBehaviour
{
	public LayerMask LayerMask = LayerMask.op_Implicit(-1);

	public float RayHeight = 10f;

	public float RayMaxDistance = 20f;

	public float MinDisplacement = 0.01f;

	public float MaxDisplacement = 0.33f;

	[Range(8f, 64f)]
	public int PlaneResolution = 24;
}


using UnityEngine;

[ExecuteInEditMode]
public class AtmosphereVolume : MonoBehaviour
{
	public float MaxVisibleDistance = 750f;

	public float BoundsAttenuationDecay = 5f;

	public FogSettings FogSettings;
}


using System;
using UnityEngine;

[Serializable]
public struct FogSettings
{
	public Gradient ColorOverDaytime;

	public float Density;

	public float StartDistance;

	public float Height;

	public float HeightDensity;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class AtmosphereVolumeRenderer : MonoBehaviour
{
	public FogMode Mode = (FogMode)3;

	public bool DistanceFog = true;

	public bool HeightFog = true;

	public AtmosphereVolume Volume;

	private static bool isSupported
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Invalid comparison between Unknown and I4
			if ((int)Application.platform != 0)
			{
				return (int)Application.platform != 1;
			}
			return false;
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class BiomeFogStencilVolume : MonoBehaviour
{
	public float Radius = 1f;
}


using System;
using UnityEngine.Rendering;

public class CommandBufferDesc
{
	public delegate void FillCommandBuffer(CommandBuffer cb);

	public CameraEvent CameraEvent { get; private set; }

	public int OrderId { get; private set; }

	public Action<CommandBuffer> FillDelegate { get; private set; }

	public CommandBufferDesc(CameraEvent cameraEvent, int orderId, FillCommandBuffer fill)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		CameraEvent = cameraEvent;
		OrderId = orderId;
		FillDelegate = fill.Invoke;
	}
}


using UnityEngine.Rendering;

public delegate void FillCommandBuffer(CommandBuffer cb);


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class CommandBufferManager : MonoBehaviour
{
}


using UnityEngine;

[ExecuteInEditMode]
public class DeferredDecal : MonoBehaviour, IClientComponent
{
	public Mesh mesh;

	public Material material;

	public DeferredDecalQueue queue;

	public bool applyImmediately = true;
}


using UnityEngine;

[ExecuteInEditMode]
public class DeferredDecalRenderer : MonoBehaviour
{
}


using System;

[Serializable]
public enum DeferredDecalQueue
{
	Background,
	Foreground
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Renderer))]
public class BindRendererBounds : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class BindSubsurfaceProfile : MonoBehaviour
{
	public SubsurfaceProfile subsurfaceProfile;
}


using System;

[Serializable]
public struct SubsurfaceScatteringParams
{
	public enum Quality
	{
		Low,
		Medium,
		High
	}

	public bool enabled;

	public bool halfResolution;

	public float radiusScale;

	public static SubsurfaceScatteringParams Default = new SubsurfaceScatteringParams
	{
		enabled = true,
		halfResolution = true,
		radiusScale = 1f
	};
}


public enum Quality
{
	Low,
	Medium,
	High
}


using System;

[Serializable]
public struct ExtendGBufferParams
{
	public bool enabled;

	public static ExtendGBufferParams Default = new ExtendGBufferParams
	{
		enabled = false
	};
}


using System;
using UnityEngine;

[Serializable]
public struct ScreenSpaceRefractionParams
{
	[Range(0.001f, 1f)]
	public float screenWeightDistance;

	public static ScreenSpaceRefractionParams Default = new ScreenSpaceRefractionParams
	{
		screenWeightDistance = 0.1f
	};
}


using UnityEngine;

[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class DeferredExtension : MonoBehaviour
{
	public ExtendGBufferParams extendGBuffer = ExtendGBufferParams.Default;

	public SubsurfaceScatteringParams subsurfaceScattering = SubsurfaceScatteringParams.Default;

	public ScreenSpaceRefractionParams screenSpaceRefraction = ScreenSpaceRefractionParams.Default;

	public float depthScale = 100f;

	public bool debug;

	public bool forceToCameraResolution;

	public bool excludeMainLight;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Renderer))]
public class DeferredExtensionMesh : MonoBehaviour
{
	public SubsurfaceProfile subsurfaceProfile;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
public class DeferredIndirectLightingPass : MonoBehaviour
{
}


using UnityEngine;

public class SeparableSSS
{
	private static Vector3 Gaussian(float variance, float r, Color falloffColor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < 3; i++)
		{
			float num = r / (0.001f + ((Color)(ref falloffColor))[i]);
			((Vector3)(ref zero))[i] = Mathf.Exp((0f - num * num) / (2f * variance)) / (6.28f * variance);
		}
		return zero;
	}

	private static Vector3 Profile(float r, Color falloffColor)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		return 0.1f * Gaussian(0.0484f, r, falloffColor) + 0.118f * Gaussian(0.187f, r, falloffColor) + 0.113f * Gaussian(0.567f, r, falloffColor) + 0.358f * Gaussian(1.99f, r, falloffColor) + 0.078f * Gaussian(7.41f, r, falloffColor);
	}

	public static void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor)
	{
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		int num = targetSize * 2 - 1;
		float num2 = ((num > 20) ? 3f : 2f);
		float num3 = 2f;
		Color[] array = (Color[])(object)new Color[num];
		float num4 = 2f * num2 / (float)(num - 1);
		for (int i = 0; i < num; i++)
		{
			float num5 = 0f - num2 + (float)i * num4;
			float num6 = ((num5 < 0f) ? (-1f) : 1f);
			array[i].a = num2 * num6 * Mathf.Abs(Mathf.Pow(num5, num3)) / Mathf.Pow(num2, num3);
		}
		for (int j = 0; j < num; j++)
		{
			float num7 = ((j > 0) ? Mathf.Abs(array[j].a - array[j - 1].a) : 0f);
			float num8 = ((j < num - 1) ? Mathf.Abs(array[j].a - array[j + 1].a) : 0f);
			Vector3 val = (num7 + num8) / 2f * Profile(array[j].a, falloffColor);
			array[j].r = val.x;
			array[j].g = val.y;
			array[j].b = val.z;
		}
		Color val2 = array[num / 2];
		for (int num9 = num / 2; num9 > 0; num9--)
		{
			array[num9] = array[num9 - 1];
		}
		array[0] = val2;
		Vector3 zero = Vector3.zero;
		for (int k = 0; k < num; k++)
		{
			zero.x += array[k].r;
			zero.y += array[k].g;
			zero.z += array[k].b;
		}
		for (int l = 0; l < num; l++)
		{
			array[l].r /= zero.x;
			array[l].g /= zero.y;
			array[l].b /= zero.z;
		}
		target[targetStart] = array[0];
		for (uint num10 = 0u; num10 < targetSize - 1; num10++)
		{
			target[targetStart + num10 + 1] = array[targetSize + num10];
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct SubsurfaceProfileData
{
	[Range(0.1f, 100f)]
	public float ScatterRadius;

	[ColorUsage(false, false)]
	public Color SubsurfaceColor;

	[ColorUsage(false, false)]
	public Color FalloffColor;

	[ColorUsage(false, true)]
	public Color TransmissionTint;

	public static SubsurfaceProfileData Default
	{
		get
		{
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			SubsurfaceProfileData result = default(SubsurfaceProfileData);
			result.ScatterRadius = 1.2f;
			result.SubsurfaceColor = new Color(0.48f, 0.41f, 0.28f);
			result.FalloffColor = new Color(1f, 0.37f, 0.3f);
			result.TransmissionTint = new Color(0.48f, 0.41f, 0.28f);
			return result;
		}
	}

	public static SubsurfaceProfileData Invalid
	{
		get
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			SubsurfaceProfileData result = default(SubsurfaceProfileData);
			result.ScatterRadius = 0f;
			result.SubsurfaceColor = Color.clear;
			result.FalloffColor = Color.clear;
			result.TransmissionTint = Color.clear;
			return result;
		}
	}
}


using UnityEngine;

public class SubsurfaceProfile : ScriptableObject
{
	private static SubsurfaceProfileTexture profileTexture = new SubsurfaceProfileTexture();

	public SubsurfaceProfileData Data = SubsurfaceProfileData.Default;

	private int id = -1;

	public static Texture2D Texture
	{
		get
		{
			if (profileTexture == null)
			{
				return null;
			}
			return profileTexture.Texture;
		}
	}

	public static Vector4[] TransmissionTints
	{
		get
		{
			if (profileTexture == null)
			{
				return null;
			}
			return profileTexture.TransmissionTints;
		}
	}

	public int Id
	{
		get
		{
			return id;
		}
		set
		{
			id = value;
		}
	}

	private void OnEnable()
	{
		profileTexture.AddProfile(this);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SubsurfaceProfileTexture
{
	private struct SubsurfaceProfileEntry
	{
		public SubsurfaceProfileData data;

		public SubsurfaceProfile profile;

		public SubsurfaceProfileEntry(SubsurfaceProfileData data, SubsurfaceProfile profile)
		{
			this.data = data;
			this.profile = profile;
		}
	}

	public const int SUBSURFACE_PROFILE_COUNT = 16;

	public const int MAX_SUBSURFACE_PROFILES = 15;

	public const int SUBSURFACE_RADIUS_SCALE = 1024;

	public const int SUBSURFACE_KERNEL_SIZE = 3;

	private HashSet<SubsurfaceProfile> entries = new HashSet<SubsurfaceProfile>();

	private Texture2D texture;

	private Vector4[] transmissionTints = (Vector4[])(object)new Vector4[16];

	private const int KernelSize0 = 24;

	private const int KernelSize1 = 16;

	private const int KernelSize2 = 8;

	private const int KernelTotalSize = 49;

	private const int Width = 49;

	public Texture2D Texture
	{
		get
		{
			if ((Object)(object)texture == (Object)null)
			{
				CreateResources();
			}
			return texture;
		}
	}

	public Vector4[] TransmissionTints
	{
		get
		{
			if ((Object)(object)texture == (Object)null)
			{
				CreateResources();
			}
			return transmissionTints;
		}
	}

	public void AddProfile(SubsurfaceProfile profile)
	{
		entries.Add(profile);
		if (entries.Count > 15)
		{
			Debug.LogWarning((object)$"[SubsurfaceScattering] Maximum number of supported Subsurface Profiles has been reached ({entries.Count}/{15}). Please remove some.");
		}
		ReleaseResources();
	}

	public static Color Clamp(Color color, float min = 0f, float max = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Color result = default(Color);
		result.r = Mathf.Clamp(color.r, min, max);
		result.g = Mathf.Clamp(color.g, min, max);
		result.b = Mathf.Clamp(color.b, min, max);
		result.a = Mathf.Clamp(color.a, min, max);
		return result;
	}

	private void WriteKernel(ref Color[] pixels, ref Color[] kernel, int id, int y, in SubsurfaceProfileData data)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		Color val = Clamp(data.SubsurfaceColor);
		Color falloffColor = Clamp(data.FalloffColor, 0.009f);
		transmissionTints[id] = Color.op_Implicit(data.TransmissionTint);
		kernel[0] = val;
		kernel[0].a = data.ScatterRadius;
		SeparableSSS.CalculateKernel(kernel, 1, 24, val, falloffColor);
		SeparableSSS.CalculateKernel(kernel, 25, 16, val, falloffColor);
		SeparableSSS.CalculateKernel(kernel, 41, 8, val, falloffColor);
		int num = 49 * y;
		for (int i = 0; i < 49; i++)
		{
			Color val2 = kernel[i];
			val2.a *= ((i > 0) ? (data.ScatterRadius / 1024f) : 1f);
			pixels[num + i] = val2;
		}
	}

	private void CreateResources()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		if (entries.Count <= 0)
		{
			return;
		}
		int num = Mathf.Min(entries.Count, 15) + 1;
		ReleaseResources();
		texture = new Texture2D(49, num, (TextureFormat)17, false, true);
		((Object)texture).name = "SubsurfaceProfiles";
		((Texture)texture).wrapMode = (TextureWrapMode)1;
		((Texture)texture).filterMode = (FilterMode)1;
		Color[] pixels = texture.GetPixels(0);
		Color[] kernel = (Color[])(object)new Color[49];
		int num2 = num - 1;
		int id = 0;
		WriteKernel(ref pixels, ref kernel, id++, num2--, SubsurfaceProfileData.Default);
		foreach (SubsurfaceProfile entry in entries)
		{
			entry.Id = id;
			WriteKernel(ref pixels, ref kernel, id++, num2--, in entry.Data);
			if (num2 < 0)
			{
				break;
			}
		}
		texture.SetPixels(pixels, 0);
		texture.Apply(false, false);
	}

	public void ReleaseResources()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)texture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)texture);
			texture = null;
		}
		if (transmissionTints != null)
		{
			for (int i = 0; i < transmissionTints.Length; i++)
			{
				Vector4[] array = transmissionTints;
				int num = i;
				SubsurfaceProfileData @default = SubsurfaceProfileData.Default;
				array[num] = Color.op_Implicit(((Color)(ref @default.TransmissionTint)).linear);
			}
		}
	}
}


private struct SubsurfaceProfileEntry
{
	public SubsurfaceProfileData data;

	public SubsurfaceProfile profile;

	public SubsurfaceProfileEntry(SubsurfaceProfileData data, SubsurfaceProfile profile)
	{
		this.data = data;
		this.profile = profile;
	}
}


using UnityEngine;

[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class DeferredMeshDecal : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class DeferredMeshDecalRenderer : MonoBehaviour
{
}


using UnityEngine;

[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
public class DeployGuideCamera : SingletonComponent<DeployGuideCamera>
{
	public DeployGuideMaterial GoodMaterial;

	public DeployGuideMaterial BadMaterial;

	public DeployGuideMaterial NeutralMaterial;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Deploy Guide Material")]
public class DeployGuideMaterial : ScriptableObject
{
	public Color Albedo = Color.white;

	public Color Emission = Color.white;

	public float EmissionStrength = 1f;

	public float FresnelPower = 1f;

	public float FresnelStrength = 1f;

	public float RimPower = 1f;

	public float RimStrength = 1f;

	public float Alpha = 0.5f;

	public float AlphaFresnelPower = 1f;

	public float BackfaceBrightness = 1f;

	public float BackfaceAmount = 0.1f;
}


using UnityEngine;

public class DeployGuideMesh : MonoBehaviour
{
}


using UnityEngine;

public class DisableTextureStreamingOnAwake : MonoBehaviour
{
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Environment Volume Properties")]
public class EnvironmentVolumeProperties : ScriptableObject
{
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Environment Volume Properties Collection")]
public class EnvironmentVolumePropertiesCollection : ScriptableObject
{
	[Serializable]
	public class EnvironmentMultiplier
	{
		public EnvironmentType Type;

		public float Multiplier;
	}

	[Serializable]
	public class OceanParameters
	{
		[Header("Lighting")]
		public AnimationCurve TransitionCurveLighting = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float DirectionalLightMultiplier = 0.25f;

		[Range(0f, 1f)]
		public float AmbientLightMultiplier;

		[Range(0f, 1f)]
		public float ReflectionMultiplier = 1f;

		[Header("Sun/Moon")]
		public AnimationCurve TransitionCurveSunMoon = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float SunMeshBrightnessMultiplier = 1f;

		[Range(0f, 1f)]
		public float MoonMeshBrightnessMultiplier = 1f;

		[Header("Atmosphere")]
		public AnimationCurve TransitionCurveAtmosphere = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float AtmosphereBrightnessMultiplier = 1f;

		[Header("Colors")]
		public AnimationCurve TransitionCurve = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float LightColorMultiplier = 1f;

		public Color LightColor = Color.black;

		[Range(0f, 1f)]
		public float SunRayColorMultiplier = 1f;

		public Color SunRayColor = Color.black;

		[Range(0f, 1f)]
		public float MoonRayColorMultiplier = 1f;

		public Color MoonRayColor = Color.black;
	}

	public float TransitionSpeed = 1f;

	public LayerMask ReflectionMask = LayerMask.op_Implicit(1084293120);

	[Horizontal(1, 0)]
	public EnvironmentMultiplier[] ReflectionMultipliers;

	public float DefaultReflectionMultiplier = 1f;

	[Horizontal(1, 0)]
	public EnvironmentMultiplier[] AmbientMultipliers;

	public float DefaultAmbientMultiplier = 1f;

	public OceanParameters OceanOverrides;

	public OceanParameters OceanOverridesDeepSea;
}


using System;

[Serializable]
public class EnvironmentMultiplier
{
	public EnvironmentType Type;

	public float Multiplier;
}


using System;
using UnityEngine;

[Serializable]
public class OceanParameters
{
	[Header("Lighting")]
	public AnimationCurve TransitionCurveLighting = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float DirectionalLightMultiplier = 0.25f;

	[Range(0f, 1f)]
	public float AmbientLightMultiplier;

	[Range(0f, 1f)]
	public float ReflectionMultiplier = 1f;

	[Header("Sun/Moon")]
	public AnimationCurve TransitionCurveSunMoon = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float SunMeshBrightnessMultiplier = 1f;

	[Range(0f, 1f)]
	public float MoonMeshBrightnessMultiplier = 1f;

	[Header("Atmosphere")]
	public AnimationCurve TransitionCurveAtmosphere = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float AtmosphereBrightnessMultiplier = 1f;

	[Header("Colors")]
	public AnimationCurve TransitionCurve = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float LightColorMultiplier = 1f;

	public Color LightColor = Color.black;

	[Range(0f, 1f)]
	public float SunRayColorMultiplier = 1f;

	public Color SunRayColor = Color.black;

	[Range(0f, 1f)]
	public float MoonRayColorMultiplier = 1f;

	public Color MoonRayColor = Color.black;
}


using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(DeferredIndirectLightingPass))]
public class SpatialEnvironmentVolumePass : MonoBehaviour
{
	private const CameraEvent VOLUME_RENDERING_CAMERA_EVENT = 6;

	private const int VOLUME_RENDERING_ORDER_ID = 1000;

	private static readonly int envVolumeBufferId = Shader.PropertyToID("_EnvVolumeBuffer");

	private static readonly int numberOfVolumesId = Shader.PropertyToID("_NumberOfEnvironmentVolumes");

	[SerializeField]
	private Mesh cubeMesh;

	[SerializeField]
	private Mesh sphereMesh;

	[SerializeField]
	private Mesh capsuleMesh;

	[SerializeField]
	private Shader shader;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	[SerializeField]
	private Shader copyToDepthBufferShader;

	public bool IsInitialized { get; private set; }
}


using UnityEngine;

public class FoliageDisplacement : MonoBehaviour, IClientComponent, ILOD
{
	public bool moving;

	public bool billboard;

	public Mesh mesh;

	public Material material;
}


using UnityEngine;

public class FoliageDisplacementManager : SingletonComponent<FoliageDisplacementManager>, IClientComponent
{
	[SerializeField]
	private Material clearDisplacementMat;
}


public static class GraphicsMemory
{
}


using UnityEngine;

[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshRenderer))]
[ExecuteInEditMode]
public class Impostor : MonoBehaviour, IClientComponent, IPrefabPreProcess
{
	public ImpostorAsset asset;

	[Header("Baking")]
	public GameObject reference;

	public float angle;

	public int resolution = 1024;

	public int padding = 32;

	public bool spriteOutlineAsMesh;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private void OnEnable()
	{
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using System;
using UnityEngine;

public class ImpostorAsset : ScriptableObject
{
	[Serializable]
	public class TextureEntry
	{
		public string name;

		public Texture2D texture;

		public TextureEntry(string name, Texture2D texture)
		{
			this.name = name;
			this.texture = texture;
		}
	}

	public TextureEntry[] textures;

	public Vector2 size;

	public Vector2 pivot;

	public Mesh mesh;

	public Texture2D FindTexture(string name)
	{
		TextureEntry[] array = textures;
		foreach (TextureEntry textureEntry in array)
		{
			if (textureEntry.name == name)
			{
				return textureEntry.texture;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class TextureEntry
{
	public string name;

	public Texture2D texture;

	public TextureEntry(string name, Texture2D texture)
	{
		this.name = name;
		this.texture = texture;
	}
}


using UnityEngine;

public class ImpostorInstanceData
{
	public ImpostorBatch Batch;

	public int BatchIndex;

	private int hash;

	private Vector4 positionAndScale = Vector4.zero;

	public Renderer Renderer { get; private set; }

	public Mesh Mesh { get; private set; }

	public Material Material { get; private set; }

	public bool DeepSea { get; private set; }

	public ImpostorInstanceData(Renderer renderer, Mesh mesh, Material material)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Renderer = renderer;
		Mesh = mesh;
		Material = material;
		hash = GenerateHashCode();
		Update();
	}

	public ImpostorInstanceData(Vector3 position, Vector3 scale, Mesh mesh, Material material)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		positionAndScale = new Vector4(position.x, position.y, position.z, scale.x);
		Mesh = mesh;
		Material = material;
		hash = GenerateHashCode();
		Update();
	}

	private int GenerateHashCode()
	{
		return ((17 * 31 + ((object)Material).GetHashCode()) * 31 + ((object)Mesh).GetHashCode()) * 31 + DeepSea.GetHashCode();
	}

	public override bool Equals(object obj)
	{
		ImpostorInstanceData impostorInstanceData = obj as ImpostorInstanceData;
		if ((Object)(object)impostorInstanceData.Material == (Object)(object)Material && (Object)(object)impostorInstanceData.Mesh == (Object)(object)Mesh)
		{
			return impostorInstanceData.DeepSea == DeepSea;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return hash;
	}

	public Vector4 PositionAndScale()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Renderer != (Object)null)
		{
			Transform transform = ((Component)Renderer).transform;
			Vector3 position = transform.position;
			Vector3 lossyScale = transform.lossyScale;
			float num = (Renderer.enabled ? lossyScale.x : (0f - lossyScale.x));
			positionAndScale = new Vector4(position.x, position.y, position.z, num);
		}
		return positionAndScale;
	}

	public void Update()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = PositionAndScale();
		if (Batch != null)
		{
			Batch.Positions[BatchIndex] = val;
			Batch.IsDirty = true;
		}
		Vector3 position = default(Vector3);
		((Vector3)(ref position))..ctor(val.x, val.y, val.z);
		DeepSea = DeepSeaManager.IsInsideDeepSea(position);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ImpostorBatch : IPooled
{
	public FPNativeList<Vector4> Positions;

	private FPNativeList<uint> args;

	private Queue<int> recycle = new Queue<int>(32);

	public Mesh Mesh { get; private set; }

	public Material Material { get; private set; }

	public ComputeBuffer PositionBuffer { get; private set; }

	public ComputeBuffer ArgsBuffer { get; private set; }

	public bool IsDirty { get; set; }

	public int Count => Positions.Count;

	public bool Visible => Positions.Count - recycle.Count > 0;

	private ComputeBuffer SafeRelease(ComputeBuffer buffer)
	{
		if (buffer != null)
		{
			buffer.Release();
		}
		return null;
	}

	public void Initialize(Mesh mesh, Material material)
	{
		Mesh = mesh;
		Material = material;
		args[0] = Mesh.GetIndexCount(0);
		args[2] = Mesh.GetIndexStart(0);
		args[3] = Mesh.GetBaseVertex(0);
	}

	void IPooled.LeavePool()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		Positions = Pool.Get<FPNativeList<Vector4>>();
		args = Pool.Get<FPNativeList<uint>>();
		args.Resize(5);
		ArgsBuffer = new ComputeBuffer(1, args.Count * 4, (ComputeBufferType)256);
	}

	void IPooled.EnterPool()
	{
		recycle.Clear();
		Pool.Free<FPNativeList<Vector4>>(ref Positions);
		Pool.Free<FPNativeList<uint>>(ref args);
		PositionBuffer = SafeRelease(PositionBuffer);
		ArgsBuffer.Release();
		ArgsBuffer = null;
	}

	public void AddInstance(ImpostorInstanceData data)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		data.Batch = this;
		if (recycle.Count > 0)
		{
			data.BatchIndex = recycle.Dequeue();
			Positions[data.BatchIndex] = data.PositionAndScale();
		}
		else
		{
			data.BatchIndex = Positions.Count;
			Positions.Add(data.PositionAndScale());
		}
		IsDirty = true;
	}

	public void RemoveInstance(ImpostorInstanceData data)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Positions[data.BatchIndex] = new Vector4(0f, 0f, 0f, -1f);
		recycle.Enqueue(data.BatchIndex);
		data.BatchIndex = 0;
		data.Batch = null;
		IsDirty = true;
	}

	public void UpdateBuffers()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Expected O, but got Unknown
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (IsDirty)
		{
			bool flag = false;
			if (PositionBuffer == null || PositionBuffer.count != Positions.Count)
			{
				PositionBuffer = SafeRelease(PositionBuffer);
				PositionBuffer = new ComputeBuffer(Positions.Count, 16);
				flag = true;
			}
			PositionBuffer.SetData<Vector4>(Positions.Array, 0, 0, Positions.Count);
			if (flag)
			{
				args[1] = (uint)Positions.Count;
				ArgsBuffer.SetData<uint>(args.Array, 0, 0, args.Count);
			}
			IsDirty = false;
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
public class ImpostorRenderer : MonoBehaviour
{
	public const string MainPassName = "DEFERRED";
}


using UnityEngine;

[RequireComponent(typeof(Light))]
public class ImpostorShadows : MonoBehaviour
{
}


using UnityEngine;

public class InstancedCameraComponent : MonoBehaviour
{
	public bool IsMirror;
}


using System;

public class InstancedEntityComponent : PrefabAttribute, IClientComponent
{
	public bool HideInsideNetworkRange;

	protected override Type GetIndexedType()
	{
		return typeof(InstancedEntityComponent);
	}
}


using System;
using Instancing;
using UnityEngine;

public class InstancedMeshFilter : PrefabAttribute, IClientComponent
{
	public MeshRenderer MeshRenderer;

	public RendererLOD RendererLOD;

	public MeshLOD MeshLOD;

	[NonSerialized]
	public InstancedMeshConfig Config;

	protected override Type GetIndexedType()
	{
		return typeof(InstancedMeshFilter);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class InstancedScheduler : SingletonComponent<InstancedScheduler>
{
	public ComputeShader CullShader;

	public ComputeShader SimplePostCullShader;

	public ComputeShader ClearBufferShader;

	public ComputeShader WriteIndirectArgsShader;

	public ComputeShader CopyMeshShader;

	public ConstructionSkin_ColourLookup ContainerColorLookup;

	public List<BuildingGrade> coloredSkins;
}


using System;

public class InstancingConfigComponent : PrefabAttribute, IClientComponent
{
	public bool DisableInstancing;

	protected override Type GetIndexedType()
	{
		return typeof(InstancingConfigComponent);
	}
}


using Instancing;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct PostCullingJob : IJob
{
	[ReadOnly]
	public NativeArray<int> CountPerMesh;

	[ReadOnly]
	public int RendererCount;

	[ReadOnly]
	public NativeArray<InstancedRendererJobData> Renderers;

	[WriteOnly]
	public JobInt PostCullMeshCount;

	[WriteOnly]
	public JobInt PostCullShadowCount;

	public void Execute()
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < RendererCount; i++)
		{
			InstancedRendererJobData instancedRendererJobData = Renderers[i];
			int num3 = CountPerMesh[i];
			if (instancedRendererJobData.HasShadow)
			{
				num2 += num3;
			}
			if (instancedRendererJobData.HasMesh)
			{
				num += num3;
			}
		}
		PostCullMeshCount.Value = num;
		PostCullShadowCount.Value = num2;
	}
}


using Unity.Mathematics;
using UnityEngine;

public static class Float4x4Ex
{
	public static float3 ToPosition(this float4x4 m)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((float4)(ref m.c3)).xyz;
	}

	public static Quaternion ToRotation(this float4x4 m)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(float3.op_Implicit(((float4)(ref m.c2)).xyz), float3.op_Implicit(((float4)(ref m.c1)).xyz));
	}
}


public class VirtualEntityScheduler
{
	public static VirtualEntityScheduler Instance { get; private set; } = new VirtualEntityScheduler();
}


using UnityEngine.Rendering;

public static class Keyword
{
	public static readonly GlobalKeyword LIGHTPROBE_SH = GlobalKeyword.Create("LIGHTPROBE_SH");

	public static readonly GlobalKeyword SHADOWS_SHADOWMASK = GlobalKeyword.Create("SHADOWS_SHADOWMASK");

	public static readonly GlobalKeyword INDIRECT_INSTANCING_ON = GlobalKeyword.Create("INDIRECT_INSTANCING_ON");
}


using UnityEngine;

[ExecuteInEditMode]
public class LightCloneShadow : MonoBehaviour
{
	public bool cloneShadowMap;

	public bool cloneShadowMask;

	[Range(0f, 2f)]
	public int shadowMaskDownscale = 1;
}


using UnityEngine;

public class LiquidWobble : MonoBehaviour
{
	[Range(0f, 1f)]
	public float CurrentWaterLevelFraction;

	public float MinWaterLevel = -11f;

	public float MaxWaterLevel = 11f;

	public float MaxWobble = 0.03f;

	public float WobbleSpeed = 1f;

	public float Recovery = 1f;
}


using System;
using UnityEngine;

public struct MaterialPropertyDesc
{
	public int nameID;

	public Type type;

	public MaterialPropertyDesc(string name, Type type)
	{
		nameID = Shader.PropertyToID(name);
		this.type = type;
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MeshTerrainRoot : ListComponent<MeshTerrainRoot>, IClientComponent
{
	public GameObject TerrainBlendSearchRoot;

	public Mesh TerrainMeshAsset;

	public Material TerrainMaterial;

	public Vector3 TerrainSize;

	public TerrainConfig TerrainConfig;
}


using UnityEngine;

public class MeshTerrainRootRuntimeObject : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class PlanarReflectionCamera : MonoBehaviour
{
	public static PlanarReflectionCamera instance;

	public float updateRate = 1f;

	public float nearClipPlane = 0.3f;

	public float farClipPlane = 25f;

	public Color fogColor = Color.white;

	public float fogDensity = 0.1f;

	public Mesh waterPlaneMesh;

	public Material waterPlaneMaterial;
}


using UnityEngine;

public class ReflectionPlane : DecayEntity
{
	private static readonly int _ColorTexID = Shader.PropertyToID("_ColorTex");

	private static readonly int _DepthTexID = Shader.PropertyToID("_DepthTex");

	private static readonly int _ReflectionLerpID = Shader.PropertyToID("_ReflectionLerp");

	[Header("Reflection Plane")]
	public LayerMask layerMask = LayerMask.op_Implicit(-1);

	public float nearClip;

	public float farClip;

	public Material reflectionMaterial;

	public Renderer reflectionRenderer;

	public float maxDistance;

	public float fadeTime = 0.25f;
}


public class MorphCache : FacepunchBehaviour
{
}


using UnityEngine;

public class ObjectMotionVectorFix : MonoBehaviour
{
}


using UnityEngine;

[RequireComponent(typeof(CommandBufferManager))]
[ExecuteInEditMode]
public class PostOpaqueDepth : MonoBehaviour
{
	public RenderTexture postOpaqueDepth;

	public RenderTexture PostOpaque => postOpaqueDepth;
}


using UnityEngine;

public class QuadDecal : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class ReflectionProbeEx : MonoBehaviour
{
	[Serializable]
	public enum ConvolutionQuality
	{
		Lowest,
		Low,
		Medium,
		High,
		VeryHigh
	}

	[Serializable]
	public struct RenderListEntry
	{
		public Renderer renderer;

		public bool alwaysEnabled;

		public RenderListEntry(Renderer renderer, bool alwaysEnabled)
		{
			this.renderer = renderer;
			this.alwaysEnabled = alwaysEnabled;
		}
	}

	private struct CubemapSkyboxVertex
	{
		public float x;

		public float y;

		public float z;

		public Color color;

		public float tu;

		public float tv;

		public float tw;
	}

	private struct CubemapFaceMatrices
	{
		public Matrix4x4 worldToView;

		public Matrix4x4 viewToWorld;

		public CubemapFaceMatrices(Vector3 x, Vector3 y, Vector3 z)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			worldToView = Matrix4x4.identity;
			((Matrix4x4)(ref worldToView))[0, 0] = ((Vector3)(ref x))[0];
			((Matrix4x4)(ref worldToView))[0, 1] = ((Vector3)(ref x))[1];
			((Matrix4x4)(ref worldToView))[0, 2] = ((Vector3)(ref x))[2];
			((Matrix4x4)(ref worldToView))[1, 0] = ((Vector3)(ref y))[0];
			((Matrix4x4)(ref worldToView))[1, 1] = ((Vector3)(ref y))[1];
			((Matrix4x4)(ref worldToView))[1, 2] = ((Vector3)(ref y))[2];
			((Matrix4x4)(ref worldToView))[2, 0] = ((Vector3)(ref z))[0];
			((Matrix4x4)(ref worldToView))[2, 1] = ((Vector3)(ref z))[1];
			((Matrix4x4)(ref worldToView))[2, 2] = ((Vector3)(ref z))[2];
			viewToWorld = ((Matrix4x4)(ref worldToView)).inverse;
		}
	}

	public ReflectionProbeRefreshMode refreshMode = (ReflectionProbeRefreshMode)1;

	public bool timeSlicing;

	public int resolution = 128;

	[InspectorName("HDR")]
	public bool hdr = true;

	public float shadowDistance;

	public ReflectionProbeClearFlags clearFlags = (ReflectionProbeClearFlags)1;

	public Color background = new Color(0.192f, 0.301f, 0.474f);

	public float nearClip = 0.3f;

	public float farClip = 1000f;

	public Transform attachToTarget;

	public Light directionalLight;

	public float textureMipBias = 2f;

	public bool highPrecision;

	public bool enableShadows;

	public ConvolutionQuality convolutionQuality;

	public List<RenderListEntry> staticRenderList = new List<RenderListEntry>();

	public Cubemap reflectionCubemap;

	public float reflectionIntensity = 1f;

	private Mesh blitMesh;

	private Mesh skyboxMesh;

	private static float[] octaVerts = new float[72]
	{
		0f, 1f, 0f, 0f, 0f, -1f, 1f, 0f, 0f, 0f,
		1f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, 1f,
		0f, 0f, 0f, 1f, -1f, 0f, 0f, 0f, 1f, 0f,
		-1f, 0f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 1f,
		0f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 0f, 0f,
		1f, 1f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 0f,
		0f, 0f, 1f, 0f, -1f, 0f, 0f, 0f, -1f, -1f,
		0f, 0f
	};

	private static readonly CubemapFaceMatrices[] cubemapFaceMatrices = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, -1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, 1f))
	};

	private static readonly CubemapFaceMatrices[] cubemapFaceMatricesD3D11 = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, 1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, -1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f))
	};

	private static readonly CubemapFaceMatrices[] shadowCubemapFaceMatrices = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, 1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, -1f))
	};

	private CubemapFaceMatrices[] platformCubemapFaceMatrices;

	private static readonly int[] tab32 = new int[32]
	{
		0, 9, 1, 10, 13, 21, 2, 29, 11, 14,
		16, 18, 22, 25, 3, 30, 8, 12, 20, 28,
		15, 17, 24, 7, 19, 27, 23, 6, 26, 5,
		4, 31
	};

	private void CreateMeshes()
	{
		if ((Object)(object)blitMesh == (Object)null)
		{
			blitMesh = CreateBlitMesh();
		}
		if ((Object)(object)skyboxMesh == (Object)null)
		{
			skyboxMesh = CreateSkyboxMesh();
		}
	}

	private void DestroyMeshes()
	{
		if ((Object)(object)blitMesh != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)blitMesh);
			blitMesh = null;
		}
		if ((Object)(object)skyboxMesh != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)skyboxMesh);
			skyboxMesh = null;
		}
	}

	private static Mesh CreateBlitMesh()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		val.vertices = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(-1f, -1f, 0f),
			new Vector3(-1f, 1f, 0f),
			new Vector3(1f, 1f, 0f),
			new Vector3(1f, -1f, 0f)
		};
		val.uv = (Vector2[])(object)new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		val.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		return val;
	}

	private static CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(v1.x, v1.y, v1.z);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(v2.x, v2.y, v2.z);
		Vector3 val3 = Vector3.Normalize(Vector3.Lerp(val, val2, 0.5f));
		CubemapSkyboxVertex result = default(CubemapSkyboxVertex);
		result.x = (result.tu = val3.x);
		result.y = (result.tv = val3.y);
		result.z = (result.tw = val3.z);
		result.color = Color.white;
		return result;
	}

	private static void Subdivide(List<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
	{
		CubemapSkyboxVertex item = SubDivVert(v1, v2);
		CubemapSkyboxVertex item2 = SubDivVert(v2, v3);
		CubemapSkyboxVertex item3 = SubDivVert(v1, v3);
		destArray.Add(v1);
		destArray.Add(item);
		destArray.Add(item3);
		destArray.Add(item);
		destArray.Add(v2);
		destArray.Add(item2);
		destArray.Add(item2);
		destArray.Add(item3);
		destArray.Add(item);
		destArray.Add(v3);
		destArray.Add(item3);
		destArray.Add(item2);
	}

	private static void SubdivideYOnly(List<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Abs(v2.y - v1.y);
		float num2 = Mathf.Abs(v2.y - v3.y);
		float num3 = Mathf.Abs(v3.y - v1.y);
		CubemapSkyboxVertex cubemapSkyboxVertex;
		CubemapSkyboxVertex cubemapSkyboxVertex2;
		CubemapSkyboxVertex cubemapSkyboxVertex3;
		if (num < num2 && num < num3)
		{
			cubemapSkyboxVertex = v3;
			cubemapSkyboxVertex2 = v1;
			cubemapSkyboxVertex3 = v2;
		}
		else if (num2 < num && num2 < num3)
		{
			cubemapSkyboxVertex = v1;
			cubemapSkyboxVertex2 = v2;
			cubemapSkyboxVertex3 = v3;
		}
		else
		{
			cubemapSkyboxVertex = v2;
			cubemapSkyboxVertex2 = v3;
			cubemapSkyboxVertex3 = v1;
		}
		CubemapSkyboxVertex item = SubDivVert(cubemapSkyboxVertex, cubemapSkyboxVertex2);
		CubemapSkyboxVertex item2 = SubDivVert(cubemapSkyboxVertex, cubemapSkyboxVertex3);
		destArray.Add(cubemapSkyboxVertex);
		destArray.Add(item);
		destArray.Add(item2);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(item2.x - cubemapSkyboxVertex2.x, item2.y - cubemapSkyboxVertex2.y, item2.z - cubemapSkyboxVertex2.z);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(item.x - cubemapSkyboxVertex3.x, item.y - cubemapSkyboxVertex3.y, item.z - cubemapSkyboxVertex3.z);
		if (val.x * val.x + val.y * val.y + val.z * val.z > val2.x * val2.x + val2.y * val2.y + val2.z * val2.z)
		{
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(cubemapSkyboxVertex3);
			destArray.Add(item2);
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex3);
		}
		else
		{
			destArray.Add(item2);
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(item2);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(cubemapSkyboxVertex3);
		}
	}

	private static Mesh CreateSkyboxMesh()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Expected O, but got Unknown
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		List<CubemapSkyboxVertex> list = new List<CubemapSkyboxVertex>();
		for (int i = 0; i < 24; i++)
		{
			CubemapSkyboxVertex item = default(CubemapSkyboxVertex);
			Vector3 val = Vector3.Normalize(new Vector3(octaVerts[i * 3], octaVerts[i * 3 + 1], octaVerts[i * 3 + 2]));
			item.x = (item.tu = val.x);
			item.y = (item.tv = val.y);
			item.z = (item.tw = val.z);
			item.color = Color.white;
			list.Add(item);
		}
		for (int j = 0; j < 3; j++)
		{
			List<CubemapSkyboxVertex> list2 = new List<CubemapSkyboxVertex>(list.Count);
			list2.AddRange(list);
			int count = list2.Count;
			list.Clear();
			list.Capacity = count * 4;
			for (int k = 0; k < count; k += 3)
			{
				Subdivide(list, list2[k], list2[k + 1], list2[k + 2]);
			}
		}
		for (int l = 0; l < 2; l++)
		{
			List<CubemapSkyboxVertex> list3 = new List<CubemapSkyboxVertex>(list.Count);
			list3.AddRange(list);
			int count2 = list3.Count;
			float num = Mathf.Pow(0.5f, (float)l + 1f);
			list.Clear();
			list.Capacity = count2 * 4;
			for (int m = 0; m < count2; m += 3)
			{
				if (Mathf.Max(Mathf.Max(Mathf.Abs(list3[m].y), Mathf.Abs(list3[m + 1].y)), Mathf.Abs(list3[m + 2].y)) > num)
				{
					list.Add(list3[m]);
					list.Add(list3[m + 1]);
					list.Add(list3[m + 2]);
				}
				else
				{
					SubdivideYOnly(list, list3[m], list3[m + 1], list3[m + 2]);
				}
			}
		}
		Mesh val2 = new Mesh();
		Vector3[] array = (Vector3[])(object)new Vector3[list.Count];
		Vector2[] array2 = (Vector2[])(object)new Vector2[list.Count];
		int[] array3 = new int[list.Count];
		for (int n = 0; n < list.Count; n++)
		{
			array[n] = new Vector3(list[n].x, list[n].y, list[n].z);
			array2[n] = Vector2.op_Implicit(new Vector3(list[n].tu, list[n].tv));
			array3[n] = n;
		}
		val2.vertices = array;
		val2.uv = array2;
		val2.triangles = array3;
		return val2;
	}

	private bool InitializeCubemapFaceMatrices()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Invalid comparison between Unknown and I4
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected I4, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		GraphicsDeviceType graphicsDeviceType = SystemInfo.graphicsDeviceType;
		if ((int)graphicsDeviceType != 2)
		{
			switch (graphicsDeviceType - 16)
			{
			case 1:
				platformCubemapFaceMatrices = cubemapFaceMatrices;
				break;
			case 2:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			case 5:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			case 0:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			default:
				platformCubemapFaceMatrices = null;
				break;
			}
		}
		else
		{
			platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
		}
		if (platformCubemapFaceMatrices == null)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogError((object)("[ReflectionProbeEx] Initialization failed. No cubemap ortho basis defined for " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString()));
			return false;
		}
		return true;
	}

	private int FastLog2(int value)
	{
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return tab32[(uint)((long)value * 130329821L) >> 27];
	}

	private uint ReverseBits(uint bits)
	{
		bits = (bits << 16) | (bits >> 16);
		bits = ((bits & 0xFF00FF) << 8) | ((bits & 0xFF00FF00u) >> 8);
		bits = ((bits & 0xF0F0F0F) << 4) | ((bits & 0xF0F0F0F0u) >> 4);
		bits = ((bits & 0x33333333) << 2) | ((bits & 0xCCCCCCCCu) >> 2);
		bits = ((bits & 0x55555555) << 1) | ((bits & 0xAAAAAAAAu) >> 1);
		return bits;
	}

	private void SafeCreateMaterial(ref Material mat, Shader shader)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		if ((Object)(object)mat == (Object)null)
		{
			mat = new Material(shader);
		}
	}

	private void SafeCreateMaterial(ref Material mat, string shaderName)
	{
		if ((Object)(object)mat == (Object)null)
		{
			SafeCreateMaterial(ref mat, Shader.Find(shaderName));
		}
	}

	private void SafeCreateCubeRT(ref RenderTexture rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite = 1)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Invalid comparison between Unknown and I4
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rt == (Object)null || !rt.IsCreated())
		{
			SafeDestroy<RenderTexture>(ref rt);
			rt = new RenderTexture(size, size, depth, format, readWrite)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).dimension = dim;
			if ((int)dim == 5)
			{
				rt.volumeDepth = 6;
			}
			rt.useMipMap = mips;
			rt.autoGenerateMips = false;
			((Texture)rt).filterMode = filter;
			((Texture)rt).anisoLevel = 0;
			rt.Create();
		}
	}

	private void SafeCreateCB(ref CommandBuffer cb, string name)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		if (cb == null)
		{
			cb = new CommandBuffer();
			cb.name = name;
		}
	}

	private void SafeDestroy<T>(ref T obj) where T : Object
	{
		if ((Object)(object)obj != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)obj);
			obj = default(T);
		}
	}

	private void SafeDispose<T>(ref T obj) where T : IDisposable
	{
		if (obj != null)
		{
			obj.Dispose();
			obj = default(T);
		}
	}
}


using System;

[Serializable]
public enum ConvolutionQuality
{
	Lowest,
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine;

[Serializable]
public struct RenderListEntry
{
	public Renderer renderer;

	public bool alwaysEnabled;

	public RenderListEntry(Renderer renderer, bool alwaysEnabled)
	{
		this.renderer = renderer;
		this.alwaysEnabled = alwaysEnabled;
	}
}


using UnityEngine;

private struct CubemapSkyboxVertex
{
	public float x;

	public float y;

	public float z;

	public Color color;

	public float tu;

	public float tv;

	public float tw;
}


using UnityEngine;

private struct CubemapFaceMatrices
{
	public Matrix4x4 worldToView;

	public Matrix4x4 viewToWorld;

	public CubemapFaceMatrices(Vector3 x, Vector3 y, Vector3 z)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		worldToView = Matrix4x4.identity;
		((Matrix4x4)(ref worldToView))[0, 0] = ((Vector3)(ref x))[0];
		((Matrix4x4)(ref worldToView))[0, 1] = ((Vector3)(ref x))[1];
		((Matrix4x4)(ref worldToView))[0, 2] = ((Vector3)(ref x))[2];
		((Matrix4x4)(ref worldToView))[1, 0] = ((Vector3)(ref y))[0];
		((Matrix4x4)(ref worldToView))[1, 1] = ((Vector3)(ref y))[1];
		((Matrix4x4)(ref worldToView))[1, 2] = ((Vector3)(ref y))[2];
		((Matrix4x4)(ref worldToView))[2, 0] = ((Vector3)(ref z))[0];
		((Matrix4x4)(ref worldToView))[2, 1] = ((Vector3)(ref z))[1];
		((Matrix4x4)(ref worldToView))[2, 2] = ((Vector3)(ref z))[2];
		viewToWorld = ((Matrix4x4)(ref worldToView)).inverse;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public static class CommandBufferEx
{
	public static void BlitArray(this CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int slice, int pass = 0)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		cb.SetGlobalTexture("_Source", source);
		cb.SetGlobalFloat("_SourceMip", 0f);
		if (slice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)slice);
			cb.SetGlobalInt("_TargetSlice", slice);
		}
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitArray(this CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Texture target, Material mat, int slice, int pass = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		cb.SetRenderTarget(RenderTargetIdentifier.op_Implicit(target), 0, (CubemapFace)(-1), -1);
		cb.SetGlobalTexture("_Source", source);
		cb.SetGlobalFloat("_SourceMip", 0f);
		if (slice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)slice);
			cb.SetGlobalInt("_TargetSlice", slice);
		}
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitArrayMip(this CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, int sourceSlice, Texture target, int targetMip, int targetSlice, Material mat, int pass = 0)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		int num = source.width >> sourceMip;
		int num2 = source.height >> sourceMip;
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(1f / (float)num, 1f / (float)num2, (float)num, (float)num2);
		int num3 = target.width >> targetMip;
		int num4 = target.height >> targetMip;
		Vector4 val2 = default(Vector4);
		((Vector4)(ref val2))..ctor(1f / (float)num3, 1f / (float)num4, (float)num3, (float)num4);
		cb.SetGlobalTexture("_Source", RenderTargetIdentifier.op_Implicit(source));
		cb.SetGlobalVector("_Source_TexelSize", val);
		cb.SetGlobalVector("_Target_TexelSize", val2);
		cb.SetGlobalFloat("_SourceMip", (float)sourceMip);
		if (sourceSlice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)sourceSlice);
			cb.SetGlobalInt("_TargetSlice", targetSlice);
		}
		cb.SetRenderTarget(RenderTargetIdentifier.op_Implicit(target), targetMip, (CubemapFace)(-1), -1);
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitMip(this CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, int slice, Material mat, int pass = 0)
	{
		cb.BlitArrayMip(blitMesh, source, mip, slice, target, mip, slice, mat, pass);
	}
}


using Rust.RenderPipeline.Runtime;
using UnityEngine;

[CreateAssetMenu(menuName = "Rendering/RustRendererFeatures/DecalsRendererFeature")]
public class DecalsRendererFeature : RustRendererFeature
{
	[SerializeField]
	private bool enableDeferredDecals = true;

	[SerializeField]
	private bool enableDeferredMeshDecals = true;

	public override void Create()
	{
	}

	public override void AddRenderPasses(RustRenderer renderer)
	{
	}
}


using Rust.RenderPipeline.Runtime;

public class DeferredDecalsRenderPass : RustRenderPass
{
}


using Rust.RenderPipeline.Runtime;

public class DeferredMeshDecalRenderPass : RustRenderPass
{
}


using Rust.RenderPipeline.Runtime;

public class SpatialEnvironmentVolumeDrawPass : RustRenderPass
{
}


using Rust.RenderPipeline.Runtime;
using UnityEngine;

[CreateAssetMenu(menuName = "Rendering/RustRendererFeatures/SpatialEnvironmentVolume")]
public class SpatialEnvironmentVolumeRendererFeature : RustRendererFeature
{
	[SerializeField]
	private Shader shader;

	[SerializeField]
	private Shader copyToDepthBufferShader;

	[SerializeField]
	private Mesh cubeMesh;

	[SerializeField]
	private Mesh sphereMesh;

	[SerializeField]
	private Mesh capsuleMesh;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	public override void Create()
	{
	}

	public override void AddRenderPasses(RustRenderer renderer)
	{
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteAlways]
public class SpatialBiomeFog : SingletonComponent<SpatialBiomeFog>
{
	public ComputeShader FogMarchShader;

	public ComputeShader AverageAmbientShader;

	public ComputeShader FarFieldAtmosphereShader;

	public ComputeShader VoxelBlurShader;

	public ComputeShader StencilShader;

	public Vector3i Resolution = new Vector3i(128, 128, 32);

	public Vector2i FarFieldResolution = new Vector2i(128, 128);

	public Texture NoiseTexture;

	public float BiomeFogDensityScale = 1f;

	public bool DoVoxelBlur = true;

	public int BlurPasses = 1;

	public float BlurRadius = 1f;

	public int NumDownsamples = 4;

	public float EnvBiomeFogDensity { get; set; } = 1f;

	public float UndergroundFogDensity { get; set; }
}


using UnityEngine;

public class TextureStreaming : SingletonComponent<MonoBehaviour>, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class VolumeClouds : SingletonComponent<VolumeClouds>
{
	public struct NoiseOffsets
	{
		public Vector2 CoverageBase;

		public Vector2 CoverageDetailPerlin;

		public Vector2 CoverageDetailWorley;

		public static NoiseOffsets Default(VolumeCloudsWeatherLayerConfig cfg)
		{
			NoiseOffsets result = default(NoiseOffsets);
			result.CoverageBase.x = cfg.CoverageBase.Offset.x;
			result.CoverageBase.y = cfg.CoverageBase.Offset.y;
			result.CoverageDetailPerlin.x = cfg.CoverageDetailPerlin.Offset.x;
			result.CoverageDetailPerlin.y = cfg.CoverageDetailPerlin.Offset.y;
			result.CoverageDetailWorley.x = cfg.CoverageDetailWorley.Offset.x;
			result.CoverageDetailWorley.y = cfg.CoverageDetailWorley.Offset.y;
			return result;
		}

		private static Vector2 RandVector(ref uint seed)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			float num = SeedRandom.Range(++seed, -100f, 100f);
			float num2 = SeedRandom.Range(++seed, -100f, 100f);
			return new Vector2(num, num2);
		}

		public static NoiseOffsets Random(uint seed)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			NoiseOffsets result = default(NoiseOffsets);
			result.CoverageBase = RandVector(ref seed);
			result.CoverageDetailPerlin = RandVector(ref seed);
			result.CoverageDetailWorley = RandVector(ref seed);
			return result;
		}
	}

	public enum Quality
	{
		Off,
		Low,
		Medium,
		High,
		Ultra,
		COUNT
	}

	public bool UseRandomOffsets = true;

	public VolumeCloudsConfig DefaultConfig;

	public VolumeCloudsCirrusConfig DefaultCirrusConfig;

	[Header("Shaders/Materials")]
	public ComputeShader MarchShader;

	public ComputeShader UpscaleShader;

	public ComputeShader ShadowMapShader;

	public ComputeShader AmbientShader;

	public Quality QualityLevel = Quality.High;

	private bool _cloudsEnabled;

	[Header("Textures")]
	public Texture CurlNoise;

	public Texture DetailNoise;

	public Texture BlueNoise;

	public float WeatherTextureScale = 0.15f;

	public float CirrusWeatherTextureScale = 0.15f;

	public float DetailNoiseScale = 1.3f;

	public float MipDistance = 25000f;

	public float GroundRadius = 60000f;

	public bool SunColorApplyContrast;

	public bool SunColorApplyFogginess;

	private static readonly int PID_DetailNoise = Shader.PropertyToID("_DetailNoise");

	private static readonly int PID_DetailScale = Shader.PropertyToID("_DetailScale");

	private static readonly int PID_Billows = Shader.PropertyToID("_Billows");

	private static readonly int PID_BillowsGamma = Shader.PropertyToID("_BillowsGamma");

	private static readonly int PID_BillowsFrequencyCurve = Shader.PropertyToID("_BillowsFrequencyCurve");

	private static readonly int PID_Wisps = Shader.PropertyToID("_Wisps");

	private static readonly int PID_WispsGamma = Shader.PropertyToID("_WispsGamma");

	private static readonly int PID_WispsFrequencyCurve = Shader.PropertyToID("_WispsFrequencyCurve");

	private static readonly int PID_DetailTypeDensityCurve = Shader.PropertyToID("_DetailTypeDensityCurve");

	private static readonly int PID_DetailTypeHeightTransition = Shader.PropertyToID("_DetailTypeHeightTransition");

	private static readonly int PID_WeatherMap = Shader.PropertyToID("_VolumeCloudsWeatherMap");

	private static readonly int PID_WeatherScale = Shader.PropertyToID("_VolumeCloudsWeatherMapScale");

	private static readonly int PID_Wind = Shader.PropertyToID("_VolumeCloudsWindVector");

	private static readonly int PID_Coverage = Shader.PropertyToID("_Coverage");

	private static readonly int PID_DensityScale = Shader.PropertyToID("_DensityScale");

	private static readonly int PID_DensityCurve = Shader.PropertyToID("_DensityCurve");

	private static readonly int PID_WispsDensitySoftening = Shader.PropertyToID("_WispsDensitySoftening");

	private static readonly int PID_MSIntensity = Shader.PropertyToID("_MSIntensity");

	private static readonly int PID_MSAbsorption = Shader.PropertyToID("_MSAbsorption");

	private static readonly int PID_MSMinDepth = Shader.PropertyToID("_MSMinDepth");

	private static readonly int PID_MSDepthFalloff = Shader.PropertyToID("_MSDepthFalloff");

	private static readonly int PID_Eccentricity = Shader.PropertyToID("_Eccentricity");

	private static readonly int PID_AmbientScatteringFalloff = Shader.PropertyToID("_AmbientScatteringFalloff");

	private static readonly int PID_ScatterBrightnessContrast = Shader.PropertyToID("_ScatterBrightnessContrast");

	private static readonly int PID_Absorption = Shader.PropertyToID("_Absorption");

	private static readonly int PID_CloudTypeTop = Shader.PropertyToID("_CloudTypeTop");

	private static readonly int PID_CloudTypeBottom = Shader.PropertyToID("_CloudTypeBottom");

	private static readonly int PID_MipDistance = Shader.PropertyToID("_MipDistance");

	private static readonly int PID_BlueNoise = Shader.PropertyToID("_BlueNoise");

	private static readonly int PID_CirrusOpaqueness = Shader.PropertyToID("_CirrusOpaqueness");

	private static readonly int PID_CirrusAbsorption = Shader.PropertyToID("_CirrusAbsorption");

	private static readonly int PID_CirrusEccentricity = Shader.PropertyToID("_CirrusEccentricity");

	private static readonly int PID_CirrusWeatherMap = Shader.PropertyToID("_CirrusWeatherMap");

	private static readonly int PID_CirrusWeatherMapScale = Shader.PropertyToID("_CirrusWeatherMapScale");

	private static readonly int PID_OutputTexture = Shader.PropertyToID("_OutputImage");

	private static readonly int PID_OutputImageSize = Shader.PropertyToID("_OutputImageSize");

	private static readonly int PID_CamPos = Shader.PropertyToID("_CamPos");

	private static readonly int PID_VolumeCloudTex = Shader.PropertyToID("_VolumeCloudTex");

	private static readonly int PID_VolumeCloudReflTex = Shader.PropertyToID("_VolumeCloudReflTex");

	private static readonly int PID_CloudTexSize = Shader.PropertyToID("_CloudTexSize");

	private static readonly int PID_FrameCount = Shader.PropertyToID("_FrameCount");

	private static readonly int PID_CamProjInv = Shader.PropertyToID("_CamProjInv");

	private static readonly int PID_StepCount = Shader.PropertyToID("_StepCount");

	private static readonly int PID_StepCountLow = Shader.PropertyToID("_StepCountLow");

	private static readonly int PID_VerticalProfileTopOffset = Shader.PropertyToID("_VerticalProfileTopOffset");

	private static readonly int PID_VerticalProfileTopScale = Shader.PropertyToID("_VerticalProfileTopScale");

	private static readonly int PID_VerticalProfileBottomOffset = Shader.PropertyToID("_VerticalProfileBottomOffset");

	private static readonly int PID_VerticalProfileBottomScale = Shader.PropertyToID("_VerticalProfileBottomScale");

	private static readonly int PID_WeatherScrollOffset = Shader.PropertyToID("_VolumeCloudsWeatherScrollOffset");

	private static readonly int PID_BlueNoiseOffset = Shader.PropertyToID("_BlueNoiseOffset");

	private static readonly int PID_RenderType = Shader.PropertyToID("_RenderType");

	private static readonly int PID_NumRadialLayers = Shader.PropertyToID("_NumRadialLayers");

	private static readonly int PID_LerpT = Shader.PropertyToID("_LerpT");

	private static readonly int PID_LerpSourceImage = Shader.PropertyToID("_LerpSourceImage");

	private static readonly int PID_LerpTargetImage = Shader.PropertyToID("_LerpTargetImage");

	private static readonly int PID_DepthBuffer = Shader.PropertyToID("_CloudDepthBuffer");

	private static readonly int PID_CamInvViewMatrix = Shader.PropertyToID("_CamInvViewMatrix");

	private static readonly int PID_PrevImage = Shader.PropertyToID("_PrevOutputImage");

	private static readonly int PID_LowResBuffer = Shader.PropertyToID("_LowResBuffer");

	private static readonly int PID_SizeDivisor = Shader.PropertyToID("_SizeDivisor");

	private static readonly int PID_ReprojectionMatrix = Shader.PropertyToID("_ReprojectionMatrix");

	private static readonly int PID_FirstFrame = Shader.PropertyToID("_FirstFrame");

	private static readonly int PID_CurrBlockOffsetX = Shader.PropertyToID("_CurrBlockOffsetX");

	private static readonly int PID_CurrBlockOffsetY = Shader.PropertyToID("_CurrBlockOffsetY");

	private static readonly int PID_ShadowInvViewProjMatrix = Shader.PropertyToID("_ShadowInvViewProjMatrix");

	private static readonly int PID_CloudShadowViewProj = Shader.PropertyToID("_CloudShadowViewProj");

	private static readonly int PID_CloudShadowMap = Shader.PropertyToID("_CloudShadowMap");

	private static readonly int PID_CloudShadowNearFar = Shader.PropertyToID("_CloudShadowNearFar");

	private static readonly int PID_SunColorScale = Shader.PropertyToID("_VolumeCloudsSunColorScale");

	private static readonly int PID_MoonColorScale = Shader.PropertyToID("_VolumeCloudsMoonColorScale");

	private static readonly int PID_AmbientColorScale = Shader.PropertyToID("_VolumeCloudsAmbientColorScale");

	private static readonly int PID_AmbientSaturation = Shader.PropertyToID("_VolumeCloudsAmbientSaturation");

	private static readonly int PID_MoonSaturation = Shader.PropertyToID("_VolumeCloudsMoonSaturation");

	private static readonly int PID_VolumeCloudsGroundRadius = Shader.PropertyToID("_VolumeCloudsGroundRadius");

	private static readonly int PID_CloudAmbientLight = Shader.PropertyToID("_CloudAmbientLight");

	private static readonly int PID_WindShear = Shader.PropertyToID("_WindShear");

	private static readonly int PID_ShadowDensityScale = Shader.PropertyToID("_VolumeCloudsShadowDensityScale");

	private static readonly int PID_AtmosphereShadowDensityScale = Shader.PropertyToID("_VolumeCloudsAtmosphereShadowDensityScale");

	private static readonly int PID_CloudHazeDensity = Shader.PropertyToID("_CloudHazeDensity");

	private static readonly int PID_CloudHazeHeightFalloff = Shader.PropertyToID("_CloudHazeHeightFalloff");

	private static readonly int PID_CloudHazeRampStartDistance = Shader.PropertyToID("_CloudHazeRampStartDistance");

	private static readonly int PID_CloudHazeRampEndDistance = Shader.PropertyToID("_CloudHazeRampEndDistance");

	private static readonly int PID_TODLerpValue = Shader.PropertyToID("_TOD_LerpValue");

	private static readonly int PID_HorizonBuffer = Shader.PropertyToID("_HorizonBuffer");

	private static readonly int PID_ApplySunContrast = Shader.PropertyToID("_VCloudsSunContrast");

	private static readonly int PID_ApplySunFogginess = Shader.PropertyToID("_VCloudsSunFogginess");

	private static readonly int PID_DetailScrollOffset = Shader.PropertyToID("_DetailScrollOffset");

	private static readonly int PID_LerpedWeatherTextureCopy = Shader.PropertyToID("_LerpedWeatherTextureCopy");

	private int[,] PID_InstabilityParams;

	private int[,] PID_CoverageBaseParams;

	private int[,] PID_CoverageDetailParams;

	private int[,] PID_CoverageDetailWParams;

	private int[,] PID_RadialLayerParams;

	private int[,] PID_CurlNoiseParams;

	public ComputeShader WeatherGenShader;

	public bool CloudsShouldBeEnabled
	{
		get
		{
			if (QualityLevel != 0)
			{
				return ((Behaviour)this).enabled;
			}
			return false;
		}
	}

	public bool CloudsEnabled => _cloudsEnabled;

	private void FetchShaderPropertyIDs()
	{
		char[] array = new char[4] { 'A', 'B', 'C', 'D' };
		PID_InstabilityParams = new int[4, 3];
		PID_CoverageBaseParams = new int[4, 3];
		PID_CoverageDetailParams = new int[4, 3];
		PID_CoverageDetailWParams = new int[4, 2];
		PID_RadialLayerParams = new int[3, 2];
		PID_CurlNoiseParams = new int[4, 1];
		for (int i = 0; i < 4; i++)
		{
			PID_InstabilityParams[i, 0] = Shader.PropertyToID($"_InstabilityParams{array[i]}0");
			PID_InstabilityParams[i, 1] = Shader.PropertyToID($"_InstabilityParams{array[i]}1");
			PID_InstabilityParams[i, 2] = Shader.PropertyToID($"_InstabilityParams{array[i]}2");
			PID_CoverageBaseParams[i, 0] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}0");
			PID_CoverageBaseParams[i, 1] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}1");
			PID_CoverageBaseParams[i, 2] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}2");
			PID_CoverageDetailParams[i, 0] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}0");
			PID_CoverageDetailParams[i, 1] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}1");
			PID_CoverageDetailParams[i, 2] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}2");
			PID_CoverageDetailWParams[i, 0] = Shader.PropertyToID($"_CoverageDetailWParams{array[i]}0");
			PID_CoverageDetailWParams[i, 1] = Shader.PropertyToID($"_CoverageDetailWParams{array[i]}1");
			PID_CurlNoiseParams[i, 0] = Shader.PropertyToID($"_CurlParams{array[i]}0");
		}
		for (int j = 0; j < 3; j++)
		{
			PID_RadialLayerParams[j, 0] = Shader.PropertyToID($"_RadialLayerParams{array[j]}0");
			PID_RadialLayerParams[j, 1] = Shader.PropertyToID($"_RadialLayerParams{array[j]}1");
		}
	}
}


using UnityEngine;

public struct NoiseOffsets
{
	public Vector2 CoverageBase;

	public Vector2 CoverageDetailPerlin;

	public Vector2 CoverageDetailWorley;

	public static NoiseOffsets Default(VolumeCloudsWeatherLayerConfig cfg)
	{
		NoiseOffsets result = default(NoiseOffsets);
		result.CoverageBase.x = cfg.CoverageBase.Offset.x;
		result.CoverageBase.y = cfg.CoverageBase.Offset.y;
		result.CoverageDetailPerlin.x = cfg.CoverageDetailPerlin.Offset.x;
		result.CoverageDetailPerlin.y = cfg.CoverageDetailPerlin.Offset.y;
		result.CoverageDetailWorley.x = cfg.CoverageDetailWorley.Offset.x;
		result.CoverageDetailWorley.y = cfg.CoverageDetailWorley.Offset.y;
		return result;
	}

	private static Vector2 RandVector(ref uint seed)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		float num = SeedRandom.Range(++seed, -100f, 100f);
		float num2 = SeedRandom.Range(++seed, -100f, 100f);
		return new Vector2(num, num2);
	}

	public static NoiseOffsets Random(uint seed)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		NoiseOffsets result = default(NoiseOffsets);
		result.CoverageBase = RandVector(ref seed);
		result.CoverageDetailPerlin = RandVector(ref seed);
		result.CoverageDetailWorley = RandVector(ref seed);
		return result;
	}
}


public enum Quality
{
	Off,
	Low,
	Medium,
	High,
	Ultra,
	COUNT
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Cirrus Config")]
public class VolumeCloudsCirrusConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig WeatherLayer = new VolumeCloudsWeatherLayerConfig();

	public float Opaqueness = 1f;

	public float Absorption = 0.2f;

	public float Eccentricity = 0.3f;

	public float CloudTextureGamma = 1f;

	public float CloudTextureScale = 1f;

	public void CopyWeatherGen(VolumeCloudsCirrusConfig copy)
	{
		WeatherLayer.CopyFrom(copy.WeatherLayer);
	}

	public void CopyFrom(VolumeCloudsCirrusConfig copy)
	{
		CopyWeatherGen(copy);
		Opaqueness = copy.Opaqueness;
		Absorption = copy.Absorption;
		Eccentricity = copy.Eccentricity;
		CloudTextureGamma = copy.CloudTextureGamma;
		CloudTextureScale = copy.CloudTextureScale;
	}

	public void Lerp(VolumeCloudsCirrusConfig a, VolumeCloudsCirrusConfig b, float t)
	{
		Opaqueness = Mathf.Lerp(a.Opaqueness, b.Opaqueness, t);
		Absorption = Mathf.Lerp(a.Absorption, b.Absorption, t);
		Eccentricity = Mathf.Lerp(a.Eccentricity, b.Eccentricity, t);
		CloudTextureGamma = Mathf.Lerp(a.CloudTextureGamma, b.CloudTextureGamma, t);
		CloudTextureScale = Mathf.Lerp(a.CloudTextureScale, b.CloudTextureScale, t);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Cloud Config")]
public class VolumeCloudsConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig WeatherLayer = new VolumeCloudsWeatherLayerConfig();

	[Header("Detail")]
	[Range(0f, 1f)]
	public float Billows = 1f;

	[Range(0f, 3f)]
	public float BillowsGamma = 2f;

	[Range(0f, 2f)]
	public float BillowsFrequencyCurve = 0.45f;

	[Range(0f, 1f)]
	public float Wisps = 1f;

	[Range(0f, 3f)]
	public float WispsGamma = 2f;

	[Range(0f, 2f)]
	public float WispsFrequencyCurve = 1f;

	[Range(0f, 2f)]
	public float DetailTypeDensityCurve = 0.25f;

	[Range(0.001f, 1f)]
	public float DetailTypeHeightTransition = 0.3f;

	[Range(0f, 2f)]
	public float CurlNoiseScale = 0.2f;

	public float CurlNoiseStrength = 50f;

	[Range(0f, 1f)]
	[Header("Density")]
	public float DensityScale = 0.05f;

	[Range(0f, 1f)]
	public float DensityCurve = 0.4f;

	[Range(0f, 1f)]
	public float WispsDensitySoftening = 0.3f;

	[Header("Multiple Scattering")]
	public float MSIntensity = 1f;

	[Range(0f, 1f)]
	public float MSAbsorption = 0.5f;

	[Range(0f, 2f)]
	public float MSDepthFalloff = 1f;

	[Range(0f, 1f)]
	public float MSMinDepth = 0.01f;

	[Header("Direct Scattering")]
	public Gradient SunColorScale;

	[Range(-1f, 1f)]
	public float SunEccentricity1 = 0.6f;

	[Range(-1f, 1f)]
	public float SunEccentricity2 = 0.2f;

	public Gradient MoonColorScale;

	[Range(-1f, 1f)]
	public float MoonEccentricity1 = 0.9f;

	[Range(-1f, 1f)]
	public float MoonEccentricity2 = 0.2f;

	[Range(0f, 2f)]
	public float MoonSaturation = 1f;

	[Range(0f, 3f)]
	public float DirectScatterBrightness = 1f;

	[Range(0f, 3f)]
	public float DirectScatterContrast = 1f;

	[Range(0f, 2f)]
	public float Absorption = 1f;

	[Header("Ambient Scattering")]
	public Gradient AmbientColorScale;

	[Range(0f, 1f)]
	public float AmbientSaturation = 0.6f;

	[Range(0f, 2f)]
	public float AmbientScatteringFalloff = 1f;

	[Range(0f, 3f)]
	public float AmbientScatterBrightness = 1f;

	[Range(0f, 3f)]
	public float AmbientScatterContrast = 1f;

	[Header("Other")]
	[Range(0f, 1f)]
	public float CoverageScale = 1f;

	[Range(0f, 1f)]
	public float CloudTypeTop = 1f;

	[Range(0f, 1f)]
	public float CloudTypeBottom;

	[Range(0f, 1f)]
	public float VerticalProfileTopEnd = 1f;

	[Range(0f, 1f)]
	public float VerticalProfileTopStart;

	[Range(0f, 1f)]
	public float VerticalProfileBottomStart = 1f;

	[Range(0f, 1f)]
	public float VerticalProfileBottomEnd;

	public float WindShear;

	public Vector2 WindVector = new Vector2(0f, 1f);

	[Range(0f, 1f)]
	public float ShadowDensityScale = 1f;

	[Range(0f, 1f)]
	public float AtmosphereShadowDensityScale = 1f;

	[Min(0f)]
	public float HazeDensity = 1f;

	[Min(0f)]
	public float HazeHeightFalloff = 0.035f;

	[Range(0f, 1f)]
	public float HorizonBuffer;

	public float EvalSunColorScale { get; set; }

	public float EvalMoonColorScale { get; set; }

	public float EvalAmbientColorScale { get; set; }

	public void CopyWeatherGen(VolumeCloudsConfig copy)
	{
		WeatherLayer.CopyFrom(copy.WeatherLayer);
	}

	public void CopyFrom(VolumeCloudsConfig copy)
	{
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		CopyWeatherGen(copy);
		Billows = copy.Billows;
		BillowsGamma = copy.BillowsGamma;
		BillowsFrequencyCurve = copy.BillowsFrequencyCurve;
		Wisps = copy.Wisps;
		WispsGamma = copy.WispsGamma;
		WispsFrequencyCurve = copy.WispsFrequencyCurve;
		DetailTypeDensityCurve = copy.DetailTypeDensityCurve;
		DetailTypeHeightTransition = copy.DetailTypeHeightTransition;
		CurlNoiseScale = copy.CurlNoiseScale;
		CurlNoiseStrength = copy.CurlNoiseStrength;
		DensityScale = copy.DensityScale;
		DensityCurve = copy.DensityCurve;
		WispsDensitySoftening = copy.WispsDensitySoftening;
		SunEccentricity1 = copy.SunEccentricity1;
		SunEccentricity2 = copy.SunEccentricity2;
		AmbientScatteringFalloff = copy.AmbientScatteringFalloff;
		Absorption = copy.Absorption;
		SunColorScale.SetKeys(copy.SunColorScale.colorKeys, copy.SunColorScale.alphaKeys);
		AmbientColorScale.SetKeys(copy.AmbientColorScale.colorKeys, copy.AmbientColorScale.alphaKeys);
		AmbientSaturation = copy.AmbientSaturation;
		CoverageScale = copy.CoverageScale;
		MSIntensity = copy.MSIntensity;
		MSAbsorption = copy.MSAbsorption;
		MSDepthFalloff = copy.MSDepthFalloff;
		MSMinDepth = copy.MSMinDepth;
		CloudTypeTop = copy.CloudTypeTop;
		CloudTypeBottom = copy.CloudTypeBottom;
		MoonColorScale.SetKeys(copy.MoonColorScale.colorKeys, copy.MoonColorScale.alphaKeys);
		MoonEccentricity1 = copy.MoonEccentricity1;
		MoonEccentricity2 = copy.MoonEccentricity2;
		MoonSaturation = copy.MoonSaturation;
		VerticalProfileTopEnd = copy.VerticalProfileTopEnd;
		VerticalProfileTopStart = copy.VerticalProfileTopStart;
		VerticalProfileBottomStart = copy.VerticalProfileBottomStart;
		VerticalProfileBottomEnd = copy.VerticalProfileBottomEnd;
		DirectScatterBrightness = copy.DirectScatterBrightness;
		DirectScatterContrast = copy.DirectScatterContrast;
		AmbientScatterBrightness = copy.AmbientScatterBrightness;
		AmbientScatterContrast = copy.AmbientScatterContrast;
		WindShear = copy.WindShear;
		WindVector = copy.WindVector;
		ShadowDensityScale = copy.ShadowDensityScale;
		AtmosphereShadowDensityScale = copy.AtmosphereShadowDensityScale;
		HazeDensity = copy.HazeDensity;
		HazeHeightFalloff = copy.HazeHeightFalloff;
		HorizonBuffer = copy.HorizonBuffer;
		EvalSunColorScale = copy.EvalSunColorScale;
		EvalMoonColorScale = copy.EvalMoonColorScale;
		EvalAmbientColorScale = copy.EvalAmbientColorScale;
	}

	public void Lerp(VolumeCloudsConfig a, VolumeCloudsConfig b, float t)
	{
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		Billows = Mathf.Lerp(a.Billows, b.Billows, t);
		BillowsGamma = Mathf.Lerp(a.BillowsGamma, b.BillowsGamma, t);
		BillowsFrequencyCurve = Mathf.Lerp(a.BillowsFrequencyCurve, b.BillowsFrequencyCurve, t);
		Wisps = Mathf.Lerp(a.Wisps, b.Wisps, t);
		WispsGamma = Mathf.Lerp(a.WispsGamma, b.WispsGamma, t);
		WispsFrequencyCurve = Mathf.Lerp(a.WispsFrequencyCurve, b.WispsFrequencyCurve, t);
		DetailTypeDensityCurve = Mathf.Lerp(a.DetailTypeDensityCurve, b.DetailTypeDensityCurve, t);
		DetailTypeHeightTransition = Mathf.Lerp(a.DetailTypeHeightTransition, b.DetailTypeHeightTransition, t);
		CurlNoiseScale = Mathf.Lerp(a.CurlNoiseScale, b.CurlNoiseScale, t);
		CurlNoiseStrength = Mathf.Lerp(a.CurlNoiseStrength, b.CurlNoiseStrength, t);
		DensityScale = Mathf.Lerp(a.DensityScale, b.DensityScale, t);
		DensityCurve = Mathf.Lerp(a.DensityCurve, b.DensityCurve, t);
		WispsDensitySoftening = Mathf.Lerp(a.WispsDensitySoftening, b.WispsDensitySoftening, t);
		MSIntensity = Mathf.Lerp(a.MSIntensity, b.MSIntensity, t);
		MSAbsorption = Mathf.Lerp(a.MSAbsorption, b.MSAbsorption, t);
		MSDepthFalloff = Mathf.Lerp(a.MSDepthFalloff, b.MSDepthFalloff, t);
		MSMinDepth = Mathf.Lerp(a.MSMinDepth, b.MSMinDepth, t);
		SunEccentricity1 = Mathf.Lerp(a.SunEccentricity1, b.SunEccentricity1, t);
		SunEccentricity2 = Mathf.Lerp(a.SunEccentricity2, b.SunEccentricity2, t);
		EvalAmbientColorScale = Mathf.Lerp(a.EvalAmbientColorScale, b.EvalAmbientColorScale, t);
		EvalSunColorScale = Mathf.Lerp(a.EvalSunColorScale, b.EvalSunColorScale, t);
		EvalMoonColorScale = Mathf.Lerp(a.EvalMoonColorScale, b.EvalMoonColorScale, t);
		AmbientSaturation = Mathf.Lerp(a.AmbientSaturation, b.AmbientSaturation, t);
		AmbientScatteringFalloff = Mathf.Lerp(a.AmbientScatteringFalloff, b.AmbientScatteringFalloff, t);
		Absorption = Mathf.Lerp(a.Absorption, b.Absorption, t);
		CoverageScale = Mathf.Lerp(a.CoverageScale, b.CoverageScale, t);
		CloudTypeTop = Mathf.Lerp(a.CloudTypeTop, b.CloudTypeTop, t);
		CloudTypeBottom = Mathf.Lerp(a.CloudTypeBottom, b.CloudTypeBottom, t);
		MoonEccentricity1 = Mathf.Lerp(a.MoonEccentricity1, b.MoonEccentricity1, t);
		MoonEccentricity2 = Mathf.Lerp(a.MoonEccentricity2, b.MoonEccentricity2, t);
		MoonSaturation = Mathf.Lerp(a.MoonSaturation, b.MoonSaturation, t);
		DirectScatterBrightness = Mathf.Lerp(a.DirectScatterBrightness, b.DirectScatterBrightness, t);
		DirectScatterContrast = Mathf.Lerp(a.DirectScatterContrast, b.DirectScatterContrast, t);
		AmbientScatterBrightness = Mathf.Lerp(a.AmbientScatterBrightness, b.AmbientScatterBrightness, t);
		AmbientScatterContrast = Mathf.Lerp(a.AmbientScatterContrast, b.AmbientScatterContrast, t);
		VerticalProfileTopStart = Mathf.Lerp(a.VerticalProfileTopStart, b.VerticalProfileTopStart, t);
		VerticalProfileTopEnd = Mathf.Lerp(a.VerticalProfileTopEnd, b.VerticalProfileTopEnd, t);
		VerticalProfileBottomStart = Mathf.Lerp(a.VerticalProfileBottomStart, b.VerticalProfileBottomStart, t);
		VerticalProfileBottomEnd = Mathf.Lerp(a.VerticalProfileBottomEnd, b.VerticalProfileBottomEnd, t);
		WindShear = Mathf.Lerp(a.WindShear, b.WindShear, t);
		WindVector = Vector2.Lerp(a.WindVector, b.WindVector, t);
		ShadowDensityScale = Mathf.Lerp(a.ShadowDensityScale, b.ShadowDensityScale, t);
		AtmosphereShadowDensityScale = Mathf.Lerp(a.AtmosphereShadowDensityScale, b.AtmosphereShadowDensityScale, t);
		HazeDensity = Mathf.Lerp(a.HazeDensity, b.HazeDensity, t);
		HazeHeightFalloff = Mathf.Lerp(a.HazeHeightFalloff, b.HazeHeightFalloff, t);
		HorizonBuffer = Mathf.Lerp(a.HorizonBuffer, b.HorizonBuffer, t);
	}
}


using System;
using System.Text;
using UnityEngine;

[Serializable]
public class VolumeCloudsNoiseLayerConfig
{
	[Range(0f, 6f)]
	public float Ceiling = 1f;

	[Range(-5f, 1f)]
	public float Floor;

	public Vector2 Frequency = Vector2.one;

	public Vector3 Offset = Vector3.zero;

	public int Octaves = 1;

	public float Rotation;

	[Range(0.001f, 10f)]
	public float Exponent = 1f;

	public void CopyFrom(VolumeCloudsNoiseLayerConfig copy)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Floor = copy.Floor;
		Ceiling = copy.Ceiling;
		Frequency = copy.Frequency;
		Offset = copy.Offset;
		Octaves = copy.Octaves;
		Rotation = copy.Rotation;
		Exponent = copy.Exponent;
	}

	public void Lerp(VolumeCloudsNoiseLayerConfig a, VolumeCloudsNoiseLayerConfig b, float t)
	{
		Floor = Mathf.SmoothStep(a.Floor, b.Floor, t);
		Ceiling = Mathf.SmoothStep(a.Ceiling, b.Ceiling, t);
		Frequency.x = Mathf.SmoothStep(a.Frequency.x, b.Frequency.x, t);
		Frequency.y = Mathf.SmoothStep(a.Frequency.y, b.Frequency.y, t);
		Offset.x = Mathf.SmoothStep(a.Offset.x, b.Offset.x, t);
		Offset.y = Mathf.SmoothStep(a.Offset.y, b.Offset.y, t);
		Offset.z = Mathf.SmoothStep(a.Offset.z, b.Offset.z, t);
		Rotation = Mathf.SmoothStep(a.Rotation, b.Rotation, t);
		Exponent = Mathf.SmoothStep(a.Exponent, b.Exponent, t);
	}

	public void Output(StringBuilder sb, Vector2 ofs)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		sb.AppendLine($"Ceiling: {Ceiling}");
		sb.AppendLine($"Floor: {Floor}");
		sb.AppendLine($"Freq: {Frequency}");
		sb.AppendLine($"Offset: {ofs}");
		sb.AppendLine($"Octaves: {Octaves}");
		sb.AppendLine($"Exp: {Exponent}");
	}
}


using System;
using UnityEngine;

[Serializable]
public class VolumeCloudsCurlNoiseConfig
{
	public Vector2 Frequency = Vector2.one;

	public float Strength;

	public int Octaves = 1;

	public void CopyFrom(VolumeCloudsCurlNoiseConfig copy)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Frequency = copy.Frequency;
		Strength = copy.Strength;
		Octaves = copy.Octaves;
	}
}


using System;
using System.Text;

[Serializable]
public class VolumeCloudsWeatherLayerConfig
{
	public VolumeCloudsNoiseLayerConfig Instability = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageBase = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageDetailPerlin = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageDetailWorley = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsCurlNoiseConfig Curl = new VolumeCloudsCurlNoiseConfig();

	public void CopyFrom(VolumeCloudsWeatherLayerConfig copy)
	{
		Instability.CopyFrom(copy.Instability);
		CoverageBase.CopyFrom(copy.CoverageBase);
		CoverageDetailPerlin.CopyFrom(copy.CoverageDetailPerlin);
		CoverageDetailWorley.CopyFrom(copy.CoverageDetailWorley);
		Curl.CopyFrom(copy.Curl);
	}

	public void Output(StringBuilder sb, VolumeClouds.NoiseOffsets ofs)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		sb.AppendLine("Cov base:");
		CoverageBase.Output(sb, ofs.CoverageBase);
		sb.AppendLine("Cov dp:");
		CoverageDetailPerlin.Output(sb, ofs.CoverageDetailPerlin);
		sb.AppendLine("Cov dw:");
		CoverageDetailWorley.Output(sb, ofs.CoverageDetailWorley);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Storm Layer Config")]
public class VolumeCloudsRadialWeatherLayerConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig Weather = new VolumeCloudsWeatherLayerConfig();

	public bool Enabled;

	public float Radius;

	public Vector2 Offset;

	public float Falloff;

	public float Blend;

	public bool FollowCamera;

	public void CopyFrom(VolumeCloudsRadialWeatherLayerConfig copy)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Enabled = copy.Enabled;
		Radius = copy.Radius;
		Offset = copy.Offset;
		Falloff = copy.Falloff;
		Blend = copy.Blend;
		FollowCamera = copy.FollowCamera;
	}
}


using UnityEngine;

public class ClothWindModify : FacepunchBehaviour
{
	public Cloth cloth;

	private Vector3 initialClothForce;

	public Vector3 worldWindScale = Vector3.one;

	public Vector3 turbulenceScale = Vector3.one;
}


using UnityEngine;

[RequireComponent(typeof(WindZone))]
[ExecuteInEditMode]
public class WindZoneEx : MonoBehaviour
{
}


using UnityEngine;

[RequireComponent(typeof(WindZone))]
[ExecuteInEditMode]
public class WindZoneExManager : MonoBehaviour
{
	private enum TestMode
	{
		Disabled,
		Low
	}

	public float maxAccumMain = 4f;

	public float maxAccumTurbulence = 4f;

	public float globalMainScale = 1f;

	public float globalTurbulenceScale = 1f;

	public Transform testPosition;
}


private enum TestMode
{
	Disabled,
	Low
}


public enum RgbColor
{
	Default,
	BuildingPrivilege,
	Cold,
	Hot,
	Hurt,
	Healed,
	Irradiated,
	Comforted
}


using System.ComponentModel;
using UnityEngine;

public class RgbEffects : SingletonComponent<RgbEffects>
{
	[ClientVar(Help = "Enables RGB lighting effects (supports SteelSeries and Razer)", Saved = true)]
	public static bool Enabled = true;

	[ClientVar(Help = "Controls how RGB values are mapped to LED lights on SteelSeries devices", Saved = true)]
	public static Vector3 ColorCorrection_SteelSeries = new Vector3(1.5f, 1.5f, 1.5f);

	[ClientVar(Help = "Controls how RGB values are mapped to LED lights on Razer devices", Saved = true)]
	public static Vector3 ColorCorrection_Razer = new Vector3(3f, 3f, 3f);

	[ClientVar(Help = "Brightness of colors, from 0 to 1 (note: may affect color accuracy)", Saved = true)]
	public static float Brightness = 1f;

	public Color defaultColor;

	public Color buildingPrivilegeColor;

	public Color coldColor;

	public Color hotColor;

	public Color hurtColor;

	public Color healedColor;

	public Color irradiatedColor;

	public Color comfortedColor;

	[EditorBrowsable(EditorBrowsableState.Never)]
	[ClientVar(Name = "static")]
	public static void ConVar_Static(Arg args)
	{
	}

	[ClientVar(Name = "pulse")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static void ConVar_Pulse(Arg args)
	{
	}
}


using System;
using System.Net;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Rust;
using Rust.Platform.Common;

public class RustPlatformHooks : IPlatformHooks
{
	public static readonly RustPlatformHooks Instance = new RustPlatformHooks();

	public uint SteamAppId => Defines.appID;

	public ServerParameters? ServerParameters
	{
		get
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			if (Net.sv == null)
			{
				return null;
			}
			IPAddress iPAddress = null;
			if (!string.IsNullOrEmpty(ConVar.Server.ip))
			{
				iPAddress = IPAddress.Parse(ConVar.Server.ip);
			}
			if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
			{
				ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
			}
			return new ServerParameters("rust", "Rust", 2621.ToString(), Net.sv.secure, CommandLine.HasSwitch("-sdrnet"), iPAddress, (ushort)Net.sv.port, (ushort)ConVar.Server.queryport);
		}
	}

	public void Abort()
	{
		Application.Quit();
	}

	public void OnItemDefinitionsChanged()
	{
		ItemManager.InvalidateWorkshopSkinCache();
	}

	public void AuthSessionValidated(ulong userId, ulong ownerUserId, AuthResponse response, string rawResponse)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnSteamAuth(userId, ownerUserId, rawResponse);
		SingletonComponent<ServerMgr>.Instance.OnValidateAuthTicketResponse(userId, ownerUserId, response);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using ProtoBuf;

public static class CheckItem
{
	private static ItemContainer _testFromContainer;

	private static ItemContainer _testToContainer;

	private static void PrepareTestContainers()
	{
		if (_testFromContainer == null)
		{
			_testFromContainer = new ItemContainer();
		}
		if (_testToContainer == null)
		{
			_testToContainer = new ItemContainer();
		}
		_testFromContainer.Clear();
		_testToContainer.Clear();
	}

	public static bool CanMoveToContainer(ItemContainer from, ItemContainer to)
	{
		PrepareTestContainers();
		if (from == null || to == null)
		{
			return false;
		}
		if (to.IsFull())
		{
			return false;
		}
		if (from.IsEmpty())
		{
			return false;
		}
		ItemContainer container = from.Save(bIncludeContainer: false);
		_testFromContainer.Load(container);
		foreach (Item item in from.itemList)
		{
			_testFromContainer.AddItem(item.info, item.amount, item.skin);
		}
		ItemContainer container2 = to.Save(bIncludeContainer: false);
		_testToContainer.Load(container2);
		foreach (Item item2 in to.itemList)
		{
			_testToContainer.AddItem(item2.info, item2.amount, item2.skin);
		}
		return _testFromContainer.TryMoveAllItems(_testToContainer);
	}

	public static bool CanMoveToContainer(ItemContainer to, List<Item> items)
	{
		PrepareTestContainers();
		if (to == null)
		{
			return false;
		}
		if (to.IsFull())
		{
			return false;
		}
		ItemContainer container = to.Save(bIncludeContainer: false);
		_testToContainer.Load(container);
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			((List<Item>)(object)val).AddRange(to.itemList.Select((Item item) => ItemManager.Create(item.info, item.amount, item.skin)));
			bool result = true;
			foreach (Item item in (List<Item>)(object)val)
			{
				if (!item.MoveToContainer(_testToContainer))
				{
					result = false;
					break;
				}
			}
			int count = ((List<Item>)(object)val).Count;
			while (count-- > 0)
			{
				((List<Item>)(object)val)[count].Remove();
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool CanFitSimple(ItemContainer to, List<Item> items)
	{
		if (to == null || items == null)
		{
			return false;
		}
		if (to.IsFull())
		{
			return false;
		}
		int num = to.capacity - to.itemList.Count;
		int count = items.Count;
		return num >= count;
	}

	public static bool CanFitSimple(ItemContainer to, int numberOfSlots)
	{
		if (to == null)
		{
			return false;
		}
		if (to.IsFull())
		{
			return false;
		}
		return to.capacity - to.itemList.Count >= numberOfSlots;
	}

	public static bool IsVirginItem(Item item)
	{
		return item.parent == null;
	}

	public static bool IsInContainer(Item item)
	{
		return item.parent != null;
	}
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

[RequireComponent(typeof(VideoPlayer))]
public class SafeVideoPlayer : MonoBehaviour
{
	[SerializeField]
	private VideoPlayer _videoPlayer;

	[SerializeField]
	private RawImage _outputImage;

	[SerializeField]
	private string primaryURL;

	[SerializeField]
	private string fallbackURL;
}


using UnityEngine;

public class SendMessageToEntityOnAnimationFinish : StateMachineBehaviour
{
	public string messageToSendToEntity;

	public float repeatRate = 0.1f;

	private const float lastMessageSent = 0f;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (0f + repeatRate > Time.time || animator.IsInTransition(layerIndex) || ((AnimatorStateInfo)(ref stateInfo)).normalizedTime < 1f)
		{
			return;
		}
		for (int i = 0; i < animator.layerCount; i++)
		{
			if (i != layerIndex)
			{
				if (animator.IsInTransition(i))
				{
					return;
				}
				AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(i);
				if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f && ((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 1f)
				{
					return;
				}
			}
		}
		BaseEntity baseEntity = ((Component)animator).gameObject.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			((Component)baseEntity).SendMessage(messageToSendToEntity, (SendMessageOptions)1);
		}
	}
}


public enum AntiHackType
{
	None,
	NoClip,
	SpeedHack,
	FlyHack,
	ProjectileHack,
	MeleeHack,
	EyeHack,
	AttackHack,
	ReloadHack,
	CooldownHack,
	InsideTerrain,
	InsideGeometry,
	EffectHack,
	Ticks
}


