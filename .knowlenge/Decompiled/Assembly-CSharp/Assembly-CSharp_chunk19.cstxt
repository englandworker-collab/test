private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using VLB;

[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam/")]
[ExecuteInEditMode]
[AddComponentMenu("")]
public class BeamGeometry : MonoBehaviour
{
	private VolumetricLightBeam m_Master;

	private Matrix4x4 m_ColorGradientMatrix;

	private MeshType m_CurrentMeshType;

	public MeshRenderer meshRenderer { get; private set; }

	public MeshFilter meshFilter { get; private set; }

	public Material material { get; private set; }

	public Mesh coneMesh { get; private set; }

	public bool visible
	{
		get
		{
			return ((Renderer)meshRenderer).enabled;
		}
		set
		{
			((Renderer)meshRenderer).enabled = value;
		}
	}

	public int sortingLayerID
	{
		get
		{
			return ((Renderer)meshRenderer).sortingLayerID;
		}
		set
		{
			((Renderer)meshRenderer).sortingLayerID = value;
		}
	}

	public int sortingOrder
	{
		get
		{
			return ((Renderer)meshRenderer).sortingOrder;
		}
		set
		{
			((Renderer)meshRenderer).sortingOrder = value;
		}
	}

	private void Start()
	{
	}

	private void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)material))
		{
			Object.DestroyImmediate((Object)(object)material);
			material = null;
		}
	}

	private static bool IsUsingCustomRenderPipeline()
	{
		if (RenderPipelineManager.currentPipeline == null)
		{
			return (Object)(object)GraphicsSettings.renderPipelineAsset != (Object)null;
		}
		return true;
	}

	private void OnEnable()
	{
		if (IsUsingCustomRenderPipeline())
		{
			RenderPipelineManager.beginCameraRendering += OnBeginCameraRendering;
		}
	}

	private void OnDisable()
	{
		if (IsUsingCustomRenderPipeline())
		{
			RenderPipelineManager.beginCameraRendering -= OnBeginCameraRendering;
		}
	}

	public void Initialize(VolumetricLightBeam master, Shader shader)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected O, but got Unknown
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		HideFlags proceduralObjectsHideFlags = Consts.ProceduralObjectsHideFlags;
		m_Master = master;
		((Component)this).transform.SetParent(((Component)master).transform, false);
		material = new Material(shader);
		((Object)material).hideFlags = proceduralObjectsHideFlags;
		meshRenderer = ((Component)this).gameObject.GetOrAddComponent<MeshRenderer>();
		((Object)meshRenderer).hideFlags = proceduralObjectsHideFlags;
		((Renderer)meshRenderer).material = material;
		((Renderer)meshRenderer).shadowCastingMode = (ShadowCastingMode)0;
		((Renderer)meshRenderer).receiveShadows = false;
		((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
		if (SortingLayer.IsValid(m_Master.sortingLayerID))
		{
			sortingLayerID = m_Master.sortingLayerID;
		}
		else
		{
			Debug.LogError((object)$"Beam '{Utils.GetPath(((Component)m_Master).transform)}' has an invalid sortingLayerID ({m_Master.sortingLayerID}). Please fix it by setting a valid layer.");
		}
		sortingOrder = m_Master.sortingOrder;
		meshFilter = ((Component)this).gameObject.GetOrAddComponent<MeshFilter>();
		((Object)meshFilter).hideFlags = proceduralObjectsHideFlags;
		((Object)((Component)this).gameObject).hideFlags = proceduralObjectsHideFlags;
	}

	public void RegenerateMesh()
	{
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
		((Component)this).gameObject.layer = Config.Instance.geometryLayerID;
		((Component)this).gameObject.tag = Config.Instance.geometryTag;
		if (Object.op_Implicit((Object)(object)coneMesh) && m_CurrentMeshType == MeshType.Custom)
		{
			Object.DestroyImmediate((Object)(object)coneMesh);
		}
		m_CurrentMeshType = m_Master.geomMeshType;
		switch (m_Master.geomMeshType)
		{
		case MeshType.Custom:
			coneMesh = MeshGenerator.GenerateConeZ_Radius(1f, 1f, 1f, m_Master.geomCustomSides, m_Master.geomCustomSegments, m_Master.geomCap);
			((Object)coneMesh).hideFlags = Consts.ProceduralObjectsHideFlags;
			meshFilter.mesh = coneMesh;
			break;
		case MeshType.Shared:
			coneMesh = GlobalMesh.mesh;
			meshFilter.sharedMesh = coneMesh;
			break;
		default:
			Debug.LogError((object)"Unsupported MeshType");
			break;
		}
		UpdateMaterialAndBounds();
	}

	private void ComputeLocalMatrix()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(m_Master.coneRadiusStart, m_Master.coneRadiusEnd);
		((Component)this).transform.localScale = new Vector3(num, num, m_Master.fadeEnd);
	}

	public void UpdateMaterialAndBounds()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
		material.renderQueue = Config.Instance.geometryRenderQueue;
		float num = m_Master.coneAngle * (MathF.PI / 180f) / 2f;
		material.SetVector("_ConeSlopeCosSin", Vector4.op_Implicit(new Vector2(Mathf.Cos(num), Mathf.Sin(num))));
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(Mathf.Max(m_Master.coneRadiusStart, 0.0001f), Mathf.Max(m_Master.coneRadiusEnd, 0.0001f));
		material.SetVector("_ConeRadius", Vector4.op_Implicit(val));
		float num2 = Mathf.Sign(m_Master.coneApexOffsetZ) * Mathf.Max(Mathf.Abs(m_Master.coneApexOffsetZ), 0.0001f);
		material.SetFloat("_ConeApexOffsetZ", num2);
		if (m_Master.colorMode == ColorMode.Gradient)
		{
			Utils.FloatPackingPrecision floatPackingPrecision = Utils.GetFloatPackingPrecision();
			material.EnableKeyword((floatPackingPrecision == Utils.FloatPackingPrecision.High) ? "VLB_COLOR_GRADIENT_MATRIX_HIGH" : "VLB_COLOR_GRADIENT_MATRIX_LOW");
			m_ColorGradientMatrix = m_Master.colorGradient.SampleInMatrix((int)floatPackingPrecision);
		}
		else
		{
			material.DisableKeyword("VLB_COLOR_GRADIENT_MATRIX_HIGH");
			material.DisableKeyword("VLB_COLOR_GRADIENT_MATRIX_LOW");
			material.SetColor("_ColorFlat", m_Master.color);
		}
		if (Consts.BlendingMode_AlphaAsBlack[m_Master.blendingModeAsInt])
		{
			material.EnableKeyword("ALPHA_AS_BLACK");
		}
		else
		{
			material.DisableKeyword("ALPHA_AS_BLACK");
		}
		material.SetInt("_BlendSrcFactor", (int)Consts.BlendingMode_SrcFactor[m_Master.blendingModeAsInt]);
		material.SetInt("_BlendDstFactor", (int)Consts.BlendingMode_DstFactor[m_Master.blendingModeAsInt]);
		material.SetFloat("_AlphaInside", m_Master.alphaInside);
		material.SetFloat("_AlphaOutside", m_Master.alphaOutside);
		material.SetFloat("_AttenuationLerpLinearQuad", m_Master.attenuationLerpLinearQuad);
		material.SetFloat("_DistanceFadeStart", m_Master.fadeStart);
		material.SetFloat("_DistanceFadeEnd", m_Master.fadeEnd);
		material.SetFloat("_DistanceCamClipping", m_Master.cameraClippingDistance);
		material.SetFloat("_FresnelPow", Mathf.Max(0.001f, m_Master.fresnelPow));
		material.SetFloat("_GlareBehind", m_Master.glareBehind);
		material.SetFloat("_GlareFrontal", m_Master.glareFrontal);
		material.SetFloat("_DrawCap", (float)(m_Master.geomCap ? 1 : 0));
		if (m_Master.depthBlendDistance > 0f)
		{
			material.EnableKeyword("VLB_DEPTH_BLEND");
			material.SetFloat("_DepthBlendDistance", m_Master.depthBlendDistance);
		}
		else
		{
			material.DisableKeyword("VLB_DEPTH_BLEND");
		}
		if (m_Master.noiseEnabled && m_Master.noiseIntensity > 0f && Noise3D.isSupported)
		{
			Noise3D.LoadIfNeeded();
			material.EnableKeyword("VLB_NOISE_3D");
			material.SetVector("_NoiseLocal", new Vector4(m_Master.noiseVelocityLocal.x, m_Master.noiseVelocityLocal.y, m_Master.noiseVelocityLocal.z, m_Master.noiseScaleLocal));
			material.SetVector("_NoiseParam", Vector4.op_Implicit(new Vector3(m_Master.noiseIntensity, m_Master.noiseVelocityUseGlobal ? 1f : 0f, m_Master.noiseScaleUseGlobal ? 1f : 0f)));
		}
		else
		{
			material.DisableKeyword("VLB_NOISE_3D");
		}
		ComputeLocalMatrix();
	}

	public void SetClippingPlane(Plane planeWS)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((Plane)(ref planeWS)).normal;
		material.EnableKeyword("VLB_CLIPPING_PLANE");
		material.SetVector("_ClippingPlaneWS", new Vector4(normal.x, normal.y, normal.z, ((Plane)(ref planeWS)).distance));
	}

	public void SetClippingPlaneOff()
	{
		material.DisableKeyword("VLB_CLIPPING_PLANE");
	}

	private void OnBeginCameraRendering(ScriptableRenderContext context, Camera cam)
	{
		UpdateCameraRelatedProperties(cam);
	}

	private void OnWillRenderObject()
	{
		if (!IsUsingCustomRenderPipeline())
		{
			Camera current = Camera.current;
			if ((Object)(object)current != (Object)null)
			{
				UpdateCameraRelatedProperties(current);
			}
		}
	}

	private void UpdateCameraRelatedProperties(Camera cam)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)cam) || !Object.op_Implicit((Object)(object)m_Master))
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)material))
		{
			Vector3 val = ((Component)m_Master).transform.InverseTransformPoint(((Component)cam).transform.position);
			material.SetVector("_CameraPosObjectSpace", Vector4.op_Implicit(val));
			Vector3 val2 = ((Component)this).transform.InverseTransformDirection(((Component)cam).transform.forward);
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			float num = (cam.orthographic ? (-1f) : m_Master.GetInsideBeamFactorFromObjectSpacePos(val));
			material.SetVector("_CameraParams", new Vector4(normalized.x, normalized.y, normalized.z, num));
			if (m_Master.colorMode == ColorMode.Gradient)
			{
				material.SetMatrix("_ColorGradientMatrix", m_ColorGradientMatrix);
			}
		}
		if (m_Master.depthBlendDistance > 0f)
		{
			cam.depthTextureMode = (DepthTextureMode)(cam.depthTextureMode | 1);
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;
using VLB;

[HelpURL("http://saladgamer.com/vlb-doc/config/")]
public class Config : ScriptableObject
{
	public int geometryLayerID = 1;

	public string geometryTag = "Untagged";

	public int geometryRenderQueue = 3000;

	public bool forceSinglePass;

	[HighlightNull]
	[SerializeField]
	private Shader beamShader1Pass;

	[FormerlySerializedAs("beamShader")]
	[SerializeField]
	[HighlightNull]
	[FormerlySerializedAs("BeamShader")]
	private Shader beamShader2Pass;

	public int sharedMeshSides = 24;

	public int sharedMeshSegments = 5;

	[Range(0.01f, 2f)]
	public float globalNoiseScale = 0.5f;

	public Vector3 globalNoiseVelocity = Consts.NoiseVelocityDefault;

	[HighlightNull]
	public TextAsset noise3DData;

	public int noise3DSize = 64;

	[HighlightNull]
	public ParticleSystem dustParticlesPrefab;

	private static Config m_Instance;

	public Shader beamShader
	{
		get
		{
			if (!forceSinglePass)
			{
				return beamShader2Pass;
			}
			return beamShader1Pass;
		}
	}

	public Vector4 globalNoiseParam => new Vector4(globalNoiseVelocity.x, globalNoiseVelocity.y, globalNoiseVelocity.z, globalNoiseScale);

	public static Config Instance
	{
		get
		{
			if ((Object)(object)m_Instance == (Object)null)
			{
				Config[] array = Resources.LoadAll<Config>("Config");
				Debug.Assert(array.Length != 0, $"Can't find any resource of type '{typeof(Config)}'. Make sure you have a ScriptableObject of this type in a 'Resources' folder.");
				m_Instance = array[0];
			}
			return m_Instance;
		}
	}

	public void Reset()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		geometryLayerID = 1;
		geometryTag = "Untagged";
		geometryRenderQueue = 3000;
		beamShader1Pass = Shader.Find("Hidden/VolumetricLightBeam1Pass");
		beamShader2Pass = Shader.Find("Hidden/VolumetricLightBeam2Pass");
		sharedMeshSides = 24;
		sharedMeshSegments = 5;
		globalNoiseScale = 0.5f;
		globalNoiseVelocity = Consts.NoiseVelocityDefault;
		ref TextAsset reference = ref noise3DData;
		Object obj = Resources.Load("Noise3D_64x64x64");
		reference = (TextAsset)(object)((obj is TextAsset) ? obj : null);
		noise3DSize = 64;
		ref ParticleSystem reference2 = ref dustParticlesPrefab;
		Object obj2 = Resources.Load("DustParticles", typeof(ParticleSystem));
		reference2 = (ParticleSystem)(object)((obj2 is ParticleSystem) ? obj2 : null);
	}

	public ParticleSystem NewVolumetricDustParticles()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)dustParticlesPrefab))
		{
			if (Application.isPlaying)
			{
				Debug.LogError((object)"Failed to instantiate VolumetricDustParticles prefab.");
			}
			return null;
		}
		ParticleSystem obj = Object.Instantiate<ParticleSystem>(dustParticlesPrefab);
		obj.useAutoRandomSeed = false;
		((Object)obj).name = "Dust Particles";
		((Object)((Component)obj).gameObject).hideFlags = Consts.ProceduralObjectsHideFlags;
		((Component)obj).gameObject.SetActive(true);
		return obj;
	}
}


using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Rendering;
using VLB;

public static class Consts
{
	private const string HelpUrlBase = "http://saladgamer.com/vlb-doc/";

	public const string HelpUrlBeam = "http://saladgamer.com/vlb-doc/comp-lightbeam/";

	public const string HelpUrlDustParticles = "http://saladgamer.com/vlb-doc/comp-dustparticles/";

	public const string HelpUrlDynamicOcclusion = "http://saladgamer.com/vlb-doc/comp-dynocclusion/";

	public const string HelpUrlTriggerZone = "http://saladgamer.com/vlb-doc/comp-triggerzone/";

	public const string HelpUrlConfig = "http://saladgamer.com/vlb-doc/config/";

	public static readonly bool ProceduralObjectsVisibleInEditor = true;

	public static readonly Color FlatColor = Color.white;

	public const ColorMode ColorModeDefault = ColorMode.Flat;

	public const float Alpha = 1f;

	public const float SpotAngleDefault = 35f;

	public const float SpotAngleMin = 0.1f;

	public const float SpotAngleMax = 179.9f;

	public const float ConeRadiusStart = 0.1f;

	public const MeshType GeomMeshType = MeshType.Shared;

	public const int GeomSidesDefault = 18;

	public const int GeomSidesMin = 3;

	public const int GeomSidesMax = 256;

	public const int GeomSegmentsDefault = 5;

	public const int GeomSegmentsMin = 0;

	public const int GeomSegmentsMax = 64;

	public const bool GeomCap = false;

	public const AttenuationEquation AttenuationEquationDefault = AttenuationEquation.Quadratic;

	public const float AttenuationCustomBlending = 0.5f;

	public const float FadeStart = 0f;

	public const float FadeEnd = 3f;

	public const float FadeMinThreshold = 0.01f;

	public const float DepthBlendDistance = 2f;

	public const float CameraClippingDistance = 0.5f;

	public const float FresnelPowMaxValue = 10f;

	public const float FresnelPow = 8f;

	public const float GlareFrontal = 0.5f;

	public const float GlareBehind = 0.5f;

	public const float NoiseIntensityMin = 0f;

	public const float NoiseIntensityMax = 1f;

	public const float NoiseIntensityDefault = 0.5f;

	public const float NoiseScaleMin = 0.01f;

	public const float NoiseScaleMax = 2f;

	public const float NoiseScaleDefault = 0.5f;

	public static readonly Vector3 NoiseVelocityDefault = new Vector3(0.07f, 0.18f, 0.05f);

	public const BlendingMode BlendingModeDefault = BlendingMode.Additive;

	public static readonly BlendMode[] BlendingMode_SrcFactor;

	public static readonly BlendMode[] BlendingMode_DstFactor;

	public static readonly bool[] BlendingMode_AlphaAsBlack;

	public const float DynOcclusionMinSurfaceRatioDefault = 0.5f;

	public const float DynOcclusionMinSurfaceRatioMin = 50f;

	public const float DynOcclusionMinSurfaceRatioMax = 100f;

	public const float DynOcclusionMaxSurfaceDotDefault = 0.25f;

	public const float DynOcclusionMaxSurfaceAngleMin = 45f;

	public const float DynOcclusionMaxSurfaceAngleMax = 90f;

	public const int ConfigGeometryLayerIDDefault = 1;

	public const string ConfigGeometryTagDefault = "Untagged";

	public const RenderQueue ConfigGeometryRenderQueueDefault = RenderQueue.Transparent;

	public const bool ConfigGeometryForceSinglePassDefault = false;

	public const int ConfigNoise3DSizeDefault = 64;

	public const int ConfigSharedMeshSides = 24;

	public const int ConfigSharedMeshSegments = 5;

	public static HideFlags ProceduralObjectsHideFlags
	{
		get
		{
			if (ProceduralObjectsVisibleInEditor)
			{
				return (HideFlags)60;
			}
			return (HideFlags)61;
		}
	}

	static Consts()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BlendMode[] array = new BlendMode[3];
		RuntimeHelpers.InitializeArray(array, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);
		BlendingMode_SrcFactor = (BlendMode[])(object)array;
		BlendMode[] array2 = new BlendMode[3];
		RuntimeHelpers.InitializeArray(array2, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);
		BlendingMode_DstFactor = (BlendMode[])(object)array2;
		BlendingMode_AlphaAsBlack = new bool[3] { true, true, false };
	}
}


using System;
using UnityEngine;
using VLB;

[DisallowMultipleComponent]
[RequireComponent(typeof(VolumetricLightBeam))]
[HelpURL("http://saladgamer.com/vlb-doc/comp-dynocclusion/")]
[ExecuteInEditMode]
public class DynamicOcclusion : MonoBehaviour
{
	private enum Direction
	{
		Up,
		Right,
		Down,
		Left
	}

	public LayerMask layerMask = LayerMask.op_Implicit(-1);

	public float minOccluderArea;

	public int waitFrameCount = 3;

	public float minSurfaceRatio = 0.5f;

	public float maxSurfaceDot = 0.25f;

	public PlaneAlignment planeAlignment;

	public float planeOffset = 0.1f;

	private VolumetricLightBeam m_Master;

	private int m_FrameCountToWait;

	private float m_RangeMultiplier = 1f;

	private uint m_PrevNonSubHitDirectionId;

	private void OnValidate()
	{
		minOccluderArea = Mathf.Max(minOccluderArea, 0f);
		waitFrameCount = Mathf.Clamp(waitFrameCount, 1, 60);
	}

	private void OnEnable()
	{
		m_Master = ((Component)this).GetComponent<VolumetricLightBeam>();
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
	}

	private void OnDisable()
	{
		SetHitNull();
	}

	private void Start()
	{
		if (Application.isPlaying)
		{
			TriggerZone component = ((Component)this).GetComponent<TriggerZone>();
			if (Object.op_Implicit((Object)(object)component))
			{
				m_RangeMultiplier = Mathf.Max(1f, component.rangeMultiplier);
			}
		}
	}

	private void LateUpdate()
	{
		if (m_FrameCountToWait <= 0)
		{
			ProcessRaycasts();
			m_FrameCountToWait = waitFrameCount;
		}
		m_FrameCountToWait--;
	}

	private Vector3 GetRandomVectorAround(Vector3 direction, float angleDiff)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = angleDiff * 0.5f;
		return Quaternion.Euler(Random.Range(0f - num, num), Random.Range(0f - num, num), Random.Range(0f - num, num)) * direction;
	}

	private RaycastHit GetBestHit(Vector3 rayPos, Vector3 rayDir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit[] array = Physics.RaycastAll(rayPos, rayDir, m_Master.fadeEnd * m_RangeMultiplier, ((LayerMask)(ref layerMask)).value);
		int num = -1;
		float num2 = float.MaxValue;
		for (int i = 0; i < array.Length; i++)
		{
			if (!((RaycastHit)(ref array[i])).collider.isTrigger && ((RaycastHit)(ref array[i])).collider.bounds.GetMaxArea2D() >= minOccluderArea && ((RaycastHit)(ref array[i])).distance < num2)
			{
				num2 = ((RaycastHit)(ref array[i])).distance;
				num = i;
			}
		}
		if (num != -1)
		{
			return array[num];
		}
		return default(RaycastHit);
	}

	private Vector3 GetDirection(uint dirInt)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		dirInt %= (uint)Enum.GetValues(typeof(Direction)).Length;
		return (Vector3)(dirInt switch
		{
			0u => ((Component)this).transform.up, 
			1u => ((Component)this).transform.right, 
			2u => -((Component)this).transform.up, 
			3u => -((Component)this).transform.right, 
			_ => Vector3.zero, 
		});
	}

	private bool IsHitValid(RaycastHit hit)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref hit)).collider))
		{
			return Vector3.Dot(((RaycastHit)(ref hit)).normal, -((Component)this).transform.forward) >= maxSurfaceDot;
		}
		return false;
	}

	private void ProcessRaycasts()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit = GetBestHit(((Component)this).transform.position, ((Component)this).transform.forward);
		if (IsHitValid(hit))
		{
			if (minSurfaceRatio > 0.5f)
			{
				for (uint num = 0u; num < (uint)Enum.GetValues(typeof(Direction)).Length; num++)
				{
					Vector3 direction = GetDirection(num + m_PrevNonSubHitDirectionId);
					Vector3 val = ((Component)this).transform.position + direction * m_Master.coneRadiusStart * (minSurfaceRatio * 2f - 1f);
					Vector3 val2 = ((Component)this).transform.position + ((Component)this).transform.forward * m_Master.fadeEnd + direction * m_Master.coneRadiusEnd * (minSurfaceRatio * 2f - 1f);
					RaycastHit bestHit = GetBestHit(val, val2 - val);
					if (IsHitValid(bestHit))
					{
						if (((RaycastHit)(ref bestHit)).distance > ((RaycastHit)(ref hit)).distance)
						{
							hit = bestHit;
						}
						continue;
					}
					m_PrevNonSubHitDirectionId = num;
					SetHitNull();
					return;
				}
			}
			SetHit(hit);
		}
		else
		{
			SetHitNull();
		}
	}

	private void SetHit(RaycastHit hit)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		PlaneAlignment planeAlignment = this.planeAlignment;
		if (planeAlignment != 0 && planeAlignment == PlaneAlignment.Beam)
		{
			SetClippingPlane(new Plane(-((Component)this).transform.forward, ((RaycastHit)(ref hit)).point));
		}
		else
		{
			SetClippingPlane(new Plane(((RaycastHit)(ref hit)).normal, ((RaycastHit)(ref hit)).point));
		}
	}

	private void SetHitNull()
	{
		SetClippingPlaneOff();
	}

	private void SetClippingPlane(Plane planeWS)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		planeWS = planeWS.TranslateCustom(((Plane)(ref planeWS)).normal * planeOffset);
		m_Master.SetClippingPlane(planeWS);
	}

	private void SetClippingPlaneOff()
	{
		m_Master.SetClippingPlaneOff();
	}
}


private enum Direction
{
	Up,
	Right,
	Down,
	Left
}


public enum ColorMode
{
	Flat,
	Gradient
}


public enum AttenuationEquation
{
	Linear,
	Quadratic,
	Blend
}


public enum BlendingMode
{
	Additive,
	SoftAdditive,
	TraditionalTransparency
}


public enum MeshType
{
	Shared,
	Custom
}


public enum RenderQueue
{
	Custom = 0,
	Background = 1000,
	Geometry = 2000,
	AlphaTest = 2450,
	GeometryLast = 2500,
	Transparent = 3000,
	Overlay = 4000
}


public enum PlaneAlignment
{
	Surface,
	Beam
}


using UnityEngine;
using VLB;

public static class GlobalMesh
{
	private static Mesh ms_Mesh;

	public static Mesh mesh
	{
		get
		{
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)ms_Mesh == (Object)null)
			{
				ms_Mesh = MeshGenerator.GenerateConeZ_Radius(1f, 1f, 1f, Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, cap: true);
				((Object)ms_Mesh).hideFlags = Consts.ProceduralObjectsHideFlags;
			}
			return ms_Mesh;
		}
	}
}


using UnityEngine;

public sealed class HighlightNullAttribute : PropertyAttribute
{
}


using System;
using UnityEngine;
using VLB;

public static class MeshGenerator
{
	private const float kMinTruncatedRadius = 0.001f;

	private static bool duplicateBackFaces => Config.Instance.forceSinglePass;

	public static Mesh GenerateConeZ_RadiusAndAngle(float lengthZ, float radiusStart, float coneAngle, int numSides, int numSegments, bool cap)
	{
		Debug.Assert(lengthZ > 0f);
		Debug.Assert(coneAngle > 0f && coneAngle < 180f);
		float radiusEnd = lengthZ * Mathf.Tan(coneAngle * (MathF.PI / 180f) * 0.5f);
		return GenerateConeZ_Radius(lengthZ, radiusStart, radiusEnd, numSides, numSegments, cap);
	}

	public static Mesh GenerateConeZ_Angle(float lengthZ, float coneAngle, int numSides, int numSegments, bool cap)
	{
		return GenerateConeZ_RadiusAndAngle(lengthZ, 0f, coneAngle, numSides, numSegments, cap);
	}

	public static Mesh GenerateConeZ_Radius(float lengthZ, float radiusStart, float radiusEnd, int numSides, int numSegments, bool cap)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(lengthZ > 0f);
		Debug.Assert(radiusStart >= 0f);
		Debug.Assert(numSides >= 3);
		Debug.Assert(numSegments >= 0);
		Mesh val = new Mesh();
		bool flag = false;
		flag = cap && radiusStart > 0f;
		radiusStart = Mathf.Max(radiusStart, 0.001f);
		int num = numSides * (numSegments + 2);
		int num2 = num;
		if (flag)
		{
			num2 += numSides + 1;
		}
		Vector3[] array = (Vector3[])(object)new Vector3[num2];
		for (int i = 0; i < numSides; i++)
		{
			float num3 = MathF.PI * 2f * (float)i / (float)numSides;
			float num4 = Mathf.Cos(num3);
			float num5 = Mathf.Sin(num3);
			for (int j = 0; j < numSegments + 2; j++)
			{
				float num6 = (float)j / (float)(numSegments + 1);
				Debug.Assert(num6 >= 0f && num6 <= 1f);
				float num7 = Mathf.Lerp(radiusStart, radiusEnd, num6);
				array[i + j * numSides] = new Vector3(num7 * num4, num7 * num5, num6 * lengthZ);
			}
		}
		if (flag)
		{
			int num8 = num;
			array[num8] = Vector3.zero;
			num8++;
			for (int k = 0; k < numSides; k++)
			{
				float num9 = MathF.PI * 2f * (float)k / (float)numSides;
				float num10 = Mathf.Cos(num9);
				float num11 = Mathf.Sin(num9);
				array[num8] = new Vector3(radiusStart * num10, radiusStart * num11, 0f);
				num8++;
			}
			Debug.Assert(num8 == array.Length);
		}
		if (!duplicateBackFaces)
		{
			val.vertices = array;
		}
		else
		{
			Vector3[] array2 = (Vector3[])(object)new Vector3[array.Length * 2];
			array.CopyTo(array2, 0);
			array.CopyTo(array2, array.Length);
			val.vertices = array2;
		}
		Vector2[] array3 = (Vector2[])(object)new Vector2[num2];
		int num12 = 0;
		for (int l = 0; l < num; l++)
		{
			array3[num12++] = Vector2.zero;
		}
		if (flag)
		{
			for (int m = 0; m < numSides + 1; m++)
			{
				array3[num12++] = new Vector2(1f, 0f);
			}
		}
		Debug.Assert(num12 == array3.Length);
		if (!duplicateBackFaces)
		{
			val.uv = array3;
		}
		else
		{
			Vector2[] array4 = (Vector2[])(object)new Vector2[array3.Length * 2];
			array3.CopyTo(array4, 0);
			array3.CopyTo(array4, array3.Length);
			for (int n = 0; n < array3.Length; n++)
			{
				Vector2 val2 = array4[n + array3.Length];
				array4[n + array3.Length] = new Vector2(val2.x, 1f);
			}
			val.uv = array4;
		}
		int num13 = numSides * 2 * Mathf.Max(numSegments + 1, 1) * 3;
		if (flag)
		{
			num13 += numSides * 3;
		}
		int[] array5 = new int[num13];
		int num14 = 0;
		for (int num15 = 0; num15 < numSides; num15++)
		{
			int num16 = num15 + 1;
			if (num16 == numSides)
			{
				num16 = 0;
			}
			for (int num17 = 0; num17 < numSegments + 1; num17++)
			{
				int num18 = num17 * numSides;
				array5[num14++] = num18 + num15;
				array5[num14++] = num18 + num16;
				array5[num14++] = num18 + num15 + numSides;
				array5[num14++] = num18 + num16 + numSides;
				array5[num14++] = num18 + num15 + numSides;
				array5[num14++] = num18 + num16;
			}
		}
		if (flag)
		{
			for (int num19 = 0; num19 < numSides - 1; num19++)
			{
				array5[num14++] = num;
				array5[num14++] = num + num19 + 2;
				array5[num14++] = num + num19 + 1;
			}
			array5[num14++] = num;
			array5[num14++] = num + 1;
			array5[num14++] = num + numSides;
		}
		Debug.Assert(num14 == array5.Length);
		if (!duplicateBackFaces)
		{
			val.triangles = array5;
		}
		else
		{
			int[] array6 = new int[array5.Length * 2];
			array5.CopyTo(array6, 0);
			for (int num20 = 0; num20 < array5.Length; num20 += 3)
			{
				array6[array5.Length + num20] = array5[num20] + num2;
				array6[array5.Length + num20 + 1] = array5[num20 + 2] + num2;
				array6[array5.Length + num20 + 2] = array5[num20 + 1] + num2;
			}
			val.triangles = array6;
		}
		Bounds bounds = default(Bounds);
		((Bounds)(ref bounds))..ctor(new Vector3(0f, 0f, lengthZ * 0.5f), new Vector3(Mathf.Max(radiusStart, radiusEnd) * 2f, Mathf.Max(radiusStart, radiusEnd) * 2f, lengthZ));
		val.bounds = bounds;
		Debug.Assert(val.vertexCount == GetVertexCount(numSides, numSegments, flag));
		Debug.Assert(val.triangles.Length == GetIndicesCount(numSides, numSegments, flag));
		return val;
	}

	public static int GetVertexCount(int numSides, int numSegments, bool geomCap)
	{
		Debug.Assert(numSides >= 2);
		Debug.Assert(numSegments >= 0);
		int num = numSides * (numSegments + 2);
		if (geomCap)
		{
			num += numSides + 1;
		}
		if (duplicateBackFaces)
		{
			num *= 2;
		}
		return num;
	}

	public static int GetIndicesCount(int numSides, int numSegments, bool geomCap)
	{
		Debug.Assert(numSides >= 2);
		Debug.Assert(numSegments >= 0);
		int num = numSides * (numSegments + 1) * 2 * 3;
		if (geomCap)
		{
			num += numSides * 3;
		}
		if (duplicateBackFaces)
		{
			num *= 2;
		}
		return num;
	}

	public static int GetSharedMeshVertexCount()
	{
		return GetVertexCount(Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, geomCap: true);
	}

	public static int GetSharedMeshIndicesCount()
	{
		return GetIndicesCount(Config.Instance.sharedMeshSides, Config.Instance.sharedMeshSegments, geomCap: true);
	}
}


using System;
using UnityEngine;
using VLB;

public static class Noise3D
{
	private static bool ms_IsSupportedChecked;

	private static bool ms_IsSupported;

	private static Texture3D ms_NoiseTexture;

	private const HideFlags kHideFlags = 61;

	private const int kMinShaderLevel = 35;

	public static bool isSupported
	{
		get
		{
			if (!ms_IsSupportedChecked)
			{
				ms_IsSupported = SystemInfo.graphicsShaderLevel >= 35;
				if (!ms_IsSupported)
				{
					Debug.LogWarning((object)isNotSupportedString);
				}
				ms_IsSupportedChecked = true;
			}
			return ms_IsSupported;
		}
	}

	public static bool isProperlyLoaded => (Object)(object)ms_NoiseTexture != (Object)null;

	public static string isNotSupportedString => $"3D Noise requires higher shader capabilities (Shader Model 3.5 / OpenGL ES 3.0), which are not available on the current platform: graphicsShaderLevel (current/required) = {SystemInfo.graphicsShaderLevel} / {35}";

	[RuntimeInitializeOnLoadMethod]
	private static void OnStartUp()
	{
		LoadIfNeeded();
	}

	public static void LoadIfNeeded()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (!isSupported)
		{
			return;
		}
		if ((Object)(object)ms_NoiseTexture == (Object)null)
		{
			ms_NoiseTexture = LoadTexture3D(Config.Instance.noise3DData, Config.Instance.noise3DSize);
			if (Object.op_Implicit((Object)(object)ms_NoiseTexture))
			{
				((Object)ms_NoiseTexture).hideFlags = (HideFlags)61;
			}
		}
		Shader.SetGlobalTexture("_VLB_NoiseTex3D", (Texture)(object)ms_NoiseTexture);
		Shader.SetGlobalVector("_VLB_NoiseGlobal", Config.Instance.globalNoiseParam);
	}

	private static Texture3D LoadTexture3D(TextAsset textData, int size)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Expected O, but got Unknown
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)textData == (Object)null)
		{
			Debug.LogErrorFormat("Fail to open Noise 3D Data", Array.Empty<object>());
			return null;
		}
		byte[] bytes = textData.bytes;
		Debug.Assert(bytes != null);
		int num = Mathf.Max(0, size * size * size);
		if (bytes.Length != num)
		{
			Debug.LogErrorFormat("Noise 3D Data file has not the proper size {0}x{0}x{0}", new object[1] { size });
			return null;
		}
		Texture3D val = new Texture3D(size, size, size, (TextureFormat)1, false);
		Color[] array = (Color[])(object)new Color[num];
		for (int i = 0; i < num; i++)
		{
			array[i] = Color32.op_Implicit(new Color32((byte)0, (byte)0, (byte)0, bytes[i]));
		}
		val.SetPixels(array);
		val.Apply();
		return val;
	}
}


using UnityEngine;
using VLB;

[DisallowMultipleComponent]
[RequireComponent(typeof(VolumetricLightBeam))]
[HelpURL("http://saladgamer.com/vlb-doc/comp-triggerzone/")]
public class TriggerZone : MonoBehaviour
{
	public bool setIsTrigger = true;

	public float rangeMultiplier = 1f;

	private const int kMeshColliderNumSides = 8;

	private Mesh m_Mesh;

	private void Update()
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		VolumetricLightBeam component = ((Component)this).GetComponent<VolumetricLightBeam>();
		if (Object.op_Implicit((Object)(object)component))
		{
			MeshCollider orAddComponent = ((Component)this).gameObject.GetOrAddComponent<MeshCollider>();
			Debug.Assert(Object.op_Implicit((Object)(object)orAddComponent));
			float lengthZ = component.fadeEnd * rangeMultiplier;
			float radiusEnd = Mathf.LerpUnclamped(component.coneRadiusStart, component.coneRadiusEnd, rangeMultiplier);
			m_Mesh = MeshGenerator.GenerateConeZ_Radius(lengthZ, component.coneRadiusStart, radiusEnd, 8, 0, cap: false);
			((Object)m_Mesh).hideFlags = Consts.ProceduralObjectsHideFlags;
			orAddComponent.sharedMesh = m_Mesh;
			if (setIsTrigger)
			{
				orAddComponent.convex = true;
				((Collider)orAddComponent).isTrigger = true;
			}
			Object.Destroy((Object)(object)this);
		}
	}
}


using System;
using Unity.Mathematics;
using UnityEngine;
using VLB;

public static class Utils
{
	public enum FloatPackingPrecision
	{
		High = 64,
		Low = 8,
		Undef = 0
	}

	private static FloatPackingPrecision ms_FloatPackingPrecision;

	private const int kFloatPackingHighMinShaderLevel = 35;

	public static string GetPath(Transform current)
	{
		if ((Object)(object)current.parent == (Object)null)
		{
			return "/" + ((Object)current).name;
		}
		return GetPath(current.parent) + "/" + ((Object)current).name;
	}

	public static T NewWithComponent<T>(string name) where T : Component
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return new GameObject(name, new Type[1] { typeof(T) }).GetComponent<T>();
	}

	public static T GetOrAddComponent<T>(this GameObject self) where T : Component
	{
		T val = self.GetComponent<T>();
		if ((Object)(object)val == (Object)null)
		{
			val = self.AddComponent<T>();
		}
		return val;
	}

	public static T GetOrAddComponent<T>(this MonoBehaviour self) where T : Component
	{
		return ((Component)self).gameObject.GetOrAddComponent<T>();
	}

	public static bool HasFlag(this Enum mask, Enum flags)
	{
		return ((int)(object)mask & (int)(object)flags) == (int)(object)flags;
	}

	public static Vector2 xy(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.x, aVector.y);
	}

	public static Vector2 xz(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.x, aVector.z);
	}

	public static Vector2 yz(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.y, aVector.z);
	}

	public static Vector2 yx(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.y, aVector.x);
	}

	public static Vector2 zx(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.z, aVector.x);
	}

	public static Vector2 zy(this Vector3 aVector)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(aVector.z, aVector.y);
	}

	public static float GetVolumeCubic(this Bounds self)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref self)).size.x * ((Bounds)(ref self)).size.y * ((Bounds)(ref self)).size.z;
	}

	public static float GetMaxArea2D(this Bounds self)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Max(Mathf.Max(((Bounds)(ref self)).size.x * ((Bounds)(ref self)).size.y, ((Bounds)(ref self)).size.y * ((Bounds)(ref self)).size.z), ((Bounds)(ref self)).size.x * ((Bounds)(ref self)).size.z);
	}

	public static Color Opaque(this Color self)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return new Color(self.r, self.g, self.b, 1f);
	}

	public static void GizmosDrawPlane(Vector3 normal, Vector3 position, Color color, float size = 1f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(normal, (Mathf.Abs(Vector3.Dot(normal, Vector3.forward)) < 0.999f) ? Vector3.forward : Vector3.up);
		Vector3 val2 = ((Vector3)(ref val)).normalized * size;
		Vector3 val3 = position + val2;
		Vector3 val4 = position - val2;
		val2 = Quaternion.AngleAxis(90f, normal) * val2;
		Vector3 val5 = position + val2;
		Vector3 val6 = position - val2;
		Gizmos.matrix = Matrix4x4.identity;
		Gizmos.color = color;
		Gizmos.DrawLine(val3, val4);
		Gizmos.DrawLine(val5, val6);
		Gizmos.DrawLine(val3, val5);
		Gizmos.DrawLine(val5, val4);
		Gizmos.DrawLine(val4, val6);
		Gizmos.DrawLine(val6, val3);
	}

	public static Plane TranslateCustom(this Plane plane, Vector3 translation)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		((Plane)(ref plane)).distance = ((Plane)(ref plane)).distance + Vector3.Dot(((Vector3)(ref translation)).normalized, ((Plane)(ref plane)).normal) * ((Vector3)(ref translation)).magnitude;
		return plane;
	}

	public static bool IsValid(this Plane plane)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((Plane)(ref plane)).normal;
		return ((Vector3)(ref normal)).sqrMagnitude > 0.5f;
	}

	public static Matrix4x4 SampleInMatrix(this Gradient self, int floatPackingPrecision)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 result = default(Matrix4x4);
		for (int i = 0; i < 16; i++)
		{
			Color color = self.Evaluate(Mathf.Clamp01((float)i / 15f));
			((Matrix4x4)(ref result))[i] = color.PackToFloat(floatPackingPrecision);
		}
		return result;
	}

	public static Color[] SampleInArray(this Gradient self, int samplesCount)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[samplesCount];
		for (int i = 0; i < samplesCount; i++)
		{
			array[i] = self.Evaluate(Mathf.Clamp01((float)i / (float)(samplesCount - 1)));
		}
		return array;
	}

	private static Vector4 Vector4_Floor(Vector4 vec)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4(Mathf.Floor(vec.x), Mathf.Floor(vec.y), Mathf.Floor(vec.z), Mathf.Floor(vec.w));
	}

	public static float4 ToFloat4(this Color color)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new float4(color.r, color.g, color.b, color.a);
	}

	public static float PackToFloat(this Color color, int floatPackingPrecision)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = Vector4_Floor(Color.op_Implicit(color * (float)(floatPackingPrecision - 1)));
		return 0f + val.x * (float)floatPackingPrecision * (float)floatPackingPrecision * (float)floatPackingPrecision + val.y * (float)floatPackingPrecision * (float)floatPackingPrecision + val.z * (float)floatPackingPrecision + val.w;
	}

	public static FloatPackingPrecision GetFloatPackingPrecision()
	{
		if (ms_FloatPackingPrecision == FloatPackingPrecision.Undef)
		{
			ms_FloatPackingPrecision = ((SystemInfo.graphicsShaderLevel >= 35) ? FloatPackingPrecision.High : FloatPackingPrecision.Low);
		}
		return ms_FloatPackingPrecision;
	}

	public static void MarkCurrentSceneDirty()
	{
	}
}


public enum FloatPackingPrecision
{
	High = 64,
	Low = 8,
	Undef = 0
}


public static class Version
{
	public const int Current = 1510;
}


using System;
using UnityEngine;
using VLB;

[ExecuteInEditMode]
[DisallowMultipleComponent]
[RequireComponent(typeof(VolumetricLightBeam))]
[HelpURL("http://saladgamer.com/vlb-doc/comp-dustparticles/")]
public class VolumetricDustParticles : MonoBehaviour
{
	public enum Direction
	{
		Beam,
		Random
	}

	[Range(0f, 1f)]
	public float alpha = 0.5f;

	[Range(0.0001f, 0.1f)]
	public float size = 0.01f;

	public Direction direction = Direction.Random;

	public float speed = 0.03f;

	public float density = 5f;

	[Range(0f, 1f)]
	public float spawnMaxDistance = 0.7f;

	public bool cullingEnabled = true;

	public float cullingMaxDistance = 10f;

	public static bool isFeatureSupported = true;

	private ParticleSystem m_Particles;

	private ParticleSystemRenderer m_Renderer;

	private static bool ms_NoMainCameraLogged = false;

	private static Camera ms_MainCamera = null;

	private VolumetricLightBeam m_Master;

	public bool isCulled { get; private set; }

	public bool particlesAreInstantiated => Object.op_Implicit((Object)(object)m_Particles);

	public int particlesCurrentCount
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)m_Particles))
			{
				return 0;
			}
			return m_Particles.particleCount;
		}
	}

	public int particlesMaxCount
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)m_Particles))
			{
				return 0;
			}
			MainModule main = m_Particles.main;
			return ((MainModule)(ref main)).maxParticles;
		}
	}

	public Camera mainCamera
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)ms_MainCamera))
			{
				ms_MainCamera = Camera.main;
				if (!Object.op_Implicit((Object)(object)ms_MainCamera) && !ms_NoMainCameraLogged)
				{
					Debug.LogErrorFormat((Object)(object)((Component)this).gameObject, "In order to use 'VolumetricDustParticles' culling, you must have a MainCamera defined in your scene.", Array.Empty<object>());
					ms_NoMainCameraLogged = true;
				}
			}
			return ms_MainCamera;
		}
	}

	private void Start()
	{
		isCulled = false;
		m_Master = ((Component)this).GetComponent<VolumetricLightBeam>();
		Debug.Assert(Object.op_Implicit((Object)(object)m_Master));
		InstantiateParticleSystem();
		SetActiveAndPlay();
	}

	private void InstantiateParticleSystem()
	{
		ParticleSystem[] componentsInChildren = ((Component)this).GetComponentsInChildren<ParticleSystem>(true);
		for (int num = componentsInChildren.Length - 1; num >= 0; num--)
		{
			Object.DestroyImmediate((Object)(object)((Component)componentsInChildren[num]).gameObject);
		}
		m_Particles = Config.Instance.NewVolumetricDustParticles();
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			((Component)m_Particles).transform.SetParent(((Component)this).transform, false);
			m_Renderer = ((Component)m_Particles).GetComponent<ParticleSystemRenderer>();
		}
	}

	private void OnEnable()
	{
		SetActiveAndPlay();
	}

	private void SetActiveAndPlay()
	{
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			((Component)m_Particles).gameObject.SetActive(true);
			SetParticleProperties();
			m_Particles.Play(true);
		}
	}

	private void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			((Component)m_Particles).gameObject.SetActive(false);
		}
	}

	private void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)m_Particles))
		{
			Object.DestroyImmediate((Object)(object)((Component)m_Particles).gameObject);
		}
		m_Particles = null;
	}

	private void Update()
	{
		if (Application.isPlaying)
		{
			UpdateCulling();
		}
		SetParticleProperties();
	}

	private void SetParticleProperties()
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Expected O, but got Unknown
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)m_Particles) || !((Component)m_Particles).gameObject.activeSelf)
		{
			return;
		}
		float num = Mathf.Clamp01(1f - m_Master.fresnelPow / 10f);
		float num2 = m_Master.fadeEnd * spawnMaxDistance;
		float num3 = num2 * density;
		int maxParticles = (int)(num3 * 4f);
		MainModule main = m_Particles.main;
		MinMaxCurve startLifetime = ((MainModule)(ref main)).startLifetime;
		((MinMaxCurve)(ref startLifetime)).mode = (ParticleSystemCurveMode)3;
		((MinMaxCurve)(ref startLifetime)).constantMin = 4f;
		((MinMaxCurve)(ref startLifetime)).constantMax = 6f;
		((MainModule)(ref main)).startLifetime = startLifetime;
		MinMaxCurve startSize = ((MainModule)(ref main)).startSize;
		((MinMaxCurve)(ref startSize)).mode = (ParticleSystemCurveMode)3;
		((MinMaxCurve)(ref startSize)).constantMin = size * 0.9f;
		((MinMaxCurve)(ref startSize)).constantMax = size * 1.1f;
		((MainModule)(ref main)).startSize = startSize;
		MinMaxGradient startColor = ((MainModule)(ref main)).startColor;
		if (m_Master.colorMode == ColorMode.Flat)
		{
			((MinMaxGradient)(ref startColor)).mode = (ParticleSystemGradientMode)0;
			Color color = m_Master.color;
			color.a *= alpha;
			((MinMaxGradient)(ref startColor)).color = color;
		}
		else
		{
			((MinMaxGradient)(ref startColor)).mode = (ParticleSystemGradientMode)1;
			Gradient colorGradient = m_Master.colorGradient;
			GradientColorKey[] colorKeys = colorGradient.colorKeys;
			GradientAlphaKey[] alphaKeys = colorGradient.alphaKeys;
			for (int i = 0; i < alphaKeys.Length; i++)
			{
				alphaKeys[i].alpha *= alpha;
			}
			Gradient val = new Gradient();
			val.SetKeys(colorKeys, alphaKeys);
			((MinMaxGradient)(ref startColor)).gradient = val;
		}
		((MainModule)(ref main)).startColor = startColor;
		MinMaxCurve startSpeed = ((MainModule)(ref main)).startSpeed;
		((MinMaxCurve)(ref startSpeed)).constant = speed;
		((MainModule)(ref main)).startSpeed = startSpeed;
		((MainModule)(ref main)).maxParticles = maxParticles;
		ShapeModule shape = m_Particles.shape;
		((ShapeModule)(ref shape)).shapeType = (ParticleSystemShapeType)8;
		((ShapeModule)(ref shape)).radius = m_Master.coneRadiusStart * Mathf.Lerp(0.3f, 1f, num);
		((ShapeModule)(ref shape)).angle = m_Master.coneAngle * 0.5f * Mathf.Lerp(0.7f, 1f, num);
		((ShapeModule)(ref shape)).length = num2;
		((ShapeModule)(ref shape)).arc = 360f;
		((ShapeModule)(ref shape)).randomDirectionAmount = ((direction == Direction.Random) ? 1f : 0f);
		EmissionModule emission = m_Particles.emission;
		MinMaxCurve rateOverTime = ((EmissionModule)(ref emission)).rateOverTime;
		((MinMaxCurve)(ref rateOverTime)).constant = num3;
		((EmissionModule)(ref emission)).rateOverTime = rateOverTime;
		if (Object.op_Implicit((Object)(object)m_Renderer))
		{
			((Renderer)m_Renderer).sortingLayerID = m_Master.sortingLayerID;
			((Renderer)m_Renderer).sortingOrder = m_Master.sortingOrder;
		}
	}

	private void UpdateCulling()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)m_Particles))
		{
			return;
		}
		bool flag = true;
		if (cullingEnabled && m_Master.hasGeometry)
		{
			if (Object.op_Implicit((Object)(object)mainCamera))
			{
				float num = cullingMaxDistance * cullingMaxDistance;
				Bounds bounds = m_Master.bounds;
				flag = ((Bounds)(ref bounds)).SqrDistance(((Component)mainCamera).transform.position) <= num;
			}
			else
			{
				cullingEnabled = false;
			}
		}
		if (((Component)m_Particles).gameObject.activeSelf != flag)
		{
			((Component)m_Particles).gameObject.SetActive(flag);
			isCulled = !flag;
		}
		if (flag && !m_Particles.isPlaying)
		{
			m_Particles.Play();
		}
	}
}


public enum Direction
{
	Beam,
	Random
}


using System;
using System.Collections;
using UnityEngine;
using UnityEngine.Serialization;
using VLB;

[HelpURL("http://saladgamer.com/vlb-doc/comp-lightbeam/")]
[ExecuteInEditMode]
[SelectionBase]
[DisallowMultipleComponent]
public class VolumetricLightBeam : MonoBehaviour
{
	public bool colorFromLight = true;

	public ColorMode colorMode;

	[FormerlySerializedAs("colorValue")]
	[ColorUsage(true, true)]
	public Color color = Consts.FlatColor;

	public Gradient colorGradient;

	[Range(0f, 1f)]
	public float alphaInside = 1f;

	[FormerlySerializedAs("alpha")]
	[Range(0f, 1f)]
	public float alphaOutside = 1f;

	public BlendingMode blendingMode;

	[FormerlySerializedAs("angleFromLight")]
	public bool spotAngleFromLight = true;

	[Range(0.1f, 179.9f)]
	public float spotAngle = 35f;

	[FormerlySerializedAs("radiusStart")]
	public float coneRadiusStart = 0.1f;

	public MeshType geomMeshType;

	[FormerlySerializedAs("geomSides")]
	public int geomCustomSides = 18;

	public int geomCustomSegments = 5;

	public bool geomCap;

	public bool fadeEndFromLight = true;

	public AttenuationEquation attenuationEquation = AttenuationEquation.Quadratic;

	[Range(0f, 1f)]
	public float attenuationCustomBlending = 0.5f;

	public float fadeStart;

	public float fadeEnd = 3f;

	public float depthBlendDistance = 2f;

	public float cameraClippingDistance = 0.5f;

	[Range(0f, 1f)]
	public float glareFrontal = 0.5f;

	[Range(0f, 1f)]
	public float glareBehind = 0.5f;

	[Obsolete("Use 'glareFrontal' instead")]
	public float boostDistanceInside = 0.5f;

	[Obsolete("This property has been merged with 'fresnelPow'")]
	public float fresnelPowInside = 6f;

	[FormerlySerializedAs("fresnelPowOutside")]
	public float fresnelPow = 8f;

	public bool noiseEnabled;

	[Range(0f, 1f)]
	public float noiseIntensity = 0.5f;

	public bool noiseScaleUseGlobal = true;

	[Range(0.01f, 2f)]
	public float noiseScaleLocal = 0.5f;

	public bool noiseVelocityUseGlobal = true;

	public Vector3 noiseVelocityLocal = Consts.NoiseVelocityDefault;

	private Plane m_PlaneWS;

	[SerializeField]
	private int pluginVersion = -1;

	[SerializeField]
	[FormerlySerializedAs("trackChangesDuringPlaytime")]
	private bool _TrackChangesDuringPlaytime;

	[SerializeField]
	private int _SortingLayerID;

	[SerializeField]
	private int _SortingOrder;

	private BeamGeometry m_BeamGeom;

	private Coroutine m_CoPlaytimeUpdate;

	private Light _CachedLight;

	public float coneAngle => Mathf.Atan2(coneRadiusEnd - coneRadiusStart, fadeEnd) * 57.29578f * 2f;

	public float coneRadiusEnd => fadeEnd * Mathf.Tan(spotAngle * (MathF.PI / 180f) * 0.5f);

	public float coneVolume
	{
		get
		{
			float num = coneRadiusStart;
			float num2 = coneRadiusEnd;
			return MathF.PI / 3f * (num * num + num * num2 + num2 * num2) * fadeEnd;
		}
	}

	public float coneApexOffsetZ
	{
		get
		{
			float num = coneRadiusStart / coneRadiusEnd;
			if (num != 1f)
			{
				return fadeEnd * num / (1f - num);
			}
			return float.MaxValue;
		}
	}

	public int geomSides
	{
		get
		{
			if (geomMeshType != MeshType.Custom)
			{
				return Config.Instance.sharedMeshSides;
			}
			return geomCustomSides;
		}
		set
		{
			geomCustomSides = value;
			Debug.LogWarning((object)"The setter VLB.VolumetricLightBeam.geomSides is OBSOLETE and has been renamed to geomCustomSides.");
		}
	}

	public int geomSegments
	{
		get
		{
			if (geomMeshType != MeshType.Custom)
			{
				return Config.Instance.sharedMeshSegments;
			}
			return geomCustomSegments;
		}
		set
		{
			geomCustomSegments = value;
			Debug.LogWarning((object)"The setter VLB.VolumetricLightBeam.geomSegments is OBSOLETE and has been renamed to geomCustomSegments.");
		}
	}

	public float attenuationLerpLinearQuad
	{
		get
		{
			if (attenuationEquation == AttenuationEquation.Linear)
			{
				return 0f;
			}
			if (attenuationEquation == AttenuationEquation.Quadratic)
			{
				return 1f;
			}
			return attenuationCustomBlending;
		}
	}

	public int sortingLayerID
	{
		get
		{
			return _SortingLayerID;
		}
		set
		{
			_SortingLayerID = value;
			if (Object.op_Implicit((Object)(object)m_BeamGeom))
			{
				m_BeamGeom.sortingLayerID = value;
			}
		}
	}

	public string sortingLayerName
	{
		get
		{
			return SortingLayer.IDToName(sortingLayerID);
		}
		set
		{
			sortingLayerID = SortingLayer.NameToID(value);
		}
	}

	public int sortingOrder
	{
		get
		{
			return _SortingOrder;
		}
		set
		{
			_SortingOrder = value;
			if (Object.op_Implicit((Object)(object)m_BeamGeom))
			{
				m_BeamGeom.sortingOrder = value;
			}
		}
	}

	public bool trackChangesDuringPlaytime
	{
		get
		{
			return _TrackChangesDuringPlaytime;
		}
		set
		{
			_TrackChangesDuringPlaytime = value;
			StartPlaytimeUpdateIfNeeded();
		}
	}

	public bool isCurrentlyTrackingChanges => m_CoPlaytimeUpdate != null;

	public bool hasGeometry => (Object)(object)m_BeamGeom != (Object)null;

	public Bounds bounds
	{
		get
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)m_BeamGeom != (Object)null))
			{
				return new Bounds(Vector3.zero, Vector3.zero);
			}
			return ((Renderer)m_BeamGeom.meshRenderer).bounds;
		}
	}

	public int blendingModeAsInt => Mathf.Clamp((int)blendingMode, 0, Enum.GetValues(typeof(BlendingMode)).Length);

	public MeshRenderer Renderer
	{
		get
		{
			if (!((Object)(object)m_BeamGeom != (Object)null))
			{
				return null;
			}
			return m_BeamGeom.meshRenderer;
		}
	}

	public string meshStats
	{
		get
		{
			Mesh val = (Object.op_Implicit((Object)(object)m_BeamGeom) ? m_BeamGeom.coneMesh : null);
			if (Object.op_Implicit((Object)(object)val))
			{
				return $"Cone angle: {coneAngle:0.0} degrees\nMesh: {val.vertexCount} vertices, {val.triangles.Length / 3} triangles";
			}
			return "no mesh available";
		}
	}

	public int meshVerticesCount
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)m_BeamGeom) || !Object.op_Implicit((Object)(object)m_BeamGeom.coneMesh))
			{
				return 0;
			}
			return m_BeamGeom.coneMesh.vertexCount;
		}
	}

	public int meshTrianglesCount
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)m_BeamGeom) || !Object.op_Implicit((Object)(object)m_BeamGeom.coneMesh))
			{
				return 0;
			}
			return m_BeamGeom.coneMesh.triangles.Length / 3;
		}
	}

	private Light lightSpotAttached
	{
		get
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)_CachedLight == (Object)null)
			{
				_CachedLight = ((Component)this).GetComponent<Light>();
			}
			if (Object.op_Implicit((Object)(object)_CachedLight) && (int)_CachedLight.type == 0)
			{
				return _CachedLight;
			}
			return null;
		}
	}

	public void SetClippingPlane(Plane planeWS)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.SetClippingPlane(planeWS);
		}
		m_PlaneWS = planeWS;
	}

	public void SetClippingPlaneOff()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.SetClippingPlaneOff();
		}
		m_PlaneWS = default(Plane);
	}

	public bool IsColliderHiddenByDynamicOccluder(Collider collider)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(Object.op_Implicit((Object)(object)collider), "You should pass a valid Collider to VLB.VolumetricLightBeam.IsColliderHiddenByDynamicOccluder");
		if (!m_PlaneWS.IsValid())
		{
			return false;
		}
		return !GeometryUtility.TestPlanesAABB((Plane[])(object)new Plane[1] { m_PlaneWS }, collider.bounds);
	}

	public float GetInsideBeamFactor(Vector3 posWS)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetInsideBeamFactorFromObjectSpacePos(((Component)this).transform.InverseTransformPoint(posWS));
	}

	public float GetInsideBeamFactorFromObjectSpacePos(Vector3 posOS)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (posOS.z < 0f)
		{
			return -1f;
		}
		Vector2 val = posOS.xy();
		val = new Vector2(((Vector2)(ref val)).magnitude, posOS.z + coneApexOffsetZ);
		Vector2 normalized = ((Vector2)(ref val)).normalized;
		return Mathf.Clamp((Mathf.Abs(Mathf.Sin(coneAngle * (MathF.PI / 180f) / 2f)) - Mathf.Abs(normalized.x)) / 0.1f, -1f, 1f);
	}

	[Obsolete("Use 'GenerateGeometry()' instead")]
	public void Generate()
	{
		GenerateGeometry();
	}

	public virtual void GenerateGeometry()
	{
		HandleBackwardCompatibility(pluginVersion, 1510);
		pluginVersion = 1510;
		ValidateProperties();
		if ((Object)(object)m_BeamGeom == (Object)null)
		{
			Shader beamShader = Config.Instance.beamShader;
			if (!Object.op_Implicit((Object)(object)beamShader))
			{
				Debug.LogError((object)"Invalid BeamShader set in VLB Config");
				return;
			}
			m_BeamGeom = Utils.NewWithComponent<BeamGeometry>("Beam Geometry");
			m_BeamGeom.Initialize(this, beamShader);
		}
		m_BeamGeom.RegenerateMesh();
		m_BeamGeom.visible = ((Behaviour)this).enabled;
	}

	public virtual void UpdateAfterManualPropertyChange()
	{
		ValidateProperties();
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.UpdateMaterialAndBounds();
		}
	}

	private void Start()
	{
		GenerateGeometry();
	}

	private void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.visible = true;
		}
		StartPlaytimeUpdateIfNeeded();
	}

	private void OnDisable()
	{
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			m_BeamGeom.visible = false;
		}
		m_CoPlaytimeUpdate = null;
	}

	private void StartPlaytimeUpdateIfNeeded()
	{
	}

	private IEnumerator CoPlaytimeUpdate()
	{
		while (trackChangesDuringPlaytime && ((Behaviour)this).enabled)
		{
			UpdateAfterManualPropertyChange();
			yield return null;
		}
		m_CoPlaytimeUpdate = null;
	}

	private void OnDestroy()
	{
		DestroyBeam();
	}

	private void DestroyBeam()
	{
		if (Object.op_Implicit((Object)(object)m_BeamGeom))
		{
			Object.DestroyImmediate((Object)(object)((Component)m_BeamGeom).gameObject);
		}
		m_BeamGeom = null;
	}

	private void AssignPropertiesFromSpotLight(Light lightSpot)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)lightSpot) && (int)lightSpot.type == 0)
		{
			if (fadeEndFromLight)
			{
				fadeEnd = lightSpot.range;
			}
			if (spotAngleFromLight)
			{
				spotAngle = lightSpot.spotAngle;
			}
			if (colorFromLight)
			{
				colorMode = ColorMode.Flat;
				color = lightSpot.color;
			}
		}
	}

	private void ClampProperties()
	{
		alphaInside = Mathf.Clamp01(alphaInside);
		alphaOutside = Mathf.Clamp01(alphaOutside);
		attenuationCustomBlending = Mathf.Clamp01(attenuationCustomBlending);
		fadeEnd = Mathf.Max(0.01f, fadeEnd);
		fadeStart = Mathf.Clamp(fadeStart, 0f, fadeEnd - 0.01f);
		spotAngle = Mathf.Clamp(spotAngle, 0.1f, 179.9f);
		coneRadiusStart = Mathf.Max(coneRadiusStart, 0f);
		depthBlendDistance = Mathf.Max(depthBlendDistance, 0f);
		cameraClippingDistance = Mathf.Max(cameraClippingDistance, 0f);
		geomCustomSides = Mathf.Clamp(geomCustomSides, 3, 256);
		geomCustomSegments = Mathf.Clamp(geomCustomSegments, 0, 64);
		fresnelPow = Mathf.Max(0f, fresnelPow);
		glareBehind = Mathf.Clamp01(glareBehind);
		glareFrontal = Mathf.Clamp01(glareFrontal);
		noiseIntensity = Mathf.Clamp(noiseIntensity, 0f, 1f);
	}

	private void ValidateProperties()
	{
		AssignPropertiesFromSpotLight(lightSpotAttached);
		ClampProperties();
	}

	private void HandleBackwardCompatibility(int serializedVersion, int newVersion)
	{
		if (serializedVersion != -1 && serializedVersion != newVersion)
		{
			if (serializedVersion < 1301)
			{
				attenuationEquation = AttenuationEquation.Linear;
			}
			if (serializedVersion < 1501)
			{
				geomMeshType = MeshType.Custom;
				geomCustomSegments = 5;
			}
			Utils.MarkCurrentSceneDirty();
		}
	}
}


using UnityEngine;

public sealed class MinAttribute : PropertyAttribute
{
	public readonly float min;

	public MinAttribute(float min)
	{
		this.min = min;
	}
}


using System;
using Smaa;
using UnityEngine;

[Serializable]
public class PredicationPreset
{
	[Min(0.0001f)]
	public float Threshold = 0.01f;

	[Range(1f, 5f)]
	public float Scale = 2f;

	[Range(0f, 1f)]
	public float Strength = 0.4f;
}


using System;
using Smaa;
using UnityEngine;

[Serializable]
public class Preset
{
	public bool DiagDetection = true;

	public bool CornerDetection = true;

	[Range(0f, 0.5f)]
	public float Threshold = 0.1f;

	[Min(0.0001f)]
	public float DepthThreshold = 0.01f;

	[Range(0f, 112f)]
	public int MaxSearchSteps = 16;

	[Range(0f, 20f)]
	public int MaxSearchStepsDiag = 8;

	[Range(0f, 100f)]
	public int CornerRounding = 25;

	[Min(0f)]
	public float LocalContrastAdaptationFactor = 2f;
}


public enum EdgeDetectionMethod
{
	Luma = 1,
	Color,
	Depth
}


public enum QualityPreset
{
	Low,
	Medium,
	High,
	Ultra,
	Custom
}


public enum DebugPass
{
	Off,
	Edges,
	Weights
}


using Smaa;
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Subpixel Morphological Antialiasing")]
public class SMAA : MonoBehaviour
{
	public DebugPass DebugPass;

	public QualityPreset Quality = QualityPreset.High;

	public EdgeDetectionMethod DetectionMethod = EdgeDetectionMethod.Luma;

	public bool UsePredication;

	public Preset CustomPreset;

	public PredicationPreset CustomPredicationPreset;

	public Shader Shader;

	public Texture2D AreaTex;

	public Texture2D SearchTex;

	protected Camera m_Camera;

	protected Preset m_LowPreset;

	protected Preset m_MediumPreset;

	protected Preset m_HighPreset;

	protected Preset m_UltraPreset;

	protected Material m_Material;

	public Material Material
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Expected O, but got Unknown
			if ((Object)(object)m_Material == (Object)null)
			{
				m_Material = new Material(Shader);
				((Object)m_Material).hideFlags = (HideFlags)61;
			}
			return m_Material;
		}
	}
}


using System;
using UnityEngine;

public class PidController
{
	private const float MaxOutput = 1000f;

	private float _integralMax;

	private float _integral;

	private float _kp;

	private float _ki;

	private float _kd;

	public float Kp
	{
		get
		{
			return _kp;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kp must be a non-negative number.");
			}
			_kp = value;
		}
	}

	public float Ki
	{
		get
		{
			return _ki;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Ki must be a non-negative number.");
			}
			_ki = value;
			_integralMax = 1000f / Ki;
			_integral = Mathf.Clamp(_integral, 0f - _integralMax, _integralMax);
		}
	}

	public float Kd
	{
		get
		{
			return _kd;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kd must be a non-negative number.");
			}
			_kd = value;
		}
	}

	public PidController(float kp, float ki, float kd)
	{
		if (kp < 0f)
		{
			throw new ArgumentOutOfRangeException("kp", "kp must be a non-negative number.");
		}
		if (ki < 0f)
		{
			throw new ArgumentOutOfRangeException("ki", "ki must be a non-negative number.");
		}
		if (kd < 0f)
		{
			throw new ArgumentOutOfRangeException("kd", "kd must be a non-negative number.");
		}
		Kp = kp;
		Ki = ki;
		Kd = kd;
		_integralMax = 1000f / Ki;
	}

	public float ComputeOutput(float error, float delta, float deltaTime)
	{
		_integral += error * deltaTime;
		_integral = Mathf.Clamp(_integral, 0f - _integralMax, _integralMax);
		float num = delta / deltaTime;
		return Mathf.Clamp(Kp * error + Ki * _integral + Kd * num, -1000f, 1000f);
	}
}


using System;
using UnityEngine;
using VacuumBreather;

public class PidQuaternionController
{
	private readonly PidController[] _internalController;

	public float Kp
	{
		get
		{
			return _internalController[0].Kp;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kp must be a non-negative number.");
			}
			_internalController[0].Kp = value;
			_internalController[1].Kp = value;
			_internalController[2].Kp = value;
			_internalController[3].Kp = value;
		}
	}

	public float Ki
	{
		get
		{
			return _internalController[0].Ki;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Ki must be a non-negative number.");
			}
			_internalController[0].Ki = value;
			_internalController[1].Ki = value;
			_internalController[2].Ki = value;
			_internalController[3].Ki = value;
		}
	}

	public float Kd
	{
		get
		{
			return _internalController[0].Kd;
		}
		set
		{
			if (value < 0f)
			{
				throw new ArgumentOutOfRangeException("value", "Kd must be a non-negative number.");
			}
			_internalController[0].Kd = value;
			_internalController[1].Kd = value;
			_internalController[2].Kd = value;
			_internalController[3].Kd = value;
		}
	}

	public PidQuaternionController(float kp, float ki, float kd)
	{
		if (kp < 0f)
		{
			throw new ArgumentOutOfRangeException("kp", "kp must be a non-negative number.");
		}
		if (ki < 0f)
		{
			throw new ArgumentOutOfRangeException("ki", "ki must be a non-negative number.");
		}
		if (kd < 0f)
		{
			throw new ArgumentOutOfRangeException("kd", "kd must be a non-negative number.");
		}
		_internalController = new PidController[4]
		{
			new PidController(kp, ki, kd),
			new PidController(kp, ki, kd),
			new PidController(kp, ki, kd),
			new PidController(kp, ki, kd)
		};
	}

	public static Quaternion MultiplyAsVector(Matrix4x4 matrix, Quaternion quaternion)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(quaternion.w, quaternion.x, quaternion.y, quaternion.z);
		Vector4 val2 = matrix * val;
		return new Quaternion(val2.y, val2.z, val2.w, val2.x);
	}

	public static Quaternion ToEulerAngleQuaternion(Vector3 eulerAngles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return new Quaternion(eulerAngles.x, eulerAngles.y, eulerAngles.z, 0f);
	}

	public Vector3 ComputeRequiredAngularAcceleration(Quaternion currentOrientation, Quaternion desiredOrientation, Vector3 currentAngularVelocity, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = QuaternionExtensions.RequiredRotation(currentOrientation, desiredOrientation);
		Quaternion error = Quaternion.identity.Subtract(val);
		Quaternion delta = ToEulerAngleQuaternion(currentAngularVelocity) * val;
		Matrix4x4 val2 = default(Matrix4x4);
		val2.m00 = (0f - val.x) * (0f - val.x) + (0f - val.y) * (0f - val.y) + (0f - val.z) * (0f - val.z);
		val2.m01 = (0f - val.x) * val.w + (0f - val.y) * (0f - val.z) + (0f - val.z) * val.y;
		val2.m02 = (0f - val.x) * val.z + (0f - val.y) * val.w + (0f - val.z) * (0f - val.x);
		val2.m03 = (0f - val.x) * (0f - val.y) + (0f - val.y) * val.x + (0f - val.z) * val.w;
		val2.m10 = val.w * (0f - val.x) + (0f - val.z) * (0f - val.y) + val.y * (0f - val.z);
		val2.m11 = val.w * val.w + (0f - val.z) * (0f - val.z) + val.y * val.y;
		val2.m12 = val.w * val.z + (0f - val.z) * val.w + val.y * (0f - val.x);
		val2.m13 = val.w * (0f - val.y) + (0f - val.z) * val.x + val.y * val.w;
		val2.m20 = val.z * (0f - val.x) + val.w * (0f - val.y) + (0f - val.x) * (0f - val.z);
		val2.m21 = val.z * val.w + val.w * (0f - val.z) + (0f - val.x) * val.y;
		val2.m22 = val.z * val.z + val.w * val.w + (0f - val.x) * (0f - val.x);
		val2.m23 = val.z * (0f - val.y) + val.w * val.x + (0f - val.x) * val.w;
		val2.m30 = (0f - val.y) * (0f - val.x) + val.x * (0f - val.y) + val.w * (0f - val.z);
		val2.m31 = (0f - val.y) * val.w + val.x * (0f - val.z) + val.w * val.y;
		val2.m32 = (0f - val.y) * val.z + val.x * val.w + val.w * (0f - val.x);
		val2.m33 = (0f - val.y) * (0f - val.y) + val.x * val.x + val.w * val.w;
		Matrix4x4 matrix = val2;
		Quaternion quaternion = ComputeOutput(error, delta, deltaTime);
		quaternion = MultiplyAsVector(matrix, quaternion);
		Quaternion val3 = quaternion.Multiply(-2f) * Quaternion.Inverse(val);
		return new Vector3(val3.x, val3.y, val3.z);
	}

	private Quaternion ComputeOutput(Quaternion error, Quaternion delta, float deltaTime)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion result = default(Quaternion);
		result.x = _internalController[0].ComputeOutput(error.x, delta.x, deltaTime);
		result.y = _internalController[1].ComputeOutput(error.y, delta.y, deltaTime);
		result.z = _internalController[2].ComputeOutput(error.z, delta.z, deltaTime);
		result.w = _internalController[3].ComputeOutput(error.w, delta.w, deltaTime);
		return result;
	}
}


using UnityEngine;

public static class QuaternionExtensions
{
	public static Quaternion Multiply(this Quaternion quaternion, float scalar)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Quaternion((float)((double)quaternion.x * (double)scalar), (float)((double)quaternion.y * (double)scalar), (float)((double)quaternion.z * (double)scalar), (float)((double)quaternion.w * (double)scalar));
	}

	public static Quaternion RequiredRotation(Quaternion from, Quaternion to)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = to * Quaternion.Inverse(from);
		if (val.w < 0f)
		{
			val.x *= -1f;
			val.y *= -1f;
			val.z *= -1f;
			val.w *= -1f;
		}
		return val;
	}

	public static Quaternion Subtract(this Quaternion lhs, Quaternion rhs)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		return new Quaternion((float)((double)lhs.x - (double)rhs.x), (float)((double)lhs.y - (double)rhs.y), (float)((double)lhs.z - (double)rhs.z), (float)((double)lhs.w - (double)rhs.w));
	}
}


using System;
using AmplifyOcclusion;
using UnityEngine;

[Serializable]
public class VersionInfo
{
	public const byte Major = 2;

	public const byte Minor = 0;

	public const byte Release = 0;

	private static string StageSuffix = "_dev002";

	[SerializeField]
	private int m_major;

	[SerializeField]
	private int m_minor;

	[SerializeField]
	private int m_release;

	public int Number => m_major * 100 + m_minor * 10 + m_release;

	public static string StaticToString()
	{
		return $"{(byte)2}.{(byte)0}.{(byte)0}" + StageSuffix;
	}

	public override string ToString()
	{
		return $"{m_major}.{m_minor}.{m_release}" + StageSuffix;
	}

	private VersionInfo()
	{
		m_major = 2;
		m_minor = 0;
		m_release = 0;
	}

	private VersionInfo(byte major, byte minor, byte release)
	{
		m_major = major;
		m_minor = minor;
		m_release = release;
	}

	public static VersionInfo Current()
	{
		return new VersionInfo(2, 0, 0);
	}

	public static bool Matches(VersionInfo version)
	{
		if (2 == version.m_major && version.m_minor == 0)
		{
			return version.m_release == 0;
		}
		return false;
	}
}


using System;
using System.IO;
using System.Text;
using TinyJSON;

public sealed class Decoder : IDisposable
{
	private enum Token
	{
		None,
		OpenBrace,
		CloseBrace,
		OpenBracket,
		CloseBracket,
		Colon,
		Comma,
		String,
		Number,
		True,
		False,
		Null
	}

	private const string whiteSpace = " \t\n\r";

	private const string wordBreak = " \t\n\r{}[],:\"";

	private StringReader json;

	private char PeekChar
	{
		get
		{
			int num = json.Peek();
			if (num != -1)
			{
				return Convert.ToChar(num);
			}
			return '\0';
		}
	}

	private char NextChar => Convert.ToChar(json.Read());

	private string NextWord
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			while (" \t\n\r{}[],:\"".IndexOf(PeekChar) == -1)
			{
				stringBuilder.Append(NextChar);
				if (json.Peek() == -1)
				{
					break;
				}
			}
			return stringBuilder.ToString();
		}
	}

	private Token NextToken
	{
		get
		{
			ConsumeWhiteSpace();
			if (json.Peek() == -1)
			{
				return Token.None;
			}
			switch (PeekChar)
			{
			case '{':
				return Token.OpenBrace;
			case '}':
				json.Read();
				return Token.CloseBrace;
			case '[':
				return Token.OpenBracket;
			case ']':
				json.Read();
				return Token.CloseBracket;
			case ',':
				json.Read();
				return Token.Comma;
			case '"':
				return Token.String;
			case ':':
				return Token.Colon;
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				return Token.Number;
			default:
				return NextWord switch
				{
					"false" => Token.False, 
					"true" => Token.True, 
					"null" => Token.Null, 
					_ => Token.None, 
				};
			}
		}
	}

	private Decoder(string jsonString)
	{
		json = new StringReader(jsonString);
	}

	public static Variant Decode(string jsonString)
	{
		using TinyJSON.Decoder decoder = new TinyJSON.Decoder(jsonString);
		return decoder.DecodeValue();
	}

	public void Dispose()
	{
		json.Dispose();
		json = null;
	}

	private ProxyObject DecodeObject()
	{
		ProxyObject proxyObject = new ProxyObject();
		json.Read();
		while (true)
		{
			switch (NextToken)
			{
			case Token.Comma:
				continue;
			case Token.None:
				return null;
			case Token.CloseBrace:
				return proxyObject;
			}
			string text = DecodeString();
			if (text == null)
			{
				return null;
			}
			if (NextToken != Token.Colon)
			{
				return null;
			}
			json.Read();
			proxyObject.Add(text, DecodeValue());
		}
	}

	private ProxyArray DecodeArray()
	{
		ProxyArray proxyArray = new ProxyArray();
		json.Read();
		bool flag = true;
		while (flag)
		{
			Token nextToken = NextToken;
			switch (nextToken)
			{
			case Token.None:
				return null;
			case Token.CloseBracket:
				flag = false;
				break;
			default:
				proxyArray.Add(DecodeByToken(nextToken));
				break;
			case Token.Comma:
				break;
			}
		}
		return proxyArray;
	}

	private Variant DecodeValue()
	{
		Token nextToken = NextToken;
		return DecodeByToken(nextToken);
	}

	private Variant DecodeByToken(Token token)
	{
		return token switch
		{
			Token.String => DecodeString(), 
			Token.Number => DecodeNumber(), 
			Token.OpenBrace => DecodeObject(), 
			Token.OpenBracket => DecodeArray(), 
			Token.True => new ProxyBoolean(value: true), 
			Token.False => new ProxyBoolean(value: false), 
			Token.Null => null, 
			_ => null, 
		};
	}

	private Variant DecodeString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		json.Read();
		bool flag = true;
		while (flag)
		{
			if (json.Peek() == -1)
			{
				flag = false;
				break;
			}
			char nextChar = NextChar;
			switch (nextChar)
			{
			case '"':
				flag = false;
				break;
			case '\\':
				if (json.Peek() == -1)
				{
					flag = false;
					break;
				}
				nextChar = NextChar;
				switch (nextChar)
				{
				case '"':
				case '/':
				case '\\':
					stringBuilder.Append(nextChar);
					break;
				case 'b':
					stringBuilder.Append('\b');
					break;
				case 'f':
					stringBuilder.Append('\f');
					break;
				case 'n':
					stringBuilder.Append('\n');
					break;
				case 'r':
					stringBuilder.Append('\r');
					break;
				case 't':
					stringBuilder.Append('\t');
					break;
				case 'u':
				{
					StringBuilder stringBuilder2 = new StringBuilder();
					for (int i = 0; i < 4; i++)
					{
						stringBuilder2.Append(NextChar);
					}
					stringBuilder.Append((char)Convert.ToInt32(stringBuilder2.ToString(), 16));
					break;
				}
				}
				break;
			default:
				stringBuilder.Append(nextChar);
				break;
			}
		}
		return new ProxyString(stringBuilder.ToString());
	}

	private Variant DecodeNumber()
	{
		return new ProxyNumber(NextWord);
	}

	private void ConsumeWhiteSpace()
	{
		while (" \t\n\r".IndexOf(PeekChar) != -1)
		{
			json.Read();
			if (json.Peek() == -1)
			{
				break;
			}
		}
	}
}


private enum Token
{
	None,
	OpenBrace,
	CloseBrace,
	OpenBracket,
	CloseBracket,
	Colon,
	Comma,
	String,
	Number,
	True,
	False,
	Null
}


using System;

[Flags]
public enum EncodeOptions
{
	None = 0,
	PrettyPrint = 1,
	NoTypeHints = 2,
	IncludePublicProperties = 4,
	EnforceHierarchyOrder = 8,
	[Obsolete("Use EncodeOptions.EnforceHierarchyOrder instead.")]
	EnforceHeirarchyOrder = 8
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Text;
using TinyJSON;

public sealed class Encoder
{
	private static readonly Type includeAttrType = typeof(Include);

	private static readonly Type excludeAttrType = typeof(Exclude);

	private static readonly Type typeHintAttrType = typeof(TypeHint);

	private readonly StringBuilder builder;

	private readonly EncodeOptions options;

	private int indent;

	private bool PrettyPrintEnabled => (options & EncodeOptions.PrettyPrint) == EncodeOptions.PrettyPrint;

	private bool TypeHintsEnabled => (options & EncodeOptions.NoTypeHints) != EncodeOptions.NoTypeHints;

	private bool IncludePublicPropertiesEnabled => (options & EncodeOptions.IncludePublicProperties) == EncodeOptions.IncludePublicProperties;

	private bool EnforceHierarchyOrderEnabled => (options & EncodeOptions.EnforceHierarchyOrder) == EncodeOptions.EnforceHierarchyOrder;

	private Encoder(EncodeOptions options)
	{
		this.options = options;
		builder = new StringBuilder();
		indent = 0;
	}

	public static string Encode(object obj)
	{
		return Encode(obj, EncodeOptions.None);
	}

	public static string Encode(object obj, EncodeOptions options)
	{
		TinyJSON.Encoder encoder = new TinyJSON.Encoder(options);
		encoder.EncodeValue(obj, forceTypeHint: false);
		return encoder.builder.ToString();
	}

	private void EncodeValue(object value, bool forceTypeHint)
	{
		if (value == null)
		{
			builder.Append("null");
		}
		else if (value is string)
		{
			EncodeString((string)value);
		}
		else if (value is ProxyString)
		{
			EncodeString(((ProxyString)value).ToString(CultureInfo.InvariantCulture));
		}
		else if (value is char)
		{
			EncodeString(value.ToString());
		}
		else if (value is bool)
		{
			builder.Append(((bool)value) ? "true" : "false");
		}
		else if (value is Enum)
		{
			EncodeString(value.ToString());
		}
		else if (value is Array)
		{
			EncodeArray((Array)value, forceTypeHint);
		}
		else if (value is IList)
		{
			EncodeList((IList)value, forceTypeHint);
		}
		else if (value is IDictionary)
		{
			EncodeDictionary((IDictionary)value, forceTypeHint);
		}
		else if (value is Guid)
		{
			EncodeString(value.ToString());
		}
		else if (value is ProxyArray)
		{
			EncodeProxyArray((ProxyArray)value);
		}
		else if (value is ProxyObject)
		{
			EncodeProxyObject((ProxyObject)value);
		}
		else if (value is float || value is double || value is int || value is uint || value is long || value is sbyte || value is byte || value is short || value is ushort || value is ulong || value is decimal || value is ProxyBoolean || value is ProxyNumber)
		{
			builder.Append(Convert.ToString(value, CultureInfo.InvariantCulture));
		}
		else
		{
			EncodeObject(value, forceTypeHint);
		}
	}

	private IEnumerable<FieldInfo> GetFieldsForType(Type type)
	{
		if (EnforceHierarchyOrderEnabled)
		{
			Stack<Type> stack = new Stack<Type>();
			while (type != null)
			{
				stack.Push(type);
				type = type.BaseType;
			}
			List<FieldInfo> list = new List<FieldInfo>();
			while (stack.Count > 0)
			{
				list.AddRange(stack.Pop().GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			}
			return list;
		}
		return type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	private IEnumerable<PropertyInfo> GetPropertiesForType(Type type)
	{
		if (EnforceHierarchyOrderEnabled)
		{
			Stack<Type> stack = new Stack<Type>();
			while (type != null)
			{
				stack.Push(type);
				type = type.BaseType;
			}
			List<PropertyInfo> list = new List<PropertyInfo>();
			while (stack.Count > 0)
			{
				list.AddRange(stack.Pop().GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			}
			return list;
		}
		return type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	}

	private void EncodeObject(object value, bool forceTypeHint)
	{
		Type type = value.GetType();
		AppendOpenBrace();
		forceTypeHint = forceTypeHint || TypeHintsEnabled;
		bool includePublicPropertiesEnabled = IncludePublicPropertiesEnabled;
		bool firstItem = !forceTypeHint;
		if (forceTypeHint)
		{
			if (PrettyPrintEnabled)
			{
				AppendIndent();
			}
			EncodeString("@type");
			AppendColon();
			EncodeString(type.FullName);
			firstItem = false;
		}
		foreach (FieldInfo item in GetFieldsForType(type))
		{
			bool forceTypeHint2 = false;
			bool flag = item.IsPublic;
			object[] customAttributes = item.GetCustomAttributes(inherit: true);
			foreach (object o in customAttributes)
			{
				if (excludeAttrType.IsInstanceOfType(o))
				{
					flag = false;
				}
				if (includeAttrType.IsInstanceOfType(o))
				{
					flag = true;
				}
				if (typeHintAttrType.IsInstanceOfType(o))
				{
					forceTypeHint2 = true;
				}
			}
			if (flag)
			{
				AppendComma(firstItem);
				EncodeString(item.Name);
				AppendColon();
				EncodeValue(item.GetValue(value), forceTypeHint2);
				firstItem = false;
			}
		}
		foreach (PropertyInfo item2 in GetPropertiesForType(type))
		{
			if (!item2.CanRead)
			{
				continue;
			}
			bool forceTypeHint3 = false;
			bool flag2 = includePublicPropertiesEnabled;
			object[] customAttributes = item2.GetCustomAttributes(inherit: true);
			foreach (object o2 in customAttributes)
			{
				if (excludeAttrType.IsInstanceOfType(o2))
				{
					flag2 = false;
				}
				if (includeAttrType.IsInstanceOfType(o2))
				{
					flag2 = true;
				}
				if (typeHintAttrType.IsInstanceOfType(o2))
				{
					forceTypeHint3 = true;
				}
			}
			if (flag2)
			{
				AppendComma(firstItem);
				EncodeString(item2.Name);
				AppendColon();
				EncodeValue(item2.GetValue(value, null), forceTypeHint3);
				firstItem = false;
			}
		}
		AppendCloseBrace();
	}

	private void EncodeProxyArray(ProxyArray value)
	{
		if (value.Count == 0)
		{
			builder.Append("[]");
			return;
		}
		AppendOpenBracket();
		bool firstItem = true;
		foreach (Variant item in (IEnumerable<Variant>)value)
		{
			AppendComma(firstItem);
			EncodeValue(item, forceTypeHint: false);
			firstItem = false;
		}
		AppendCloseBracket();
	}

	private void EncodeProxyObject(ProxyObject value)
	{
		if (value.Count == 0)
		{
			builder.Append("{}");
			return;
		}
		AppendOpenBrace();
		bool firstItem = true;
		foreach (string key in value.Keys)
		{
			AppendComma(firstItem);
			EncodeString(key);
			AppendColon();
			EncodeValue(value[key], forceTypeHint: false);
			firstItem = false;
		}
		AppendCloseBrace();
	}

	private void EncodeDictionary(IDictionary value, bool forceTypeHint)
	{
		if (value.Count == 0)
		{
			builder.Append("{}");
			return;
		}
		AppendOpenBrace();
		bool firstItem = true;
		foreach (object key in value.Keys)
		{
			AppendComma(firstItem);
			EncodeString(key.ToString());
			AppendColon();
			EncodeValue(value[key], forceTypeHint);
			firstItem = false;
		}
		AppendCloseBrace();
	}

	private void EncodeList(IList value, bool forceTypeHint)
	{
		if (value.Count == 0)
		{
			builder.Append("[]");
			return;
		}
		AppendOpenBracket();
		bool firstItem = true;
		foreach (object item in value)
		{
			AppendComma(firstItem);
			EncodeValue(item, forceTypeHint);
			firstItem = false;
		}
		AppendCloseBracket();
	}

	private void EncodeArray(Array value, bool forceTypeHint)
	{
		if (value.Rank == 1)
		{
			EncodeList(value, forceTypeHint);
			return;
		}
		int[] indices = new int[value.Rank];
		EncodeArrayRank(value, 0, indices, forceTypeHint);
	}

	private void EncodeArrayRank(Array value, int rank, int[] indices, bool forceTypeHint)
	{
		AppendOpenBracket();
		int lowerBound = value.GetLowerBound(rank);
		int upperBound = value.GetUpperBound(rank);
		if (rank == value.Rank - 1)
		{
			for (int i = lowerBound; i <= upperBound; i++)
			{
				indices[rank] = i;
				AppendComma(i == lowerBound);
				EncodeValue(value.GetValue(indices), forceTypeHint);
			}
		}
		else
		{
			for (int j = lowerBound; j <= upperBound; j++)
			{
				indices[rank] = j;
				AppendComma(j == lowerBound);
				EncodeArrayRank(value, rank + 1, indices, forceTypeHint);
			}
		}
		AppendCloseBracket();
	}

	private void EncodeString(string value)
	{
		builder.Append('"');
		char[] array = value.ToCharArray();
		foreach (char c in array)
		{
			switch (c)
			{
			case '"':
				builder.Append("\\\"");
				continue;
			case '\\':
				builder.Append("\\\\");
				continue;
			case '\b':
				builder.Append("\\b");
				continue;
			case '\f':
				builder.Append("\\f");
				continue;
			case '\n':
				builder.Append("\\n");
				continue;
			case '\r':
				builder.Append("\\r");
				continue;
			case '\t':
				builder.Append("\\t");
				continue;
			}
			int num = Convert.ToInt32(c);
			if (num >= 32 && num <= 126)
			{
				builder.Append(c);
			}
			else
			{
				builder.Append("\\u" + Convert.ToString(num, 16).PadLeft(4, '0'));
			}
		}
		builder.Append('"');
	}

	private void AppendIndent()
	{
		for (int i = 0; i < indent; i++)
		{
			builder.Append('\t');
		}
	}

	private void AppendOpenBrace()
	{
		builder.Append('{');
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent++;
		}
	}

	private void AppendCloseBrace()
	{
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent--;
			AppendIndent();
		}
		builder.Append('}');
	}

	private void AppendOpenBracket()
	{
		builder.Append('[');
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent++;
		}
	}

	private void AppendCloseBracket()
	{
		if (PrettyPrintEnabled)
		{
			builder.Append('\n');
			indent--;
			AppendIndent();
		}
		builder.Append(']');
	}

	private void AppendComma(bool firstItem)
	{
		if (!firstItem)
		{
			builder.Append(',');
			if (PrettyPrintEnabled)
			{
				builder.Append('\n');
			}
		}
		if (PrettyPrintEnabled)
		{
			AppendIndent();
		}
	}

	private void AppendColon()
	{
		builder.Append(':');
		if (PrettyPrintEnabled)
		{
			builder.Append(' ');
		}
	}
}


using System;
using System.Collections.Generic;

public static class Extensions
{
	public static bool AnyOfType<TSource>(this IEnumerable<TSource> source, Type expectedType)
	{
		if (source == null)
		{
			throw new ArgumentNullException("source");
		}
		if (expectedType == null)
		{
			throw new ArgumentNullException("expectedType");
		}
		foreach (TSource item in source)
		{
			if (expectedType.IsInstanceOfType(item))
			{
				return true;
			}
		}
		return false;
	}
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public sealed class Include : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class Exclude : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class AfterDecode : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Method)]
public class BeforeEncode : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class TypeHint : Attribute
{
}


using System;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]
public class DecodeAlias : Attribute
{
	public string[] Names { get; private set; }

	public DecodeAlias(params string[] names)
	{
		Names = names;
	}

	public bool Contains(string name)
	{
		return Array.IndexOf(Names, name) > -1;
	}
}


using System;
using TinyJSON;

[Obsolete("Use the Exclude attribute instead.")]
public sealed class Skip : Exclude
{
}


using System;
using TinyJSON;

[Obsolete("Use the AfterDecode attribute instead.")]
public sealed class Load : AfterDecode
{
}


using System;

public sealed class DecodeException : Exception
{
	public DecodeException(string message)
		: base(message)
	{
	}

	public DecodeException(string message, Exception innerException)
		: base(message, innerException)
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using TinyJSON;

public static class JSON
{
	private static readonly Type includeAttrType = typeof(Include);

	private static readonly Type excludeAttrType = typeof(Exclude);

	private static readonly Type decodeAliasAttrType = typeof(DecodeAlias);

	private static readonly Dictionary<string, Type> typeCache = new Dictionary<string, Type>();

	private const BindingFlags instanceBindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

	private const BindingFlags staticBindingFlags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

	private static readonly MethodInfo decodeTypeMethod = typeof(JSON).GetMethod("DecodeType", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeListMethod = typeof(JSON).GetMethod("DecodeList", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeDictionaryMethod = typeof(JSON).GetMethod("DecodeDictionary", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeArrayMethod = typeof(JSON).GetMethod("DecodeArray", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	private static readonly MethodInfo decodeMultiRankArrayMethod = typeof(JSON).GetMethod("DecodeMultiRankArray", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

	public static Variant Load(string json)
	{
		if (json == null)
		{
			throw new ArgumentNullException("json");
		}
		return Decoder.Decode(json);
	}

	public static string Dump(object data)
	{
		return Dump(data, EncodeOptions.None);
	}

	public static string Dump(object data, EncodeOptions options)
	{
		if (data != null)
		{
			Type type = data.GetType();
			if (!type.IsEnum && !type.IsPrimitive && !type.IsArray)
			{
				MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					if (methodInfo.GetCustomAttributes(inherit: false).AnyOfType(typeof(BeforeEncode)) && methodInfo.GetParameters().Length == 0)
					{
						methodInfo.Invoke(data, null);
					}
				}
			}
		}
		return Encoder.Encode(data, options);
	}

	public static void MakeInto<T>(Variant data, out T item)
	{
		item = DecodeType<T>(data);
	}

	private static Type FindType(string fullName)
	{
		if (fullName == null)
		{
			return null;
		}
		if (typeCache.TryGetValue(fullName, out var value))
		{
			return value;
		}
		Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
		for (int i = 0; i < assemblies.Length; i++)
		{
			value = assemblies[i].GetType(fullName);
			if (value != null)
			{
				typeCache.Add(fullName, value);
				return value;
			}
		}
		return null;
	}

	private static T DecodeType<T>(Variant data)
	{
		if (data == null)
		{
			return default(T);
		}
		Type type = typeof(T);
		if (type.IsEnum)
		{
			return (T)Enum.Parse(type, data.ToString(CultureInfo.InvariantCulture));
		}
		if (type.IsPrimitive || type == typeof(string) || type == typeof(decimal))
		{
			return (T)Convert.ChangeType(data, type);
		}
		if (type == typeof(Guid))
		{
			return (T)(object)new Guid(data.ToString(CultureInfo.InvariantCulture));
		}
		if (type.IsArray)
		{
			if (type.GetArrayRank() == 1)
			{
				return (T)decodeArrayMethod.MakeGenericMethod(type.GetElementType()).Invoke(null, new object[1] { data });
			}
			if (!(data is ProxyArray proxyArray))
			{
				throw new DecodeException("Variant is expected to be a ProxyArray here, but it is not.");
			}
			int[] array = new int[type.GetArrayRank()];
			if (proxyArray.CanBeMultiRankArray(array))
			{
				Type elementType = type.GetElementType();
				if (elementType == null)
				{
					throw new DecodeException("Array element type is expected to be not null, but it is.");
				}
				Array array2 = Array.CreateInstance(elementType, array);
				MethodInfo methodInfo = decodeMultiRankArrayMethod.MakeGenericMethod(elementType);
				try
				{
					methodInfo.Invoke(null, new object[4] { proxyArray, array2, 1, array });
				}
				catch (Exception innerException)
				{
					throw new DecodeException("Error decoding multidimensional array. Did you try to decode into an array of incompatible rank or element type?", innerException);
				}
				return (T)Convert.ChangeType(array2, typeof(T));
			}
			throw new DecodeException("Error decoding multidimensional array; JSON data doesn't seem fit this structure.");
		}
		if (typeof(IList).IsAssignableFrom(type))
		{
			return (T)decodeListMethod.MakeGenericMethod(type.GetGenericArguments()).Invoke(null, new object[1] { data });
		}
		if (typeof(IDictionary).IsAssignableFrom(type))
		{
			return (T)decodeDictionaryMethod.MakeGenericMethod(type.GetGenericArguments()).Invoke(null, new object[1] { data });
		}
		string typeHint = ((data as ProxyObject) ?? throw new InvalidCastException("ProxyObject expected when decoding into '" + type.FullName + "'.")).TypeHint;
		T val;
		if (typeHint != null && typeHint != type.FullName)
		{
			Type type2 = FindType(typeHint);
			if (type2 == null)
			{
				throw new TypeLoadException("Could not load type '" + typeHint + "'.");
			}
			if (!type.IsAssignableFrom(type2))
			{
				throw new InvalidCastException("Cannot assign type '" + typeHint + "' to type '" + type.FullName + "'.");
			}
			val = (T)Activator.CreateInstance(type2);
			type = type2;
		}
		else
		{
			val = Activator.CreateInstance<T>();
		}
		foreach (KeyValuePair<string, Variant> item in (IEnumerable<KeyValuePair<string, Variant>>)(ProxyObject)data)
		{
			FieldInfo fieldInfo = type.GetField(item.Key, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (fieldInfo == null)
			{
				FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (FieldInfo fieldInfo2 in fields)
				{
					object[] customAttributes = fieldInfo2.GetCustomAttributes(inherit: true);
					foreach (object obj in customAttributes)
					{
						if (decodeAliasAttrType.IsInstanceOfType(obj) && ((DecodeAlias)obj).Contains(item.Key))
						{
							fieldInfo = fieldInfo2;
							break;
						}
					}
				}
			}
			if (fieldInfo != null)
			{
				bool flag = fieldInfo.IsPublic;
				object[] customAttributes = fieldInfo.GetCustomAttributes(inherit: true);
				foreach (object o in customAttributes)
				{
					if (excludeAttrType.IsInstanceOfType(o))
					{
						flag = false;
					}
					if (includeAttrType.IsInstanceOfType(o))
					{
						flag = true;
					}
				}
				if (flag)
				{
					MethodInfo methodInfo2 = decodeTypeMethod.MakeGenericMethod(fieldInfo.FieldType);
					if (type.IsValueType)
					{
						object obj2 = val;
						fieldInfo.SetValue(obj2, methodInfo2.Invoke(null, new object[1] { item.Value }));
						val = (T)obj2;
					}
					else
					{
						fieldInfo.SetValue(val, methodInfo2.Invoke(null, new object[1] { item.Value }));
					}
				}
			}
			PropertyInfo propertyInfo = type.GetProperty(item.Key, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (propertyInfo == null)
			{
				PropertyInfo[] properties = type.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (PropertyInfo propertyInfo2 in properties)
				{
					object[] customAttributes = propertyInfo2.GetCustomAttributes(inherit: false);
					foreach (object obj3 in customAttributes)
					{
						if (decodeAliasAttrType.IsInstanceOfType(obj3) && ((DecodeAlias)obj3).Contains(item.Key))
						{
							propertyInfo = propertyInfo2;
							break;
						}
					}
				}
			}
			if (propertyInfo != null && propertyInfo.CanWrite && propertyInfo.GetCustomAttributes(inherit: false).AnyOfType(includeAttrType))
			{
				MethodInfo methodInfo3 = decodeTypeMethod.MakeGenericMethod(propertyInfo.PropertyType);
				if (type.IsValueType)
				{
					object obj4 = val;
					propertyInfo.SetValue(obj4, methodInfo3.Invoke(null, new object[1] { item.Value }), null);
					val = (T)obj4;
				}
				else
				{
					propertyInfo.SetValue(val, methodInfo3.Invoke(null, new object[1] { item.Value }), null);
				}
			}
		}
		MethodInfo[] methods = type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		foreach (MethodInfo methodInfo4 in methods)
		{
			if (methodInfo4.GetCustomAttributes(inherit: false).AnyOfType(typeof(AfterDecode)))
			{
				methodInfo4.Invoke(val, (methodInfo4.GetParameters().Length == 0) ? null : new object[1] { data });
			}
		}
		return val;
	}

	private static List<T> DecodeList<T>(Variant data)
	{
		List<T> list = new List<T>();
		foreach (Variant item in (IEnumerable<Variant>)((data as ProxyArray) ?? throw new DecodeException("Variant is expected to be a ProxyArray here, but it is not.")))
		{
			list.Add(DecodeType<T>(item));
		}
		return list;
	}

	private static Dictionary<TKey, TValue> DecodeDictionary<TKey, TValue>(Variant data)
	{
		Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>();
		Type typeFromHandle = typeof(TKey);
		foreach (KeyValuePair<string, Variant> item in (IEnumerable<KeyValuePair<string, Variant>>)((data as ProxyObject) ?? throw new DecodeException("Variant is expected to be a ProxyObject here, but it is not.")))
		{
			TKey key = (TKey)(typeFromHandle.IsEnum ? Enum.Parse(typeFromHandle, item.Key) : Convert.ChangeType(item.Key, typeFromHandle));
			TValue value = DecodeType<TValue>(item.Value);
			dictionary.Add(key, value);
		}
		return dictionary;
	}

	private static T[] DecodeArray<T>(Variant data)
	{
		ProxyArray obj = (data as ProxyArray) ?? throw new DecodeException("Variant is expected to be a ProxyArray here, but it is not.");
		T[] array = new T[obj.Count];
		int num = 0;
		foreach (Variant item in (IEnumerable<Variant>)obj)
		{
			array[num++] = DecodeType<T>(item);
		}
		return array;
	}

	private static void DecodeMultiRankArray<T>(ProxyArray arrayData, Array array, int arrayRank, int[] indices)
	{
		int count = arrayData.Count;
		for (int i = 0; i < count; i++)
		{
			indices[arrayRank - 1] = i;
			if (arrayRank < array.Rank)
			{
				DecodeMultiRankArray<T>(arrayData[i] as ProxyArray, array, arrayRank + 1, indices);
			}
			else
			{
				array.SetValue(DecodeType<T>(arrayData[i]), indices);
			}
		}
	}

	public static void SupportTypeForAOT<T>()
	{
		DecodeType<T>(null);
		DecodeList<T>(null);
		DecodeArray<T>(null);
		DecodeDictionary<short, T>(null);
		DecodeDictionary<ushort, T>(null);
		DecodeDictionary<int, T>(null);
		DecodeDictionary<uint, T>(null);
		DecodeDictionary<long, T>(null);
		DecodeDictionary<ulong, T>(null);
		DecodeDictionary<float, T>(null);
		DecodeDictionary<double, T>(null);
		DecodeDictionary<decimal, T>(null);
		DecodeDictionary<bool, T>(null);
		DecodeDictionary<string, T>(null);
	}

	private static void SupportValueTypesForAOT()
	{
		SupportTypeForAOT<short>();
		SupportTypeForAOT<ushort>();
		SupportTypeForAOT<int>();
		SupportTypeForAOT<uint>();
		SupportTypeForAOT<long>();
		SupportTypeForAOT<ulong>();
		SupportTypeForAOT<float>();
		SupportTypeForAOT<double>();
		SupportTypeForAOT<decimal>();
		SupportTypeForAOT<bool>();
		SupportTypeForAOT<string>();
	}
}


using System.Collections;
using System.Collections.Generic;
using TinyJSON;

public sealed class ProxyArray : Variant, IEnumerable<Variant>, IEnumerable
{
	private readonly List<Variant> list;

	public override Variant this[int index]
	{
		get
		{
			return list[index];
		}
		set
		{
			list[index] = value;
		}
	}

	public int Count => list.Count;

	public ProxyArray()
	{
		list = new List<Variant>();
	}

	IEnumerator<Variant> IEnumerable<Variant>.GetEnumerator()
	{
		return list.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return list.GetEnumerator();
	}

	public void Add(Variant item)
	{
		list.Add(item);
	}

	internal bool CanBeMultiRankArray(int[] rankLengths)
	{
		return CanBeMultiRankArray(0, rankLengths);
	}

	private bool CanBeMultiRankArray(int rank, int[] rankLengths)
	{
		int num = (rankLengths[rank] = list.Count);
		if (rank == rankLengths.Length - 1)
		{
			return true;
		}
		if (!(list[0] is ProxyArray { Count: var count }))
		{
			return false;
		}
		for (int i = 1; i < num; i++)
		{
			if (!(list[i] is ProxyArray proxyArray2))
			{
				return false;
			}
			if (proxyArray2.Count != count)
			{
				return false;
			}
			if (!proxyArray2.CanBeMultiRankArray(rank + 1, rankLengths))
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using TinyJSON;

public sealed class ProxyBoolean : Variant
{
	private readonly bool value;

	public ProxyBoolean(bool value)
	{
		this.value = value;
	}

	public override bool ToBoolean(IFormatProvider provider)
	{
		return value;
	}

	public override string ToString(IFormatProvider provider)
	{
		if (!value)
		{
			return "false";
		}
		return "true";
	}
}


using System;
using System.Globalization;
using TinyJSON;

public sealed class ProxyNumber : Variant
{
	private static readonly char[] floatingPointCharacters = new char[2] { '.', 'e' };

	private readonly IConvertible value;

	public ProxyNumber(IConvertible value)
	{
		string text = value as string;
		this.value = ((text != null) ? Parse(text) : value);
	}

	private static IConvertible Parse(string value)
	{
		if (value.IndexOfAny(floatingPointCharacters) == -1)
		{
			ulong result2;
			if (value[0] == '-')
			{
				if (long.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result))
				{
					return result;
				}
			}
			else if (ulong.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out result2))
			{
				return result2;
			}
		}
		if (decimal.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result3))
		{
			if (result3 == 0m && double.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result4) && Math.Abs(result4) > double.Epsilon)
			{
				return result4;
			}
			return result3;
		}
		if (double.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out var result5))
		{
			return result5;
		}
		return 0;
	}

	public override bool ToBoolean(IFormatProvider provider)
	{
		return value.ToBoolean(provider);
	}

	public override byte ToByte(IFormatProvider provider)
	{
		return value.ToByte(provider);
	}

	public override char ToChar(IFormatProvider provider)
	{
		return value.ToChar(provider);
	}

	public override decimal ToDecimal(IFormatProvider provider)
	{
		return value.ToDecimal(provider);
	}

	public override double ToDouble(IFormatProvider provider)
	{
		return value.ToDouble(provider);
	}

	public override short ToInt16(IFormatProvider provider)
	{
		return value.ToInt16(provider);
	}

	public override int ToInt32(IFormatProvider provider)
	{
		return value.ToInt32(provider);
	}

	public override long ToInt64(IFormatProvider provider)
	{
		return value.ToInt64(provider);
	}

	public override sbyte ToSByte(IFormatProvider provider)
	{
		return value.ToSByte(provider);
	}

	public override float ToSingle(IFormatProvider provider)
	{
		return value.ToSingle(provider);
	}

	public override string ToString(IFormatProvider provider)
	{
		return value.ToString(provider);
	}

	public override ushort ToUInt16(IFormatProvider provider)
	{
		return value.ToUInt16(provider);
	}

	public override uint ToUInt32(IFormatProvider provider)
	{
		return value.ToUInt32(provider);
	}

	public override ulong ToUInt64(IFormatProvider provider)
	{
		return value.ToUInt64(provider);
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using TinyJSON;

public sealed class ProxyObject : Variant, IEnumerable<KeyValuePair<string, Variant>>, IEnumerable
{
	public const string TypeHintKey = "@type";

	private readonly Dictionary<string, Variant> dict;

	public string TypeHint
	{
		get
		{
			if (TryGetValue("@type", out var item))
			{
				return item.ToString(CultureInfo.InvariantCulture);
			}
			return null;
		}
	}

	public override Variant this[string key]
	{
		get
		{
			return dict[key];
		}
		set
		{
			dict[key] = value;
		}
	}

	public int Count => dict.Count;

	public Dictionary<string, Variant>.KeyCollection Keys => dict.Keys;

	public Dictionary<string, Variant>.ValueCollection Values => dict.Values;

	public ProxyObject()
	{
		dict = new Dictionary<string, Variant>();
	}

	IEnumerator<KeyValuePair<string, Variant>> IEnumerable<KeyValuePair<string, Variant>>.GetEnumerator()
	{
		return dict.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return dict.GetEnumerator();
	}

	public void Add(string key, Variant item)
	{
		dict.Add(key, item);
	}

	public bool TryGetValue(string key, out Variant item)
	{
		return dict.TryGetValue(key, out item);
	}
}


using System;
using TinyJSON;

public sealed class ProxyString : Variant
{
	private readonly string value;

	public ProxyString(string value)
	{
		this.value = value;
	}

	public override string ToString(IFormatProvider provider)
	{
		return value;
	}
}


using System;
using System.Globalization;
using TinyJSON;

public abstract class Variant : IConvertible
{
	protected static readonly IFormatProvider FormatProvider = new NumberFormatInfo();

	public virtual Variant this[string key]
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public virtual Variant this[int index]
	{
		get
		{
			throw new NotSupportedException();
		}
		set
		{
			throw new NotSupportedException();
		}
	}

	public void Make<T>(out T item)
	{
		JSON.MakeInto<T>(this, out item);
	}

	public T Make<T>()
	{
		JSON.MakeInto<T>(this, out var item);
		return item;
	}

	public string ToJSON()
	{
		return JSON.Dump(this);
	}

	public virtual TypeCode GetTypeCode()
	{
		return TypeCode.Object;
	}

	public virtual object ToType(Type conversionType, IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to " + conversionType.Name);
	}

	public virtual DateTime ToDateTime(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to DateTime");
	}

	public virtual bool ToBoolean(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Boolean");
	}

	public virtual byte ToByte(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Byte");
	}

	public virtual char ToChar(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Char");
	}

	public virtual decimal ToDecimal(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Decimal");
	}

	public virtual double ToDouble(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Double");
	}

	public virtual short ToInt16(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Int16");
	}

	public virtual int ToInt32(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Int32");
	}

	public virtual long ToInt64(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Int64");
	}

	public virtual sbyte ToSByte(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to SByte");
	}

	public virtual float ToSingle(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to Single");
	}

	public virtual string ToString(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to String");
	}

	public virtual ushort ToUInt16(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to UInt16");
	}

	public virtual uint ToUInt32(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to UInt32");
	}

	public virtual ulong ToUInt64(IFormatProvider provider)
	{
		throw new InvalidCastException("Cannot convert " + GetType()?.ToString() + " to UInt64");
	}

	public override string ToString()
	{
		return ToString(FormatProvider);
	}

	public static implicit operator bool(Variant variant)
	{
		return variant.ToBoolean(FormatProvider);
	}

	public static implicit operator float(Variant variant)
	{
		return variant.ToSingle(FormatProvider);
	}

	public static implicit operator double(Variant variant)
	{
		return variant.ToDouble(FormatProvider);
	}

	public static implicit operator ushort(Variant variant)
	{
		return variant.ToUInt16(FormatProvider);
	}

	public static implicit operator short(Variant variant)
	{
		return variant.ToInt16(FormatProvider);
	}

	public static implicit operator uint(Variant variant)
	{
		return variant.ToUInt32(FormatProvider);
	}

	public static implicit operator int(Variant variant)
	{
		return variant.ToInt32(FormatProvider);
	}

	public static implicit operator ulong(Variant variant)
	{
		return variant.ToUInt64(FormatProvider);
	}

	public static implicit operator long(Variant variant)
	{
		return variant.ToInt64(FormatProvider);
	}

	public static implicit operator decimal(Variant variant)
	{
		return variant.ToDecimal(FormatProvider);
	}

	public static implicit operator string(Variant variant)
	{
		return variant.ToString(FormatProvider);
	}

	public static implicit operator Guid(Variant variant)
	{
		return new Guid(variant.ToString(FormatProvider));
	}
}


using UnityEngine;

public class TerrainFormer : MonoBehaviour
{
	private void Awake()
	{
		Object.Destroy((Object)(object)this);
	}
}


using UnityEngine;

public class TerrainSetNeighbours : MonoBehaviour
{
	[SerializeField]
	private Terrain leftTerrain;

	[SerializeField]
	private Terrain topTerrain;

	[SerializeField]
	private Terrain rightTerrain;

	[SerializeField]
	private Terrain bottomTerrain;

	private void Awake()
	{
		((Component)this).GetComponent<Terrain>().SetNeighbors(leftTerrain, topTerrain, rightTerrain, bottomTerrain);
		Object.Destroy((Object)(object)this);
	}

	public void SetNeighbours(Terrain leftTerrain, Terrain topTerrain, Terrain rightTerrain, Terrain bottomTerrain)
	{
		this.leftTerrain = leftTerrain;
		this.topTerrain = topTerrain;
		this.rightTerrain = rightTerrain;
		this.bottomTerrain = bottomTerrain;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct FlipBoolJob : IJob
{
	public NativeArray<bool> Values;

	public void Execute()
	{
		for (int i = 0; i < Values.Length; i++)
		{
			Values[i] = !Values[i];
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct FillJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> Values;

	[ReadOnly]
	public T Value;

	public void Execute()
	{
		for (int i = 0; i < Values.Length; i++)
		{
			Values[i] = Value;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GenerateAscSeqListJob : IJob
{
	[WriteOnly]
	public NativeList<int> Values;

	[ReadOnly]
	public int Start;

	[ReadOnly]
	public int Step;

	[ReadOnly]
	public int Count;

	public void Execute()
	{
		int num = Start;
		for (int i = 0; i < Count; i++)
		{
			Values.AddNoResize(num);
			num += Step;
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct InvertIndexListJob : IJob
{
	public NativeList<int> Indices;

	public NativeArray<bool> WorkBuffer;

	public void Execute()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < WorkBuffer.Length; i++)
		{
			WorkBuffer[i] = false;
		}
		Enumerator<int> enumerator = Indices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				WorkBuffer[current] = true;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Indices.Clear();
		for (int j = 0; j < WorkBuffer.Length; j++)
		{
			if (!WorkBuffer[j])
			{
				Indices.AddNoResize(j);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GatherJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> Results;

	[ReadOnly]
	public ReadOnly<T> Source;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			Results[i] = Source[Indices[i]];
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct ScatterToJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> Results;

	[ReadOnly]
	public ReadOnly<T> Source;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			Results[Indices[i]] = Source[i];
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Brush
{
	public float spacing;

	public Vector2 brushSize;

	public Texture2D texture;

	public Color color;

	public bool erase;
}


public abstract class BaseTip
{
	public abstract bool ShouldShow { get; }

	public string Type => GetType().Name;

	public virtual bool CanShowInTutorial => false;

	protected bool PlayerIsInTutorial => false;

	public abstract Phrase GetPhrase();
}


using UnityEngine;

public class EnableGameObjectOnClientConnect : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;

public class BanList<TKey>
{
	private readonly Dictionary<TKey, double> _bans;

	public BanList()
	{
		_bans = new Dictionary<TKey, double>();
	}

	public void Ban(TKey key, double timeInSeconds)
	{
		lock (_bans)
		{
			double num = TimeEx.realtimeSinceStartup + timeInSeconds;
			if (_bans.TryGetValue(key, out var value))
			{
				num = Math.Max(num, value);
			}
			_bans[key] = num;
		}
	}

	public bool IsBanned(TKey key)
	{
		lock (_bans)
		{
			if (!_bans.TryGetValue(key, out var value))
			{
				return false;
			}
			if (TimeEx.realtimeSinceStartup < value)
			{
				return true;
			}
			_bans.Remove(key);
			return false;
		}
	}

	public void Cleanup()
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		List<TKey> list = Pool.Get<List<TKey>>();
		lock (_bans)
		{
			foreach (KeyValuePair<TKey, double> ban in _bans)
			{
				if (realtimeSinceStartup >= ban.Value)
				{
					list.Add(ban.Key);
				}
			}
			foreach (TKey item in list)
			{
				_bans.Remove(item);
			}
		}
		Pool.FreeUnmanaged<TKey>(ref list);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using CompanionServer;
using CompanionServer.Cameras;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class CameraRendererManager : SingletonComponent<CameraRendererManager>
{
	private readonly Stack<CameraRenderTask> _taskPool = new Stack<CameraRenderTask>();

	private int _tasksTaken;

	private int _tasksReturned;

	private int _tasksCreated;

	private readonly Stopwatch _stopwatch = new Stopwatch();

	private readonly List<CameraRenderer> _renderers = new List<CameraRenderer>();

	private int _renderIndex;

	private int _completeIndex;

	protected override void OnDestroy()
	{
		((SingletonComponent)this).OnDestroy();
		foreach (CameraRenderer renderer in _renderers)
		{
			renderer.Reset();
		}
		_renderers.Clear();
		CameraRenderTask.FreeCachedSamplePositions();
		while (_taskPool.Count > 0)
		{
			_taskPool.Pop().Dispose();
		}
	}

	public void StartRendering(IRemoteControllable rc)
	{
		if (rc == null || rc.IsUnityNull())
		{
			throw new ArgumentNullException("rc");
		}
		if (List.FindWith<CameraRenderer, IRemoteControllable>((IReadOnlyCollection<CameraRenderer>)_renderers, (Func<CameraRenderer, IRemoteControllable>)((CameraRenderer r) => r.rc), rc, (IEqualityComparer<IRemoteControllable>)null) == null)
		{
			CameraRenderer cameraRenderer = Pool.Get<CameraRenderer>();
			_renderers.Add(cameraRenderer);
			cameraRenderer.Init(rc);
		}
	}

	public void Tick()
	{
		if (CameraRenderer.enabled)
		{
			DispatchRenderers();
			CompleteRenderers();
			CleanupRenderers();
		}
	}

	public CameraRenderTask BorrowTask()
	{
		if (_taskPool.Count > 0)
		{
			_tasksTaken++;
			return _taskPool.Pop();
		}
		_tasksCreated++;
		return new CameraRenderTask();
	}

	public void ReturnTask(ref CameraRenderTask task)
	{
		if (task != null)
		{
			task.Reset();
			_tasksReturned++;
			_taskPool.Push(task);
			task = null;
		}
	}

	[ServerVar]
	public static void pool_stats(Arg arg)
	{
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			arg.ReplyWith("Camera renderer manager is null!");
			return;
		}
		arg.ReplyWith($"Active renderers: {instance._renderers.Count}\nTasks in pool: {instance._taskPool.Count}\nTasks taken: {instance._tasksTaken}\nTasks returned: {instance._tasksReturned}\nTasks created: {instance._tasksCreated}");
	}

	private void DispatchRenderers()
	{
		List<CameraRenderer> list = Pool.Get<List<CameraRenderer>>();
		int count = _renderers.Count;
		for (int i = 0; i < count; i++)
		{
			if (_renderIndex >= count)
			{
				_renderIndex = 0;
			}
			CameraRenderer cameraRenderer = _renderers[_renderIndex++];
			if (cameraRenderer.CanRender())
			{
				list.Add(cameraRenderer);
				if (list.Count >= CameraRenderer.maxRendersPerFrame)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			int maxSampleCount = CameraRenderer.maxRaysPerFrame / list.Count;
			foreach (CameraRenderer item in list)
			{
				item.Render(maxSampleCount);
			}
		}
		Pool.Free<CameraRenderer>(ref list, false);
	}

	private void CompleteRenderers()
	{
		_stopwatch.Restart();
		int count = _renderers.Count;
		for (int i = 0; i < count; i++)
		{
			if (_completeIndex >= count)
			{
				_completeIndex = 0;
			}
			CameraRenderer cameraRenderer = _renderers[_completeIndex++];
			if (cameraRenderer.state == CameraRendererState.Rendering)
			{
				cameraRenderer.CompleteRender();
				if (_stopwatch.Elapsed.TotalMilliseconds >= (double)CameraRenderer.completionFrameBudgetMs)
				{
					break;
				}
			}
		}
	}

	private void CleanupRenderers()
	{
		List<CameraRenderer> list = Pool.Get<List<CameraRenderer>>();
		foreach (CameraRenderer renderer in _renderers)
		{
			if (renderer.state == CameraRendererState.Invalid)
			{
				list.Add(renderer);
			}
		}
		_renderers.RemoveAll((CameraRenderer r) => r.state == CameraRendererState.Invalid);
		foreach (CameraRenderer item in list)
		{
			CameraRenderer current2 = item;
			Pool.Free<CameraRenderer>(ref current2);
		}
		Pool.Free<CameraRenderer>(ref list, false);
	}
}


using System;
using CompanionServer;

public readonly struct CameraTarget : IEquatable<CameraTarget>
{
	public NetworkableId EntityId { get; }

	public CameraTarget(NetworkableId entityId)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EntityId = entityId;
	}

	public bool Equals(CameraTarget other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return EntityId == other.EntityId;
	}

	public override bool Equals(object obj)
	{
		if (obj is CameraTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityId = EntityId;
		return ((object)(NetworkableId)(ref entityId)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(CameraTarget left, CameraTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(CameraTarget left, CameraTarget right)
	{
		return !left.Equals(right);
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;

public class ChatLog
{
	public struct Entry
	{
		public ulong SteamId;

		public string Name;

		public string Message;

		public string Color;

		public uint Time;
	}

	private class ChatState : IPooled
	{
		public List<Entry> History;

		public void EnterPool()
		{
			if (History != null)
			{
				Pool.FreeUnmanaged<Entry>(ref History);
			}
		}

		public void LeavePool()
		{
		}
	}

	private const int MaxBacklog = 20;

	private readonly Dictionary<ulong, ChatState> States = new Dictionary<ulong, ChatState>();

	public void Record(ulong teamId, ulong steamId, string name, string message, string color, uint time)
	{
		if (!States.TryGetValue(teamId, out var value))
		{
			value = Pool.Get<ChatState>();
			value.History = Pool.Get<List<Entry>>();
			States.Add(teamId, value);
		}
		while (value.History.Count >= 20)
		{
			value.History.RemoveAt(0);
		}
		value.History.Add(new Entry
		{
			SteamId = steamId,
			Name = name,
			Message = message,
			Color = color,
			Time = time
		});
	}

	public void Remove(ulong teamId)
	{
		if (States.TryGetValue(teamId, out var value))
		{
			States.Remove(teamId);
			Pool.Free<ChatState>(ref value);
		}
	}

	public IReadOnlyList<Entry> GetHistory(ulong teamId)
	{
		if (!States.TryGetValue(teamId, out var value))
		{
			return null;
		}
		return value.History;
	}
}


public struct Entry
{
	public ulong SteamId;

	public string Name;

	public string Message;

	public string Color;

	public uint Time;
}


using System.Collections.Generic;
using Facepunch;

private class ChatState : IPooled
{
	public List<Entry> History;

	public void EnterPool()
	{
		if (History != null)
		{
			Pool.FreeUnmanaged<Entry>(ref History);
		}
	}

	public void LeavePool()
	{
	}
}


using System;
using CompanionServer;

public struct ClanTarget : IEquatable<ClanTarget>
{
	public long ClanId { get; }

	public ClanTarget(long clanId)
	{
		ClanId = clanId;
	}

	public bool Equals(ClanTarget other)
	{
		return ClanId == other.ClanId;
	}

	public override bool Equals(object obj)
	{
		if (obj is ClanTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (int)ClanId;
	}

	public static bool operator ==(ClanTarget left, ClanTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(ClanTarget left, ClanTarget right)
	{
		return !left.Equals(right);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using CompanionServer;
using ConVar;
using Facepunch;
using Fleck;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Connection : IConnection
{
	private static readonly MemoryStream MessageStream = new MemoryStream(1048576);

	private readonly Listener _listener;

	private readonly IWebSocketConnection _connection;

	private CompanionServer.PlayerTarget? _subscribedPlayer;

	private readonly HashSet<EntityTarget> _subscribedEntities;

	private readonly HashSet<ClanTarget> _subscribedClans;

	private IRemoteControllable _currentCamera;

	private ulong _cameraViewerSteamId;

	private bool _isControllingCamera;

	public long ConnectionId { get; private set; }

	public IPAddress Address => _connection.ConnectionInfo.ClientIpAddress;

	public IRemoteControllable CurrentCamera => _currentCamera;

	public bool IsControllingCamera => _isControllingCamera;

	public ulong ControllingSteamId => _cameraViewerSteamId;

	public InputState InputState { get; set; }

	public Connection(long connectionId, Listener listener, IWebSocketConnection connection)
	{
		ConnectionId = connectionId;
		_listener = listener;
		_connection = connection;
		_subscribedEntities = new HashSet<EntityTarget>();
		_subscribedClans = new HashSet<ClanTarget>();
	}

	public void OnClose()
	{
		if (_subscribedPlayer.HasValue)
		{
			_listener.PlayerSubscribers.Remove(_subscribedPlayer.Value, this);
			_subscribedPlayer = null;
		}
		foreach (EntityTarget subscribedEntity in _subscribedEntities)
		{
			_listener.EntitySubscribers.Remove(subscribedEntity, this);
		}
		_subscribedEntities.Clear();
		foreach (ClanTarget subscribedClan in _subscribedClans)
		{
			_listener.ClanSubscribers.Remove(subscribedClan, this);
		}
		_subscribedClans.Clear();
		_currentCamera?.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
		if (TryGetCameraTarget(_currentCamera, out var target))
		{
			_listener.CameraSubscribers.Remove(target, this);
		}
		_currentCamera = null;
		_cameraViewerSteamId = 0uL;
		_isControllingCamera = false;
	}

	public void OnMessage(Span<byte> data)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (App.update && App.queuelimit > 0 && data.Length <= App.maxmessagesize)
		{
			MemoryBuffer val = default(MemoryBuffer);
			((MemoryBuffer)(ref val))..ctor(data.Length);
			data.CopyTo(MemoryBuffer.op_Implicit(val));
			_listener.Enqueue(this, ((MemoryBuffer)(ref val)).Slice(data.Length));
		}
	}

	public void Close()
	{
		IWebSocketConnection connection = _connection;
		if (connection != null)
		{
			connection.Close();
		}
	}

	public void Send(AppResponse response)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		AppMessage val = Pool.Get<AppMessage>();
		val.response = response;
		MessageStream.Position = 0L;
		ProtoStreamExtensions.WriteToStream((IProto)(object)val, (Stream)MessageStream, false, 2097152);
		int num = (int)MessageStream.Position;
		MessageStream.Position = 0L;
		MemoryBuffer val2 = default(MemoryBuffer);
		((MemoryBuffer)(ref val2))..ctor(num);
		MessageStream.Read(((MemoryBuffer)(ref val2)).Data, 0, num);
		if (val.ShouldPool)
		{
			val.Dispose();
		}
		SendRaw(((MemoryBuffer)(ref val2)).Slice(num));
	}

	public void Subscribe(CompanionServer.PlayerTarget target)
	{
		if (!(_subscribedPlayer == target))
		{
			EndViewing();
			if (_subscribedPlayer.HasValue)
			{
				_listener.PlayerSubscribers.Remove(_subscribedPlayer.Value, this);
				_subscribedPlayer = null;
			}
			_listener.PlayerSubscribers.Add(target, this);
			_subscribedPlayer = target;
		}
	}

	public void Subscribe(EntityTarget target)
	{
		if (_subscribedEntities.Add(target))
		{
			_listener.EntitySubscribers.Add(target, this);
		}
	}

	public bool BeginViewing(IRemoteControllable camera)
	{
		if (!_subscribedPlayer.HasValue)
		{
			return false;
		}
		if (!TryGetCameraTarget(camera, out var target))
		{
			if (_currentCamera == camera)
			{
				_currentCamera?.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
				_currentCamera = null;
				_isControllingCamera = false;
				_cameraViewerSteamId = 0uL;
			}
			return false;
		}
		if (_currentCamera == camera)
		{
			_listener.CameraSubscribers.Add(target, this);
			return true;
		}
		if (TryGetCameraTarget(_currentCamera, out var target2))
		{
			_listener.CameraSubscribers.Remove(target2, this);
			_currentCamera.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
			_currentCamera = null;
			_isControllingCamera = false;
			_cameraViewerSteamId = 0uL;
		}
		ulong steamId = _subscribedPlayer.Value.SteamId;
		if (!camera.CanControl(steamId))
		{
			return false;
		}
		_listener.CameraSubscribers.Add(target, this);
		_currentCamera = camera;
		_isControllingCamera = _currentCamera.InitializeControl(new CameraViewerId(steamId, ConnectionId));
		_cameraViewerSteamId = steamId;
		InputState?.Clear();
		return true;
	}

	public void EndViewing()
	{
		if (TryGetCameraTarget(_currentCamera, out var target))
		{
			_listener.CameraSubscribers.Remove(target, this);
		}
		_currentCamera?.StopControl(new CameraViewerId(_cameraViewerSteamId, ConnectionId));
		_currentCamera = null;
		_isControllingCamera = false;
		_cameraViewerSteamId = 0uL;
	}

	public void Subscribe(ClanTarget target)
	{
		if (_subscribedClans.Contains(target))
		{
			return;
		}
		foreach (ClanTarget subscribedClan in _subscribedClans)
		{
			_listener.ClanSubscribers.Remove(subscribedClan, this);
		}
		_subscribedClans.Clear();
		if (_subscribedClans.Add(target))
		{
			_listener.ClanSubscribers.Add(target, this);
		}
	}

	public void Unsubscribe(ClanTarget target)
	{
		if (_subscribedClans.Remove(target))
		{
			_listener.ClanSubscribers.Remove(target, this);
		}
	}

	public void SendRaw(MemoryBuffer data)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if (((MemoryBuffer)(ref data)).Length == 0)
		{
			return;
		}
		if (_connection == null || !_connection.IsAvailable)
		{
			DebugEx.LogWarning((object)$"Ignoring Rust+ message send to disconnected client (connectionID={ConnectionId} steamID={_subscribedPlayer?.SteamId})", (StackTraceLogType)0);
			((MemoryBuffer)(ref data)).Dispose();
			return;
		}
		try
		{
			_connection.Send(data);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to send message to app client {_connection.ConnectionInfo.ClientIpAddress}: {arg}");
		}
	}

	private static bool TryGetCameraTarget(IRemoteControllable camera, out CameraTarget target)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = camera?.GetEnt();
		if (camera.IsUnityNull() || (Object)(object)baseEntity == (Object)null || !baseEntity.IsValid())
		{
			target = default(CameraTarget);
			return false;
		}
		target = new CameraTarget(baseEntity.net.ID);
		return true;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using ConVar;
using Facepunch;

public class ConnectionLimiter
{
	private readonly object _sync;

	private readonly Dictionary<IPAddress, int> _addressCounts;

	private int _overallCount;

	public ConnectionLimiter()
	{
		_sync = new object();
		_addressCounts = new Dictionary<IPAddress, int>();
		_overallCount = 0;
	}

	public bool TryAdd(IPAddress address)
	{
		if (address == null)
		{
			return false;
		}
		lock (_sync)
		{
			if (_overallCount >= App.maxconnections)
			{
				return false;
			}
			if (_addressCounts.TryGetValue(address, out var value))
			{
				if (value >= App.maxconnectionsperip)
				{
					return false;
				}
				_addressCounts[address] = value + 1;
			}
			else
			{
				_addressCounts.Add(address, 1);
			}
			_overallCount++;
			return true;
		}
	}

	public void Remove(IPAddress address)
	{
		if (address == null)
		{
			return;
		}
		lock (_sync)
		{
			if (_addressCounts.TryGetValue(address, out var value))
			{
				if (value <= 1)
				{
					_addressCounts.Remove(address);
				}
				else
				{
					_addressCounts[address] = value - 1;
				}
				_overallCount--;
			}
		}
	}

	public void Clear()
	{
		lock (_sync)
		{
			_addressCounts.Clear();
			_overallCount = 0;
		}
	}

	public override string ToString()
	{
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "IP", "connections" });
			lock (_sync)
			{
				foreach (KeyValuePair<IPAddress, int> item in _addressCounts.OrderByDescending((KeyValuePair<IPAddress, int> t) => t.Value))
				{
					val.AddRow(new string[2]
					{
						item.Key.ToString(),
						item.Value.ToString()
					});
				}
				return $"{val}\n{_overallCount} total";
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using CompanionServer;

public readonly struct EntityTarget : IEquatable<EntityTarget>
{
	public NetworkableId EntityId { get; }

	public EntityTarget(NetworkableId entityId)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		EntityId = entityId;
	}

	public bool Equals(EntityTarget other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return EntityId == other.EntityId;
	}

	public override bool Equals(object obj)
	{
		if (obj is EntityTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityId = EntityId;
		return ((object)(NetworkableId)(ref entityId)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(EntityTarget left, EntityTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(EntityTarget left, EntityTarget right)
	{
		return !left.Equals(right);
	}
}


using CompanionServer;
using ProtoBuf;

public interface IConnection
{
	long ConnectionId { get; }

	IRemoteControllable CurrentCamera { get; }

	bool IsControllingCamera { get; }

	ulong ControllingSteamId { get; }

	InputState InputState { get; set; }

	void Send(AppResponse response);

	void Subscribe(CompanionServer.PlayerTarget target);

	void Subscribe(EntityTarget target);

	void Subscribe(ClanTarget target);

	void Unsubscribe(ClanTarget target);

	bool BeginViewing(IRemoteControllable camera);

	void EndViewing();
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Threading;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Fleck;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Listener : IDisposable, IBroadcastSender<AppBroadcast>
{
	private struct Message
	{
		public readonly Connection Connection;

		public readonly MemoryBuffer Buffer;

		public Message(Connection connection, MemoryBuffer buffer)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Connection = connection;
			Buffer = buffer;
		}
	}

	private static readonly ByteArrayStream Stream = new ByteArrayStream();

	private readonly TokenBucketList<IPAddress> _ipTokenBuckets;

	private readonly BanList<IPAddress> _ipBans;

	private readonly TokenBucketList<ulong> _playerTokenBuckets;

	private readonly TokenBucketList<ulong> _pairingTokenBuckets;

	private readonly Queue<Message> _messageQueue;

	private readonly WebSocketServer _server;

	private readonly Stopwatch _stopwatch;

	private RealTimeSince _lastCleanup;

	private long _nextConnectionId;

	public readonly IPAddress Address;

	public readonly int Port;

	public readonly ConnectionLimiter Limiter;

	public readonly SubscriberList<CompanionServer.PlayerTarget, AppBroadcast> PlayerSubscribers;

	public readonly SubscriberList<EntityTarget, AppBroadcast> EntitySubscribers;

	public readonly SubscriberList<ClanTarget, AppBroadcast> ClanSubscribers;

	public readonly SubscriberList<CameraTarget, AppBroadcast> CameraSubscribers;

	public Listener(IPAddress ipAddress, int port)
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Expected O, but got Unknown
		Listener listener = this;
		Address = ipAddress;
		Port = port;
		Limiter = new ConnectionLimiter();
		_ipTokenBuckets = new TokenBucketList<IPAddress>(50.0, 15.0);
		_ipBans = new BanList<IPAddress>();
		_playerTokenBuckets = new TokenBucketList<ulong>(25.0, 3.0);
		_pairingTokenBuckets = new TokenBucketList<ulong>(5.0, 0.1);
		_messageQueue = new Queue<Message>();
		SynchronizationContext syncContext = SynchronizationContext.Current;
		_server = new WebSocketServer($"ws://{Address}:{Port}/", true);
		_server.Start((Action<IWebSocketConnection>)delegate(IWebSocketConnection socket)
		{
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Expected O, but got Unknown
			IPAddress address = socket.ConnectionInfo.ClientIpAddress;
			if (!listener.Limiter.TryAdd(address) || listener._ipBans.IsBanned(address))
			{
				socket.Close();
			}
			else
			{
				long connectionId = Interlocked.Increment(ref listener._nextConnectionId);
				Connection conn = new Connection(connectionId, listener, socket);
				socket.OnClose = delegate
				{
					listener.Limiter.Remove(address);
					syncContext.Post(delegate(object c)
					{
						((Connection)c).OnClose();
					}, conn);
				};
				socket.OnBinary = new BinaryDataHandler(conn.OnMessage);
				socket.OnError = Debug.LogError;
			}
		});
		_stopwatch = new Stopwatch();
		PlayerSubscribers = new SubscriberList<CompanionServer.PlayerTarget, AppBroadcast>(this, null);
		EntitySubscribers = new SubscriberList<EntityTarget, AppBroadcast>(this, null);
		ClanSubscribers = new SubscriberList<ClanTarget, AppBroadcast>(this, null);
		CameraSubscribers = new SubscriberList<CameraTarget, AppBroadcast>(this, 30.0);
	}

	public void Dispose()
	{
		WebSocketServer server = _server;
		if (server != null)
		{
			server.Dispose();
		}
	}

	internal void Enqueue(Connection connection, MemoryBuffer data)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		lock (_messageQueue)
		{
			if (!App.update || _messageQueue.Count >= App.queuelimit)
			{
				((MemoryBuffer)(ref data)).Dispose();
				return;
			}
			Message item = new Message(connection, data);
			_messageQueue.Enqueue(item);
		}
	}

	public bool Update()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (!App.update)
		{
			return false;
		}
		bool result = false;
		TimeWarning val = TimeWarning.New("CompanionServer.MessageQueue", 0);
		try
		{
			lock (_messageQueue)
			{
				_stopwatch.Restart();
				while (_messageQueue.Count > 0 && _stopwatch.Elapsed.TotalMilliseconds < 5.0)
				{
					Message message = _messageQueue.Dequeue();
					Dispatch(message);
					result = true;
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (RealTimeSince.op_Implicit(_lastCleanup) >= 3f)
		{
			_lastCleanup = RealTimeSince.op_Implicit(0f);
			_ipTokenBuckets.Cleanup();
			_ipBans.Cleanup();
			_playerTokenBuckets.Cleanup();
			_pairingTokenBuckets.Cleanup();
		}
		return result;
	}

	private void Dispatch(Message message)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		MemoryBuffer buffer = message.Buffer;
		AppRequest val;
		try
		{
			ByteArrayStream stream = Stream;
			MemoryBuffer buffer2 = message.Buffer;
			byte[] data = ((MemoryBuffer)(ref buffer2)).Data;
			buffer2 = message.Buffer;
			stream.SetData(data, 0, ((MemoryBuffer)(ref buffer2)).Length);
			val = Pool.Get<AppRequest>();
			ProtoStreamExtensions.ReadFromStream((IProto)(object)val, (Stream)(object)Stream, false, 1048576);
		}
		catch
		{
			DebugEx.LogWarning((object)$"Malformed companion packet from {message.Connection.Address}", (StackTraceLogType)0);
			message.Connection.Close();
			throw;
		}
		finally
		{
			((MemoryBuffer)(ref buffer)).Dispose();
		}
		if (!Handle<AppEmpty, Info>(val.getInfo, message.Connection, val) && !Handle<AppEmpty, CompanionServer.Handlers.Time>(val.getTime, message.Connection, val) && !Handle<AppEmpty, Map>(val.getMap, message.Connection, val) && !Handle<AppEmpty, TeamInfo>(val.getTeamInfo, message.Connection, val) && !Handle<AppEmpty, TeamChat>(val.getTeamChat, message.Connection, val) && !Handle<AppSendMessage, SendTeamChat>(val.sendTeamMessage, message.Connection, val) && !Handle<AppEmpty, EntityInfo>(val.getEntityInfo, message.Connection, val) && !Handle<AppSetEntityValue, SetEntityValue>(val.setEntityValue, message.Connection, val) && !Handle<AppEmpty, CheckSubscription>(val.checkSubscription, message.Connection, val) && !Handle<AppFlag, SetSubscription>(val.setSubscription, message.Connection, val) && !Handle<AppEmpty, MapMarkers>(val.getMapMarkers, message.Connection, val) && !Handle<AppPromoteToLeader, PromoteToLeader>(val.promoteToLeader, message.Connection, val) && !Handle<AppEmpty, ClanInfo>(val.getClanInfo, message.Connection, val) && !Handle<AppEmpty, ClanChat>(val.getClanChat, message.Connection, val) && !Handle<AppSendMessage, SetClanMotd>(val.setClanMotd, message.Connection, val) && !Handle<AppSendMessage, SendClanChat>(val.sendClanMessage, message.Connection, val) && !Handle<AppGetNexusAuth, NexusAuth>(val.getNexusAuth, message.Connection, val) && !Handle<AppCameraSubscribe, CameraSubscribe>(val.cameraSubscribe, message.Connection, val) && !Handle<AppEmpty, CameraUnsubscribe>(val.cameraUnsubscribe, message.Connection, val) && !Handle<AppCameraInput, CameraInput>(val.cameraInput, message.Connection, val))
		{
			AppResponse val2 = Pool.Get<AppResponse>();
			val2.seq = val.seq;
			val2.error = Pool.Get<AppError>();
			val2.error.error = "unhandled";
			message.Connection.Send(val2);
			val.Dispose();
		}
	}

	private bool Handle<TProto, THandler>(TProto protocol, Connection connection, AppRequest request) where TProto : class, IProto where THandler : BaseHandler<TProto>, new()
	{
		if (protocol == null)
		{
			return false;
		}
		THandler val = Pool.Get<THandler>();
		val.Initialize(_playerTokenBuckets, connection, request, protocol);
		try
		{
			ValidationResult validationResult = val.Validate();
			switch (validationResult)
			{
			case ValidationResult.Rejected:
				connection.Close();
				break;
			default:
				val.SendError(validationResult.ToErrorCode());
				break;
			case ValidationResult.Success:
				val.Execute();
				break;
			}
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"AppRequest threw an exception: {arg}");
			val.SendError("server_error");
		}
		Pool.Free<THandler>(ref val);
		return true;
	}

	public void BroadcastTo(List<Connection> targets, AppBroadcast broadcast)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		MemoryBuffer broadcastBuffer = GetBroadcastBuffer(broadcast);
		foreach (Connection target in targets)
		{
			target.SendRaw(((MemoryBuffer)(ref broadcastBuffer)).DontDispose());
		}
		((MemoryBuffer)(ref broadcastBuffer)).Dispose();
	}

	private static MemoryBuffer GetBroadcastBuffer(AppBroadcast broadcast)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		MemoryBuffer val = default(MemoryBuffer);
		((MemoryBuffer)(ref val))..ctor(65536);
		Stream.SetData(((MemoryBuffer)(ref val)).Data, 0, ((MemoryBuffer)(ref val)).Length);
		AppMessage val2 = Pool.Get<AppMessage>();
		val2.broadcast = broadcast;
		ProtoStreamExtensions.WriteToStream((IProto)(object)val2, (Stream)(object)Stream, false, 2097152);
		if (val2.ShouldPool)
		{
			val2.Dispose();
		}
		return ((MemoryBuffer)(ref val)).Slice((int)((Stream)(object)Stream).Position);
	}

	public bool CanSendPairingNotification(ulong playerId)
	{
		return _pairingTokenBuckets.Get(playerId).TryTake(1.0);
	}
}


using Fleck;

private struct Message
{
	public readonly Connection Connection;

	public readonly MemoryBuffer Buffer;

	public Message(Connection connection, MemoryBuffer buffer)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Connection = connection;
		Buffer = buffer;
	}
}


public enum NotificationChannel
{
	Pairing = 1001,
	PlayerLoggedIn,
	PlayerDied,
	SmartAlarm,
	ClanAnnouncement
}


public enum NotificationSendResult
{
	Failed,
	Sent,
	Empty,
	Disabled,
	RateLimited,
	ServerError,
	NoTargetsFound,
	TooManySubscribers
}


using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch;
using Network;
using Newtonsoft.Json;
using UnityEngine;

public class NotificationList
{
	private const string ApiEndpoint = "https://companion-rust.facepunch.com/api/push/send";

	private static readonly HttpClient Http = new HttpClient();

	private readonly HashSet<ulong> _subscriptions = new HashSet<ulong>();

	private double _lastSend;

	public bool AddSubscription(ulong steamId)
	{
		if (steamId == 0L)
		{
			return false;
		}
		if (_subscriptions.Count >= 50)
		{
			return false;
		}
		return _subscriptions.Add(steamId);
	}

	public bool RemoveSubscription(ulong steamId)
	{
		return _subscriptions.Remove(steamId);
	}

	public bool HasSubscription(ulong steamId)
	{
		return _subscriptions.Contains(steamId);
	}

	public List<ulong> ToList()
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (ulong subscription in _subscriptions)
		{
			list.Add(subscription);
		}
		return list;
	}

	public void LoadFrom(List<ulong> steamIds)
	{
		_subscriptions.Clear();
		if (steamIds == null)
		{
			return;
		}
		foreach (ulong steamId in steamIds)
		{
			_subscriptions.Add(steamId);
		}
	}

	public void IntersectWith(HashSet<ulong> players)
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (ulong player in players)
		{
			list.Add(player);
		}
		_subscriptions.IntersectWith(list);
		Pool.FreeUnmanaged<ulong>(ref list);
	}

	public Task<NotificationSendResult> SendNotification(NotificationChannel channel, string title, string body, string type)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		if (realtimeSinceStartup - _lastSend < 15.0)
		{
			return Task.FromResult(NotificationSendResult.RateLimited);
		}
		Dictionary<string, string> dictionary = Util.TryGetServerPairingData();
		if (dictionary == null)
		{
			return Task.FromResult(NotificationSendResult.Failed);
		}
		if (!string.IsNullOrWhiteSpace(type))
		{
			dictionary["type"] = type;
		}
		_lastSend = realtimeSinceStartup;
		return SendNotificationImpl(_subscriptions, channel, title, body, dictionary);
	}

	public static async Task<NotificationSendResult> SendNotificationTo(ICollection<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		NotificationSendResult notificationSendResult = await SendNotificationImpl(steamIds, channel, title, body, data);
		if (notificationSendResult == NotificationSendResult.NoTargetsFound)
		{
			notificationSendResult = NotificationSendResult.Sent;
		}
		return notificationSendResult;
	}

	public static async Task<NotificationSendResult> SendNotificationTo(ulong steamId, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		HashSet<ulong> set = Pool.Get<HashSet<ulong>>();
		set.Clear();
		set.Add(steamId);
		NotificationSendResult result = await SendNotificationImpl(set, channel, title, body, data);
		set.Clear();
		Pool.FreeUnmanaged<ulong>(ref set);
		return result;
	}

	private static async Task<NotificationSendResult> SendNotificationImpl(ICollection<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		if (!CompanionServer.Server.IsEnabled || !App.notifications)
		{
			return NotificationSendResult.Disabled;
		}
		if (string.IsNullOrWhiteSpace(title) || string.IsNullOrWhiteSpace(body))
		{
			return NotificationSendResult.Empty;
		}
		if (steamIds.Count == 0)
		{
			return NotificationSendResult.Sent;
		}
		List<List<ulong>> batches = Pool.Get<List<List<ulong>>>();
		List<ulong> list = null;
		foreach (ulong steamId in steamIds)
		{
			if (list == null)
			{
				list = Pool.Get<List<ulong>>();
			}
			list.Add(steamId);
			if (list.Count >= 100)
			{
				batches.Add(list);
				list = null;
			}
		}
		if (list != null && list.Count > 0)
		{
			batches.Add(list);
		}
		NotificationSendResult? errorResult = null;
		bool anySent = false;
		foreach (List<ulong> item in batches)
		{
			List<ulong> batchCopy = item;
			NotificationSendResult notificationSendResult = await SendNotificationBatchImpl(batchCopy, channel, title, body, data);
			Pool.FreeUnmanaged<ulong>(ref batchCopy);
			switch (notificationSendResult)
			{
			case NotificationSendResult.Failed:
				errorResult = NotificationSendResult.Failed;
				break;
			case NotificationSendResult.ServerError:
				if (errorResult != NotificationSendResult.Failed)
				{
					errorResult = NotificationSendResult.ServerError;
				}
				break;
			}
			if (notificationSendResult == NotificationSendResult.Sent)
			{
				anySent = true;
			}
		}
		Pool.FreeUnmanaged<List<ulong>>(ref batches);
		if (data != null)
		{
			data.Clear();
			Pool.FreeUnmanaged<string, string>(ref data);
		}
		if (errorResult.HasValue)
		{
			return errorResult.Value;
		}
		return anySent ? NotificationSendResult.Sent : NotificationSendResult.NoTargetsFound;
	}

	private static async Task<NotificationSendResult> SendNotificationBatchImpl(IEnumerable<ulong> steamIds, NotificationChannel channel, string title, string body, Dictionary<string, string> data)
	{
		PushRequest pushRequest = Pool.Get<PushRequest>();
		pushRequest.ServerToken = CompanionServer.Server.Token;
		pushRequest.Channel = channel;
		pushRequest.Title = title;
		pushRequest.Body = body;
		pushRequest.Data = data;
		pushRequest.SteamIds = Pool.Get<List<ulong>>();
		foreach (ulong steamId in steamIds)
		{
			pushRequest.SteamIds.Add(steamId);
		}
		string text = JsonConvert.SerializeObject((object)pushRequest);
		Pool.Free<PushRequest>(ref pushRequest);
		try
		{
			StringContent val = new StringContent(text, Encoding.UTF8, "application/json");
			HttpResponseMessage val2 = await Http.PostAsync("https://companion-rust.facepunch.com/api/push/send", (HttpContent)(object)val);
			if (!val2.IsSuccessStatusCode)
			{
				DebugEx.LogWarning((object)$"Failed to send notification: {val2.StatusCode}", (StackTraceLogType)0);
				return NotificationSendResult.ServerError;
			}
			if (val2.StatusCode == HttpStatusCode.Accepted)
			{
				return NotificationSendResult.NoTargetsFound;
			}
			return NotificationSendResult.Sent;
		}
		catch (Exception arg)
		{
			DebugEx.LogWarning((object)$"Exception thrown when sending notification: {arg}", (StackTraceLogType)0);
			return NotificationSendResult.Failed;
		}
	}
}


using System;
using CompanionServer;

public readonly struct PlayerTarget : IEquatable<CompanionServer.PlayerTarget>
{
	public ulong SteamId { get; }

	public PlayerTarget(ulong steamId)
	{
		SteamId = steamId;
	}

	public bool Equals(CompanionServer.PlayerTarget other)
	{
		return SteamId == other.SteamId;
	}

	public override bool Equals(object obj)
	{
		if (obj is CompanionServer.PlayerTarget other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return SteamId.GetHashCode();
	}

	public static bool operator ==(CompanionServer.PlayerTarget left, CompanionServer.PlayerTarget right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(CompanionServer.PlayerTarget left, CompanionServer.PlayerTarget right)
	{
		return !left.Equals(right);
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;

public class PushRequest : IPooled
{
	public string ServerToken;

	public List<ulong> SteamIds;

	public NotificationChannel Channel;

	public string Title;

	public string Body;

	public Dictionary<string, string> Data;

	public void EnterPool()
	{
		Pool.FreeUnmanaged<ulong>(ref SteamIds);
		Channel = (NotificationChannel)0;
		Title = null;
		Body = null;
		Data = null;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

public static class Server
{
	private class RegisterResponse
	{
		public string ServerId;

		public string ServerToken;
	}

	private class TestConnectionResponse
	{
		public List<string> Messages;
	}

	private const string ApiEndpoint = "https://companion-rust.facepunch.com/api/server";

	private static readonly HttpClient Http = new HttpClient();

	public static readonly ChatLog TeamChat = new ChatLog();

	internal static string Token;

	public static Listener Listener { get; private set; }

	public static bool IsEnabled
	{
		get
		{
			if (App.port >= 0 && !string.IsNullOrWhiteSpace(App.serverid))
			{
				return Listener != null;
			}
			return false;
		}
	}

	public static void Initialize(bool minimal = false)
	{
		if (App.port < 0)
		{
			return;
		}
		if (IsEnabled)
		{
			Debug.LogWarning((object)"Rust+ is already started up! Skipping second startup");
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (!((Object)(object)activeGameMode != (Object)null) || activeGameMode.rustPlus)
		{
			Shutdown();
			Map.PopulateCache();
			if (App.port == 0)
			{
				App.port = Math.Max(ConVar.Server.port, RCon.Port) + 67;
			}
			try
			{
				Listener = new Listener(App.GetListenIP(), App.port);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Companion server failed to start: {arg}");
			}
			if (!minimal)
			{
				PostInitializeServer();
			}
		}
	}

	public static void Shutdown()
	{
		SetServerId(null);
		Listener?.Dispose();
		Listener = null;
	}

	public static bool Update()
	{
		return Listener?.Update() ?? false;
	}

	public static void Broadcast(CompanionServer.PlayerTarget target, AppBroadcast broadcast)
	{
		Listener?.PlayerSubscribers?.Send(target, broadcast);
	}

	public static void Broadcast(EntityTarget target, AppBroadcast broadcast)
	{
		Listener?.EntitySubscribers?.Send(target, broadcast);
	}

	public static void Broadcast(ClanTarget target, AppBroadcast broadcast)
	{
		Listener?.ClanSubscribers?.Send(target, broadcast);
	}

	public static void Broadcast(CameraTarget target, AppBroadcast broadcast)
	{
		Listener?.CameraSubscribers?.Send(target, broadcast);
	}

	public static bool HasAnySubscribers(CameraTarget target)
	{
		return Listener?.CameraSubscribers?.HasAnySubscribers(target) == true;
	}

	public static bool CanSendPairingNotification(ulong playerId)
	{
		return Listener?.CanSendPairingNotification(playerId) ?? false;
	}

	private static async void PostInitializeServer()
	{
		await SetupServerRegistration();
		await CheckConnectivity();
	}

	private static async Task SetupServerRegistration()
	{
		_ = 3;
		try
		{
			if (TryLoadServerRegistration(out var _, out var serverToken))
			{
				StringContent refreshContent = new StringContent(serverToken, Encoding.UTF8, "text/plain");
				HttpResponseMessage val = await AutoRetry(() => Http.PostAsync("https://companion-rust.facepunch.com/api/server/refresh", (HttpContent)(object)refreshContent));
				if (val.IsSuccessStatusCode)
				{
					SetServerRegistration(await val.Content.ReadAsStringAsync());
					return;
				}
				Debug.LogWarning((object)"Failed to refresh server ID - registering a new one");
			}
			HttpResponseMessage obj = await AutoRetry(() => Http.GetAsync("https://companion-rust.facepunch.com/api/server/register"));
			obj.EnsureSuccessStatusCode();
			SetServerRegistration(await obj.Content.ReadAsStringAsync());
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to setup companion server registration: {arg}");
		}
	}

	private static bool TryLoadServerRegistration(out string serverId, out string serverToken)
	{
		serverId = null;
		serverToken = null;
		string serverIdPath = GetServerIdPath();
		if (!File.Exists(serverIdPath))
		{
			return false;
		}
		try
		{
			RegisterResponse registerResponse = JsonConvert.DeserializeObject<RegisterResponse>(File.ReadAllText(serverIdPath));
			serverId = registerResponse.ServerId;
			serverToken = registerResponse.ServerToken;
			return true;
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to load companion server registration: {arg}");
			return false;
		}
	}

	private static void SetServerRegistration(string responseJson)
	{
		RegisterResponse registerResponse = null;
		try
		{
			registerResponse = JsonConvert.DeserializeObject<RegisterResponse>(responseJson);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to parse registration response JSON: {responseJson}\n\n{arg}");
		}
		SetServerId(registerResponse?.ServerId);
		Token = registerResponse?.ServerToken;
		if (registerResponse == null)
		{
			return;
		}
		try
		{
			File.WriteAllText(GetServerIdPath(), responseJson);
		}
		catch (Exception arg2)
		{
			Debug.LogError((object)$"Unable to save companion app server registration - server ID may be different after restart: {arg2}");
		}
	}

	private static async Task CheckConnectivity()
	{
		if (!IsEnabled)
		{
			Shutdown();
			return;
		}
		try
		{
			string publicIp = await App.GetPublicIPAsync();
			if (string.IsNullOrEmpty(publicIp))
			{
				Debug.LogError((object)"Failed to determine public IP address for Rust+ while running the connectivity test. Disabling Rust+ features because we wouldn't know what IP to tell Rust+ to connect to.");
				SetServerId(null);
			}
			StringContent testContent = new StringContent("", Encoding.UTF8, "text/plain");
			HttpResponseMessage testResponse = await AutoRetry(() => Http.PostAsync("https://companion-rust.facepunch.com/api/server" + $"/test_connection?address={publicIp}&port={App.port}", (HttpContent)(object)testContent));
			string text = await testResponse.Content.ReadAsStringAsync();
			TestConnectionResponse testConnectionResponse = null;
			try
			{
				testConnectionResponse = JsonConvert.DeserializeObject<TestConnectionResponse>(text);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Failed to parse connectivity test response JSON: {text}\n\n{arg}");
			}
			if (testConnectionResponse == null)
			{
				return;
			}
			IEnumerable<string> messages = testConnectionResponse.Messages;
			string text2 = string.Join("\n", messages ?? Enumerable.Empty<string>());
			if (testResponse.StatusCode == (HttpStatusCode)555)
			{
				Debug.LogError((object)("Rust+ companion server connectivity test failed! Disabling Rust+ features.\n\n" + text2));
				SetServerId(null);
				return;
			}
			testResponse.EnsureSuccessStatusCode();
			if (!string.IsNullOrWhiteSpace(text2))
			{
				Debug.LogWarning((object)("Rust+ companion server connectivity test has warnings:\n" + text2));
			}
		}
		catch (Exception arg2)
		{
			Debug.LogError((object)$"Failed to check connectivity to the companion server: {arg2}");
		}
	}

	private static async Task<HttpResponseMessage> AutoRetry(Func<Task<HttpResponseMessage>> action)
	{
		Exception lastException = null;
		for (int i = 0; i < 5; i++)
		{
			try
			{
				HttpResponseMessage val = await action();
				int statusCode = (int)val.StatusCode;
				if (statusCode != 555 && statusCode >= 500 && statusCode <= 599 && i < 4)
				{
					val.EnsureSuccessStatusCode();
				}
				return val;
			}
			catch (Exception ex)
			{
				lastException = ex;
			}
			await Task.Delay(30000);
		}
		throw lastException ?? new Exception("Exceeded maximum number of retries");
	}

	private static void SetServerId(string serverId)
	{
		Command obj = Server.Find("app.serverid");
		if (obj != null)
		{
			obj.Set(serverId ?? "");
		}
	}

	private static string GetServerIdPath()
	{
		return Path.Combine(ConVar.Server.rootFolder, "companion.id");
	}
}


private class RegisterResponse
{
	public string ServerId;

	public string ServerToken;
}


using System.Collections.Generic;

private class TestConnectionResponse
{
	public List<string> Messages;
}


using System.Collections.Generic;
using CompanionServer;

public interface IBroadcastSender<TMessage>
{
	void BroadcastTo(List<Connection> targets, TMessage message);
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using CompanionServer;
using Facepunch;
using Network;

public class SubscriberList<TKey, TMessage> where TKey : IEquatable<TKey>
{
	private readonly object _syncRoot;

	private readonly Dictionary<TKey, Dictionary<Connection, double>> _subscriptions;

	private readonly IBroadcastSender<TMessage> _sender;

	private readonly double? _timeoutSeconds;

	private readonly Stopwatch _lastCleanup;

	public SubscriberList(IBroadcastSender<TMessage> sender, double? timeoutSeconds = null)
	{
		_syncRoot = new object();
		_subscriptions = new Dictionary<TKey, Dictionary<Connection, double>>();
		_sender = sender;
		_timeoutSeconds = timeoutSeconds;
		_lastCleanup = Stopwatch.StartNew();
	}

	public void Add(TKey key, Connection value)
	{
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value2))
			{
				value2 = new Dictionary<Connection, double>();
				_subscriptions.Add(key, value2);
			}
			value2[value] = TimeEx.realtimeSinceStartup;
		}
		CleanupExpired();
	}

	public void Remove(TKey key, Connection value)
	{
		lock (_syncRoot)
		{
			if (_subscriptions.TryGetValue(key, out var value2))
			{
				value2.Remove(value);
				if (value2.Count == 0)
				{
					_subscriptions.Remove(key);
				}
			}
		}
		CleanupExpired();
	}

	public void Clear(TKey key)
	{
		lock (_syncRoot)
		{
			if (_subscriptions.TryGetValue(key, out var value))
			{
				value.Clear();
			}
		}
	}

	public void Send(TKey key, TMessage message)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		List<Connection> list;
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value))
			{
				return;
			}
			list = Pool.Get<List<Connection>>();
			foreach (KeyValuePair<Connection, double> item in value)
			{
				if (!_timeoutSeconds.HasValue || realtimeSinceStartup - item.Value < _timeoutSeconds.Value)
				{
					list.Add(item.Key);
				}
			}
		}
		_sender.BroadcastTo(list, message);
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public bool HasAnySubscribers(TKey key)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value))
			{
				return false;
			}
			foreach (KeyValuePair<Connection, double> item in value)
			{
				if (!_timeoutSeconds.HasValue || realtimeSinceStartup - item.Value < _timeoutSeconds.Value)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool HasSubscriber(TKey key, Connection target)
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		lock (_syncRoot)
		{
			if (!_subscriptions.TryGetValue(key, out var value) || !value.TryGetValue(target, out var value2))
			{
				return false;
			}
			if (!_timeoutSeconds.HasValue || realtimeSinceStartup - value2 < _timeoutSeconds.Value)
			{
				return true;
			}
		}
		return false;
	}

	private void CleanupExpired()
	{
		if (!_timeoutSeconds.HasValue || _lastCleanup.Elapsed.TotalMinutes < 2.0)
		{
			return;
		}
		_lastCleanup.Restart();
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		List<(TKey, Connection)> list = Pool.Get<List<(TKey, Connection)>>();
		lock (_syncRoot)
		{
			foreach (KeyValuePair<TKey, Dictionary<Connection, double>> subscription in _subscriptions)
			{
				foreach (KeyValuePair<Connection, double> item in subscription.Value)
				{
					if (realtimeSinceStartup - item.Value >= _timeoutSeconds.Value)
					{
						list.Add((subscription.Key, item.Key));
					}
				}
			}
			foreach (var (key, value) in list)
			{
				Remove(key, value);
			}
		}
		Pool.FreeUnmanaged<(TKey, Connection)>(ref list);
	}
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public static class AppPlayerExtensions
{
	public static AppTeamInfo GetAppTeamInfo(this BasePlayer player, ulong steamId)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		AppTeamInfo obj = Pool.Get<AppTeamInfo>();
		obj.members = Pool.Get<List<Member>>();
		Member val = Pool.Get<Member>();
		if ((Object)(object)player != (Object)null)
		{
			Vector2 val2 = Util.WorldToMap(((Component)player).transform.position);
			val.steamId = player.userID;
			val.name = player.displayName ?? "";
			val.x = val2.x;
			val.y = val2.y;
			val.isOnline = player.IsConnected;
			val.spawnTime = player.lifeStory?.timeBorn ?? 0;
			val.isAlive = player.IsAlive();
			val.deathTime = player.previousLifeStory?.timeDied ?? 0;
		}
		else
		{
			val.steamId = steamId;
			val.name = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(steamId) ?? "";
			val.x = 0f;
			val.y = 0f;
			val.isOnline = false;
			val.spawnTime = 0u;
			val.isAlive = false;
			val.deathTime = 0u;
		}
		obj.members.Add(val);
		obj.leaderSteamId = 0uL;
		obj.mapNotes = GetMapNotes(val.steamId, personalNotes: true);
		obj.leaderMapNotes = Pool.Get<List<Note>>();
		return obj;
	}

	public static AppTeamInfo GetAppTeamInfo(this RelationshipManager.PlayerTeam team, ulong requesterSteamId)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		AppTeamInfo val = Pool.Get<AppTeamInfo>();
		val.members = Pool.Get<List<Member>>();
		for (int i = 0; i < team.members.Count; i++)
		{
			ulong num = team.members[i];
			BasePlayer basePlayer = RelationshipManager.FindByID(num);
			if (!Object.op_Implicit((Object)(object)basePlayer))
			{
				basePlayer = null;
			}
			Vector2 val2 = Util.WorldToMap((basePlayer != null) ? ((Component)basePlayer).transform.position : Vector3.zero);
			Member val3 = Pool.Get<Member>();
			val3.steamId = num;
			val3.name = basePlayer?.displayName ?? SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(num) ?? "";
			val3.x = val2.x;
			val3.y = val2.y;
			val3.isOnline = basePlayer?.IsConnected ?? false;
			val3.spawnTime = (basePlayer?.lifeStory?.timeBorn).GetValueOrDefault();
			val3.isAlive = basePlayer?.IsAlive() ?? false;
			val3.deathTime = (basePlayer?.previousLifeStory?.timeDied).GetValueOrDefault();
			val.members.Add(val3);
		}
		val.leaderSteamId = team.teamLeader;
		val.mapNotes = GetMapNotes(requesterSteamId, personalNotes: true);
		if (requesterSteamId != team.teamLeader)
		{
			val.leaderMapNotes = GetMapNotes(team.teamLeader, personalNotes: false);
		}
		else
		{
			val.leaderMapNotes = Pool.Get<List<Note>>();
		}
		return val;
	}

	private static List<Note> GetMapNotes(ulong playerId, bool personalNotes)
	{
		List<Note> result = Pool.Get<List<Note>>();
		PlayerState val = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerId);
		if (val != null)
		{
			if (personalNotes && val.deathMarker != null)
			{
				AddMapNote(result, val.deathMarker, BasePlayer.MapNoteType.Death);
			}
			if (val.pointsOfInterest != null)
			{
				foreach (MapNote item in val.pointsOfInterest)
				{
					AddMapNote(result, item, BasePlayer.MapNoteType.PointOfInterest);
				}
			}
		}
		return result;
	}

	private static void AddMapNote(List<Note> result, MapNote note, BasePlayer.MapNoteType type)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = Util.WorldToMap(note.worldPosition);
		Note val2 = Pool.Get<Note>();
		val2.type = (int)type;
		val2.x = val.x;
		val2.y = val.y;
		val2.icon = note.icon;
		val2.colourIndex = note.colourIndex;
		val2.label = note.label;
		result.Add(val2);
	}
}


using System;
using CompanionServer;
using Facepunch;
using Network;

public class TokenBucket : IPooled
{
	private double _lastUpdate;

	private double _tokens;

	public ITokenBucketSettings Settings;

	public bool IsFull
	{
		get
		{
			Update();
			return _tokens >= Settings.MaxTokens;
		}
	}

	public bool IsNaughty
	{
		get
		{
			Update();
			return _tokens <= -10.0;
		}
	}

	void IPooled.LeavePool()
	{
	}

	void IPooled.EnterPool()
	{
		Settings = null;
		_lastUpdate = 0.0;
		_tokens = 0.0;
	}

	public void Reset()
	{
		_lastUpdate = TimeEx.realtimeSinceStartup;
		_tokens = Settings?.MaxTokens ?? 0.0;
	}

	public bool TryTake(double requestedTokens)
	{
		Update();
		if (requestedTokens > _tokens)
		{
			_tokens -= 1.0;
			return false;
		}
		_tokens -= requestedTokens;
		return true;
	}

	private void Update()
	{
		double realtimeSinceStartup = TimeEx.realtimeSinceStartup;
		double num = realtimeSinceStartup - _lastUpdate;
		_lastUpdate = realtimeSinceStartup;
		double num2 = num * Settings.TokensPerSec;
		_tokens = Math.Min(_tokens + num2, Settings.MaxTokens);
	}
}


public interface ITokenBucketSettings
{
	double MaxTokens { get; }

	double TokensPerSec { get; }
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;

public class TokenBucketList<TKey> : ITokenBucketSettings
{
	private readonly Dictionary<TKey, TokenBucket> _buckets;

	public double MaxTokens { get; }

	public double TokensPerSec { get; }

	public TokenBucketList(double maxTokens, double tokensPerSec)
	{
		_buckets = new Dictionary<TKey, TokenBucket>();
		MaxTokens = maxTokens;
		TokensPerSec = tokensPerSec;
	}

	public TokenBucket Get(TKey key)
	{
		if (_buckets.TryGetValue(key, out var value))
		{
			return value;
		}
		TokenBucket tokenBucket = Pool.Get<TokenBucket>();
		tokenBucket.Settings = this;
		tokenBucket.Reset();
		_buckets.Add(key, tokenBucket);
		return tokenBucket;
	}

	public void Cleanup()
	{
		List<TKey> list = Pool.Get<List<TKey>>();
		foreach (KeyValuePair<TKey, TokenBucket> bucket in _buckets)
		{
			if (bucket.Value.IsFull)
			{
				list.Add(bucket.Key);
			}
		}
		foreach (TKey item in list)
		{
			if (_buckets.TryGetValue(item, out var value))
			{
				Pool.Free<TokenBucket>(ref value);
				_buckets.Remove(item);
			}
		}
		Pool.FreeUnmanaged<TKey>(ref list);
	}
}


using System.Collections.Generic;
using System.Globalization;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using ProtoBuf;
using UnityEngine;

public static class Util
{
	public const int OceanMargin = 500;

	public static readonly Phrase NotificationEmpty = new Phrase("app.error.empty", "Notification was not sent because it was missing some content.");

	public static readonly Phrase NotificationDisabled = new Phrase("app.error.disabled", "Rust+ features are disabled on this server.");

	public static readonly Phrase NotificationRateLimit = new Phrase("app.error.ratelimit", "You are sending too many notifications at a time. Please wait and then try again.");

	public static readonly Phrase NotificationServerError = new Phrase("app.error.servererror", "The companion server failed to send the notification.");

	public static readonly Phrase NotificationNoTargets = new Phrase("app.error.notargets", "Open the Rust+ menu in-game to pair your phone with this server.");

	public static readonly Phrase NotificationTooManySubscribers = new Phrase("app.error.toomanysubs", "There are too many players subscribed to these notifications.");

	public static readonly Phrase NotificationUnknown = new Phrase("app.error.unknown", "An unknown error occurred sending the notification.");

	public static Vector2 WorldToMap(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(worldPos.x - TerrainMeta.Position.x, worldPos.z - TerrainMeta.Position.z);
	}

	public static void SendSignedInNotification(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && player.currentTeam != 0L)
		{
			Dictionary<string, string> dictionary = TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "login");
				dictionary.Add("targetId", player.UserIDString);
				dictionary.Add("targetName", StringExtensions.Truncate(player.displayName, 128, (string)null));
				RelationshipManager.ServerInstance.FindTeam(player.currentTeam)?.SendNotification(NotificationChannel.PlayerLoggedIn, player.displayName + " is now online", ConVar.Server.hostname, dictionary, player.userID);
			}
		}
	}

	public static void SendDeathNotification(BasePlayer player, BaseEntity killer)
	{
		string value;
		string text;
		if (killer is BasePlayer basePlayer && ((object)basePlayer).GetType() == typeof(BasePlayer))
		{
			value = basePlayer.UserIDString;
			text = basePlayer.displayName;
		}
		else
		{
			if (PrefabAttribute.server.Find(killer.prefabID, out PrefabInformation result))
			{
				Phrase title = result.title;
				if (!string.IsNullOrEmpty((title != null) ? title.english : null))
				{
					value = "";
					text = result.title.english;
					goto IL_0081;
				}
			}
			value = "";
			text = killer.ShortPrefabName;
		}
		goto IL_0081;
		IL_0081:
		if (!((Object)(object)player == (Object)null) && !string.IsNullOrEmpty(text))
		{
			Dictionary<string, string> dictionary = TryGetServerPairingData();
			if (dictionary != null)
			{
				dictionary.Add("type", "death");
				dictionary.Add("targetId", value);
				dictionary.Add("targetName", StringExtensions.Truncate(text, 128, (string)null));
				NotificationList.SendNotificationTo(player.userID, NotificationChannel.PlayerDied, "You were killed by " + text, ConVar.Server.hostname, dictionary);
			}
		}
	}

	public static Task<NotificationSendResult> SendPairNotification(string type, BasePlayer player, string title, string message, Dictionary<string, string> data)
	{
		if (!CompanionServer.Server.IsEnabled)
		{
			return Task.FromResult(NotificationSendResult.Disabled);
		}
		if (!CompanionServer.Server.CanSendPairingNotification(player.userID))
		{
			return Task.FromResult(NotificationSendResult.RateLimited);
		}
		if (data == null)
		{
			data = TryGetPlayerPairingData(player);
			if (data == null)
			{
				return Task.FromResult(NotificationSendResult.Failed);
			}
		}
		data.Add("type", type);
		return NotificationList.SendNotificationTo(player.userID, NotificationChannel.Pairing, title, message, data);
	}

	public static Dictionary<string, string> TryGetServerPairingData()
	{
		string value = App.GetPublicIP() ?? "";
		if (string.IsNullOrWhiteSpace(value) || string.IsNullOrWhiteSpace(App.serverid))
		{
			return null;
		}
		Dictionary<string, string> dictionary = Pool.Get<Dictionary<string, string>>();
		dictionary.Clear();
		dictionary.Add("id", App.serverid);
		dictionary.Add("name", StringExtensions.Truncate(ConVar.Server.hostname, 128, (string)null));
		dictionary.Add("desc", StringExtensions.Truncate(ConVar.Server.description, 512, (string)null));
		dictionary.Add("img", StringExtensions.Truncate(ConVar.Server.headerimage, 128, (string)null));
		dictionary.Add("logo", StringExtensions.Truncate(ConVar.Server.logoimage, 128, (string)null));
		dictionary.Add("url", StringExtensions.Truncate(ConVar.Server.url, 128, (string)null));
		dictionary.Add("ip", value);
		dictionary.Add("port", App.port.ToString("G", CultureInfo.InvariantCulture));
		if (NexusServer.Started)
		{
			int? nexusId = NexusServer.NexusId;
			string zoneKey = NexusServer.ZoneKey;
			if (nexusId.HasValue && zoneKey != null)
			{
				dictionary.Add("nexus", Nexus.endpoint);
				dictionary.Add("nexusId", nexusId.Value.ToString("G"));
				dictionary.Add("nexusZone", zoneKey);
			}
		}
		return dictionary;
	}

	public static Dictionary<string, string> TryGetPlayerPairingData(BasePlayer player)
	{
		Dictionary<string, string> dictionary = TryGetServerPairingData();
		if (dictionary == null)
		{
			return null;
		}
		bool locked;
		int orGenerateAppToken = SingletonComponent<ServerMgr>.Instance.persistance.GetOrGenerateAppToken(player.userID, out locked);
		dictionary.Add("playerId", player.UserIDString);
		dictionary.Add("playerToken", orGenerateAppToken.ToString("G", CultureInfo.InvariantCulture));
		return dictionary;
	}

	public static void BroadcastAppTeamRemoval(this BasePlayer player)
	{
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.teamChanged = Pool.Get<AppTeamChanged>();
		val.teamChanged.playerId = player.userID;
		val.teamChanged.teamInfo = player.GetAppTeamInfo(player.userID);
		CompanionServer.Server.Broadcast(new CompanionServer.PlayerTarget(player.userID), val);
	}

	public static void BroadcastAppTeamUpdate(this RelationshipManager.PlayerTeam team)
	{
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.teamChanged = Pool.Get<AppTeamChanged>();
		val.ShouldPool = false;
		foreach (ulong member in team.members)
		{
			val.teamChanged.playerId = member;
			val.teamChanged.teamInfo = team.GetAppTeamInfo(member);
			CompanionServer.Server.Broadcast(new CompanionServer.PlayerTarget(member), val);
		}
		val.ShouldPool = true;
		val.Dispose();
	}

	public static void BroadcastTeamChat(this RelationshipManager.PlayerTeam team, ulong steamId, string name, string message, string color)
	{
		uint current = (uint)Epoch.Current;
		CompanionServer.Server.TeamChat.Record(team.teamID, steamId, name, message, color, current);
		AppBroadcast val = Pool.Get<AppBroadcast>();
		val.teamMessage = Pool.Get<AppNewTeamMessage>();
		val.teamMessage.message = Pool.Get<AppTeamMessage>();
		val.ShouldPool = false;
		AppTeamMessage message2 = val.teamMessage.message;
		message2.steamId = steamId;
		message2.name = name;
		message2.message = message;
		message2.color = color;
		message2.time = current;
		foreach (ulong member in team.members)
		{
			CompanionServer.Server.Broadcast(new CompanionServer.PlayerTarget(member), val);
		}
		val.ShouldPool = true;
		val.Dispose();
	}

	public static async void SendNotification(this RelationshipManager.PlayerTeam team, NotificationChannel channel, string title, string body, Dictionary<string, string> data, ulong ignorePlayer = 0uL)
	{
		List<ulong> steamIds = Pool.Get<List<ulong>>();
		foreach (ulong member in team.members)
		{
			if (member == ignorePlayer)
			{
				continue;
			}
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			if (!((Object)(object)basePlayer == (Object)null))
			{
				Networkable net = basePlayer.net;
				if (((net != null) ? net.connection : null) != null)
				{
					continue;
				}
			}
			steamIds.Add(member);
		}
		await NotificationList.SendNotificationTo(steamIds, channel, title, body, data);
		Pool.FreeUnmanaged<ulong>(ref steamIds);
	}

	public static string ToErrorCode(this ValidationResult result)
	{
		return result switch
		{
			ValidationResult.NotFound => "not_found", 
			ValidationResult.RateLimit => "rate_limit", 
			ValidationResult.Banned => "banned", 
			_ => "unknown", 
		};
	}

	public static Phrase ToErrorMessage(this NotificationSendResult result)
	{
		return (Phrase)(result switch
		{
			NotificationSendResult.Sent => null, 
			NotificationSendResult.Empty => NotificationEmpty, 
			NotificationSendResult.Disabled => NotificationDisabled, 
			NotificationSendResult.RateLimited => NotificationRateLimit, 
			NotificationSendResult.ServerError => NotificationServerError, 
			NotificationSendResult.NoTargetsFound => NotificationNoTargets, 
			NotificationSendResult.TooManySubscribers => NotificationTooManySubscribers, 
			_ => NotificationUnknown, 
		});
	}
}


using System;
using System.Threading.Tasks;
using CompanionServer;
using CompanionServer.Handlers;
using UnityEngine;

public abstract class BaseClanHandler<T> : BasePlayerHandler<T> where T : class
{
	protected IClanBackend ClanBackend { get; private set; }

	protected async ValueTask<IClan> GetClan()
	{
		if (ClanBackend == null)
		{
			return null;
		}
		ClanValueResult<IClan> val = ((!((Object)(object)base.Player != (Object)null) || base.Player.clanId == 0L) ? (await ClanBackend.GetByMember(base.UserId)) : (await ClanBackend.Get(base.Player.clanId)));
		ClanValueResult<IClan> val2 = val;
		if ((int)val2.Result != 3 && (int)val2.Result != 4)
		{
			IClan value = val2.Value;
			base.Client.Subscribe(new ClanTarget(value.ClanId));
			return value;
		}
		return null;
	}

	public override void EnterPool()
	{
		base.EnterPool();
		ClanBackend = null;
	}

	public override ValidationResult Validate()
	{
		ValidationResult num = base.Validate();
		if (num == ValidationResult.Success && (Object)(object)ClanManager.ServerInstance != (Object)null)
		{
			ClanBackend = ClanManager.ServerInstance.Backend;
		}
		return num;
	}

	protected void SendError(ClanResult result)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		base.SendError(GetErrorString(result));
	}

	private static string GetErrorString(ClanResult result)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Expected I4, but got Unknown
		return (int)result switch
		{
			1 => throw new ArgumentException("ClanResult.Success is not an error"), 
			2 => "clan_timeout", 
			3 => "clan_no_clan", 
			4 => "clan_not_found", 
			5 => "clan_no_permission", 
			6 => "clan_invalid_text", 
			7 => "clan_invalid_logo", 
			8 => "clan_invalid_color", 
			9 => "clan_duplicate_name", 
			10 => "clan_role_not_empty", 
			11 => "clan_cannot_swap_leader", 
			12 => "clan_cannot_delete_leader", 
			13 => "clan_cannot_kick_leader", 
			14 => "clan_cannot_demote_leader", 
			15 => "clan_already_in_clan", 
			_ => "clan_fail", 
		};
	}
}


using CompanionServer;
using CompanionServer.Handlers;
using UnityEngine;

public abstract class BaseEntityHandler<T> : BasePlayerHandler<T> where T : class
{
	protected AppIOEntity Entity { get; private set; }

	public override void EnterPool()
	{
		base.EnterPool();
		Entity = null;
	}

	public override ValidationResult Validate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		ValidationResult validationResult = base.Validate();
		if (validationResult != 0)
		{
			return validationResult;
		}
		AppIOEntity appIOEntity = BaseNetworkable.serverEntities.Find(base.Request.entityId) as AppIOEntity;
		if ((Object)(object)appIOEntity == (Object)null)
		{
			return ValidationResult.NotFound;
		}
		BuildingPrivlidge buildingPrivilege = appIOEntity.GetBuildingPrivilege();
		if ((Object)(object)buildingPrivilege != (Object)null && !buildingPrivilege.IsAuthed(base.UserId))
		{
			return ValidationResult.NotFound;
		}
		Entity = appIOEntity;
		base.Client.Subscribe(new EntityTarget(base.Request.entityId));
		return ValidationResult.Success;
	}
}


using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public abstract class BaseHandler<T> : IHandler, IPooled where T : class
{
	protected TokenBucketList<ulong> PlayerBuckets { get; private set; }

	protected virtual double TokenCost => 1.0;

	public IConnection Client { get; private set; }

	public AppRequest Request { get; private set; }

	public T Proto { get; private set; }

	public void Initialize(TokenBucketList<ulong> playerBuckets, IConnection client, AppRequest request, T proto)
	{
		PlayerBuckets = playerBuckets;
		Client = client;
		Request = request;
		Proto = proto;
	}

	public virtual void EnterPool()
	{
		PlayerBuckets = null;
		Client = null;
		if (Request != null)
		{
			Request.Dispose();
			Request = null;
		}
		Proto = null;
	}

	public void LeavePool()
	{
	}

	public virtual ValidationResult Validate()
	{
		return ValidationResult.Success;
	}

	public abstract void Execute();

	protected void SendSuccess()
	{
		AppSuccess success = Pool.Get<AppSuccess>();
		AppResponse val = Pool.Get<AppResponse>();
		val.success = success;
		Send(val);
	}

	public void SendError(string code)
	{
		AppError val = Pool.Get<AppError>();
		val.error = code;
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.error = val;
		Send(val2);
	}

	public void SendFlag(bool value)
	{
		AppFlag val = Pool.Get<AppFlag>();
		val.value = value;
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.flag = val;
		Send(val2);
	}

	protected void Send(AppResponse response)
	{
		response.seq = Request.seq;
		Client.Send(response);
	}
}


using CompanionServer;
using CompanionServer.Handlers;

public abstract class BasePlayerHandler<T> : BaseHandler<T> where T : class
{
	protected ulong UserId { get; private set; }

	protected BasePlayer Player { get; private set; }

	public override void EnterPool()
	{
		UserId = 0uL;
		Player = null;
	}

	public override ValidationResult Validate()
	{
		ValidationResult validationResult = base.Validate();
		if (validationResult != 0)
		{
			return validationResult;
		}
		bool locked;
		int orGenerateAppToken = SingletonComponent<ServerMgr>.Instance.persistance.GetOrGenerateAppToken(base.Request.playerId, out locked);
		if (base.Request.playerId == 0L || base.Request.playerToken != orGenerateAppToken)
		{
			return ValidationResult.NotFound;
		}
		if (locked)
		{
			return ValidationResult.Banned;
		}
		if ((ServerUsers.Get(base.Request.playerId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)
		{
			return ValidationResult.Banned;
		}
		TokenBucket tokenBucket = base.PlayerBuckets?.Get(base.Request.playerId);
		if (tokenBucket == null || !tokenBucket.TryTake(TokenCost))
		{
			if (tokenBucket == null || !tokenBucket.IsNaughty)
			{
				return ValidationResult.RateLimit;
			}
			return ValidationResult.Rejected;
		}
		UserId = base.Request.playerId;
		Player = BasePlayer.FindByID(UserId) ?? BasePlayer.FindSleeping(UserId);
		base.Client.Subscribe(new CompanionServer.PlayerTarget(UserId));
		return ValidationResult.Success;
	}
}


using CompanionServer.Cameras;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CameraInput : BaseHandler<AppCameraInput>
{
	protected override double TokenCost => 0.01;

	public override void Execute()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		if (!CameraRenderer.enabled)
		{
			SendError("not_enabled");
			return;
		}
		if (base.Client.CurrentCamera == null || !base.Client.IsControllingCamera)
		{
			SendError("no_camera");
			return;
		}
		InputState inputState = base.Client.InputState;
		if (inputState == null)
		{
			inputState = new InputState();
			base.Client.InputState = inputState;
		}
		InputMessage val = Pool.Get<InputMessage>();
		val.buttons = base.Proto.buttons;
		val.mouseDelta = Sanitize(Vector2.op_Implicit(base.Proto.mouseDelta));
		val.aimAngles = Vector3.zero;
		inputState.Flip(val);
		Pool.Free<InputMessage>(ref val);
		base.Client.CurrentCamera.UserInput(inputState, new CameraViewerId(base.Client.ControllingSteamId, base.Client.ConnectionId));
		SendSuccess();
	}

	private static Vector3 Sanitize(Vector3 value)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Sanitize(value.x), Sanitize(value.y), Sanitize(value.z));
	}

	private static float Sanitize(float value)
	{
		if (float.IsNaN(value) || float.IsInfinity(value))
		{
			return 0f;
		}
		return Mathf.Clamp(value, -100f, 100f);
	}
}


using CompanionServer;
using CompanionServer.Cameras;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CameraSubscribe : BasePlayerHandler<AppCameraSubscribe>
{
	public override void Execute()
	{
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		if (!CameraRenderer.enabled)
		{
			SendError("not_enabled");
			return;
		}
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			SendError("server_error");
			return;
		}
		if (string.IsNullOrEmpty(base.Proto.cameraId))
		{
			base.Client.EndViewing();
			SendError("invalid_id");
			return;
		}
		if (!base.Player.IsValid())
		{
			base.Client.EndViewing();
			SendError("no_player");
			return;
		}
		if (base.Player.IsConnected)
		{
			base.Client.EndViewing();
			SendError("player_online");
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(base.Proto.cameraId);
		if (remoteControllable == null || !remoteControllable.CanControl(base.UserId))
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		if (remoteControllable is CCTV_RC cCTV_RC && cCTV_RC.IsStatic())
		{
			base.Client.EndViewing();
			SendError("access_denied");
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (!ent.IsValid())
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		if (Vector3.Distance(((Component)base.Player).transform.position, ((Component)ent).transform.position) >= remoteControllable.MaxRange)
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		if (!base.Client.BeginViewing(remoteControllable))
		{
			base.Client.EndViewing();
			SendError("not_found");
			return;
		}
		instance.StartRendering(remoteControllable);
		AppResponse val = Pool.Get<AppResponse>();
		AppCameraInfo val2 = Pool.Get<AppCameraInfo>();
		val2.width = CameraRenderer.width;
		val2.height = CameraRenderer.height;
		val2.nearPlane = CameraRenderer.nearPlane;
		val2.farPlane = CameraRenderer.farPlane;
		val2.controlFlags = (int)(base.Client.IsControllingCamera ? remoteControllable.RequiredControls : RemoteControllableControls.None);
		val.cameraSubscribeInfo = val2;
		Send(val);
	}
}


using CompanionServer.Cameras;
using CompanionServer.Handlers;
using ProtoBuf;

public class CameraUnsubscribe : BaseHandler<AppEmpty>
{
	public override void Execute()
	{
		if (!CameraRenderer.enabled)
		{
			SendError("not_enabled");
			return;
		}
		base.Client.EndViewing();
		SendSuccess();
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class CheckSubscription : BaseEntityHandler<AppEmpty>
{
	public override void Execute()
	{
		if (base.Entity is ISubscribable subscribable)
		{
			bool value = subscribable.HasSubscription(base.UserId);
			SendFlag(value);
		}
		else
		{
			SendError("wrong_type");
		}
	}
}


using System.Collections.Generic;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class ClanChat : BaseClanHandler<AppEmpty>
{
	public override async void Execute()
	{
		IClan val = await GetClan();
		if (val == null)
		{
			((BaseHandler<AppEmpty>)this).SendError("no_clan");
			return;
		}
		ClanValueResult<ClanChatScrollback> val2 = await val.GetChatScrollback();
		if (!val2.IsSuccess)
		{
			SendError(val2.Result);
			return;
		}
		AppResponse val3 = Pool.Get<AppResponse>();
		val3.clanChat = Pool.Get<AppClanChat>();
		val3.clanChat.messages = Pool.Get<List<AppClanMessage>>();
		foreach (ClanChatEntry entry in val2.Value.Entries)
		{
			AppClanMessage val4 = Pool.Get<AppClanMessage>();
			val4.steamId = entry.SteamId;
			val4.name = entry.Name;
			val4.message = entry.Message;
			val4.time = entry.Time;
			val3.clanChat.messages.Add(val4);
		}
		Send(val3);
	}
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class ClanInfo : BaseClanHandler<AppEmpty>
{
	public override async void Execute()
	{
		IClan clan = await GetClan();
		if (clan == null)
		{
			((BaseHandler<AppEmpty>)this).SendError("no_clan");
			return;
		}
		await clan.RefreshIfStale();
		AppClanInfo val = Pool.Get<AppClanInfo>();
		val.clanInfo = clan.ToProto();
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.clanInfo = val;
		Send(val2);
	}
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class EntityInfo : BaseEntityHandler<AppEmpty>
{
	public override void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		AppEntityInfo val = Pool.Get<AppEntityInfo>();
		val.type = base.Entity.Type;
		val.payload = Pool.Get<AppEntityPayload>();
		base.Entity.FillEntityPayload(val.payload);
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.entityInfo = val;
		Send(val2);
	}
}


public enum ValidationResult
{
	Success,
	NotFound,
	RateLimit,
	Banned,
	Rejected
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public interface IHandler : IPooled
{
	AppRequest Request { get; }

	ValidationResult Validate();

	void Execute();

	void SendError(string code);
}


using CompanionServer.Cameras;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Facepunch.Math;
using ProtoBuf;

public class Info : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		AppInfo val = Pool.Get<AppInfo>();
		val.name = Server.hostname;
		val.headerImage = Server.headerimage;
		val.logoImage = Server.logoimage;
		val.url = Server.url;
		val.map = World.Name;
		val.mapSize = World.Size;
		val.wipeTime = (uint)Epoch.FromDateTime(SaveRestore.SaveCreatedTime.ToUniversalTime());
		val.players = (uint)BasePlayer.activePlayerList.Count;
		val.maxPlayers = (uint)Server.maxplayers;
		val.queuedPlayers = (uint)SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		val.seed = World.Seed;
		val.camerasEnabled = CameraRenderer.enabled;
		if (NexusServer.Started)
		{
			int? nexusId = NexusServer.NexusId;
			string zoneKey = NexusServer.ZoneKey;
			if (nexusId.HasValue && zoneKey != null)
			{
				val.nexus = Nexus.endpoint;
				val.nexusId = nexusId.Value;
				val.nexusZone = zoneKey;
			}
		}
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.info = val;
		Send(val2);
	}
}


using System;
using System.Collections.Generic;
using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Map : BasePlayerHandler<AppEmpty>
{
	private static int _width;

	private static int _height;

	private static byte[] _imageData;

	private static string _background;

	public static byte[] ImageData => _imageData;

	protected override double TokenCost => 5.0;

	public override void Execute()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (_imageData == null)
		{
			SendError("no_map");
			return;
		}
		AppMap val = Pool.Get<AppMap>();
		val.width = (uint)_width;
		val.height = (uint)_height;
		val.oceanMargin = 500;
		val.jpgImage = _imageData;
		val.background = _background;
		val.monuments = Pool.Get<List<Monument>>();
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Landmarks != null)
		{
			foreach (LandmarkInfo landmark in TerrainMeta.Path.Landmarks)
			{
				if (landmark.shouldDisplayOnMap)
				{
					Vector2 val2 = Util.WorldToMap(((Component)landmark).transform.position);
					Monument val3 = Pool.Get<Monument>();
					val3.token = (landmark.displayPhrase.IsValid() ? landmark.displayPhrase.token : ((Object)((Component)landmark).transform.root).name);
					val3.x = val2.x;
					val3.y = val2.y;
					val.monuments.Add(val3);
				}
			}
		}
		AppResponse val4 = Pool.Get<AppResponse>();
		val4.map = val;
		Send(val4);
	}

	public static void PopulateCache()
	{
		RenderToCache();
	}

	private static void RenderToCache()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		_imageData = null;
		_width = 0;
		_height = 0;
		try
		{
			_imageData = MapImageRenderer.Render(out _width, out _height, out var background);
			_background = "#" + ColorUtility.ToHtmlStringRGB(background);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Exception thrown when rendering map for the app: {arg}");
		}
		if (_imageData == null)
		{
			Debug.LogError((object)"Map image is null! App users will not be able to see the map.");
		}
	}
}


using System.Collections.Generic;
using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class MapMarkers : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		AppMapMarkers val = Pool.Get<AppMapMarkers>();
		val.markers = Pool.Get<List<AppMarker>>();
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		if (playerTeam != null)
		{
			foreach (ulong member in playerTeam.members)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				if (!((Object)(object)basePlayer == (Object)null))
				{
					val.markers.Add(GetPlayerMarker(basePlayer));
				}
			}
		}
		else if ((Object)(object)base.Player != (Object)null)
		{
			val.markers.Add(GetPlayerMarker(base.Player));
		}
		foreach (MapMarker serverMapMarker in MapMarker.serverMapMarkers)
		{
			if ((int)serverMapMarker.appType != 0)
			{
				val.markers.Add(serverMapMarker.GetAppMarkerData());
			}
		}
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.mapMarkers = val;
		Send(val2);
	}

	private static AppMarker GetPlayerMarker(BasePlayer player)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		AppMarker obj = Pool.Get<AppMarker>();
		Vector2 val = Util.WorldToMap(((Component)player).transform.position);
		obj.id = player.net.ID;
		obj.type = (AppMarkerType)1;
		obj.x = val.x;
		obj.y = val.y;
		obj.steamId = player.userID;
		return obj;
	}
}


using System.Globalization;
using CompanionServer.Handlers;
using ConVar;
using Facepunch;
using Facepunch.Nexus;
using ProtoBuf;

public class NexusAuth : BaseHandler<AppGetNexusAuth>
{
	public override ValidationResult Validate()
	{
		if (!NexusServer.Started)
		{
			return ValidationResult.NotFound;
		}
		return base.Validate();
	}

	public override async void Execute()
	{
		if (base.Request.playerId == 0L)
		{
			SendError("invalid_playerid");
			return;
		}
		string text = base.Request.playerId.ToString("G", CultureInfo.InvariantCulture);
		NexusPlayer val = await NexusServer.ZoneClient.GetPlayer(text);
		Variable val2 = default(Variable);
		if (val == null || !val.TryGetVariable("appKey", ref val2) || (int)val2.Type != 1 || base.Proto.appKey != val2.GetAsString())
		{
			SendError("access_denied");
			return;
		}
		AppResponse val3 = Pool.Get<AppResponse>();
		val3.nexusAuth = Pool.Get<AppNexusAuth>();
		val3.nexusAuth.serverId = App.serverid;
		val3.nexusAuth.playerToken = SingletonComponent<ServerMgr>.Instance.persistance.GetOrGenerateAppToken(base.Request.playerId, out var _);
		Send(val3);
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class PromoteToLeader : BasePlayerHandler<AppPromoteToLeader>
{
	public override void Execute()
	{
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		if (playerTeam == null)
		{
			SendError("no_team");
			return;
		}
		if (playerTeam.teamLeader != base.UserId)
		{
			SendError("access_denied");
			return;
		}
		if (playerTeam.teamLeader == base.Proto.steamId)
		{
			SendSuccess();
			return;
		}
		if (!playerTeam.members.Contains(base.Proto.steamId))
		{
			SendError("not_found");
			return;
		}
		playerTeam.SetTeamLeader(base.Proto.steamId);
		SendSuccess();
	}
}


using CompanionServer.Handlers;
using ConVar;
using Facepunch.Extend;
using ProtoBuf;

public class SendClanChat : BaseClanHandler<AppSendMessage>
{
	protected override double TokenCost => 2.0;

	public override async void Execute()
	{
		if (await GetClan() == null)
		{
			((BaseHandler<AppSendMessage>)this).SendError("no_clan");
			return;
		}
		string text = base.Proto.message?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			SendSuccess();
			return;
		}
		text = StringExtensions.Truncate(text, 256, "");
		string username = base.Player?.displayName ?? SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(base.UserId) ?? "[unknown]";
		if (await Chat.sayAs(Chat.ChatChannel.Clan, base.UserId, username, text, base.Player))
		{
			SendSuccess();
		}
		else
		{
			((BaseHandler<AppSendMessage>)this).SendError("message_not_sent");
		}
	}
}


using CompanionServer.Handlers;
using ConVar;
using Facepunch.Extend;
using ProtoBuf;

public class SendTeamChat : BasePlayerHandler<AppSendMessage>
{
	protected override double TokenCost => 2.0;

	public override async void Execute()
	{
		string text = base.Proto.message?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			SendSuccess();
			return;
		}
		text = StringExtensions.Truncate(text, 256, "");
		string username = base.Player?.displayName ?? SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(base.UserId) ?? "[unknown]";
		if (await Chat.sayAs(Chat.ChatChannel.Team, base.UserId, username, text, base.Player))
		{
			SendSuccess();
		}
		else
		{
			SendError("message_not_sent");
		}
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class SetClanMotd : BaseClanHandler<AppSendMessage>
{
	public override async void Execute()
	{
		string motd = default(string);
		if (!ClanValidator.ValidateMotd(base.Proto.message, ref motd))
		{
			((BaseHandler<AppSendMessage>)this).SendError("invalid_motd");
			return;
		}
		IClan clan = await GetClan();
		if (clan == null)
		{
			((BaseHandler<AppSendMessage>)this).SendError("no_clan");
			return;
		}
		long previousTimestamp = clan.MotdTimestamp;
		ClanResult val = await clan.SetMotd(motd, base.UserId);
		if ((int)val == 1)
		{
			SendSuccess();
			ClanPushNotifications.SendClanAnnouncement(clan, previousTimestamp, base.UserId);
		}
		else
		{
			SendError(val);
		}
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class SetEntityValue : BaseEntityHandler<AppSetEntityValue>
{
	public override void Execute()
	{
		if (base.Entity is SmartSwitch smartSwitch)
		{
			smartSwitch.Value = base.Proto.value;
			SendSuccess();
		}
		else
		{
			SendError("wrong_type");
		}
	}
}


using CompanionServer.Handlers;
using ProtoBuf;

public class SetSubscription : BaseEntityHandler<AppFlag>
{
	public override void Execute()
	{
		if (base.Entity is ISubscribable subscribable)
		{
			if (base.Proto.value)
			{
				if (subscribable.AddSubscription(base.UserId))
				{
					SendSuccess();
				}
				else
				{
					SendError("too_many_subscribers");
				}
			}
			else
			{
				subscribable.RemoveSubscription(base.UserId);
			}
			SendSuccess();
		}
		else
		{
			SendError("wrong_type");
		}
	}
}


using System.Collections.Generic;
using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class TeamChat : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		if (playerTeam == null)
		{
			SendError("no_team");
			return;
		}
		AppResponse val = Pool.Get<AppResponse>();
		val.teamChat = Pool.Get<AppTeamChat>();
		val.teamChat.messages = Pool.Get<List<AppTeamMessage>>();
		IReadOnlyList<ChatLog.Entry> history = Server.TeamChat.GetHistory(playerTeam.teamID);
		if (history != null)
		{
			foreach (ChatLog.Entry item in history)
			{
				AppTeamMessage val2 = Pool.Get<AppTeamMessage>();
				val2.steamId = item.SteamId;
				val2.name = item.Name;
				val2.message = item.Message;
				val2.color = item.Color;
				val2.time = item.Time;
				val.teamChat.messages.Add(val2);
			}
		}
		Send(val);
	}
}


using CompanionServer;
using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;

public class TeamInfo : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(base.UserId);
		AppTeamInfo teamInfo = ((playerTeam == null) ? base.Player.GetAppTeamInfo(base.UserId) : playerTeam.GetAppTeamInfo(base.UserId));
		AppResponse val = Pool.Get<AppResponse>();
		val.teamInfo = teamInfo;
		Send(val);
	}
}


using CompanionServer.Handlers;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class Time : BasePlayerHandler<AppEmpty>
{
	public override void Execute()
	{
		TOD_Sky instance = TOD_Sky.Instance;
		TOD_Time time = instance.Components.Time;
		AppTime val = Pool.Get<AppTime>();
		val.dayLengthMinutes = time.DayLengthInMinutes;
		val.timeScale = (time.ProgressTime ? Time.timeScale : 0f);
		val.sunrise = instance.SunriseTime;
		val.sunset = instance.SunsetTime;
		val.time = instance.Cycle.Hour;
		AppResponse val2 = Pool.Get<AppResponse>();
		val2.time = val;
		Send(val2);
	}
}


public enum CameraRendererState
{
	Invalid,
	WaitingToRender,
	Rendering
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using CompanionServer;
using CompanionServer.Cameras;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class CameraRenderer : IPooled
{
	[ServerVar]
	public static bool enabled = true;

	[ServerVar]
	public static float completionFrameBudgetMs = 5f;

	[ServerVar]
	public static int maxRendersPerFrame = 25;

	[ServerVar]
	public static int maxRaysPerFrame = 100000;

	[ServerVar]
	public static int width = 160;

	[ServerVar]
	public static int height = 90;

	[ServerVar]
	public static float verticalFov = 65f;

	[ServerVar]
	public static float nearPlane = 0f;

	[ServerVar]
	public static float farPlane = 250f;

	[ServerVar]
	public static int layerMask = 1218656529;

	[ServerVar]
	public static float renderInterval = 0.05f;

	[ServerVar]
	public static int samplesPerRender = 3000;

	[ServerVar]
	public static int entityMaxAge = 5;

	[ServerVar]
	public static int entityMaxDistance = 100;

	[ServerVar]
	public static int playerMaxDistance = 30;

	[ServerVar]
	public static int playerNameMaxDistance = 10;

	private static readonly Dictionary<NetworkableId, NetworkableId> _entityIdMap = new Dictionary<NetworkableId, NetworkableId>();

	private readonly Dictionary<int, (byte MaterialIndex, int Age)> _knownColliders = new Dictionary<int, (byte, int)>();

	private readonly Dictionary<int, BaseEntity> _colliderToEntity = new Dictionary<int, BaseEntity>();

	private double _lastRenderTimestamp;

	private float _fieldOfView;

	private int _sampleOffset;

	private int _nextSampleOffset;

	private int _sampleCount;

	private CameraRenderTask _task;

	private ulong? _cachedViewerSteamId;

	private BasePlayer _cachedViewer;

	public CameraRendererState state;

	public IRemoteControllable rc;

	public BaseEntity entity;

	public CameraRenderer()
	{
		Reset();
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
	}

	public void Reset()
	{
		_knownColliders.Clear();
		_colliderToEntity.Clear();
		_lastRenderTimestamp = 0.0;
		_fieldOfView = 0f;
		_sampleOffset = 0;
		_nextSampleOffset = 0;
		_sampleCount = 0;
		if (_task != null)
		{
			CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
			if ((Object)(object)instance != (Object)null)
			{
				instance.ReturnTask(ref _task);
			}
		}
		_cachedViewerSteamId = null;
		_cachedViewer = null;
		state = CameraRendererState.Invalid;
		rc = null;
		entity = null;
	}

	public void Init(IRemoteControllable remoteControllable)
	{
		if (remoteControllable == null)
		{
			throw new ArgumentNullException("remoteControllable");
		}
		rc = remoteControllable;
		entity = remoteControllable.GetEnt();
		if ((Object)(object)entity == (Object)null || !entity.IsValid())
		{
			throw new ArgumentException("RemoteControllable's entity is null or invalid", "rc");
		}
		state = CameraRendererState.WaitingToRender;
	}

	public bool CanRender()
	{
		if (state != CameraRendererState.WaitingToRender)
		{
			return false;
		}
		if (TimeEx.realtimeSinceStartup - _lastRenderTimestamp < (double)renderInterval)
		{
			return false;
		}
		return true;
	}

	public void Render(int maxSampleCount)
	{
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			state = CameraRendererState.Invalid;
			return;
		}
		if (state != CameraRendererState.WaitingToRender)
		{
			throw new InvalidOperationException($"CameraRenderer cannot render in state {state}");
		}
		if (rc.IsUnityNull() || !entity.IsValid())
		{
			state = CameraRendererState.Invalid;
			return;
		}
		Transform eyes = rc.GetEyes();
		if ((Object)(object)eyes == (Object)null)
		{
			state = CameraRendererState.Invalid;
			return;
		}
		if (_task != null)
		{
			Debug.LogError((object)"CameraRenderer: Trying to render but a task is already allocated?", (Object)(object)entity);
			instance.ReturnTask(ref _task);
		}
		_fieldOfView = verticalFov / Mathf.Clamp(rc.GetFovScale(), 1f, 8f);
		_sampleCount = Mathf.Clamp(samplesPerRender, 1, Mathf.Min(width * height, maxSampleCount));
		_task = instance.BorrowTask();
		_nextSampleOffset = _task.Start(width, height, _fieldOfView, nearPlane, farPlane, layerMask, eyes, _sampleCount, _sampleOffset, _knownColliders);
		state = CameraRendererState.Rendering;
	}

	public void CompleteRender()
	{
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_044c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			state = CameraRendererState.Invalid;
			return;
		}
		if (state != CameraRendererState.Rendering)
		{
			throw new InvalidOperationException($"CameraRenderer cannot complete render in state {state}");
		}
		if (_task == null)
		{
			Debug.LogError((object)"CameraRenderer: Trying to complete render but no task is allocated?", (Object)(object)entity);
			state = CameraRendererState.Invalid;
		}
		else
		{
			if (((CustomYieldInstruction)_task).keepWaiting)
			{
				return;
			}
			if (rc.IsUnityNull() || !entity.IsValid())
			{
				instance.ReturnTask(ref _task);
				state = CameraRendererState.Invalid;
				return;
			}
			Transform eyes = rc.GetEyes();
			if ((Object)(object)eyes == (Object)null)
			{
				instance.ReturnTask(ref _task);
				state = CameraRendererState.Invalid;
				return;
			}
			int num = _sampleCount * 4;
			byte[] array = Shared.ArrayPool.Rent(num);
			List<int> hitColliderIds = Pool.Get<List<int>>();
			List<int> foundColliderIds = Pool.Get<List<int>>();
			int count = _task.ExtractRayData(array, hitColliderIds, foundColliderIds);
			instance.ReturnTask(ref _task);
			UpdateCollidersMap(foundColliderIds);
			Pool.FreeUnmanaged<int>(ref hitColliderIds);
			Pool.FreeUnmanaged<int>(ref foundColliderIds);
			ulong num2 = rc.ControllingViewerId?.SteamId ?? 0;
			if (num2 == 0L)
			{
				_cachedViewerSteamId = null;
				_cachedViewer = null;
			}
			else if (num2 != _cachedViewerSteamId)
			{
				_cachedViewerSteamId = num2;
				_cachedViewer = BasePlayer.FindByID(num2) ?? BasePlayer.FindSleeping(num2);
			}
			float distance = (_cachedViewer.IsValid() ? Mathf.Clamp01(Vector3.Distance(((Component)_cachedViewer).transform.position, ((Component)entity).transform.position) / rc.MaxRange) : 0f);
			Vector3 position = eyes.position;
			Quaternion rotation = eyes.rotation;
			Matrix4x4 worldToLocalMatrix = eyes.worldToLocalMatrix;
			NetworkableId iD = entity.net.ID;
			_entityIdMap.Clear();
			AppBroadcast val = Pool.Get<AppBroadcast>();
			val.cameraRays = Pool.Get<AppCameraRays>();
			val.cameraRays.verticalFov = _fieldOfView;
			val.cameraRays.sampleOffset = _sampleOffset;
			val.cameraRays.rayData = new ArraySegment<byte>(array, 0, count);
			val.cameraRays.distance = distance;
			val.cameraRays.entities = Pool.Get<List<Entity>>();
			val.cameraRays.timeOfDay = (((Object)(object)TOD_Sky.Instance != (Object)null) ? TOD_Sky.Instance.LerpValue : 1f);
			foreach (BaseEntity value in _colliderToEntity.Values)
			{
				if (!value.IsValid())
				{
					continue;
				}
				Vector3 position2 = ((Component)value).transform.position;
				float num3 = Vector3.Distance(position2, position);
				if (num3 > (float)entityMaxDistance)
				{
					continue;
				}
				string name = null;
				if (value is BasePlayer basePlayer)
				{
					if (num3 > (float)playerMaxDistance)
					{
						continue;
					}
					if (num3 <= (float)playerNameMaxDistance)
					{
						name = basePlayer.displayName;
					}
				}
				Entity val2 = Pool.Get<Entity>();
				val2.entityId = RandomizeEntityId(value.net.ID);
				val2.type = (EntityType)((value is TreeEntity) ? 1 : 2);
				val2.position = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(position2);
				Quaternion val3 = Quaternion.Inverse(((Component)value).transform.rotation) * rotation;
				val2.rotation = ((Quaternion)(ref val3)).eulerAngles * (MathF.PI / 180f);
				val2.size = Vector3.Scale(((Bounds)(ref value.bounds)).size, ((Component)value).transform.localScale);
				val2.name = name;
				val.cameraRays.entities.Add(val2);
			}
			val.cameraRays.entities.Sort((Entity x, Entity y) => x.entityId.Value.CompareTo(y.entityId.Value));
			Server.Broadcast(new CameraTarget(iD), val);
			_sampleOffset = _nextSampleOffset;
			if (!Server.HasAnySubscribers(new CameraTarget(iD)))
			{
				state = CameraRendererState.Invalid;
				return;
			}
			_lastRenderTimestamp = TimeEx.realtimeSinceStartup;
			state = CameraRendererState.WaitingToRender;
		}
	}

	private void UpdateCollidersMap(List<int> foundColliderIds)
	{
		List<int> list = Pool.Get<List<int>>();
		foreach (int key in _knownColliders.Keys)
		{
			list.Add(key);
		}
		List<int> list2 = Pool.Get<List<int>>();
		foreach (int item2 in list)
		{
			if (_knownColliders.TryGetValue(item2, out (byte, int) value))
			{
				if (value.Item2 > entityMaxAge)
				{
					list2.Add(item2);
				}
				else
				{
					_knownColliders[item2] = (value.Item1, value.Item2 + 1);
				}
			}
		}
		Pool.FreeUnmanaged<int>(ref list);
		foreach (int item3 in list2)
		{
			_knownColliders.Remove(item3);
			_colliderToEntity.Remove(item3);
		}
		Pool.FreeUnmanaged<int>(ref list2);
		foreach (int foundColliderId in foundColliderIds)
		{
			if (_knownColliders.Count >= 512)
			{
				break;
			}
			Collider collider = CameraBurstUtil.GetCollider(foundColliderId);
			if ((Object)(object)collider == (Object)null)
			{
				continue;
			}
			byte item;
			if (collider is TerrainCollider)
			{
				item = 1;
			}
			else
			{
				BaseEntity baseEntity = collider.ToBaseEntity();
				item = GetMaterialIndex(collider.sharedMaterial, baseEntity);
				if (baseEntity is TreeEntity || baseEntity is BasePlayer)
				{
					_colliderToEntity[foundColliderId] = baseEntity;
				}
			}
			_knownColliders[foundColliderId] = (item, 0);
		}
	}

	private static NetworkableId RandomizeEntityId(NetworkableId realId)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (_entityIdMap.TryGetValue(realId, out var value))
		{
			return value;
		}
		NetworkableId val = default(NetworkableId);
		do
		{
			((NetworkableId)(ref val))..ctor((ulong)Random.Range(0, 2500));
		}
		while (_entityIdMap.ContainsKey(val));
		_entityIdMap.Add(realId, val);
		return val;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static byte GetMaterialIndex(PhysicMaterial material, BaseEntity entity)
	{
		switch (material.GetName())
		{
		case "Water":
			return 2;
		case "Rock":
			return 3;
		case "Stones":
			return 4;
		case "Wood":
			return 5;
		case "Metal":
			return 6;
		default:
			if ((Object)(object)entity != (Object)null && entity is BasePlayer)
			{
				return 7;
			}
			return 0;
		}
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public struct RaycastSamplePositionsJob : IJob
{
	public int2 res;

	public Random random;

	public NativeArray<int2> positions;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < res.y; i++)
		{
			for (int j = 0; j < res.x; j++)
			{
				positions[num++] = new int2(j, i);
			}
		}
		for (num = res.x * res.y - 1; num >= 1; num--)
		{
			int num2 = ((Random)(ref random)).NextInt(num + 1);
			ref NativeArray<int2> reference = ref positions;
			int num3 = num;
			ref NativeArray<int2> reference2 = ref positions;
			int num4 = num2;
			int2 val = positions[num2];
			int2 val2 = positions[num];
			int2 val4 = (reference[num3] = val);
			val4 = (reference2[num4] = val2);
		}
	}
}


using Unity.Collections;
using Unity.Jobs;

public struct RaycastBufferSetupJob : IJob
{
	public NativeArray<int> colliderIds;

	public NativeArray<byte> colliderMaterials;

	[WriteOnly]
	public NativeArray<int> colliderHits;

	public void Execute()
	{
		if (colliderIds.Length > 1)
		{
			SortByAscending(ref colliderIds, ref colliderMaterials, 0, colliderIds.Length - 1);
		}
		for (int i = 0; i < colliderHits.Length; i++)
		{
			colliderHits[i] = 0;
		}
	}

	private static void SortByAscending(ref NativeArray<int> colliderIds, ref NativeArray<byte> colliderMaterials, int leftIndex, int rightIndex)
	{
		int i = leftIndex;
		int num = rightIndex;
		int num2 = colliderIds[leftIndex];
		while (i <= num)
		{
			for (; colliderIds[i] < num2; i++)
			{
			}
			while (colliderIds[num] > num2)
			{
				num--;
			}
			if (i <= num)
			{
				int num3 = i;
				int num4 = num;
				int num5 = colliderIds[num];
				int num6 = colliderIds[i];
				int num8 = (colliderIds[num3] = num5);
				num8 = (colliderIds[num4] = num6);
				num4 = i;
				num3 = num;
				byte b = colliderMaterials[num];
				byte b2 = colliderMaterials[i];
				byte b4 = (colliderMaterials[num4] = b);
				b4 = (colliderMaterials[num3] = b2);
				i++;
				num--;
			}
		}
		if (leftIndex < num)
		{
			SortByAscending(ref colliderIds, ref colliderMaterials, leftIndex, num);
		}
		if (i < rightIndex)
		{
			SortByAscending(ref colliderIds, ref colliderMaterials, i, rightIndex);
		}
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct RaycastRaySetupJob : IJobParallelFor
{
	public float2 res;

	public float2 halfRes;

	public float aspectRatio;

	public float worldHeight;

	public float3 cameraPos;

	public quaternion cameraRot;

	public float nearPlane;

	public float farPlane;

	public int layerMask;

	public int sampleOffset;

	[ReadOnly]
	public NativeArray<int2> samplePositions;

	[WriteOnly]
	[NativeMatchesParallelForLength]
	public NativeArray<RaycastCommand> raycastCommands;

	public void Execute(int index)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		int num;
		for (num = sampleOffset + index; num >= samplePositions.Length; num -= samplePositions.Length)
		{
		}
		float2 val = (float2.op_Implicit(samplePositions[num]) - halfRes) / res;
		float3 val2 = default(float3);
		((float3)(ref val2))..ctor(val.x * worldHeight * aspectRatio, val.y * worldHeight, 1f);
		float3 val3 = math.mul(cameraRot, val2);
		float3 val4 = cameraPos + val3 * nearPlane;
		raycastCommands[index] = new RaycastCommand(float3.op_Implicit(val4), float3.op_Implicit(val3), farPlane, layerMask, 1);
	}
}


using System.Threading;
using CompanionServer.Cameras;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public struct RaycastRayProcessingJob : IJobParallelFor
{
	public float3 cameraForward;

	public float farPlane;

	[ReadOnly]
	public NativeArray<RaycastHit> raycastHits;

	[ReadOnly]
	public NativeArray<int> colliderIds;

	[ReadOnly]
	public NativeArray<byte> colliderMaterials;

	[NativeDisableParallelForRestriction]
	[WriteOnly]
	public NativeArray<int> colliderHits;

	[WriteOnly]
	[NativeMatchesParallelForLength]
	public NativeArray<int> outputs;

	[NativeDisableParallelForRestriction]
	public NativeArray<int> foundCollidersIndex;

	[NativeDisableParallelForRestriction]
	public NativeArray<int> foundColliders;

	public void Execute(int index)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		ref RaycastHit @readonly = BurstUtil.GetReadonly<RaycastHit>(ref raycastHits, index);
		int colliderId = @readonly.GetColliderId();
		bool num = colliderId != 0;
		byte b = 0;
		if (num)
		{
			int num2 = Interlocked.Increment(ref BurstUtil.Get<int>(ref foundCollidersIndex, 0));
			if (num2 <= foundColliders.Length)
			{
				foundColliders[num2 - 1] = colliderId;
			}
			int num3 = BinarySearch(colliderIds, colliderId);
			if (num3 >= 0)
			{
				b = colliderMaterials[num3];
				Interlocked.Increment(ref BurstUtil.Get<int>(ref colliderHits, num3));
			}
		}
		float distance;
		RaycastHit val;
		if (!num)
		{
			distance = farPlane;
		}
		else
		{
			val = @readonly;
			distance = ((RaycastHit)(ref val)).distance;
		}
		float num4 = distance;
		if (b == 7)
		{
			b = 0;
			num4 *= 1.1f;
		}
		float num5 = math.clamp(num4 / farPlane, 0f, 1f);
		float3 val2 = cameraForward;
		val = @readonly;
		float num6 = math.max(math.dot(val2, float3.op_Implicit(((RaycastHit)(ref val)).normal)), 0f);
		ushort num7 = (ushort)(num5 * 1023f);
		byte b2 = (byte)(num6 * 63f);
		outputs[index] = (num7 >> 8 << 24) | ((num7 & 0xFF) << 16) | (b2 << 8) | b;
	}

	private static int BinarySearch(NativeArray<int> haystack, int needle)
	{
		int num = 0;
		int num2 = haystack.Length - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num / 2);
			int num4 = Compare(haystack[num3], needle);
			if (num4 == 0)
			{
				return num3;
			}
			if (num4 < 0)
			{
				num = num3 + 1;
			}
			else
			{
				num2 = num3 - 1;
			}
		}
		return ~num;
	}

	private static int Compare(int x, int y)
	{
		if (x < y)
		{
			return -1;
		}
		if (x > y)
		{
			return 1;
		}
		return 0;
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Jobs;

public struct RaycastOutputCompressJob : IJob
{
	[ReadOnly]
	public NativeArray<int> rayOutputs;

	[WriteOnly]
	public NativeArray<int> dataLength;

	[WriteOnly]
	public NativeArray<byte> data;

	public void Execute()
	{
		int num = rayOutputs.Length * 4;
		if (data.Length < num)
		{
			throw new InvalidOperationException("Not enough data buffer available to compress rays");
		}
		NativeArray<int> val = default(NativeArray<int>);
		val..ctor(64, (Allocator)2, (NativeArrayOptions)1);
		int num2 = 0;
		for (int i = 0; i < rayOutputs.Length; i++)
		{
			int num3 = rayOutputs[i];
			ushort num4 = RayDistance(num3);
			byte b = RayAlignment(num3);
			byte b2 = RayMaterial(num3);
			int num5 = (num4 / 128 * 3 + b / 16 * 5 + b2 * 7) & 0x3F;
			int num6 = val[num5];
			if (num6 == num3)
			{
				data[num2++] = (byte)(0 | num5);
				continue;
			}
			int num7 = num4 - RayDistance(num6);
			int num8 = b - RayAlignment(num6);
			if (b2 == RayMaterial(num6) && num7 >= -15 && num7 <= 16 && num8 >= -3 && num8 <= 4)
			{
				data[num2++] = (byte)(0x40 | num5);
				data[num2++] = (byte)((num7 + 15 << 3) | (num8 + 3));
			}
			else if (b2 == RayMaterial(num6) && num8 == 0 && num7 >= -127 && num7 <= 128)
			{
				data[num2++] = (byte)(0x80 | num5);
				data[num2++] = (byte)(num7 + 127);
			}
			else if (b2 < 63)
			{
				val[num5] = num3;
				data[num2++] = (byte)(0xC0 | b2);
				data[num2++] = (byte)(num4 >> 2);
				data[num2++] = (byte)(((num4 & 3) << 6) | b);
			}
			else
			{
				val[num5] = num3;
				data[num2++] = byte.MaxValue;
				data[num2++] = (byte)(num4 >> 2);
				data[num2++] = (byte)(((num4 & 3) << 6) | b);
				data[num2++] = b2;
			}
		}
		val.Dispose();
		dataLength[0] = num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static ushort RayDistance(int ray)
	{
		return (ushort)(ray >> 16);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static byte RayAlignment(int ray)
	{
		return (byte)(ray >> 8);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static byte RayMaterial(int ray)
	{
		return (byte)ray;
	}
}


using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public struct RaycastColliderProcessingJob : IJob
{
	public NativeArray<int> foundCollidersLength;

	public NativeArray<int> foundColliders;

	public void Execute()
	{
		int num = math.min(foundCollidersLength[0], foundColliders.Length);
		if (num <= 1)
		{
			return;
		}
		SortAscending(ref foundColliders, 0, num - 1);
		NativeArray<int> counts = default(NativeArray<int>);
		counts..ctor(num, (Allocator)2, (NativeArrayOptions)0);
		int num2 = 0;
		int i = 0;
		while (i < num)
		{
			int num3 = foundColliders[i];
			int num4 = 1;
			for (; i < num && foundColliders[i] == num3; i++)
			{
				num4++;
			}
			foundColliders[num2] = num3;
			counts[num2] = num4;
			num2++;
		}
		SortByDescending(ref foundColliders, ref counts, 0, num2 - 1);
		counts.Dispose();
		int num5 = math.min(num2, 512);
		foundCollidersLength[0] = num5;
	}

	private static void SortByDescending(ref NativeArray<int> colliders, ref NativeArray<int> counts, int leftIndex, int rightIndex)
	{
		int i = leftIndex;
		int num = rightIndex;
		int num2 = counts[leftIndex];
		while (i <= num)
		{
			for (; counts[i] > num2; i++)
			{
			}
			while (counts[num] < num2)
			{
				num--;
			}
			if (i <= num)
			{
				int num3 = i;
				ref NativeArray<int> reference = ref colliders;
				int num4 = num;
				int num5 = colliders[num];
				int num6 = colliders[i];
				int num8 = (colliders[num3] = num5);
				num8 = (reference[num4] = num6);
				num4 = i;
				reference = ref counts;
				num3 = num;
				num6 = counts[num];
				num5 = counts[i];
				num8 = (counts[num4] = num6);
				num8 = (reference[num3] = num5);
				i++;
				num--;
			}
		}
		if (leftIndex < num)
		{
			SortByDescending(ref colliders, ref counts, leftIndex, num);
		}
		if (i < rightIndex)
		{
			SortByDescending(ref colliders, ref counts, i, rightIndex);
		}
	}

	private static void SortAscending(ref NativeArray<int> array, int leftIndex, int rightIndex)
	{
		int i = leftIndex;
		int num = rightIndex;
		int num2 = array[leftIndex];
		while (i <= num)
		{
			for (; array[i] < num2; i++)
			{
			}
			while (array[num] > num2)
			{
				num--;
			}
			if (i <= num)
			{
				int num3 = i;
				int num4 = num;
				int num5 = array[num];
				int num6 = array[i];
				int num8 = (array[num3] = num5);
				num8 = (array[num4] = num6);
				i++;
				num--;
			}
		}
		if (leftIndex < num)
		{
			SortAscending(ref array, leftIndex, num);
		}
		if (i < rightIndex)
		{
			SortAscending(ref array, i, rightIndex);
		}
	}
}


using System.Runtime.CompilerServices;
using CompanionServer.Cameras;
using UnityEngine;

internal static class CameraBurstUtil
{
	private struct RaycastHitPublic
	{
		public Vector3 m_Point;

		public Vector3 m_Normal;

		public uint m_FaceID;

		public float m_Distance;

		public Vector2 m_UV;

		public int m_Collider;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static int GetColliderId(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).colliderInstanceID;
	}

	public unsafe static Collider GetCollider(int colliderInstanceId)
	{
		RaycastHitPublic raycastHitPublic = default(RaycastHitPublic);
		raycastHitPublic.m_Collider = colliderInstanceId;
		RaycastHitPublic raycastHitPublic2 = raycastHitPublic;
		return ((RaycastHit)(&raycastHitPublic2)).collider;
	}
}


using UnityEngine;

private struct RaycastHitPublic
{
	public Vector3 m_Point;

	public Vector3 m_Normal;

	public uint m_FaceID;

	public float m_Distance;

	public Vector2 m_UV;

	public int m_Collider;
}


using System;
using System.Collections.Generic;
using CompanionServer.Cameras;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public class CameraRenderTask : CustomYieldInstruction, IDisposable
{
	public const int MaxSamplesPerRender = 10000;

	public const int MaxColliders = 512;

	private static readonly Dictionary<(int, int), NativeArray<int2>> _samplePositions = new Dictionary<(int, int), NativeArray<int2>>();

	private NativeArray<RaycastCommand> _raycastCommands;

	private NativeArray<RaycastHit> _raycastHits;

	private NativeArray<int> _colliderIds;

	private NativeArray<byte> _colliderMaterials;

	private NativeArray<int> _colliderHits;

	private NativeArray<int> _raycastOutput;

	private NativeArray<int> _foundCollidersLength;

	private NativeArray<int> _foundColliders;

	private NativeArray<int> _outputDataLength;

	private NativeArray<byte> _outputData;

	private JobHandle? _pendingJob;

	private int _sampleCount;

	private int _colliderLength;

	public override bool keepWaiting
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			if (_pendingJob.HasValue)
			{
				JobHandle value = _pendingJob.Value;
				return !((JobHandle)(ref value)).IsCompleted;
			}
			return false;
		}
	}

	public CameraRenderTask()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		_raycastCommands = new NativeArray<RaycastCommand>(10000, (Allocator)4, (NativeArrayOptions)1);
		_raycastHits = new NativeArray<RaycastHit>(10000, (Allocator)4, (NativeArrayOptions)0);
		_colliderIds = new NativeArray<int>(512, (Allocator)4, (NativeArrayOptions)0);
		_colliderMaterials = new NativeArray<byte>(512, (Allocator)4, (NativeArrayOptions)0);
		_colliderHits = new NativeArray<int>(512, (Allocator)4, (NativeArrayOptions)0);
		_raycastOutput = new NativeArray<int>(10000, (Allocator)4, (NativeArrayOptions)0);
		_foundCollidersLength = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)0);
		_foundColliders = new NativeArray<int>(10000, (Allocator)4, (NativeArrayOptions)0);
		_outputDataLength = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)0);
		_outputData = new NativeArray<byte>(40000, (Allocator)4, (NativeArrayOptions)0);
	}

	~CameraRenderTask()
	{
		try
		{
			Dispose();
		}
		finally
		{
			((object)this).Finalize();
		}
	}

	public void Dispose()
	{
		_raycastCommands.Dispose();
		_raycastHits.Dispose();
		_colliderIds.Dispose();
		_colliderMaterials.Dispose();
		_colliderHits.Dispose();
		_raycastOutput.Dispose();
		_foundCollidersLength.Dispose();
		_foundColliders.Dispose();
		_outputDataLength.Dispose();
		_outputData.Dispose();
	}

	public void Reset()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (_pendingJob.HasValue)
		{
			JobHandle value = _pendingJob.Value;
			if (!((JobHandle)(ref value)).IsCompleted)
			{
				Debug.LogWarning((object)"CameraRenderTask is resetting before completion! This will cause it to synchronously block for completion.");
			}
			value = _pendingJob.Value;
			((JobHandle)(ref value)).Complete();
		}
		_pendingJob = null;
		_sampleCount = 0;
	}

	public int Start(int width, int height, float verticalFov, float nearPlane, float farPlane, int layerMask, Transform cameraTransform, int sampleCount, int sampleOffset, Dictionary<int, (byte MaterialIndex, int Age)> knownColliders)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cameraTransform == (Object)null)
		{
			throw new ArgumentNullException("cameraTransform");
		}
		if (sampleCount <= 0 || sampleCount > 10000)
		{
			throw new ArgumentOutOfRangeException("sampleCount");
		}
		if (sampleOffset < 0)
		{
			throw new ArgumentOutOfRangeException("sampleOffset");
		}
		if (knownColliders == null)
		{
			throw new ArgumentNullException("knownColliders");
		}
		if (knownColliders.Count > 512)
		{
			throw new ArgumentException("Too many colliders", "knownColliders");
		}
		if (_pendingJob.HasValue)
		{
			throw new InvalidOperationException("A render job was already started for this instance.");
		}
		_sampleCount = sampleCount;
		_colliderLength = knownColliders.Count;
		int num = 0;
		foreach (KeyValuePair<int, (byte, int)> knownCollider in knownColliders)
		{
			_colliderIds[num] = knownCollider.Key;
			_colliderMaterials[num] = knownCollider.Value.Item1;
			num++;
		}
		NativeArray<int2> samplePositions = GetSamplePositions(width, height);
		_foundCollidersLength[0] = 0;
		RaycastBufferSetupJob raycastBufferSetupJob = default(RaycastBufferSetupJob);
		raycastBufferSetupJob.colliderIds = _colliderIds.GetSubArray(0, _colliderLength);
		raycastBufferSetupJob.colliderMaterials = _colliderMaterials.GetSubArray(0, _colliderLength);
		raycastBufferSetupJob.colliderHits = _colliderHits.GetSubArray(0, _colliderLength);
		RaycastBufferSetupJob raycastBufferSetupJob2 = raycastBufferSetupJob;
		RaycastRaySetupJob raycastRaySetupJob = default(RaycastRaySetupJob);
		raycastRaySetupJob.res = new float2((float)width, (float)height);
		raycastRaySetupJob.halfRes = new float2((float)width / 2f, (float)height / 2f);
		raycastRaySetupJob.aspectRatio = (float)width / (float)height;
		raycastRaySetupJob.worldHeight = 2f * Mathf.Tan(MathF.PI / 360f * verticalFov);
		raycastRaySetupJob.cameraPos = float3.op_Implicit(cameraTransform.position);
		raycastRaySetupJob.cameraRot = quaternion.op_Implicit(cameraTransform.rotation);
		raycastRaySetupJob.nearPlane = nearPlane;
		raycastRaySetupJob.farPlane = farPlane;
		raycastRaySetupJob.layerMask = layerMask;
		raycastRaySetupJob.samplePositions = samplePositions;
		raycastRaySetupJob.sampleOffset = sampleOffset % samplePositions.Length;
		raycastRaySetupJob.raycastCommands = _raycastCommands.GetSubArray(0, sampleCount);
		RaycastRaySetupJob raycastRaySetupJob2 = raycastRaySetupJob;
		RaycastRayProcessingJob raycastRayProcessingJob = default(RaycastRayProcessingJob);
		raycastRayProcessingJob.cameraForward = float3.op_Implicit(-cameraTransform.forward);
		raycastRayProcessingJob.farPlane = farPlane;
		raycastRayProcessingJob.raycastHits = _raycastHits.GetSubArray(0, sampleCount);
		raycastRayProcessingJob.colliderIds = _colliderIds.GetSubArray(0, _colliderLength);
		raycastRayProcessingJob.colliderMaterials = _colliderMaterials.GetSubArray(0, _colliderLength);
		raycastRayProcessingJob.colliderHits = _colliderHits.GetSubArray(0, _colliderLength);
		raycastRayProcessingJob.outputs = _raycastOutput.GetSubArray(0, sampleCount);
		raycastRayProcessingJob.foundCollidersIndex = _foundCollidersLength;
		raycastRayProcessingJob.foundColliders = _foundColliders;
		RaycastRayProcessingJob raycastRayProcessingJob2 = raycastRayProcessingJob;
		RaycastColliderProcessingJob raycastColliderProcessingJob = default(RaycastColliderProcessingJob);
		raycastColliderProcessingJob.foundCollidersLength = _foundCollidersLength;
		raycastColliderProcessingJob.foundColliders = _foundColliders;
		RaycastColliderProcessingJob raycastColliderProcessingJob2 = raycastColliderProcessingJob;
		RaycastOutputCompressJob raycastOutputCompressJob = default(RaycastOutputCompressJob);
		raycastOutputCompressJob.rayOutputs = _raycastOutput.GetSubArray(0, sampleCount);
		raycastOutputCompressJob.dataLength = _outputDataLength;
		raycastOutputCompressJob.data = _outputData;
		RaycastOutputCompressJob raycastOutputCompressJob2 = raycastOutputCompressJob;
		JobHandle val = IJobExtensions.Schedule<RaycastBufferSetupJob>(raycastBufferSetupJob2, default(JobHandle));
		JobHandle val2 = IJobParallelForExtensions.Schedule<RaycastRaySetupJob>(raycastRaySetupJob2, sampleCount, 100, default(JobHandle));
		JobHandle val3 = RaycastCommand.ScheduleBatch(_raycastCommands.GetSubArray(0, sampleCount), _raycastHits.GetSubArray(0, sampleCount), 100, val2);
		JobHandle val4 = IJobParallelForExtensions.Schedule<RaycastRayProcessingJob>(raycastRayProcessingJob2, sampleCount, 100, JobHandle.CombineDependencies(val, val3));
		JobHandle val5 = IJobExtensions.Schedule<RaycastColliderProcessingJob>(raycastColliderProcessingJob2, val4);
		JobHandle val6 = IJobExtensions.Schedule<RaycastOutputCompressJob>(raycastOutputCompressJob2, val4);
		_pendingJob = JobHandle.CombineDependencies(val6, val5);
		return sampleOffset + sampleCount;
	}

	public int ExtractRayData(byte[] buffer, List<int> hitColliderIds = null, List<int> foundColliderIds = null)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		if (buffer == null)
		{
			throw new ArgumentNullException("buffer");
		}
		int num = _sampleCount * 4;
		if (buffer.Length < num)
		{
			throw new ArgumentException("Output buffer is not large enough to hold all the ray data", "buffer");
		}
		if (!_pendingJob.HasValue)
		{
			throw new InvalidOperationException("Job was not started for this CameraRenderTask");
		}
		JobHandle value = _pendingJob.Value;
		if (!((JobHandle)(ref value)).IsCompleted)
		{
			Debug.LogWarning((object)"Trying to extract ray data from CameraRenderTask before completion! This will cause it to synchronously block for completion.");
		}
		value = _pendingJob.Value;
		((JobHandle)(ref value)).Complete();
		int num2 = _outputDataLength[0];
		NativeArray<byte>.Copy(_outputData.GetSubArray(0, num2), buffer, num2);
		if (hitColliderIds != null)
		{
			hitColliderIds.Clear();
			for (int i = 0; i < _colliderLength; i++)
			{
				if (_colliderHits[i] > 0)
				{
					hitColliderIds.Add(_colliderIds[i]);
				}
			}
		}
		if (foundColliderIds != null)
		{
			foundColliderIds.Clear();
			int num3 = _foundCollidersLength[0];
			for (int j = 0; j < num3; j++)
			{
				foundColliderIds.Add(_foundColliders[j]);
			}
		}
		return num2;
	}

	private static NativeArray<int2> GetSamplePositions(int width, int height)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (width <= 0)
		{
			throw new ArgumentOutOfRangeException("width");
		}
		if (height <= 0)
		{
			throw new ArgumentOutOfRangeException("height");
		}
		(int, int) key = (width, height);
		if (_samplePositions.TryGetValue(key, out var value))
		{
			return value;
		}
		value..ctor(width * height, (Allocator)4, (NativeArrayOptions)0);
		RaycastSamplePositionsJob raycastSamplePositionsJob = default(RaycastSamplePositionsJob);
		raycastSamplePositionsJob.res = new int2(width, height);
		raycastSamplePositionsJob.random = new Random(1337u);
		raycastSamplePositionsJob.positions = value;
		IJobExtensions.Run<RaycastSamplePositionsJob>(raycastSamplePositionsJob);
		_samplePositions.Add(key, value);
		return value;
	}

	public static void FreeCachedSamplePositions()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<(int, int), NativeArray<int2>> samplePosition in _samplePositions)
		{
			samplePosition.Value.Dispose();
		}
		_samplePositions.Clear();
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GatherPlayersWithTicksJob : IJob
{
	[WriteOnly]
	public NativeList<int> ValidIndices;

	[ReadOnly]
	public TickInterpolatorCache.ReadOnlyState TickCache;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<int> enumerator = Indices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				if (TickCache.Infos[current].Count > 0)
				{
					ValidIndices.AddNoResize(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct BuildLayerMasksJob : IJob
{
	[WriteOnly]
	public NativeList<int> LayerMasks;

	[ReadOnly]
	internal ReadOnly<AntiHack.Batch> Batches;

	[ReadOnly]
	public int DefaultMask;

	[ReadOnly]
	public int NoVehiclesMask;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<AntiHack.Batch> enumerator = Batches.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				AntiHack.Batch current = enumerator.Current;
				int num = (current.VehicleLayer ? DefaultMask : NoVehiclesMask);
				for (int i = 0; i < current.Count; i++)
				{
					LayerMasks.AddNoResize(num);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GatherHitIndicesJob : IJob
{
	[WriteOnly]
	public NativeList<int> Results;

	[ReadOnly]
	public ReadOnly<bool> Hits;

	public void Execute()
	{
		for (int i = 0; i < Hits.Length; i++)
		{
			if (Hits[i])
			{
				Results.AddNoResize(i);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct BuildBatchLookupMapJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Lookup;

	[ReadOnly]
	internal ReadOnly<AntiHack.Batch> Batches;

	public void Execute()
	{
		int num = 0;
		for (int i = 0; i < Batches.Length; i++)
		{
			AntiHack.Batch batch = Batches[i];
			for (int j = 0; j < batch.Count; j++)
			{
				int num2 = num + j;
				Lookup[num2] = i;
			}
			num += batch.Count;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherNoClipBatchesJob : IJob
{
	[WriteOnly]
	public NativeList<Vector3> From;

	[WriteOnly]
	public NativeList<Vector3> To;

	internal NativeArray<AntiHack.Batch> Batches;

	[ReadOnly]
	public TickInterpolatorCache.ReadOnlyState TickCache;

	[ReadOnly]
	public ReadOnly<Matrix4x4> Matrices;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<float> DeltaTimes;

	[ReadOnly]
	public int MaxSteps;

	[ReadOnly]
	public float DefaultStepSize;

	[ReadOnly]
	public float LagThreshold;

	[ReadOnly]
	public bool TickBufferPrevention;

	[ReadOnly]
	public float MaxTickCount;

	[ReadOnly]
	public int DefaultProtection;

	public void Execute()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = BasePlayer.NoClipOffset();
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			TickInterpolatorCache.PlayerTickIterator playerTickIterator = TickInterpolatorCache.GetPlayerTickIterator(TickCache, num);
			Matrix4x4 val2 = Matrices[i];
			bool flag = ((Matrix4x4)(ref val2))[15] == 0f;
			Vector3 val3 = (flag ? playerTickIterator.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(playerTickIterator.StartPoint));
			Vector3 val4 = (flag ? playerTickIterator.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(playerTickIterator.EndPoint));
			AntiHack.Batch batch = Batches[i];
			bool num2 = DeltaTimes[num] < LagThreshold && TickBufferPrevention;
			int count = batch.Count;
			int num3 = DefaultProtection;
			if (num2 && (float)count >= MaxTickCount)
			{
				num3 = Mathf.Min(2, num3);
			}
			if (num3 >= 3)
			{
				float distance = Mathf.Max(playerTickIterator.Length / (float)MaxSteps, DefaultStepSize);
				int num4 = 0;
				while (playerTickIterator.MoveNext(distance))
				{
					num4++;
					val4 = (flag ? playerTickIterator.CurrentPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(playerTickIterator.CurrentPoint));
					From.AddNoResize(val3 + val);
					To.AddNoResize(val4 + val);
					val3 = val4;
				}
				batch.Count = num4;
			}
			else
			{
				From.AddNoResize(val3 + val);
				To.AddNoResize(val4 + val);
				batch.Count = 1;
			}
			Batches[i] = batch;
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct FindValidIndicesJob : IJob
{
	[WriteOnly]
	public NativeList<int> ValidIndices;

	public NativeArray<bool> WorkBuffer;

	[ReadOnly]
	public ReadOnly<int> InvalidIndices;

	[ReadOnly]
	public ReadOnly<int> AllIndices;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<int> enumerator = AllIndices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				WorkBuffer[current] = true;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = InvalidIndices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current2 = enumerator.Current;
				WorkBuffer[current2] = false;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = AllIndices.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current3 = enumerator.Current;
				if (WorkBuffer[current3])
				{
					ValidIndices.AddNoResize(current3);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct InsideTerrainHeightsChecksJob : IJob
{
	[WriteOnly]
	public NativeArray<bool> Results;

	[WriteOnly]
	public NativeList<int> IndicesToCheck;

	[WriteOnly]
	public NativeArray<Vector3> PosiToCheck;

	[WriteOnly]
	public NativeArray<float> RadiiToCheck;

	[ReadOnly]
	public ReadOnly<Vector3> Posi;

	[ReadOnly]
	public ReadOnly<float> HeightMapHeights;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public float TerrainPadding;

	[ReadOnly]
	public float RadiusToCheck;

	public void Execute()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < Posi.Length; i++)
		{
			Vector3 val = Posi[i];
			float num2 = val.y + TerrainPadding;
			float num3 = HeightMapHeights[i];
			float num4 = TerrainHeights[i];
			if (num2 > num3 || num2 > num4)
			{
				Results[i] = false;
				continue;
			}
			IndicesToCheck.AddNoResize(i);
			PosiToCheck[num] = val;
			RadiiToCheck[num] = RadiusToCheck;
			num++;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct ScatterInvertedBool : IJob
{
	[WriteOnly]
	public NativeArray<bool> To;

	[ReadOnly]
	public ReadOnly<bool> From;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			To[Indices[i]] = !From[i];
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct GenerateInsideMeshCommandsJob : IJobFor
{
	[WriteOnly]
	public NativeArray<RaycastCommand> Commands;

	[ReadOnly]
	public ReadOnly<Vector3> Posi;

	[ReadOnly]
	public float Distance;

	public void Execute(int index)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		QueryParameters val = default(QueryParameters);
		((QueryParameters)(ref val))..ctor(65536, false, (QueryTriggerInteraction)0, true);
		Commands[index] = new RaycastCommand(Posi[index], Vector3.up, val, Distance);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckInsideMeshHitsJob : IJobFor
{
	[WriteOnly]
	public NativeArray<bool> Results;

	[ReadOnly]
	public ReadOnly<RaycastHit> Hits;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = Hits[index];
		Results[index] = ((RaycastHit)(ref val)).colliderInstanceID != 0 && Vector3.Dot(Vector3.up, ((RaycastHit)(ref val)).normal) > 0f;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct FilterInsideMeshHitsJob : IJobFor
{
	public NativeArray<RaycastHit> Hits;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = Hits[index];
		if (((RaycastHit)(ref val)).colliderInstanceID == 0 || !(Vector3.Dot(Vector3.up, ((RaycastHit)(ref val)).normal) > 0f))
		{
			Hits[index] = default(RaycastHit);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public static class NativeArrayEx
{
	public static void Add<T>(this ref NativeArray<T> array, T item, ref int size) where T : unmanaged
	{
		if (size >= array.Length)
		{
			Expand(ref array, array.Length * 2, (NativeArrayOptions)1);
		}
		array[size] = item;
		size++;
	}

	public static void RemoveUnordered<T>(this ref NativeArray<T> array, int index, ref int count) where T : unmanaged
	{
		int num = count - 1;
		if (index != num)
		{
			array[index] = array[num];
		}
		count--;
	}

	public static void Expand<T>(this ref NativeArray<T> array, int newCapacity, NativeArrayOptions options = 1, bool copyContents = true, bool usePowerOfTwo = false) where T : struct
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if (newCapacity <= array.Length)
		{
			return;
		}
		NativeArray<T> val = default(NativeArray<T>);
		val..ctor(usePowerOfTwo ? Mathf.NextPowerOfTwo(newCapacity) : newCapacity, (Allocator)4, options);
		if (array.IsCreated)
		{
			if (copyContents)
			{
				array.CopyTo(val.GetSubArray(0, array.Length));
			}
			array.Dispose();
		}
		array = val;
	}

	public static void SafeDispose<T>(this ref NativeArray<T> array) where T : unmanaged
	{
		if (array.IsCreated)
		{
			array.Dispose();
		}
	}

	public unsafe static void MemClear<T>(this in NativeArray<T> array) where T : struct
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		UnsafeUtility.MemClear(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks<T>(array), (long)(UnsafeUtility.SizeOf<T>() * array.Length));
	}

	public unsafe static void MemSet<T>(this in NativeArray<T> array, byte value) where T : struct
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		UnsafeUtility.MemSet(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks<T>(array), value, (long)(UnsafeUtility.SizeOf<T>() * array.Length));
	}

	public unsafe static NativeBitArray AsBitArray<T>(this ref NativeArray<T> array) where T : struct
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return NativeBitArrayUnsafeUtility.ConvertExistingDataToNativeBitArray(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks<T>(array), array.Length, AllocatorHandle.op_Implicit((Allocator)1));
	}

	[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
	private static void CheckReinterpretLoadRange<U, T>(this ref ReadOnly<T> array, int sourceIndex) where U : struct where T : struct
	{
	}

	public unsafe static U ReinterpretLoad<U, T>(this ref ReadOnly<T> array, int sourceIndex) where U : struct where T : struct
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return UnsafeUtility.ReadArrayElement<U>((void*)((byte*)NativeArrayUnsafeUtility.GetUnsafeReadOnlyPtr<T>(array) + (long)UnsafeUtility.SizeOf<T>() * (long)sourceIndex), 0);
	}

	public static bool TryFindRegion<T>(this ref NativeArray<T> array, T value, ref int index, ref int length) where T : struct, IEquatable<T>
	{
		index += length;
		while (index < array.Length && !EqualityComparer<T>.Default.Equals(array[index], value))
		{
			index++;
		}
		if (index == array.Length)
		{
			return false;
		}
		length = 1;
		while (index + length < array.Length && EqualityComparer<T>.Default.Equals(array[index + length], value))
		{
			length++;
		}
		return true;
	}

	public static bool GenericEquals<T>(T a, T b) where T : IEquatable<T>
	{
		return a.Equals(b);
	}
}


using Unity.Collections;

public static class NativeReferenceEx
{
	public static void SafeDispose<T>(this ref NativeReference<T> reference) where T : unmanaged
	{
		if (reference.IsCreated)
		{
			reference.Dispose();
		}
	}
}


using Unity.Collections;

public static class NativeListEx
{
	public static void Expand<T>(this ref NativeList<T> list, int newCapacity, bool copyContents = true) where T : unmanaged
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (!list.IsCreated || newCapacity > list.Capacity)
		{
			if (list.IsCreated)
			{
				if (copyContents)
				{
					list.Capacity = newCapacity;
				}
				else
				{
					list.Dispose();
					list = new NativeList<T>(newCapacity, AllocatorHandle.op_Implicit((Allocator)4));
				}
			}
			else
			{
				list = new NativeList<T>(newCapacity, AllocatorHandle.op_Implicit((Allocator)4));
			}
		}
		if (!copyContents)
		{
			list.Clear();
		}
	}

	public static void SafeDispose<T>(this ref NativeList<T> list) where T : unmanaged
	{
		if (list.IsCreated)
		{
			list.Dispose();
		}
	}

	public static void CopyFrom<T>(this ref NativeList<T> list, in ReadOnly<T> from) where T : unmanaged
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		list.Resize(from.Length, (NativeArrayOptions)0);
		from.CopyTo(list.AsArray());
	}
}


using System;
using System.Collections;
using System.Text;
using Facepunch;

public static class BitArrayEx
{
	public static bool TryFind(this BitArray array, out int i, int max = int.MaxValue, bool value = false, int start = 0)
	{
		int num = Math.Min(array.Length, max);
		for (i = start; i < num; i++)
		{
			if (array.Get(i) == value)
			{
				return true;
			}
		}
		return false;
	}

	public static string ToStringEx(this BitArray array)
	{
		StringBuilder stringBuilder = Pool.Get<StringBuilder>();
		stringBuilder.EnsureCapacity(array.Length);
		for (int i = 0; i < array.Length; i++)
		{
			stringBuilder.Append(array.Get(i) ? '|' : '_');
		}
		string result = stringBuilder.ToString();
		Pool.FreeUnmanaged(ref stringBuilder);
		return result;
	}
}


using System.Collections.Generic;
using Instancing;

public class BuildingBlockConfig
{
	public uint PrefabId;

	public List<BuildingBlockSkin> Skins = new List<BuildingBlockSkin>();
}


using UnityEngine;

public class BuildingBlockSkin
{
	public uint SkinPrefabId;

	public int Grade;

	public ulong Skin;

	public Matrix4x4 LocalToWorld;
}


using System.Collections.Generic;
using Instancing;

public class BuildingSkinConfig
{
	public uint PrefabId;

	public List<ConditionalModelConfig> Conditionals = new List<ConditionalModelConfig>();
}


using UnityEngine;

public class ConditionalModelConfig
{
	public ulong ModelStateMask;

	public uint TargetPrefabId;

	public Matrix4x4 LocalToWorld;
}


public class InstancedEntityConfig
{
	public uint PrefabId;

	public bool HideInsideNetworkRange;
}


using System;
using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

[Serializable]
public class InstancedLODState
{
	public Mesh Mesh;

	public Material[] Materials;

	public Matrix4x4 LocalToWorld;

	public ShadowCastingMode CastShadows;

	public bool RecieveShadows;

	public LightProbeUsage LightProbes;

	public int LodLevel;

	public int TotalLodLevels;

	public InstancedMeshCategory MeshCategory;

	public float MinimumDistance;

	public float MaximumDistance;

	public InstancedLODState(Matrix4x4 localToWorld, MeshRenderer renderer, float minDistance, float maxDistance, int lodLevel, int lodLevels, InstancedMeshCategory category)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		MeshCull component = ((Component)renderer).GetComponent<MeshCull>();
		MeshFilter component2 = ((Component)renderer).GetComponent<MeshFilter>();
		Mesh = component2.sharedMesh;
		Materials = ((Renderer)renderer).sharedMaterials;
		LocalToWorld = localToWorld;
		CastShadows = ((Renderer)renderer).shadowCastingMode;
		RecieveShadows = ((Renderer)renderer).receiveShadows;
		LightProbes = ((Renderer)renderer).lightProbeUsage;
		MinimumDistance = minDistance;
		MaximumDistance = component?.Distance ?? maxDistance;
		MeshCategory = category;
		LodLevel = lodLevel;
		TotalLodLevels = lodLevels;
	}
}


public enum InstancedMeshCategory
{
	BuildingBlock,
	Cliff,
	Other
}


using System;
using System.Collections.Generic;
using Instancing;

[Serializable]
public class InstancedPrefabConfig
{
	public uint PrefabId;

	public List<InstancedMeshConfig> Meshes = new List<InstancedMeshConfig>();

	public InstancedPrefabConfig(uint prefabId)
	{
		PrefabId = prefabId;
	}
}


using System;
using System.Collections.Generic;
using Instancing;

[Serializable]
public class InstancedMeshConfig
{
	public List<InstancedLODState> states;
}


using System;
using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

public struct MeshRenderKey : IEquatable<MeshRenderKey>
{
	public Mesh Mesh;

	public Material[] Materials;

	public ShadowCastingMode CastShadows;

	public bool RecieveShadows;

	public LightProbeUsage LightProbeUsages;

	public MeshRenderKey(Mesh mesh, Material[] materials, ShadowCastingMode castShadows, bool recieveShadows, LightProbeUsage lightProbes)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Mesh = mesh;
		Materials = materials;
		CastShadows = castShadows;
		RecieveShadows = recieveShadows;
		LightProbeUsages = lightProbes;
	}

	public bool Equals(MeshRenderKey other)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Mesh != (Object)(object)other.Mesh || CastShadows != other.CastShadows || RecieveShadows != other.RecieveShadows || LightProbeUsages != other.LightProbeUsages)
		{
			return false;
		}
		if (Materials == null || other.Materials == null)
		{
			return Materials == other.Materials;
		}
		for (int i = 0; i < Materials.Length; i++)
		{
			if ((Object)(object)Materials[i] != (Object)(object)other.Materials[i])
			{
				return false;
			}
		}
		return true;
	}

	public override bool Equals(object obj)
	{
		if (obj is MeshRenderKey other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (17 * 31 + ((object)Mesh)?.GetHashCode()).GetValueOrDefault();
	}
}


using System;
using Instancing;

public struct PrefabRenderKey : IEquatable<PrefabRenderKey>
{
	public uint PrefabId;

	public int Grade;

	public ulong Skin;

	public PrefabRenderKey(uint prefabId, int grade, ulong skin)
	{
		PrefabId = prefabId;
		Grade = grade;
		Skin = skin;
	}

	public bool Equals(PrefabRenderKey other)
	{
		if (PrefabId == other.PrefabId && Grade == other.Grade)
		{
			return Skin == other.Skin;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is PrefabRenderKey other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (int)(((PrefabId * 397) ^ (uint)Grade) * 397) ^ Skin.GetHashCode();
	}
}


public struct GridAllocation
{
	public int StartIndex;

	public int Capacity;
}


using Unity.Mathematics;

public struct GridJobData
{
	public int GridId;

	public int StartIndex;

	public int Count;

	public int Capacity;

	public float3 MinBounds;

	public float3 MaxBounds;

	public bool CanBeFrustumCulled;

	public bool CanBeDistanceCulled;
}


using System;
using System.Runtime.InteropServices;
using Instancing;
using Unity.Mathematics;

[StructLayout(LayoutKind.Explicit)]
public struct InstancedCullData
{
	[Flags]
	public enum BitFlags : uint
	{
		Visible = 1u,
		HasShadow = 2u,
		HasMesh = 4u,
		LastLOD = 8u
	}

	[FieldOffset(0)]
	public float3 CullPosition;

	[FieldOffset(12)]
	public float3 BoundsMin;

	[FieldOffset(24)]
	public float3 BoundsMax;

	[FieldOffset(36)]
	public float MinDistance;

	[FieldOffset(40)]
	public float MaxDistance;

	[FieldOffset(44)]
	public int RendererId;

	[FieldOffset(48)]
	public int SliceIndex;

	[FieldOffset(52)]
	public BitFlags Flags;

	[FieldOffset(56)]
	public long VirtualMeshId;

	public bool IsVisible
	{
		get
		{
			return (Flags & BitFlags.Visible) == BitFlags.Visible;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.Visible;
			}
			else
			{
				Flags &= ~BitFlags.Visible;
			}
		}
	}

	public bool HasShadow
	{
		get
		{
			return (Flags & BitFlags.HasShadow) == BitFlags.HasShadow;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.HasShadow;
			}
			else
			{
				Flags &= ~BitFlags.HasShadow;
			}
		}
	}

	public bool HasMesh
	{
		get
		{
			return (Flags & BitFlags.HasMesh) == BitFlags.HasMesh;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.HasMesh;
			}
			else
			{
				Flags &= ~BitFlags.HasMesh;
			}
		}
	}

	public bool LastLOD
	{
		get
		{
			return (Flags & BitFlags.LastLOD) == BitFlags.LastLOD;
		}
		set
		{
			if (value)
			{
				Flags |= BitFlags.LastLOD;
			}
			else
			{
				Flags &= ~BitFlags.LastLOD;
			}
		}
	}
}


using System;

[Flags]
public enum BitFlags : uint
{
	Visible = 1u,
	HasShadow = 2u,
	HasMesh = 4u,
	LastLOD = 8u
}


using UnityEngine.Rendering;

public struct InstancedRendererJobData
{
	public int Id;

	public int DrawCallCount;

	public float MinDistance;

	public float MaxDistance;

	public ShadowCastingMode ShadowMode;

	public bool HasMesh => (int)ShadowMode != 3;

	public bool HasShadow => (int)ShadowMode > 0;
}


using System;
using Instancing;
using Unity.Mathematics;

public struct MeshOverrideData : IEquatable<MeshOverrideData>
{
	public float4 Color;

	public bool Equals(MeshOverrideData other)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (Color.x == other.Color.x && Color.y == other.Color.y && Color.z == other.Color.z)
		{
			return Color.w == other.Color.w;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is MeshOverrideData other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((object)(float4)(ref Color)/*cast due to .constrained prefix*/).GetHashCode();
	}

	public static bool operator ==(MeshOverrideData left, MeshOverrideData right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(MeshOverrideData left, MeshOverrideData right)
	{
		return !left.Equals(right);
	}
}


using Instancing;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct PreCullingJob : IJob
{
	[ReadOnly]
	public NativeArray<InstancedRendererJobData> Meshes;

	[ReadOnly]
	public int RendererCount;

	[ReadOnly]
	public NativeArray<uint> CountPerMesh;

	[ReadOnly]
	public NativeArray<DrawCallJobData> DrawCalls;

	[ReadOnly]
	public int DrawCallCount;

	[WriteOnly]
	public NativeArray<RenderSlice> RenderSlices;

	public void Execute()
	{
		CalculateRenderSlices();
	}

	private void CalculateRenderSlices()
	{
		uint num = 0u;
		for (int i = 0; i < RendererCount; i++)
		{
			uint num2 = CountPerMesh[i];
			uint num3 = num2;
			if (num3 != 0)
			{
				RenderSlices[i] = new RenderSlice
				{
					StartIndex = num,
					Length = num2
				};
				num += num3;
			}
			else
			{
				RenderSlices[i] = default(RenderSlice);
			}
		}
	}
}


using Instancing;
using UnityEngine;

public static class ComputeBufferEx
{
	public static void SetBuffer<T>(this ComputeShader shader, int kernel, int name, GPUBuffer<T> buffer) where T : unmanaged
	{
		shader.SetBuffer(kernel, name, buffer.Buffer);
	}
}


public class GPUBuffer
{
	public enum Target
	{
		Structured,
		IndirectArgs,
		Vertex,
		Index,
		Raw
	}
}


public enum Target
{
	Structured,
	IndirectArgs,
	Vertex,
	Index,
	Raw
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Instancing;
using Unity.Collections;
using UnityEngine;

public class GPUBuffer<T> : GPUBuffer, IDisposable where T : unmanaged
{
	private Target _type;

	public int BufferVersion { get; private set; }

	public GraphicsBuffer Buffer { get; private set; }

	public Target Type { get; private set; }

	public int count { get; private set; }

	public int stride { get; private set; }

	public int ByteLength => count * stride;

	public GPUBuffer(int length, Target target)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Expected O, but got Unknown
		count = length;
		stride = Marshal.SizeOf<T>();
		Type = target;
		switch (target)
		{
		case Target.Structured:
			_type = (Target)16;
			break;
		case Target.IndirectArgs:
			_type = (Target)256;
			break;
		case Target.Vertex:
			_type = (Target)1;
			break;
		case Target.Index:
			_type = (Target)2;
			break;
		case Target.Raw:
			_type = (Target)32;
			break;
		default:
			throw new NotImplementedException($"GPUBuffer Target '{target}'");
		}
		Buffer = new GraphicsBuffer(_type, length, stride);
		ClearData();
	}

	public void SetData(List<T> data)
	{
		Buffer.SetData<T>(data);
	}

	public void SetData(List<int> data, int nativeArrayIndex, int computeBufferIndex, int length)
	{
		Buffer.SetData<int>(data, nativeArrayIndex, computeBufferIndex, length);
	}

	public void SetData(T[] data)
	{
		Buffer.SetData((Array)data);
	}

	public void SetData(T[] data, int nativeArrayIndex, int computeBufferIndex, int length)
	{
		Buffer.SetData((Array)data, nativeArrayIndex, computeBufferIndex, length);
	}

	public void SetData(NativeArray<T> data)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Buffer.SetData<T>(data);
	}

	public void SetData(NativeArray<T> data, int nativeArrayIndex, int computeBufferIndex, int length)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Buffer.SetData<T>(data, nativeArrayIndex, computeBufferIndex, length);
	}

	public void ClearData()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<T> data = default(NativeArray<T>);
		data..ctor(count, (Allocator)2, (NativeArrayOptions)1);
		try
		{
			Buffer.SetData<T>(data);
		}
		finally
		{
			((IDisposable)data/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void Expand(int newCapacity, bool preserveData = false)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		GraphicsBuffer val = new GraphicsBuffer(_type, newCapacity, stride);
		BufferVersion++;
		if (preserveData)
		{
			T[] array = new T[newCapacity];
			Buffer.GetData((Array)array, 0, 0, count);
			val.SetData((Array)array);
		}
		Dispose();
		Buffer = val;
		count = newCapacity;
		if (!preserveData)
		{
			ClearData();
		}
	}

	public void EnsureCapacity(int size, bool preserveData = false, float expandRatio = 2f)
	{
		if (Buffer.count < size)
		{
			int newCapacity = (int)((float)size * expandRatio);
			Expand(newCapacity, preserveData);
		}
	}

	public void Dispose()
	{
		GraphicsBuffer buffer = Buffer;
		if (buffer != null)
		{
			buffer.Dispose();
		}
		Buffer = null;
	}
}


using System.Collections.Generic;
using System.Linq;
using Instancing;
using UnityEngine;

public static class InstancedPrefabConverter
{
	private static InstancedMeshCategory GetMeshCategory(string prefabPath)
	{
		if (prefabPath.StartsWith("assets/prefabs/building core"))
		{
			return InstancedMeshCategory.BuildingBlock;
		}
		if (prefabPath.StartsWith("assets/bundled/prefabs/autospawn/"))
		{
			return InstancedMeshCategory.Cliff;
		}
		return InstancedMeshCategory.Other;
	}

	public static InstancedPrefabConfig ExtractInstancedRenderers(GameObject prefab, uint prefabId, IEnumerable<InstancedMeshFilter> instancedFilters)
	{
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		InstancedPrefabConfig instancedPrefabConfig = new InstancedPrefabConfig(prefabId);
		string text = StringPool.Get(prefabId);
		(from x in instancedFilters
			select x.RendererLOD into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		(from x in instancedFilters
			select x.MeshRenderer into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		(from x in instancedFilters
			select x.MeshLOD into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		foreach (Transform allChild in prefab.transform.GetAllChildren())
		{
			if (((Object)allChild).name == "reflection" && !((Component)allChild).gameObject.activeSelf)
			{
				Debug.Log((object)("Reflection probe in " + text));
			}
		}
		InstancedMeshCategory meshCategory = GetMeshCategory(text);
		foreach (InstancedMeshFilter instancedFilter in instancedFilters)
		{
			InstancedMeshConfig instancedMeshConfig = new InstancedMeshConfig
			{
				states = new List<InstancedLODState>()
			};
			instancedPrefabConfig.Meshes.Add(instancedMeshConfig);
			instancedFilter.Config = instancedMeshConfig;
			float num = 2500f;
			InstancedLODState instancedLODState = null;
			if ((Object)(object)instancedFilter.MeshRenderer != (Object)null)
			{
				MeshRenderer meshRenderer = instancedFilter.MeshRenderer;
				if (!((Object)(object)meshRenderer == (Object)null))
				{
					instancedLODState = new InstancedLODState(((Component)meshRenderer).transform.localToWorldMatrix, meshRenderer, 0f, num, 0, 1, meshCategory);
					instancedMeshConfig.states.Add(instancedLODState);
				}
			}
			else if ((Object)(object)instancedFilter.MeshLOD != (Object)null)
			{
				MeshLOD.State[] array = instancedFilter.MeshLOD.States.OrderBy((MeshLOD.State x) => x.distance).ToArray();
				for (int i = 0; i < array.Length; i++)
				{
					MeshLOD.State state = array[i];
					MeshRenderer component = ((Component)instancedFilter.MeshLOD).GetComponent<MeshRenderer>();
					if (!((Object)(object)component == (Object)null))
					{
						Matrix4x4 localToWorldMatrix = ((Component)component).transform.localToWorldMatrix;
						MeshLOD.State? state2 = array.ElementAtOrDefault(i + 1);
						float minDistance = ((i == 0) ? 0f : state.distance);
						float maxDistance = state2?.distance ?? num;
						instancedLODState = new InstancedLODState(localToWorldMatrix, component, minDistance, maxDistance, i, array.Length, meshCategory);
						instancedMeshConfig.states.Add(instancedLODState);
					}
				}
			}
			else
			{
				if (!((Object)(object)instancedFilter.RendererLOD != (Object)null))
				{
					continue;
				}
				RendererLOD.State[] array2 = instancedFilter.RendererLOD.States.OrderBy((RendererLOD.State x) => x.distance).ToArray();
				for (int j = 0; j < array2.Length; j++)
				{
					RendererLOD.State state3 = array2[j];
					Renderer renderer = state3.renderer;
					MeshRenderer val = (MeshRenderer)(object)((renderer is MeshRenderer) ? renderer : null);
					if (!((Object)(object)val == (Object)null))
					{
						Matrix4x4 localToWorldMatrix2 = ((Component)val).transform.localToWorldMatrix;
						RendererLOD.State? state4 = array2.ElementAtOrDefault(j + 1);
						float minDistance2 = ((j == 0) ? 0f : state3.distance);
						float maxDistance2 = state4?.distance ?? num;
						instancedLODState = new InstancedLODState(localToWorldMatrix2, val, minDistance2, maxDistance2, j, array2.Length, meshCategory);
						instancedMeshConfig.states.Add(instancedLODState);
					}
				}
			}
		}
		return instancedPrefabConfig;
	}
}


public static class InstancedPrefabPreProcess
{
}


using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

internal static class InstancingUtil
{
	public static readonly int PositionBufferProperty = Shader.PropertyToID("_PositionBuffer");

	public static readonly int RenderBufferProperty = Shader.PropertyToID("_PostCullBuffer");

	public static readonly int IndirectExtraArgProperty = Shader.PropertyToID("_IndirectExtraArgsBuffer");

	public static readonly int Param_MeshOverrideBuffer = Shader.PropertyToID("_MeshOverrideBuffer");

	public static readonly int Param_RenderSliceIndexes = Shader.PropertyToID("_RenderSliceIndexes");

	public static readonly int DrawCallIndexProperty = Shader.PropertyToID("_DrawCallIndex");

	public static readonly int Param_RendererIndex = Shader.PropertyToID("_RendererIndex");

	public static readonly int Param_Verticies = Shader.PropertyToID("_Verticies");

	public static readonly int Param_Triangles = Shader.PropertyToID("_Triangles");

	public static readonly GlobalKeyword Keyword_Rust_Procedural_Rendering = GlobalKeyword.Create("RUST_PROCEDURAL_INSTANCING");

	public const int CullingGPUThreads = 1024;

	public static float MB(int bytes)
	{
		return (float)Math.Round((float)(bytes / 100000) / 10f, 1);
	}

	public static StringBuilder MemoryUsage(this StringBuilder builder, string name, ComputeBuffer buffer)
	{
		builder.AppendLine($"[ComputeBuffer] {name} {buffer.count} | {MB(buffer.count * buffer.stride)}MB");
		return builder;
	}

	public static StringBuilder MemoryUsage(this StringBuilder builder, string name, GraphicsBuffer buffer)
	{
		builder.AppendLine($"[ComputeBuffer] {name} {buffer.count} | {MB(buffer.count * buffer.stride)}MB");
		return builder;
	}

	public static StringBuilder MemoryUsage<T>(this StringBuilder builder, string name, NativeArray<T> array, int count = -1) where T : unmanaged
	{
		int num = Marshal.SizeOf<T>();
		builder.AppendLine(string.Format("[NativeArray] {0}{1} Capacity: {2} | {3}MB", name, (count >= 0) ? (" Count: " + count) : "", array.Length, MB(array.Length * num)));
		return builder;
	}

	public static StringBuilder MemoryUsage<T>(this StringBuilder builder, string name, ICollection<T> array)
	{
		Type type = (array.GetType().IsGenericType ? array.GetType() : array.GetType().GetGenericTypeDefinition());
		string arg = "Collection";
		if (type == typeof(Dictionary<, >))
		{
			arg = "Dictionary";
		}
		else if (type == typeof(List<>))
		{
			arg = "List";
		}
		else if (type == typeof(HashSet<>))
		{
			arg = "HashSet";
		}
		else if (type == typeof(Array))
		{
			arg = "Array";
		}
		int count = array.Count;
		builder.AppendLine($"[{arg}] {name} Size: {count}");
		return builder;
	}

	public static int GetIterationCount(int count, int threads)
	{
		return count / threads + ((count % threads != 0) ? 1 : 0);
	}
}


using System;
using Instancing;
using Unity.Collections;

public struct JobInt
{
	private NativeArray<int> Array;

	public int Value
	{
		get
		{
			if (!Array.IsCreated)
			{
				throw new InvalidOperationException("You must call 'JobInt.Create()' before using this in a job");
			}
			return Array[0];
		}
		set
		{
			if (!Array.IsCreated)
			{
				throw new InvalidOperationException("You must call 'JobInt.Create()' before using this in a job");
			}
			Array[0] = value;
		}
	}

	public static JobInt Create()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		JobInt result = default(JobInt);
		result.Array = new NativeArray<int>(1, (Allocator)4, (NativeArrayOptions)1);
		return result;
	}

	public static void Destroy(JobInt instance)
	{
		NativeArrayEx.SafeDispose(ref instance.Array);
	}
}


using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Instancing;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;

public class GeometryBuffers
{
	[StructLayout(LayoutKind.Explicit, Size = 96)]
	public struct VertexData
	{
		[FieldOffset(0)]
		public float4 Position;

		[FieldOffset(16)]
		public float4 UV01;

		[FieldOffset(32)]
		public float4 UV23;

		[FieldOffset(48)]
		public float4 Normal;

		[FieldOffset(64)]
		public float4 Tangent;

		[FieldOffset(80)]
		public float4 Color;
	}

	private int _meshCopyMode;

	public GPUBuffer<VertexData> VertexBuffer;

	public GPUBuffer<int> TriangleBuffer;

	private int VertexIndex;

	private int TriangleIndex;

	private Dictionary<Mesh, MultidrawMeshInfo[]> _meshes = new Dictionary<Mesh, MultidrawMeshInfo[]>();

	public bool IsDirty { get; set; }

	public void Initialize(int meshCopyMode)
	{
		_meshCopyMode = meshCopyMode;
		AllocateNativeMemory();
		ResetStreamPosition();
	}

	private void ResetStreamPosition()
	{
		TriangleIndex = 0;
		VertexIndex = 0;
	}

	public void Destroy()
	{
		FreeNativeMemory();
		_meshes.Clear();
	}

	private void AllocateNativeMemory()
	{
		VertexBuffer = new GPUBuffer<VertexData>(800000, GPUBuffer.Target.Structured);
		TriangleBuffer = new GPUBuffer<int>(3000000, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		VertexBuffer?.Dispose();
		VertexBuffer = null;
		TriangleBuffer?.Dispose();
		TriangleBuffer = null;
	}

	public MultidrawMeshInfo[] CopyMesh(Mesh mesh)
	{
		if (_meshes.TryGetValue(mesh, out var value))
		{
			return value;
		}
		value = CalculateSubmeshInfo(mesh);
		_meshes.Add(mesh, value);
		if (_meshCopyMode == 0)
		{
			CopyMeshViaCPU(mesh);
		}
		else
		{
			CopyMeshViaShader(mesh);
		}
		IsDirty = true;
		return value;
	}

	private void CopyMeshViaShader(Mesh mesh)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		mesh.vertexBufferTarget = (Target)(mesh.vertexBufferTarget | 0x20);
		mesh.indexBufferTarget = (Target)(mesh.indexBufferTarget | 0x20);
		int num = 0;
		GraphicsBuffer vertexBuffer = mesh.GetVertexBuffer(num);
		GraphicsBuffer indexBuffer = mesh.GetIndexBuffer();
		ComputeShader copyMeshShader = SingletonComponent<InstancedScheduler>.Instance.CopyMeshShader;
		int num2 = copyMeshShader.FindKernel("CopyMeshKernel");
		int vertexCount = mesh.vertexCount;
		int num3 = 0;
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			num3 += (int)mesh.GetIndexCount(i);
		}
		copyMeshShader.SetInt("_Offset_Vertex", mesh.GetVertexAttributeOffset((VertexAttribute)0));
		copyMeshShader.SetInt("_Offset_UV0", mesh.GetVertexAttributeOffset((VertexAttribute)4));
		copyMeshShader.SetInt("_Offset_UV1", mesh.GetVertexAttributeOffset((VertexAttribute)5));
		copyMeshShader.SetInt("_Offset_UV2", mesh.GetVertexAttributeOffset((VertexAttribute)6));
		copyMeshShader.SetInt("_Offset_UV3", mesh.GetVertexAttributeOffset((VertexAttribute)7));
		copyMeshShader.SetInt("_Offset_Normal", mesh.GetVertexAttributeOffset((VertexAttribute)1));
		copyMeshShader.SetInt("_Offset_Tangent", mesh.GetVertexAttributeOffset((VertexAttribute)2));
		copyMeshShader.SetInt("_Offset_Color", mesh.GetVertexAttributeOffset((VertexAttribute)3));
		copyMeshShader.SetBuffer(num2, "_Verts", mesh.GetVertexBuffer(num));
		copyMeshShader.SetBuffer(num2, "_Triangles", mesh.GetIndexBuffer());
		copyMeshShader.SetInt("_TriangleCount", num3);
		copyMeshShader.SetInt("_VertexCount", vertexCount);
		copyMeshShader.SetInt("_VertexStride", mesh.GetVertexBufferStride(0));
		copyMeshShader.SetInt("_TriangleStride", ((int)mesh.indexFormat == 0) ? 2 : 4);
		copyMeshShader.SetInt("_OutputVertexIndex", VertexIndex);
		copyMeshShader.SetInt("_OutputTriangleIndex", TriangleIndex);
		copyMeshShader.SetBuffer(num2, "_Output", VertexBuffer.Buffer);
		copyMeshShader.SetBuffer(num2, "_OutputTriangles", TriangleBuffer.Buffer);
		VertexIndex += vertexCount;
		TriangleIndex += num3;
		if (VertexBuffer.count < VertexIndex + 1 || TriangleBuffer.count < TriangleIndex + 1)
		{
			Debug.Log((object)"Resizing multidraw geometry buffer");
			VertexBuffer.EnsureCapacity(VertexIndex + 1, preserveData: true);
			TriangleBuffer.EnsureCapacity(TriangleIndex + 1, preserveData: true);
			IsDirty = true;
		}
		int iterationCount = InstancingUtil.GetIterationCount(Mathf.Max(num3, vertexCount), 1024);
		copyMeshShader.Dispatch(num2, iterationCount, 1, 1);
		vertexBuffer.Dispose();
		indexBuffer.Dispose();
	}

	public void Rebuild()
	{
		ResetStreamPosition();
		foreach (Mesh key in _meshes.Keys)
		{
			CopyMeshViaShader(key);
		}
	}

	private MultidrawMeshInfo[] CalculateSubmeshInfo(Mesh mesh)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		MultidrawMeshInfo[] array = new MultidrawMeshInfo[mesh.subMeshCount];
		for (int i = 0; i < mesh.subMeshCount; i++)
		{
			SubMeshDescriptor subMesh = mesh.GetSubMesh(i);
			MultidrawMeshInfo multidrawMeshInfo = default(MultidrawMeshInfo);
			multidrawMeshInfo.IndexStart = TriangleIndex + ((SubMeshDescriptor)(ref subMesh)).indexStart;
			multidrawMeshInfo.VertexStart = VertexIndex + ((SubMeshDescriptor)(ref subMesh)).baseVertex;
			multidrawMeshInfo.VertexCount = ((SubMeshDescriptor)(ref subMesh)).vertexCount;
			MultidrawMeshInfo multidrawMeshInfo2 = multidrawMeshInfo;
			array[i] = multidrawMeshInfo2;
		}
		return array;
	}

	private void CopyMeshViaCPU(Mesh mesh)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data data = MeshCache.Get(mesh);
		NativeArray<VertexData> data2 = default(NativeArray<VertexData>);
		data2..ctor(data.vertices.Length, (Allocator)2, (NativeArrayOptions)1);
		for (int i = 0; i < data2.Length; i++)
		{
			VertexData vertexData = default(VertexData);
			Vector3 val = data.vertices[i];
			Vector2 val2 = (mesh.HasVertexAttribute((VertexAttribute)4) ? data.uv[i] : Vector2.zero);
			Vector2 val3 = (mesh.HasVertexAttribute((VertexAttribute)5) ? data.uv2[i] : Vector2.zero);
			Vector2 val4 = (mesh.HasVertexAttribute((VertexAttribute)6) ? data.uv3[i] : Vector2.zero);
			Vector2 val5 = (mesh.HasVertexAttribute((VertexAttribute)7) ? data.uv4[i] : Vector2.zero);
			Vector3 val6 = (mesh.HasVertexAttribute((VertexAttribute)1) ? data.normals[i] : Vector3.zero);
			Vector4 val7 = (mesh.HasVertexAttribute((VertexAttribute)2) ? data.tangents[i] : Vector4.zero);
			Color32 val8 = (Color32)(mesh.HasVertexAttribute((VertexAttribute)3) ? data.colors32[i] : new Color32((byte)0, (byte)0, (byte)0, (byte)0));
			vertexData.Position = new float4(val.x, val.y, val.z, 1f);
			vertexData.UV01 = new float4(val2.x, val2.y, val3.x, val3.y);
			vertexData.UV23 = new float4(val4.x, val4.y, val5.x, val5.y);
			vertexData.Normal = new float4(val6.x, val6.y, val6.z, 1f);
			vertexData.Tangent = new float4(val7.x, val7.y, val7.z, val7.w);
			vertexData.Color = new float4((float)(int)val8.r / 255f, (float)(int)val8.g / 255f, (float)(int)val8.b / 255f, (float)(int)val8.a / 255f);
			data2[i] = vertexData;
		}
		VertexBuffer.EnsureCapacity(VertexIndex + data2.Length + 1);
		VertexBuffer.SetData(data2, 0, VertexIndex, data2.Length);
		VertexIndex += data2.Length;
		int[] triangles = data.triangles;
		TriangleBuffer.EnsureCapacity(TriangleIndex + triangles.Length + 1);
		TriangleBuffer.SetData(triangles, 0, TriangleIndex, triangles.Length);
		TriangleIndex += triangles.Length;
		data2.Dispose();
		IsDirty = true;
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		builder.AppendLine($"Vertex Buffer: {VertexIndex} / {VertexBuffer.count}");
		builder.AppendLine($"Triangle Buffer: {TriangleIndex} / {TriangleBuffer.count}");
		builder.AppendLine($"Meshes: {_meshes.Count}");
	}
}


using System.Runtime.InteropServices;
using Unity.Mathematics;

[StructLayout(LayoutKind.Explicit, Size = 96)]
public struct VertexData
{
	[FieldOffset(0)]
	public float4 Position;

	[FieldOffset(16)]
	public float4 UV01;

	[FieldOffset(32)]
	public float4 UV23;

	[FieldOffset(48)]
	public float4 Normal;

	[FieldOffset(64)]
	public float4 Tangent;

	[FieldOffset(80)]
	public float4 Color;
}


public struct MultidrawMeshInfo
{
	public int VertexStart;

	public int VertexCount;

	public int IndexStart;
}


using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

public class InstancedMeshRenderer
{
	public int RendererId { get; }

	public int DrawCallIndex { get; }

	public int DrawCallCount { get; }

	public string MeshName => ((Object)Mesh).name;

	public Mesh Mesh { get; }

	public Material[] Materials { get; private set; }

	public Material[] MultidrawMaterials { get; private set; }

	public ShadowCastingMode CastShadows { get; }

	public bool RecieveShadows { get; }

	public LightProbeUsage LightProbes { get; }

	public int Verticies { get; }

	public int Triangles { get; }

	public int VertexStart { get; private set; }

	public int IndexStart { get; private set; }

	public int LodLevel { get; }

	public int TotalLodLevels { get; }

	public bool IsLastLod { get; }

	public InstancedMeshCategory MeshCategory { get; }

	public MultidrawMeshInfo[] MultidrawSubmeshes { get; }

	public bool HasShadow => (int)CastShadows > 0;

	public bool HasMesh => (int)CastShadows != 3;

	public Vector3[] BoundsPoints { get; }

	public InstancedMeshRenderer(int rendererIndex, int drawCallIndex, MeshRenderKey key, Material[] multidrawMaterials, int lodLevel, int lodLevels, InstancedMeshCategory meshCategory, GeometryBuffers buffers)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		RendererId = rendererIndex;
		DrawCallIndex = drawCallIndex;
		Mesh = key.Mesh;
		Materials = key.Materials;
		MultidrawMaterials = multidrawMaterials;
		CastShadows = key.CastShadows;
		RecieveShadows = key.RecieveShadows;
		LightProbes = key.LightProbeUsages;
		Verticies = Mesh.vertexCount;
		LodLevel = lodLevel;
		TotalLodLevels = lodLevels;
		IsLastLod = lodLevel == lodLevels - 1;
		MeshCategory = meshCategory;
		DrawCallCount = Mathf.Min(Mesh.subMeshCount, Materials.Length);
		if (Materials.Length > Mesh.subMeshCount)
		{
			string name = ((Object)Mesh).name;
			Debug.LogError((object)("More submesh than material for mesh " + name));
		}
		if (Mesh.subMeshCount > Materials.Length)
		{
			string name2 = ((Object)Mesh).name;
			Debug.LogWarning((object)("More materials than submesh for mesh " + name2));
		}
		for (int i = 0; i < Mesh.subMeshCount; i++)
		{
			Triangles += (int)Mesh.GetIndexCount(i) / 3;
		}
		Bounds bounds = Mesh.bounds;
		BoundsPoints = (Vector3[])(object)new Vector3[8]
		{
			((Bounds)(ref bounds)).min,
			((Bounds)(ref bounds)).max,
			new Vector3(((Bounds)(ref bounds)).max.x, ((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).min.z),
			new Vector3(((Bounds)(ref bounds)).min.x, ((Bounds)(ref bounds)).max.y, ((Bounds)(ref bounds)).min.z),
			new Vector3(((Bounds)(ref bounds)).min.x, ((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.z),
			new Vector3(((Bounds)(ref bounds)).max.x, ((Bounds)(ref bounds)).max.y, ((Bounds)(ref bounds)).min.z),
			new Vector3(((Bounds)(ref bounds)).min.x, ((Bounds)(ref bounds)).max.y, ((Bounds)(ref bounds)).max.z),
			new Vector3(((Bounds)(ref bounds)).max.x, ((Bounds)(ref bounds)).min.y, ((Bounds)(ref bounds)).max.z)
		};
		MultidrawSubmeshes = buffers.CopyMesh(Mesh);
	}

	public void SetMaterials(Material[] materials)
	{
		Materials = materials;
	}

	public void SetPlaceholderMaterials(Material[] materials)
	{
		Materials = materials;
	}

	public int GetDrawCallIndex(int submesh)
	{
		return DrawCallIndex + submesh;
	}

	public int GetIndirectArgIndex(int submesh)
	{
		return GetDrawCallIndex(submesh) * 5;
	}

	public int GetIndirectArgByteIndex(int submesh)
	{
		return GetIndirectArgIndex(submesh) * 4;
	}
}


using UnityEngine;

public struct RenderUpdate
{
	public uint PrefabId;

	public NetworkableId NetworkId;

	public int Grade;

	public ulong Skin;

	public ulong ModelState;

	public Vector3 Position;

	public Quaternion Rotation;

	public Color CustomColor;

	public int CustomColorIndex;

	public bool IsGlobalUpdate;

	public bool InsideNetworkRange;
}


public struct CellId
{
	public int Index;

	public CellId(int index)
	{
		Index = index;
	}

	public override string ToString()
	{
		return Index.ToString();
	}
}


public struct CellHeader
{
	public int StartIndex;

	public int Count;

	public int PartitionKey;
}


using Instancing;
using Unity.Mathematics;

public struct InstancedMeshData
{
	public InstancedCullData CullData;

	public float4x4 LocalToWorld;
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Instancing;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

public class CellMeshAllocator
{
	private class CellPartition : IPooled
	{
		public List<CellId> PackedCells;

		public List<CellId> CellsWithSpace;

		public bool IsEmpty()
		{
			if (PackedCells.IsNullOrEmpty())
			{
				return CellsWithSpace.IsNullOrEmpty();
			}
			return false;
		}

		public void AddPackedCell(CellId cell)
		{
			if (PackedCells == null)
			{
				PackedCells = Pool.Get<List<CellId>>();
			}
			PackedCells.Add(cell);
		}

		public void RemovePackedCell(CellId cell)
		{
			if (PackedCells != null)
			{
				PackedCells.Remove(cell);
				if (PackedCells.Count == 0)
				{
					Pool.FreeUnmanaged<CellId>(ref PackedCells);
				}
			}
		}

		public void AddCellWithSpace(CellId cell)
		{
			if (CellsWithSpace == null)
			{
				CellsWithSpace = Pool.Get<List<CellId>>();
			}
			CellsWithSpace.Add(cell);
		}

		public void RemoveCellWithSpace(CellId cell)
		{
			if (CellsWithSpace != null)
			{
				CellsWithSpace.Remove(cell);
				if (CellsWithSpace.Count == 0)
				{
					Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
				}
			}
		}

		public void EnterPool()
		{
			if (PackedCells != null)
			{
				Pool.FreeUnmanaged<CellId>(ref PackedCells);
			}
			if (CellsWithSpace != null)
			{
				Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
			}
		}

		public void LeavePool()
		{
		}
	}

	public const int CellCapacity = 32;

	private const int initialCellCount = 8192;

	public const int InitialCapacity = 262144;

	private Dictionary<int, CellPartition> partitions = new Dictionary<int, CellPartition>();

	private List<CellId> recycledCells = new List<CellId>();

	private Dictionary<long, int> meshLookup = new Dictionary<long, int>();

	public Dictionary<long, int> sliceIndexLookup = new Dictionary<long, int>();

	private Dictionary<int, List<long>> sliceLists = new Dictionary<int, List<long>>();

	public NativeArray<CellHeader> Cells;

	public NativeArray<InstancedCullData> CullData;

	public NativeArray<float4x4> PositionData;

	public NativeArray<MeshOverrideData> OverrideArray;

	public GPUBuffer<float4x4> PositionBuffer;

	public GPUBuffer<InstancedCullData> CullingDataBuffer;

	public GPUBuffer<MeshOverrideData> OverrideBuffer;

	private bool dirty;

	public int CellCount { get; private set; }

	public void Initialize()
	{
		AllocateNativeMemory();
		meshLookup = new Dictionary<long, int>();
		sliceIndexLookup = new Dictionary<long, int>();
		sliceLists = new Dictionary<int, List<long>>();
		partitions = new Dictionary<int, CellPartition>();
		recycledCells = new List<CellId>();
		CellCount = 0;
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
		dirty = false;
	}

	private void AllocateNativeMemory()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Cells = new NativeArray<CellHeader>(8192, (Allocator)4, (NativeArrayOptions)1);
		int num = Cells.Length * 32;
		CullData = new NativeArray<InstancedCullData>(num, (Allocator)4, (NativeArrayOptions)1);
		PositionData = new NativeArray<float4x4>(num, (Allocator)4, (NativeArrayOptions)1);
		OverrideArray = new NativeArray<MeshOverrideData>(num, (Allocator)4, (NativeArrayOptions)1);
		PositionBuffer = new GPUBuffer<float4x4>(num, GPUBuffer.Target.Structured);
		CullingDataBuffer = new GPUBuffer<InstancedCullData>(num, GPUBuffer.Target.Structured);
		OverrideBuffer = new GPUBuffer<MeshOverrideData>(num, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref Cells);
		NativeArrayEx.SafeDispose(ref CullData);
		PositionData.SafeDispose<float4x4>();
		PositionBuffer?.Dispose();
		PositionBuffer = null;
		CullingDataBuffer?.Dispose();
		CullingDataBuffer = null;
	}

	public CellId AddMesh(InstancedCullData data, int partitionKey, float4x4 localToWorld)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		if (!partitions.TryGetValue(partitionKey, out var value))
		{
			value = Pool.Get<CellPartition>();
			partitions[partitionKey] = value;
		}
		if (value.CellsWithSpace.IsNullOrEmpty())
		{
			value.AddCellWithSpace(CreateCell(partitionKey));
		}
		CellId cellId = value.CellsWithSpace[value.CellsWithSpace.Count - 1];
		CellHeader cellHeader = Cells[cellId.Index];
		int num = cellHeader.StartIndex + cellHeader.Count;
		cellHeader.Count++;
		int count = cellHeader.Count;
		Cells[cellId.Index] = cellHeader;
		if (!sliceLists.TryGetValue(data.RendererId, out var value2))
		{
			value2 = new List<long>();
			sliceLists[data.RendererId] = value2;
		}
		data.SliceIndex = value2.Count;
		value2.Add(data.VirtualMeshId);
		CullData[num] = data;
		PositionData[num] = localToWorld;
		OverrideArray[num] = default(MeshOverrideData);
		if (Render.computebuffer_setdata_immediate)
		{
			CullingDataBuffer.SetData(CullData, num, num, 1);
			PositionBuffer.SetData(PositionData, num, num, 1);
			OverrideBuffer.SetData(OverrideArray, num, num, 1);
		}
		else
		{
			dirty = true;
		}
		meshLookup.Add(data.VirtualMeshId, num);
		if (count == 32)
		{
			value.RemoveCellWithSpace(cellId);
			value.AddPackedCell(cellId);
		}
		else if (count > 32)
		{
			Debug.LogError((object)$"AddMesh() fucked up: >{32} elements in cell {cellId}");
		}
		return cellId;
	}

	public bool TryRemoveMesh(long virtualMeshId, out InstancedCullData removedData)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			removedData = default(InstancedCullData);
			return false;
		}
		removedData = CullData[value];
		CellId cellId = GetCellId(value);
		CellHeader cellHeader = Cells[cellId.Index];
		int num = cellHeader.StartIndex + cellHeader.Count - 1;
		int count = cellHeader.Count;
		int partitionKey = cellHeader.PartitionKey;
		int num2 = --cellHeader.Count;
		Cells[cellId.Index] = cellHeader;
		if (value != num)
		{
			InstancedCullData instancedCullData = CullData[num];
			CullData[value] = instancedCullData;
			PositionData[value] = PositionData[num];
			OverrideArray[value] = OverrideArray[num];
			meshLookup[instancedCullData.VirtualMeshId] = value;
			if (Render.computebuffer_setdata_immediate)
			{
				CullingDataBuffer.SetData(CullData, value, value, 1);
				PositionBuffer.SetData(PositionData, value, value, 1);
				OverrideBuffer.SetData(OverrideArray, value, value, 1);
			}
			else
			{
				dirty = true;
			}
		}
		CullData[num] = default(InstancedCullData);
		if (Render.computebuffer_setdata_immediate)
		{
			CullingDataBuffer.SetData(CullData, num, num, 1);
		}
		else
		{
			dirty = true;
		}
		List<long> list = sliceLists[removedData.RendererId];
		long num3 = list[list.Count - 1];
		if (removedData.VirtualMeshId != num3)
		{
			int num4 = meshLookup[num3];
			InstancedCullData instancedCullData2 = CullData[num4];
			instancedCullData2.SliceIndex = removedData.SliceIndex;
			CullData[num4] = instancedCullData2;
			if (Render.computebuffer_setdata_immediate)
			{
				CullingDataBuffer.SetData(CullData, num4, num4, 1);
			}
			else
			{
				dirty = true;
			}
			list[removedData.SliceIndex] = num3;
		}
		list.RemoveAt(list.Count - 1);
		CellPartition cellPartition = partitions[partitionKey];
		if (count == 32)
		{
			cellPartition.RemovePackedCell(cellId);
			cellPartition.AddCellWithSpace(cellId);
		}
		else if (num2 == 0)
		{
			cellPartition.RemoveCellWithSpace(cellId);
			if (cellPartition.IsEmpty())
			{
				partitions.Remove(partitionKey);
				Pool.Free<CellPartition>(ref cellPartition);
			}
			RecycleCell(cellId);
		}
		meshLookup.Remove(virtualMeshId);
		return true;
	}

	public InstancedMeshData? TryGetMeshData(long virtualMeshId)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			return null;
		}
		InstancedMeshData value2 = default(InstancedMeshData);
		value2.CullData = CullData[value];
		value2.LocalToWorld = PositionData[value];
		return value2;
	}

	public void SetMeshVisible(long virtualMeshId, bool visible)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			Debug.LogError((object)$"Trying to remove mesh {virtualMeshId} that doesn't exist");
			return;
		}
		InstancedCullData instancedCullData = CullData[value];
		if (instancedCullData.IsVisible != visible)
		{
			instancedCullData.IsVisible = visible;
			CullData[value] = instancedCullData;
			if (Render.computebuffer_setdata_immediate)
			{
				CullingDataBuffer.SetData(CullData, value, value, 1);
			}
			else
			{
				dirty = true;
			}
		}
	}

	public void SetOverride(long virtualMeshId, MeshOverrideData newData)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (!meshLookup.TryGetValue(virtualMeshId, out var value))
		{
			Debug.LogError((object)$"Trying to set override of mesh {virtualMeshId} that doesn't exist");
		}
		else if (OverrideArray[value] != newData)
		{
			OverrideArray[value] = newData;
			if (Render.computebuffer_setdata_immediate)
			{
				OverrideBuffer.SetData(OverrideArray, value, value, 1);
			}
			else
			{
				dirty = true;
			}
		}
	}

	private CellId CreateCell(int sortingKey)
	{
		CellId result;
		if (recycledCells.Count > 0)
		{
			result = recycledCells[recycledCells.Count - 1];
			recycledCells.RemoveAt(recycledCells.Count - 1);
		}
		else
		{
			result = new CellId(CellCount);
			CellCount++;
		}
		if (Cells.Length <= CellCount)
		{
			ExpandData();
		}
		Cells[result.Index] = new CellHeader
		{
			Count = 0,
			PartitionKey = sortingKey,
			StartIndex = result.Index * 32
		};
		return result;
	}

	public void ExpandData()
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		NativeArrayEx.Expand(ref Cells, Cells.Length * 2, (NativeArrayOptions)1);
		int newCapacity = Cells.Length * 32;
		NativeArrayEx.Expand(ref CullData, newCapacity, (NativeArrayOptions)1);
		PositionData.Expand<float4x4>(newCapacity, (NativeArrayOptions)1, copyContents: true, usePowerOfTwo: false);
		NativeArrayEx.Expand(ref OverrideArray, newCapacity, (NativeArrayOptions)1);
		CullingDataBuffer.Expand(newCapacity);
		CullingDataBuffer.SetData(CullData);
		PositionBuffer.Expand(newCapacity);
		PositionBuffer.SetData(PositionData);
		OverrideBuffer.Expand(newCapacity);
		OverrideBuffer.SetData(OverrideArray);
	}

	private void RecycleCell(CellId cellId)
	{
		recycledCells.Add(cellId);
	}

	private CellId GetCellId(int index)
	{
		return new CellId(index / 32);
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		int num = ((IEnumerable<CellHeader>)(object)Cells).Take(CellCount).Sum((CellHeader x) => 32 - x.Count);
		int num2 = CellCount * 32;
		builder.AppendLine("### CellAllocator ###");
		builder.AppendLine($"Cells: {CellCount}");
		builder.AppendLine($"Empty Space In Cells: {num} / {num2} ({Math.Round((double)num / (double)num2, 1)}%)");
		builder.MemoryUsage<CellHeader>("Cell Headers", Cells);
		builder.MemoryUsage<InstancedCullData>("Data Array", CullData);
		builder.MemoryUsage("MeshLookup", (ICollection<KeyValuePair<long, int>>)meshLookup);
		builder.MemoryUsage("Recycled Cells", (ICollection<CellId>)recycledCells);
		builder.MemoryUsage("Partitions", (ICollection<KeyValuePair<int, CellPartition>>)partitions);
		builder.AppendLine("# Allocation Summary #");
		var array = (from x in ((IEnumerable<CellHeader>)(object)Cells).Take(CellCount)
			group x by x.Count into x
			select new
			{
				amountInCell = x.Key,
				count = x.Count()
			} into x
			orderby x.amountInCell
			select x).ToArray();
		foreach (var anon in array)
		{
			builder.AppendLine($"{anon.amountInCell}/{32} Cells: {anon.count}");
		}
	}

	public void FlushComputeBuffers()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (dirty)
		{
			dirty = false;
			CullingDataBuffer.SetData(CullData);
			PositionBuffer.SetData(PositionData);
			OverrideBuffer.SetData(OverrideArray);
		}
	}
}


using System.Collections.Generic;
using Facepunch;

private class CellPartition : IPooled
{
	public List<CellId> PackedCells;

	public List<CellId> CellsWithSpace;

	public bool IsEmpty()
	{
		if (PackedCells.IsNullOrEmpty())
		{
			return CellsWithSpace.IsNullOrEmpty();
		}
		return false;
	}

	public void AddPackedCell(CellId cell)
	{
		if (PackedCells == null)
		{
			PackedCells = Pool.Get<List<CellId>>();
		}
		PackedCells.Add(cell);
	}

	public void RemovePackedCell(CellId cell)
	{
		if (PackedCells != null)
		{
			PackedCells.Remove(cell);
			if (PackedCells.Count == 0)
			{
				Pool.FreeUnmanaged<CellId>(ref PackedCells);
			}
		}
	}

	public void AddCellWithSpace(CellId cell)
	{
		if (CellsWithSpace == null)
		{
			CellsWithSpace = Pool.Get<List<CellId>>();
		}
		CellsWithSpace.Add(cell);
	}

	public void RemoveCellWithSpace(CellId cell)
	{
		if (CellsWithSpace != null)
		{
			CellsWithSpace.Remove(cell);
			if (CellsWithSpace.Count == 0)
			{
				Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
			}
		}
	}

	public void EnterPool()
	{
		if (PackedCells != null)
		{
			Pool.FreeUnmanaged<CellId>(ref PackedCells);
		}
		if (CellsWithSpace != null)
		{
			Pool.FreeUnmanaged<CellId>(ref CellsWithSpace);
		}
	}

	public void LeavePool()
	{
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct RenderSlice
{
	[FieldOffset(0)]
	public uint StartIndex;

	[FieldOffset(4)]
	public uint Length;
}


using System.Text;
using Instancing;
using Unity.Collections;
using UnityEngine;

public class CullingManager
{
	public NativeArray<RenderSlice> RenderSlicesArray;

	public GPUBuffer<RenderSlice> RenderSlicesBuffer;

	public void Initialize()
	{
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		int num = 512;
		RenderSlicesArray = new NativeArray<RenderSlice>(num, (Allocator)4, (NativeArrayOptions)1);
		RenderSlicesBuffer = new GPUBuffer<RenderSlice>(num, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref RenderSlicesArray);
		RenderSlicesBuffer?.Dispose();
		RenderSlicesBuffer = null;
	}

	public void EnsureCapacity(int rendererCount)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (RenderSlicesArray.Length < rendererCount + 1)
		{
			int newCapacity = Mathf.ClosestPowerOfTwo(rendererCount) * 2;
			NativeArrayEx.Expand(ref RenderSlicesArray, newCapacity, (NativeArrayOptions)1);
			RenderSlicesBuffer.Expand(newCapacity);
			RenderSlicesBuffer.SetData(RenderSlicesArray);
		}
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### CullingManager ###");
		builder.MemoryUsage<RenderSlice>("PostCullInstanceCounts", RenderSlicesArray);
	}

	public void UpdateComputeBuffers()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		RenderSlicesBuffer.SetData(RenderSlicesArray);
	}
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct DrawCallJobData
{
	[FieldOffset(0)]
	public int DrawCallIndex;

	[FieldOffset(4)]
	public int RendererIndex;

	[FieldOffset(8)]
	public uint IndexCount;

	[FieldOffset(12)]
	public uint IndexStart;

	[FieldOffset(16)]
	public uint VertexStart;

	[FieldOffset(20)]
	public uint MultidrawIndexStart;

	[FieldOffset(24)]
	public uint MultidrawVertexStart;

	[FieldOffset(28)]
	public int Padding1;
}


using System;
using Instancing;
using UnityEngine;
using UnityEngine.Rendering;

public struct DrawCallKey : IEquatable<DrawCallKey>, IComparable<DrawCallKey>, IComparable
{
	public Material Material;

	public ShadowCastingMode ShadowMode;

	public bool ReceiveShadows;

	public LightProbeUsage LightProbes;

	public DrawCallKey(Material material, ShadowCastingMode shadowMode, bool receiveShadows, LightProbeUsage lightProbes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Material = material;
		ShadowMode = shadowMode;
		ReceiveShadows = receiveShadows;
		LightProbes = lightProbes;
	}

	public int CompareTo(DrawCallKey other)
	{
		return GetHashCode().CompareTo(other.GetHashCode());
	}

	public int CompareTo(object obj)
	{
		if (obj == null)
		{
			return 1;
		}
		if (obj is DrawCallKey other)
		{
			return CompareTo(other);
		}
		throw new ArgumentException("Object must be 'DrawCallKey'");
	}

	public bool Equals(DrawCallKey other)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Material == (Object)(object)other.Material && ShadowMode == other.ShadowMode && ReceiveShadows == other.ReceiveShadows)
		{
			return LightProbes == other.LightProbes;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is DrawCallKey other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return HashCode.Combine<int, ShadowCastingMode, bool, LightProbeUsage>(((object)Material)?.GetHashCode() ?? 0, ShadowMode, ReceiveShadows, LightProbes);
	}

	public static bool operator ==(DrawCallKey a, DrawCallKey b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(DrawCallKey a, DrawCallKey b)
	{
		return !(a == b);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Instancing;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class DrawCallManager
{
	private class DrawCall
	{
		public int DrawCallIndex;

		public int RendererId;

		public Mesh Mesh;

		public int SubmeshIndex;

		public Material Material;

		public Material MultidrawMaterial;

		public ShadowCastingMode ShadowMode;

		public bool ReceiveShadows;

		public LightProbeUsage LightProbes;

		public InstancedMeshCategory MeshCategory;

		public int MultiDrawExtraCount;

		private DrawCallKey _key;

		public DrawCallJobData JobData;

		public MaterialPropertyBlock MaterialBlock = new MaterialPropertyBlock();

		public DrawCallKey CalculateKey()
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			if (_key == default(DrawCallKey))
			{
				_key = new DrawCallKey(Material, ShadowMode, ReceiveShadows, LightProbes);
			}
			return _key;
		}
	}

	private readonly CellMeshAllocator cellAllocator;

	private readonly GeometryBuffers GeometryBuffers;

	public NativeArray<DrawCallJobData> DrawCallArray;

	public GPUBuffer<DrawCallJobData> DrawCallBuffer;

	public GPUBuffer<uint> IndirectArgsBuffer;

	public GPUBuffer<uint> IndirectExtraArgBuffer;

	public GPUBuffer<uint> RenderBuffer;

	private int _overrideBufferVersion;

	private int _positionBufferVersion;

	private List<DrawCall> DrawCalls = new List<DrawCall>();

	private bool _needsDrawCallRebuild;

	private int IndirectArgCapacity;

	private const int renderLayer = 2097152;

	private const int initialCapacity = 1024;

	private Bounds cullingBounds = new Bounds(Vector3.zero, Vector3.one * 30000f);

	public int DrawCallsLastFrame { get; private set; }

	public int DrawCallCount => DrawCalls.Count;

	public DrawCallManager(CellMeshAllocator cellAllocator, GeometryBuffers geometryBuffers)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		this.cellAllocator = cellAllocator;
		GeometryBuffers = geometryBuffers;
	}

	public void Initialize()
	{
		DrawCalls = new List<DrawCall>();
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		IndirectArgCapacity = 1024;
		DrawCallArray = new NativeArray<DrawCallJobData>(IndirectArgCapacity, (Allocator)4, (NativeArrayOptions)1);
		DrawCallBuffer = new GPUBuffer<DrawCallJobData>(IndirectArgCapacity, GPUBuffer.Target.Structured);
		IndirectArgsBuffer = new GPUBuffer<uint>(IndirectArgCapacity * 5, GPUBuffer.Target.IndirectArgs);
		IndirectExtraArgBuffer = new GPUBuffer<uint>(IndirectArgCapacity, GPUBuffer.Target.Structured);
		RenderBuffer = new GPUBuffer<uint>(32000, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref DrawCallArray);
		DrawCallBuffer?.Dispose();
		DrawCallBuffer = null;
		IndirectArgsBuffer?.Dispose();
		IndirectArgsBuffer = null;
		IndirectExtraArgBuffer?.Dispose();
		IndirectExtraArgBuffer = null;
		RenderBuffer?.Dispose();
		RenderBuffer = null;
	}

	public void AddDrawCall(InstancedMeshRenderer renderer, int submeshIndex, uint indicies, uint indiciesIndex, uint vertexIndex, MultidrawMeshInfo multidraw)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		int count = DrawCalls.Count;
		int num = Math.Min(renderer.Materials.Length - 1, submeshIndex);
		DrawCall drawCall = new DrawCall
		{
			DrawCallIndex = count,
			LightProbes = renderer.LightProbes,
			Material = renderer.Materials[num],
			MultidrawMaterial = renderer.MultidrawMaterials[num],
			Mesh = renderer.Mesh,
			ReceiveShadows = renderer.RecieveShadows,
			RendererId = renderer.RendererId,
			ShadowMode = renderer.CastShadows,
			MeshCategory = renderer.MeshCategory,
			SubmeshIndex = submeshIndex
		};
		drawCall.JobData = new DrawCallJobData
		{
			IndexCount = indicies,
			IndexStart = indiciesIndex,
			VertexStart = vertexIndex,
			MultidrawIndexStart = (uint)multidraw.IndexStart,
			MultidrawVertexStart = (uint)multidraw.VertexStart,
			DrawCallIndex = count,
			RendererIndex = renderer.RendererId
		};
		DrawCalls.Add(drawCall);
		_needsDrawCallRebuild = true;
		EnsureDrawCallCapcity();
		DrawCallArray[count] = drawCall.JobData;
		if (!NeedsToRebuildMaterialBlocks())
		{
			RebuildAllMaterialBlocks();
		}
		else
		{
			UpdateMaterialBlock(drawCall);
		}
	}

	private bool NeedsToRebuildMaterialBlocks()
	{
		if (cellAllocator.PositionBuffer.BufferVersion == _positionBufferVersion)
		{
			return cellAllocator.OverrideBuffer.BufferVersion != _overrideBufferVersion;
		}
		return true;
	}

	private void RebuildAllMaterialBlocks()
	{
		_overrideBufferVersion = cellAllocator.OverrideBuffer.BufferVersion;
		_positionBufferVersion = cellAllocator.PositionBuffer.BufferVersion;
		for (int i = 0; i < DrawCalls.Count; i++)
		{
			UpdateMaterialBlock(DrawCalls[i]);
		}
	}

	private void UpdateMaterialBlock(DrawCall drawCall)
	{
		MaterialPropertyBlock materialBlock = drawCall.MaterialBlock;
		materialBlock.SetBuffer(InstancingUtil.PositionBufferProperty, cellAllocator.PositionBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.RenderBufferProperty, RenderBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.IndirectExtraArgProperty, IndirectExtraArgBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.Param_MeshOverrideBuffer, cellAllocator.OverrideBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.Param_Verticies, GeometryBuffers.VertexBuffer.Buffer);
		materialBlock.SetBuffer(InstancingUtil.Param_Triangles, GeometryBuffers.TriangleBuffer.Buffer);
		materialBlock.SetInt(InstancingUtil.DrawCallIndexProperty, drawCall.DrawCallIndex);
	}

	public void EnsureCapacity(int totalMeshCount)
	{
		bool flag = false;
		if (totalMeshCount > RenderBuffer.count)
		{
			int newCapacity = Mathf.ClosestPowerOfTwo(totalMeshCount) * 2;
			RenderBuffer.Expand(newCapacity);
			flag = true;
		}
		if (NeedsToRebuildMaterialBlocks())
		{
			flag = true;
		}
		if (GeometryBuffers.IsDirty)
		{
			flag = true;
			GeometryBuffers.IsDirty = false;
		}
		if (_needsDrawCallRebuild)
		{
			SortAndBatchDrawCalls();
			_needsDrawCallRebuild = false;
		}
		if (flag)
		{
			RebuildAllMaterialBlocks();
		}
	}

	private void EnsureDrawCallCapcity()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (DrawCalls.Count > IndirectArgCapacity)
		{
			IndirectArgCapacity = Mathf.ClosestPowerOfTwo(DrawCalls.Count) * 2;
			NativeArrayEx.Expand(ref DrawCallArray, IndirectArgCapacity, (NativeArrayOptions)1);
			DrawCallBuffer.Expand(IndirectArgCapacity);
			DrawCallBuffer.SetData(DrawCallArray);
			IndirectArgsBuffer.Expand(IndirectArgCapacity * 5);
			IndirectExtraArgBuffer.Expand(IndirectArgCapacity);
		}
	}

	public void UpdateComputeBuffers()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		DrawCallBuffer.SetData(DrawCallArray);
	}

	private void SortAndBatchDrawCalls()
	{
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		DrawCalls = DrawCalls.OrderBy((DrawCall x) => x.CalculateKey().GetHashCode()).ToList();
		foreach (DrawCall drawCall3 in DrawCalls)
		{
			drawCall3.MultiDrawExtraCount = 0;
		}
		int num;
		for (num = 0; num < DrawCalls.Count; num++)
		{
			DrawCall drawCall = DrawCalls[num];
			for (int i = num + 1; i < DrawCalls.Count && DrawCalls[i].CalculateKey() == drawCall.CalculateKey(); i++)
			{
				drawCall.MultiDrawExtraCount++;
			}
			num += drawCall.MultiDrawExtraCount;
		}
		for (int j = 0; j < DrawCalls.Count; j++)
		{
			DrawCall drawCall2 = DrawCalls[j];
			drawCall2.DrawCallIndex = j;
			drawCall2.JobData.DrawCallIndex = drawCall2.DrawCallIndex;
			DrawCallArray[j] = drawCall2.JobData;
		}
		DrawCallBuffer.SetData(DrawCallArray);
	}

	public void SubmitDrawCalls()
	{
		DrawCallsLastFrame = 0;
		SubmitDrawCallsInternal(MainCamera.mainCamera);
	}

	private void SubmitDrawCallsInternal(Camera camera)
	{
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Invalid comparison between Unknown and I4
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Invalid comparison between Unknown and I4
		if ((Object)(object)camera == (Object)null || !((Behaviour)camera).enabled)
		{
			return;
		}
		if (Render.IsMultidrawEnabled)
		{
			Shader.EnableKeyword(ref InstancingUtil.Keyword_Rust_Procedural_Rendering);
		}
		for (int i = 0; i < DrawCalls.Count; i++)
		{
			DrawCall drawCall = DrawCalls[i];
			switch (drawCall.MeshCategory)
			{
			case InstancedMeshCategory.BuildingBlock:
				if (!Render.instanced_toggle_buildings)
				{
					continue;
				}
				break;
			case InstancedMeshCategory.Cliff:
				if (!Render.instanced_toggle_cliffs)
				{
					continue;
				}
				break;
			case InstancedMeshCategory.Other:
				if (!Render.instanced_toggle_other)
				{
					continue;
				}
				break;
			}
			DrawCallsLastFrame++;
			if (Render.IsMultidrawEnabled)
			{
				RenderParams val = default(RenderParams);
				((RenderParams)(ref val)).camera = camera;
				((RenderParams)(ref val)).layer = 2097152;
				((RenderParams)(ref val)).lightProbeUsage = drawCall.LightProbes;
				((RenderParams)(ref val)).material = drawCall.MultidrawMaterial;
				((RenderParams)(ref val)).worldBounds = cullingBounds;
				((RenderParams)(ref val)).shadowCastingMode = drawCall.ShadowMode;
				((RenderParams)(ref val)).receiveShadows = drawCall.ReceiveShadows;
				((RenderParams)(ref val)).matProps = drawCall.MaterialBlock;
				RenderParams val2 = val;
				if (((int)((RenderParams)(ref val2)).shadowCastingMode != 1 && (int)((RenderParams)(ref val2)).shadowCastingMode != 3) || Render.render_shadows)
				{
					Graphics.RenderPrimitivesIndexedIndirect(ref val2, (MeshTopology)0, GeometryBuffers.TriangleBuffer.Buffer, IndirectArgsBuffer.Buffer, 1 + drawCall.MultiDrawExtraCount, i);
				}
				i += drawCall.MultiDrawExtraCount;
			}
			else
			{
				int num = drawCall.DrawCallIndex * 5 * 4;
				Graphics.DrawMeshInstancedIndirect(drawCall.Mesh, drawCall.SubmeshIndex, drawCall.Material, cullingBounds, IndirectArgsBuffer.Buffer, num, drawCall.MaterialBlock, drawCall.ShadowMode, drawCall.ReceiveShadows, 2097152, camera, drawCall.LightProbes);
			}
		}
		Shader.DisableKeyword(ref InstancingUtil.Keyword_Rust_Procedural_Rendering);
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### DrawCallManager ###");
		builder.MemoryUsage("RenderBuffer", RenderBuffer.Buffer);
		builder.MemoryUsage("IndirectArgsBuffer", IndirectArgsBuffer.Buffer);
		builder.MemoryUsage("IndirectExtraArgsBuffer", IndirectExtraArgBuffer.Buffer);
		builder.MemoryUsage<DrawCallJobData>("DrawCallArray", DrawCallArray, DrawCalls.Count);
		builder.MemoryUsage("DrawCalls", (ICollection<DrawCall>)DrawCalls);
	}
}


using UnityEngine;
using UnityEngine.Rendering;

private class DrawCall
{
	public int DrawCallIndex;

	public int RendererId;

	public Mesh Mesh;

	public int SubmeshIndex;

	public Material Material;

	public Material MultidrawMaterial;

	public ShadowCastingMode ShadowMode;

	public bool ReceiveShadows;

	public LightProbeUsage LightProbes;

	public InstancedMeshCategory MeshCategory;

	public int MultiDrawExtraCount;

	private DrawCallKey _key;

	public DrawCallJobData JobData;

	public MaterialPropertyBlock MaterialBlock = new MaterialPropertyBlock();

	public DrawCallKey CalculateKey()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (_key == default(DrawCallKey))
		{
			_key = new DrawCallKey(Material, ShadowMode, ReceiveShadows, LightProbes);
		}
		return _key;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public class InstancedCommandBufferManager
{
	private CommandBuffer normalCommandBuffer;

	private CommandBuffer shadowCommandBuffer;

	public void OnCameraEnabled(Camera camera)
	{
	}

	public void OnCameraDisabled(Camera camera)
	{
	}

	public void UpdateCameraHook()
	{
	}
}


using Unity.Collections;

public class InstancedCullingManager
{
	public NativeArray<int> RenderSliceIndexes;

	public NativeArray<int> PostCullingMeshCounts;
}


using System.Collections.Generic;
using UnityEngine;

public class MaterialCache
{
	public Dictionary<Material, Material> modifiedMaterials = new Dictionary<Material, Material>();

	public Material EnableProceduralInstancing(Material material)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (modifiedMaterials.TryGetValue(material, out var value))
		{
			return value;
		}
		value = new Material(material);
		value.enableInstancing = true;
		value.EnableKeyword("PROCEDURAL_INSTANCING_ON");
		modifiedMaterials.Add(material, value);
		RequestTextureStreaming(material);
		return value;
	}

	private void RequestTextureStreaming(Material material)
	{
		RequestMipmap(material, "_MainTex");
		RequestMipmap(material, "_MetallicGlossMap");
		RequestMipmap(material, "_SpecGlossMap");
		RequestMipmap(material, "_BumpMap");
		RequestMipmap(material, "_OcclusionMap");
		RequestMipmap(material, "_EmissionMap");
		RequestMipmap(material, "_TransmissionMap");
		RequestMipmap(material, "_SubsurfaceMaskMap");
		RequestMipmap(material, "_TransmissionMaskMap");
		RequestMipmap(material, "_DetailMask");
		RequestMipmap(material, "_DetailOcclusionMap");
		RequestMipmap(material, "_BiomeLayer_TintMask");
		RequestMipmap(material, "_WetnessLayer_Mask");
		RequestMipmap(material, "_DetailAlbedoMap");
		RequestMipmap(material, "_DetailMetallicGlossMap");
		RequestMipmap(material, "_DetailNormalMap");
		RequestMipmap(material, "_DetailTintMap");
		RequestMipmap(material, "_DetailBlendMaskMap");
	}

	private void RequestMipmap(Material material, string textureName)
	{
		if (material.HasTexture(textureName))
		{
			Texture texture = material.GetTexture(textureName);
			Texture2D val = (Texture2D)(object)((texture is Texture2D) ? texture : null);
			if ((Object)(object)val != (Object)null)
			{
				val.requestedMipmapLevel = 0;
			}
		}
	}

	public void FreeMemory()
	{
		foreach (Material value in modifiedMaterials.Values)
		{
			Object.DestroyImmediate((Object)(object)value);
		}
		modifiedMaterials = new Dictionary<Material, Material>();
	}
}


using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;
using Instancing;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

public class MeshGridManager
{
	private struct MeshGridKey
	{
		public int SpatialId;

		public bool IsShadow;
	}

	private class GridAllocationInfo
	{
		public List<int> Cells = new List<int>();
	}

	public NativeArray<GridJobData> Grids;

	private float HalfWorldSize;

	private float GridSize;

	private const int GridCount = 32;

	private const int normalGridCount = 1024;

	private const int shadowGridCount = 1024;

	private const int outOfBoundsGrid = 2048;

	private const int lastGridId = 2048;

	public void Initialize()
	{
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Grids = new NativeArray<GridJobData>(2049, (Allocator)4, (NativeArrayOptions)1);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref Grids);
	}

	public int GetPartitionKey(float3 position, bool hasShadow)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		int num = GetGridId(position);
		if (hasShadow && num != 2048)
		{
			num += 1024;
		}
		return num;
	}

	public void SetWorldSize(float worldSize)
	{
		GridSize = worldSize / 32f;
		HalfWorldSize = worldSize / 2f;
		UpdateGridBounds();
	}

	private void UpdateGridBounds()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Grids.Length; i++)
		{
			GridJobData gridJobData = Grids[i];
			gridJobData.GridId = i;
			if (i < 1024)
			{
				gridJobData.CanBeFrustumCulled = true;
			}
			if (i < 2048)
			{
				Bounds gridBounds = GetGridBounds(i);
				gridJobData.CanBeDistanceCulled = true;
				gridJobData.MinBounds = float3.op_Implicit(((Bounds)(ref gridBounds)).min);
				gridJobData.MaxBounds = float3.op_Implicit(((Bounds)(ref gridBounds)).max);
			}
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int GetGridId(float3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)((point.x + HalfWorldSize) / GridSize);
		int num2 = (int)((point.z + HalfWorldSize) / GridSize);
		if (num < 0 || num2 < 0 || num >= 32 || num2 >= 32)
		{
			return 2048;
		}
		return num + num2 * 32;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private float3 GetGridCenter(int gridId)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (gridId >= 1024 && gridId < 2048)
		{
			gridId -= 1024;
		}
		float num = (float)(gridId % 32) * GridSize - HalfWorldSize;
		float num2 = (float)(gridId / 32) * GridSize - HalfWorldSize;
		return new float3(num + GridSize / 2f, 0f, num2 + GridSize / 2f);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private Bounds GetGridBounds(int gridId)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float3 gridCenter = GetGridCenter(gridId);
		return new Bounds(float3.op_Implicit(gridCenter), new Vector3(GridSize, 1000f, GridSize));
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### GridManager ###");
		builder.MemoryUsage<GridJobData>("Grids", Grids, Grids.Length);
	}
}


private struct MeshGridKey
{
	public int SpatialId;

	public bool IsShadow;
}


using System.Collections.Generic;

private class GridAllocationInfo
{
	public List<int> Cells = new List<int>();
}


using System.Collections.Generic;
using System.Linq;
using System.Text;
using Instancing;
using Unity.Collections;
using UnityEngine;

public class RenderManager
{
	public NativeArray<InstancedRendererJobData> RendererArray;

	public NativeArray<uint> MeshCountArray;

	private Dictionary<MeshRenderKey, InstancedMeshRenderer> rendererLookup = new Dictionary<MeshRenderKey, InstancedMeshRenderer>();

	public List<InstancedMeshRenderer> Renderers = new List<InstancedMeshRenderer>();

	public GeometryBuffers GeometryBuffers;

	private const int initialRendererCapacity = 512;

	private readonly DrawCallManager drawCallManager;

	private readonly MaterialCache _materialCache;

	public int TotalMeshCount { get; private set; }

	public int TotalDrawCallCount { get; private set; }

	public int RendererCount => Renderers.Count;

	public RenderManager(DrawCallManager drawCalls, GeometryBuffers geometryBuffers, MaterialCache materialCache)
	{
		drawCallManager = drawCalls;
		GeometryBuffers = geometryBuffers;
		_materialCache = materialCache;
	}

	public void Initialize()
	{
		Renderers = new List<InstancedMeshRenderer>();
		rendererLookup = new Dictionary<MeshRenderKey, InstancedMeshRenderer>();
		TotalMeshCount = 0;
		TotalDrawCallCount = 0;
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		RendererArray = new NativeArray<InstancedRendererJobData>(512, (Allocator)4, (NativeArrayOptions)1);
		MeshCountArray = new NativeArray<uint>(512, (Allocator)4, (NativeArrayOptions)1);
	}

	private void FreeNativeMemory()
	{
		NativeArrayEx.SafeDispose(ref RendererArray);
		NativeArrayEx.SafeDispose(ref MeshCountArray);
	}

	public void OnMeshAdded(int rendererId)
	{
		MeshCountArray[rendererId] += 1;
		TotalMeshCount++;
	}

	public void OnMeshRemoved(int rendererId)
	{
		MeshCountArray[rendererId] -= 1;
		TotalMeshCount--;
	}

	public Bounds CalculateMeshBounds(int meshId, Matrix4x4 localToWorld)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return GeometryUtility.CalculateBounds(Renderers[meshId].BoundsPoints, localToWorld);
	}

	public bool DoesRendererHaveShadow(int meshId)
	{
		return Renderers[meshId].HasShadow;
	}

	public bool DoesRendererHaveMesh(int rendererId)
	{
		return Renderers[rendererId].HasMesh;
	}

	public bool IsLastLOD(int rendererId)
	{
		return Renderers[rendererId].IsLastLod;
	}

	public int GetRendererId(InstancedLODState lod)
	{
		InstancedMeshRenderer instancedMeshRenderer = GetRenderer(lod);
		if (instancedMeshRenderer == null)
		{
			instancedMeshRenderer = RegisterRenderer(lod);
		}
		return instancedMeshRenderer.RendererId;
	}

	public float GetMinDistance(int rendererId)
	{
		return RendererArray[rendererId].MinDistance;
	}

	public float GetMaxDistance(int rendererId)
	{
		return RendererArray[rendererId].MaxDistance;
	}

	public Mesh GetMeshForRenderer(int rendererId)
	{
		return Renderers[rendererId].Mesh;
	}

	private InstancedMeshRenderer GetRenderer(InstancedLODState lod)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderKey key = new MeshRenderKey(lod.Mesh, lod.Materials, lod.CastShadows, lod.RecieveShadows, lod.LightProbes);
		rendererLookup.TryGetValue(key, out var value);
		return value;
	}

	private InstancedMeshRenderer RegisterRenderer(InstancedLODState lod)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderKey key = new MeshRenderKey(lod.Mesh, lod.Materials, lod.CastShadows, lod.RecieveShadows, lod.LightProbes);
		if (rendererLookup.TryGetValue(key, out var value))
		{
			Debug.LogWarning((object)"Tried to register a renderer that already exists: skipping");
			return value;
		}
		int count = Renderers.Count;
		int drawCallCount = drawCallManager.DrawCallCount;
		Material[] multidrawMaterials = key.Materials.Select((Material x) => _materialCache.EnableProceduralInstancing(x)).ToArray();
		InstancedMeshRenderer instancedMeshRenderer = new InstancedMeshRenderer(count, drawCallCount, key, multidrawMaterials, lod.LodLevel, lod.TotalLodLevels, lod.MeshCategory, GeometryBuffers);
		for (int i = 0; i < instancedMeshRenderer.DrawCallCount; i++)
		{
			Mesh mesh = instancedMeshRenderer.Mesh;
			drawCallManager.AddDrawCall(instancedMeshRenderer, i, mesh.GetIndexCount(i), mesh.GetIndexStart(i), mesh.GetBaseVertex(i), instancedMeshRenderer.MultidrawSubmeshes[i]);
		}
		rendererLookup[key] = instancedMeshRenderer;
		Renderers.Add(instancedMeshRenderer);
		InstancedRendererJobData instancedRendererJobData = default(InstancedRendererJobData);
		instancedRendererJobData.Id = count;
		instancedRendererJobData.MinDistance = lod.MinimumDistance;
		instancedRendererJobData.MaxDistance = lod.MaximumDistance;
		instancedRendererJobData.ShadowMode = instancedMeshRenderer.CastShadows;
		instancedRendererJobData.DrawCallCount = instancedMeshRenderer.DrawCallCount;
		InstancedRendererJobData instancedRendererJobData2 = instancedRendererJobData;
		EnsureJobDataCapacity();
		RendererArray[count] = instancedRendererJobData2;
		TotalDrawCallCount += instancedMeshRenderer.DrawCallCount;
		return instancedMeshRenderer;
	}

	private void EnsureJobDataCapacity()
	{
		if (RendererArray.Length <= Renderers.Count)
		{
			int newCapacity = Mathf.ClosestPowerOfTwo(Renderers.Count) * 2;
			NativeArrayEx.Expand(ref RendererArray, newCapacity, (NativeArrayOptions)1);
			NativeArrayEx.Expand(ref MeshCountArray, newCapacity, (NativeArrayOptions)1);
		}
	}

	public void PrintMemoryUsage(StringBuilder builder)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		builder.AppendLine("### RenderManager ###");
		builder.MemoryUsage("Renderers", (ICollection<InstancedMeshRenderer>)Renderers);
		builder.MemoryUsage<InstancedRendererJobData>("RendererArray", RendererArray);
		builder.MemoryUsage<uint>("MeshCountArray", MeshCountArray);
	}
}


using System;
using System.Collections.Generic;
using Instancing;
using UnityEngine;

public class TextureAtlasScheduler
{
	private class TextureAtlas
	{
		public int Resolution;

		public Texture2DArray TextureArray;

		public List<TextureAtlasItem> Textures = new List<TextureAtlasItem>();
	}

	private class TextureAtlasItem
	{
		public Texture Texture;

		public bool Occupied;
	}

	public static readonly TextureAtlasScheduler Instanced = new TextureAtlasScheduler();

	private Dictionary<int, TextureAtlas> textureAtlases = new Dictionary<int, TextureAtlas>();

	private int AddTexture(TextureAtlas atlas, Texture texture)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Expected O, but got Unknown
		int num = atlas.Textures.FindIndex((TextureAtlasItem x) => !x.Occupied);
		if (num == -1)
		{
			atlas.Textures.Add(new TextureAtlasItem());
			num = atlas.Textures.Count - 1;
		}
		TextureAtlasItem textureAtlasItem = atlas.Textures[num];
		textureAtlasItem.Occupied = false;
		if (atlas.TextureArray.depth < atlas.Textures.Count)
		{
			Texture2DArray val = new Texture2DArray(atlas.Resolution, atlas.Resolution, atlas.TextureArray.depth * 2, atlas.TextureArray.format, false);
			Graphics.CopyTexture((Texture)(object)atlas.TextureArray, (Texture)(object)val);
			Object.Destroy((Object)(object)atlas.TextureArray);
			atlas.TextureArray = val;
		}
		textureAtlasItem.Texture = texture;
		textureAtlasItem.Occupied = true;
		return num;
	}

	private void UpdateTexture(TextureAtlas atlas, Texture texture, int index)
	{
		atlas.Textures[index].Texture = texture;
		Graphics.CopyTexture(texture, (Texture)(object)atlas.TextureArray);
	}

	public int AddTextureToAtlas(Texture texture)
	{
		TextureAtlas orCreateAtlas = GetOrCreateAtlas(texture.width, texture.height);
		return AddTexture(orCreateAtlas, texture);
	}

	public void ReplaceTextureInAtlas(Texture texture, int index)
	{
		GetOrCreateAtlas(texture.width, texture.height);
	}

	private TextureAtlas GetOrCreateAtlas(int width, int height)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected O, but got Unknown
		if (width != height)
		{
			throw new NotSupportedException("Textures must be the same width and height");
		}
		if (!textureAtlases.TryGetValue(width, out var value))
		{
			value = new TextureAtlas
			{
				Resolution = width,
				TextureArray = new Texture2DArray(width, height, 8, (TextureFormat)5, false)
			};
			textureAtlases[width] = value;
		}
		return value;
	}

	private int GetResolutionKey(int xSize, int ySize)
	{
		return xSize * 10000 + ySize;
	}
}


using System.Collections.Generic;
using UnityEngine;

private class TextureAtlas
{
	public int Resolution;

	public Texture2DArray TextureArray;

	public List<TextureAtlasItem> Textures = new List<TextureAtlasItem>();
}


using UnityEngine;

private class TextureAtlasItem
{
	public Texture Texture;

	public bool Occupied;
}


using Instancing;

public class VirtualMeshScheduler
{
	public static readonly VirtualMeshScheduler Instance = new VirtualMeshScheduler();
}


public class VirtualPrefabScheduler
{
}


using System;
using System.Collections.Generic;
using Instancing;
using Rust.Workshop;
using UnityEngine;

public class WorkshopSkinScheduler
{
	private class SkinnableData
	{
		public List<DefaultSkinTexture> DefaultTextures = new List<DefaultSkinTexture>();
	}

	private class SkinData
	{
		public ulong SkinId;

		public SkinTexture[] Textures;
	}

	public struct DefaultSkinTexture
	{
		public int Resolution;

		public string Path;

		public Texture Texture;
	}

	public struct SkinTexture
	{
		public int Resolution;

		public int TextureIndex;

		public SkinTexture(int resolution, int textureIndex)
		{
			Resolution = resolution;
			TextureIndex = textureIndex;
		}
	}

	private Dictionary<ulong, SkinData> skinLookup = new Dictionary<ulong, SkinData>();

	private Dictionary<ulong, Skinnable> skinnableLookup = new Dictionary<ulong, Skinnable>();

	public SkinTexture[] GetTextures(Skin skinDef, ulong skinId)
	{
		if (!skinLookup.TryGetValue(skinId, out var value))
		{
			value = InitializeSkin(skinDef, skinId);
		}
		return value.Textures;
	}

	private SkinnableData GetOrCreateSkinnable(Skin skinDef)
	{
		new SkinnableData();
		throw new NotImplementedException();
	}

	private SkinData InitializeSkin(Skin skinDef, ulong skinId)
	{
		SkinData skinData = new SkinData
		{
			SkinId = skinId
		};
		skinLookup.Add(skinId, skinData);
		SkinnableData orCreateSkinnable = GetOrCreateSkinnable(skinDef);
		List<SkinTexture> list = new List<SkinTexture>();
		foreach (DefaultSkinTexture defaultTexture in orCreateSkinnable.DefaultTextures)
		{
			int textureIndex = TextureAtlasScheduler.Instanced.AddTextureToAtlas(defaultTexture.Texture);
			list.Add(new SkinTexture(defaultTexture.Resolution, textureIndex));
			string path = FindSkinTexturePath(skinId);
			LoadTextureAsync(path, defaultTexture.Resolution, textureIndex);
		}
		return skinData;
	}

	private string FindSkinTexturePath(ulong workshopSkin)
	{
		throw new NotImplementedException();
	}

	private void LoadTextureAsync(string path, int resolution, int textureIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Expected O, but got Unknown
		Texture texture = (Texture)new Texture2D(resolution, resolution);
		TextureAtlasScheduler.Instanced.ReplaceTextureInAtlas(texture, textureIndex);
	}
}


using System.Collections.Generic;

private class SkinnableData
{
	public List<DefaultSkinTexture> DefaultTextures = new List<DefaultSkinTexture>();
}


private class SkinData
{
	public ulong SkinId;

	public SkinTexture[] Textures;
}


using UnityEngine;

public struct DefaultSkinTexture
{
	public int Resolution;

	public string Path;

	public Texture Texture;
}


public struct SkinTexture
{
	public int Resolution;

	public int TextureIndex;

	public SkinTexture(int resolution, int textureIndex)
	{
		Resolution = resolution;
		TextureIndex = textureIndex;
	}
}


using System;
using ConVar;
using Instancing;
using Unity.Mathematics;
using UnityEngine;

public class GPUInstancedCulling
{
	public struct CullingParameters
	{
		public ComputeShader cullShader;

		public ComputeShader postCullShader;

		public int shadowCameras;

		public Vector3 cameraPosition;

		public float maxDistance;

		public float distanceScale;

		public GPUBuffer<float4> frustumPlanes;

		public bool frustumCulling;

		public GPUBuffer<InstancedCullData> inputBuffer;

		public int inputLength;

		public GPUBuffer<DrawCallJobData> drawCalls;

		public int drawCallCount;

		public GPUBuffer<RenderSlice> renderSlices;

		public int sliceCount;

		public GPUBuffer<uint> renderBuffer;

		public GPUBuffer<uint> indirectArgs;

		public GPUBuffer<uint> indirectExtraArgs;
	}

	private static readonly int Param_InputBuffer = Shader.PropertyToID("_InputBuffer");

	private static readonly int Param_OutputBuffer = Shader.PropertyToID("_OutputBuffer");

	private static readonly int Param_ComputeBuffer = Shader.PropertyToID("_ComputeBuffer");

	private static readonly int Param_IndirectArgs = Shader.PropertyToID("_IndirectArgs");

	private static readonly int Param_IndirectExtraArgs = Shader.PropertyToID("_IndirectExtraArgs");

	private static readonly int Param_RenderSlices = Shader.PropertyToID("_RenderSlices");

	private static readonly int Param_SliceCounts = Shader.PropertyToID("_SliceCounts");

	private static readonly int Param_FrustumPlanes = Shader.PropertyToID("_FrustumPlanes");

	private static readonly int Param_ShadowFrustumCount = Shader.PropertyToID("_ShadowFrustumCount");

	private static readonly int Param_CameraPosition = Shader.PropertyToID("_CameraPosition");

	private static readonly int Param_MaxDistance = Shader.PropertyToID("_MaxDistance");

	private static readonly int Param_DistanceScale = Shader.PropertyToID("_DistanceScale");

	private static readonly int Param_SliceCount = Shader.PropertyToID("_SliceCount");

	private static readonly int Param_Length = Shader.PropertyToID("_Length");

	private static readonly int Param_DrawCalls = Shader.PropertyToID("_DrawCalls");

	private static readonly int Param_DrawCallCount = Shader.PropertyToID("_DrawCallCount");

	private static readonly int Param_Multidraw_Enabled = Shader.PropertyToID("_Multidraw_Enabled");

	private static readonly int Param_FrustumCullingEnabled = Shader.PropertyToID("_FrustumCullingEnabled");

	private GPUBuffer<uint> tempBuffer;

	private GPUBuffer<uint> postCullMeshCounts;

	public void Initialize()
	{
		AllocateNativeMemory();
	}

	public void OnDestroy()
	{
		FreeNativeMemory();
	}

	private void AllocateNativeMemory()
	{
		tempBuffer = new GPUBuffer<uint>(1024, GPUBuffer.Target.Structured);
		postCullMeshCounts = new GPUBuffer<uint>(1024, GPUBuffer.Target.Structured);
	}

	private void FreeNativeMemory()
	{
		tempBuffer?.Dispose();
		tempBuffer = null;
		postCullMeshCounts?.Dispose();
		postCullMeshCounts = null;
	}

	public void SimpleCulling(CullingParameters options)
	{
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (options.renderSlices.count < options.sliceCount + 1)
		{
			throw new ArgumentException("SliceIndexes must be at least as large as slice count + 1!");
		}
		if (tempBuffer.count < options.inputBuffer.count)
		{
			tempBuffer.Expand(options.inputBuffer.count);
		}
		if (postCullMeshCounts.count < options.renderSlices.count)
		{
			postCullMeshCounts.Expand(options.renderSlices.count);
		}
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, tempBuffer);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, postCullMeshCounts);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, options.renderBuffer);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, options.indirectArgs);
		ClearBuffer(SingletonComponent<InstancedScheduler>.Instance.ClearBufferShader, options.indirectExtraArgs);
		CullingShader(options.cullShader, options.inputBuffer, options.inputLength, tempBuffer, options.renderSlices, options.frustumPlanes, options.shadowCameras, options.cameraPosition, options.maxDistance, options.distanceScale, options.frustumCulling);
		SimplePostCull(options.postCullShader, tempBuffer, options.renderBuffer, options.renderSlices, options.sliceCount, postCullMeshCounts);
		WriteIndirectArgs(SingletonComponent<InstancedScheduler>.Instance.WriteIndirectArgsShader, postCullMeshCounts, options.renderSlices, options.drawCalls, options.drawCallCount, options.indirectArgs, options.indirectExtraArgs);
	}

	private static void CullingShader(ComputeShader shader, GPUBuffer<InstancedCullData> inputBuffer, int inputLength, GPUBuffer<uint> outputBuffer, GPUBuffer<RenderSlice> renderSlices, GPUBuffer<float4> frustumPlanes, int shadowCameras, Vector3 cameraPosition, float maxDistance, float distanceScale, bool frustumCulling)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (outputBuffer.stride != 4)
		{
			throw new ArgumentException($"Cull output buffer must have a stride of 4 ({outputBuffer.stride})!");
		}
		int iterationCount = GetIterationCount(inputLength, 1024);
		if (iterationCount != 0)
		{
			int num = shader.FindKernel("CullingKernel");
			shader.SetBuffer(num, Param_InputBuffer, inputBuffer);
			shader.SetBuffer(num, Param_OutputBuffer, outputBuffer);
			shader.SetBuffer(num, Param_RenderSlices, renderSlices);
			shader.SetBuffer<float4>(num, Param_FrustumPlanes, frustumPlanes);
			shader.SetVector(Param_CameraPosition, Vector4.op_Implicit(cameraPosition));
			shader.SetFloat(Param_MaxDistance, maxDistance);
			shader.SetFloat(Param_DistanceScale, distanceScale);
			shader.SetFloat(Param_FrustumCullingEnabled, frustumCulling ? 1f : 0f);
			shader.SetInt(Param_ShadowFrustumCount, shadowCameras);
			shader.Dispatch(num, iterationCount, 1, 1);
		}
	}

	private static void SimplePostCull(ComputeShader shader, GPUBuffer<uint> inputBuffer, GPUBuffer<uint> outputBuffer, GPUBuffer<RenderSlice> renderSlices, int sliceCount, GPUBuffer<uint> sliceCounts)
	{
		int iterationCount = GetIterationCount(sliceCount, 1024);
		if (iterationCount != 0)
		{
			int num = shader.FindKernel("SimplePostCull");
			shader.SetBuffer(num, Param_InputBuffer, inputBuffer);
			shader.SetBuffer(num, Param_OutputBuffer, outputBuffer);
			shader.SetBuffer(num, Param_RenderSlices, renderSlices);
			shader.SetBuffer(num, Param_SliceCounts, sliceCounts);
			shader.SetInt(Param_SliceCount, (Render.max_renderers > 0) ? Render.max_renderers : sliceCount);
			shader.Dispatch(num, iterationCount, 1, 1);
		}
	}

	private static void WriteIndirectArgs(ComputeShader shader, GPUBuffer<uint> sliceCounts, GPUBuffer<RenderSlice> renderSlices, GPUBuffer<DrawCallJobData> drawCalls, int drawCallCount, GPUBuffer<uint> indirectArgs, GPUBuffer<uint> indirectExtraArgs)
	{
		int iterationCount = GetIterationCount(drawCallCount, 1024);
		if (iterationCount != 0)
		{
			int num = shader.FindKernel("WriteIndirectArgs");
			shader.SetBuffer(num, Param_SliceCounts, sliceCounts);
			shader.SetBuffer(num, Param_RenderSlices, renderSlices);
			shader.SetBuffer(num, Param_DrawCalls, drawCalls);
			shader.SetInt(Param_DrawCallCount, drawCallCount);
			shader.SetBuffer(num, Param_IndirectArgs, indirectArgs);
			shader.SetBuffer(num, Param_IndirectExtraArgs, indirectExtraArgs);
			shader.SetInt(Param_Multidraw_Enabled, Render.IsMultidrawEnabled ? 1 : 0);
			shader.Dispatch(num, iterationCount, 1, 1);
		}
	}

	private static void ClearBuffer(ComputeShader shader, GPUBuffer<uint> buffer)
	{
		int count = buffer.count;
		int iterationCount = GetIterationCount(count, 1024);
		int num = shader.FindKernel("ClearBufferKernel");
		shader.SetBuffer(num, Param_ComputeBuffer, buffer);
		shader.SetInt(Param_Length, count);
		shader.Dispatch(num, iterationCount, 1, 1);
	}

	private static int GetIterationCount(int count, int threads)
	{
		return count / threads + ((count % threads != 0) ? 1 : 0);
	}
}


using Unity.Mathematics;
using UnityEngine;

public struct CullingParameters
{
	public ComputeShader cullShader;

	public ComputeShader postCullShader;

	public int shadowCameras;

	public Vector3 cameraPosition;

	public float maxDistance;

	public float distanceScale;

	public GPUBuffer<float4> frustumPlanes;

	public bool frustumCulling;

	public GPUBuffer<InstancedCullData> inputBuffer;

	public int inputLength;

	public GPUBuffer<DrawCallJobData> drawCalls;

	public int drawCallCount;

	public GPUBuffer<RenderSlice> renderSlices;

	public int sliceCount;

	public GPUBuffer<uint> renderBuffer;

	public GPUBuffer<uint> indirectArgs;

	public GPUBuffer<uint> indirectExtraArgs;
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct FillFalseJobDefer : IJobParallelForDefer
{
	[ReadOnly]
	public NativeList<Ray> rays;

	public NativeArray<bool> HitResults;

	public void Execute(int index)
	{
		HitResults[index] = false;
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct AdjustByTopologyJob : IJobParallelForDefer
{
	[ReadOnly]
	public NativeList<Ray> rays;

	public NativeArray<bool> hitResults;

	public NativeArray<Vector3> hitNormals;

	public ReadOnly<Vector3> hitPositions;

	[ReadOnly]
	public NativeArray<int> TopologyData;

	[ReadOnly]
	public int TopologyRes;

	[ReadOnly]
	public Vector2 DataOrigin;

	[ReadOnly]
	public Vector2 DataScale;

	public void Execute(int index)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (hitResults[index])
		{
			hitNormals[index] = Vector3.up;
			float num = (hitPositions[index].x - DataOrigin.x) * DataScale.x;
			float num2 = (hitPositions[index].z - DataOrigin.y) * DataScale.y;
			int num3 = Math.Clamp((int)(num * (float)TopologyRes), 0, TopologyRes - 1);
			int num4 = Math.Clamp((int)(num2 * (float)TopologyRes), 0, TopologyRes - 1) * TopologyRes + num3;
			hitResults[index] = (TopologyData[num4] & 0x180) != 0;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct SmallDisplacementPlaneTraceJob : IJobParallelForDefer
{
	public Plane SeaPlane;

	[ReadOnly]
	public NativeList<int> Indices;

	[ReadOnly]
	public NativeArray<Ray> Rays;

	public ReadOnly<float> MaxDists;

	[NativeDisableParallelForRestriction]
	[WriteOnly]
	public NativeArray<bool> HitResults;

	[WriteOnly]
	[NativeDisableParallelForRestriction]
	public NativeArray<Vector3> HitPositions;

	public void Execute(int indicesIndex)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		int num = Indices[indicesIndex];
		Ray val = Rays[num];
		float num2 = MaxDists[num];
		bool flag = false;
		Vector3 val2 = Vector3.zero;
		float num3 = default(float);
		if (((Plane)(ref SeaPlane)).Raycast(val, ref num3) && num3 < num2)
		{
			flag = true;
			val2 = ((Ray)(ref val)).GetPoint(num3);
		}
		HitResults[num] = flag;
		HitPositions[num] = val2;
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct OceanTraceJob : IJobParallelForDefer
{
	public const int maxSteps = 16;

	public const int maxBinarySteps = 16;

	public const float intersectionThreshold = 0.1f;

	public const float seaLevel = 0f;

	public float MaxDisplacement;

	[ReadOnly]
	public NativeList<int> Indices;

	[ReadOnly]
	public NativeArray<Ray> Rays;

	public ReadOnly<float> MaxDists;

	[WriteOnly]
	[NativeDisableParallelForRestriction]
	public NativeArray<bool> HitResults;

	[NativeDisableParallelForRestriction]
	[WriteOnly]
	public NativeArray<Vector3> HitPositions;

	public float OneOverOctave0Scale;

	[ReadOnly]
	[NativeDisableParallelForRestriction]
	public NativeOceanDisplacementShort3 SimData;

	public int Spectrum0;

	public int Spectrum1;

	public int Frame0;

	public int Frame1;

	public float spectrumBlend;

	public float frameBlend;

	public TerrainHeightMap.HeightMapQueryStructure HeightMapQueryStructure;

	public TerrainTexturing.ShoreVectorQueryStructure ShoreVectorQueryStructure;

	public float distanceAttenuationFactor;

	public float depthAttenuationFactor;

	public void Execute(int indicesIndex)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		int num = Indices[indicesIndex];
		Ray ray = Rays[num];
		float maxDist = MaxDists[num];
		Vector3 result;
		bool flag = Trace(in ray, maxDist, out result);
		HitResults[num] = flag;
		HitPositions[num] = result;
	}

	private bool Trace(in Ray ray, float maxDist, out Vector3 result)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f - MaxDisplacement;
		Ray val = ray;
		Vector3 point = ((Ray)(ref val)).GetPoint(maxDist);
		val = ray;
		if (((Ray)(ref val)).origin.y > MaxDisplacement && point.y > MaxDisplacement)
		{
			result = Vector3.zero;
			return false;
		}
		val = ray;
		if (((Ray)(ref val)).origin.y < num && point.y < num)
		{
			result = Vector3.zero;
			return false;
		}
		val = ray;
		Vector3 val2 = ((Ray)(ref val)).origin;
		val = ray;
		Vector3 direction = ((Ray)(ref val)).direction;
		float num2 = 0f;
		float num3 = 0f;
		float num4 = 2f / (math.abs(direction.y) + 1f);
		result = val2;
		if (direction.y <= -0.99f)
		{
			result.y = GetHeight(val2);
			return math.lengthsq(float3.op_Implicit(result - val2)) < maxDist * maxDist;
		}
		if (val2.y >= MaxDisplacement + 0f)
		{
			num3 = (num2 = (0f - (val2.y - MaxDisplacement - 0f)) / direction.y);
			val2 += num2 * direction;
			if (num3 >= maxDist)
			{
				result = Vector3.zero;
				return false;
			}
		}
		int num5 = 0;
		while (true)
		{
			float height = GetHeight(val2);
			num2 = num4 * Mathf.Abs(val2.y - height - 0f);
			val2 += num2 * direction;
			num3 += num2;
			if (num5 >= 16 || num2 < 0.1f)
			{
				break;
			}
			if (num3 >= maxDist)
			{
				return false;
			}
			num5++;
		}
		if (num2 < 0.1f && num3 >= 0f)
		{
			result = val2;
			return true;
		}
		if (direction.y < 0f)
		{
			num2 = (0f - (val2.y + MaxDisplacement - 0f)) / direction.y;
			Vector3 val3 = val2;
			Vector3 val4 = val2;
			float num6 = num2;
			val = ray;
			Vector3 val5 = val4 + num6 * ((Ray)(ref val)).direction;
			for (int i = 0; i < 16; i++)
			{
				val2 = (val3 + val5) * 0.5f;
				float height2 = GetHeight(val2);
				if (val2.y - height2 - 0f > 0f)
				{
					val3 = val2;
				}
				else
				{
					val5 = val2;
				}
				if (math.abs(val2.y - height2) < 0.1f)
				{
					val2.y = height2;
					break;
				}
			}
			result = val2;
			return true;
		}
		return false;
	}

	private float GetHeight(Vector3 point)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetHeightRaw(point) * GetHeightAttenuation(point);
	}

	public float GetHeightAttenuation(Vector3 position)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		float x = HeightMapQueryStructure.TerrainPosition.x;
		float z = HeightMapQueryStructure.TerrainPosition.z;
		float x2 = HeightMapQueryStructure.TerrainOneOverSize.x;
		float z2 = HeightMapQueryStructure.TerrainOneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float coarseDistanceToShore = ShoreVectorQueryStructure.GetCoarseDistanceToShore(position);
		float heightFast = HeightMapQueryStructure.GetHeightFast(uv);
		float num3 = Mathf.Clamp01(coarseDistanceToShore / distanceAttenuationFactor);
		float num4 = Mathf.Clamp01(Mathf.Abs(heightFast) / depthAttenuationFactor);
		return num3 * num4;
	}

	private float GetHeightRaw(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero = GetDisplacement(position);
		zero = GetDisplacement(position - zero);
		zero = GetDisplacement(position - zero);
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return GetDisplacement(normX, normZ);
	}

	private Vector3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		Vector3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		Vector3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		Vector3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		Vector3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(float3.op_Implicit(displacementFromSimData), float3.op_Implicit(displacementFromSimData2), num5);
		float3 val2 = math.lerp(float3.op_Implicit(displacementFromSimData3), float3.op_Implicit(displacementFromSimData4), num5);
		return float3.op_Implicit(math.lerp(val, val2, num6));
	}

	private Vector3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], spectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], spectrumBlend);
		return float3.op_Implicit(math.lerp(val, val2, frameBlend));
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PaintSplatJob : IJobFor
{
	[NativeDisableParallelForRestriction]
	public ReadOnly<float> HeightMapDelta;

	public int HeightMapRes;

	[NativeDisableParallelForRestriction]
	public ReadOnly<float> AngleMapDeg;

	[NativeDisableParallelForRestriction]
	public ReadOnly<int> TopologyMap;

	public int TopologyMapRes;

	[NativeDisableParallelForRestriction]
	public NativeArray<byte> SplatMap;

	public int SplatMapRes;

	public int SplatNum;

	[NativeDisableParallelForRestriction]
	public ReadOnly<int, int> SplatType2Index;

	public float TerrainOneOverSizeX;

	public void Execute(int index)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		int num = index % HeightMapRes;
		int num2 = index / HeightMapRes;
		float num3 = ((float)num - 0.5f) / (float)HeightMapRes;
		float num4 = ((float)num2 - 0.5f) / (float)HeightMapRes;
		if ((TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, 0f, num3, num4) & 0xB4990) != 0 || (TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, 8f, num3, num4) & 2) != 0 || AngleMapDeg[num2 * HeightMapRes + num] < 3f)
		{
			return;
		}
		float grad;
		float num5 = ConcavityFactor(HeightMapDelta, HeightMapRes, num, num2, out grad);
		if (!(num5 < 3.5762787E-07f))
		{
			int x = Index(num3, SplatMapRes);
			int z = Index(num4, SplatMapRes);
			float splat = GetSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, num3, num4, 2);
			float splat2 = GetSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, num3, num4, 4);
			if (splat > 0.25f || splat2 > 0.25f)
			{
				num5 = math.saturate(num5 * 3f);
				grad = math.pow(grad, 2f);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 64, math.pow(num5, 0.8f) * grad);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 128, math.pow(num5, 1.5f) * grad);
			}
			else
			{
				num5 = math.saturate(num5 * 3f);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 1, math.pow(num5, 4f) * math.pow(grad, 1.5f));
				grad = math.pow(grad, 2f);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 64, math.pow(num5, 0.8f) * grad);
				AddSplat(SplatMap, SplatMapRes, SplatNum, SplatType2Index, x, z, 128, math.pow(num5, 1.4f) * grad);
			}
		}
		static int Index(float normalized, int res)
		{
			int num6 = (int)(normalized * (float)res);
			if (num6 >= 0)
			{
				if (num6 <= res - 1)
				{
					return num6;
				}
				return res - 1;
			}
			return 0;
		}
	}

	private static void AddSplat(NativeArray<byte> src, int res, int splatNum, ReadOnly<int, int> type2Index, int x, int z, int id, float d)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		float splat = GetSplat(src, res, splatNum, type2Index, x, z, id);
		float num = math.saturate(splat + d);
		int num2 = type2Index[id];
		if (splat >= 1f)
		{
			return;
		}
		float num3 = (1f - num) / (1f - splat);
		for (int i = 0; i < splatNum; i++)
		{
			if (i == num2)
			{
				src[(i * res + z) * res + x] = BitUtility.Float2Byte(num);
			}
			else
			{
				src[(i * res + z) * res + x] = BitUtility.Float2Byte(num3 * BitUtility.Byte2Float((int)src[(i * res + z) * res + x]));
			}
		}
	}

	private static float GetSplat(NativeArray<byte> src, int res, int splatNum, ReadOnly<int, int> type2Index, float xn, float zn, int mask)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = xn * (float)num;
		float num3 = zn * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetSplat(src, res, splatNum, type2Index, num4, num5, mask), GetSplat(src, res, splatNum, type2Index, x, num5, mask), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetSplat(src, res, splatNum, type2Index, num4, z, mask), GetSplat(src, res, splatNum, type2Index, x, z, mask), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	private static float GetSplat(NativeArray<byte> src, int res, int splatNum, ReadOnly<int, int> type2Index, int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(type2Index[mask] * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < splatNum; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	private static float ConcavityFactor(ReadOnly<float> data, int res, int x, int z, out float grad)
	{
		int num = x - 1;
		int num2 = x + 1;
		int num3 = z - 1;
		int num4 = z + 1;
		float num5 = data[z * res + x];
		float num6 = data[z * res + num];
		float num7 = data[z * res + num2];
		float num8 = data[num4 * res + x];
		float num9 = data[num3 * res + x];
		float num10 = num6 + num7 + num8 + num9;
		float num11 = data[num3 * res + num] + data[num3 * res + num2] + data[num4 * res + num] + data[num4 * res + num2];
		float num12 = num7 - num6;
		float num13 = num8 - num9;
		grad = math.sqrt(num12 * num12 + num13 * num13);
		return math.max(num10 / 4f + num11 / 4f - num5, 0f);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PopulateDeltaHeightJob : IJobParallelFor
{
	public ReadOnly<float> HeightMapOriginal;

	public ReadOnly<float> HeightMap;

	[WriteOnly]
	public NativeArray<float> DeltaHeightMap;

	public void Execute(int index)
	{
		DeltaHeightMap[index] = HeightMapOriginal[index] - HeightMap[index];
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CopyBackFloatHeightToShortHeightJob : IJobParallelFor
{
	public ReadOnly<float> HeightMapAsFloat;

	[WriteOnly]
	public NativeArray<short> HeightMapAsShort;

	public float TerrainOneOverSizeY;

	public float TerrainPositionY;

	public void Execute(int index)
	{
		HeightMapAsShort[index] = BitUtility.Float2Short(TerrainOneOverSizeY * (HeightMapAsFloat[index] - TerrainPositionY));
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct EvaporationJob : IJobParallelFor
{
	public NativeArray<float> WaterMap;

	public float DT;

	public float EvaporationRate;

	public void Execute(int index)
	{
		ref NativeArray<float> waterMap = ref WaterMap;
		waterMap[index] *= 1f - EvaporationRate * DT;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CopyArrayJob<T> : IJob where T : unmanaged
{
	[WriteOnly]
	public NativeArray<T> CopyTarget;

	[ReadOnly]
	public NativeArray<T> CopySource;

	public void Execute()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		CopyTarget.CopyFrom(CopySource);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PrepareMapJob : IJobParallelForBatch
{
	public ReadOnly<short> HeightMapAsShort;

	[WriteOnly]
	public NativeArray<float> HeightMapAsFloat;

	public ParallelWriter<int> OceanIndicesWriter;

	public float TerrainPositionY;

	public float TerrainSizeY;

	public float OceanLevel;

	public void Execute(int startIndex, int count)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		NativeList<int> val = default(NativeList<int>);
		val..ctor(count, AllocatorHandle.op_Implicit((Allocator)2));
		for (int i = startIndex; i < startIndex + count; i++)
		{
			float num2 = (HeightMapAsFloat[i] = TerrainPositionY + BitUtility.Short2Float((int)HeightMapAsShort[i]) * TerrainSizeY);
			if (num2 <= OceanLevel)
			{
				val.Add(ref i);
			}
		}
		OceanIndicesWriter.AddRangeNoResize(val);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct TransportSedimentJob : IJobParallelFor
{
	public NativeArray<float> SedimentMap;

	public ReadOnly<float> SedimentReadOnlyMap;

	public ReadOnly<float2> VelocityMap;

	public int Res;

	public float DT;

	public void Execute(int index)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		int num = index % Res;
		int num2 = index / Res;
		float2 val = VelocityMap[index];
		int num3 = (int)((float)num - DT * val.x);
		int num4 = (int)((float)num2 - DT * val.y);
		num3 = math.clamp(num3, 0, Res - 1);
		num4 = math.clamp(num4, 0, Res - 1);
		SedimentMap[index] = SedimentReadOnlyMap[num4 * Res + num3];
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CalcMinHeightMapJob : IJobParallelFor
{
	public ReadOnly<float> TerrainHeightMap;

	public int HeightMapRes;

	[WriteOnly]
	public NativeArray<float> MinTerrainHeightMap;

	public ReadOnly<int> TopologyMap;

	public int TopologyMapRes;

	public float OceanHeight;

	public float TerrainOneOverSizeX;

	public void Execute(int index)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainHeightMap[index];
		if (!(num < OceanHeight))
		{
			int num2 = index % HeightMapRes;
			int num3 = index / HeightMapRes;
			float normX = ((float)num2 - 0.5f) / (float)HeightMapRes;
			float normZ = ((float)num3 - 0.5f) / (float)HeightMapRes;
			bool flag = (TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, 0f, normX, normZ) & 0x14080) != 0;
			float num4 = 8f;
			float num5 = 8f;
			while (num5 > 0f && !flag && (TerrainTopologyMapJobUtil.GetTopologyRadius(TopologyMap, TopologyMapRes, TerrainOneOverSizeX, num5, normX, normZ) & 0x3C198) != 0)
			{
				num4 = num5;
				num5 -= 0.25f;
			}
			float num6 = (flag ? 0f : math.unlerp(0f, 8f, num4));
			num = math.max(OceanHeight, num - 1f * num6);
		}
		MinTerrainHeightMap[index] = num;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct ErosionAndDepositionJob : IJobParallelFor
{
	public NativeArray<float> SedimentMap;

	public ReadOnly<float> MinTerrainHeightMap;

	public ReadOnly<float> TerrainHeightMapSrcFloat;

	public NativeArray<float> TerrainHeightMapDstFloat;

	public NativeArray<float> WaterMap;

	public ReadOnly<float2> VelocityMap;

	public ReadOnly<float> AngleMap;

	public float DT;

	private const float SedimentCapacityConst = 0.0015f;

	private const float DissolveRateConstant = 0.15f;

	public void Execute(int index)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		float num = math.max(0.01047198f, AngleMap[index]);
		float2 val = VelocityMap[index];
		float num2 = 0.0015f * math.sin(num) * math.length(val);
		ref float reference = ref BurstUtil.Get<float>(ref WaterMap, index);
		float num3 = 1f - math.smoothstep(0f, 10f, reference);
		ref float reference2 = ref BurstUtil.Get<float>(ref SedimentMap, index);
		float num4 = DT * 0.15f * (num2 - reference2) * num3;
		float num5 = math.select(-1f, 1f, num2 > reference2) * num4;
		num5 = math.max(num5, 0f);
		float num6 = TerrainHeightMapSrcFloat[index];
		float num7 = num6 - num5;
		num7 = math.max(num7, MinTerrainHeightMap[index]);
		num5 = num7 - (num6 - num5);
		TerrainHeightMapDstFloat[index] = num7;
		reference2 += num5;
		reference += num5;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct TileCalculateAngleMap : IJobParallelFor
{
	[NativeDisableParallelForRestriction]
	[WriteOnly]
	public NativeArray<float> AngleMap;

	[ReadOnly]
	public ReadOnly<float> TerrainHeightMapSrcFloat;

	public float NormY;

	public int Res;

	public int NumXTiles;

	public int TileSizeX;

	public int TileSizeZ;

	public void Execute(int index)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		int num = index % NumXTiles;
		int num2 = index / NumXTiles;
		int num3 = math.max(num * TileSizeX, 1);
		int num4 = math.max(num2 * TileSizeZ, 1);
		int num5 = math.min(num3 + TileSizeX, Res - 1);
		int num6 = math.min(num4 + TileSizeZ, Res - 1);
		int4 val = default(int4);
		((int4)(ref val))..ctor(Res);
		int2 val2 = default(int2);
		((int2)(ref val2))..ctor(1, -1);
		for (int i = num4; i < num6; i++)
		{
			int2 val3 = new int2(i) + val2;
			int4 val4 = ((int2)(ref val3)).yyxy * val;
			for (int j = num3; j < num5; j++)
			{
				float4 val5 = float4.op_Implicit(val4 + new int4(j + 1, j - 1, j - 1, j - 1));
				float num7 = (TerrainHeightMapSrcFloat[(int)val5.x] - TerrainHeightMapSrcFloat[(int)val5.y]) * -0.5f;
				float num8 = (TerrainHeightMapSrcFloat[(int)val5.z] - TerrainHeightMapSrcFloat[(int)val5.w]) * -0.5f;
				float3 val6 = math.normalize(new float3(num7, NormY, num8));
				float num9 = math.dot(val6, val6);
				AngleMap[i * Res + j] = math.acos(math.clamp(math.dot(math.up(), math.normalize(val6)) / num9, -1f, 1f));
			}
		}
	}
}


using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct AdjustWaterHeightByFluxJob : IJobParallelFor
{
	public NativeArray<float> WaterMap;

	public NativeArray<float2> VelocityMap;

	public ReadOnly<float4> FluxMap;

	public int Res;

	public float DT;

	public float InvGridCellSquareSize;

	public void Execute(int index)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		int num = index % Res;
		int num2 = index / Res;
		ref float2 reference = ref BurstUtil.Get<float2>(ref VelocityMap, index);
		if (num == 0 || num2 == 0 || num == Res - 1 || num2 == Res - 1)
		{
			reference = float2.zero;
			return;
		}
		float4 val = FluxMap[index];
		float num3 = math.csum(val);
		int4x2 val2 = default(int4x2);
		((int4x2)(ref val2))..ctor(new int4(num - 1, num + 1, num, num), new int4(num2, num2, num2 + 1, num2 - 1));
		val2.c0 = val2.c1 * Res + val2.c0;
		float y = FluxMap[val2.c0.x].y;
		float x = FluxMap[val2.c0.y].x;
		float w = FluxMap[val2.c0.z].w;
		float z = FluxMap[val2.c0.w].z;
		float num4 = y + x + w + z;
		float num5 = DT * (num4 - num3);
		BurstUtil.Get<float>(ref WaterMap, index) += num5 * InvGridCellSquareSize;
		float2 val3 = default(float2);
		val3.x = y - val.x + val.y - x;
		val3.y = w - val.z + val.w - z;
		float2 val4 = val3;
		val4 *= 0.5f;
		reference += val4 * DT;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int ToIndex([AssumeRange(0L, 2147483647L)] int x, [AssumeRange(0L, 2147483647L)] int y, [AssumeRange(0L, 2147483647L)] int res)
	{
		return y * res + x;
	}
}


using Unity.Burst;
using Unity.Burst.CompilerServices;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct CalculateOutputFluxJob : IJobParallelFor
{
	public ReadOnly<float> TerrainHeightMapFloatVal;

	public ReadOnly<float> WaterMap;

	public NativeArray<float4> FluxMap;

	public int Res;

	public float DT;

	public float GridCellSquareSize;

	public float PipeLength;

	public float PipeArea;

	private const float Gravity = 10f;

	[SkipLocalsInit]
	public unsafe void Execute(int index)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		ref float4 reference = ref BurstUtil.Get<float4>(ref FluxMap, index);
		int num = index % Res;
		int num2 = index / Res;
		if (num == 0 || num2 == 0 || num == Res - 1 || num2 == Res - 1)
		{
			reference = float4.zero;
			return;
		}
		float num3 = TerrainHeightMapFloatVal[index];
		float num4 = WaterMap[index];
		float num5 = num3 + num4;
		int4x2 val = default(int4x2);
		((int4x2)(ref val))..ctor(new int4(num - 1, num + 1, num, num), new int4(num2, num2, num2 + 1, num2 - 1));
		int4 val2 = math.mad(val.c1, int4.op_Implicit(Res), val.c0);
		float4 val3 = default(float4);
		val3.x = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.x) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.x);
		val3.y = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.y) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.y);
		val3.z = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.z) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.z);
		val3.w = *(float*)BurstUtil.GetReadonly<float>(ref TerrainHeightMapFloatVal, val2.w) + *(float*)BurstUtil.GetReadonly<float>(ref WaterMap, val2.w);
		reference = math.max(float4.zero, reference + DT * PipeArea * (10f * (num5 - val3) / PipeLength));
		float num6 = math.min(1f, num4 * GridCellSquareSize / (math.csum(reference) * DT));
		reference *= num6;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct RefillOceanJob : IJobParallelFor
{
	public ReadOnly<int> OceanIndices;

	public ReadOnly<float> HeightMap;

	[WriteOnly]
	[NativeDisableParallelForRestriction]
	public NativeArray<float> WaterMap;

	public float OceanLevel;

	public void Execute(int index)
	{
		int num = OceanIndices[index];
		float num2 = HeightMap[num];
		WaterMap[num] = OceanLevel - num2;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct WaterIncrementationJob : IJobParallelFor
{
	public NativeArray<float> WaterMap;

	public float WaterFillRate;

	public float DT;

	public void Execute(int index)
	{
		ref NativeArray<float> waterMap = ref WaterMap;
		waterMap[index] += WaterFillRate * DT;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetCoarseDistsToShoreJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Dists;

	public ReadOnly<Vector3> Positions;

	public ReadOnly<int> Indices;

	[ReadOnly]
	public TerrainTexturing.ShoreVectorQueryStructure QueryStructure;

	public void Execute()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 pos = Positions[num];
			Dists[num] = QueryStructure.GetCoarseDistanceToShore(pos);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GenSamplePoints : IJob
{
	public int shoreMapSize;

	public float upscaleCoords;

	public Vector3 terrainPosition;

	[WriteOnly]
	public NativeArray<Vector3> positions;

	[WriteOnly]
	public NativeArray<int> indices;

	public void Execute()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		int i = 0;
		int num = 0;
		for (; i < shoreMapSize; i++)
		{
			float num2 = ((float)i + 0.5f) * upscaleCoords;
			int num3 = 0;
			while (num3 < shoreMapSize)
			{
				float num4 = ((float)num3 + 0.5f) * upscaleCoords;
				Vector3 val = new Vector3(terrainPosition.x, 0f, terrainPosition.z) + new Vector3(num4, 0f, num2);
				positions[num] = val;
				indices[num] = num;
				num3++;
				num++;
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GenShoreVecBitMapJob : IJobParallelFor
{
	public ReadOnly<float> waterHeights;

	public ReadOnly<float> terrainHeights;

	[WriteOnly]
	public NativeArray<byte> bitmap;

	public void Execute(int index)
	{
		bool flag = Mathf.Max(waterHeights[index] - terrainHeights[index], 0f) <= 0f;
		bitmap[index] = (byte)(flag ? 255u : 0u);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GenTopologyRadiiJob : IJobParallelFor
{
	public ReadOnly<float> heights;

	public NativeArray<float> radii;

	public void Execute(int index)
	{
		float num = heights[index];
		float num2 = Mathf.InverseLerp(4f, 0f, num);
		float num3 = Mathf.Lerp(8f, 16f, num2);
		radii[index] = num3;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct ProcessTopologyJob : IJobParallelFor
{
	public NativeArray<Vector4> vectors;

	public ReadOnly<int> topologies;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = vectors[index];
		int num = topologies[index];
		if ((num & 0x180) != 0)
		{
			val.w = 1f;
		}
		else if ((num & 0x32000) != 0)
		{
			val.w = 2f;
		}
		else if ((num & 0xC000) != 0)
		{
			val.w = 3f;
		}
		vectors[index] = val;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct FillAsOceanTopologyJob : IJobParallelFor
{
	public NativeArray<Vector4> vectors;

	public void Execute(int index)
	{
		BurstUtil.Get<Vector4>(ref vectors, index).w = 1f;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PopulateTextureDataJob : IJobParallelFor
{
	[WriteOnly]
	public NativeArray<half4> colors;

	public ReadOnly<Vector4> vectors;

	public ReadOnly<float> distances;

	public void Execute(int index)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		ref Vector4 @readonly = BurstUtil.GetReadonly<Vector4>(ref vectors, index);
		colors[index] = new half4(math.half(@readonly.x), math.half(@readonly.y), math.half(distances[index]), math.half(@readonly.w));
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByPosJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector3> Pos;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	[ReadOnly]
	public Vector2 DataOrigin;

	[ReadOnly]
	public Vector2 DataScale;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Pos.Length; i++)
		{
			float num2 = (Pos[i].x - DataOrigin.x) * DataScale.x;
			float num3 = (Pos[i].z - DataOrigin.y) * DataScale.y;
			float num4 = num2 * (float)num;
			float num5 = num3 * (float)num;
			int num6 = Mathf.Clamp((int)num4, 0, num);
			int num7 = Mathf.Clamp((int)num5, 0, num);
			int num8 = Mathf.Min(num6 + 1, num);
			int num9 = Mathf.Min(num7 + 1, num);
			float num10 = BitUtility.Short2Float((int)Data[num7 * Res + num6]);
			float num11 = BitUtility.Short2Float((int)Data[num7 * Res + num8]);
			float num12 = BitUtility.Short2Float((int)Data[num9 * Res + num6]);
			float num13 = BitUtility.Short2Float((int)Data[num9 * Res + num8]);
			float num14 = Mathf.Lerp(num10, num11, num4 - (float)num6);
			float num15 = Mathf.Lerp(num12, num13, num4 - (float)num6);
			Heights[i] = Offset + Mathf.Lerp(num14, num15, num5 - (float)num7) * Scale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByUVJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector2> UV;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < UV.Length; i++)
		{
			float num2 = UV[i].x * (float)num;
			float num3 = UV[i].y * (float)num;
			int num4 = Mathf.Clamp((int)num2, 0, num);
			int num5 = Mathf.Clamp((int)num3, 0, num);
			int num6 = Mathf.Min(num4 + 1, num);
			int num7 = Mathf.Min(num5 + 1, num);
			float num8 = BitUtility.Short2Float((int)Data[num5 * Res + num4]);
			float num9 = BitUtility.Short2Float((int)Data[num5 * Res + num6]);
			float num10 = BitUtility.Short2Float((int)Data[num7 * Res + num4]);
			float num11 = BitUtility.Short2Float((int)Data[num7 * Res + num6]);
			float num12 = Mathf.Lerp(num8, num9, num2 - (float)num4);
			float num13 = Mathf.Lerp(num10, num11, num2 - (float)num4);
			Heights[i] = Offset + Mathf.Lerp(num12, num13, num3 - (float)num5) * Scale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByUVJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector2> UV;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	public void Execute()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			float num3 = UV[num2].x * (float)num;
			float num4 = UV[num2].y * (float)num;
			int num5 = Mathf.Clamp((int)num3, 0, num);
			int num6 = Mathf.Clamp((int)num4, 0, num);
			int num7 = Mathf.Min(num5 + 1, num);
			int num8 = Mathf.Min(num6 + 1, num);
			float num9 = BitUtility.Short2Float((int)Data[num6 * Res + num5]);
			float num10 = BitUtility.Short2Float((int)Data[num6 * Res + num7]);
			float num11 = BitUtility.Short2Float((int)Data[num8 * Res + num5]);
			float num12 = BitUtility.Short2Float((int)Data[num8 * Res + num7]);
			float num13 = Mathf.Lerp(num9, num10, num3 - (float)num5);
			float num14 = Mathf.Lerp(num11, num12, num3 - (float)num5);
			Heights[num2] = Offset + Mathf.Lerp(num13, num14, num4 - (float)num6) * Scale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightByIndexJob : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public NativeArray<Vector2i> Indices;

	[ReadOnly]
	public NativeArray<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float Offset;

	[ReadOnly]
	public float Scale;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i].y * Res + Indices[i].x;
			Heights[i] = Offset + BitUtility.Short2Float((int)Data[num]) * Scale;
		}
	}
}


using Unity.Collections;

public static class TerrainTopologyMapJobUtil
{
	public static int GetTopologyRadius(ReadOnly<int> src, int res, float terrainOneOverSizeX, float radius, float normX, float normZ)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = terrainOneOverSizeX * radius;
		int x_mid = Index(normX, res);
		int z_mid = Index(normZ, res);
		int x_min = Index(normX - num, res);
		int x_max = Index(normX + num, res);
		int z_min = Index(normZ - num, res);
		int z_max = Index(normZ + num, res);
		return GetTopologyRadius(src, res, radius, x_min, x_mid, x_max, z_min, z_mid, z_max);
	}

	private static int Index(float normalized, int res)
	{
		int num = (int)(normalized * (float)res);
		if (num >= 0)
		{
			if (num <= res - 1)
			{
				return num;
			}
			return res - 1;
		}
		return 0;
	}

	internal static int GetTopologyRadius(ReadOnly<int> src, int res, float radius, int x_min, int x_mid, int x_max, int z_min, int z_mid, int z_max)
	{
		int num = 0;
		float num2 = radius * radius;
		for (int i = z_min; i <= z_max; i++)
		{
			int num3 = i - z_mid;
			int num4 = num3 * num3;
			for (int j = x_min; j <= x_max; j++)
			{
				int num5 = j - x_mid;
				if (!((float)(num5 * num5 + num4) > num2))
				{
					num |= src[i * res + j];
				}
			}
		}
		return num;
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetTopologyByPosJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public NativeArray<Vector3> Pos;

	[ReadOnly]
	public NativeArray<int> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public Vector2 DataOrigin;

	[ReadOnly]
	public Vector2 DataScale;

	public void Execute()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		int max = Res - 1;
		for (int i = 0; i < Pos.Length; i++)
		{
			float num = (Pos[i].x - DataOrigin.x) * DataScale.x;
			float num2 = (Pos[i].z - DataOrigin.y) * DataScale.y;
			int num3 = Math.Clamp((int)(num * (float)Res), 0, max);
			int num4 = Math.Clamp((int)(num2 * (float)Res), 0, max) * Res + num3;
			Topologies[i] = Data[num4];
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetTopologyByUVJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public NativeArray<Vector2> UV;

	[ReadOnly]
	public NativeArray<int> Data;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		int max = Res - 1;
		for (int i = 0; i < UV.Length; i++)
		{
			int num = Math.Clamp((int)(UV[i].x * (float)Res), 0, max);
			int num2 = Math.Clamp((int)(UV[i].y * (float)Res), 0, max) * Res + num;
			Topologies[i] = Data[num2];
		}
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GetTopologyRadiusJob : IJob
{
	public int Res;

	public ReadOnly<int> Src;

	public NativeReference<int> Topo;

	public int x_mid;

	public int z_mid;

	public int x_min;

	public int x_max;

	public int z_min;

	public int z_max;

	public float radius;

	public void Execute()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Topo.Value = TerrainTopologyMapJobUtil.GetTopologyRadius(Src, Res, radius, x_min, x_mid, x_max, z_min, z_mid, z_max);
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GetTopologyRadiusJobIndirect : IJobParallelFor
{
	public float WorldX;

	public float WorldZ;

	public float OneOverSizeX;

	public float OneOverSizeZ;

	public ReadOnly<int> Src;

	public int Res;

	public ReadOnly<Vector3> WorldPositions;

	public ReadOnly<float> Radii;

	[WriteOnly]
	public NativeArray<int> Topologies;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = WorldPositions[index];
		float normX = (val.x - WorldX) * OneOverSizeX;
		float normZ = (val.z - WorldZ) * OneOverSizeZ;
		Topologies[index] = TerrainTopologyMapJobUtil.GetTopologyRadius(Src, Res, OneOverSizeX, Radii[index], normX, normZ);
	}
}


using TerrainTopologyMapJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GetTopologyRadiusNormalizedJobIndirect : IJobParallelFor
{
	public float OneOverSizeX;

	public ReadOnly<int> Src;

	public int Res;

	public ReadOnly<Vector2> WorldNXZ;

	public ReadOnly<float> Radii;

	[WriteOnly]
	public NativeArray<int> Topologies;

	public void Execute(int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		float x = WorldNXZ[index].x;
		float y = WorldNXZ[index].y;
		Topologies[index] = TerrainTopologyMapJobUtil.GetTopologyRadius(Src, Res, OneOverSizeX, Radii[index], x, y);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct GetTopologyByIndexJob : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public NativeArray<Vector2i> Indices;

	[ReadOnly]
	public NativeArray<int> Data;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i].y * Res + Indices[i].x;
			Topologies[i] = Data[num];
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetTopologyByUVJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> Topologies;

	[ReadOnly]
	public ReadOnly<Vector2> UV;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<int> Data;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		int max = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			int num2 = Math.Clamp((int)(UV[num].x * (float)Res), 0, max);
			int num3 = Math.Clamp((int)(UV[num].y * (float)Res), 0, max) * Res + num2;
			Topologies[num] = Data[num3];
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightsFastJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector2> UVs;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<short> Data;

	[ReadOnly]
	public int Res;

	[ReadOnly]
	public float TerrainPos;

	[ReadOnly]
	public float TerrainScale;

	public void Execute()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			float num3 = UVs[num2].x * (float)num;
			float num4 = UVs[num2].y * (float)num;
			int num5 = (int)num3;
			int num6 = (int)num4;
			float num7 = num3 - (float)num5;
			float num8 = num4 - (float)num6;
			num5 = ((num5 >= 0) ? num5 : 0);
			num6 = ((num6 >= 0) ? num6 : 0);
			num5 = ((num5 <= num) ? num5 : num);
			num6 = ((num6 <= num) ? num6 : num);
			int num9 = ((num3 < (float)num) ? 1 : 0);
			int num10 = ((num4 < (float)num) ? Res : 0);
			int num11 = num6 * Res + num5;
			int num12 = num11 + num9;
			int num13 = num11 + num10;
			int num14 = num13 + num9;
			float num15 = BitUtility.Short2Float((int)Data[num11]);
			float num16 = BitUtility.Short2Float((int)Data[num12]);
			float num17 = BitUtility.Short2Float((int)Data[num13]);
			float num18 = BitUtility.Short2Float((int)Data[num14]);
			float num19 = (num16 - num15) * num7 + num15;
			float num20 = ((num18 - num17) * num7 + num17 - num19) * num8 + num19;
			Heights[num2] = TerrainPos + num20 * TerrainScale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightsJob : IJobParallelFor
{
	[WriteOnly]
	public NativeArray<float> Heights;

	public ReadOnly<Vector3> Pos;

	public Bounds DeepSeaBounds;

	public ReadOnly<short> Data;

	public ReadOnly<short> DeepSeaData;

	public Vector3 TerrainPos;

	public float TerrainScale;

	public Vector2 TerrainOneOverSize;

	public int Res;

	public void Execute(int index)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		Vector3 min = ((Bounds)(ref DeepSeaBounds)).min;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / ((Bounds)(ref DeepSeaBounds)).size.x, 1f / ((Bounds)(ref DeepSeaBounds)).size.z);
		bool num2 = ((Bounds)(ref DeepSeaBounds)).Contains(Pos[index]);
		Vector3 val2 = (num2 ? min : TerrainPos);
		Vector2 val3 = (num2 ? val : TerrainOneOverSize);
		ReadOnly<short> val4 = (num2 ? DeepSeaData : Data);
		float num3 = (Pos[index].x - val2.x) * val3.x;
		float num4 = (Pos[index].z - val2.z) * val3.y;
		float num5 = num3 * (float)num;
		float num6 = num4 * (float)num;
		int num7 = (int)num5;
		int num8 = (int)num6;
		float num9 = num5 - (float)num7;
		float num10 = num6 - (float)num8;
		num7 = ((num7 >= 0) ? num7 : 0);
		num8 = ((num8 >= 0) ? num8 : 0);
		num7 = ((num7 <= num) ? num7 : num);
		num8 = ((num8 <= num) ? num8 : num);
		int num11 = ((num5 < (float)num) ? 1 : 0);
		int num12 = ((num6 < (float)num) ? Res : 0);
		int num13 = num8 * Res + num7;
		int num14 = num13 + num11;
		int num15 = num13 + num12;
		int num16 = num15 + num11;
		float num17 = BitUtility.Short2Float((int)val4[num13]);
		float num18 = BitUtility.Short2Float((int)val4[num14]);
		float num19 = BitUtility.Short2Float((int)val4[num15]);
		float num20 = BitUtility.Short2Float((int)val4[num16]);
		float num21 = (num18 - num17) * num9 + num17;
		float num22 = ((num20 - num19) * num9 + num19 - num21) * num10 + num21;
		Heights[index] = TerrainPos.y + num22 * TerrainScale;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<short> Data;

	[ReadOnly]
	public Vector3 TerrainPos;

	[ReadOnly]
	public float TerrainScale;

	[ReadOnly]
	public Vector2 TerrainOneOverSize;

	[ReadOnly]
	public int Res;

	public void Execute()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num2 = Indices[i];
			float num3 = (Pos[num2].x - TerrainPos.x) * TerrainOneOverSize.x;
			float num4 = (Pos[num2].z - TerrainPos.z) * TerrainOneOverSize.y;
			float num5 = num3 * (float)num;
			float num6 = num4 * (float)num;
			int num7 = (int)num5;
			int num8 = (int)num6;
			float num9 = num5 - (float)num7;
			float num10 = num6 - (float)num8;
			num7 = ((num7 >= 0) ? num7 : 0);
			num8 = ((num8 >= 0) ? num8 : 0);
			num7 = ((num7 <= num) ? num7 : num);
			num8 = ((num8 <= num) ? num8 : num);
			int num11 = ((num5 < (float)num) ? 1 : 0);
			int num12 = ((num6 < (float)num) ? Res : 0);
			int num13 = num8 * Res + num7;
			int num14 = num13 + num11;
			int num15 = num13 + num12;
			int num16 = num15 + num11;
			float num17 = BitUtility.Short2Float((int)Data[num13]);
			float num18 = BitUtility.Short2Float((int)Data[num14]);
			float num19 = BitUtility.Short2Float((int)Data[num15]);
			float num20 = BitUtility.Short2Float((int)Data[num16]);
			float num21 = (num18 - num17) * num9 + num17;
			float num22 = ((num20 - num19) * num9 + num19 - num21) * num10 + num21;
			Heights[num2] = TerrainPos.y + num22 * TerrainScale;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckPosRadJob : IJob
{
	public NativeReference<bool> Result;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	public Vector3 CheckPos;

	public float CheckRad;

	public void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Result.Value = Grid.Check(CheckPos, CheckRad);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckPosRadBatchJob : IJob
{
	[WriteOnly]
	public NativeList<int> OverlapIndices;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> Radii;

	public void Execute()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Pos.Length; i++)
		{
			if (Grid.Check(Pos[i], Radii[i]))
			{
				OverlapIndices.AddNoResize(i);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckPosRadBatchJobIndirect : IJob
{
	[WriteOnly]
	public NativeList<int> OverlapIndices;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (Grid.Check(Pos[num], Radii[num]))
			{
				OverlapIndices.AddNoResize(num);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckBoundsJob : IJob
{
	public NativeReference<bool> Result;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	public Bounds CheckBounds;

	public void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Result.Value = Grid.Check(CheckBounds);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckBoundsJobIndirect : IJob
{
	[WriteOnly]
	public NativeList<int> OverlapIndices;

	[ReadOnly]
	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Bounds checkBounds = default(Bounds);
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Starts[num];
			Vector3 val2 = Ends[num];
			float num2 = Radii[num];
			Vector3 val3 = Vector3.one * num2;
			Vector3 val4 = Vector3.Min(val, val2) - val3;
			Vector3 val5 = Vector3.Max(val, val2) + val3;
			((Bounds)(ref checkBounds))..ctor((val5 + val4) * 0.5f, val5 - val4);
			if (Grid.Check(checkBounds))
			{
				OverlapIndices.AddNoResize(num);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckRayJob : IJob
{
	public NativeReference<bool> Result;

	[NativeDisableContainerSafetyRestriction]
	public CoarseQueryGrid Grid;

	public Vector3 Start;

	public Vector3 End;

	public float CheckRad;

	public void Execute()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Result.Value = Grid.Check(Start, End, CheckRad);
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;

public struct GridDefinition
{
	[NativeDisableContainerSafetyRestriction]
	public ReadOnly<NativeBitArray> OcclusionSubGridBlocked;

	public int3 ChunkCount;

	public int3 SubChunkCount;

	public bool IsValidGrid(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= ChunkCount.x || p.y >= ChunkCount.y || p.z >= ChunkCount.z)
		{
			return false;
		}
		return true;
	}

	public bool IsValidSubGrid(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= SubChunkCount.x || p.y >= SubChunkCount.y || p.z >= SubChunkCount.z)
		{
			return false;
		}
		return true;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCount.x * ChunkCount.y + y * ChunkCount.z + x;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool IsBlocked(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return IsBlocked(p.x, p.y, p.z);
	}

	private bool IsBlocked(int x, int y, int z)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int num = Math.DivRem(x, 8, out result);
		int result2;
		int num2 = Math.DivRem(y, 8, out result2);
		int result3;
		int num3 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(num, num2, num3);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(math.int3(num, num2, num3)) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num4 = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num4);
		}
		return false;
	}
}


using System.Runtime.InteropServices;
using ServerOcclusionJobs;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct Algorithm
{
	public static bool Trace(int3 from, int3 to, in GridDefinition gridDef, int blockedGridThreshold, int neighbourThreshold, bool useNeighbourThresholds)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int neighboursChecked = 0;
		int num2 = from.x;
		int num3 = from.y;
		int num4 = from.z;
		int x = to.x;
		int y = to.y;
		int z = to.z;
		int num5 = x - from.x;
		int num6 = y - from.y;
		int num7 = z - from.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int num14 = ((num5 >= 0) ? 1 : (-1));
		int num15 = ((num6 >= 0) ? 1 : (-1));
		int num16 = ((num7 >= 0) ? 1 : (-1));
		int3 nStep = -math.int3(num14, num15, num16);
		if (num8 >= num9 && num8 >= num10)
		{
			int num17 = num12 - num8;
			int num18 = num13 - num8;
			for (int i = 0; i < num8; i++)
			{
				if (!AddToGridArea(new int3(num2, num3, num4), in gridDef, nStep, ref neighboursChecked, useNeighbourThresholds, neighbourThreshold) && ++num > blockedGridThreshold)
				{
					return true;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num11;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num11;
				}
				num17 += num12;
				num18 += num13;
				num2 += num14;
			}
		}
		else if (num9 >= num8 && num9 >= num10)
		{
			int num17 = num11 - num9;
			int num18 = num13 - num9;
			for (int j = 0; j < num9; j++)
			{
				if (!AddToGridArea(new int3(num2, num3, num4), in gridDef, nStep, ref neighboursChecked, useNeighbourThresholds, neighbourThreshold) && ++num > blockedGridThreshold)
				{
					return true;
				}
				if (num17 > 0)
				{
					num2 += num14;
					num17 -= num12;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num12;
				}
				num17 += num11;
				num18 += num13;
				num3 += num15;
			}
		}
		else
		{
			int num17 = num12 - num10;
			int num18 = num11 - num10;
			for (int k = 0; k < num10; k++)
			{
				if (!AddToGridArea(new int3(num2, num3, num4), in gridDef, nStep, ref neighboursChecked, useNeighbourThresholds, neighbourThreshold) && ++num > blockedGridThreshold)
				{
					return true;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num13;
				}
				if (num18 > 0)
				{
					num2 += num14;
					num18 -= num13;
				}
				num17 += num12;
				num18 += num11;
				num4 += num16;
			}
		}
		return false;
	}

	public static bool Gather(int3 from, int3 to, in GridDefinition gridDef, int blockedGridThreshold, int neighbourThreshold, bool useNeighbourThresholds, NativeList<(int3, Color)> cells)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int neighboursChecked = 0;
		int num2 = from.x;
		int num3 = from.y;
		int num4 = from.z;
		int x = to.x;
		int y = to.y;
		int z = to.z;
		int num5 = x - from.x;
		int num6 = y - from.y;
		int num7 = z - from.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int num14 = ((num5 >= 0) ? 1 : (-1));
		int num15 = ((num6 >= 0) ? 1 : (-1));
		int num16 = ((num7 >= 0) ? 1 : (-1));
		int3 nStep = -math.int3(num14, num15, num16);
		if (num8 >= num9 && num8 >= num10)
		{
			int num17 = num12 - num8;
			int num18 = num13 - num8;
			int3 val = default(int3);
			for (int i = 0; i < num8; i++)
			{
				((int3)(ref val))..ctor(num2, num3, num4);
				if (!AddToGridArea(val, in gridDef, nStep, ref neighboursChecked, useNeighbourThresholds, neighbourThreshold, cells))
				{
					(int3, Color) tuple = (val, Color.red);
					cells.Add(ref tuple);
					if (++num > blockedGridThreshold)
					{
						return true;
					}
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num11;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num11;
				}
				num17 += num12;
				num18 += num13;
				num2 += num14;
			}
		}
		else if (num9 >= num8 && num9 >= num10)
		{
			int num17 = num11 - num9;
			int num18 = num13 - num9;
			int3 val2 = default(int3);
			for (int j = 0; j < num9; j++)
			{
				((int3)(ref val2))..ctor(num2, num3, num4);
				if (!AddToGridArea(val2, in gridDef, nStep, ref neighboursChecked, useNeighbourThresholds, neighbourThreshold, cells))
				{
					(int3, Color) tuple = (val2, Color.red);
					cells.Add(ref tuple);
					if (++num > blockedGridThreshold)
					{
						return true;
					}
				}
				if (num17 > 0)
				{
					num2 += num14;
					num17 -= num12;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num12;
				}
				num17 += num11;
				num18 += num13;
				num3 += num15;
			}
		}
		else
		{
			int num17 = num12 - num10;
			int num18 = num11 - num10;
			int3 val3 = default(int3);
			for (int k = 0; k < num10; k++)
			{
				((int3)(ref val3))..ctor(num2, num3, num4);
				if (!AddToGridArea(val3, in gridDef, nStep, ref neighboursChecked, useNeighbourThresholds, neighbourThreshold, cells))
				{
					(int3, Color) tuple = (val3, Color.red);
					cells.Add(ref tuple);
					if (++num > blockedGridThreshold)
					{
						return true;
					}
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num13;
				}
				if (num18 > 0)
				{
					num2 += num14;
					num18 -= num13;
				}
				num17 += num12;
				num18 += num11;
				num4 += num16;
			}
		}
		return false;
	}

	private static bool NeighbourBlockedOneAxis(in GridDefinition grid, int3 cell, int xDir, int yDir, int zDir)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0438: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		if (xDir != 0)
		{
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y, cell.z + 1), new int3(cell.x, cell.y, cell.z + 1), new int3(cell.x + xDir, cell.y, cell.z + 1)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y, cell.z - 1), new int3(cell.x, cell.y, cell.z - 1), new int3(cell.x + xDir, cell.y, cell.z - 1)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y + 1, cell.z), new int3(cell.x, cell.y + 1, cell.z), new int3(cell.x + xDir, cell.y + 1, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y - 1, cell.z), new int3(cell.x, cell.y - 1, cell.z), new int3(cell.x + xDir, cell.y - 1, cell.z)))
			{
				return false;
			}
		}
		else if (yDir != 0)
		{
			if (!AreBlocked(in grid, new int3(cell.x - 1, cell.y - yDir, cell.z), new int3(cell.x - 1, cell.y, cell.z), new int3(cell.x - 1, cell.y + yDir, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x + 1, cell.y - yDir, cell.z), new int3(cell.x + 1, cell.y, cell.z), new int3(cell.x + 1, cell.y + yDir, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y - yDir, cell.z - 1), new int3(cell.x, cell.y, cell.z - 1), new int3(cell.x, cell.y + yDir, cell.z - 1)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y - yDir, cell.z + 1), new int3(cell.x, cell.y, cell.z + 1), new int3(cell.x, cell.y + yDir, cell.z + 1)))
			{
				return false;
			}
		}
		else
		{
			if (!AreBlocked(in grid, new int3(cell.x - 1, cell.y, cell.z - zDir), new int3(cell.x - 1, cell.y, cell.z), new int3(cell.x - 1, cell.y, cell.z + zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x + 1, cell.y, cell.z - zDir), new int3(cell.x + 1, cell.y, cell.z), new int3(cell.x + 1, cell.y, cell.z + zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y - 1, cell.z - zDir), new int3(cell.x, cell.y - 1, cell.z), new int3(cell.x, cell.y - 1, cell.z + zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y + 1, cell.z - zDir), new int3(cell.x, cell.y + 1, cell.z), new int3(cell.x, cell.y + 1, cell.z + zDir)))
			{
				return false;
			}
		}
		return true;
	}

	private static bool NeighbourBlockedTwoAxis(in GridDefinition grid, int3 cell, int xDir, int yDir, int zDir)
	{
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_0450: Unknown result type (might be due to invalid IL or missing references)
		//IL_0459: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		if (xDir != 0 && zDir != 0)
		{
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y, cell.z), new int3(cell.x - xDir, cell.y, cell.z + zDir), new int3(cell.x, cell.y, cell.z + zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y + 1, cell.z - zDir), new int3(cell.x, cell.y + 1, cell.z), new int3(cell.x + xDir, cell.y + 1, cell.z + zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y, cell.z - zDir), new int3(cell.x + xDir, cell.y, cell.z - zDir), new int3(cell.x + xDir, cell.y, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y - 1, cell.z - zDir), new int3(cell.x, cell.y - 1, cell.z), new int3(cell.x + xDir, cell.y - 1, cell.z + zDir)))
			{
				return false;
			}
		}
		else if (xDir != 0 && yDir != 0)
		{
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y, cell.z), new int3(cell.x - xDir, cell.y + yDir, cell.z), new int3(cell.x, cell.y + yDir, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y - yDir, cell.z + 1), new int3(cell.x, cell.y, cell.z + 1), new int3(cell.x + xDir, cell.y + yDir, cell.z + 1)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y - yDir, cell.z), new int3(cell.x + xDir, cell.y - yDir, cell.z), new int3(cell.x + xDir, cell.y, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y - yDir, cell.z - 1), new int3(cell.x, cell.y, cell.z - 1), new int3(cell.x + xDir, cell.y + yDir, cell.z - 1)))
			{
				return false;
			}
		}
		else
		{
			if (!AreBlocked(in grid, new int3(cell.x, cell.y, cell.z - zDir), new int3(cell.x, cell.y + yDir, cell.z - zDir), new int3(cell.x, cell.y + yDir, cell.z)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x + 1, cell.y - yDir, cell.z - zDir), new int3(cell.x + 1, cell.y, cell.z), new int3(cell.x + 1, cell.y + yDir, cell.z - zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x, cell.y - yDir, cell.z), new int3(cell.x, cell.y - yDir, cell.z + zDir), new int3(cell.x, cell.y, cell.z + zDir)))
			{
				return false;
			}
			if (!AreBlocked(in grid, new int3(cell.x - 1, cell.y - yDir, cell.z - zDir), new int3(cell.x - 1, cell.y, cell.z), new int3(cell.x - 1, cell.y + yDir, cell.z - zDir)))
			{
				return false;
			}
		}
		return true;
	}

	private static bool NeighbourBlockedThreeAxis(in GridDefinition grid, int3 cell, int xDir, int yDir, int zDir)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y, cell.z), new int3(cell.x - xDir, cell.y, cell.z + zDir), new int3(cell.x, cell.y, cell.z + zDir)))
		{
			return false;
		}
		if (!AreBlocked(in grid, new int3(cell.x, cell.y, cell.z - zDir), new int3(cell.x + xDir, cell.y, cell.z - zDir), new int3(cell.x + xDir, cell.y, cell.z)))
		{
			return false;
		}
		if (!AreBlocked(in grid, new int3(cell.x - xDir, cell.y, cell.z - zDir), new int3(cell.x - xDir, cell.y + yDir, cell.z - zDir), new int3(cell.x, cell.y + yDir, cell.z)))
		{
			return false;
		}
		if (!AreBlocked(in grid, new int3(cell.x, cell.y - yDir, cell.z), new int3(cell.x + xDir, cell.y - yDir, cell.z + zDir), new int3(cell.x + xDir, cell.y, cell.z + zDir)))
		{
			return false;
		}
		return true;
	}

	private static bool AreBlocked(in GridDefinition grid, int3 p1, int3 p2, int3 p3)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (grid.IsValidSubGrid(p1) && grid.IsBlocked(p1))
		{
			return true;
		}
		if (grid.IsValidSubGrid(p2) && grid.IsBlocked(p2))
		{
			return true;
		}
		if (grid.IsValidSubGrid(p3) && grid.IsBlocked(p3))
		{
			return true;
		}
		return false;
	}

	private static bool AddNeighbours(int3 cell, in GridDefinition grid, int3 nStep)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		return (((nStep.x != 0) ? 1 : 0) + ((nStep.y != 0) ? 1 : 0) + ((nStep.z != 0) ? 1 : 0)) switch
		{
			1 => !NeighbourBlockedOneAxis(in grid, cell, -nStep.x, -nStep.y, -nStep.z), 
			2 => !NeighbourBlockedTwoAxis(in grid, cell, -nStep.x, -nStep.y, -nStep.z), 
			3 => !NeighbourBlockedThreeAxis(in grid, cell, -nStep.x, -nStep.y, -nStep.z), 
			_ => true, 
		};
	}

	private static bool AddToGridArea(int3 cell, in GridDefinition grid, int3 nStep, ref int neighboursChecked, bool useNeighbourThresholds, int neighbourThreshold)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!grid.IsBlocked(cell))
		{
			return true;
		}
		if (!useNeighbourThresholds || ++neighboursChecked <= neighbourThreshold)
		{
			return AddNeighbours(cell, in grid, nStep);
		}
		return false;
	}

	private static bool AddToGridArea(int3 cell, in GridDefinition grid, int3 nStep, ref int neighboursChecked, bool useNeighbourThresholds, int neighbourThreshold, NativeList<(int3, Color)> cells)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (!grid.IsBlocked(cell))
		{
			(int3, Color) tuple = (cell, Color.green);
			cells.Add(ref tuple);
			return true;
		}
		if ((!useNeighbourThresholds || ++neighboursChecked <= neighbourThreshold) && AddNeighbours(cell, in grid, nStep))
		{
			(int3, Color) tuple = (cell, Color.yellow);
			cells.Add(ref tuple);
			return true;
		}
		return false;
	}
}


using ServerOcclusionJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalculatePathBetweenGridsJob : IJob
{
	public ServerOcclusion.SubGrid From;

	public ServerOcclusion.SubGrid To;

	public NativeReference<bool> PathBlocked;

	public GridDefinition Grid;

	public int BlockedGridThreshold;

	public int NeighbourThreshold;

	public bool UseNeighbourThresholds;

	public void Execute()
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		int3 from = default(int3);
		((int3)(ref from))..ctor(From.x, From.y, From.z);
		int3 to = default(int3);
		((int3)(ref to))..ctor(To.x, To.y, To.z);
		PathBlocked.Value = Algorithm.Trace(from, to, in Grid, BlockedGridThreshold, NeighbourThreshold, UseNeighbourThresholds);
	}
}


using ServerOcclusionJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalculatePathsBetweenGridsJob : IJobParallelForBatch
{
	public ReadOnly<(ServerOcclusion.SubGrid from, ServerOcclusion.SubGrid to)> Paths;

	public NativeArray<bool> PathsBlocked;

	public GridDefinition Grid;

	public int BlockedGridThreshold;

	public int NeighbourThreshold;

	public bool UseNeighbourThresholds;

	public void Execute(int startIndex, int count)
	{
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		int3 from = default(int3);
		int3 to = default(int3);
		for (int i = startIndex; i < startIndex + count; i++)
		{
			var (subGrid, subGrid2) = Paths[i];
			((int3)(ref from))..ctor(subGrid.x, subGrid.y, subGrid.z);
			((int3)(ref to))..ctor(subGrid2.x, subGrid2.y, subGrid2.z);
			PathsBlocked[i] = Algorithm.Trace(from, to, in Grid, BlockedGridThreshold, NeighbourThreshold, UseNeighbourThresholds);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalculateSubGridSamplePointsJob : IJobFor
{
	[WriteOnly]
	[NativeDisableParallelForRestriction]
	public NativeArray<Vector3> Posi;

	[ReadOnly]
	public ReadOnly<ServerOcclusion.SubGrid> SubGridCells;

	[ReadOnly]
	public ReadOnly<Vector3> GridOffsets;

	[ReadOnly]
	public Vector3 CellOffset;

	public void Execute(int index)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		int length = GridOffsets.Length;
		ServerOcclusion.SubGrid subGrid = SubGridCells[index];
		Vector3 val = new Vector3((float)subGrid.x - CellOffset.x, (float)subGrid.y - CellOffset.y, (float)subGrid.z - CellOffset.z) * 2f;
		for (int i = 0; i < length; i++)
		{
			Posi[index * length + i] = val + GridOffsets[i];
		}
	}
}


public static class Client
{
	public const byte Default = 0;

	public const byte Tick = 1;
}


public static class Server
{
	public const byte Default = 0;

	public const byte Positions = 14;
}


using UnityEngine;

public static class ImageEffectHelper
{
	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			Debug.LogWarningFormat("Missing shader for image effect {0}", new object[1] { effect });
			return false;
		}
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2))
		{
			Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = (HideFlags)52
		};
	}
}


using UnityEngine;

public sealed class MinAttribute : PropertyAttribute
{
	public readonly float min;

	public MinAttribute(float min)
	{
		this.min = min;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class RenderTextureUtility
{
	private List<RenderTexture> m_TemporaryRTs = new List<RenderTexture>();

	public RenderTexture GetTemporaryRenderTexture(int width, int height, int depthBuffer = 0, RenderTextureFormat format = 2, FilterMode filterMode = 1)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture temporary = RenderTexture.GetTemporary(width, height, depthBuffer, format);
		((Texture)temporary).filterMode = filterMode;
		((Texture)temporary).wrapMode = (TextureWrapMode)1;
		((Object)temporary).name = "RenderTextureUtilityTempTexture";
		m_TemporaryRTs.Add(temporary);
		return temporary;
	}

	public void ReleaseTemporaryRenderTexture(RenderTexture rt)
	{
		if (!((Object)(object)rt == (Object)null))
		{
			if (!m_TemporaryRTs.Contains(rt))
			{
				Debug.LogErrorFormat("Attempting to remove texture that was not allocated: {0}", new object[1] { rt });
			}
			else
			{
				m_TemporaryRTs.Remove(rt);
				RenderTexture.ReleaseTemporary(rt);
			}
		}
	}

	public void ReleaseAllTemporaryRenderTextures()
	{
		for (int i = 0; i < m_TemporaryRTs.Count; i++)
		{
			RenderTexture.ReleaseTemporary(m_TemporaryRTs[i]);
		}
		m_TemporaryRTs.Clear();
	}
}


using System;
using UnityEngine;
using UnityStandardAssets.CinematicEffects;

[AddComponentMenu("Image Effects/Cinematic/Tonemapping and Color Grading")]
[ExecuteInEditMode]
[ImageEffectAllowedInSceneView]
public class TonemappingColorGrading : MonoBehaviour
{
	[AttributeUsage(AttributeTargets.Field)]
	public class SettingsGroup : Attribute
	{
	}

	public class IndentedGroup : PropertyAttribute
	{
	}

	public class ChannelMixer : PropertyAttribute
	{
	}

	public class ColorWheelGroup : PropertyAttribute
	{
		public int minSizePerWheel = 60;

		public int maxSizePerWheel = 150;

		public ColorWheelGroup()
		{
		}

		public ColorWheelGroup(int minSizePerWheel, int maxSizePerWheel)
		{
			this.minSizePerWheel = minSizePerWheel;
			this.maxSizePerWheel = maxSizePerWheel;
		}
	}

	public class Curve : PropertyAttribute
	{
		public Color color = Color.white;

		public Curve()
		{
		}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)


		public Curve(float r, float g, float b, float a)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			color = new Color(r, g, b, a);
		}
	}

	[Serializable]
	public struct EyeAdaptationSettings
	{
		public bool enabled;

		[Tooltip("Midpoint Adjustment.")]
		[Min(0f)]
		public float middleGrey;

		[Tooltip("The lowest possible exposure value; adjust this value to modify the brightest areas of your level.")]
		public float min;

		[Tooltip("The highest possible exposure value; adjust this value to modify the darkest areas of your level.")]
		public float max;

		[Tooltip("Speed of linear adaptation. Higher is faster.")]
		[Min(0f)]
		public float speed;

		[Tooltip("Displays a luminosity helper in the GameView.")]
		public bool showDebug;

		public static EyeAdaptationSettings defaultSettings
		{
			get
			{
				EyeAdaptationSettings result = default(EyeAdaptationSettings);
				result.enabled = false;
				result.showDebug = false;
				result.middleGrey = 0.5f;
				result.min = -3f;
				result.max = 3f;
				result.speed = 1.5f;
				return result;
			}
		}
	}

	public enum Tonemapper
	{
		ACES,
		Curve,
		Hable,
		HejlDawson,
		Photographic,
		Reinhard,
		Neutral
	}

	[Serializable]
	public struct TonemappingSettings
	{
		public bool enabled;

		[Tooltip("Tonemapping technique to use. ACES is the recommended one.")]
		public Tonemapper tonemapper;

		[Min(0f)]
		[Tooltip("Adjusts the overall exposure of the scene.")]
		public float exposure;

		[Tooltip("Custom tonemapping curve.")]
		public AnimationCurve curve;

		[Range(-0.1f, 0.1f)]
		public float neutralBlackIn;

		[Range(1f, 20f)]
		public float neutralWhiteIn;

		[Range(-0.09f, 0.1f)]
		public float neutralBlackOut;

		[Range(1f, 19f)]
		public float neutralWhiteOut;

		[Range(0.1f, 20f)]
		public float neutralWhiteLevel;

		[Range(1f, 10f)]
		public float neutralWhiteClip;

		public static TonemappingSettings defaultSettings
		{
			get
			{
				TonemappingSettings result = default(TonemappingSettings);
				result.enabled = false;
				result.tonemapper = Tonemapper.Neutral;
				result.exposure = 1f;
				result.curve = CurvesSettings.defaultCurve;
				result.neutralBlackIn = 0.02f;
				result.neutralWhiteIn = 10f;
				result.neutralBlackOut = 0f;
				result.neutralWhiteOut = 10f;
				result.neutralWhiteLevel = 5.3f;
				result.neutralWhiteClip = 10f;
				return result;
			}
		}
	}

	[Serializable]
	public struct LUTSettings
	{
		public bool enabled;

		[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
		public Texture texture;

		[Tooltip("Blending factor.")]
		[Range(0f, 1f)]
		public float contribution;

		public static LUTSettings defaultSettings
		{
			get
			{
				LUTSettings result = default(LUTSettings);
				result.enabled = false;
				result.texture = null;
				result.contribution = 1f;
				return result;
			}
		}
	}

	[Serializable]
	public struct ColorWheelsSettings
	{
		[ColorUsage(false)]
		public Color shadows;

		[ColorUsage(false)]
		public Color midtones;

		[ColorUsage(false)]
		public Color highlights;

		public static ColorWheelsSettings defaultSettings
		{
			get
			{
				//IL_000a: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				ColorWheelsSettings result = default(ColorWheelsSettings);
				result.shadows = Color.white;
				result.midtones = Color.white;
				result.highlights = Color.white;
				return result;
			}
		}
	}

	[Serializable]
	public struct BasicsSettings
	{
		[Range(-2f, 2f)]
		[Tooltip("Sets the white balance to a custom color temperature.")]
		public float temperatureShift;

		[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
		[Range(-2f, 2f)]
		public float tint;

		[Space]
		[Range(-0.5f, 0.5f)]
		[Tooltip("Shift the hue of all colors.")]
		public float hue;

		[Range(0f, 2f)]
		[Tooltip("Pushes the intensity of all colors.")]
		public float saturation;

		[Range(-1f, 1f)]
		[Tooltip("Adjusts the saturation so that clipping is minimized as colors approach full saturation.")]
		public float vibrance;

		[Range(0f, 10f)]
		[Tooltip("Brightens or darkens all colors.")]
		public float value;

		[Tooltip("Expands or shrinks the overall range of tonal values.")]
		[Range(0f, 2f)]
		[Space]
		public float contrast;

		[Tooltip("Contrast gain curve. Controls the steepness of the curve.")]
		[Range(0.01f, 5f)]
		public float gain;

		[Tooltip("Applies a pow function to the source.")]
		[Range(0.01f, 5f)]
		public float gamma;

		public static BasicsSettings defaultSettings
		{
			get
			{
				BasicsSettings result = default(BasicsSettings);
				result.temperatureShift = 0f;
				result.tint = 0f;
				result.contrast = 1f;
				result.hue = 0f;
				result.saturation = 1f;
				result.value = 1f;
				result.vibrance = 0f;
				result.gain = 1f;
				result.gamma = 1f;
				return result;
			}
		}
	}

	[Serializable]
	public struct ChannelMixerSettings
	{
		public int currentChannel;

		public Vector3[] channels;

		public static ChannelMixerSettings defaultSettings
		{
			get
			{
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				//IL_005f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0064: Unknown result type (might be due to invalid IL or missing references)
				ChannelMixerSettings result = default(ChannelMixerSettings);
				result.currentChannel = 0;
				result.channels = (Vector3[])(object)new Vector3[3]
				{
					new Vector3(1f, 0f, 0f),
					new Vector3(0f, 1f, 0f),
					new Vector3(0f, 0f, 1f)
				};
				return result;
			}
		}
	}

	[Serializable]
	public struct CurvesSettings
	{
		[Curve]
		public AnimationCurve master;

		[Curve(1f, 0f, 0f, 1f)]
		public AnimationCurve red;

		[Curve(0f, 1f, 0f, 1f)]
		public AnimationCurve green;

		[Curve(0f, 1f, 1f, 1f)]
		public AnimationCurve blue;

		public static CurvesSettings defaultSettings
		{
			get
			{
				CurvesSettings result = default(CurvesSettings);
				result.master = defaultCurve;
				result.red = defaultCurve;
				result.green = defaultCurve;
				result.blue = defaultCurve;
				return result;
			}
		}

		public static AnimationCurve defaultCurve => new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f, 1f, 1f),
			new Keyframe(1f, 1f, 1f, 1f)
		});
	}

	public enum ColorGradingPrecision
	{
		Normal = 0x10,
		High = 0x20
	}

	[Serializable]
	public struct ColorGradingSettings
	{
		public bool enabled;

		[Tooltip("Internal LUT precision. \"Normal\" is 256x16, \"High\" is 1024x32. Prefer \"Normal\" on mobile devices.")]
		public ColorGradingPrecision precision;

		[ColorWheelGroup]
		[Space]
		public ColorWheelsSettings colorWheels;

		[Space]
		[IndentedGroup]
		public BasicsSettings basics;

		[ChannelMixer]
		[Space]
		public ChannelMixerSettings channelMixer;

		[Space]
		[IndentedGroup]
		public CurvesSettings curves;

		[Space]
		[Tooltip("Use dithering to try and minimize color banding in dark areas.")]
		public bool useDithering;

		[Tooltip("Displays the generated LUT in the top left corner of the GameView.")]
		public bool showDebug;

		public static ColorGradingSettings defaultSettings
		{
			get
			{
				ColorGradingSettings result = default(ColorGradingSettings);
				result.enabled = false;
				result.useDithering = false;
				result.showDebug = false;
				result.precision = ColorGradingPrecision.Normal;
				result.colorWheels = ColorWheelsSettings.defaultSettings;
				result.basics = BasicsSettings.defaultSettings;
				result.channelMixer = ChannelMixerSettings.defaultSettings;
				result.curves = CurvesSettings.defaultSettings;
				return result;
			}
		}

		internal void Reset()
		{
			curves = CurvesSettings.defaultSettings;
		}
	}

	[SettingsGroup]
	[SerializeField]
	private EyeAdaptationSettings m_EyeAdaptation = EyeAdaptationSettings.defaultSettings;

	[SerializeField]
	[SettingsGroup]
	private TonemappingSettings m_Tonemapping = TonemappingSettings.defaultSettings;

	[SettingsGroup]
	[SerializeField]
	private ColorGradingSettings m_ColorGrading = ColorGradingSettings.defaultSettings;

	[SettingsGroup]
	[SerializeField]
	private LUTSettings m_Lut = LUTSettings.defaultSettings;

	[SerializeField]
	private Shader m_Shader;
}


using System;

[AttributeUsage(AttributeTargets.Field)]
public class SettingsGroup : Attribute
{
}


using UnityEngine;

public class IndentedGroup : PropertyAttribute
{
}


using UnityEngine;

public class ChannelMixer : PropertyAttribute
{
}


using UnityEngine;

public class ColorWheelGroup : PropertyAttribute
{
	public int minSizePerWheel = 60;

	public int maxSizePerWheel = 150;

	public ColorWheelGroup()
	{
	}

	public ColorWheelGroup(int minSizePerWheel, int maxSizePerWheel)
	{
		this.minSizePerWheel = minSizePerWheel;
		this.maxSizePerWheel = maxSizePerWheel;
	}
}


using UnityEngine;

public class Curve : PropertyAttribute
{
	public Color color = Color.white;

	public Curve()
	{
	}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
	//IL_0006: Unknown result type (might be due to invalid IL or missing references)


	public Curve(float r, float g, float b, float a)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		color = new Color(r, g, b, a);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct EyeAdaptationSettings
{
	public bool enabled;

	[Tooltip("Midpoint Adjustment.")]
	[Min(0f)]
	public float middleGrey;

	[Tooltip("The lowest possible exposure value; adjust this value to modify the brightest areas of your level.")]
	public float min;

	[Tooltip("The highest possible exposure value; adjust this value to modify the darkest areas of your level.")]
	public float max;

	[Tooltip("Speed of linear adaptation. Higher is faster.")]
	[Min(0f)]
	public float speed;

	[Tooltip("Displays a luminosity helper in the GameView.")]
	public bool showDebug;

	public static EyeAdaptationSettings defaultSettings
	{
		get
		{
			EyeAdaptationSettings result = default(EyeAdaptationSettings);
			result.enabled = false;
			result.showDebug = false;
			result.middleGrey = 0.5f;
			result.min = -3f;
			result.max = 3f;
			result.speed = 1.5f;
			return result;
		}
	}
}


public enum Tonemapper
{
	ACES,
	Curve,
	Hable,
	HejlDawson,
	Photographic,
	Reinhard,
	Neutral
}


using System;
using UnityEngine;

[Serializable]
public struct TonemappingSettings
{
	public bool enabled;

	[Tooltip("Tonemapping technique to use. ACES is the recommended one.")]
	public Tonemapper tonemapper;

	[Min(0f)]
	[Tooltip("Adjusts the overall exposure of the scene.")]
	public float exposure;

	[Tooltip("Custom tonemapping curve.")]
	public AnimationCurve curve;

	[Range(-0.1f, 0.1f)]
	public float neutralBlackIn;

	[Range(1f, 20f)]
	public float neutralWhiteIn;

	[Range(-0.09f, 0.1f)]
	public float neutralBlackOut;

	[Range(1f, 19f)]
	public float neutralWhiteOut;

	[Range(0.1f, 20f)]
	public float neutralWhiteLevel;

	[Range(1f, 10f)]
	public float neutralWhiteClip;

	public static TonemappingSettings defaultSettings
	{
		get
		{
			TonemappingSettings result = default(TonemappingSettings);
			result.enabled = false;
			result.tonemapper = Tonemapper.Neutral;
			result.exposure = 1f;
			result.curve = CurvesSettings.defaultCurve;
			result.neutralBlackIn = 0.02f;
			result.neutralWhiteIn = 10f;
			result.neutralBlackOut = 0f;
			result.neutralWhiteOut = 10f;
			result.neutralWhiteLevel = 5.3f;
			result.neutralWhiteClip = 10f;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct LUTSettings
{
	public bool enabled;

	[Tooltip("Custom lookup texture (strip format, e.g. 256x16).")]
	public Texture texture;

	[Tooltip("Blending factor.")]
	[Range(0f, 1f)]
	public float contribution;

	public static LUTSettings defaultSettings
	{
		get
		{
			LUTSettings result = default(LUTSettings);
			result.enabled = false;
			result.texture = null;
			result.contribution = 1f;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ColorWheelsSettings
{
	[ColorUsage(false)]
	public Color shadows;

	[ColorUsage(false)]
	public Color midtones;

	[ColorUsage(false)]
	public Color highlights;

	public static ColorWheelsSettings defaultSettings
	{
		get
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			ColorWheelsSettings result = default(ColorWheelsSettings);
			result.shadows = Color.white;
			result.midtones = Color.white;
			result.highlights = Color.white;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct BasicsSettings
{
	[Range(-2f, 2f)]
	[Tooltip("Sets the white balance to a custom color temperature.")]
	public float temperatureShift;

	[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
	[Range(-2f, 2f)]
	public float tint;

	[Space]
	[Range(-0.5f, 0.5f)]
	[Tooltip("Shift the hue of all colors.")]
	public float hue;

	[Range(0f, 2f)]
	[Tooltip("Pushes the intensity of all colors.")]
	public float saturation;

	[Range(-1f, 1f)]
	[Tooltip("Adjusts the saturation so that clipping is minimized as colors approach full saturation.")]
	public float vibrance;

	[Range(0f, 10f)]
	[Tooltip("Brightens or darkens all colors.")]
	public float value;

	[Tooltip("Expands or shrinks the overall range of tonal values.")]
	[Range(0f, 2f)]
	[Space]
	public float contrast;

	[Tooltip("Contrast gain curve. Controls the steepness of the curve.")]
	[Range(0.01f, 5f)]
	public float gain;

	[Tooltip("Applies a pow function to the source.")]
	[Range(0.01f, 5f)]
	public float gamma;

	public static BasicsSettings defaultSettings
	{
		get
		{
			BasicsSettings result = default(BasicsSettings);
			result.temperatureShift = 0f;
			result.tint = 0f;
			result.contrast = 1f;
			result.hue = 0f;
			result.saturation = 1f;
			result.value = 1f;
			result.vibrance = 0f;
			result.gain = 1f;
			result.gamma = 1f;
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ChannelMixerSettings
{
	public int currentChannel;

	public Vector3[] channels;

	public static ChannelMixerSettings defaultSettings
	{
		get
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			ChannelMixerSettings result = default(ChannelMixerSettings);
			result.currentChannel = 0;
			result.channels = (Vector3[])(object)new Vector3[3]
			{
				new Vector3(1f, 0f, 0f),
				new Vector3(0f, 1f, 0f),
				new Vector3(0f, 0f, 1f)
			};
			return result;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct CurvesSettings
{
	[Curve]
	public AnimationCurve master;

	[Curve(1f, 0f, 0f, 1f)]
	public AnimationCurve red;

	[Curve(0f, 1f, 0f, 1f)]
	public AnimationCurve green;

	[Curve(0f, 1f, 1f, 1f)]
	public AnimationCurve blue;

	public static CurvesSettings defaultSettings
	{
		get
		{
			CurvesSettings result = default(CurvesSettings);
			result.master = defaultCurve;
			result.red = defaultCurve;
			result.green = defaultCurve;
			result.blue = defaultCurve;
			return result;
		}
	}

	public static AnimationCurve defaultCurve => new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f, 1f, 1f),
		new Keyframe(1f, 1f, 1f, 1f)
	});
}


public enum ColorGradingPrecision
{
	Normal = 0x10,
	High = 0x20
}


using System;
using UnityEngine;

[Serializable]
public struct ColorGradingSettings
{
	public bool enabled;

	[Tooltip("Internal LUT precision. \"Normal\" is 256x16, \"High\" is 1024x32. Prefer \"Normal\" on mobile devices.")]
	public ColorGradingPrecision precision;

	[ColorWheelGroup]
	[Space]
	public ColorWheelsSettings colorWheels;

	[Space]
	[IndentedGroup]
	public BasicsSettings basics;

	[ChannelMixer]
	[Space]
	public ChannelMixerSettings channelMixer;

	[Space]
	[IndentedGroup]
	public CurvesSettings curves;

	[Space]
	[Tooltip("Use dithering to try and minimize color banding in dark areas.")]
	public bool useDithering;

	[Tooltip("Displays the generated LUT in the top left corner of the GameView.")]
	public bool showDebug;

	public static ColorGradingSettings defaultSettings
	{
		get
		{
			ColorGradingSettings result = default(ColorGradingSettings);
			result.enabled = false;
			result.useDithering = false;
			result.showDebug = false;
			result.precision = ColorGradingPrecision.Normal;
			result.colorWheels = ColorWheelsSettings.defaultSettings;
			result.basics = BasicsSettings.defaultSettings;
			result.channelMixer = ChannelMixerSettings.defaultSettings;
			result.curves = CurvesSettings.defaultSettings;
			return result;
		}
	}

	internal void Reset()
	{
		curves = CurvesSettings.defaultSettings;
	}
}


using UnityEngine;
using UnityStandardAssets.ImageEffects;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Other/Scope Overlay")]
public class ScopeEffect : PostEffectsBase, IImageEffect
{
	public Material overlayMaterial;

	public override bool CheckResources()
	{
		return true;
	}

	public bool IsActive()
	{
		if (((Behaviour)this).enabled)
		{
			return ((PostEffectsBase)this).CheckResources();
		}
		return false;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		overlayMaterial.SetVector("_Screen", Vector4.op_Implicit(new Vector2((float)Screen.width, (float)Screen.height)));
		Graphics.Blit((Texture)(object)source, destination, overlayMaterial);
	}
}


using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using WaterLevelJobs;

[BurstCompile]
public static class WaterLevelBurst
{
	internal delegate void GetBuoyancyWaterInfoBatched_00007733$PostfixBurstDelegate(in NativeArray<Vector3> allPositions, in NativeArray<Vector2> allUVPositions, in NativeArray<float> pointTerrainHeightNativeArray, in NativeArray<float> pointWaterHeightNativeArray, in NativeArray<bool> doDeepWaterChecksStateNativeArray, ref NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<int> instancePointCountNativeArray, in int instanceCount, in TerrainTopologyMap.TopologyQueryStructure topologyMap, in NativeArray<bool> waterIgnoreStates, ref NativeArray<bool> needsDeepWaterChecks, bool isDeepSea, out bool hasAnyDeepWaterChecks);

	internal static class GetBuoyancyWaterInfoBatched_00007733$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(GetBuoyancyWaterInfoBatched_00007733$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static GetBuoyancyWaterInfoBatched_00007733$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in NativeArray<Vector3> allPositions, in NativeArray<Vector2> allUVPositions, in NativeArray<float> pointTerrainHeightNativeArray, in NativeArray<float> pointWaterHeightNativeArray, in NativeArray<bool> doDeepWaterChecksStateNativeArray, ref NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<int> instancePointCountNativeArray, in int instanceCount, in TerrainTopologyMap.TopologyQueryStructure topologyMap, in NativeArray<bool> waterIgnoreStates, ref NativeArray<bool> needsDeepWaterChecks, bool isDeepSea, out bool hasAnyDeepWaterChecks)
		{
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref NativeArray<Vector3>, ref NativeArray<Vector2>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<bool>, ref NativeArray<WaterLevel.WaterInfo>, ref NativeArray<int>, ref int, ref TerrainTopologyMap.TopologyQueryStructure, ref NativeArray<bool>, ref NativeArray<bool>, bool, ref bool, void>)functionPointer)(ref allPositions, ref allUVPositions, ref pointTerrainHeightNativeArray, ref pointWaterHeightNativeArray, ref doDeepWaterChecksStateNativeArray, ref pointWaterInfoNativeArray, ref instancePointCountNativeArray, ref instanceCount, ref topologyMap, ref waterIgnoreStates, ref needsDeepWaterChecks, isDeepSea, ref hasAnyDeepWaterChecks);
					return;
				}
			}
			GetBuoyancyWaterInfoBatched$BurstManaged(in allPositions, in allUVPositions, in pointTerrainHeightNativeArray, in pointWaterHeightNativeArray, in doDeepWaterChecksStateNativeArray, ref pointWaterInfoNativeArray, in instancePointCountNativeArray, in instanceCount, in topologyMap, in waterIgnoreStates, ref needsDeepWaterChecks, isDeepSea, out hasAnyDeepWaterChecks);
		}
	}

	internal delegate void ConstructDeepWaterCommands_00007734$PostfixBurstDelegate(in NativeArray<Vector3> allPositions, in NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<bool> needsDeepWaterChecks, out NativeList<RaycastCommand> deepWaterCasts, out NativeList<int> raycastPointIndices, Allocator allocator);

	internal static class ConstructDeepWaterCommands_00007734$BurstDirectCall
	{
		private static IntPtr Pointer;

		private static IntPtr DeferredCompilation;

		[BurstDiscard]
		private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
		{
			if (Pointer == (IntPtr)0)
			{
				Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(ConstructDeepWaterCommands_00007734$PostfixBurstDelegate).TypeHandle);
			}
			P_0 = Pointer;
		}

		private static IntPtr GetFunctionPointer()
		{
			nint result = 0;
			GetFunctionPointerDiscard(ref result);
			return result;
		}

		public static void Constructor()
		{
			DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
		}

		public static void Initialize()
		{
		}

		static ConstructDeepWaterCommands_00007734$BurstDirectCall()
		{
			Constructor();
		}

		public unsafe static void Invoke(in NativeArray<Vector3> allPositions, in NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<bool> needsDeepWaterChecks, out NativeList<RaycastCommand> deepWaterCasts, out NativeList<int> raycastPointIndices, Allocator allocator)
		{
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (BurstCompiler.IsEnabled)
			{
				IntPtr functionPointer = GetFunctionPointer();
				if (functionPointer != (IntPtr)0)
				{
					((delegate* unmanaged[Cdecl]<ref NativeArray<Vector3>, ref NativeArray<WaterLevel.WaterInfo>, ref NativeArray<bool>, ref NativeList<RaycastCommand>, ref NativeList<int>, Allocator, void>)functionPointer)(ref allPositions, ref pointWaterInfoNativeArray, ref needsDeepWaterChecks, ref deepWaterCasts, ref raycastPointIndices, allocator);
					return;
				}
			}
			ConstructDeepWaterCommands$BurstManaged(in allPositions, in pointWaterInfoNativeArray, in needsDeepWaterChecks, out deepWaterCasts, out raycastPointIndices, allocator);
		}
	}

	[BurstCompile]
	public static void GetBuoyancyWaterInfoBatched(in NativeArray<Vector3> allPositions, in NativeArray<Vector2> allUVPositions, in NativeArray<float> pointTerrainHeightNativeArray, in NativeArray<float> pointWaterHeightNativeArray, in NativeArray<bool> doDeepWaterChecksStateNativeArray, ref NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<int> instancePointCountNativeArray, in int instanceCount, in TerrainTopologyMap.TopologyQueryStructure topologyMap, in NativeArray<bool> waterIgnoreStates, ref NativeArray<bool> needsDeepWaterChecks, bool isDeepSea, out bool hasAnyDeepWaterChecks)
	{
		GetBuoyancyWaterInfoBatched_00007733$BurstDirectCall.Invoke(in allPositions, in allUVPositions, in pointTerrainHeightNativeArray, in pointWaterHeightNativeArray, in doDeepWaterChecksStateNativeArray, ref pointWaterInfoNativeArray, in instancePointCountNativeArray, in instanceCount, in topologyMap, in waterIgnoreStates, ref needsDeepWaterChecks, isDeepSea, out hasAnyDeepWaterChecks);
	}

	[BurstCompile]
	public static void ConstructDeepWaterCommands(in NativeArray<Vector3> allPositions, in NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<bool> needsDeepWaterChecks, out NativeList<RaycastCommand> deepWaterCasts, out NativeList<int> raycastPointIndices, Allocator allocator)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		ConstructDeepWaterCommands_00007734$BurstDirectCall.Invoke(in allPositions, in pointWaterInfoNativeArray, in needsDeepWaterChecks, out deepWaterCasts, out raycastPointIndices, allocator);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void GetBuoyancyWaterInfoBatched$BurstManaged(in NativeArray<Vector3> allPositions, in NativeArray<Vector2> allUVPositions, in NativeArray<float> pointTerrainHeightNativeArray, in NativeArray<float> pointWaterHeightNativeArray, in NativeArray<bool> doDeepWaterChecksStateNativeArray, ref NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<int> instancePointCountNativeArray, in int instanceCount, in TerrainTopologyMap.TopologyQueryStructure topologyMap, in NativeArray<bool> waterIgnoreStates, ref NativeArray<bool> needsDeepWaterChecks, bool isDeepSea, out bool hasAnyDeepWaterChecks)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		hasAnyDeepWaterChecks = false;
		int num = 0;
		for (int i = 0; i < instanceCount; i++)
		{
			bool flag = doDeepWaterChecksStateNativeArray[i];
			float num2 = pointTerrainHeightNativeArray[i];
			int num3 = instancePointCountNativeArray[i];
			int num4 = num + num3;
			for (int j = num; j < num4; j++)
			{
				Vector3 position = allPositions[j];
				Vector2 uv = allUVPositions[j];
				float num5 = pointWaterHeightNativeArray[j];
				WaterLevel.WaterInfo waterInfo = default(WaterLevel.WaterInfo);
				if (position.y > num5 && WaterVolumeBurst.TestBurst(in position, out var info))
				{
					pointWaterInfoNativeArray[j] = info;
					continue;
				}
				bool flag2 = position.y < num2 - 1f;
				if (flag2 && WaterVolumeBurst.TestBurst(in position, out var info2))
				{
					pointWaterInfoNativeArray[j] = info2;
					continue;
				}
				bool flag3 = flag && (position.y < num5 - 10f || (TerrainMeta.OutOfBoundsBurst(position) && !isDeepSea));
				int topologyFast = topologyMap.GetTopologyFast(uv);
				if ((flag2 || flag3 || (topologyFast & 0x3C180) == 0) && waterIgnoreStates[j])
				{
					pointWaterInfoNativeArray[j] = waterInfo;
					continue;
				}
				if (flag3)
				{
					needsDeepWaterChecks[j] = true;
					hasAnyDeepWaterChecks = true;
				}
				waterInfo.isValid = true;
				waterInfo.currentDepth = Mathf.Max(0f, num5 - position.y);
				waterInfo.overallDepth = Mathf.Max(0f, num5 - num2);
				waterInfo.surfaceLevel = num5;
				waterInfo.terrainHeight = num2;
				waterInfo.topology = topologyFast;
				pointWaterInfoNativeArray[j] = waterInfo;
			}
			num += num3;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	[BurstCompile]
	internal static void ConstructDeepWaterCommands$BurstManaged(in NativeArray<Vector3> allPositions, in NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<bool> needsDeepWaterChecks, out NativeList<RaycastCommand> deepWaterCasts, out NativeList<int> raycastPointIndices, Allocator allocator)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		deepWaterCasts = new NativeList<RaycastCommand>(32, AllocatorHandle.op_Implicit(allocator));
		raycastPointIndices = new NativeList<int>(32, AllocatorHandle.op_Implicit((Allocator)2));
		QueryParameters val = default(QueryParameters);
		val.hitTriggers = (QueryTriggerInteraction)2;
		val.layerMask = 16;
		QueryParameters val2 = val;
		RaycastCommand val4 = default(RaycastCommand);
		for (int i = 0; i < needsDeepWaterChecks.Length; i++)
		{
			if (needsDeepWaterChecks[i])
			{
				Vector3 val3 = allPositions[i];
				((RaycastCommand)(ref val4))..ctor(val3, Vector3.up, val2, float.MaxValue);
				deepWaterCasts.Add(ref val4);
				raycastPointIndices.Add(ref i);
			}
		}
	}
}


using Unity.Collections;
using UnityEngine;

internal delegate void GetBuoyancyWaterInfoBatched_00007733$PostfixBurstDelegate(in NativeArray<Vector3> allPositions, in NativeArray<Vector2> allUVPositions, in NativeArray<float> pointTerrainHeightNativeArray, in NativeArray<float> pointWaterHeightNativeArray, in NativeArray<bool> doDeepWaterChecksStateNativeArray, ref NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<int> instancePointCountNativeArray, in int instanceCount, in TerrainTopologyMap.TopologyQueryStructure topologyMap, in NativeArray<bool> waterIgnoreStates, ref NativeArray<bool> needsDeepWaterChecks, bool isDeepSea, out bool hasAnyDeepWaterChecks);


using System;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

internal static class GetBuoyancyWaterInfoBatched_00007733$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(GetBuoyancyWaterInfoBatched_00007733$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static GetBuoyancyWaterInfoBatched_00007733$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in NativeArray<Vector3> allPositions, in NativeArray<Vector2> allUVPositions, in NativeArray<float> pointTerrainHeightNativeArray, in NativeArray<float> pointWaterHeightNativeArray, in NativeArray<bool> doDeepWaterChecksStateNativeArray, ref NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<int> instancePointCountNativeArray, in int instanceCount, in TerrainTopologyMap.TopologyQueryStructure topologyMap, in NativeArray<bool> waterIgnoreStates, ref NativeArray<bool> needsDeepWaterChecks, bool isDeepSea, out bool hasAnyDeepWaterChecks)
	{
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref NativeArray<Vector3>, ref NativeArray<Vector2>, ref NativeArray<float>, ref NativeArray<float>, ref NativeArray<bool>, ref NativeArray<WaterLevel.WaterInfo>, ref NativeArray<int>, ref int, ref TerrainTopologyMap.TopologyQueryStructure, ref NativeArray<bool>, ref NativeArray<bool>, bool, ref bool, void>)functionPointer)(ref allPositions, ref allUVPositions, ref pointTerrainHeightNativeArray, ref pointWaterHeightNativeArray, ref doDeepWaterChecksStateNativeArray, ref pointWaterInfoNativeArray, ref instancePointCountNativeArray, ref instanceCount, ref topologyMap, ref waterIgnoreStates, ref needsDeepWaterChecks, isDeepSea, ref hasAnyDeepWaterChecks);
				return;
			}
		}
		GetBuoyancyWaterInfoBatched$BurstManaged(in allPositions, in allUVPositions, in pointTerrainHeightNativeArray, in pointWaterHeightNativeArray, in doDeepWaterChecksStateNativeArray, ref pointWaterInfoNativeArray, in instancePointCountNativeArray, in instanceCount, in topologyMap, in waterIgnoreStates, ref needsDeepWaterChecks, isDeepSea, out hasAnyDeepWaterChecks);
	}
}


using Unity.Collections;
using UnityEngine;

internal delegate void ConstructDeepWaterCommands_00007734$PostfixBurstDelegate(in NativeArray<Vector3> allPositions, in NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<bool> needsDeepWaterChecks, out NativeList<RaycastCommand> deepWaterCasts, out NativeList<int> raycastPointIndices, Allocator allocator);


using System;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;

internal static class ConstructDeepWaterCommands_00007734$BurstDirectCall
{
	private static IntPtr Pointer;

	private static IntPtr DeferredCompilation;

	[BurstDiscard]
	private unsafe static void GetFunctionPointerDiscard(ref IntPtr P_0)
	{
		if (Pointer == (IntPtr)0)
		{
			Pointer = (nint)BurstCompiler.GetILPPMethodFunctionPointer2(DeferredCompilation, (RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/, typeof(ConstructDeepWaterCommands_00007734$PostfixBurstDelegate).TypeHandle);
		}
		P_0 = Pointer;
	}

	private static IntPtr GetFunctionPointer()
	{
		nint result = 0;
		GetFunctionPointerDiscard(ref result);
		return result;
	}

	public static void Constructor()
	{
		DeferredCompilation = BurstCompiler.CompileILPPMethod2((RuntimeMethodHandle)/*OpCode not supported: LdMemberToken*/);
	}

	public static void Initialize()
	{
	}

	static ConstructDeepWaterCommands_00007734$BurstDirectCall()
	{
		Constructor();
	}

	public unsafe static void Invoke(in NativeArray<Vector3> allPositions, in NativeArray<WaterLevel.WaterInfo> pointWaterInfoNativeArray, in NativeArray<bool> needsDeepWaterChecks, out NativeList<RaycastCommand> deepWaterCasts, out NativeList<int> raycastPointIndices, Allocator allocator)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (BurstCompiler.IsEnabled)
		{
			IntPtr functionPointer = GetFunctionPointer();
			if (functionPointer != (IntPtr)0)
			{
				((delegate* unmanaged[Cdecl]<ref NativeArray<Vector3>, ref NativeArray<WaterLevel.WaterInfo>, ref NativeArray<bool>, ref NativeList<RaycastCommand>, ref NativeList<int>, Allocator, void>)functionPointer)(ref allPositions, ref pointWaterInfoNativeArray, ref needsDeepWaterChecks, ref deepWaterCasts, ref raycastPointIndices, allocator);
				return;
			}
		}
		ConstructDeepWaterCommands$BurstManaged(in allPositions, in pointWaterInfoNativeArray, in needsDeepWaterChecks, out deepWaterCasts, out raycastPointIndices, allocator);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherMaxWaterLevelsJob : IJob
{
	[WriteOnly]
	public NativeArray<float> WaterLevels;

	public ReadOnly<Vector3> Positions;

	public Bounds DeepSeaBounds;

	public float waterLevelMain;

	public float waterLevelDeep;

	public void Execute()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Positions.Length; i++)
		{
			WaterLevels[i] = (((Bounds)(ref DeepSeaBounds)).Contains(Positions[i]) ? waterLevelDeep : waterLevelMain);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ToUVJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<Vector2> UV;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public Vector2 TerrainPos;

	[ReadOnly]
	public Vector2 TerrainOneOverSize;

	public void Execute()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val2 = default(Vector2);
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Pos[num];
			((Vector2)(ref val2))..ctor(val.x, val.z);
			UV[num] = (val2 - TerrainPos) * TerrainOneOverSize;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherWavesIndicesJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> WaveIndices;

	[WriteOnly]
	public NativeReference<int> WaveIndexCount;

	[WriteOnly]
	public NativeArray<int> DeepWaveIndices;

	[WriteOnly]
	public NativeReference<int> DeepWaveIndexCount;

	public ReadOnly<Vector3> Positions;

	[ReadOnly]
	public ReadOnly<int> Topologies;

	[ReadOnly]
	public ReadOnly<float> Heights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<float> WaterLevels;

	public Bounds deepSeaBounds;

	public void Execute()
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		int value = 0;
		int value2 = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			bool num2 = Heights[num] < WaterLevels[num];
			bool flag = (Topologies[num] & 0x180) != 0;
			if (num2 && flag)
			{
				if (((Bounds)(ref deepSeaBounds)).Contains(Positions[num]))
				{
					DeepWaveIndices[value2++] = num;
				}
				else
				{
					WaveIndices[value++] = num;
				}
			}
		}
		WaveIndexCount.Value = value;
		DeepWaveIndexCount.Value = value2;
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ApplyMaxHeightsJobIndirect : IJob
{
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<int> Topologies;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<float> WaterLevels;

	[ReadOnly]
	public float OceanLevel;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			bool num2 = Heights[num] < WaterLevels[num];
			bool flag = (Topologies[num] & 0x180) != 0;
			if (num2 && flag)
			{
				Heights[num] = Math.Max(Heights[num], OceanLevel);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct SelectMaxWaterLevelJobIndirect : IJob
{
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<float> DynamicHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float OceanLevel;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float num2 = Heights[num];
			float num3 = OceanLevel + DynamicHeights[num];
			Heights[num] = Mathf.Max(num2, num3);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalcCenterJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<Vector3> Results;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Results[num] = (Starts[num] + Ends[num]) * 0.5f;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct InitialValidateInfoJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<WaterLevel.WaterInfo> Results;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<float> WaterHeights;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Starts[num];
			Vector3 val2 = Ends[num];
			float num2 = Radii[num];
			float minY = Mathf.Min(val.y, val2.y) - num2;
			float maxY = Mathf.Max(val.y, val2.y) + num2;
			Results[num] = WaterLevel.InitialValidate(minY, maxY, WaterHeights[num], TerrainHeights[num]);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherValidInfosJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> ValidIndices;

	[WriteOnly]
	public NativeReference<int> ValidIndexCount;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (Infos[num].isValid)
			{
				ValidIndices[value++] = num;
			}
		}
		ValidIndexCount.Value = value;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GatherInvalidInfosJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<int> InvalidIndices;

	[WriteOnly]
	public NativeReference<int> InvalidIndexCount;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (!Infos[num].isValid)
			{
				InvalidIndices[value++] = num;
			}
		}
		InvalidIndexCount.Value = value;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct UpdateWaterHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> WaterHeights;

	[ReadOnly]
	public NativeArray<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public NativeArray<int> Indices;

	public void Execute()
	{
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (Infos[num].isValid)
			{
				WaterHeights[num] = Infos[num].surfaceLevel;
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct SetupHeadQueryJobIndirect : IJob
{
	public NativeArray<int> Indices;

	[WriteOnly]
	public NativeReference<int> QueryIndexCount;

	[WriteOnly]
	public NativeArray<Vector3> QueryStarts;

	[WriteOnly]
	public NativeArray<float> QueryRadii;

	[ReadOnly]
	public ReadOnly<bool> ValidInfos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	public void Execute()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		int value = 0;
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			if (ValidInfos[num])
			{
				Vector3 val = Starts[num];
				Vector3 val2 = Ends[num];
				float num2 = Radii[num];
				float num3 = Mathf.Min(val.y, val2.y) - num2;
				float num4 = Mathf.Max(val.y, val2.y) + num2;
				Vector3 val3 = Vector3Ex.WithY((val + val2) * 0.5f, Mathf.Lerp(num3, num4, 0.75f));
				Indices[value++] = num;
				QueryStarts[num] = val3;
				QueryRadii[num] = 0.01f;
			}
		}
		QueryIndexCount.Value = value;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ApplyHeadQueryResultsJobIndirect : IJob
{
	public NativeArray<float> WaterHeights;

	[WriteOnly]
	public NativeArray<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<bool> ValidInfos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public unsafe void Execute()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float num2 = WaterHeights[num];
			if (ValidInfos[num])
			{
				UnsafeUtility.ArrayElementAsRef<WaterLevel.WaterInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<WaterLevel.WaterInfo>(Infos), num).isValid = false;
				num2 = -1000f;
			}
			else
			{
				num2 = Mathf.Min(num2, Starts[num].y);
			}
			WaterHeights[num] = num2;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ResolveWaterInfosJobIndirect : IJob
{
	public NativeArray<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	[ReadOnly]
	public ReadOnly<float> WaterHeights;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public unsafe void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 val = Starts[num];
			Vector3 val2 = Ends[num];
			float num2 = Radii[num];
			float num3 = Mathf.Min(val.y, val2.y) - num2;
			float num4 = WaterHeights[num];
			float num5 = TerrainHeights[num];
			ref WaterLevel.WaterInfo reference = ref UnsafeUtility.ArrayElementAsRef<WaterLevel.WaterInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<WaterLevel.WaterInfo>(Infos), num);
			reference.currentDepth = Mathf.Max(0f, num4 - num3);
			reference.overallDepth = Mathf.Max(0f, num4 - num5);
			reference.surfaceLevel = num4;
			reference.terrainHeight = num5;
		}
	}
}


public enum RPCProgressBarState
{
	None,
	Start,
	Cancel,
	Complete,
	LAST
}


using System.Collections;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class GhostShip : JunkPileWater, IDeepSeaSpawner
{
	public GameObjectRef hackableLockedCratePrefab;

	public Transform[] crateSpawnPoints;

	public GameObjectRef mapMarkerPrefab;

	public BoatGroupSpawner boatGroupSpawner;

	private SpawnGroup[] _spawnGroups = new SpawnGroup[0];

	private BaseEntity spawnedMapMarker;

	private NavMeshDataInstance navMeshInst;

	private Matrix4x4 navMeshTransf;

	public override Matrix4x4 WorldToNavMeshSpace
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (!((NavMeshDataInstance)(ref navMeshInst)).valid)
			{
				return base.WorldToNavMeshSpace;
			}
			return navMeshTransf * ((Component)this).transform.worldToLocalMatrix;
		}
	}

	public override Matrix4x4 NavMeshToWorldSpace
	{
		get
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (!((NavMeshDataInstance)(ref navMeshInst)).valid)
			{
				return base.WorldToNavMeshSpace;
			}
			return ((Component)this).transform.localToWorldMatrix * ((Matrix4x4)(ref navMeshTransf)).inverse;
		}
	}

	protected override void StartTimeout()
	{
	}

	public override void ServerInit()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		DeepSeaManager.ServerGhostShips.Add(this);
		if (mapMarkerPrefab.isValid)
		{
			spawnedMapMarker = base.gameManager.CreateEntity(mapMarkerPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
			spawnedMapMarker.Spawn();
		}
		NavMeshSurface componentInChildren = ((Component)this).GetComponentInChildren<NavMeshSurface>();
		if (Object.op_Implicit((Object)(object)componentInChildren) && (Object)(object)componentInChildren.navMeshData != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			Quaternion rotation = ((Component)this).transform.rotation;
			navMeshInst = NavMesh.AddNavMeshData(componentInChildren.navMeshData, position, rotation);
			((NavMeshDataInstance)(ref navMeshInst)).owner = (Object)(object)this;
			navMeshTransf = Matrix4x4.TRS(position, rotation, Vector3.one);
			if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance != (Object)null)
			{
				SingletonComponent<DynamicNavMesh>.Instance.IgnoreRoots.Add(((Component)this).transform);
			}
		}
		if (_spawnGroups.IsEmpty())
		{
			GetAllSpawnGroups();
		}
	}

	internal override void DoServerDestroy()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		DeepSeaManager.ServerGhostShips.Remove(this);
		if (((NavMeshDataInstance)(ref navMeshInst)).valid)
		{
			NavMesh.RemoveNavMeshData(navMeshInst);
		}
		if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance != (Object)null)
		{
			SingletonComponent<DynamicNavMesh>.Instance.IgnoreRoots.Remove(((Component)this).transform);
		}
		if ((Object)(object)spawnedMapMarker != (Object)null)
		{
			spawnedMapMarker.Kill();
		}
		spawnedMapMarker = null;
	}

	public void SpawnHackableLockedCrate()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (crateSpawnPoints != null)
		{
			Transform random = crateSpawnPoints.GetRandom();
			if (!((Object)(object)random == (Object)null))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(hackableLockedCratePrefab.resourcePath, random.position, random.rotation);
				baseEntity.Spawn();
				baseEntity.SetParent(this, worldPositionStays: true);
			}
		}
	}

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (from is HackableLockedCrate && msg == "HackingStarted")
		{
			boatGroupSpawner.SpawnBoatGroup(BoatAI.AILoadMode.KillBoat);
		}
	}

	public override bool ShouldJunkpileBeDestroyedBy(PlayerBoat boat)
	{
		return false;
	}

	public IEnumerator TriggerSpawnGroups()
	{
		SpawnGroup[] spawnGroups = _spawnGroups;
		foreach (SpawnGroup spawnGroup in spawnGroups)
		{
			if (!spawnGroup.HasSpawnedAny() || !spawnGroup.wantsInitialSpawn)
			{
				spawnGroup.Fill();
				yield return null;
			}
		}
	}

	public void GetAllSpawnGroups()
	{
		_spawnGroups = ((Component)this).GetComponentsInChildren<SpawnGroup>();
	}

	public override bool ShouldChildrenInheritNetworkGroup()
	{
		return false;
	}

	private void OnDrawGizmos()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (crateSpawnPoints == null)
		{
			return;
		}
		Transform[] array = crateSpawnPoints;
		foreach (Transform val in array)
		{
			if (!((Object)(object)val == (Object)null))
			{
				Gizmos.color = Color.yellow;
				Gizmos.DrawSphere(val.position, 0.1f);
			}
		}
	}
}


using Sonar;
using UnityEngine;

public class SonarObject : MonoBehaviour, IClientComponent
{
	public enum SType
	{
		MoonPool,
		Sub
	}

	[SerializeField]
	private SType sonarType;
}


public enum SType
{
	MoonPool,
	Sub
}


using Sonar;
using UnityEngine;

public class SonarSystem : FacepunchBehaviour
{
	[SerializeField]
	private float range = 100f;

	[SerializeField]
	private float maxDepth = float.PositiveInfinity;

	[SerializeField]
	private ParticleSystem sonarPS;

	[SerializeField]
	private ParticleSystem blipPS;

	[SerializeField]
	private SonarObject us;

	[SerializeField]
	private Color greenBlip;

	[SerializeField]
	private Color redBlip;

	[SerializeField]
	private Color whiteBlip;

	[SerializeField]
	private SoundDefinition sonarBlipSound;

	[SerializeField]
	private GameObject sonarSoundParent;
}


using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct UpdateWaterCache : IJob
{
	[WriteOnly]
	public NativeArray<BasePlayer.CachedState> States;

	[ReadOnly]
	public ReadOnly<float> Factors;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public unsafe void Execute()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			ref BasePlayer.CachedState reference = ref UnsafeUtility.ArrayElementAsRef<BasePlayer.CachedState>(NativeArrayUnsafeUtility.GetUnsafePtr<BasePlayer.CachedState>(States), num);
			reference.WaterFactor = Factors[num];
			reference.WaterInfo = Infos[num];
			reference.IsSwimming = BasePlayer.IsSwimming(reference.WaterFactor);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
internal struct GatherPosToValidateJob : IJob
{
	[WriteOnly]
	public NativeArray<BasePlayer.PositionChange> Changes;

	[WriteOnly]
	public NativeList<int> ToValidate;

	[ReadOnly]
	public TickInterpolatorCache.ReadOnlyState TickCache;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector3 startPoint = TickInterpolatorCache.GetStartPoint(TickCache, num);
			Vector3 endPoint = TickInterpolatorCache.GetEndPoint(TickCache, num);
			bool num2 = startPoint != endPoint;
			Changes[num] = BasePlayer.PositionChange.Same;
			if (num2)
			{
				ToValidate.AddNoResize(num);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile]
public struct RecacheTransforms : IJobParallelForTransform
{
	[WriteOnly]
	public NativeArray<Vector3> LocalPos;

	[WriteOnly]
	public NativeArray<Vector3> Pos;

	[WriteOnly]
	public NativeArray<Quaternion> LocalRots;

	[WriteOnly]
	public NativeArray<Quaternion> Rots;

	public void Execute(int index, TransformAccess transf)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transf)).isValid)
		{
			LocalPos[index] = ((TransformAccess)(ref transf)).localPosition;
			Pos[index] = ((TransformAccess)(ref transf)).position;
			LocalRots[index] = ((TransformAccess)(ref transf)).localRotation;
			Rots[index] = ((TransformAccess)(ref transf)).rotation;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalcWaterFactorsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Factors;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public ReadOnly<WaterLevel.WaterInfo> Infos;

	[ReadOnly]
	public ReadOnly<Vector3> Starts;

	[ReadOnly]
	public ReadOnly<Vector3> Ends;

	[ReadOnly]
	public ReadOnly<float> Radii;

	public void Execute()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Factors[num] = WaterLevel.Factor(Infos[num], Starts[num], Ends[num], Radii[num]);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GetWaterFactorsParamsJobIndirect : IJob
{
	public NativeArray<Vector3> Starts;

	public NativeArray<Vector3> Ends;

	[WriteOnly]
	public NativeArray<float> Radii;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<Quaternion> Rots;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			Vector2 val = Vector2.op_Implicit(Ends[num]);
			float x = val.x;
			float num2 = val.y * 0.5f;
			Vector3 val2 = Starts[num];
			Vector3 val3 = Pos[num];
			Quaternion val4 = Rots[num];
			Vector3 val5 = val3 + val4 * (val2 - Vector3.up * (num2 - x));
			Vector3 val6 = val3 + val4 * (val2 + Vector3.up * (num2 - x));
			Starts[num] = val5;
			Ends[num] = val6;
			Radii[num] = x;
		}
	}
}


using System;

public class ConsoleInput
{
	public string inputString = "";

	public string[] statusText = new string[3] { "", "", "" };

	public int StatusLineCount
	{
		get
		{
			if (statusText != null)
			{
				return statusText.Length;
			}
			return 0;
		}
	}

	public int InputCursorTop => StatusCursorTop - 1;

	public int StatusCursorTop => Console.BufferHeight - StatusLineCount - 1;

	public bool valid => Console.BufferWidth > 0;

	public int lineWidth => Console.BufferWidth;

	public event Action<string> OnInputText;

	public void ClearLine(int numLines)
	{
		Console.CursorLeft = 0;
		Console.Write(new string(' ', lineWidth * numLines));
		Console.CursorTop -= numLines;
		Console.CursorLeft = 0;
	}

	public void RedrawInputLine(bool clear = true)
	{
		ConsoleColor backgroundColor = Console.BackgroundColor;
		ConsoleColor foregroundColor = Console.ForegroundColor;
		Console.CursorVisible = false;
		try
		{
			if (clear)
			{
				ClearLine(1);
			}
			Console.ForegroundColor = ConsoleColor.White;
			Console.CursorLeft = 0;
			Console.BackgroundColor = ConsoleColor.Black;
			Console.ForegroundColor = ConsoleColor.Green;
			if (inputString.Length == 0)
			{
				Console.BackgroundColor = backgroundColor;
				Console.ForegroundColor = foregroundColor;
				return;
			}
			if (inputString.Length < lineWidth - 2)
			{
				Console.Write(inputString);
			}
			else
			{
				Console.Write(inputString.Substring(inputString.Length - (lineWidth - 2)));
			}
		}
		catch (Exception)
		{
		}
		Console.BackgroundColor = backgroundColor;
		Console.ForegroundColor = foregroundColor;
		Console.CursorVisible = true;
	}

	public void RedrawStatusText()
	{
		ConsoleColor backgroundColor = Console.BackgroundColor;
		ConsoleColor foregroundColor = Console.ForegroundColor;
		int cursorTop = Console.CursorTop;
		int cursorLeft = Console.CursorLeft;
		try
		{
			Console.CursorTop++;
			Console.ForegroundColor = ConsoleColor.White;
			for (int i = 0; i < statusText.Length; i++)
			{
				Console.CursorLeft = 0;
				Console.Write(statusText[i].PadRight(lineWidth));
			}
		}
		catch
		{
		}
		Console.BackgroundColor = backgroundColor;
		Console.ForegroundColor = foregroundColor;
		try
		{
			Console.CursorTop = cursorTop;
			Console.CursorLeft = cursorLeft;
		}
		catch
		{
		}
	}

	public void FixBottomOfBuffer()
	{
		try
		{
			Console.CursorTop = InputCursorTop;
		}
		catch
		{
		}
	}

	internal void OnBackspace()
	{
		if (inputString.Length >= 1)
		{
			inputString = inputString.Substring(0, inputString.Length - 1);
			RedrawInputLine();
		}
	}

	internal void OnEscape()
	{
		inputString = "";
		RedrawInputLine();
	}

	internal void OnEnter()
	{
		ClearLine(statusText.Length);
		ConsoleColor foregroundColor = Console.ForegroundColor;
		Console.ForegroundColor = ConsoleColor.Green;
		Console.WriteLine("> " + inputString);
		Console.ForegroundColor = foregroundColor;
		string obj = inputString;
		inputString = "";
		if (this.OnInputText != null)
		{
			this.OnInputText(obj);
		}
		RedrawInputLine();
	}

	public void Update()
	{
		if (!valid)
		{
			return;
		}
		try
		{
			if (!Console.KeyAvailable)
			{
				return;
			}
		}
		catch (Exception)
		{
			return;
		}
		ConsoleKeyInfo consoleKeyInfo = Console.ReadKey();
		if (consoleKeyInfo.Key == ConsoleKey.Enter)
		{
			OnEnter();
		}
		else if (consoleKeyInfo.Key == ConsoleKey.Backspace)
		{
			OnBackspace();
		}
		else if (consoleKeyInfo.Key == ConsoleKey.Escape)
		{
			OnEscape();
		}
		else if (consoleKeyInfo.KeyChar != 0)
		{
			inputString += consoleKeyInfo.KeyChar;
			RedrawInputLine(clear: false);
		}
	}
}


using System;

public class ResetStaticFieldsAttribute : Attribute
{
}


using UnityEngine;

[DisallowMultipleComponent]
[RequireComponent(typeof(Camera))]
public class InstancedDebugDraw : SingletonComponent<InstancedDebugDraw>
{
	public Material overlayMaterial;

	public Material depthTestedMaterial;
}


using System;
using UnityEngine;

public class DDraw : MonoBehaviour
{
	public static void BroadcastArrow(Vector3 start, Vector3 end, Color color, float duration = 10f, float headSize = 0.5f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.arrow", duration, color, start, end, headSize, distanceFade, zTest);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void BroadcastLine(Vector3 start, Vector3 end, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.line", duration, color, start, end, distanceFade, zTest);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void BroadcastSphere(Vector3 pos, float radius, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.sphere", duration, color, pos, radius, distanceFade, zTest);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void BroadcastText(Vector3 pos, string text, Color color, float duration = 10f, bool distanceFade = true, bool zTest = false)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.text", duration, color, pos, text, distanceFade, zTest);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void BroadcastCapsule(Vector3 pos, Vector3 rot, float radius, float height, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.capsule", duration, color, pos, rot, radius, height, distanceFade, zTest);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void BroadcastBox(Vector3 pos, Vector3 size, Vector3 rot, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.box", duration, color, pos, $"{size.x} {size.y} {size.z}", rot, distanceFade, zTest);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void BroadcastBounds(Bounds bounds, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		BroadcastBox(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size, Vector3.zero, color, duration, distanceFade, zTest);
	}

	public static void BroadcastClear()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && current.IsConnected)
				{
					current.SendConsoleCommand("ddraw.clear");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void Arrow(BasePlayer player, Vector3 start, Vector3 end, Color color, float duration = 10f, float headSize = 0.5f, bool distanceFade = true, bool zTest = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.arrow", duration, color, start, end, headSize, distanceFade, zTest);
		}
	}

	public static void Line(BasePlayer player, Vector3 start, Vector3 end, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.line", duration, color, start, end, distanceFade, zTest);
		}
	}

	public static void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.sphere", duration, color, pos, radius, distanceFade, zTest);
		}
	}

	public static void Text(BasePlayer player, Vector3 pos, string text, Color color, float duration = 10f, bool distanceFade = true, bool zTest = false)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.text", duration, color, pos, text, distanceFade, zTest);
		}
	}

	public static void Capsule(BasePlayer player, Vector3 pos, Vector3 rot, float radius, float height, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.capsule", duration, color, pos, rot, radius, height, distanceFade, zTest);
		}
	}

	public static void Bounds(BasePlayer player, Bounds bounds, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Box(player, ((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size, Vector3.zero, color, duration, distanceFade, zTest);
	}

	public static void Box(BasePlayer player, Vector3 pos, Vector3 size, Vector3 rot, Color color, float duration = 10f, bool distanceFade = true, bool zTest = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.box", duration, color, pos, $"{size.x} {size.y} {size.z}", rot, distanceFade, zTest);
		}
	}

	public static void Clear(BasePlayer player)
	{
		if (!((Object)(object)player == (Object)null) && player.IsConnected)
		{
			player.SendConsoleCommand("ddraw.clear");
		}
	}
}


using UnityEngine;

public class CachedMonumentComponent : MonoBehaviour
{
	public MonumentInfo Monument;

	public Vector3 LastPosition;

	public void UpdateMonument(MonumentInfo info, Collider collider)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Monument = info;
		LastPosition = ((Component)collider).transform.position;
	}
}


using UnityEngine;
using UnityEngine.Animations;

public static class AniamtorEx
{
	public static void SetFloatFixed(this Animator animator, int id, float value, float dampTime, float deltaTime)
	{
		if (value == 0f)
		{
			float @float = animator.GetFloat(id);
			if (@float == 0f)
			{
				return;
			}
			if (@float < float.Epsilon)
			{
				animator.SetFloat(id, 0f);
				return;
			}
		}
		animator.SetFloat(id, value, dampTime, deltaTime);
	}

	public static void SetFloatFixed(this AnimatorControllerPlayable playable, int id, float value, float dampTime, float deltaTime)
	{
		float @float = ((AnimatorControllerPlayable)(ref playable)).GetFloat(id);
		if (value == 0f)
		{
			if (@float == 0f)
			{
				return;
			}
			if (@float < float.Epsilon)
			{
				((AnimatorControllerPlayable)(ref playable)).SetFloat(id, 0f);
				return;
			}
		}
		float num = Mathf.Lerp(@float, value, deltaTime / Mathf.Max(dampTime, 0.0001f));
		((AnimatorControllerPlayable)(ref playable)).SetFloat(id, num);
	}

	public static void SetBoolChecked(this AnimatorControllerPlayable playable, int id, bool value)
	{
		if (((AnimatorControllerPlayable)(ref playable)).GetBool(id) != value)
		{
			((AnimatorControllerPlayable)(ref playable)).SetBool(id, value);
		}
	}

	public static void SetBoolChecked(this Animator animator, int id, bool value)
	{
		if (animator.GetBool(id) != value)
		{
			animator.SetBool(id, value);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class ArgEx
{
	public static BasePlayer Player(this Arg arg)
	{
		if (arg == null || arg.Connection == null)
		{
			return null;
		}
		return arg.Connection.player as BasePlayer;
	}

	public static BasePlayer GetPlayer(this Arg arg, int iArgNum)
	{
		string @string = arg.GetString(iArgNum, (string)null);
		if (@string == null)
		{
			return null;
		}
		return BasePlayer.Find(@string);
	}

	public static List<BasePlayer> GetPlayerArgs(this Arg arg, int startArgIndex)
	{
		List<BasePlayer> list = new List<BasePlayer>();
		int num = arg.Args.Length - startArgIndex;
		if (num <= 0)
		{
			return list;
		}
		for (int i = 0; i < num; i++)
		{
			BasePlayer player = arg.GetPlayer(startArgIndex + i);
			if ((Object)(object)player != (Object)null)
			{
				list.Add(player);
				Debug.Log((object)("Added player " + player.displayName));
			}
		}
		return list;
	}

	public static BasePlayer GetSleeper(this Arg arg, int iArgNum)
	{
		string @string = arg.GetString(iArgNum, "");
		if (@string == null)
		{
			return null;
		}
		return BasePlayer.FindSleeping(@string);
	}

	public static BasePlayer GetPlayerOrSleeper(this Arg arg, int iArgNum)
	{
		string @string = arg.GetString(iArgNum, "");
		if (@string == null)
		{
			return null;
		}
		return BasePlayer.FindAwakeOrSleeping(@string);
	}

	public static BasePlayer GetPlayerOrSleeperOrBot(this Arg arg, int iArgNum)
	{
		uint num = default(uint);
		if (arg.TryGetUInt(iArgNum, ref num))
		{
			return BasePlayer.FindBot(num);
		}
		return arg.GetPlayerOrSleeper(iArgNum);
	}

	public static NetworkableId GetEntityID(this Arg arg, int iArg, NetworkableId def = default(NetworkableId))
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return new NetworkableId(arg.GetUInt64(iArg, def.Value));
	}

	public static ItemId GetItemID(this Arg arg, int iArg, ItemId def = default(ItemId))
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return new ItemId(arg.GetUInt64(iArg, def.Value));
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;
using VLB;

public static class ColliderEx
{
	public static PhysicMaterial GetMaterialAt(this Collider obj, Vector3 pos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)obj == (Object)null)
		{
			return TerrainMeta.Config.WaterMaterial;
		}
		if (obj is TerrainCollider)
		{
			return TerrainMeta.Physics.GetMaterial(pos);
		}
		return obj.sharedMaterial;
	}

	public static float EstimateVolume(this Collider collider)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lossyScale = ((Component)collider).transform.lossyScale;
		SphereCollider val = (SphereCollider)(object)((collider is SphereCollider) ? collider : null);
		if (val != null)
		{
			return val.radius * lossyScale.x * val.radius * lossyScale.y * val.radius * lossyScale.z * 4.1887903f;
		}
		BoxCollider val2 = (BoxCollider)(object)((collider is BoxCollider) ? collider : null);
		if (val2 != null)
		{
			return val2.size.x * lossyScale.x * val2.size.y * lossyScale.y * val2.size.z * lossyScale.z;
		}
		MeshCollider val3 = (MeshCollider)(object)((collider is MeshCollider) ? collider : null);
		if (val3 != null)
		{
			Bounds bounds = ((Collider)val3).bounds;
			Vector3 size = ((Bounds)(ref bounds)).size;
			return size.x * lossyScale.x * size.y * lossyScale.y * size.z * lossyScale.z;
		}
		CapsuleCollider val4 = (CapsuleCollider)(object)((collider is CapsuleCollider) ? collider : null);
		if (val4 != null)
		{
			float num = val4.radius * Mathf.Max(lossyScale.x, lossyScale.z);
			float num2 = (val4.height - num * 2f) * lossyScale.y;
			return MathF.PI * num * num * num2 + 4.1887903f * num * num * num;
		}
		return 0f;
	}

	public static bool IsOnLayer(this Collider col, Layer rustLayer)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)col != (Object)null)
		{
			return ((Component)col).gameObject.IsOnLayer(rustLayer);
		}
		return false;
	}

	public static bool IsOnLayer(this Collider col, int layer)
	{
		if ((Object)(object)col != (Object)null)
		{
			return ((Component)col).gameObject.IsOnLayer(layer);
		}
		return false;
	}

	public static float GetRadius(this Collider col, Vector3 transformScale)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		float result = 1f;
		SphereCollider val = (SphereCollider)(object)((col is SphereCollider) ? col : null);
		if (val != null)
		{
			result = val.radius * Vector3Ex.Max(transformScale);
		}
		else
		{
			BoxCollider val2 = (BoxCollider)(object)((col is BoxCollider) ? col : null);
			if (val2 != null)
			{
				result = Vector3Ex.Max(Vector3.Scale(val2.size, transformScale)) * 0.5f;
			}
			else
			{
				CapsuleCollider val3 = (CapsuleCollider)(object)((col is CapsuleCollider) ? col : null);
				if (val3 != null)
				{
					float num = val3.direction switch
					{
						0 => transformScale.y, 
						1 => transformScale.x, 
						_ => transformScale.x, 
					};
					result = val3.radius * num;
				}
				else
				{
					MeshCollider val4 = (MeshCollider)(object)((col is MeshCollider) ? col : null);
					if (val4 != null)
					{
						Bounds bounds = ((Collider)val4).bounds;
						result = Vector3Ex.Max(Vector3.Scale(((Bounds)(ref bounds)).size, transformScale)) * 0.5f;
					}
				}
			}
		}
		return result;
	}

	public static MonumentInfo GetMonument(this Collider collider, bool ignoreEntity = true)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)collider == (Object)null)
		{
			return null;
		}
		if (ignoreEntity && (Object)(object)collider.ToBaseEntity() != (Object)null)
		{
			return null;
		}
		CachedMonumentComponent cachedMonumentComponent = ((Component)collider).GetComponent<CachedMonumentComponent>();
		if ((Object)(object)cachedMonumentComponent == (Object)null || cachedMonumentComponent.LastPosition != ((Component)collider).transform.position)
		{
			cachedMonumentComponent = ((Component)collider).gameObject.GetOrAddComponent<CachedMonumentComponent>();
			PreventBuildingMonumentTag component = ((Component)collider).GetComponent<PreventBuildingMonumentTag>();
			if ((Object)(object)component != (Object)null)
			{
				cachedMonumentComponent.UpdateMonument(component.GetAttachedMonument(), collider);
				return cachedMonumentComponent.Monument;
			}
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapBounds(collider.bounds, list, 536870912, (QueryTriggerInteraction)2);
			foreach (Collider item in list)
			{
				component = ((Component)item).GetComponent<PreventBuildingMonumentTag>();
				if ((Object)(object)component != (Object)null)
				{
					cachedMonumentComponent.UpdateMonument(component.GetAttachedMonument(), collider);
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
		}
		return cachedMonumentComponent?.Monument;
	}
}


using UnityEngine;

public static class CollisionEx
{
	public static BaseEntity GetEntity(this Collision col)
	{
		return col.collider.ToBaseEntity();
	}
}


using Facepunch;
using UnityEngine;

public static class ComponentEx
{
	public static T Instantiate<T>(this T component) where T : Component
	{
		return Instantiate.GameObject(((Component)component).gameObject, (Transform)null).GetComponent<T>();
	}

	public static bool HasComponent<T>(this Component component) where T : Component
	{
		return (Object)(object)component.GetComponent<T>() != (Object)null;
	}

	public static bool? IsEnabled(this Component component)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Behaviour val = (Behaviour)(object)((component is Behaviour) ? component : null);
		if (val != null)
		{
			return val.enabled;
		}
		Collider val2 = (Collider)(object)((component is Collider) ? component : null);
		if (val2 != null)
		{
			return val2.enabled;
		}
		Renderer val3 = (Renderer)(object)((component is Renderer) ? component : null);
		if (val3 != null)
		{
			return val3.enabled;
		}
		ParticleSystem val4 = (ParticleSystem)(object)((component is ParticleSystem) ? component : null);
		if (val4 != null)
		{
			EmissionModule emission = val4.emission;
			return ((EmissionModule)(ref emission)).enabled;
		}
		LODGroup val5 = (LODGroup)(object)((component is LODGroup) ? component : null);
		if (val5 != null)
		{
			return val5.enabled;
		}
		return null;
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using Facepunch;
using Rust;
using UnityEngine;

public static class CoroutineEx
{
	public static WaitForEndOfFrame waitForEndOfFrame = new WaitForEndOfFrame();

	public static WaitForFixedUpdate waitForFixedUpdate = new WaitForFixedUpdate();

	private static Dictionary<float, WaitForSeconds> waitForSecondsBuffer = new Dictionary<float, WaitForSeconds>();

	public static WaitForSeconds waitForSeconds(float seconds)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		if (!waitForSecondsBuffer.TryGetValue(seconds, out var value))
		{
			value = new WaitForSeconds(seconds);
			waitForSecondsBuffer.Add(seconds, value);
		}
		return value;
	}

	public static WaitForSecondsRealtimeEx waitForSecondsRealtime(float seconds)
	{
		WaitForSecondsRealtimeEx obj = Pool.Get<WaitForSecondsRealtimeEx>();
		obj.WaitTime = seconds;
		return obj;
	}

	public static IEnumerator Combine(params IEnumerator[] coroutines)
	{
		while (true)
		{
			bool flag = true;
			foreach (IEnumerator enumerator in coroutines)
			{
				if (enumerator != null && enumerator.MoveNext())
				{
					flag = false;
				}
			}
			if (flag)
			{
				break;
			}
			yield return waitForEndOfFrame;
		}
	}

	public static Task AsTask(this IEnumerator coroutine)
	{
		if (coroutine == null)
		{
			return Task.CompletedTask;
		}
		TaskCompletionSource<object> tcs = new TaskCompletionSource<object>();
		((MonoBehaviour)Global.Runner).StartCoroutine(RunImpl());
		return tcs.Task;
		IEnumerator RunImpl()
		{
			yield return coroutine;
			tcs.SetResult(null);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust;
using Rust.Registry;
using UnityEngine;

public static class GameObjectEx
{
	public static BaseEntity ToBaseEntity(this GameObject go, bool allowDestroyed = false)
	{
		return go.transform.ToBaseEntity(allowDestroyed);
	}

	public static BaseEntity ToBaseEntity(this Collider collider, bool allowDestroyed = false)
	{
		return ((Component)collider).transform.ToBaseEntity(allowDestroyed);
	}

	public static BaseEntity ToBaseEntity(this Transform transform, bool allowDestroyed = false)
	{
		IEntity val = GetEntityFromRegistry(transform, allowDestroyed);
		if (val == null && !((Component)transform).gameObject.activeInHierarchy)
		{
			val = GetEntityFromComponent(transform);
		}
		return val as BaseEntity;
	}

	public static bool IsOnLayer(this GameObject go, Layer rustLayer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return go.IsOnLayer((int)rustLayer);
	}

	public static bool IsOnLayer(this GameObject go, int layer)
	{
		if ((Object)(object)go != (Object)null)
		{
			return go.layer == layer;
		}
		return false;
	}

	private static IEntity GetEntityFromRegistry(Transform transform, bool allowDestroyed = false)
	{
		Transform val = transform;
		IEntity val2 = Entity.Get(val);
		while (val2 == null && (Object)(object)val.parent != (Object)null)
		{
			val = val.parent;
			val2 = Entity.Get(val);
		}
		if (val2 == null || (val2.IsDestroyed && !allowDestroyed))
		{
			return null;
		}
		return val2;
	}

	private static IEntity GetEntityFromComponent(Transform transform)
	{
		Transform val = transform;
		IEntity component = ((Component)val).GetComponent<IEntity>();
		while (component == null && (Object)(object)val.parent != (Object)null)
		{
			val = val.parent;
			component = ((Component)val).GetComponent<IEntity>();
		}
		if (component != null && !component.IsDestroyed)
		{
			return component;
		}
		return null;
	}

	public static bool HasComponent<T>(this GameObject obj) where T : Component
	{
		return (Object)(object)obj.GetComponent<T>() != (Object)null;
	}

	public static bool HasComponentInParent<T>(this GameObject obj) where T : Component
	{
		return (Object)(object)obj.GetComponentInParent<T>() != (Object)null;
	}

	public static void SetChildComponentsEnabled<T>(this GameObject gameObject, bool enabled) where T : MonoBehaviour
	{
		List<T> list = Pool.Get<List<T>>();
		gameObject.GetComponentsInChildren<T>(true, list);
		foreach (T item in list)
		{
			((Behaviour)(object)item).enabled = enabled;
		}
		Pool.FreeUnmanaged<T>(ref list);
	}

	public static GameObject FindInChildren(this GameObject parent, string name)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (((Object)parent).name == name)
		{
			return parent;
		}
		foreach (Transform item in parent.transform)
		{
			GameObject val = ((Component)item).gameObject.FindInChildren(name);
			if ((Object)(object)val != (Object)null)
			{
				return val;
			}
		}
		return null;
	}
}


public static class NetworkNetworkable
{
}


using Network;

public static class NetworkPacketEx
{
	public static BasePlayer Player(this Message v)
	{
		if (v.connection == null)
		{
			return null;
		}
		return v.connection.player as BasePlayer;
	}
}


public static class ObjectEffectsEx
{
}


using UnityEngine;

public static class QuaternionEx
{
	public static Quaternion AlignToNormal(this Quaternion rot, Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.FromToRotation(Vector3.up, normal) * rot;
	}

	public static Quaternion LookRotationWithOffset(Vector3 offset, Vector3 forward, Vector3 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(forward, Vector3.up) * Quaternion.Inverse(Quaternion.LookRotation(offset, Vector3.up));
	}

	public static Quaternion LookRotationForcedUp(Vector3 forward, Vector3 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (forward == up)
		{
			return Quaternion.LookRotation(up);
		}
		Vector3 val = Vector3.Cross(forward, up);
		forward = Vector3.Cross(up, val);
		return Quaternion.LookRotation(forward, up);
	}

	public static Quaternion LookRotationGradient(Vector3 normal, Vector3 up)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((normal == Vector3.up) ? Vector3.forward : Vector3.Cross(normal, Vector3.up));
		return LookRotationForcedUp(Vector3.Cross(normal, val), up);
	}

	public static Quaternion LookRotationNormal(Vector3 normal, Vector3 up = default(Vector3))
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (up != Vector3.zero)
		{
			return LookRotationForcedUp(up, normal);
		}
		if (normal == Vector3.up)
		{
			return LookRotationForcedUp(Vector3.forward, normal);
		}
		if (normal == Vector3.down)
		{
			return LookRotationForcedUp(Vector3.back, normal);
		}
		if (normal.y == 0f)
		{
			return LookRotationForcedUp(Vector3.up, normal);
		}
		Vector3 val = Vector3.Cross(normal, Vector3.up);
		return LookRotationForcedUp(-Vector3.Cross(normal, val), normal);
	}

	public static Quaternion EnsureValid(this Quaternion rot, float epsilon = float.Epsilon)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if (!(Quaternion.Dot(rot, rot) >= epsilon))
		{
			return Quaternion.identity;
		}
		return rot;
	}
}


using UnityEngine;

public static class RayEx
{
	public static Vector3 ClosestPoint(this Ray ray, Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return ((Ray)(ref ray)).origin + Vector3.Dot(pos - ((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction) * ((Ray)(ref ray)).direction;
	}

	public static float Distance(this Ray ray, Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(((Ray)(ref ray)).direction, pos - ((Ray)(ref ray)).origin);
		return ((Vector3)(ref val)).magnitude;
	}

	public static float SqrDistance(this Ray ray, Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(((Ray)(ref ray)).direction, pos - ((Ray)(ref ray)).origin);
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public static bool IsNaNOrInfinity(this Ray r)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!Vector3Ex.IsNaNOrInfinity(((Ray)(ref r)).origin))
		{
			return Vector3Ex.IsNaNOrInfinity(((Ray)(ref r)).direction);
		}
		return true;
	}
}


using UnityEngine;

public static class SkinnedMeshRendererEx
{
	public static Transform FindRig(this SkinnedMeshRenderer renderer)
	{
		Transform parent = ((Component)renderer).transform.parent;
		Transform val = renderer.rootBone;
		while ((Object)(object)val != (Object)null && (Object)(object)val.parent != (Object)null && (Object)(object)val.parent != (Object)(object)parent)
		{
			val = val.parent;
		}
		return val;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public static class TransformEx
{
	public static string GetRecursiveName(this Transform transform, string strEndName = "")
	{
		string text = ((Object)transform).name;
		if (!string.IsNullOrEmpty(strEndName))
		{
			text = text + "/" + strEndName;
		}
		if ((Object)(object)transform.parent != (Object)null)
		{
			text = transform.parent.GetRecursiveName(text);
		}
		return text;
	}

	public static void RemoveComponent<T>(this Transform transform) where T : Component
	{
		T component = ((Component)transform).GetComponent<T>();
		if (!((Object)(object)component == (Object)null))
		{
			GameManager.Destroy((Component)(object)component);
		}
	}

	public static void RetireAllChildren(this Transform transform, GameManager gameManager)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		List<GameObject> list = Pool.Get<List<GameObject>>();
		foreach (Transform item in transform)
		{
			Transform val = item;
			if (!((Component)val).CompareTag("persist"))
			{
				list.Add(((Component)val).gameObject);
			}
		}
		foreach (GameObject item2 in list)
		{
			gameManager.Retire(item2);
		}
		Pool.FreeUnmanaged<GameObject>(ref list);
	}

	public static List<Transform> GetChildren(this Transform transform)
	{
		return ((IEnumerable)transform).Cast<Transform>().ToList();
	}

	public static void OrderChildren(this Transform tx, Func<Transform, object> selector)
	{
		foreach (Transform item in ((IEnumerable)tx).Cast<Transform>().OrderBy(selector))
		{
			item.SetAsLastSibling();
		}
	}

	public static List<Transform> GetAllChildren(this Transform transform)
	{
		List<Transform> list = new List<Transform>();
		if ((Object)(object)transform != (Object)null)
		{
			transform.AddAllChildren(list);
		}
		return list;
	}

	public static void AddAllChildren(this Transform transform, List<Transform> list)
	{
		list.Add(transform);
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (!((Object)(object)child == (Object)null))
			{
				child.AddAllChildren(list);
			}
		}
	}

	public static Transform[] GetChildrenWithTag(this Transform transform, string strTag)
	{
		return (from x in transform.GetAllChildren()
			where ((Component)x).CompareTag(strTag)
			select x).ToArray();
	}

	public static Matrix4x4 LocalToPrefabRoot(this Transform transform)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 val = Matrix4x4.identity;
		while ((Object)(object)transform.parent != (Object)null)
		{
			val *= Matrix4x4.TRS(transform.localPosition, transform.localRotation, transform.localScale);
			transform = transform.parent;
		}
		return val;
	}

	public static void Identity(this GameObject go, bool resetScale = true)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = go.transform;
		transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
		if (resetScale)
		{
			transform.localScale = Vector3.one;
		}
	}

	public static GameObject CreateChild(this GameObject go)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		//IL_001e: Expected O, but got Unknown
		GameObject val = new GameObject();
		val.transform.parent = go.transform;
		Identity(val);
		return val;
	}

	public static GameObject InstantiateChild(this GameObject go, GameObject prefab)
	{
		GameObject obj = Instantiate.GameObject(prefab, (Transform)null);
		obj.transform.SetParent(go.transform, false);
		obj.Identity();
		return obj;
	}

	public static void SetLayerRecursive(this GameObject go, int Layer)
	{
		if (go.layer != Layer)
		{
			go.layer = Layer;
		}
		for (int i = 0; i < go.transform.childCount; i++)
		{
			((Component)go.transform.GetChild(i)).gameObject.SetLayerRecursive(Layer);
		}
	}

	public static bool DropToGround(this Transform transform, bool alignToNormal = false, float fRange = 100f)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (transform.GetGroundInfo(out var pos, out var normal, fRange))
		{
			transform.position = pos;
			if (alignToNormal)
			{
				transform.rotation = Quaternion.LookRotation(transform.forward, normal);
			}
			return true;
		}
		return false;
	}

	public static bool GetGroundInfo(this Transform transform, out Vector3 pos, out Vector3 normal, float range = 100f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TransformUtil.GetGroundInfo(transform.position, out pos, out normal, range, transform);
	}

	public static bool GetGroundInfoTerrainOnly(this Transform transform, out Vector3 pos, out Vector3 normal, float range = 100f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TransformUtil.GetGroundInfoTerrainOnly(transform.position, out pos, out normal, range);
	}

	public static Bounds WorkoutRenderBounds(this Transform tx)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = default(Bounds);
		((Bounds)(ref bounds))..ctor(Vector3.zero, Vector3.zero);
		Renderer[] componentsInChildren = ((Component)tx).GetComponentsInChildren<Renderer>();
		foreach (Renderer val in componentsInChildren)
		{
			if (!(val is ParticleSystemRenderer))
			{
				if (((Bounds)(ref bounds)).center == Vector3.zero)
				{
					bounds = val.bounds;
				}
				else
				{
					((Bounds)(ref bounds)).Encapsulate(val.bounds);
				}
			}
		}
		return bounds;
	}

	public static List<T> GetSiblings<T>(this Transform transform, bool includeSelf = false)
	{
		List<T> list = new List<T>();
		if ((Object)(object)transform.parent == (Object)null)
		{
			return list;
		}
		for (int i = 0; i < transform.parent.childCount; i++)
		{
			Transform child = transform.parent.GetChild(i);
			if (includeSelf || !((Object)(object)child == (Object)(object)transform))
			{
				T component = ((Component)child).GetComponent<T>();
				if (component != null)
				{
					list.Add(component);
				}
			}
		}
		return list;
	}

	public static void DestroyChildren(this Transform transform)
	{
		for (int i = 0; i < transform.childCount; i++)
		{
			GameManager.Destroy(((Component)transform.GetChild(i)).gameObject);
		}
	}

	public static void SetChildrenActive(this Transform transform, bool b)
	{
		for (int i = 0; i < transform.childCount; i++)
		{
			((Component)transform.GetChild(i)).gameObject.SetActive(b);
		}
	}

	public static Transform ActiveChild(this Transform transform, string name, bool bDisableOthers)
	{
		Transform result = null;
		for (int i = 0; i < transform.childCount; i++)
		{
			Transform child = transform.GetChild(i);
			if (((Object)child).name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
			{
				result = child;
				((Component)child).gameObject.SetActive(true);
			}
			else if (bDisableOthers)
			{
				((Component)child).gameObject.SetActive(false);
			}
		}
		return result;
	}

	public static T GetComponentInChildrenIncludeDisabled<T>(this Transform transform) where T : Component
	{
		List<T> list = Pool.Get<List<T>>();
		((Component)transform).GetComponentsInChildren<T>(true, list);
		T result = ((list.Count > 0) ? list[0] : default(T));
		Pool.FreeUnmanaged<T>(ref list);
		return result;
	}

	public static bool HasComponentInChildrenIncludeDisabled<T>(this Transform transform) where T : Component
	{
		List<T> list = Pool.Get<List<T>>();
		((Component)transform).GetComponentsInChildren<T>(true, list);
		bool result = list.Count > 0;
		Pool.FreeUnmanaged<T>(ref list);
		return result;
	}

	public static Bounds GetBounds(this Transform transform, bool includeRenderers = true, bool includeColliders = true, bool includeInactive = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		Bounds result = default(Bounds);
		((Bounds)(ref result))..ctor(Vector3.zero, Vector3.zero);
		if (includeRenderers)
		{
			MeshLOD[] componentsInChildren = ((Component)transform).GetComponentsInChildren<MeshLOD>(includeInactive);
			foreach (MeshLOD meshLOD in componentsInChildren)
			{
				Mesh highestDetailMesh = meshLOD.GetHighestDetailMesh();
				if ((Object)(object)highestDetailMesh != (Object)null)
				{
					Matrix4x4 matrix = transform.worldToLocalMatrix * ((Component)meshLOD).transform.localToWorldMatrix;
					Bounds bounds = highestDetailMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds.Transform(matrix));
				}
			}
			MeshFilter[] componentsInChildren2 = ((Component)transform).GetComponentsInChildren<MeshFilter>(includeInactive);
			foreach (MeshFilter val in componentsInChildren2)
			{
				if (Object.op_Implicit((Object)(object)val.sharedMesh))
				{
					Matrix4x4 matrix2 = transform.worldToLocalMatrix * ((Component)val).transform.localToWorldMatrix;
					Bounds bounds2 = val.sharedMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds2.Transform(matrix2));
				}
			}
			SkinnedMeshRenderer[] componentsInChildren3 = ((Component)transform).GetComponentsInChildren<SkinnedMeshRenderer>(includeInactive);
			foreach (SkinnedMeshRenderer val2 in componentsInChildren3)
			{
				if (Object.op_Implicit((Object)(object)val2.sharedMesh))
				{
					Matrix4x4 matrix3 = transform.worldToLocalMatrix * ((Component)val2).transform.localToWorldMatrix;
					Bounds bounds3 = val2.sharedMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds3.Transform(matrix3));
				}
			}
		}
		if (includeColliders)
		{
			MeshCollider[] componentsInChildren4 = ((Component)transform).GetComponentsInChildren<MeshCollider>(includeInactive);
			foreach (MeshCollider val3 in componentsInChildren4)
			{
				if (Object.op_Implicit((Object)(object)val3.sharedMesh) && !((Collider)val3).isTrigger)
				{
					Matrix4x4 matrix4 = transform.worldToLocalMatrix * ((Component)val3).transform.localToWorldMatrix;
					Bounds bounds4 = val3.sharedMesh.bounds;
					((Bounds)(ref result)).Encapsulate(bounds4.Transform(matrix4));
				}
			}
		}
		return result;
	}
}


using UnityEngine;
using UnityEngine.UI;

public static class UIEx
{
	public static Vector2 Unpivot(this RectTransform rect, Vector2 localPos)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		ref float x = ref localPos.x;
		float num = x;
		float x2 = rect.pivot.x;
		Rect rect2 = rect.rect;
		x = num + x2 * ((Rect)(ref rect2)).width;
		ref float y = ref localPos.y;
		float num2 = y;
		float y2 = rect.pivot.y;
		rect2 = rect.rect;
		y = num2 + y2 * ((Rect)(ref rect2)).height;
		return localPos;
	}

	public static void CenterOnPosition(this ScrollRect scrollrect, Vector2 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)scrollrect).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(((Transform)scrollrect.content).localScale.x, ((Transform)scrollrect.content).localScale.y);
		pos.x *= val2.x;
		pos.y *= val2.y;
		Rect rect = scrollrect.content.rect;
		float num = ((Rect)(ref rect)).width * val2.x;
		rect = val.rect;
		float num2 = num - ((Rect)(ref rect)).width;
		rect = scrollrect.content.rect;
		float num3 = ((Rect)(ref rect)).height * val2.y;
		rect = val.rect;
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(num2, num3 - ((Rect)(ref rect)).height);
		pos.x = pos.x / val3.x + scrollrect.content.pivot.x;
		pos.y = pos.y / val3.y + scrollrect.content.pivot.y;
		if ((int)scrollrect.movementType != 0)
		{
			pos.x = Mathf.Clamp(pos.x, 0f, 1f);
			pos.y = Mathf.Clamp(pos.y, 0f, 1f);
		}
		scrollrect.normalizedPosition = pos;
	}

	public static void RebuildHackUnity2019(this Image image)
	{
		Sprite sprite = image.sprite;
		image.sprite = null;
		image.sprite = sprite;
	}
}


using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.Jobs;

public static class JobEx
{
	public static int GetBatchSize(int length)
	{
		return Mathf.Max(length / JobsUtility.JobWorkerCount, 64);
	}

	public static JobHandle ScheduleParallel<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobFor
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return IJobForExtensions.ScheduleParallel<T>(jobData, arrayLength, GetBatchSize(arrayLength), dependsOn);
	}

	public static JobHandle ScheduleParallelByRef<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobFor
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return IJobForExtensions.ScheduleParallelByRef<T>(ref jobData, arrayLength, GetBatchSize(arrayLength), dependsOn);
	}

	public static JobHandle ScheduleParallelReadOnly<T>(this ref T jobData, TransformAccessArray transforms, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForTransform
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForTransformExtensions.ScheduleReadOnly<T>(jobData, transforms, GetBatchSize(((TransformAccessArray)(ref transforms)).length), dependsOn);
	}

	public static JobHandle ScheduleParallelReadOnlyByRef<T>(this ref T jobData, TransformAccessArray transforms, JobHandle dependsOn = default(JobHandle)) where T : struct, IJobParallelForTransform
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForTransformExtensions.ScheduleReadOnlyByRef<T>(ref jobData, transforms, GetBatchSize(((TransformAccessArray)(ref transforms)).length), dependsOn);
	}
}


using Unity.Jobs;
using UnityEngine.Jobs;

public static class ParallelJobEx
{
	public static JobHandle ScheduleParallel<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobParallelFor
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForExtensions.Schedule<T>(jobData, arrayLength, JobEx.GetBatchSize(arrayLength), dependsOn);
	}

	public static JobHandle ScheduleParallelByRef<T>(this ref T jobData, int arrayLength, JobHandle dependsOn) where T : struct, IJobParallelFor
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return IJobParallelForExtensions.ScheduleByRef<T>(ref jobData, arrayLength, JobEx.GetBatchSize(arrayLength), dependsOn);
	}
}


using System;
using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[ExecuteInEditMode]
[AddComponentMenu("UI/Scroll Rect Ex", 37)]
[SelectionBase]
[RequireComponent(typeof(RectTransform))]
public class ScrollRectEx : UIBehaviour, IInitializePotentialDragHandler, IEventSystemHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutGroup, ILayoutController
{
	public enum MovementType
	{
		Unrestricted,
		Elastic,
		Clamped
	}

	public enum ScrollbarVisibility
	{
		Permanent,
		AutoHide,
		AutoHideAndExpandViewport
	}

	[Serializable]
	public class ScrollRectEvent : UnityEvent<Vector2>
	{
	}

	public InputButton scrollButton;

	public InputButton altScrollButton;

	[SerializeField]
	private RectTransform m_Content;

	[SerializeField]
	private bool m_Horizontal = true;

	[SerializeField]
	private bool m_Vertical = true;

	[SerializeField]
	private MovementType m_MovementType = MovementType.Elastic;

	[SerializeField]
	private float m_Elasticity = 0.1f;

	[SerializeField]
	private bool m_Inertia = true;

	[SerializeField]
	private float m_DecelerationRate = 0.135f;

	[SerializeField]
	private float m_ScrollSensitivity = 1f;

	[SerializeField]
	private RectTransform m_Viewport;

	[SerializeField]
	private Scrollbar m_HorizontalScrollbar;

	[SerializeField]
	private Scrollbar m_VerticalScrollbar;

	[SerializeField]
	private ScrollbarVisibility m_HorizontalScrollbarVisibility;

	[SerializeField]
	private ScrollbarVisibility m_VerticalScrollbarVisibility;

	[SerializeField]
	private float m_HorizontalScrollbarSpacing;

	[SerializeField]
	private float m_VerticalScrollbarSpacing;

	[SerializeField]
	private ScrollRectEvent m_OnValueChanged = new ScrollRectEvent();

	private Vector2 m_PointerStartLocalCursor = Vector2.zero;

	private Vector2 m_ContentStartPosition = Vector2.zero;

	private RectTransform m_ViewRect;

	private Bounds m_ContentBounds;

	private Bounds m_ViewBounds;

	private Vector2 m_Velocity;

	private bool m_Dragging;

	private Vector2 m_PrevPosition = Vector2.zero;

	private Bounds m_PrevContentBounds;

	private Bounds m_PrevViewBounds;

	[NonSerialized]
	private bool m_HasRebuiltLayout;

	private bool m_HSliderExpand;

	private bool m_VSliderExpand;

	private float m_HSliderHeight;

	private float m_VSliderWidth;

	[NonSerialized]
	private RectTransform m_Rect;

	private RectTransform m_HorizontalScrollbarRect;

	private RectTransform m_VerticalScrollbarRect;

	private DrivenRectTransformTracker m_Tracker;

	private readonly Vector3[] m_Corners = (Vector3[])(object)new Vector3[4];

	public RectTransform content
	{
		get
		{
			return m_Content;
		}
		set
		{
			m_Content = value;
		}
	}

	public bool horizontal
	{
		get
		{
			return m_Horizontal;
		}
		set
		{
			m_Horizontal = value;
		}
	}

	public bool vertical
	{
		get
		{
			return m_Vertical;
		}
		set
		{
			m_Vertical = value;
		}
	}

	public MovementType movementType
	{
		get
		{
			return m_MovementType;
		}
		set
		{
			m_MovementType = value;
		}
	}

	public float elasticity
	{
		get
		{
			return m_Elasticity;
		}
		set
		{
			m_Elasticity = value;
		}
	}

	public bool inertia
	{
		get
		{
			return m_Inertia;
		}
		set
		{
			m_Inertia = value;
		}
	}

	public float decelerationRate
	{
		get
		{
			return m_DecelerationRate;
		}
		set
		{
			m_DecelerationRate = value;
		}
	}

	public float scrollSensitivity
	{
		get
		{
			return m_ScrollSensitivity;
		}
		set
		{
			m_ScrollSensitivity = value;
		}
	}

	public RectTransform viewport
	{
		get
		{
			return m_Viewport;
		}
		set
		{
			m_Viewport = value;
			SetDirtyCaching();
		}
	}

	public Scrollbar horizontalScrollbar
	{
		get
		{
			return m_HorizontalScrollbar;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
			{
				((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetHorizontalNormalizedPosition);
			}
			m_HorizontalScrollbar = value;
			if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
			{
				((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetHorizontalNormalizedPosition);
			}
			SetDirtyCaching();
		}
	}

	public Scrollbar verticalScrollbar
	{
		get
		{
			return m_VerticalScrollbar;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
			{
				((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetVerticalNormalizedPosition);
			}
			m_VerticalScrollbar = value;
			if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
			{
				((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetVerticalNormalizedPosition);
			}
			SetDirtyCaching();
		}
	}

	public ScrollbarVisibility horizontalScrollbarVisibility
	{
		get
		{
			return m_HorizontalScrollbarVisibility;
		}
		set
		{
			m_HorizontalScrollbarVisibility = value;
			SetDirtyCaching();
		}
	}

	public ScrollbarVisibility verticalScrollbarVisibility
	{
		get
		{
			return m_VerticalScrollbarVisibility;
		}
		set
		{
			m_VerticalScrollbarVisibility = value;
			SetDirtyCaching();
		}
	}

	public float horizontalScrollbarSpacing
	{
		get
		{
			return m_HorizontalScrollbarSpacing;
		}
		set
		{
			m_HorizontalScrollbarSpacing = value;
			SetDirty();
		}
	}

	public float verticalScrollbarSpacing
	{
		get
		{
			return m_VerticalScrollbarSpacing;
		}
		set
		{
			m_VerticalScrollbarSpacing = value;
			SetDirty();
		}
	}

	public ScrollRectEvent onValueChanged
	{
		get
		{
			return m_OnValueChanged;
		}
		set
		{
			m_OnValueChanged = value;
		}
	}

	protected RectTransform viewRect
	{
		get
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Expected O, but got Unknown
			if ((Object)(object)m_ViewRect == (Object)null)
			{
				m_ViewRect = m_Viewport;
			}
			if ((Object)(object)m_ViewRect == (Object)null)
			{
				m_ViewRect = (RectTransform)((Component)this).transform;
			}
			return m_ViewRect;
		}
	}

	public Vector2 velocity
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_Velocity;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_Velocity = value;
		}
	}

	private RectTransform rectTransform
	{
		get
		{
			if ((Object)(object)m_Rect == (Object)null)
			{
				m_Rect = ((Component)this).GetComponent<RectTransform>();
			}
			return m_Rect;
		}
	}

	public Vector2 normalizedPosition
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return new Vector2(horizontalNormalizedPosition, verticalNormalizedPosition);
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			SetNormalizedPosition(value.x, 0);
			SetNormalizedPosition(value.y, 1);
		}
	}

	public float horizontalNormalizedPosition
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			UpdateBounds();
			if (((Bounds)(ref m_ContentBounds)).size.x <= ((Bounds)(ref m_ViewBounds)).size.x)
			{
				return (((Bounds)(ref m_ViewBounds)).min.x > ((Bounds)(ref m_ContentBounds)).min.x) ? 1 : 0;
			}
			return (((Bounds)(ref m_ViewBounds)).min.x - ((Bounds)(ref m_ContentBounds)).min.x) / (((Bounds)(ref m_ContentBounds)).size.x - ((Bounds)(ref m_ViewBounds)).size.x);
		}
		set
		{
			SetNormalizedPosition(value, 0);
		}
	}

	public float verticalNormalizedPosition
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			UpdateBounds();
			if (((Bounds)(ref m_ContentBounds)).size.y <= ((Bounds)(ref m_ViewBounds)).size.y)
			{
				return (((Bounds)(ref m_ViewBounds)).min.y > ((Bounds)(ref m_ContentBounds)).min.y) ? 1 : 0;
			}
			return (((Bounds)(ref m_ViewBounds)).min.y - ((Bounds)(ref m_ContentBounds)).min.y) / (((Bounds)(ref m_ContentBounds)).size.y - ((Bounds)(ref m_ViewBounds)).size.y);
		}
		set
		{
			SetNormalizedPosition(value, 1);
		}
	}

	private bool hScrollingNeeded
	{
		get
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (Application.isPlaying)
			{
				return ((Bounds)(ref m_ContentBounds)).size.x > ((Bounds)(ref m_ViewBounds)).size.x + 0.01f;
			}
			return true;
		}
	}

	private bool vScrollingNeeded
	{
		get
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (Application.isPlaying)
			{
				return ((Bounds)(ref m_ContentBounds)).size.y > ((Bounds)(ref m_ViewBounds)).size.y + 0.01f;
			}
			return true;
		}
	}

	public Rect normalizedViewRect
	{
		get
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			UpdateBounds();
			Vector3 val = Vector3Ex.Inverse(((Bounds)(ref m_ContentBounds)).size);
			Vector3 val2 = Vector3.Scale(Vector3Ex.Abs(((Bounds)(ref m_ContentBounds)).center - ((Bounds)(ref m_ContentBounds)).extents) + new Vector3(0f - ((Bounds)(ref m_ViewBounds)).extents.x, ((Bounds)(ref m_ViewBounds)).extents.y), val);
			Vector3 val3 = Vector3.Scale(((Bounds)(ref m_ViewBounds)).size, val);
			return new Rect(Vector2.op_Implicit(val2), Vector2.op_Implicit(val3));
		}
	}

	protected ScrollRectEx()
	{
	}//IL_0049: Unknown result type (might be due to invalid IL or missing references)
	//IL_004e: Unknown result type (might be due to invalid IL or missing references)
	//IL_0054: Unknown result type (might be due to invalid IL or missing references)
	//IL_0059: Unknown result type (might be due to invalid IL or missing references)
	//IL_005f: Unknown result type (might be due to invalid IL or missing references)
	//IL_0064: Unknown result type (might be due to invalid IL or missing references)


	public virtual void Rebuild(CanvasUpdate executing)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Invalid comparison between Unknown and I4
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((int)executing == 0)
		{
			UpdateCachedData();
		}
		if ((int)executing == 2)
		{
			UpdateBounds();
			UpdateScrollbars(Vector2.zero);
			UpdatePrevData();
			m_HasRebuiltLayout = true;
		}
	}

	private void UpdateCachedData()
	{
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		m_HorizontalScrollbarRect = (RectTransform)(((Object)(object)m_HorizontalScrollbar == (Object)null) ? null : /*isinst with value type is only supported in some contexts*/);
		m_VerticalScrollbarRect = (RectTransform)(((Object)(object)m_VerticalScrollbar == (Object)null) ? null : /*isinst with value type is only supported in some contexts*/);
		bool num = (Object)(object)((Transform)viewRect).parent == (Object)(object)transform;
		bool flag = !Object.op_Implicit((Object)(object)m_HorizontalScrollbarRect) || (Object)(object)((Transform)m_HorizontalScrollbarRect).parent == (Object)(object)transform;
		bool flag2 = !Object.op_Implicit((Object)(object)m_VerticalScrollbarRect) || (Object)(object)((Transform)m_VerticalScrollbarRect).parent == (Object)(object)transform;
		bool flag3 = num && flag && flag2;
		m_HSliderExpand = flag3 && Object.op_Implicit((Object)(object)m_HorizontalScrollbarRect) && horizontalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
		m_VSliderExpand = flag3 && Object.op_Implicit((Object)(object)m_VerticalScrollbarRect) && verticalScrollbarVisibility == ScrollbarVisibility.AutoHideAndExpandViewport;
		Rect rect;
		float hSliderHeight;
		if (!((Object)(object)m_HorizontalScrollbarRect == (Object)null))
		{
			rect = m_HorizontalScrollbarRect.rect;
			hSliderHeight = ((Rect)(ref rect)).height;
		}
		else
		{
			hSliderHeight = 0f;
		}
		m_HSliderHeight = hSliderHeight;
		float vSliderWidth;
		if (!((Object)(object)m_VerticalScrollbarRect == (Object)null))
		{
			rect = m_VerticalScrollbarRect.rect;
			vSliderWidth = ((Rect)(ref rect)).width;
		}
		else
		{
			vSliderWidth = 0f;
		}
		m_VSliderWidth = vSliderWidth;
	}

	protected override void OnEnable()
	{
		((UIBehaviour)this).OnEnable();
		if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
		{
			((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetHorizontalNormalizedPosition);
		}
		if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
		{
			((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).AddListener((UnityAction<float>)SetVerticalNormalizedPosition);
		}
		CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild((ICanvasElement)(object)this);
	}

	protected override void OnDisable()
	{
		if (!Application.isQuitting)
		{
			CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild((ICanvasElement)(object)this);
			if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
			{
				((UnityEvent<float>)(object)m_HorizontalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetHorizontalNormalizedPosition);
			}
			if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
			{
				((UnityEvent<float>)(object)m_VerticalScrollbar.onValueChanged).RemoveListener((UnityAction<float>)SetVerticalNormalizedPosition);
			}
			m_HasRebuiltLayout = false;
			((DrivenRectTransformTracker)(ref m_Tracker)).Clear();
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
			((UIBehaviour)this).OnDisable();
		}
	}

	public override bool IsActive()
	{
		if (((UIBehaviour)this).IsActive())
		{
			return (Object)(object)m_Content != (Object)null;
		}
		return false;
	}

	private void EnsureLayoutHasRebuilt()
	{
		if (!m_HasRebuiltLayout && !CanvasUpdateRegistry.IsRebuildingLayout())
		{
			Canvas.ForceUpdateCanvases();
		}
	}

	public virtual void StopMovement()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		m_Velocity = Vector2.zero;
	}

	public virtual void OnScroll(PointerEventData data)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (!((UIBehaviour)this).IsActive())
		{
			return;
		}
		EnsureLayoutHasRebuilt();
		UpdateBounds();
		Vector2 scrollDelta = data.scrollDelta;
		scrollDelta.y *= -1f;
		if (vertical && !horizontal)
		{
			if (Mathf.Abs(scrollDelta.x) > Mathf.Abs(scrollDelta.y))
			{
				scrollDelta.y = scrollDelta.x;
			}
			scrollDelta.x = 0f;
		}
		if (horizontal && !vertical)
		{
			if (Mathf.Abs(scrollDelta.y) > Mathf.Abs(scrollDelta.x))
			{
				scrollDelta.x = scrollDelta.y;
			}
			scrollDelta.y = 0f;
		}
		Vector2 anchoredPosition = m_Content.anchoredPosition;
		anchoredPosition += scrollDelta * m_ScrollSensitivity;
		if (m_MovementType == MovementType.Clamped)
		{
			anchoredPosition += CalculateOffset(anchoredPosition - m_Content.anchoredPosition);
		}
		SetContentAnchoredPosition(anchoredPosition);
		UpdateBounds();
	}

	public virtual void OnInitializePotentialDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (eventData.button == scrollButton || eventData.button == altScrollButton)
		{
			m_Velocity = Vector2.zero;
		}
	}

	public virtual void OnBeginDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if ((eventData.button == scrollButton || eventData.button == altScrollButton) && ((UIBehaviour)this).IsActive())
		{
			UpdateBounds();
			m_PointerStartLocalCursor = Vector2.zero;
			RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, ref m_PointerStartLocalCursor);
			m_ContentStartPosition = m_Content.anchoredPosition;
			m_Dragging = true;
		}
	}

	public virtual void OnEndDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (eventData.button == scrollButton || eventData.button == altScrollButton)
		{
			m_Dragging = false;
		}
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		if ((eventData.button != scrollButton && eventData.button != altScrollButton) || !((UIBehaviour)this).IsActive() || !RectTransformUtility.ScreenPointToLocalPointInRectangle(viewRect, eventData.position, eventData.pressEventCamera, ref val))
		{
			return;
		}
		UpdateBounds();
		Vector2 val2 = val - m_PointerStartLocalCursor;
		Vector2 val3 = m_ContentStartPosition + val2;
		Vector2 val4 = CalculateOffset(val3 - m_Content.anchoredPosition);
		val3 += val4;
		if (m_MovementType == MovementType.Elastic)
		{
			if (val4.x != 0f)
			{
				val3.x -= RubberDelta(val4.x, ((Bounds)(ref m_ViewBounds)).size.x);
			}
			if (val4.y != 0f)
			{
				val3.y -= RubberDelta(val4.y, ((Bounds)(ref m_ViewBounds)).size.y);
			}
		}
		SetContentAnchoredPosition(val3);
	}

	protected virtual void SetContentAnchoredPosition(Vector2 position)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (!m_Horizontal)
		{
			position.x = m_Content.anchoredPosition.x;
		}
		if (!m_Vertical)
		{
			position.y = m_Content.anchoredPosition.y;
		}
		if (position != m_Content.anchoredPosition)
		{
			m_Content.anchoredPosition = position;
			UpdateBounds();
		}
	}

	protected virtual void LateUpdate()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)m_Content))
		{
			return;
		}
		EnsureLayoutHasRebuilt();
		UpdateScrollbarVisibility();
		UpdateBounds();
		float unscaledDeltaTime = Time.unscaledDeltaTime;
		Vector2 val = CalculateOffset(Vector2.zero);
		if (!m_Dragging && (val != Vector2.zero || m_Velocity != Vector2.zero))
		{
			Vector2 val2 = m_Content.anchoredPosition;
			for (int i = 0; i < 2; i++)
			{
				if (m_MovementType == MovementType.Elastic && ((Vector2)(ref val))[i] != 0f)
				{
					float num = ((Vector2)(ref m_Velocity))[i];
					int num2 = i;
					Vector2 anchoredPosition = m_Content.anchoredPosition;
					float num3 = ((Vector2)(ref anchoredPosition))[i];
					anchoredPosition = m_Content.anchoredPosition;
					((Vector2)(ref val2))[num2] = Mathf.SmoothDamp(num3, ((Vector2)(ref anchoredPosition))[i] + ((Vector2)(ref val))[i], ref num, m_Elasticity, float.PositiveInfinity, unscaledDeltaTime);
					((Vector2)(ref m_Velocity))[i] = num;
				}
				else if (m_Inertia)
				{
					ref Vector2 reference = ref m_Velocity;
					int num4 = i;
					((Vector2)(ref reference))[num4] = ((Vector2)(ref reference))[num4] * Mathf.Pow(m_DecelerationRate, unscaledDeltaTime);
					if (Mathf.Abs(((Vector2)(ref m_Velocity))[i]) < 1f)
					{
						((Vector2)(ref m_Velocity))[i] = 0f;
					}
					reference = ref val2;
					num4 = i;
					((Vector2)(ref reference))[num4] = ((Vector2)(ref reference))[num4] + ((Vector2)(ref m_Velocity))[i] * unscaledDeltaTime;
				}
				else
				{
					((Vector2)(ref m_Velocity))[i] = 0f;
				}
			}
			if (m_Velocity != Vector2.zero)
			{
				if (m_MovementType == MovementType.Clamped)
				{
					val = CalculateOffset(val2 - m_Content.anchoredPosition);
					val2 += val;
				}
				SetContentAnchoredPosition(val2);
			}
		}
		if (m_Dragging && m_Inertia)
		{
			Vector3 val3 = Vector2.op_Implicit((m_Content.anchoredPosition - m_PrevPosition) / unscaledDeltaTime);
			m_Velocity = Vector2.op_Implicit(Vector3.Lerp(Vector2.op_Implicit(m_Velocity), val3, unscaledDeltaTime * 10f));
		}
		if (m_ViewBounds != m_PrevViewBounds || m_ContentBounds != m_PrevContentBounds || m_Content.anchoredPosition != m_PrevPosition)
		{
			UpdateScrollbars(val);
			((UnityEvent<Vector2>)m_OnValueChanged).Invoke(normalizedPosition);
			UpdatePrevData();
		}
	}

	private void UpdatePrevData()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_Content == (Object)null)
		{
			m_PrevPosition = Vector2.zero;
		}
		else
		{
			m_PrevPosition = m_Content.anchoredPosition;
		}
		m_PrevViewBounds = m_ViewBounds;
		m_PrevContentBounds = m_ContentBounds;
	}

	private void UpdateScrollbars(Vector2 offset)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
		{
			if (((Bounds)(ref m_ContentBounds)).size.x > 0f)
			{
				m_HorizontalScrollbar.size = Mathf.Clamp01((((Bounds)(ref m_ViewBounds)).size.x - Mathf.Abs(offset.x)) / ((Bounds)(ref m_ContentBounds)).size.x);
			}
			else
			{
				m_HorizontalScrollbar.size = 1f;
			}
			m_HorizontalScrollbar.value = horizontalNormalizedPosition;
		}
		if (Object.op_Implicit((Object)(object)m_VerticalScrollbar))
		{
			if (((Bounds)(ref m_ContentBounds)).size.y > 0f)
			{
				m_VerticalScrollbar.size = Mathf.Clamp01((((Bounds)(ref m_ViewBounds)).size.y - Mathf.Abs(offset.y)) / ((Bounds)(ref m_ContentBounds)).size.y);
			}
			else
			{
				m_VerticalScrollbar.size = 1f;
			}
			m_VerticalScrollbar.value = verticalNormalizedPosition;
		}
	}

	private void SetHorizontalNormalizedPosition(float value)
	{
		SetNormalizedPosition(value, 0);
	}

	private void SetVerticalNormalizedPosition(float value)
	{
		SetNormalizedPosition(value, 1);
	}

	private void SetNormalizedPosition(float value, int axis)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		EnsureLayoutHasRebuilt();
		UpdateBounds();
		Vector3 val = ((Bounds)(ref m_ContentBounds)).size;
		float num = ((Vector3)(ref val))[axis];
		val = ((Bounds)(ref m_ViewBounds)).size;
		float num2 = num - ((Vector3)(ref val))[axis];
		val = ((Bounds)(ref m_ViewBounds)).min;
		float num3 = ((Vector3)(ref val))[axis] - value * num2;
		val = ((Transform)m_Content).localPosition;
		float num4 = ((Vector3)(ref val))[axis] + num3;
		val = ((Bounds)(ref m_ContentBounds)).min;
		float num5 = num4 - ((Vector3)(ref val))[axis];
		Vector3 localPosition = ((Transform)m_Content).localPosition;
		if (Mathf.Abs(((Vector3)(ref localPosition))[axis] - num5) > 0.01f)
		{
			((Vector3)(ref localPosition))[axis] = num5;
			((Transform)m_Content).localPosition = localPosition;
			((Vector2)(ref m_Velocity))[axis] = 0f;
			UpdateBounds();
		}
	}

	private static float RubberDelta(float overStretching, float viewSize)
	{
		return (1f - 1f / (Mathf.Abs(overStretching) * 0.55f / viewSize + 1f)) * viewSize * Mathf.Sign(overStretching);
	}

	protected override void OnRectTransformDimensionsChange()
	{
		SetDirty();
	}

	public virtual void SetLayoutHorizontal()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		((DrivenRectTransformTracker)(ref m_Tracker)).Clear();
		Rect rect;
		if (m_HSliderExpand || m_VSliderExpand)
		{
			((DrivenRectTransformTracker)(ref m_Tracker)).Add((Object)(object)this, viewRect, (DrivenTransformProperties)16134);
			viewRect.anchorMin = Vector2.zero;
			viewRect.anchorMax = Vector2.one;
			viewRect.sizeDelta = Vector2.zero;
			viewRect.anchoredPosition = Vector2.zero;
			LayoutRebuilder.ForceRebuildLayoutImmediate(content);
			rect = viewRect.rect;
			Vector3 val = Vector2.op_Implicit(((Rect)(ref rect)).center);
			rect = viewRect.rect;
			m_ViewBounds = new Bounds(val, Vector2.op_Implicit(((Rect)(ref rect)).size));
			m_ContentBounds = GetBounds();
		}
		if (m_VSliderExpand && vScrollingNeeded)
		{
			viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
			LayoutRebuilder.ForceRebuildLayoutImmediate(content);
			rect = viewRect.rect;
			Vector3 val2 = Vector2.op_Implicit(((Rect)(ref rect)).center);
			rect = viewRect.rect;
			m_ViewBounds = new Bounds(val2, Vector2.op_Implicit(((Rect)(ref rect)).size));
			m_ContentBounds = GetBounds();
		}
		if (m_HSliderExpand && hScrollingNeeded)
		{
			viewRect.sizeDelta = new Vector2(viewRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
			rect = viewRect.rect;
			Vector3 val3 = Vector2.op_Implicit(((Rect)(ref rect)).center);
			rect = viewRect.rect;
			m_ViewBounds = new Bounds(val3, Vector2.op_Implicit(((Rect)(ref rect)).size));
			m_ContentBounds = GetBounds();
		}
		if (m_VSliderExpand && vScrollingNeeded && viewRect.sizeDelta.x == 0f && viewRect.sizeDelta.y < 0f)
		{
			viewRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), viewRect.sizeDelta.y);
		}
	}

	public virtual void SetLayoutVertical()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		UpdateScrollbarLayout();
		Rect rect = viewRect.rect;
		Vector3 val = Vector2.op_Implicit(((Rect)(ref rect)).center);
		rect = viewRect.rect;
		m_ViewBounds = new Bounds(val, Vector2.op_Implicit(((Rect)(ref rect)).size));
		m_ContentBounds = GetBounds();
	}

	private void UpdateScrollbarVisibility()
	{
		if (Object.op_Implicit((Object)(object)m_VerticalScrollbar) && m_VerticalScrollbarVisibility != 0 && ((Component)m_VerticalScrollbar).gameObject.activeSelf != vScrollingNeeded)
		{
			((Component)m_VerticalScrollbar).gameObject.SetActive(vScrollingNeeded);
		}
		if (Object.op_Implicit((Object)(object)m_HorizontalScrollbar) && m_HorizontalScrollbarVisibility != 0 && ((Component)m_HorizontalScrollbar).gameObject.activeSelf != hScrollingNeeded)
		{
			((Component)m_HorizontalScrollbar).gameObject.SetActive(hScrollingNeeded);
		}
	}

	private void UpdateScrollbarLayout()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		if (m_VSliderExpand && Object.op_Implicit((Object)(object)m_HorizontalScrollbar))
		{
			((DrivenRectTransformTracker)(ref m_Tracker)).Add((Object)(object)this, m_HorizontalScrollbarRect, (DrivenTransformProperties)5378);
			m_HorizontalScrollbarRect.anchorMin = new Vector2(0f, m_HorizontalScrollbarRect.anchorMin.y);
			m_HorizontalScrollbarRect.anchorMax = new Vector2(1f, m_HorizontalScrollbarRect.anchorMax.y);
			m_HorizontalScrollbarRect.anchoredPosition = new Vector2(0f, m_HorizontalScrollbarRect.anchoredPosition.y);
			if (vScrollingNeeded)
			{
				m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f - (m_VSliderWidth + m_VerticalScrollbarSpacing), m_HorizontalScrollbarRect.sizeDelta.y);
			}
			else
			{
				m_HorizontalScrollbarRect.sizeDelta = new Vector2(0f, m_HorizontalScrollbarRect.sizeDelta.y);
			}
		}
		if (m_HSliderExpand && Object.op_Implicit((Object)(object)m_VerticalScrollbar))
		{
			((DrivenRectTransformTracker)(ref m_Tracker)).Add((Object)(object)this, m_VerticalScrollbarRect, (DrivenTransformProperties)10756);
			m_VerticalScrollbarRect.anchorMin = new Vector2(m_VerticalScrollbarRect.anchorMin.x, 0f);
			m_VerticalScrollbarRect.anchorMax = new Vector2(m_VerticalScrollbarRect.anchorMax.x, 1f);
			m_VerticalScrollbarRect.anchoredPosition = new Vector2(m_VerticalScrollbarRect.anchoredPosition.x, 0f);
			if (hScrollingNeeded)
			{
				m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f - (m_HSliderHeight + m_HorizontalScrollbarSpacing));
			}
			else
			{
				m_VerticalScrollbarRect.sizeDelta = new Vector2(m_VerticalScrollbarRect.sizeDelta.x, 0f);
			}
		}
	}

	private void UpdateBounds()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = viewRect.rect;
		Vector3 val = Vector2.op_Implicit(((Rect)(ref rect)).center);
		rect = viewRect.rect;
		m_ViewBounds = new Bounds(val, Vector2.op_Implicit(((Rect)(ref rect)).size));
		m_ContentBounds = GetBounds();
		if (!((Object)(object)m_Content == (Object)null))
		{
			Vector3 size = ((Bounds)(ref m_ContentBounds)).size;
			Vector3 center = ((Bounds)(ref m_ContentBounds)).center;
			Vector3 val2 = ((Bounds)(ref m_ViewBounds)).size - size;
			if (val2.x > 0f)
			{
				center.x -= val2.x * (m_Content.pivot.x - 0.5f);
				size.x = ((Bounds)(ref m_ViewBounds)).size.x;
			}
			if (val2.y > 0f)
			{
				center.y -= val2.y * (m_Content.pivot.y - 0.5f);
				size.y = ((Bounds)(ref m_ViewBounds)).size.y;
			}
			((Bounds)(ref m_ContentBounds)).size = size;
			((Bounds)(ref m_ContentBounds)).center = center;
		}
	}

	private Bounds GetBounds()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_Content == (Object)null)
		{
			return default(Bounds);
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(float.MinValue, float.MinValue, float.MinValue);
		Matrix4x4 worldToLocalMatrix = ((Transform)viewRect).worldToLocalMatrix;
		m_Content.GetWorldCorners(m_Corners);
		for (int i = 0; i < 4; i++)
		{
			Vector3 val3 = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint3x4(m_Corners[i]);
			val = Vector3.Min(val3, val);
			val2 = Vector3.Max(val3, val2);
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result))..ctor(val, Vector3.zero);
		((Bounds)(ref result)).Encapsulate(val2);
		return result;
	}

	private Vector2 CalculateOffset(Vector2 delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		Vector2 zero = Vector2.zero;
		if (m_MovementType == MovementType.Unrestricted)
		{
			return zero;
		}
		Vector2 val = Vector2.op_Implicit(((Bounds)(ref m_ContentBounds)).min);
		Vector2 val2 = Vector2.op_Implicit(((Bounds)(ref m_ContentBounds)).max);
		if (m_Horizontal)
		{
			val.x += delta.x;
			val2.x += delta.x;
			if (val.x > ((Bounds)(ref m_ViewBounds)).min.x)
			{
				zero.x = ((Bounds)(ref m_ViewBounds)).min.x - val.x;
			}
			else if (val2.x < ((Bounds)(ref m_ViewBounds)).max.x)
			{
				zero.x = ((Bounds)(ref m_ViewBounds)).max.x - val2.x;
			}
		}
		if (m_Vertical)
		{
			val.y += delta.y;
			val2.y += delta.y;
			if (val2.y < ((Bounds)(ref m_ViewBounds)).max.y)
			{
				zero.y = ((Bounds)(ref m_ViewBounds)).max.y - val2.y;
			}
			else if (val.y > ((Bounds)(ref m_ViewBounds)).min.y)
			{
				zero.y = ((Bounds)(ref m_ViewBounds)).min.y - val.y;
			}
		}
		return zero;
	}

	protected void SetDirty()
	{
		if (((UIBehaviour)this).IsActive())
		{
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
		}
	}

	protected void SetDirtyCaching()
	{
		if (((UIBehaviour)this).IsActive())
		{
			CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild((ICanvasElement)(object)this);
			LayoutRebuilder.MarkLayoutForRebuild(rectTransform);
		}
	}

	public void CenterOnPosition(Vector2 pos)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(((Transform)content).localScale.x, ((Transform)content).localScale.y);
		pos.x *= val2.x;
		pos.y *= val2.y;
		Rect rect = content.rect;
		float num = ((Rect)(ref rect)).width * val2.x;
		rect = val.rect;
		float num2 = num - ((Rect)(ref rect)).width;
		rect = content.rect;
		float num3 = ((Rect)(ref rect)).height * val2.y;
		rect = val.rect;
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(num2, num3 - ((Rect)(ref rect)).height);
		pos.x = pos.x / val3.x + content.pivot.x;
		pos.y = pos.y / val3.y + content.pivot.y;
		if (movementType != 0)
		{
			pos.x = Mathf.Clamp(pos.x, 0f, 1f);
			pos.y = Mathf.Clamp(pos.y, 0f, 1f);
		}
		normalizedPosition = pos;
	}

	public void LayoutComplete()
	{
	}

	public void GraphicUpdateComplete()
	{
	}

	Transform ICanvasElement.get_transform()
	{
		return ((Component)this).transform;
	}
}


public enum MovementType
{
	Unrestricted,
	Elastic,
	Clamped
}


public enum ScrollbarVisibility
{
	Permanent,
	AutoHide,
	AutoHideAndExpandViewport
}


using System;
using UnityEngine.Events;

[Serializable]
public class ScrollRectEvent : UnityEvent<Vector2>
{
}


using UnityEngine.UI;

public class ScrollRectSettable : ScrollRect
{
	public void SetHorizNormalizedPosition(float value)
	{
		((ScrollRect)this).SetNormalizedPosition(value, 0);
	}

	public void SetVertNormalizedPosition(float value)
	{
		((ScrollRect)this).SetNormalizedPosition(value, 1);
	}
}


using System;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/Diamond Graph")]
public class DiamondGraph : UIPrimitiveBase
{
	[SerializeField]
	private float m_a = 1f;

	[SerializeField]
	private float m_b = 1f;

	[SerializeField]
	private float m_c = 1f;

	[SerializeField]
	private float m_d = 1f;

	public float A
	{
		get
		{
			return m_a;
		}
		set
		{
			m_a = value;
		}
	}

	public float B
	{
		get
		{
			return m_b;
		}
		set
		{
			m_b = value;
		}
	}

	public float C
	{
		get
		{
			return m_c;
		}
		set
		{
			m_c = value;
		}
	}

	public float D
	{
		get
		{
			return m_d;
		}
		set
		{
			m_d = value;
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		vh.Clear();
		Rect rect = ((Graphic)this).rectTransform.rect;
		float num = ((Rect)(ref rect)).width / 2f;
		m_a = Math.Min(1f, Math.Max(0f, m_a));
		m_b = Math.Min(1f, Math.Max(0f, m_b));
		m_c = Math.Min(1f, Math.Max(0f, m_c));
		m_d = Math.Min(1f, Math.Max(0f, m_d));
		Color32 val = Color32.op_Implicit(((Graphic)this).color);
		vh.AddVert(new Vector3((0f - num) * m_a, 0f), val, new Vector2(0f, 0f));
		vh.AddVert(new Vector3(0f, num * m_b), val, new Vector2(0f, 1f));
		vh.AddVert(new Vector3(num * m_c, 0f), val, new Vector2(1f, 1f));
		vh.AddVert(new Vector3(0f, (0f - num) * m_d), val, new Vector2(1f, 0f));
		vh.AddTriangle(0, 1, 2);
		vh.AddTriangle(2, 3, 0);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Circle")]
public class UICircle : UIPrimitiveBase
{
	[Tooltip("The Arc Invert property will invert the construction of the Arc.")]
	public bool ArcInvert = true;

	[Range(0f, 1f)]
	[Tooltip("The Arc property is a percentage of the entire circumference of the circle.")]
	public float Arc = 1f;

	[Range(0f, 1000f)]
	[Tooltip("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
	public int ArcSteps = 100;

	[Range(0f, 360f)]
	[Tooltip("The Arc Rotation property permits adjusting the geometry orientation around the Z axis.")]
	public int ArcRotation;

	[Tooltip("The Progress property allows the primitive to be used as a progression indicator.")]
	[Range(0f, 1f)]
	public float Progress;

	private float _progress;

	public Color ProgressColor = new Color(255f, 255f, 255f, 255f);

	public bool Fill = true;

	public float Thickness = 5f;

	public int Padding;

	private List<int> indices = new List<int>();

	private List<UIVertex> vertices = new List<UIVertex>();

	private Vector2 uvCenter = new Vector2(0.5f, 0.5f);

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_043d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		int num = ((!ArcInvert) ? 1 : (-1));
		Rect rect = ((Graphic)this).rectTransform.rect;
		float width = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float num2;
		if (!(width < ((Rect)(ref rect)).height))
		{
			rect = ((Graphic)this).rectTransform.rect;
			num2 = ((Rect)(ref rect)).height;
		}
		else
		{
			rect = ((Graphic)this).rectTransform.rect;
			num2 = ((Rect)(ref rect)).width;
		}
		float num3 = num2 - (float)Padding;
		float num4 = (0f - ((Graphic)this).rectTransform.pivot.x) * num3;
		float num5 = (0f - ((Graphic)this).rectTransform.pivot.x) * num3 + Thickness;
		vh.Clear();
		indices.Clear();
		vertices.Clear();
		int item = 0;
		int num6 = 1;
		int num7 = 0;
		float num8 = Arc * 360f / (float)ArcSteps;
		_progress = (float)ArcSteps * Progress;
		float num9 = (float)num * (MathF.PI / 180f) * (float)ArcRotation;
		float num10 = Mathf.Cos(num9);
		float num11 = Mathf.Sin(num9);
		UIVertex simpleVert = UIVertex.simpleVert;
		simpleVert.color = Color32.op_Implicit((_progress > 0f) ? ProgressColor : ((Graphic)this).color);
		simpleVert.position = Vector2.op_Implicit(new Vector2(num4 * num10, num4 * num11));
		simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f));
		vertices.Add(simpleVert);
		Vector2 zero = default(Vector2);
		((Vector2)(ref zero))..ctor(num5 * num10, num5 * num11);
		if (Fill)
		{
			zero = Vector2.zero;
		}
		simpleVert.position = Vector2.op_Implicit(zero);
		simpleVert.uv0 = Vector4.op_Implicit((Vector2)(Fill ? uvCenter : new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f)));
		vertices.Add(simpleVert);
		for (int i = 1; i <= ArcSteps; i++)
		{
			float num12 = (float)num * (MathF.PI / 180f) * ((float)i * num8 + (float)ArcRotation);
			num10 = Mathf.Cos(num12);
			num11 = Mathf.Sin(num12);
			simpleVert.color = Color32.op_Implicit(((float)i > _progress) ? ((Graphic)this).color : ProgressColor);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num4 * num10, num4 * num11));
			simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f));
			vertices.Add(simpleVert);
			if (!Fill)
			{
				simpleVert.position = Vector2.op_Implicit(new Vector2(num5 * num10, num5 * num11));
				simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num3 + 0.5f, simpleVert.position.y / num3 + 0.5f));
				vertices.Add(simpleVert);
				num7 = num6;
				indices.Add(item);
				indices.Add(num6 + 1);
				indices.Add(num6);
				num6++;
				item = num6;
				num6++;
				indices.Add(item);
				indices.Add(num6);
				indices.Add(num7);
			}
			else
			{
				indices.Add(item);
				indices.Add(num6 + 1);
				if ((float)i > _progress)
				{
					indices.Add(ArcSteps + 2);
				}
				else
				{
					indices.Add(1);
				}
				num6++;
				item = num6;
			}
		}
		if (Fill)
		{
			simpleVert.position = Vector2.op_Implicit(zero);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.uv0 = Vector4.op_Implicit(uvCenter);
			vertices.Add(simpleVert);
		}
		vh.AddUIVertexStream(vertices, indices);
	}

	public void SetProgress(float progress)
	{
		Progress = progress;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetArcSteps(int steps)
	{
		ArcSteps = steps;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetInvertArc(bool invert)
	{
		ArcInvert = invert;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetArcRotation(int rotation)
	{
		ArcRotation = rotation;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetFill(bool fill)
	{
		Fill = fill;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetBaseColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateBaseAlpha(float value)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((Graphic)this).color;
		color.a = value;
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetProgressColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ProgressColor = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateProgressAlpha(float value)
	{
		ProgressColor.a = value;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetPadding(int padding)
	{
		Padding = padding;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetThickness(int thickness)
	{
		Thickness = thickness;
		((Graphic)this).SetVerticesDirty();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Circle Simple")]
public class UICircleSimple : UIPrimitiveBase
{
	[Range(0f, 1000f)]
	[Tooltip("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
	public int ArcSteps = 100;

	public bool Fill = true;

	public float Thickness = 5f;

	public bool ThicknessIsOutside;

	private List<int> indices = new List<int>();

	private List<UIVertex> vertices = new List<UIVertex>();

	private Vector2 uvCenter = new Vector2(0.5f, 0.5f);

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((Graphic)this).rectTransform.rect;
		float width = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float num;
		if (!(width < ((Rect)(ref rect)).height))
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).height;
		}
		else
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).width;
		}
		float num2 = num;
		float num3 = (ThicknessIsOutside ? ((0f - ((Graphic)this).rectTransform.pivot.x) * num2 - Thickness) : ((0f - ((Graphic)this).rectTransform.pivot.x) * num2));
		float num4 = (ThicknessIsOutside ? ((0f - ((Graphic)this).rectTransform.pivot.x) * num2) : ((0f - ((Graphic)this).rectTransform.pivot.x) * num2 + Thickness));
		vh.Clear();
		indices.Clear();
		vertices.Clear();
		int item = 0;
		int num5 = 1;
		int num6 = 0;
		float num7 = 360f / (float)ArcSteps;
		float num8 = Mathf.Cos(0f);
		float num9 = Mathf.Sin(0f);
		UIVertex simpleVert = UIVertex.simpleVert;
		simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
		simpleVert.position = Vector2.op_Implicit(new Vector2(num3 * num8, num3 * num9));
		simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f));
		vertices.Add(simpleVert);
		Vector2 zero = default(Vector2);
		((Vector2)(ref zero))..ctor(num4 * num8, num4 * num9);
		if (Fill)
		{
			zero = Vector2.zero;
		}
		simpleVert.position = Vector2.op_Implicit(zero);
		simpleVert.uv0 = Vector4.op_Implicit((Vector2)(Fill ? uvCenter : new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f)));
		vertices.Add(simpleVert);
		for (int i = 1; i <= ArcSteps; i++)
		{
			float num10 = MathF.PI / 180f * ((float)i * num7);
			num8 = Mathf.Cos(num10);
			num9 = Mathf.Sin(num10);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num3 * num8, num3 * num9));
			simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f));
			vertices.Add(simpleVert);
			if (!Fill)
			{
				simpleVert.position = Vector2.op_Implicit(new Vector2(num4 * num8, num4 * num9));
				simpleVert.uv0 = Vector4.op_Implicit(new Vector2(simpleVert.position.x / num2 + 0.5f, simpleVert.position.y / num2 + 0.5f));
				vertices.Add(simpleVert);
				num6 = num5;
				indices.Add(item);
				indices.Add(num5 + 1);
				indices.Add(num5);
				num5++;
				item = num5;
				num5++;
				indices.Add(item);
				indices.Add(num5);
				indices.Add(num6);
			}
			else
			{
				indices.Add(item);
				indices.Add(num5 + 1);
				indices.Add(1);
				num5++;
				item = num5;
			}
		}
		if (Fill)
		{
			simpleVert.position = Vector2.op_Implicit(zero);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.uv0 = Vector4.op_Implicit(uvCenter);
			vertices.Add(simpleVert);
		}
		vh.AddUIVertexStream(vertices, indices);
	}

	public void SetArcSteps(int steps)
	{
		ArcSteps = steps;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetFill(bool fill)
	{
		Fill = fill;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetBaseColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateBaseAlpha(float value)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((Graphic)this).color;
		color.a = value;
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetThickness(int thickness)
	{
		Thickness = thickness;
		((Graphic)this).SetVerticesDirty();
	}
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/Cut Corners")]
public class UICornerCut : UIPrimitiveBase
{
	public Vector2 cornerSize = new Vector2(16f, 16f);

	[Header("Corners to cut")]
	[SerializeField]
	private bool m_cutUL = true;

	[SerializeField]
	private bool m_cutUR;

	[SerializeField]
	private bool m_cutLL;

	[SerializeField]
	private bool m_cutLR;

	[Tooltip("Up-Down colors become Left-Right colors")]
	[SerializeField]
	private bool m_makeColumns;

	[Header("Color the cut bars differently")]
	[SerializeField]
	private bool m_useColorUp;

	[SerializeField]
	private Color32 m_colorUp;

	[SerializeField]
	private bool m_useColorDown;

	[SerializeField]
	private Color32 m_colorDown;

	public bool CutUL
	{
		get
		{
			return m_cutUL;
		}
		set
		{
			m_cutUL = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool CutUR
	{
		get
		{
			return m_cutUR;
		}
		set
		{
			m_cutUR = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool CutLL
	{
		get
		{
			return m_cutLL;
		}
		set
		{
			m_cutLL = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool CutLR
	{
		get
		{
			return m_cutLR;
		}
		set
		{
			m_cutLR = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool MakeColumns
	{
		get
		{
			return m_makeColumns;
		}
		set
		{
			m_makeColumns = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool UseColorUp
	{
		get
		{
			return m_useColorUp;
		}
		set
		{
			m_useColorUp = value;
		}
	}

	public Color32 ColorUp
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_colorUp;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_colorUp = value;
		}
	}

	public bool UseColorDown
	{
		get
		{
			return m_useColorDown;
		}
		set
		{
			m_useColorDown = value;
		}
	}

	public Color32 ColorDown
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_colorDown;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			m_colorDown = value;
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036a: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((Graphic)this).rectTransform.rect;
		Rect val = rect;
		Color32 val2 = Color32.op_Implicit(((Graphic)this).color);
		bool flag = m_cutUL | m_cutUR;
		bool flag2 = m_cutLL | m_cutLR;
		bool flag3 = m_cutLL | m_cutUL;
		bool flag4 = m_cutLR | m_cutUR;
		if (!(flag || flag2) || !(((Vector2)(ref cornerSize)).sqrMagnitude > 0f))
		{
			return;
		}
		vh.Clear();
		if (flag3)
		{
			((Rect)(ref val)).xMin = ((Rect)(ref val)).xMin + cornerSize.x;
		}
		if (flag2)
		{
			((Rect)(ref val)).yMin = ((Rect)(ref val)).yMin + cornerSize.y;
		}
		if (flag)
		{
			((Rect)(ref val)).yMax = ((Rect)(ref val)).yMax - cornerSize.y;
		}
		if (flag4)
		{
			((Rect)(ref val)).xMax = ((Rect)(ref val)).xMax - cornerSize.x;
		}
		Vector2 val3 = default(Vector2);
		Vector2 val4 = default(Vector2);
		Vector2 val5 = default(Vector2);
		Vector2 val6 = default(Vector2);
		if (m_makeColumns)
		{
			((Vector2)(ref val3))..ctor(((Rect)(ref rect)).xMin, m_cutUL ? ((Rect)(ref val)).yMax : ((Rect)(ref rect)).yMax);
			((Vector2)(ref val4))..ctor(((Rect)(ref rect)).xMax, m_cutUR ? ((Rect)(ref val)).yMax : ((Rect)(ref rect)).yMax);
			((Vector2)(ref val5))..ctor(((Rect)(ref rect)).xMin, m_cutLL ? ((Rect)(ref val)).yMin : ((Rect)(ref rect)).yMin);
			((Vector2)(ref val6))..ctor(((Rect)(ref rect)).xMax, m_cutLR ? ((Rect)(ref val)).yMin : ((Rect)(ref rect)).yMin);
			if (flag3)
			{
				AddSquare(val5, val3, new Vector2(((Rect)(ref val)).xMin, ((Rect)(ref rect)).yMax), new Vector2(((Rect)(ref val)).xMin, ((Rect)(ref rect)).yMin), rect, m_useColorUp ? m_colorUp : val2, vh);
			}
			if (flag4)
			{
				AddSquare(val4, val6, new Vector2(((Rect)(ref val)).xMax, ((Rect)(ref rect)).yMin), new Vector2(((Rect)(ref val)).xMax, ((Rect)(ref rect)).yMax), rect, m_useColorDown ? m_colorDown : val2, vh);
			}
		}
		else
		{
			((Vector2)(ref val3))..ctor(m_cutUL ? ((Rect)(ref val)).xMin : ((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMax);
			((Vector2)(ref val4))..ctor(m_cutUR ? ((Rect)(ref val)).xMax : ((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMax);
			((Vector2)(ref val5))..ctor(m_cutLL ? ((Rect)(ref val)).xMin : ((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMin);
			((Vector2)(ref val6))..ctor(m_cutLR ? ((Rect)(ref val)).xMax : ((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMin);
			if (flag2)
			{
				AddSquare(val6, val5, new Vector2(((Rect)(ref rect)).xMin, ((Rect)(ref val)).yMin), new Vector2(((Rect)(ref rect)).xMax, ((Rect)(ref val)).yMin), rect, m_useColorDown ? m_colorDown : val2, vh);
			}
			if (flag)
			{
				AddSquare(val3, val4, new Vector2(((Rect)(ref rect)).xMax, ((Rect)(ref val)).yMax), new Vector2(((Rect)(ref rect)).xMin, ((Rect)(ref val)).yMax), rect, m_useColorUp ? m_colorUp : val2, vh);
			}
		}
		if (m_makeColumns)
		{
			AddSquare(new Rect(((Rect)(ref val)).xMin, ((Rect)(ref rect)).yMin, ((Rect)(ref val)).width, ((Rect)(ref rect)).height), rect, val2, vh);
		}
		else
		{
			AddSquare(new Rect(((Rect)(ref rect)).xMin, ((Rect)(ref val)).yMin, ((Rect)(ref rect)).width, ((Rect)(ref val)).height), rect, val2, vh);
		}
	}

	private static void AddSquare(Rect rect, Rect rectUV, Color32 color32, VertexHelper vh)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		int num = AddVert(((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMin, rectUV, color32, vh);
		int num2 = AddVert(((Rect)(ref rect)).xMin, ((Rect)(ref rect)).yMax, rectUV, color32, vh);
		int num3 = AddVert(((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMax, rectUV, color32, vh);
		int num4 = AddVert(((Rect)(ref rect)).xMax, ((Rect)(ref rect)).yMin, rectUV, color32, vh);
		vh.AddTriangle(num, num2, num3);
		vh.AddTriangle(num3, num4, num);
	}

	private static void AddSquare(Vector2 a, Vector2 b, Vector2 c, Vector2 d, Rect rectUV, Color32 color32, VertexHelper vh)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		int num = AddVert(a.x, a.y, rectUV, color32, vh);
		int num2 = AddVert(b.x, b.y, rectUV, color32, vh);
		int num3 = AddVert(c.x, c.y, rectUV, color32, vh);
		int num4 = AddVert(d.x, d.y, rectUV, color32, vh);
		vh.AddTriangle(num, num2, num3);
		vh.AddTriangle(num3, num4, num);
	}

	private static int AddVert(float x, float y, Rect area, Color32 color32, VertexHelper vh)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(Mathf.InverseLerp(((Rect)(ref area)).xMin, ((Rect)(ref area)).xMax, x), Mathf.InverseLerp(((Rect)(ref area)).yMin, ((Rect)(ref area)).yMax, y));
		vh.AddVert(new Vector3(x, y), color32, val);
		return vh.currentVertCount - 1;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class UIGoldenRatioRenderer : UILineRenderer
{
	private enum Orientations
	{
		Left,
		Top,
		Right,
		Bottom
	}

	private readonly List<Vector2> _points = new List<Vector2>();

	private readonly List<Rect> _rects = new List<Rect>();

	private int canvasWidth;

	private int canvasHeight;

	public float lineThickness2 = 1f;

	private void DrawSpiral(VertexHelper vh)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		_points.Clear();
		_rects.Clear();
		float num = (1f + Mathf.Sqrt(5f)) / 2f;
		Rect pixelRect = ((Graphic)this).canvas.pixelRect;
		canvasWidth = (int)((Rect)(ref pixelRect)).width;
		pixelRect = ((Graphic)this).canvas.pixelRect;
		canvasHeight = (int)((Rect)(ref pixelRect)).height;
		Orientations orientation;
		float num2;
		float num3;
		if (canvasWidth > canvasHeight)
		{
			orientation = Orientations.Left;
			if ((float)canvasWidth / (float)canvasHeight > num)
			{
				num2 = canvasHeight;
				num3 = num2 * num;
			}
			else
			{
				num3 = canvasWidth;
				num2 = num3 / num;
			}
		}
		else
		{
			orientation = Orientations.Top;
			if ((float)canvasHeight / (float)canvasWidth > num)
			{
				num3 = canvasWidth;
				num2 = num3 * num;
			}
			else
			{
				num2 = canvasHeight;
				num3 = num2 / num;
			}
		}
		float num4 = -canvasWidth / 2;
		float num5 = canvasHeight / 2;
		num4 += ((float)canvasWidth - num3) / 2f;
		num5 += ((float)canvasHeight - num2) / 2f;
		List<Vector2> list = new List<Vector2>();
		DrawPhiRectangles(vh, list, num4, num5, num3, num2, orientation);
		if (list.Count > 1)
		{
			Vector2 val = list[0];
			Vector2 val2 = list[list.Count - 1];
			float num6 = val.x - val2.x;
			float num7 = val.y - val2.y;
			float num8 = Mathf.Sqrt(num6 * num6 + num7 * num7);
			float num9 = Mathf.Atan2(num7, num6);
			float num10 = MathF.PI / 50f;
			float num11 = 1f - 1f / num / 25f * 0.78f;
			Vector2 item = default(Vector2);
			while (num8 > 32f)
			{
				((Vector2)(ref item))..ctor(val2.x + num8 * Mathf.Cos(num9), (float)canvasHeight - (val2.y + num8 * Mathf.Sin(num9)));
				_points.Add(item);
				num9 += num10;
				num8 *= num11;
			}
		}
	}

	private void DrawPhiRectangles(VertexHelper vh, List<Vector2> points, float x, float y, float width, float height, Orientations orientation)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!(width < 1f) && !(height < 1f))
		{
			if (width >= 10f && height >= 10f)
			{
				_rects.Add(new Rect(x, y, width, height));
			}
			switch (orientation)
			{
			case Orientations.Left:
				points.Add(new Vector2(x, y + height));
				x += height;
				width -= height;
				orientation = Orientations.Top;
				break;
			case Orientations.Top:
				points.Add(new Vector2(x, y));
				y += width;
				height -= width;
				orientation = Orientations.Right;
				break;
			case Orientations.Right:
				points.Add(new Vector2(x + width, y));
				width -= height;
				orientation = Orientations.Bottom;
				break;
			case Orientations.Bottom:
				points.Add(new Vector2(x + width, y + height));
				height -= width;
				orientation = Orientations.Left;
				break;
			}
			DrawPhiRectangles(vh, points, x, y, width, height, orientation);
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((Graphic)this).canvas == (Object)null)
		{
			return;
		}
		relativeSize = false;
		DrawSpiral(vh);
		m_points = _points.ToArray();
		base.OnPopulateMesh(vh);
		foreach (Rect rect in _rects)
		{
			Rect current = rect;
			DrawRect(vh, new Rect(((Rect)(ref current)).x, ((Rect)(ref current)).y - lineThickness2 * 0.5f, ((Rect)(ref current)).width, lineThickness2));
			DrawRect(vh, new Rect(((Rect)(ref current)).x - lineThickness2 * 0.5f, ((Rect)(ref current)).y, lineThickness2, ((Rect)(ref current)).height));
			DrawRect(vh, new Rect(((Rect)(ref current)).x, ((Rect)(ref current)).y + ((Rect)(ref current)).height - lineThickness2 * 0.5f, ((Rect)(ref current)).width, lineThickness2));
			DrawRect(vh, new Rect(((Rect)(ref current)).x + ((Rect)(ref current)).width - lineThickness2 * 0.5f, ((Rect)(ref current)).y, lineThickness2, ((Rect)(ref current)).height));
		}
	}

	private void DrawRect(VertexHelper vh, Rect rect)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		Vector2[] array = (Vector2[])(object)new Vector2[4]
		{
			new Vector2(((Rect)(ref rect)).x, ((Rect)(ref rect)).y),
			new Vector2(((Rect)(ref rect)).x + ((Rect)(ref rect)).width, ((Rect)(ref rect)).y),
			new Vector2(((Rect)(ref rect)).x + ((Rect)(ref rect)).width, ((Rect)(ref rect)).y + ((Rect)(ref rect)).height),
			new Vector2(((Rect)(ref rect)).x, ((Rect)(ref rect)).y + ((Rect)(ref rect)).height)
		};
		UIVertex[] array2 = (UIVertex[])(object)new UIVertex[4];
		for (int i = 0; i < array2.Length; i++)
		{
			UIVertex simpleVert = UIVertex.simpleVert;
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			Vector2 val = array[i];
			Rect pixelRect = ((Graphic)this).canvas.pixelRect;
			simpleVert.position = Vector2.op_Implicit(Vector2Ex.WithY(val, ((Rect)(ref pixelRect)).height - array[i].y));
			array2[i] = simpleVert;
		}
		vh.AddUIVertexQuad(array2);
	}
}


private enum Orientations
{
	Left,
	Top,
	Right,
	Bottom
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UIGridRenderer")]
public class UIGridRenderer : UILineRenderer
{
	[SerializeField]
	private int m_GridColumns = 10;

	[SerializeField]
	private int m_GridRows = 10;

	public int GridColumns
	{
		get
		{
			return m_GridColumns;
		}
		set
		{
			if (m_GridColumns != value)
			{
				m_GridColumns = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	public int GridRows
	{
		get
		{
			return m_GridRows;
		}
		set
		{
			if (m_GridRows != value)
			{
				m_GridRows = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		relativeSize = true;
		int num = GridRows * 3 + 1;
		if (GridRows % 2 == 0)
		{
			num++;
		}
		num += GridColumns * 3 + 1;
		m_points = (Vector2[])(object)new Vector2[num];
		int num2 = 0;
		for (int i = 0; i < GridRows; i++)
		{
			float x = 1f;
			float x2 = 0f;
			if (i % 2 == 0)
			{
				x = 0f;
				x2 = 1f;
			}
			float y = (float)i / (float)GridRows;
			m_points[num2].x = x;
			m_points[num2].y = y;
			num2++;
			m_points[num2].x = x2;
			m_points[num2].y = y;
			num2++;
			m_points[num2].x = x2;
			m_points[num2].y = (float)(i + 1) / (float)GridRows;
			num2++;
		}
		if (GridRows % 2 == 0)
		{
			m_points[num2].x = 1f;
			m_points[num2].y = 1f;
			num2++;
		}
		m_points[num2].x = 0f;
		m_points[num2].y = 1f;
		num2++;
		for (int j = 0; j < GridColumns; j++)
		{
			float y2 = 1f;
			float y3 = 0f;
			if (j % 2 == 0)
			{
				y2 = 0f;
				y3 = 1f;
			}
			float x3 = (float)j / (float)GridColumns;
			m_points[num2].x = x3;
			m_points[num2].y = y2;
			num2++;
			m_points[num2].x = x3;
			m_points[num2].y = y3;
			num2++;
			m_points[num2].x = (float)(j + 1) / (float)GridColumns;
			m_points[num2].y = y3;
			num2++;
		}
		if (GridColumns % 2 == 0)
		{
			m_points[num2].x = 1f;
			m_points[num2].y = 1f;
		}
		else
		{
			m_points[num2].x = 1f;
			m_points[num2].y = 0f;
		}
		base.OnPopulateMesh(vh);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Sprites;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UILineRenderer")]
[RequireComponent(typeof(RectTransform))]
public class UILineRenderer : UIPrimitiveBase
{
	private enum SegmentType
	{
		Start,
		Middle,
		End,
		Full
	}

	public enum JoinType
	{
		Bevel,
		Miter
	}

	public enum BezierType
	{
		None,
		Quick,
		Basic,
		Improved,
		Catenary
	}

	private const float MIN_MITER_JOIN = MathF.PI / 12f;

	private const float MIN_BEVEL_NICE_JOIN = MathF.PI / 6f;

	private static Vector2 UV_TOP_LEFT;

	private static Vector2 UV_BOTTOM_LEFT;

	private static Vector2 UV_TOP_CENTER_LEFT;

	private static Vector2 UV_TOP_CENTER_RIGHT;

	private static Vector2 UV_BOTTOM_CENTER_LEFT;

	private static Vector2 UV_BOTTOM_CENTER_RIGHT;

	private static Vector2 UV_TOP_RIGHT;

	private static Vector2 UV_BOTTOM_RIGHT;

	private static Vector2[] startUvs;

	private static Vector2[] middleUvs;

	private static Vector2[] endUvs;

	private static Vector2[] fullUvs;

	[SerializeField]
	[Tooltip("Points to draw lines between\n Can be improved using the Resolution Option")]
	internal Vector2[] m_points;

	[Tooltip("Segments to be drawn\n This is a list of arrays of points")]
	[SerializeField]
	internal List<Vector2[]> m_segments;

	[SerializeField]
	[Tooltip("Thickness of the line")]
	internal float lineThickness = 2f;

	[SerializeField]
	[Tooltip("Use the relative bounds of the Rect Transform (0,0 -> 0,1) or screen space coordinates")]
	internal bool relativeSize;

	[SerializeField]
	[Tooltip("Do the points identify a single line or split pairs of lines")]
	internal bool lineList;

	[SerializeField]
	[Tooltip("Add end caps to each line\nMultiple caps when used with Line List")]
	internal bool lineCaps;

	[SerializeField]
	[Tooltip("Resolution of the Bezier curve, different to line Resolution")]
	internal int bezierSegmentsPerCurve = 10;

	[Tooltip("The type of Join used between lines, Square/Mitre or Curved/Bevel")]
	public JoinType LineJoins;

	[Tooltip("Bezier method to apply to line, see docs for options\nCan't be used in conjunction with Resolution as Bezier already changes the resolution")]
	public BezierType BezierMode;

	[HideInInspector]
	public bool drivenExternally;

	public float LineThickness
	{
		get
		{
			return lineThickness;
		}
		set
		{
			lineThickness = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool RelativeSize
	{
		get
		{
			return relativeSize;
		}
		set
		{
			relativeSize = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineList
	{
		get
		{
			return lineList;
		}
		set
		{
			lineList = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineCaps
	{
		get
		{
			return lineCaps;
		}
		set
		{
			lineCaps = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public int BezierSegmentsPerCurve
	{
		get
		{
			return bezierSegmentsPerCurve;
		}
		set
		{
			bezierSegmentsPerCurve = value;
		}
	}

	public Vector2[] Points
	{
		get
		{
			return m_points;
		}
		set
		{
			if (m_points != value)
			{
				m_points = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	public List<Vector2[]> Segments
	{
		get
		{
			return m_segments;
		}
		set
		{
			m_segments = value;
			((Graphic)this).SetAllDirty();
		}
	}

	private void PopulateMesh(VertexHelper vh, Vector2[] pointsToDraw)
	{
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034a: Unknown result type (might be due to invalid IL or missing references)
		//IL_034f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_055e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0593: Unknown result type (might be due to invalid IL or missing references)
		//IL_0448: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_0478: Unknown result type (might be due to invalid IL or missing references)
		//IL_048e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_0517: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0531: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0501: Unknown result type (might be due to invalid IL or missing references)
		if (BezierMode != 0 && BezierMode != BezierType.Catenary && pointsToDraw.Length > 3)
		{
			BezierPath bezierPath = new BezierPath();
			bezierPath.SetControlPoints(pointsToDraw);
			bezierPath.SegmentsPerCurve = bezierSegmentsPerCurve;
			pointsToDraw = (BezierMode switch
			{
				BezierType.Basic => bezierPath.GetDrawingPoints0(), 
				BezierType.Improved => bezierPath.GetDrawingPoints1(), 
				_ => bezierPath.GetDrawingPoints2(), 
			}).ToArray();
		}
		if (BezierMode == BezierType.Catenary && pointsToDraw.Length == 2)
		{
			pointsToDraw = new CableCurve(pointsToDraw)
			{
				slack = base.Resoloution,
				steps = BezierSegmentsPerCurve
			}.Points();
		}
		if (base.ImproveResolution != 0)
		{
			pointsToDraw = IncreaseResolution(pointsToDraw);
		}
		Rect rect;
		float num;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).width;
		}
		else
		{
			num = 1f;
		}
		float num2 = num;
		float num3;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num3 = ((Rect)(ref rect)).height;
		}
		else
		{
			num3 = 1f;
		}
		float num4 = num3;
		float num5 = (0f - ((Graphic)this).rectTransform.pivot.x) * num2;
		float num6 = (0f - ((Graphic)this).rectTransform.pivot.y) * num4;
		List<UIVertex[]> list = new List<UIVertex[]>();
		if (lineList)
		{
			for (int i = 1; i < pointsToDraw.Length; i += 2)
			{
				Vector2 val = pointsToDraw[i - 1];
				Vector2 val2 = pointsToDraw[i];
				((Vector2)(ref val))..ctor(val.x * num2 + num5, val.y * num4 + num6);
				((Vector2)(ref val2))..ctor(val2.x * num2 + num5, val2.y * num4 + num6);
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val, val2, SegmentType.Middle, (list.Count > 1) ? list[list.Count - 2] : null));
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.End));
				}
			}
		}
		else
		{
			for (int j = 1; j < pointsToDraw.Length; j++)
			{
				Vector2 val3 = pointsToDraw[j - 1];
				Vector2 val4 = pointsToDraw[j];
				((Vector2)(ref val3))..ctor(val3.x * num2 + num5, val3.y * num4 + num6);
				((Vector2)(ref val4))..ctor(val4.x * num2 + num5, val4.y * num4 + num6);
				if (lineCaps && j == 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val3, val4, SegmentType.Middle));
				if (lineCaps && j == pointsToDraw.Length - 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.End));
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			if (!lineList && k < list.Count - 1)
			{
				Vector3 val5 = list[k][1].position - list[k][2].position;
				Vector3 val6 = list[k + 1][2].position - list[k + 1][1].position;
				float num7 = Vector2.Angle(Vector2.op_Implicit(val5), Vector2.op_Implicit(val6)) * (MathF.PI / 180f);
				float num8 = Mathf.Sign(Vector3.Cross(((Vector3)(ref val5)).normalized, ((Vector3)(ref val6)).normalized).z);
				float num9 = lineThickness / (2f * Mathf.Tan(num7 / 2f));
				Vector3 position = list[k][2].position - ((Vector3)(ref val5)).normalized * num9 * num8;
				Vector3 position2 = list[k][3].position + ((Vector3)(ref val5)).normalized * num9 * num8;
				JoinType joinType = LineJoins;
				if (joinType == JoinType.Miter)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 12f)
					{
						list[k][2].position = position;
						list[k][3].position = position2;
						list[k + 1][0].position = position2;
						list[k + 1][1].position = position;
					}
					else
					{
						joinType = JoinType.Bevel;
					}
				}
				if (joinType == JoinType.Bevel)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 6f)
					{
						if (num8 < 0f)
						{
							list[k][2].position = position;
							list[k + 1][1].position = position;
						}
						else
						{
							list[k][3].position = position2;
							list[k + 1][0].position = position2;
						}
					}
					UIVertex[] array = (UIVertex[])(object)new UIVertex[4]
					{
						list[k][2],
						list[k][3],
						list[k + 1][0],
						list[k + 1][1]
					};
					vh.AddUIVertexQuad(array);
				}
			}
			vh.AddUIVertexQuad(list[k]);
		}
		if (vh.currentVertCount > 64000)
		{
			Debug.LogError((object)("Max Verticies size is 64000, current mesh vertcies count is [" + vh.currentVertCount + "] - Cannot Draw"));
			vh.Clear();
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		if (m_points != null && m_points.Length != 0)
		{
			GeneratedUVs();
			vh.Clear();
			PopulateMesh(vh, m_points);
		}
		else if (m_segments != null && m_segments.Count > 0)
		{
			GeneratedUVs();
			vh.Clear();
			for (int i = 0; i < m_segments.Count; i++)
			{
				Vector2[] pointsToDraw = m_segments[i];
				PopulateMesh(vh, pointsToDraw);
			}
		}
	}

	private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		switch (type)
		{
		case SegmentType.Start:
		{
			val = end - start;
			Vector2 start2 = start - ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(start2, start, SegmentType.Start);
		}
		case SegmentType.End:
		{
			val = end - start;
			Vector2 end2 = end + ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(end, end2, SegmentType.End);
		}
		default:
			Debug.LogError((object)"Bad SegmentType passed in to CreateLineCap. Must be SegmentType.Start or SegmentType.End");
			return null;
		}
	}

	private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type, UIVertex[] previousVert = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = new Vector2(start.y - end.y, end.x - start.x);
		Vector2 val2 = ((Vector2)(ref val)).normalized * lineThickness / 2f;
		Vector2 val3 = Vector2.zero;
		Vector2 val4 = Vector2.zero;
		if (previousVert != null)
		{
			((Vector2)(ref val3))..ctor(previousVert[3].position.x, previousVert[3].position.y);
			((Vector2)(ref val4))..ctor(previousVert[2].position.x, previousVert[2].position.y);
		}
		else
		{
			val3 = start - val2;
			val4 = start + val2;
		}
		Vector2 val5 = end + val2;
		Vector2 val6 = end - val2;
		return type switch
		{
			SegmentType.Start => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, startUvs), 
			SegmentType.End => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, endUvs), 
			SegmentType.Full => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, fullUvs), 
			_ => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, middleUvs), 
		};
	}

	protected override void GeneratedUVs()
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.activeSprite != (Object)null)
		{
			Vector4 outerUV = DataUtility.GetOuterUV(base.activeSprite);
			Vector4 innerUV = DataUtility.GetInnerUV(base.activeSprite);
			UV_TOP_LEFT = new Vector2(outerUV.x, outerUV.y);
			UV_BOTTOM_LEFT = new Vector2(outerUV.x, outerUV.w);
			UV_TOP_CENTER_LEFT = new Vector2(innerUV.x, innerUV.y);
			UV_TOP_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.y);
			UV_BOTTOM_CENTER_LEFT = new Vector2(innerUV.x, innerUV.w);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.w);
			UV_TOP_RIGHT = new Vector2(outerUV.z, outerUV.y);
			UV_BOTTOM_RIGHT = new Vector2(outerUV.z, outerUV.w);
		}
		else
		{
			UV_TOP_LEFT = Vector2.zero;
			UV_BOTTOM_LEFT = new Vector2(0f, 1f);
			UV_TOP_CENTER_LEFT = new Vector2(0.5f, 0f);
			UV_TOP_CENTER_RIGHT = new Vector2(0.5f, 0f);
			UV_BOTTOM_CENTER_LEFT = new Vector2(0.5f, 1f);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(0.5f, 1f);
			UV_TOP_RIGHT = new Vector2(1f, 0f);
			UV_BOTTOM_RIGHT = Vector2.one;
		}
		startUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_CENTER_LEFT, UV_TOP_CENTER_LEFT };
		middleUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_LEFT, UV_BOTTOM_CENTER_LEFT, UV_BOTTOM_CENTER_RIGHT, UV_TOP_CENTER_RIGHT };
		endUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_RIGHT, UV_BOTTOM_CENTER_RIGHT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
		fullUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
	}

	protected override void ResolutionToNativeSize(float distance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.UseNativeSize)
		{
			Rect rect = base.activeSprite.rect;
			m_Resolution = distance / (((Rect)(ref rect)).width / base.pixelsPerUnit);
			rect = base.activeSprite.rect;
			lineThickness = ((Rect)(ref rect)).height / base.pixelsPerUnit;
		}
	}

	private int GetSegmentPointCount()
	{
		List<Vector2[]> segments = Segments;
		if (segments != null && segments.Count > 0)
		{
			int num = 0;
			{
				foreach (Vector2[] segment in Segments)
				{
					num += segment.Length;
				}
				return num;
			}
		}
		return Points.Length;
	}

	public Vector2 GetPosition(int index, int segmentIndex = 0)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (segmentIndex > 0)
		{
			return Segments[segmentIndex - 1][index - 1];
		}
		if (Segments.Count > 0)
		{
			int num = 0;
			int num2 = index;
			foreach (Vector2[] segment in Segments)
			{
				if (num2 - segment.Length > 0)
				{
					num2 -= segment.Length;
					num++;
					continue;
				}
				break;
			}
			return Segments[num][num2 - 1];
		}
		return Points[index - 1];
	}

	public Vector2 GetPositionBySegment(int index, int segment)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return Segments[segment][index - 1];
	}

	public Vector2 GetClosestPoint(Vector2 p1, Vector2 p2, Vector2 p3)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = p3 - p1;
		Vector2 val2 = p2 - p1;
		float num = Mathf.Clamp01(Vector2.Dot(val, ((Vector2)(ref val2)).normalized) / ((Vector2)(ref val2)).magnitude);
		return p1 + val2 * num;
	}
}


private enum SegmentType
{
	Start,
	Middle,
	End,
	Full
}


public enum JoinType
{
	Bevel,
	Miter
}


public enum BezierType
{
	None,
	Quick,
	Basic,
	Improved,
	Catenary
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Sprites;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[RequireComponent(typeof(RectTransform))]
[AddComponentMenu("UI/Extensions/Primitives/UILineRendererList")]
public class UILineRendererList : UIPrimitiveBase
{
	private enum SegmentType
	{
		Start,
		Middle,
		End,
		Full
	}

	public enum JoinType
	{
		Bevel,
		Miter
	}

	public enum BezierType
	{
		None,
		Quick,
		Basic,
		Improved,
		Catenary
	}

	private const float MIN_MITER_JOIN = MathF.PI / 12f;

	private const float MIN_BEVEL_NICE_JOIN = MathF.PI / 6f;

	private static Vector2 UV_TOP_LEFT;

	private static Vector2 UV_BOTTOM_LEFT;

	private static Vector2 UV_TOP_CENTER_LEFT;

	private static Vector2 UV_TOP_CENTER_RIGHT;

	private static Vector2 UV_BOTTOM_CENTER_LEFT;

	private static Vector2 UV_BOTTOM_CENTER_RIGHT;

	private static Vector2 UV_TOP_RIGHT;

	private static Vector2 UV_BOTTOM_RIGHT;

	private static Vector2[] startUvs;

	private static Vector2[] middleUvs;

	private static Vector2[] endUvs;

	private static Vector2[] fullUvs;

	[Tooltip("Points to draw lines between\n Can be improved using the Resolution Option")]
	[SerializeField]
	internal List<Vector2> m_points;

	[Tooltip("Thickness of the line")]
	[SerializeField]
	internal float lineThickness = 2f;

	[Tooltip("Use the relative bounds of the Rect Transform (0,0 -> 0,1) or screen space coordinates")]
	[SerializeField]
	internal bool relativeSize;

	[Tooltip("Do the points identify a single line or split pairs of lines")]
	[SerializeField]
	internal bool lineList;

	[SerializeField]
	[Tooltip("Add end caps to each line\nMultiple caps when used with Line List")]
	internal bool lineCaps;

	[Tooltip("Resolution of the Bezier curve, different to line Resolution")]
	[SerializeField]
	internal int bezierSegmentsPerCurve = 10;

	[Tooltip("The type of Join used between lines, Square/Mitre or Curved/Bevel")]
	public JoinType LineJoins;

	[Tooltip("Bezier method to apply to line, see docs for options\nCan't be used in conjunction with Resolution as Bezier already changes the resolution")]
	public BezierType BezierMode;

	[HideInInspector]
	public bool drivenExternally;

	public float LineThickness
	{
		get
		{
			return lineThickness;
		}
		set
		{
			lineThickness = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool RelativeSize
	{
		get
		{
			return relativeSize;
		}
		set
		{
			relativeSize = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineList
	{
		get
		{
			return lineList;
		}
		set
		{
			lineList = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineCaps
	{
		get
		{
			return lineCaps;
		}
		set
		{
			lineCaps = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public int BezierSegmentsPerCurve
	{
		get
		{
			return bezierSegmentsPerCurve;
		}
		set
		{
			bezierSegmentsPerCurve = value;
		}
	}

	public List<Vector2> Points
	{
		get
		{
			return m_points;
		}
		set
		{
			if (m_points != value)
			{
				m_points = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	public void AddPoint(Vector2 pointToAdd)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		m_points.Add(pointToAdd);
		((Graphic)this).SetAllDirty();
	}

	public void RemovePoint(Vector2 pointToRemove)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		m_points.Remove(pointToRemove);
		((Graphic)this).SetAllDirty();
	}

	public void ClearPoints()
	{
		m_points.Clear();
		((Graphic)this).SetAllDirty();
	}

	private void PopulateMesh(VertexHelper vh, List<Vector2> pointsToDraw)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0544: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0577: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_058f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_048a: Unknown result type (might be due to invalid IL or missing references)
		//IL_048c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0515: Unknown result type (might be due to invalid IL or missing references)
		//IL_052b: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
		if (BezierMode != 0 && BezierMode != BezierType.Catenary && pointsToDraw.Count > 3)
		{
			BezierPath bezierPath = new BezierPath();
			bezierPath.SetControlPoints(pointsToDraw);
			bezierPath.SegmentsPerCurve = bezierSegmentsPerCurve;
			pointsToDraw = BezierMode switch
			{
				BezierType.Basic => bezierPath.GetDrawingPoints0(), 
				BezierType.Improved => bezierPath.GetDrawingPoints1(), 
				_ => bezierPath.GetDrawingPoints2(), 
			};
		}
		if (BezierMode == BezierType.Catenary && pointsToDraw.Count == 2)
		{
			CableCurve cableCurve = new CableCurve(pointsToDraw);
			cableCurve.slack = base.Resoloution;
			cableCurve.steps = BezierSegmentsPerCurve;
			pointsToDraw.Clear();
			pointsToDraw.AddRange(cableCurve.Points());
		}
		if (base.ImproveResolution != 0)
		{
			pointsToDraw = IncreaseResolution(pointsToDraw);
		}
		Rect rect;
		float num;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).width;
		}
		else
		{
			num = 1f;
		}
		float num2 = num;
		float num3;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num3 = ((Rect)(ref rect)).height;
		}
		else
		{
			num3 = 1f;
		}
		float num4 = num3;
		float num5 = (0f - ((Graphic)this).rectTransform.pivot.x) * num2;
		float num6 = (0f - ((Graphic)this).rectTransform.pivot.y) * num4;
		List<UIVertex[]> list = new List<UIVertex[]>();
		if (lineList)
		{
			for (int i = 1; i < pointsToDraw.Count; i += 2)
			{
				Vector2 val = pointsToDraw[i - 1];
				Vector2 val2 = pointsToDraw[i];
				((Vector2)(ref val))..ctor(val.x * num2 + num5, val.y * num4 + num6);
				((Vector2)(ref val2))..ctor(val2.x * num2 + num5, val2.y * num4 + num6);
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val, val2, SegmentType.Middle));
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.End));
				}
			}
		}
		else
		{
			for (int j = 1; j < pointsToDraw.Count; j++)
			{
				Vector2 val3 = pointsToDraw[j - 1];
				Vector2 val4 = pointsToDraw[j];
				((Vector2)(ref val3))..ctor(val3.x * num2 + num5, val3.y * num4 + num6);
				((Vector2)(ref val4))..ctor(val4.x * num2 + num5, val4.y * num4 + num6);
				if (lineCaps && j == 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val3, val4, SegmentType.Middle));
				if (lineCaps && j == pointsToDraw.Count - 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.End));
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			if (!lineList && k < list.Count - 1)
			{
				Vector3 val5 = list[k][1].position - list[k][2].position;
				Vector3 val6 = list[k + 1][2].position - list[k + 1][1].position;
				float num7 = Vector2.Angle(Vector2.op_Implicit(val5), Vector2.op_Implicit(val6)) * (MathF.PI / 180f);
				float num8 = Mathf.Sign(Vector3.Cross(((Vector3)(ref val5)).normalized, ((Vector3)(ref val6)).normalized).z);
				float num9 = lineThickness / (2f * Mathf.Tan(num7 / 2f));
				Vector3 position = list[k][2].position - ((Vector3)(ref val5)).normalized * num9 * num8;
				Vector3 position2 = list[k][3].position + ((Vector3)(ref val5)).normalized * num9 * num8;
				JoinType joinType = LineJoins;
				if (joinType == JoinType.Miter)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 12f)
					{
						list[k][2].position = position;
						list[k][3].position = position2;
						list[k + 1][0].position = position2;
						list[k + 1][1].position = position;
					}
					else
					{
						joinType = JoinType.Bevel;
					}
				}
				if (joinType == JoinType.Bevel)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 6f)
					{
						if (num8 < 0f)
						{
							list[k][2].position = position;
							list[k + 1][1].position = position;
						}
						else
						{
							list[k][3].position = position2;
							list[k + 1][0].position = position2;
						}
					}
					UIVertex[] array = (UIVertex[])(object)new UIVertex[4]
					{
						list[k][2],
						list[k][3],
						list[k + 1][0],
						list[k + 1][1]
					};
					vh.AddUIVertexQuad(array);
				}
			}
			vh.AddUIVertexQuad(list[k]);
		}
		if (vh.currentVertCount > 64000)
		{
			Debug.LogError((object)("Max Verticies size is 64000, current mesh vertcies count is [" + vh.currentVertCount + "] - Cannot Draw"));
			vh.Clear();
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		if (m_points != null && m_points.Count > 0)
		{
			GeneratedUVs();
			vh.Clear();
			PopulateMesh(vh, m_points);
		}
	}

	private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		switch (type)
		{
		case SegmentType.Start:
		{
			val = end - start;
			Vector2 start2 = start - ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(start2, start, SegmentType.Start);
		}
		case SegmentType.End:
		{
			val = end - start;
			Vector2 end2 = end + ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(end, end2, SegmentType.End);
		}
		default:
			Debug.LogError((object)"Bad SegmentType passed in to CreateLineCap. Must be SegmentType.Start or SegmentType.End");
			return null;
		}
	}

	private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = new Vector2(start.y - end.y, end.x - start.x);
		Vector2 val2 = ((Vector2)(ref val)).normalized * lineThickness / 2f;
		Vector2 val3 = start - val2;
		Vector2 val4 = start + val2;
		Vector2 val5 = end + val2;
		Vector2 val6 = end - val2;
		return type switch
		{
			SegmentType.Start => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, startUvs), 
			SegmentType.End => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, endUvs), 
			SegmentType.Full => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, fullUvs), 
			_ => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, middleUvs), 
		};
	}

	protected override void GeneratedUVs()
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.activeSprite != (Object)null)
		{
			Vector4 outerUV = DataUtility.GetOuterUV(base.activeSprite);
			Vector4 innerUV = DataUtility.GetInnerUV(base.activeSprite);
			UV_TOP_LEFT = new Vector2(outerUV.x, outerUV.y);
			UV_BOTTOM_LEFT = new Vector2(outerUV.x, outerUV.w);
			UV_TOP_CENTER_LEFT = new Vector2(innerUV.x, innerUV.y);
			UV_TOP_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.y);
			UV_BOTTOM_CENTER_LEFT = new Vector2(innerUV.x, innerUV.w);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.w);
			UV_TOP_RIGHT = new Vector2(outerUV.z, outerUV.y);
			UV_BOTTOM_RIGHT = new Vector2(outerUV.z, outerUV.w);
		}
		else
		{
			UV_TOP_LEFT = Vector2.zero;
			UV_BOTTOM_LEFT = new Vector2(0f, 1f);
			UV_TOP_CENTER_LEFT = new Vector2(0.5f, 0f);
			UV_TOP_CENTER_RIGHT = new Vector2(0.5f, 0f);
			UV_BOTTOM_CENTER_LEFT = new Vector2(0.5f, 1f);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(0.5f, 1f);
			UV_TOP_RIGHT = new Vector2(1f, 0f);
			UV_BOTTOM_RIGHT = Vector2.one;
		}
		startUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_CENTER_LEFT, UV_TOP_CENTER_LEFT };
		middleUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_LEFT, UV_BOTTOM_CENTER_LEFT, UV_BOTTOM_CENTER_RIGHT, UV_TOP_CENTER_RIGHT };
		endUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_RIGHT, UV_BOTTOM_CENTER_RIGHT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
		fullUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
	}

	protected override void ResolutionToNativeSize(float distance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.UseNativeSize)
		{
			Rect rect = base.activeSprite.rect;
			m_Resolution = distance / (((Rect)(ref rect)).width / base.pixelsPerUnit);
			rect = base.activeSprite.rect;
			lineThickness = ((Rect)(ref rect)).height / base.pixelsPerUnit;
		}
	}
}


private enum SegmentType
{
	Start,
	Middle,
	End,
	Full
}


public enum JoinType
{
	Bevel,
	Miter
}


public enum BezierType
{
	None,
	Quick,
	Basic,
	Improved,
	Catenary
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UILineTextureRenderer")]
public class UILineTextureRenderer : UIPrimitiveBase
{
	[SerializeField]
	private Rect m_UVRect = new Rect(0f, 0f, 1f, 1f);

	[SerializeField]
	private Vector2[] m_points;

	public float LineThickness = 2f;

	public bool UseMargins;

	public Vector2 Margin;

	public bool relativeSize;

	public Rect uvRect
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_UVRect;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			if (!(m_UVRect == value))
			{
				m_UVRect = value;
				((Graphic)this).SetVerticesDirty();
			}
		}
	}

	public Vector2[] Points
	{
		get
		{
			return m_points;
		}
		set
		{
			if (m_points != value)
			{
				m_points = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_0475: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0489: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_054b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0552: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0564: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_0577: Unknown result type (might be due to invalid IL or missing references)
		//IL_0579: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_057d: Unknown result type (might be due to invalid IL or missing references)
		//IL_051b: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		if (m_points == null || m_points.Length < 2)
		{
			m_points = (Vector2[])(object)new Vector2[2]
			{
				new Vector2(0f, 0f),
				new Vector2(1f, 1f)
			};
		}
		int num = 24;
		Rect rect = ((Graphic)this).rectTransform.rect;
		float num2 = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float num3 = ((Rect)(ref rect)).height;
		float num4 = 0f - ((Graphic)this).rectTransform.pivot.x;
		rect = ((Graphic)this).rectTransform.rect;
		float num5 = num4 * ((Rect)(ref rect)).width;
		float num6 = 0f - ((Graphic)this).rectTransform.pivot.y;
		rect = ((Graphic)this).rectTransform.rect;
		float num7 = num6 * ((Rect)(ref rect)).height;
		if (!relativeSize)
		{
			num2 = 1f;
			num3 = 1f;
		}
		List<Vector2> list = new List<Vector2>();
		list.Add(m_points[0]);
		Vector2 val = m_points[0];
		Vector2 val2 = m_points[1] - m_points[0];
		Vector2 item = val + ((Vector2)(ref val2)).normalized * (float)num;
		list.Add(item);
		for (int i = 1; i < m_points.Length - 1; i++)
		{
			list.Add(m_points[i]);
		}
		Vector2 val3 = m_points[m_points.Length - 1];
		val2 = m_points[m_points.Length - 1] - m_points[m_points.Length - 2];
		item = val3 - ((Vector2)(ref val2)).normalized * (float)num;
		list.Add(item);
		list.Add(m_points[m_points.Length - 1]);
		Vector2[] array = list.ToArray();
		if (UseMargins)
		{
			num2 -= Margin.x;
			num3 -= Margin.y;
			num5 += Margin.x / 2f;
			num7 += Margin.y / 2f;
		}
		vh.Clear();
		Vector2 val4 = Vector2.zero;
		Vector2 val5 = Vector2.zero;
		Vector2 val12 = default(Vector2);
		Vector2 val13 = default(Vector2);
		Vector2 val14 = default(Vector2);
		Vector2 val15 = default(Vector2);
		Vector2 val16 = default(Vector2);
		for (int j = 1; j < array.Length; j++)
		{
			Vector2 val6 = array[j - 1];
			Vector2 val7 = array[j];
			((Vector2)(ref val6))..ctor(val6.x * num2 + num5, val6.y * num3 + num7);
			((Vector2)(ref val7))..ctor(val7.x * num2 + num5, val7.y * num3 + num7);
			float num8 = Mathf.Atan2(val7.y - val6.y, val7.x - val6.x) * 180f / MathF.PI;
			Vector2 val8 = val6 + new Vector2(0f, (0f - LineThickness) / 2f);
			Vector2 val9 = val6 + new Vector2(0f, LineThickness / 2f);
			Vector2 val10 = val7 + new Vector2(0f, LineThickness / 2f);
			Vector2 val11 = val7 + new Vector2(0f, (0f - LineThickness) / 2f);
			val8 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val8), Vector2.op_Implicit(val6), new Vector3(0f, 0f, num8)));
			val9 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val9), Vector2.op_Implicit(val6), new Vector3(0f, 0f, num8)));
			val10 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val10), Vector2.op_Implicit(val7), new Vector3(0f, 0f, num8)));
			val11 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val11), Vector2.op_Implicit(val7), new Vector3(0f, 0f, num8)));
			Vector2 zero = Vector2.zero;
			((Vector2)(ref val12))..ctor(0f, 1f);
			((Vector2)(ref val13))..ctor(0.5f, 0f);
			((Vector2)(ref val14))..ctor(0.5f, 1f);
			((Vector2)(ref val15))..ctor(1f, 0f);
			((Vector2)(ref val16))..ctor(1f, 1f);
			Vector2[] uvs = (Vector2[])(object)new Vector2[4] { val13, val14, val14, val13 };
			if (j > 1)
			{
				vh.AddUIVertexQuad(SetVbo((Vector2[])(object)new Vector2[4] { val4, val5, val8, val9 }, uvs));
			}
			if (j == 1)
			{
				uvs = (Vector2[])(object)new Vector2[4] { zero, val12, val14, val13 };
			}
			else if (j == array.Length - 1)
			{
				uvs = (Vector2[])(object)new Vector2[4] { val13, val14, val16, val15 };
			}
			vh.AddUIVertexQuad(SetVbo((Vector2[])(object)new Vector2[4] { val8, val9, val10, val11 }, uvs));
			val4 = val10;
			val5 = val11;
		}
	}

	public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point - pivot;
		val = Quaternion.Euler(angles) * val;
		point = val + pivot;
		return point;
	}
}


using System;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Polygon")]
public class UIPolygon : UIPrimitiveBase
{
	public bool fill = true;

	public float thickness = 5f;

	[Range(3f, 360f)]
	public int sides = 3;

	[Range(0f, 360f)]
	public float rotation;

	[Range(0f, 1f)]
	public float[] VerticesDistances = new float[3];

	private float size;

	public void DrawPolygon(int _sides)
	{
		sides = _sides;
		VerticesDistances = new float[_sides + 1];
		for (int i = 0; i < _sides; i++)
		{
			VerticesDistances[i] = 1f;
		}
		rotation = 0f;
		((Graphic)this).SetAllDirty();
	}

	public void DrawPolygon(int _sides, float[] _VerticesDistances)
	{
		sides = _sides;
		VerticesDistances = _VerticesDistances;
		rotation = 0f;
		((Graphic)this).SetAllDirty();
	}

	public void DrawPolygon(int _sides, float[] _VerticesDistances, float _rotation)
	{
		sides = _sides;
		VerticesDistances = _VerticesDistances;
		rotation = _rotation;
		((Graphic)this).SetAllDirty();
	}

	private void Update()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((Graphic)this).rectTransform.rect;
		size = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float width = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		if (width > ((Rect)(ref rect)).height)
		{
			rect = ((Graphic)this).rectTransform.rect;
			size = ((Rect)(ref rect)).height;
		}
		else
		{
			rect = ((Graphic)this).rectTransform.rect;
			size = ((Rect)(ref rect)).width;
		}
		thickness = Mathf.Clamp(thickness, 0f, size / 2f);
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		vh.Clear();
		Vector2 val = Vector2.zero;
		Vector2 val2 = Vector2.zero;
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(0f, 0f);
		Vector2 val4 = default(Vector2);
		((Vector2)(ref val4))..ctor(0f, 1f);
		Vector2 val5 = default(Vector2);
		((Vector2)(ref val5))..ctor(1f, 1f);
		Vector2 val6 = default(Vector2);
		((Vector2)(ref val6))..ctor(1f, 0f);
		float num = 360f / (float)sides;
		int num2 = sides + 1;
		if (VerticesDistances.Length != num2)
		{
			VerticesDistances = new float[num2];
			for (int i = 0; i < num2 - 1; i++)
			{
				VerticesDistances[i] = 1f;
			}
		}
		VerticesDistances[num2 - 1] = VerticesDistances[0];
		Vector2 val8 = default(Vector2);
		Vector2 zero = default(Vector2);
		for (int j = 0; j < num2; j++)
		{
			float num3 = (0f - ((Graphic)this).rectTransform.pivot.x) * size * VerticesDistances[j];
			float num4 = (0f - ((Graphic)this).rectTransform.pivot.x) * size * VerticesDistances[j] + thickness;
			float num5 = MathF.PI / 180f * ((float)j * num + rotation);
			float num6 = Mathf.Cos(num5);
			float num7 = Mathf.Sin(num5);
			((Vector2)(ref val3))..ctor(0f, 1f);
			((Vector2)(ref val4))..ctor(1f, 1f);
			((Vector2)(ref val5))..ctor(1f, 0f);
			((Vector2)(ref val6))..ctor(0f, 0f);
			Vector2 val7 = val;
			((Vector2)(ref val8))..ctor(num3 * num6, num3 * num7);
			Vector2 val9;
			if (fill)
			{
				zero = Vector2.zero;
				val9 = Vector2.zero;
			}
			else
			{
				((Vector2)(ref zero))..ctor(num4 * num6, num4 * num7);
				val9 = val2;
			}
			val = val8;
			val2 = zero;
			vh.AddUIVertexQuad(SetVbo((Vector2[])(object)new Vector2[4] { val7, val8, zero, val9 }, (Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }));
		}
	}
}


public enum ResolutionMode
{
	None,
	PerSegment,
	PerLine
}


using System;
using UnityEngine;

internal static class SetPropertyUtility
{
	public static bool SetColor(ref Color currentValue, Color newValue)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (currentValue.r == newValue.r && currentValue.g == newValue.g && currentValue.b == newValue.b && currentValue.a == newValue.a)
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}

	public static bool SetEquatableStruct<T>(ref T currentValue, T newValue) where T : IEquatable<T>
	{
		if (currentValue.Equals(newValue))
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}

	public static bool SetStruct<T>(ref T currentValue, T newValue) where T : struct
	{
		if (currentValue.Equals(newValue))
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}

	public static bool SetClass<T>(ref T currentValue, T newValue) where T : class
	{
		if ((currentValue == null && newValue == null) || (currentValue != null && currentValue.Equals(newValue)))
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class UIPrimitiveBase : MaskableGraphic, ILayoutElement, ICanvasRaycastFilter
{
	protected static Material s_ETC1DefaultUI;

	private List<Vector2> outputList = new List<Vector2>();

	[SerializeField]
	private Sprite m_Sprite;

	[NonSerialized]
	private Sprite m_OverrideSprite;

	internal float m_EventAlphaThreshold = 1f;

	[SerializeField]
	private ResolutionMode m_improveResolution;

	[SerializeField]
	protected float m_Resolution;

	[SerializeField]
	private bool m_useNativeSize;

	public Sprite sprite
	{
		get
		{
			return m_Sprite;
		}
		set
		{
			if (SetPropertyUtility.SetClass(ref m_Sprite, value))
			{
				GeneratedUVs();
			}
			((Graphic)this).SetAllDirty();
		}
	}

	public Sprite overrideSprite
	{
		get
		{
			return activeSprite;
		}
		set
		{
			if (SetPropertyUtility.SetClass(ref m_OverrideSprite, value))
			{
				GeneratedUVs();
			}
			((Graphic)this).SetAllDirty();
		}
	}

	protected Sprite activeSprite
	{
		get
		{
			if (!((Object)(object)m_OverrideSprite != (Object)null))
			{
				return sprite;
			}
			return m_OverrideSprite;
		}
	}

	public float eventAlphaThreshold
	{
		get
		{
			return m_EventAlphaThreshold;
		}
		set
		{
			m_EventAlphaThreshold = value;
		}
	}

	public ResolutionMode ImproveResolution
	{
		get
		{
			return m_improveResolution;
		}
		set
		{
			m_improveResolution = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public float Resoloution
	{
		get
		{
			return m_Resolution;
		}
		set
		{
			m_Resolution = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool UseNativeSize
	{
		get
		{
			return m_useNativeSize;
		}
		set
		{
			m_useNativeSize = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public static Material defaultETC1GraphicMaterial
	{
		get
		{
			if ((Object)(object)s_ETC1DefaultUI == (Object)null)
			{
				s_ETC1DefaultUI = Canvas.GetETC1SupportedCanvasMaterial();
			}
			return s_ETC1DefaultUI;
		}
	}

	public override Texture mainTexture
	{
		get
		{
			if ((Object)(object)activeSprite == (Object)null)
			{
				if ((Object)(object)((Graphic)this).material != (Object)null && (Object)(object)((Graphic)this).material.mainTexture != (Object)null)
				{
					return ((Graphic)this).material.mainTexture;
				}
				return (Texture)(object)Graphic.s_WhiteTexture;
			}
			return (Texture)(object)activeSprite.texture;
		}
	}

	public bool hasBorder
	{
		get
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)activeSprite != (Object)null)
			{
				Vector4 border = activeSprite.border;
				return ((Vector4)(ref border)).sqrMagnitude > 0f;
			}
			return false;
		}
	}

	public float pixelsPerUnit
	{
		get
		{
			float num = 100f;
			if (Object.op_Implicit((Object)(object)activeSprite))
			{
				num = activeSprite.pixelsPerUnit;
			}
			float num2 = 100f;
			if (Object.op_Implicit((Object)(object)((Graphic)this).canvas))
			{
				num2 = ((Graphic)this).canvas.referencePixelsPerUnit;
			}
			return num / num2;
		}
	}

	public override Material material
	{
		get
		{
			if ((Object)(object)((Graphic)this).m_Material != (Object)null)
			{
				return ((Graphic)this).m_Material;
			}
			if (Object.op_Implicit((Object)(object)activeSprite) && (Object)(object)activeSprite.associatedAlphaSplitTexture != (Object)null)
			{
				return defaultETC1GraphicMaterial;
			}
			return ((Graphic)this).defaultMaterial;
		}
		set
		{
			((Graphic)this).material = value;
		}
	}

	public virtual float minWidth => 0f;

	public virtual float preferredWidth
	{
		get
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)overrideSprite == (Object)null)
			{
				return 0f;
			}
			Rect rect = overrideSprite.rect;
			return ((Rect)(ref rect)).size.x / pixelsPerUnit;
		}
	}

	public virtual float flexibleWidth => -1f;

	public virtual float minHeight => 0f;

	public virtual float preferredHeight
	{
		get
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)overrideSprite == (Object)null)
			{
				return 0f;
			}
			Rect rect = overrideSprite.rect;
			return ((Rect)(ref rect)).size.y / pixelsPerUnit;
		}
	}

	public virtual float flexibleHeight => -1f;

	public virtual int layoutPriority => 0;

	protected UIPrimitiveBase()
	{
		((Graphic)this).useLegacyMeshGeneration = false;
	}

	protected UIVertex[] SetVbo(Vector2[] vertices, Vector2[] uvs)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		UIVertex[] array = (UIVertex[])(object)new UIVertex[4];
		for (int i = 0; i < vertices.Length; i++)
		{
			UIVertex simpleVert = UIVertex.simpleVert;
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.position = Vector2.op_Implicit(vertices[i]);
			simpleVert.uv0 = Vector4.op_Implicit(uvs[i]);
			array[i] = simpleVert;
		}
		return array;
	}

	protected Vector2[] IncreaseResolution(Vector2[] input)
	{
		return IncreaseResolution(new List<Vector2>(input)).ToArray();
	}

	protected List<Vector2> IncreaseResolution(List<Vector2> input)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		outputList.Clear();
		switch (ImproveResolution)
		{
		case ResolutionMode.PerLine:
		{
			float num3 = 0f;
			float num = 0f;
			for (int j = 0; j < input.Count - 1; j++)
			{
				num3 += Vector2.Distance(input[j], input[j + 1]);
			}
			ResolutionToNativeSize(num3);
			num = num3 / m_Resolution;
			int num4 = 0;
			for (int k = 0; k < input.Count - 1; k++)
			{
				Vector2 val3 = input[k];
				outputList.Add(val3);
				Vector2 val4 = input[k + 1];
				float num5 = Vector2.Distance(val3, val4) / num;
				float num6 = 1f / num5;
				for (int l = 0; (float)l < num5; l++)
				{
					outputList.Add(Vector2.Lerp(val3, val4, (float)l * num6));
					num4++;
				}
				outputList.Add(val4);
			}
			break;
		}
		case ResolutionMode.PerSegment:
		{
			for (int i = 0; i < input.Count - 1; i++)
			{
				Vector2 val = input[i];
				outputList.Add(val);
				Vector2 val2 = input[i + 1];
				ResolutionToNativeSize(Vector2.Distance(val, val2));
				float num = 1f / m_Resolution;
				for (float num2 = 1f; num2 < m_Resolution; num2 += 1f)
				{
					outputList.Add(Vector2.Lerp(val, val2, num * num2));
				}
				outputList.Add(val2);
			}
			break;
		}
		}
		return outputList;
	}

	protected virtual void GeneratedUVs()
	{
	}

	protected virtual void ResolutionToNativeSize(float distance)
	{
	}

	public virtual void CalculateLayoutInputHorizontal()
	{
	}

	public virtual void CalculateLayoutInputVertical()
	{
	}

	public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		//IL_0128: Expected O, but got Unknown
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		if (m_EventAlphaThreshold >= 1f)
		{
			return true;
		}
		Sprite val = overrideSprite;
		if ((Object)(object)val == (Object)null)
		{
			return true;
		}
		Vector2 local = default(Vector2);
		RectTransformUtility.ScreenPointToLocalPointInRectangle(((Graphic)this).rectTransform, screenPoint, eventCamera, ref local);
		Rect pixelAdjustedRect = ((Graphic)this).GetPixelAdjustedRect();
		local.x += ((Graphic)this).rectTransform.pivot.x * ((Rect)(ref pixelAdjustedRect)).width;
		local.y += ((Graphic)this).rectTransform.pivot.y * ((Rect)(ref pixelAdjustedRect)).height;
		local = MapCoordinate(local, pixelAdjustedRect);
		Rect textureRect = val.textureRect;
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(local.x / ((Rect)(ref textureRect)).width, local.y / ((Rect)(ref textureRect)).height);
		float num = Mathf.Lerp(((Rect)(ref textureRect)).x, ((Rect)(ref textureRect)).xMax, val2.x) / (float)((Texture)val.texture).width;
		float num2 = Mathf.Lerp(((Rect)(ref textureRect)).y, ((Rect)(ref textureRect)).yMax, val2.y) / (float)((Texture)val.texture).height;
		try
		{
			return val.texture.GetPixelBilinear(num, num2).a >= m_EventAlphaThreshold;
		}
		catch (UnityException val3)
		{
			UnityException val4 = val3;
			Debug.LogError((object)("Using clickAlphaThreshold lower than 1 on Image whose sprite texture cannot be read. " + ((Exception)(object)val4).Message + " Also make sure to disable sprite packing for this sprite."), (Object)(object)this);
			return true;
		}
	}

	private Vector2 MapCoordinate(Vector2 local, Rect rect)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		_ = sprite.rect;
		return new Vector2(local.x * ((Rect)(ref rect)).width, local.y * ((Rect)(ref rect)).height);
	}

	private Vector4 GetAdjustedBorders(Vector4 border, Rect rect)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i <= 1; i++)
		{
			float num = ((Vector4)(ref border))[i] + ((Vector4)(ref border))[i + 2];
			Vector2 size = ((Rect)(ref rect)).size;
			if (((Vector2)(ref size))[i] < num && num != 0f)
			{
				size = ((Rect)(ref rect)).size;
				float num2 = ((Vector2)(ref size))[i] / num;
				ref Vector4 reference = ref border;
				int num3 = i;
				((Vector4)(ref reference))[num3] = ((Vector4)(ref reference))[num3] * num2;
				reference = ref border;
				num3 = i + 2;
				((Vector4)(ref reference))[num3] = ((Vector4)(ref reference))[num3] * num2;
			}
		}
		return border;
	}

	protected override void OnEnable()
	{
		((MaskableGraphic)this).OnEnable();
		((Graphic)this).SetAllDirty();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Ring")]
public class UIRing : UIPrimitiveBase
{
	public float innerRadius = 16f;

	public float outerRadius = 32f;

	[Range(0f, 1000f)]
	[Tooltip("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
	public int ArcSteps = 100;

	private List<int> indices = new List<int>();

	private List<UIVertex> vertices = new List<UIVertex>();

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		float num = innerRadius * 2f;
		float num2 = outerRadius * 2f;
		vh.Clear();
		indices.Clear();
		vertices.Clear();
		int item = 0;
		int num3 = 1;
		float num4 = 360f / (float)ArcSteps;
		float num5 = Mathf.Cos(0f);
		float num6 = Mathf.Sin(0f);
		UIVertex simpleVert = UIVertex.simpleVert;
		simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
		simpleVert.position = Vector2.op_Implicit(new Vector2(num2 * num5, num2 * num6));
		vertices.Add(simpleVert);
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(num * num5, num * num6);
		simpleVert.position = Vector2.op_Implicit(val);
		vertices.Add(simpleVert);
		for (int i = 1; i <= ArcSteps; i++)
		{
			float num7 = MathF.PI / 180f * ((float)i * num4);
			num5 = Mathf.Cos(num7);
			num6 = Mathf.Sin(num7);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num2 * num5, num2 * num6));
			vertices.Add(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num * num5, num * num6));
			vertices.Add(simpleVert);
			int item2 = num3;
			indices.Add(item);
			indices.Add(num3 + 1);
			indices.Add(num3);
			num3++;
			item = num3;
			num3++;
			indices.Add(item);
			indices.Add(num3);
			indices.Add(item2);
		}
		vh.AddUIVertexStream(vertices, indices);
	}

	public void SetArcSteps(int steps)
	{
		ArcSteps = steps;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetBaseColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateBaseAlpha(float value)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((Graphic)this).color;
		color.a = value;
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BezierPath
{
	public int SegmentsPerCurve = 10;

	public float MINIMUM_SQR_DISTANCE = 0.01f;

	public float DIVISION_THRESHOLD = -0.99f;

	private List<Vector2> controlPoints;

	private int curveCount;

	public BezierPath()
	{
		controlPoints = new List<Vector2>();
	}

	public void SetControlPoints(List<Vector2> newControlPoints)
	{
		controlPoints.Clear();
		controlPoints.AddRange(newControlPoints);
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public void SetControlPoints(Vector2[] newControlPoints)
	{
		controlPoints.Clear();
		controlPoints.AddRange(newControlPoints);
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector2> GetControlPoints()
	{
		return controlPoints;
	}

	public void Interpolate(List<Vector2> segmentPoints, float scale)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector2 val = segmentPoints[i];
				Vector2 val2 = segmentPoints[i + 1] - val;
				Vector2 item = val + scale * val2;
				controlPoints.Add(val);
				controlPoints.Add(item);
				continue;
			}
			if (i == segmentPoints.Count - 1)
			{
				Vector2 val3 = segmentPoints[i - 1];
				Vector2 val4 = segmentPoints[i];
				Vector2 val5 = val4 - val3;
				Vector2 item2 = val4 - scale * val5;
				controlPoints.Add(item2);
				controlPoints.Add(val4);
				continue;
			}
			Vector2 val6 = segmentPoints[i - 1];
			Vector2 val7 = segmentPoints[i];
			Vector2 val8 = segmentPoints[i + 1];
			Vector2 val9 = val8 - val6;
			Vector2 normalized = ((Vector2)(ref val9)).normalized;
			Vector2 val10 = scale * normalized;
			val9 = val7 - val6;
			Vector2 item3 = val7 - val10 * ((Vector2)(ref val9)).magnitude;
			Vector2 val11 = scale * normalized;
			val9 = val8 - val7;
			Vector2 item4 = val7 + val11 * ((Vector2)(ref val9)).magnitude;
			controlPoints.Add(item3);
			controlPoints.Add(val7);
			controlPoints.Add(item4);
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public void SamplePoints(List<Vector2> sourcePoints, float minSqrDistance, float maxSqrDistance, float scale)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (sourcePoints.Count < 2)
		{
			return;
		}
		Stack<Vector2> stack = new Stack<Vector2>();
		stack.Push(sourcePoints[0]);
		Vector2 val = sourcePoints[1];
		int num = 2;
		Vector2 val2;
		for (num = 2; num < sourcePoints.Count; num++)
		{
			val2 = val - sourcePoints[num];
			if (((Vector2)(ref val2)).sqrMagnitude > minSqrDistance)
			{
				val2 = stack.Peek() - sourcePoints[num];
				if (((Vector2)(ref val2)).sqrMagnitude > maxSqrDistance)
				{
					stack.Push(val);
				}
			}
			val = sourcePoints[num];
		}
		Vector2 val3 = stack.Pop();
		Vector2 val4 = stack.Peek();
		val2 = val4 - val;
		Vector2 normalized = ((Vector2)(ref val2)).normalized;
		val2 = val - val3;
		float magnitude = ((Vector2)(ref val2)).magnitude;
		val2 = val3 - val4;
		float magnitude2 = ((Vector2)(ref val2)).magnitude;
		val3 += normalized * ((magnitude2 - magnitude) / 2f);
		stack.Push(val3);
		stack.Push(val);
		Interpolate(new List<Vector2>(stack), scale);
	}

	public Vector2 CalculateBezierPoint(int curveIndex, float t)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		int num = curveIndex * 3;
		Vector2 p = controlPoints[num];
		Vector2 p2 = controlPoints[num + 1];
		Vector2 p3 = controlPoints[num + 2];
		Vector2 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	public List<Vector2> GetDrawingPoints0()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < curveCount; i++)
		{
			if (i == 0)
			{
				list.Add(CalculateBezierPoint(i, 0f));
			}
			for (int j = 1; j <= SegmentsPerCurve; j++)
			{
				float t = (float)j / (float)SegmentsPerCurve;
				list.Add(CalculateBezierPoint(i, t));
			}
		}
		return list;
	}

	public List<Vector2> GetDrawingPoints1()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < controlPoints.Count - 3; i += 3)
		{
			Vector2 p = controlPoints[i];
			Vector2 p2 = controlPoints[i + 1];
			Vector2 p3 = controlPoints[i + 2];
			Vector2 p4 = controlPoints[i + 3];
			if (i == 0)
			{
				list.Add(CalculateBezierPoint(0f, p, p2, p3, p4));
			}
			for (int j = 1; j <= SegmentsPerCurve; j++)
			{
				float t = (float)j / (float)SegmentsPerCurve;
				list.Add(CalculateBezierPoint(t, p, p2, p3, p4));
			}
		}
		return list;
	}

	public List<Vector2> GetDrawingPoints2()
	{
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector2> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector2> FindDrawingPoints(int curveIndex)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		List<Vector2> list = new List<Vector2>();
		Vector2 item = CalculateBezierPoint(curveIndex, 0f);
		Vector2 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector2> pointList, int insertionIndex)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = CalculateBezierPoint(curveIndex, t0);
		Vector2 val2 = CalculateBezierPoint(curveIndex, t1);
		Vector2 val3 = val - val2;
		if (((Vector2)(ref val3)).sqrMagnitude < MINIMUM_SQR_DISTANCE)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector2 val4 = CalculateBezierPoint(curveIndex, num);
		val3 = val - val4;
		Vector2 normalized = ((Vector2)(ref val3)).normalized;
		val3 = val2 - val4;
		Vector2 normalized2 = ((Vector2)(ref val3)).normalized;
		if (Vector2.Dot(normalized, normalized2) > DIVISION_THRESHOLD || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, val4);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	private Vector2 CalculateBezierPoint(float t, Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI.Extensions;

[Serializable]
public class CableCurve
{
	[SerializeField]
	private Vector2 m_start;

	[SerializeField]
	private Vector2 m_end;

	[SerializeField]
	private float m_slack;

	[SerializeField]
	private int m_steps;

	[SerializeField]
	private bool m_regen;

	private static Vector2[] emptyCurve = (Vector2[])(object)new Vector2[2]
	{
		new Vector2(0f, 0f),
		new Vector2(0f, 0f)
	};

	[SerializeField]
	private Vector2[] points;

	public bool regenPoints
	{
		get
		{
			return m_regen;
		}
		set
		{
			m_regen = value;
		}
	}

	public Vector2 start
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_start;
		}
		set
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			if (value != m_start)
			{
				m_regen = true;
			}
			m_start = value;
		}
	}

	public Vector2 end
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_end;
		}
		set
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			if (value != m_end)
			{
				m_regen = true;
			}
			m_end = value;
		}
	}

	public float slack
	{
		get
		{
			return m_slack;
		}
		set
		{
			if (value != m_slack)
			{
				m_regen = true;
			}
			m_slack = Mathf.Max(0f, value);
		}
	}

	public int steps
	{
		get
		{
			return m_steps;
		}
		set
		{
			if (value != m_steps)
			{
				m_regen = true;
			}
			m_steps = Mathf.Max(2, value);
		}
	}

	public Vector2 midPoint
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			Vector2 result = Vector2.zero;
			if (m_steps == 2)
			{
				return (points[0] + points[1]) * 0.5f;
			}
			if (m_steps > 2)
			{
				int num = m_steps / 2;
				result = ((m_steps % 2 != 0) ? points[num] : ((points[num] + points[num + 1]) * 0.5f));
			}
			return result;
		}
	}

	public CableCurve()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		points = emptyCurve;
		m_start = Vector2.up;
		m_end = Vector2.up + Vector2.right;
		m_slack = 0.5f;
		m_steps = 20;
		m_regen = true;
	}

	public CableCurve(Vector2[] inputPoints)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		points = inputPoints;
		m_start = inputPoints[0];
		m_end = inputPoints[1];
		m_slack = 0.5f;
		m_steps = 20;
		m_regen = true;
	}

	public CableCurve(List<Vector2> inputPoints)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		points = inputPoints.ToArray();
		m_start = inputPoints[0];
		m_end = inputPoints[1];
		m_slack = 0.5f;
		m_steps = 20;
		m_regen = true;
	}

	public CableCurve(CableCurve v)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		points = v.Points();
		m_start = v.start;
		m_end = v.end;
		m_slack = v.slack;
		m_steps = v.steps;
		m_regen = v.regenPoints;
	}

	public Vector2[] Points()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		if (!m_regen)
		{
			return points;
		}
		if (m_steps < 2)
		{
			return emptyCurve;
		}
		float num = Vector2.Distance(m_end, m_start);
		float num2 = Vector2.Distance(new Vector2(m_end.x, m_start.y), m_start);
		float num3 = num + Mathf.Max(0.0001f, m_slack);
		float num4 = 0f;
		float y = m_start.y;
		float num5 = num2;
		float y2 = end.y;
		if (num5 - num4 == 0f)
		{
			return emptyCurve;
		}
		float num6 = Mathf.Sqrt(Mathf.Pow(num3, 2f) - Mathf.Pow(y2 - y, 2f)) / (num5 - num4);
		int num7 = 30;
		int num8 = 0;
		int num9 = num7 * 10;
		bool flag = false;
		float num10 = 0f;
		float num11 = 0f;
		float num12 = 100f;
		float num13 = 0f;
		for (int i = 0; i < num7; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				num8++;
				num11 = num10 + num12;
				num13 = (float)Math.Sinh(num11) / num11;
				if (!float.IsInfinity(num13))
				{
					if (num13 == num6)
					{
						flag = true;
						num10 = num11;
						break;
					}
					if (num13 > num6)
					{
						break;
					}
					num10 = num11;
					if (num8 > num9)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				break;
			}
			num12 *= 0.1f;
		}
		float num14 = (num5 - num4) / 2f / num10;
		float num15 = (num4 + num5 - num14 * Mathf.Log((num3 + y2 - y) / (num3 - y2 + y))) / 2f;
		float num16 = (y2 + y - num3 * (float)Math.Cosh(num10) / (float)Math.Sinh(num10)) / 2f;
		points = (Vector2[])(object)new Vector2[m_steps];
		float num17 = m_steps - 1;
		for (int k = 0; k < m_steps; k++)
		{
			float num18 = (float)k / num17;
			Vector2 zero = Vector2.zero;
			zero.x = Mathf.Lerp(start.x, end.x, num18);
			zero.y = num14 * (float)Math.Cosh((num18 * num2 - num15) / num14) + num16;
			points[k] = zero;
		}
		m_regen = false;
		return points;
	}
}


