using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using FIMSpace;
using FIMSpace.AnimationTools;
using FIMSpace.FProceduralAnimation;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[AddComponentMenu("FImpossible Creations/Legs Animator")]
[DefaultExecutionOrder(-1301)]
[HelpURL("https://assetstore.unity.com/packages/tools/animation/legs-animator-154245")]
public class LegsAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon
{
	private struct CalibrateTransform
	{
		public Transform Transform;

		private Quaternion initLocalRot;

		public CalibrateTransform(Transform t)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			Transform = t;
			initLocalRot = t.localRotation;
		}

		public void Calibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			Transform.localRotation = initLocalRot;
		}
	}

	public enum EStepType
	{
		IdleGluing,
		MovementGluing,
		OnLanding,
		OnStopping
	}

	public interface ILegStepReceiver
	{
		void LegAnimatorStepEvent(Leg leg, float power, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
	}

	public interface ILegRaiseReceiver
	{
		void LegAnimatorRaiseEvent(Leg leg, float predictedDistance, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
	}

	[Serializable]
	public class LegsAnimatorCustomModuleHelper
	{
		public bool Enabled = true;

		public LegsAnimator Parent;

		public LegsAnimatorControlModuleBase ModuleReference;

		[SerializeField]
		[HideInInspector]
		public List<string> customStringList;

		[SerializeField]
		[HideInInspector]
		public List<Object> customObjectList;

		[SerializeField]
		private List<Variable> variables = new List<Variable>();

		public LegsAnimatorControlModuleBase PlaymodeModule { get; private set; }

		public LegsAnimatorControlModuleBase CurrentModule => PlaymodeModule;

		public LegsAnimatorCustomModuleHelper(LegsAnimator get)
		{
			Parent = get;
		}

		public void PreparePlaymodeModule(LegsAnimator parent)
		{
			if (!((Object)(object)PlaymodeModule != (Object)null) && !((Object)(object)ModuleReference == (Object)null))
			{
				PlaymodeModule = Object.Instantiate<LegsAnimatorControlModuleBase>(ModuleReference);
				PlaymodeModule.Base_Init(parent, this);
			}
		}

		public void DisposeModule()
		{
			if ((Object)(object)PlaymodeModule != (Object)null)
			{
				Object.Destroy((Object)(object)PlaymodeModule);
			}
			PlaymodeModule = null;
		}

		public Variable RequestVariable(string name, object defaultValue)
		{
			if (variables == null)
			{
				variables = new List<Variable>();
			}
			int hashCode = name.GetHashCode();
			for (int i = 0; i < variables.Count; i++)
			{
				if (variables[i].GetNameHash == hashCode)
				{
					return variables[i];
				}
			}
			Variable variable = new Variable(name, defaultValue);
			variables.Add(variable);
			return variable;
		}
	}

	[Serializable]
	public class PelvisImpulseSettings
	{
		public string OptionalName = "Impulse";

		[Space(3f)]
		public float PowerMultiplier = 1f;

		[Tooltip("Duration of translation impulse in seconds")]
		public float ImpulseDuration = 0.5f;

		[Space(5f)]
		public Vector3 WorldTranslation = Vector3.zero;

		public Vector3 LocalTranslation = new Vector3(0f, -0.2f, 0.1f);

		[Space(5f)]
		public Vector3 HipsRotate = Vector3.zero;

		[Space(5f)]
		[Range(0f, 1f)]
		public float InheritElasticness = 0.75f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve ImpulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve YAxisMultiplyCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

		[Space(5f)]
		[Tooltip("Local Offset Z-forward will bo rotated to face the legs animator's current desired move direction value")]
		public bool AlignWithDesiredMoveDirection;

		public PelvisImpulseSettings Copy()
		{
			return (PelvisImpulseSettings)MemberwiseClone();
		}

		public PelvisImpulseSettings()
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			ImpulseCurve = GetDefaultCurveInstance();
		}

		public static AnimationCurve GetDefaultCurveInstance()
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			AnimationCurve obj = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);
			obj.AddKey(new Keyframe(0.2f, 1f));
			obj.SmoothTangents(1, 0.5f);
			return obj;
		}

		public PelvisImpulseSettings(Vector3 vector3, float duration, float power)
			: this()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			LocalTranslation = vector3;
			ImpulseDuration = duration;
			PowerMultiplier = power;
		}
	}

	public struct ImpulseExecutor
	{
		public float Elapsed;

		public float PowerMultiplier;

		public float ImpulseDuration;

		public Vector3 WorldTranslation;

		public Vector3 LocalTranslation;

		public float InheritElasticness;

		public Vector3 HipsRotation;

		public bool AlignDesired;

		public AnimationCurve ImpulseCurve;

		public AnimationCurve YAxisMultiplyCurve;

		private static AnimationCurve _defaultCurve;

		private static AnimationCurve _defaultCurve11;

		public static AnimationCurve DefaultCurve
		{
			get
			{
				if (_defaultCurve == null)
				{
					_defaultCurve = PelvisImpulseSettings.GetDefaultCurveInstance();
				}
				return _defaultCurve;
			}
		}

		public static AnimationCurve DefaultCurve11
		{
			get
			{
				if (_defaultCurve11 == null)
				{
					_defaultCurve11 = AnimationCurve.Linear(0f, 1f, 1f, 1f);
				}
				return _defaultCurve11;
			}
		}

		public bool Finished => Elapsed >= ImpulseDuration;

		public float Progress
		{
			get
			{
				if (ImpulseDuration != 0f)
				{
					return Elapsed / ImpulseDuration;
				}
				return 1f;
			}
		}

		public float Evaluation => ImpulseCurve.Evaluate(Progress);

		public float Elastic => InheritElasticness;

		public float Power => PowerMultiplier;

		public Vector3 CurrentLocalOffset => LocalTranslation * Evaluation * Power;

		public float CurrentLocalYAxisMultiplier => YAxisMultiplyCurve.Evaluate(Progress);

		public Vector3 CurrentWorldOffset => WorldTranslation * Evaluation * Power;

		public ImpulseExecutor(PelvisImpulseSettings settings, float powerMultiplier = 1f, float durationMultiplier = 1f)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = settings.PowerMultiplier * powerMultiplier;
			ImpulseDuration = settings.ImpulseDuration * durationMultiplier;
			WorldTranslation = settings.WorldTranslation;
			LocalTranslation = settings.LocalTranslation;
			InheritElasticness = settings.InheritElasticness;
			HipsRotation = settings.HipsRotate;
			ImpulseCurve = settings.ImpulseCurve;
			YAxisMultiplyCurve = settings.YAxisMultiplyCurve;
			AlignDesired = settings.AlignWithDesiredMoveDirection;
		}

		public ImpulseExecutor(Vector3 localOffset, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = Vector3.zero;
			LocalTranslation = localOffset;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			HipsRotation = Vector3.zero;
			AlignDesired = alignWithDesiredDir;
		}

		public ImpulseExecutor(Vector3 localOffset, Vector3 hipsRotation, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = Vector3.zero;
			HipsRotation = hipsRotation;
			LocalTranslation = localOffset;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			AlignDesired = alignWithDesiredDir;
		}

		public ImpulseExecutor(float duration, Vector3 worldOffset, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = worldOffset;
			HipsRotation = Vector3.zero;
			LocalTranslation = Vector3.zero;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			AlignDesired = alignWithDesiredDir;
		}

		public void Update(float delta)
		{
			Elapsed += delta;
		}
	}

	public enum EHipsAdjustStyle
	{
		SmoothDamp,
		FollowLegHeight
	}

	public enum EHipsHubsHandling
	{
		[Tooltip("Applying hips movement offset to the selected hub, in order to fix disconnected hips bones (rare case)")]
		FixDisconnected,
		[Tooltip("Detailed mode is computing hips hub offsets individually, giving more realistic effect but costs a bit more")]
		Detailed
	}

	[Serializable]
	public class HipsReference
	{
		public class HipsHubBackbone
		{
			public Transform frontBone;

			private Vector3 _dir = Vector3.zero;

			private Vector3 _sd_dir = Vector3.zero;

			private FMuscle_Vector3 _FMuscle;

			public LegsAnimator Owner { get; private set; }

			public Transform bone { get; private set; }

			public Quaternion initialLocalRotation { get; private set; }

			public Vector3 keyframePosition { get; private set; }

			public Quaternion TargetRotation { get; internal set; }

			public HipsHubBackbone(LegsAnimator owner, Transform b)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				Owner = owner;
				bone = b;
				initialLocalRotation = b.localRotation;
				_FMuscle = new FMuscle_Vector3();
				_FMuscle.Initialize(Vector3.zero);
			}

			public void PreCalibrate()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				bone.localRotation = initialLocalRotation;
			}

			public void Calibrate()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				keyframePosition = bone.position;
			}

			public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0074: Unknown result type (might be due to invalid IL or missing references)
				//IL_0075: Unknown result type (might be due to invalid IL or missing references)
				//IL_0085: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0090: Unknown result type (might be due to invalid IL or missing references)
				if (Owner.HubBackBonesElasticity < 0.0001f)
				{
					return toHubNewB;
				}
				if (Owner.HubBackBonesElasticity <= 0.1f)
				{
					_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
				}
				else
				{
					_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
				}
				return _dir;
			}
		}

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		[Tooltip("Applying elasticity algorithm on the pelvis bone align motion, to make it look more organic.")]
		public float HipsElasticityBlend = 1f;

		public FMuscle_Vector3 HipsMuscle;

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float HipsRotElasticityBlend;

		public FMuscle_Quaternion HipsRotMuscle;

		[NonSerialized]
		public Vector3 LastKeyframePosition;

		[NonSerialized]
		public Vector3 LastKeyframeLocalPosition;

		[NonSerialized]
		public Quaternion LastKeyframeRotation;

		[NonSerialized]
		public Quaternion LastKeyframeLocalRotation;

		[NonSerialized]
		public Vector3 LastRootLocalPos;

		[NonSerialized]
		public float LastHipsHeightDiff;

		[NonSerialized]
		public Vector3 InitHipsPositionRootSpace;

		[NonSerialized]
		public float InitialHipsHeightLocal;

		[NonSerialized]
		internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

		private Transform root;

		private Vector3 initLocalPos;

		private Quaternion initLocalRot;

		private Vector3 _Hips_StabilityLocalAdjustement = Vector3.zero;

		private Vector3 _Hips_sd_StabilAdjustm = Vector3.zero;

		private Vector3 _stretchPreventerOff = Vector3.zero;

		private float _sd_Hips_StepHeightAdjustOffset;

		private int _h_lowestHitLeg = -1;

		private Vector3 _reAdjustLocal = Vector3.zero;

		private Vector3 _sd_readj = Vector3.zero;

		private Vector3 _pushSmoothed = Vector3.zero;

		private Vector3 _sd_pushSmoothed = Vector3.zero;

		public LegsAnimator Owner { get; private set; }

		public List<Leg> ChildLegs { get; private set; }

		public Transform bone { get; private set; }

		public UniRotateBone UniRotate { get; private set; }

		public List<HipsHubBackbone> HubBackBones { get; private set; }

		public Vector3 _Get_Hips_StabilityLocalAdjustement => _Hips_StabilityLocalAdjustement;

		public float _Hips_LastHipsOffset { get; private set; }

		public float _Hips_StepHeightAdjustOffset { get; private set; }

		public Vector3 ExtraNonElasticOffset { get; internal set; }

		public Vector3 _PreHipsAdjustPosition { get; internal set; }

		public void Initialize(LegsAnimator owner, Transform bone, Transform root)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			Owner = owner;
			this.bone = bone;
			this.root = root;
			initLocalPos = bone.localPosition;
			initLocalRot = bone.localRotation;
			ExtraNonElasticOffset = Vector3.zero;
			_Hips_StabilityLocalAdjustement = Vector3.zero;
			_Hips_sd_StabilAdjustm = Vector3.zero;
			InitHipsPositionRootSpace = root.InverseTransformPoint(bone.position);
			InitialHipsHeightLocal = InitHipsPositionRootSpace.y;
			if (HipsMuscle == null)
			{
				HipsMuscle = new FMuscle_Vector3();
			}
			if (HipsRotMuscle == null)
			{
				HipsRotMuscle = new FMuscle_Quaternion();
			}
			HipsMuscle.Initialize(Vector3.zero);
			HipsRotMuscle.Initialize(Quaternion.identity);
			UniRotate = new UniRotateBone(bone, root);
			Calibrate();
		}

		internal void PrepareLegs()
		{
			ChildLegs = new List<Leg>();
			if (!Owner._hipsHubs_using)
			{
				ChildLegs = Owner.Legs;
			}
			else
			{
				for (int i = 0; i < Owner.Legs.Count; i++)
				{
					bool? flag = IsFirstParent(Owner.Legs[i], bone);
					if (flag == true)
					{
						ChildLegs.Add(Owner.Legs[i]);
					}
					else if (!flag.HasValue && this == Owner.HipsSetup)
					{
						ChildLegs.Add(Owner.Legs[i]);
					}
				}
			}
			for (int j = 0; j < ChildLegs.Count; j++)
			{
				ChildLegs[j].AssignParentHub(this);
			}
		}

		internal void PrepareHubBones()
		{
			PrepareLegs();
			HubBackBones = new List<HipsHubBackbone>();
			Transform frontBone = bone;
			Transform parent = bone.parent;
			while ((Object)(object)parent != (Object)null)
			{
				bool flag = false;
				for (int i = 0; i < Owner.HipsHubs.Count; i++)
				{
					if ((Object)(object)parent == (Object)(object)Owner.HipsHubs[i].bone)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					HipsHubBackbone hipsHubBackbone = new HipsHubBackbone(Owner, parent);
					hipsHubBackbone.frontBone = frontBone;
					HubBackBones.Add(hipsHubBackbone);
					if (!((Object)(object)parent == (Object)(object)Owner.HipsSetup.bone))
					{
						frontBone = parent;
						parent = parent.parent;
						continue;
					}
					break;
				}
				break;
			}
		}

		private bool? IsFirstParent(Leg leg, Transform hub)
		{
			if ((Object)(object)leg.BoneStart == (Object)null)
			{
				return false;
			}
			Transform val = leg.BoneStart;
			while ((Object)(object)val != (Object)null)
			{
				if ((Object)(object)val == (Object)(object)hub)
				{
					return true;
				}
				if ((Object)(object)val == (Object)(object)Owner.Hips)
				{
					return false;
				}
				for (int i = 0; i < Owner.ExtraHipsHubs.Count; i++)
				{
					if ((Object)(object)val == (Object)(object)Owner.ExtraHipsHubs[i])
					{
						return false;
					}
				}
				val = val.parent;
			}
			return null;
		}

		public void Reset()
		{
			Calibrate();
			_Hips_LastHipsOffset = 0f;
		}

		public void PreCalibrate()
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			UniRotate.PreCalibrate();
			if (Owner.Calibrate != ECalibrateMode.FixedCalibrate)
			{
				UniRotate.PreCalibrate();
			}
			else
			{
				bone.localPosition = LastKeyframeLocalPosition;
				bone.localRotation = LastKeyframeLocalRotation;
			}
			if (HubBackBones != null)
			{
				for (int i = 0; i < HubBackBones.Count; i++)
				{
					HubBackBones[i].PreCalibrate();
				}
			}
		}

		public void Calibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			LastKeyframePosition = bone.position;
			LastKeyframeLocalPosition = bone.localPosition;
			LastKeyframeLocalRotation = bone.localRotation;
			LastKeyframeRotation = bone.rotation;
			LastRootLocalPos = Owner.ToRootLocalSpace(LastKeyframePosition);
			LastHipsHeightDiff = GetHeightDiff(LastRootLocalPos.y);
			if (HubBackBones != null)
			{
				for (int i = 0; i < HubBackBones.Count; i++)
				{
					HubBackBones[i].Calibrate();
				}
			}
		}

		public float GetHeightDiff(float rootSpaceHeight)
		{
			return Mathf.InverseLerp(0f, InitialHipsHeightLocal, rootSpaceHeight);
		}

		public void CopyMuscleSettingsFrom(HipsReference hipsSetup)
		{
			HipsMuscle.Acceleration = hipsSetup.HipsMuscle.Acceleration;
			HipsMuscle.AccelerationLimit = hipsSetup.HipsMuscle.AccelerationLimit;
			HipsMuscle.Damping = hipsSetup.HipsMuscle.Damping;
			HipsMuscle.BrakePower = hipsSetup.HipsMuscle.BrakePower;
		}

		public Vector3 CalculateCenterOfMassStability(float stabilizingMultiplier)
		{
			//IL_0331: Unknown result type (might be due to invalid IL or missing references)
			//IL_0336: Unknown result type (might be due to invalid IL or missing references)
			//IL_033c: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0191: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0328: Unknown result type (might be due to invalid IL or missing references)
			//IL_0329: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0317: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_0217: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_021e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0220: Unknown result type (might be due to invalid IL or missing references)
			//IL_0222: Unknown result type (might be due to invalid IL or missing references)
			//IL_0227: Unknown result type (might be due to invalid IL or missing references)
			//IL_0231: Unknown result type (might be due to invalid IL or missing references)
			//IL_0236: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_023d: Unknown result type (might be due to invalid IL or missing references)
			//IL_023f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_0246: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0251: Unknown result type (might be due to invalid IL or missing references)
			//IL_0263: Unknown result type (might be due to invalid IL or missing references)
			//IL_0264: Unknown result type (might be due to invalid IL or missing references)
			//IL_026d: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0285: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_028f: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.StabilizeCenterOfMass > 0f)
			{
				Vector3 val = default(Vector3);
				((Vector3)(ref val))..ctor(0f, 0f, 0f);
				float num = ChildLegs.Count;
				if (Owner.StabilityAlgorithm == EStabilityMode.Biped_Deprecated)
				{
					for (int i = 0; i < ChildLegs.Count; i++)
					{
						Leg leg = ChildLegs[i];
						Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
						Vector3 previousFinalIKPosForStability = leg._PreviousFinalIKPosForStability;
						Vector3 val3 = Owner.ToRootLocalSpace(previousFinalIKPosForStability + val2);
						Vector3 initialPosInRootSpace = leg.InitialPosInRootSpace;
						initialPosInRootSpace.y += _Hips_LastHipsOffset;
						Vector3 val4 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace, leg.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace) : leg.AnkleH.LastKeyframeRootPos);
						Vector3 val5 = val3 - val4;
						val5.y *= 0.25f;
						val += val5 * leg.BlendWeight * 0.5f * (stabilizingMultiplier * Owner.StabilizeCenterOfMass);
					}
					val.y /= num;
				}
				else if (Owner.StabilityAlgorithm == EStabilityMode.Universal)
				{
					Vector3 lastRootLocalPos = LastRootLocalPos;
					for (int j = 0; j < ChildLegs.Count; j++)
					{
						Leg leg2 = ChildLegs[j];
						Vector3 initialPosInRootSpace2 = leg2.InitialPosInRootSpace;
						initialPosInRootSpace2.y += _Hips_LastHipsOffset;
						Vector3 val6 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace2, leg2.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace2) : leg2.AnkleH.LastKeyframeRootPos);
						Vector3 val7 = lastRootLocalPos - val6;
						Vector3 val8 = Owner.ToRootLocalSpace(leg2._PreviousFinalIKPosForStability);
						Vector3 val9 = lastRootLocalPos - val8;
						Vector3 val10 = val7 - val9;
						val10.y *= 0.25f;
						val += val10 * leg2.BlendWeight * (stabilizingMultiplier * Owner.StabilizeCenterOfMass) / num;
					}
				}
				if (val.y > 0f)
				{
					val.y = 0f;
				}
				if (Owner.StabilizingSpeed < 1f)
				{
					float duration = 0f;
					if (Owner.StabilizingSpeed < 1f)
					{
						duration = 0.001f + (1f - Owner.StabilizingSpeed) * 0.4f;
					}
					Owner.ValueTowards(ref _Hips_StabilityLocalAdjustement, val, ref _Hips_sd_StabilAdjustm, duration);
				}
				else
				{
					_Hips_StabilityLocalAdjustement = val;
				}
			}
			else
			{
				_Hips_StabilityLocalAdjustement = Vector3.zero;
			}
			return _Hips_StabilityLocalAdjustement;
		}

		public Vector3 CalculateStretchPreventerOffset()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.HipsStretchPreventer < 0.0001f)
			{
				return Vector3.zero;
			}
			Vector3 val = Vector3.zero;
			float num = 0f;
			Vector3 lastRootLocalPos = LastRootLocalPos;
			lastRootLocalPos.y = 0f;
			lastRootLocalPos = Owner.baseTransform.TransformPoint(lastRootLocalPos);
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				float stretchValue = leg.IKProcessor.GetStretchValue(leg._PreviousFinalIKPosForStability);
				if (stretchValue > Owner.LimitLegStretch * 0.975f)
				{
					num += 1f;
					float num2 = stretchValue - Owner.LimitLegStretch * 0.975f;
					Vector3 vec = lastRootLocalPos - leg._PreviousFinalIKPosForStability;
					vec = Owner.ToRootLocalSpaceVec(vec);
					if (vec.y > 0f)
					{
						vec.y = 0f;
					}
					vec.x *= -0.6f;
					vec.z *= -0.6f;
					val += vec * Mathf.Clamp(num2 * 3f, 0f, 0.5f);
				}
			}
			if (Owner.StretchPreventerSpeed < 1f)
			{
				float num3 = Mathf.Lerp(8f, 40f, Owner.StretchPreventerSpeed) * Owner.DeltaTime;
				if (num > 0f)
				{
					_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, val / num, num3);
				}
				else
				{
					_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, Vector3.zero, num3 * 0.7f);
				}
			}
			else
			{
				_stretchPreventerOff = val;
			}
			return _stretchPreventerOff;
		}

		public Vector3 CalculateGlueMovePush()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_0198: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3.zero;
			if (Owner.GlueBlend < 0.0001f)
			{
				return val;
			}
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				if ((leg.G_Attached || leg.G_DuringLegAdjustMovement) && leg.G_LastLegMoveDistanceFactor > 0.055f && leg.G_GlueInternalTransition > 0f && leg.G_GlueInternalTransition < 1f && leg.G_HandlerExecutingLegAnimationMode == EGlueMode.Idle)
				{
					Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd);
					Vector3 val3 = Owner.ToRootLocalSpace(leg._PreviousFinalIKPosForStability + val2);
					val3.z = 0f - val3.z;
					float num = Owner.BaseLegAnimating.PushHipsOnMoveCurve.Evaluate(leg.G_GlueInternalTransition);
					Vector3 val4 = -val3 * num * 1f;
					val4.y -= num * leg.G_LastLegMoveDistanceFactor * Owner.ScaleReferenceNoScale * 0.75f;
					Vector3 val5;
					if (Owner.NormalizePush)
					{
						float num2 = Mathf.Min(1f, ((Vector3)(ref val4)).magnitude / (Owner.ScaleReferenceNoScale * 0.33f));
						num2 *= num2;
						val5 = ((Vector3)(ref val4)).normalized * Owner.ScaleReferenceNoScale * 0.33f * num2;
					}
					else
					{
						val5 = val4;
					}
					val5.y *= Owner.PushYBlend;
					val += val5 * leg.BlendWeight;
				}
			}
			return val;
		}

		private void AnimateStepAdjustTo(float yOffset)
		{
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.HipsHeightStepSpeed >= 1f)
			{
				_Hips_StepHeightAdjustOffset = yOffset;
				return;
			}
			float landingBoost = Owner.GetLandingBoost();
			if (Owner.HipsAdjustStyle == EHipsAdjustStyle.FollowLegHeight && yOffset < _Hips_StepHeightAdjustOffset && _h_lowestHitLeg != -1)
			{
				Vector3 previousFinalIKPos = Owner.Legs[_h_lowestHitLeg]._PreviousFinalIKPos;
				previousFinalIKPos = Owner.ToRootLocalSpace(previousFinalIKPos);
				previousFinalIKPos.y -= Owner.ScaleReferenceNoScale * 0.325f;
				if (previousFinalIKPos.y > yOffset)
				{
					yOffset = previousFinalIKPos.y;
				}
			}
			_Hips_StepHeightAdjustOffset = Mathf.SmoothDamp(_Hips_StepHeightAdjustOffset, yOffset, ref _sd_Hips_StepHeightAdjustOffset, Mathf.LerpUnclamped(0.4f, 0.01f, landingBoost), 1000000f, Owner.DeltaTime);
			_h_lowestHitLeg = -1;
		}

		public float CalculateBodyAdjust()
		{
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			_Hips_LastHipsOffset = 0f;
			if (Owner.HipsHeightStepBlend <= 0f)
			{
				return 0f;
			}
			if (Owner.IsGrounded)
			{
				Vector3 val = default(Vector3);
				((Vector3)(ref val))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
				Vector3 val2 = default(Vector3);
				((Vector3)(ref val2))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
				for (int i = 0; i < ChildLegs.Count; i++)
				{
					Leg leg = ChildLegs[i];
					if (!leg.RaycastHitted)
					{
						continue;
					}
					RaycastHit lastGroundHit = leg.LastGroundHit;
					Vector3 point = ((RaycastHit)(ref lastGroundHit)).point;
					point = Owner.ToRootLocalSpace(point);
					if (point.y <= 0f)
					{
						if (0f - point.y < Owner.BodyStepDown * Owner.ScaleReferenceNoScale && point.y < val.y)
						{
							val = point;
							_h_lowestHitLeg = i;
						}
					}
					else if (point.y < Owner.MaxBodyStepUp * Owner.ScaleReferenceNoScale && point.y < val.y)
					{
						val2 = point;
					}
				}
				bool flag = false;
				if (val.x != float.MaxValue && Owner.BodyStepDown > 0f && val.y <= 0f)
				{
					AnimateStepAdjustTo(val.y);
					flag = true;
				}
				if (!flag && Owner.MaxBodyStepUp > 0f && val2.x != float.MaxValue)
				{
					AnimateStepAdjustTo(val2.y);
					flag = true;
				}
				if (!flag)
				{
					AnimateStepAdjustTo(0f);
				}
			}
			else
			{
				AnimateStepAdjustTo(0f);
			}
			float num = Owner.HipsBlendWeight * Owner._MainBlend * Owner.IsGroundedBlend * Owner.RagdolledDisablerBlend;
			_Hips_LastHipsOffset = _Hips_StepHeightAdjustOffset * Owner.baseTransform.lossyScale.y * num;
			return _Hips_LastHipsOffset;
		}

		public Vector3 CalculateStretchReadjust()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3.zero;
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				Vector3 val2 = leg._FinalIKPos - val;
				if (leg.IKProcessor.GetStretchValue(val2) > Owner.LimitLegStretch)
				{
					Vector3 notStretchedPositionTowards = leg.IKProcessor.GetNotStretchedPositionTowards(val2, Owner.LimitLegStretch);
					Vector3 val3 = val2 - notStretchedPositionTowards;
					val += val3;
				}
			}
			val = Owner.ToRootLocalSpaceVec(val);
			_reAdjustLocal = Vector3.SmoothDamp(_reAdjustLocal, val, ref _sd_readj, 0.1f, 10000000f, Owner.DeltaTime);
			return _reAdjustLocal;
		}

		public Vector3 SmoothPushOffset(Vector3 pushLocalOffset, float pushDuration)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			Owner.ValueTowards(ref _pushSmoothed, pushLocalOffset, ref _sd_pushSmoothed, pushDuration);
			return _pushSmoothed;
		}

		public Vector3 AnimateOffset(Vector3 hubOffset)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return hubOffset;
		}
	}

	public enum EStabilityMode
	{
		Biped_Deprecated,
		Universal
	}

	[Serializable]
	public class Leg
	{
		private struct GlueAttachement
		{
			public RaycastHit AttachHit;

			public Transform AttachedTo;

			public Vector3 PosInAttachementLocal;

			public Vector3 NormalInAttachementLocal;

			public Quaternion RotInAttachementLocal;

			public bool NoTransform { get; private set; }

			public GlueAttachement(Leg leg, RaycastHit legGroundHit)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0067: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0080: Unknown result type (might be due to invalid IL or missing references)
				//IL_0085: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_003a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0046: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
				//IL_0098: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				AttachHit = legGroundHit;
				AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
				if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
				{
					NoTransform = true;
					PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
					NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
					RotInAttachementLocal = leg._PreviousFinalIKRot;
					return;
				}
				NoTransform = false;
				PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
				NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
				if (!leg.Owner.AnimateFeet)
				{
					RotInAttachementLocal = Quaternion.identity;
				}
				else
				{
					RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
				}
			}

			internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				//IL_000a: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				Vector3 relevantHitPoint = GetRelevantHitPoint();
				return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
			}

			internal Vector3 GetRelevantHitPoint()
			{
				//IL_0017: Unknown result type (might be due to invalid IL or missing references)
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				if (NoTransform || (Object)(object)AttachedTo == (Object)null)
				{
					return PosInAttachementLocal;
				}
				return AttachedTo.TransformPoint(PosInAttachementLocal);
			}

			internal Vector3 GetRelevantNormal()
			{
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				if (NoTransform)
				{
					return NormalInAttachementLocal;
				}
				return AttachedTo.TransformDirection(NormalInAttachementLocal);
			}

			internal Quaternion GetRelevantAttachementRotation()
			{
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				if (NoTransform)
				{
					return RotInAttachementLocal;
				}
				return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
			}

			internal void OverwritePosition(Vector3 legAnimPos)
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)AttachedTo == (Object)null)
				{
					PosInAttachementLocal = legAnimPos;
				}
				else
				{
					PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
				}
			}
		}

		private class GlueAttachementHandler
		{
			public class LegTransitionAnimation
			{
				private enum EMoveType
				{
					FromAnimation,
					FromLastAttachement
				}

				private GlueAttachementHandler handler;

				public float LegAdjustementYOffset;

				public float LegAdjustementFootAngleOffset;

				private Vector3 _legSpherizeLocalVector = Vector3.zero;

				private float _legMoveDurMul = 1f;

				private Quaternion baseRotationOnStepUp;

				public float legMoveDistanceFactor;

				private float sd_trProgress;

				private Vector3 previousPositionLocal;

				private Vector3 previousPositionWorld;

				private Quaternion previousRotationWorld;

				private Vector3 lastAppliedGluePosition;

				private Vector3 lastAppliedGluePositionLocal;

				private Quaternion lastAppliedGlueRotation;

				private float lastSpeedup;

				private EMoveType animationMoveType;

				private bool _instantTransition;

				private bool _wasAnimatingLeg;

				private LegsAnimator Owner => handler.Owner;

				private Leg leg => handler.leg;

				public bool duringLegAdjustMovement { get; private set; }

				public bool wasAttaching { get; private set; }

				public bool attached { get; private set; }

				public float transitionProgress { get; private set; }

				public float lastAttachCompleteTime { get; private set; }

				public float transitionProgressLastFrame { get; private set; }

				public EGlueMode LastAnimationGlueMode
				{
					get
					{
						if (animationMoveType != 0)
						{
							return EGlueMode.Idle;
						}
						return EGlueMode.Moving;
					}
				}

				public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
				{
					//IL_0001: Unknown result type (might be due to invalid IL or missing references)
					//IL_0006: Unknown result type (might be due to invalid IL or missing references)
					handler = glueTransitionHelper;
					Reset();
				}

				public void Reset()
				{
					//IL_0029: Unknown result type (might be due to invalid IL or missing references)
					//IL_002e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0049: Unknown result type (might be due to invalid IL or missing references)
					//IL_004e: Unknown result type (might be due to invalid IL or missing references)
					animationMoveType = EMoveType.FromAnimation;
					transitionProgress = 0f;
					transitionProgressLastFrame = 0f;
					baseRotationOnStepUp = Owner.BaseTransform.rotation;
					duringLegAdjustMovement = false;
					wasAttaching = false;
					attached = false;
					_legSpherizeLocalVector = Vector3.zero;
					ReInitialize();
				}

				public void ReInitialize()
				{
					//IL_0007: Unknown result type (might be due to invalid IL or missing references)
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0018: Unknown result type (might be due to invalid IL or missing references)
					//IL_001d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0029: Unknown result type (might be due to invalid IL or missing references)
					//IL_002e: Unknown result type (might be due to invalid IL or missing references)
					//IL_003a: Unknown result type (might be due to invalid IL or missing references)
					//IL_003f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0051: Unknown result type (might be due to invalid IL or missing references)
					//IL_0056: Unknown result type (might be due to invalid IL or missing references)
					//IL_005b: Unknown result type (might be due to invalid IL or missing references)
					lastAppliedGluePosition = leg._SourceIKPos;
					lastAppliedGlueRotation = leg._SourceIKRot;
					previousPositionWorld = leg._SourceIKPos;
					previousRotationWorld = leg._SourceIKRot;
					previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
				}

				internal void ScheduleInstantTransition()
				{
					_instantTransition = true;
				}

				internal void DoAttaching(bool canAttach)
				{
					if (canAttach != wasAttaching)
					{
						wasAttaching = canAttach;
						if (canAttach)
						{
							OnChangeTargetPosition();
						}
						else
						{
							attached = false;
							if (transitionProgress != 0f)
							{
								OnChangeTargetPosition();
							}
						}
					}
					if (duringLegAdjustMovement && transitionProgress >= 1f)
					{
						duringLegAdjustMovement = false;
					}
				}

				internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
				{
					//IL_0099: Unknown result type (might be due to invalid IL or missing references)
					//IL_0023: Unknown result type (might be due to invalid IL or missing references)
					//IL_0024: Unknown result type (might be due to invalid IL or missing references)
					//IL_0029: Unknown result type (might be due to invalid IL or missing references)
					//IL_0042: Unknown result type (might be due to invalid IL or missing references)
					//IL_0047: Unknown result type (might be due to invalid IL or missing references)
					//IL_006a: Unknown result type (might be due to invalid IL or missing references)
					//IL_005d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0070: Unknown result type (might be due to invalid IL or missing references)
					//IL_0076: Unknown result type (might be due to invalid IL or missing references)
					//IL_006f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0080: Unknown result type (might be due to invalid IL or missing references)
					//IL_0091: Unknown result type (might be due to invalid IL or missing references)
					//IL_0092: Unknown result type (might be due to invalid IL or missing references)
					//IL_0097: Unknown result type (might be due to invalid IL or missing references)
					if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
					{
						Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
						Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
						if (val.y < val2.y)
						{
							val.y = val2.y;
							legAnimPos = Owner.RootToWorldSpace(val);
						}
					}
					return legAnimPos;
				}

				public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
				{
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_000d: Unknown result type (might be due to invalid IL or missing references)
					//IL_001f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0024: Unknown result type (might be due to invalid IL or missing references)
					//IL_0056: Unknown result type (might be due to invalid IL or missing references)
					//IL_0063: Unknown result type (might be due to invalid IL or missing references)
					//IL_006b: Unknown result type (might be due to invalid IL or missing references)
					//IL_0078: Unknown result type (might be due to invalid IL or missing references)
					//IL_007d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0082: Unknown result type (might be due to invalid IL or missing references)
					//IL_0087: Unknown result type (might be due to invalid IL or missing references)
					//IL_012a: Unknown result type (might be due to invalid IL or missing references)
					LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
					Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
					if (legAnimatingSettings.SpherizeTrack.length > 1)
					{
						float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
						val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
					}
					if (Owner.AnimateFeet)
					{
						LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
						LegAdjustementFootAngleOffset /= lastSpeedup;
					}
					float num2 = Owner.ScaleReferenceNoScale * 0.75f;
					float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
					num3 *= num2;
					LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
					_wasAnimatingLeg = true;
					return val;
				}

				internal Vector3 GetTargetPosition()
				{
					//IL_0122: Unknown result type (might be due to invalid IL or missing references)
					//IL_0127: Unknown result type (might be due to invalid IL or missing references)
					//IL_0107: Unknown result type (might be due to invalid IL or missing references)
					//IL_010c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0111: Unknown result type (might be due to invalid IL or missing references)
					//IL_0038: Unknown result type (might be due to invalid IL or missing references)
					//IL_003d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0042: Unknown result type (might be due to invalid IL or missing references)
					//IL_0026: Unknown result type (might be due to invalid IL or missing references)
					//IL_002b: Unknown result type (might be due to invalid IL or missing references)
					//IL_0138: Unknown result type (might be due to invalid IL or missing references)
					//IL_0144: Unknown result type (might be due to invalid IL or missing references)
					//IL_0149: Unknown result type (might be due to invalid IL or missing references)
					//IL_0154: Unknown result type (might be due to invalid IL or missing references)
					//IL_0159: Unknown result type (might be due to invalid IL or missing references)
					//IL_0135: Unknown result type (might be due to invalid IL or missing references)
					//IL_011f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0050: Unknown result type (might be due to invalid IL or missing references)
					//IL_0177: Unknown result type (might be due to invalid IL or missing references)
					//IL_017e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0183: Unknown result type (might be due to invalid IL or missing references)
					//IL_0188: Unknown result type (might be due to invalid IL or missing references)
					//IL_016d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0172: Unknown result type (might be due to invalid IL or missing references)
					//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
					//IL_0068: Unknown result type (might be due to invalid IL or missing references)
					//IL_006d: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
					//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
					//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
					//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
					//IL_0197: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
					//IL_00de: Unknown result type (might be due to invalid IL or missing references)
					//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
					//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
					//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
					//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
					//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
					//IL_008e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0093: Unknown result type (might be due to invalid IL or missing references)
					//IL_0098: Unknown result type (might be due to invalid IL or missing references)
					float glueAnimationBlend = handler.glueAnimationBlend;
					if (animationMoveType == EMoveType.FromAnimation)
					{
						if (glueAnimationBlend < 0.0001f)
						{
							return Owner.RootToWorldSpace(previousPositionLocal);
						}
						Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
						if (transitionProgress < 0.0001f)
						{
							return val;
						}
						Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
						if (transitionProgress > 0.9995f)
						{
							return val2;
						}
						return Vector3.LerpUnclamped(val, val2, transitionProgress);
					}
					Vector3 val3;
					if (leg.Owner.OnlyLocalAnimation)
					{
						val3 = Owner.RootToWorldSpace(previousPositionLocal);
						if (transitionProgress < 0.0001f)
						{
							return val3;
						}
					}
					else
					{
						val3 = previousPositionWorld;
						if (transitionProgress < 0.0001f)
						{
							return val3;
						}
						val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
					}
					Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
					if (transitionProgress >= 1f)
					{
						return val4;
					}
					float num = 1f - transitionProgress;
					return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
				}

				internal void RequireRepose()
				{
					if (attached)
					{
						attached = false;
						OnChangeTargetPosition();
					}
				}

				internal Quaternion GetTargetRotation()
				{
					//IL_0001: Unknown result type (might be due to invalid IL or missing references)
					//IL_0006: Unknown result type (might be due to invalid IL or missing references)
					//IL_0014: Unknown result type (might be due to invalid IL or missing references)
					//IL_0015: Unknown result type (might be due to invalid IL or missing references)
					//IL_0016: Unknown result type (might be due to invalid IL or missing references)
					//IL_0034: Unknown result type (might be due to invalid IL or missing references)
					//IL_0039: Unknown result type (might be due to invalid IL or missing references)
					//IL_0026: Unknown result type (might be due to invalid IL or missing references)
					//IL_002b: Unknown result type (might be due to invalid IL or missing references)
					//IL_004b: Unknown result type (might be due to invalid IL or missing references)
					//IL_004c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0053: Unknown result type (might be due to invalid IL or missing references)
					//IL_0058: Unknown result type (might be due to invalid IL or missing references)
					//IL_0047: Unknown result type (might be due to invalid IL or missing references)
					//IL_0048: Unknown result type (might be due to invalid IL or missing references)
					//IL_0059: Unknown result type (might be due to invalid IL or missing references)
					Quaternion val = previousRotationWorld;
					if (transitionProgress < 0.001f)
					{
						return val;
					}
					Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
					if (transitionProgress > 0.9995f)
					{
						return val2;
					}
					return Quaternion.LerpUnclamped(val, val2, transitionProgress);
				}

				internal void OnChangeTargetPosition()
				{
					//IL_0022: Unknown result type (might be due to invalid IL or missing references)
					//IL_0027: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
					//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
					//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
					//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
					//IL_0100: Unknown result type (might be due to invalid IL or missing references)
					//IL_0105: Unknown result type (might be due to invalid IL or missing references)
					//IL_010a: Unknown result type (might be due to invalid IL or missing references)
					//IL_0141: Unknown result type (might be due to invalid IL or missing references)
					//IL_0146: Unknown result type (might be due to invalid IL or missing references)
					//IL_014d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0152: Unknown result type (might be due to invalid IL or missing references)
					//IL_0153: Unknown result type (might be due to invalid IL or missing references)
					//IL_0158: Unknown result type (might be due to invalid IL or missing references)
					//IL_0197: Unknown result type (might be due to invalid IL or missing references)
					//IL_019c: Unknown result type (might be due to invalid IL or missing references)
					//IL_019d: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
					//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
					//IL_0247: Unknown result type (might be due to invalid IL or missing references)
					//IL_024c: Unknown result type (might be due to invalid IL or missing references)
					//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
					//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
					//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
					//IL_0201: Unknown result type (might be due to invalid IL or missing references)
					//IL_0211: Unknown result type (might be due to invalid IL or missing references)
					//IL_0213: Unknown result type (might be due to invalid IL or missing references)
					//IL_0223: Unknown result type (might be due to invalid IL or missing references)
					//IL_022d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0232: Unknown result type (might be due to invalid IL or missing references)
					handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
					baseRotationOnStepUp = Owner.BaseTransform.rotation;
					if (handler.glueAnimationBlend < 0.2f)
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					else if (animationMoveType == EMoveType.FromLastAttachement)
					{
						animationMoveType = EMoveType.FromLastAttachement;
					}
					else if (handler.glueAnimationBlend > 0.75f)
					{
						if (transitionProgress < 0.1f || transitionProgress > 0.9f)
						{
							animationMoveType = EMoveType.FromLastAttachement;
						}
						else
						{
							animationMoveType = EMoveType.FromAnimation;
						}
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					if (leg.Owner.OnlyLocalAnimation)
					{
						previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
					}
					else
					{
						previousPositionWorld = lastAppliedGluePosition;
					}
					previousRotationWorld = lastAppliedGlueRotation;
					previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
					if (animationMoveType == EMoveType.FromLastAttachement)
					{
						if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
						{
							transitionProgress = 0f;
						}
						Vector3 val = previousPositionWorld;
						Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
						float magnitude = ((Vector3)(ref val2)).magnitude;
						legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
						legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
						Vector3 val3 = ((Vector3)(ref val2)).normalized;
						val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
						((Vector3)(ref val3)).Normalize();
						leg.SendRaiseEvent(magnitude);
						if (legMoveDistanceFactor > 0.0401f)
						{
							_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
							Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
							((Vector3)(ref worldDir)).Normalize();
							_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
							duringLegAdjustMovement = true;
						}
						else
						{
							animationMoveType = EMoveType.FromAnimation;
							_legSpherizeLocalVector = Vector3.zero;
							duringLegAdjustMovement = false;
						}
					}
					else
					{
						duringLegAdjustMovement = false;
						transitionProgress = 0f;
					}
				}

				public void UpdateAnimation()
				{
					//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
					//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
					//IL_0201: Unknown result type (might be due to invalid IL or missing references)
					//IL_0211: Unknown result type (might be due to invalid IL or missing references)
					//IL_011a: Unknown result type (might be due to invalid IL or missing references)
					//IL_0107: Unknown result type (might be due to invalid IL or missing references)
					//IL_010c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0111: Unknown result type (might be due to invalid IL or missing references)
					//IL_0192: Unknown result type (might be due to invalid IL or missing references)
					//IL_0197: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
					//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
					float num = (Owner.JustGrounded ? 0.2f : 1f);
					float num2 = (Owner.JustGrounded ? 5f : 1f);
					transitionProgressLastFrame = transitionProgress;
					if (_instantTransition)
					{
						_instantTransition = false;
						transitionProgress = 1f;
						lastAttachCompleteTime = Time.time;
					}
					if (!Owner.IsGrounded)
					{
						return;
					}
					if (animationMoveType == EMoveType.FromLastAttachement)
					{
						float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
						float num4 = 1f;
						lastSpeedup = 1f;
						if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
						{
							if (leg.hasOppositeleg)
							{
								Leg oppositeLeg = leg.GetOppositeLeg();
								Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
								if (leg.Owner.OnlyLocalAnimation)
								{
									targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
								}
								float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
								if (stretchValue > leg.LegStretchLimit * 0.95f)
								{
									float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
									if (num5 < 0f)
									{
										num5 = 0f;
									}
									num4 += num5;
								}
								if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
								{
									Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
									float magnitude = ((Vector3)(ref val)).magnitude;
									float num6 = Owner.ScaleReference * 0.4f;
									if (magnitude > num6)
									{
										float num7 = magnitude - num6;
										num4 += num7 / num6 * 2f;
									}
								}
							}
							if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
							{
								float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
								if (num8 > 12f)
								{
									float num9 = Mathf.InverseLerp(30f, 135f, num8);
									num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
									transitionProgress += Owner.DeltaTime * num9 * num2;
								}
							}
							num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
						}
						lastSpeedup = num4;
						transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
						if (transitionProgress > 0.9995f && duringLegAdjustMovement)
						{
							TriggerAttach();
						}
					}
					else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
					{
						TriggerAttach();
					}
					else
					{
						transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
					}
				}

				private void TriggerAttach()
				{
					if (!attached)
					{
						transitionProgress = 1f;
						lastAttachCompleteTime = Time.time;
						attached = leg.Glue_TriggerFinalAttach();
						duringLegAdjustMovement = false;
					}
				}

				public void PostUpdate()
				{
					//IL_0007: Unknown result type (might be due to invalid IL or missing references)
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0019: Unknown result type (might be due to invalid IL or missing references)
					//IL_001e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0023: Unknown result type (might be due to invalid IL or missing references)
					//IL_002f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0034: Unknown result type (might be due to invalid IL or missing references)
					lastAppliedGluePosition = leg._GluePosition;
					lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
					lastAppliedGlueRotation = leg._GlueRotation;
					if (!_wasAnimatingLeg)
					{
						LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
						LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
					}
					else
					{
						_wasAnimatingLeg = false;
					}
				}
			}

			private LegsAnimator Owner;

			private Leg ParentLeg;

			private float _sd_glueAnimationBlend;

			private bool _instantTransition;

			private Vector3 lastGluePosition = Vector3.zero;

			private Quaternion lastGlueRotation = Quaternion.identity;

			public LegTransitionAnimation legMoveAnimation { get; private set; }

			private Leg leg => ParentLeg;

			public float glueAnimationBlend { get; private set; }

			public float attachTransitionProgress => legMoveAnimation.transitionProgress;

			public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

			public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

			public EGlueMode lasGlueModeOnAttaching { get; private set; }

			public GlueAttachementHandler(Leg leg)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				ParentLeg = leg;
				Owner = leg.Owner;
				legMoveAnimation = new LegTransitionAnimation(this);
				lasGlueModeOnAttaching = Owner._glueModeExecuted;
				Reset(initializing: true);
			}

			public void Reset(bool initializing)
			{
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0040: Unknown result type (might be due to invalid IL or missing references)
				glueAnimationBlend = 0f;
				_sd_glueAnimationBlend = 0f;
				if (initializing)
				{
					lastGluePosition = leg.BoneEnd.position;
					lastGlueRotation = leg.BoneEnd.rotation;
				}
				legMoveAnimation.Reset();
			}

			public void SheduleInstantTransition()
			{
				_instantTransition = true;
				legMoveAnimation.ScheduleInstantTransition();
			}

			public void TransitionToGlueAnimation()
			{
				legMoveAnimation.DoAttaching(canAttach: true);
				ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
			}

			public void TransitionToDisableGlueAnimation()
			{
				legMoveAnimation.DoAttaching(canAttach: false);
				ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
			}

			public Vector3 GetGluePosition()
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_0052: Unknown result type (might be due to invalid IL or missing references)
				//IL_005d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				if (glueAnimationBlend > 0.9995f)
				{
					lastGluePosition = legMoveAnimation.GetTargetPosition();
				}
				else if (glueAnimationBlend < 0.0001f)
				{
					lastGluePosition = leg.A_PreIKPosForGluing;
				}
				else
				{
					lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
				}
				return lastGluePosition;
			}

			public Quaternion GetGlueRotation()
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_0052: Unknown result type (might be due to invalid IL or missing references)
				//IL_005d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				if (glueAnimationBlend > 0.999f)
				{
					lastGlueRotation = legMoveAnimation.GetTargetRotation();
				}
				else if (glueAnimationBlend < 0f)
				{
					lastGlueRotation = leg._FinalIKRot;
				}
				else
				{
					lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
				}
				return lastGlueRotation;
			}

			public void UpdateTransitioning(bool attaching)
			{
				legMoveAnimation.UpdateAnimation();
			}

			public void PostUpdate()
			{
				legMoveAnimation.PostUpdate();
			}

			internal void OnLegRequireRepose()
			{
				legMoveAnimation.RequireRepose();
			}

			private void ChangeGlueAnimationBlendTo(float target, float speed)
			{
				if (Owner.GroundedTime < 0f)
				{
					speed = 0.99f;
				}
				if (_instantTransition && target > 0f)
				{
					glueAnimationBlend = target;
					_instantTransition = false;
					return;
				}
				if (speed >= 1f)
				{
					glueAnimationBlend = target;
					return;
				}
				if (leg.G_JustLanded)
				{
					glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
				}
				glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
				if (float.IsNaN(_sd_glueAnimationBlend))
				{
					_sd_glueAnimationBlend = 0f;
				}
			}
		}

		public enum GlueReposeRequest
		{
			None,
			Repose,
			ReposeIfFar
		}

		public class LegHelper
		{
			public Transform Bone;

			public LegHelper Child;

			public Vector3 InitPositionRootSpace;

			public Vector3 LastKeyframeRootPos;

			public LegHelper(Leg leg, Transform bone)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_001a: Unknown result type (might be due to invalid IL or missing references)
				Bone = bone;
				InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
			}

			public void Calibrate(Leg leg, Vector3 wPos)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0003: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
			}
		}

		private GlueAttachement G_Attachement;

		public bool G_CustomForceAttach;

		public bool G_CustomForceNOTDetach;

		public bool G_CustomForceDetach;

		public bool G_CustomForceNOTAttach;

		private float lastFootForwardAngleDiffABS;

		private GlueAttachementHandler G_AttachementHandler;

		private Vector3 A_PreviousRelevantAnklePos;

		private Vector3 A_LastApppliedAlignPos;

		private Vector3 A_LastApppliedAlignPosLocal;

		private Vector3 A_PreIKPosForGluing;

		private Quaternion A_LastApppliedAlignRot;

		private Quaternion A_LastTargetAlignRot;

		private bool A_WasFullAlign;

		private float A_aligningBlendByGluing = 1f;

		private Vector3 A_LastElevation;

		private float A_LastElevateH;

		private float _sd_A_Elev;

		[NonSerialized]
		public float Adj_A_ElevateLerpSpeedStart = 8f;

		[NonSerialized]
		public float Adj_A_ElevateLerpSpeedAfter = 5f;

		[NonSerialized]
		public float Adj_A_ElevateSpeedupMargin = 0.014f;

		private float A_AligningFor;

		private Vector3 A_LastAlignRootSpacePos;

		private Vector3 A_LastSmoothTargetedPosLocal;

		private float A_LastSuddenSmoothYOffset;

		private float A_SuddenSmoothing;

		private float A_lastSuddenSmoothingDiff;

		private bool A_WasSmoothing;

		private bool A_WasAligningFrameBack;

		private Vector3 A_SmoothedIKPos;

		[NonSerialized]
		public bool G_InstantReglue;

		private float _glueTargetBlend = 1f;

		private float _gluingCulldown;

		protected bool G_JustLanded;

		[NonSerialized]
		public float ExtraGluingBlend = 1f;

		private Vector3 _GlueLastAttachPosition;

		private Vector3 _GlueLastAttachPositionRootLocal;

		private Quaternion _GlueLastAttachRotation;

		private Vector3 _GluePosition;

		private Quaternion _GlueRotation;

		private Vector3 _G_LastPreGlueSourceLocalIKPos;

		private Vector3 _G_PreGlueSourceLocalIKPos;

		private Vector3 _G_sd_RefSwing = Vector3.zero;

		private bool _G_WasDisabled = true;

		[NonSerialized]
		public GlueReposeRequest G_RequestRepose;

		private bool _G_WasGrounded = true;

		private Vector3 _G_LasGroundedPosLocal;

		private Quaternion _G_LasGroundedRotLocal;

		private Vector3 G_GlueDragOffset = Vector3.zero;

		private LegHelper _h_boneStart;

		private LegHelper _h_boneMid;

		private LegHelper _h_boneEnd;

		private Vector3 C_AnkleToHeelRootSpace = Vector3.one;

		private Vector3 C_LastHeelWorldPos;

		private Vector3 C_LastHeelRootSpacePos;

		private Vector3 C_LastFootEndWorldPos;

		private Vector3 C_LastFootEndRootSpacePos;

		private Vector3 C_Local_AnkleToHeelRotated;

		private float _C_DynamicYScale = 1f;

		public LegsAnimator Owner;

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float LegBlendWeight = 1f;

		internal float InternalModuleBlendWeight = 1f;

		private float finalBoneBlend = 1f;

		[Tooltip("Make idle glue animation motion faster for this single leg")]
		public float LegMoveSpeedMultiplier = 1f;

		public float LegRaiseMultiplier = 1f;

		[Space(3f)]
		public float GlueThresholdMultiplier = 1f;

		public Vector2 GluePointOffset = Vector2.zero;

		[Space(3f)]
		[Range(0f, 1f)]
		public float LegStretchMultiplier = 1f;

		[Tooltip("Motion preset for the leg to be animated with different character than the other legs ('Idle Glue Motion' settings)")]
		public LegMotionSettingsPreset CustomLegAnimating;

		[Range(-40f, 40f)]
		public float FootPitchOffset;

		public Transform BoneStart;

		public Transform BoneMid;

		public Transform BoneEnd;

		public ELegSide Side;

		public int OppositeLegIndex = -1;

		public ERaycastPrecision RaycastPrecision;

		[Tooltip("(Experimental) If you want to animate in additional feet bone which in some cases can add nice animation feeling")]
		public bool UseFeet;

		public Transform BoneFeet;

		[Tooltip("Defining how quick heel should get up if leg gets stretched (change max stretching param under IK tab to be lower value that 1.1)")]
		[Range(0f, 1f)]
		public float FeetSensitivity = 0.5f;

		private bool hasOppositeleg;

		private LegStepAnimatingParameters targetLegAnimating;

		[Tooltip("Apply IK hint inversion, in case leg is bending in wrong direction.")]
		public bool InverseHint;

		public Vector3 AnkleToHeel = Vector3.zero;

		public Vector3 AnkleToFeetEnd = Vector3.zero;

		public Vector3 AnkleRight = Vector3.right;

		public Vector3 AnkleUp = Vector3.up;

		public Vector3 AnkleForward = Vector3.forward;

		[Range(0f, 1.001f)]
		public float FootMiddlePosition = 0.5f;

		[Space(5f)]
		[FPD_Suffix(-45f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "", true, 0)]
		public float AnkleYawCorrection;

		private bool _StepSent = true;

		private float _StepSentAt = -100f;

		private float _RaiseSentAt = -100f;

		private bool _OppositeLegStepped = true;

		private float _ToConfirmStepEvent;

		private Vector3 _SourceIKPosUnchangedY;

		private Vector3 _SourceIKPos;

		public Vector3 _FinalIKPos;

		private Quaternion _SourceIKRot;

		private Quaternion _FinalIKRot;

		private bool customOverwritingIKPos;

		private Vector3 customOverwritePos = Vector3.zero;

		private bool customOverwritingIKRot;

		private Quaternion customOverwriteRot = Quaternion.identity;

		private bool _wasFixedCalibrateAnimationCaptured;

		private bool _wasGrounded = true;

		private Vector3 _ungroundLocalIKCache;

		private bool _overwrittenSourceIKPos;

		public RaycastHit legGroundHit;

		public RaycastHit lastGroundHitWithTarget;

		private Vector3 previousAnkleAlignedOnGroundHitWorldPos;

		private Vector3 ankleAlignedOnGroundHitRootLocal;

		private Quaternion ankleAlignedOnGroundHitRotation;

		private RaycastHit replacementHit;

		private bool _UsingEmptyRaycast;

		private bool _UsingCustomRaycast;

		private bool _disableSourceRaycast;

		private float _CustomRaycastBlendIn;

		private RaycastHit _CustomRaycastHit;

		private Vector3 _PreviousCustomRaycastingStartIKPos;

		private Vector3 _PreviousCustomRaycastingIKPos;

		private bool _noRaycast_skipFeetCalcs;

		public bool G_AttachPossible
		{
			get
			{
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				if (RaycastHitted)
				{
					return C_Local_MidFootPosVsGroundHit.y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel;
				}
				return false;
			}
		}

		public bool _Glue_AskingForDetach { get; private set; }

		public float BelowFootRange => ScaleRef * _C_DynamicYScale * 0.2f;

		private GlueAttachementHandler.LegTransitionAnimation G_LegAnimation => G_AttachementHandler.legMoveAnimation;

		public Vector3 G_GluePosition => _GluePosition;

		public float G_GlueAnimationBlend => G_AttachementHandler.glueAnimationBlend;

		public float G_GlueInternalTransition => G_AttachementHandler.attachTransitionProgress;

		public float G_LastAttachCompleteTime => G_AttachementHandler.legMoveAnimation.lastAttachCompleteTime;

		public float G_GlueInternalTransitionLastFrame => G_AttachementHandler.attachTransitionProgressLastFrame;

		public float G_LastLegMoveDistanceFactor => G_AttachementHandler.legMoveDistanceFactor;

		public bool G_DuringLegAdjustMovement => G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement;

		public EGlueMode G_HandlerExecutingLegAnimationMode => G_AttachementHandler.legMoveAnimation.LastAnimationGlueMode;

		public bool A_PreWasAligning { get; private set; }

		public bool A_PreWasAligningNearGround { get; private set; }

		public bool A_WasAligning { get; private set; }

		public float A_AligningHelperBlend { get; private set; }

		public float A_LastAlignHeightDiff { get; private set; }

		public float A_LastAlignHeightCompareValue { get; private set; }

		public bool G_Attached { get; private set; }

		public bool G_DuringAttaching => G_LegAnimation.duringLegAdjustMovement;

		public bool G_FadingIn => G_LegAnimation.duringLegAdjustMovement;

		public Vector3 _G_RefernceSwing { get; private set; }

		private float G_GlueTesholdRange => Owner.ScaleReferenceNoScale * GlueThresholdMultiplier * Owner.GlueRangeThreshold * 0.5f;

		private Transform Root => Owner.BaseTransform;

		private float ScaleRef => Owner.ScaleReference;

		private float FloorLevel => Owner._glueingFloorLevel;

		private float DeltaTime => Owner.DeltaTime;

		public LegHelper ThighH => _h_boneStart;

		private FimpIK_Limb.IKBone ThighIK => IKProcessor.StartIKBone;

		public LegHelper LowerLegH => _h_boneMid;

		private FimpIK_Limb.IKBone LowerLegIK => IKProcessor.MiddleIKBone;

		public LegHelper AnkleH => _h_boneEnd;

		public FimpIK_Limb.IKBone AnkleIK => IKProcessor.EndIKBone;

		public Vector3 C_LastMidRefFootWorldPos { get; private set; }

		public Vector3 C_LastMidRefFootRootSpacePos { get; private set; }

		public Vector3 C_Local_MidFootPosVsGroundHit { get; private set; }

		public float C_Local_FootElevateInAnimation { get; private set; }

		public float C_AnkleToHeelWorldHeight { get; private set; }

		public float C_AnimatedAnkleFlatHeight { get; private set; }

		public int PlaymodeIndex { get; private set; }

		public float BlendWeight { get; private set; }

		[field: NonSerialized]
		public Leg NextLeg { get; private set; }

		[field: NonSerialized]
		public HipsReference ParentHub { get; private set; }

		public LegStepAnimatingParameters LegAnimatingSettings => targetLegAnimating;

		public float LegStretchLimit { get; private set; } = 1f;

		public FimpIK_Limb IKProcessor { get; private set; }

		public Vector3 _PreviousFinalIKPos { get; private set; }

		public Vector3 _PreviousFinalIKPosRootLocal { get; private set; }

		public Vector3 _PreviousFinalIKPosForStability { get; private set; }

		public Quaternion _PreviousFinalIKRot { get; private set; }

		public Vector3 _AnimatorStartBonePos { get; private set; }

		public Vector3 _AnimatorMidBonePos { get; private set; }

		public Vector3 _AnimatorEndBonePos { get; private set; }

		public Quaternion _AnimatorStartBoneLocRot { get; private set; }

		public Quaternion _AnimatorMidBoneLocRot { get; private set; }

		public Quaternion _AnimatorEndBoneLocRot { get; private set; }

		public bool RaycastHitted { get; private set; }

		public RaycastHit LastGroundHit => legGroundHit;

		public Vector3 groundHitRootSpacePos { get; private set; }

		public Vector3 lastRaycastingOrigin { get; private set; }

		public Vector3 lastRaycastingEndPoint { get; private set; }

		public Vector3 ankleAlignedOnGroundHitWorldPos { get; private set; }

		public bool User_RaycastHittedSource { get; private set; }

		public float raycastSlopeAngle { get; private set; }

		public Vector3 InitialPosInRootSpace { get; private set; }

		public List<Leg> Legs => Owner.Legs;

		public bool Glue_CheckDetachement()
		{
			bool flag = Glue_Conditions_Detach();
			if (!flag)
			{
				flag = Glue_Conditions_DetachForced();
			}
			_Glue_AskingForDetach = flag;
			return flag;
		}

		public bool Glue_CheckIdleDetachementConfirm()
		{
			if (Owner._glueModeExecuted != 0)
			{
				return true;
			}
			if (hasOppositeleg)
			{
				Leg oppositeLeg = GetOppositeLeg();
				if (Glue_CheckOppositeLegMovementRestriction(oppositeLeg))
				{
					return false;
				}
			}
			return true;
		}

		private bool Glue_Conditions_Attach()
		{
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			if (!Owner.IsGrounded)
			{
				return false;
			}
			if (_glueTargetBlend < 0.0001f)
			{
				return false;
			}
			if (!RaycastHitted)
			{
				return false;
			}
			if (G_CustomForceNOTDetach)
			{
				return true;
			}
			if (_gluingCulldown > 0f)
			{
				return false;
			}
			if (G_CustomForceAttach)
			{
				return true;
			}
			if (Owner.DontGlueAttachIfTooNearOppositeLeg > 0f && hasOppositeleg)
			{
				Vector3 val = ToRootLocalSpace(_PreviousFinalIKPos);
				Leg oppositeLeg = GetOppositeLeg();
				Vector3 val2 = ToRootLocalSpace(oppositeLeg._PreviousFinalIKPos);
				float num = Owner.DontGlueAttachIfTooNearOppositeLeg * Owner.ScaleReference;
				if (Vector2.Distance(new Vector2(val.x, val.z), new Vector2(val2.x, val2.z)) < num)
				{
					return false;
				}
			}
			if (G_HandlerExecutingLegAnimationMode == EGlueMode.Moving)
			{
				bool flag = false;
				float y = C_Local_MidFootPosVsGroundHit.y;
				if (y > FloorLevel)
				{
					if (y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				if (!flag)
				{
					return false;
				}
			}
			if (G_CustomForceNOTAttach)
			{
				return false;
			}
			if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f && Owner.DesiredMovementDirection != Vector3.zero)
			{
				Vector3 val3 = ToRootLocalSpaceDir(Owner.DesiredMovementDirection);
				Vector3 g_RefernceSwing = _G_RefernceSwing;
				if (Vector3.Dot(((Vector3)(ref val3)).normalized, ((Vector3)(ref g_RefernceSwing)).normalized) > 1f - Owner.SwingHelper)
				{
					return false;
				}
			}
			return true;
		}

		private bool Glue_CheckOppositeLegMovementRestriction(Leg oppositeLeg)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			if (!RaycastHitted)
			{
				return false;
			}
			if (!Owner.IsGrounded)
			{
				return false;
			}
			if (C_Local_MidFootPosVsGroundHit.y > BelowFootRange)
			{
				return false;
			}
			if (G_CustomForceNOTDetach)
			{
				return true;
			}
			if (!oppositeLeg.RaycastHitted)
			{
				return false;
			}
			if (oppositeLeg.C_Local_MidFootPosVsGroundHit.y > oppositeLeg.BelowFootRange)
			{
				return false;
			}
			if (oppositeLeg.G_GlueInternalTransition < LegAnimatingSettings.AllowDetachBefore)
			{
				return true;
			}
			return false;
		}

		private Leg GetOppositeLeg()
		{
			if (OppositeLegIndex < 0)
			{
				return null;
			}
			if (OppositeLegIndex >= Owner.Legs.Count)
			{
				return null;
			}
			return Owner.Legs[OppositeLegIndex];
		}

		private void Gluing_SetCulldown(float minDuration = 0.01f)
		{
			_gluingCulldown = Mathf.Max(_gluingCulldown, minDuration + (0.02f - Owner.GlueFadeOutSpeed * 0.03f));
		}

		public bool Glue_Conditions_Detach()
		{
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			bool flag = false;
			if (G_CustomForceNOTDetach)
			{
				return flag;
			}
			if (G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement)
			{
				return false;
			}
			if (!Glue_Conditions_Attach())
			{
				flag = true;
			}
			if (Owner.AnimateFeet && lastFootForwardAngleDiffABS > Owner.UnglueOn && !G_JustLanded)
			{
				if (Owner._glueModeExecuted != 0)
				{
					Gluing_SetCulldown();
				}
				flag = true;
			}
			if (!flag && !G_JustLanded)
			{
				Vector3 val = Vector3.zero;
				if (GluePointOffset != Vector2.zero)
				{
					val = -GetGluePointOffset();
				}
				if (Vector3.Distance(ankleAlignedOnGroundHitRootLocal + val, _GlueLastAttachPositionRootLocal) > G_GlueTesholdRange)
				{
					if (Owner._glueModeExecuted != 0)
					{
						Gluing_SetCulldown();
					}
					flag = true;
				}
			}
			return flag;
		}

		public Vector3 GetGluePointOffset()
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			float num = Owner.ScaleReferenceNoScale * Owner.GlueRangeThreshold;
			return Owner.RootToWorldSpaceVec(new Vector3(GluePointOffset.x * num, 0f, GluePointOffset.y * num));
		}

		private bool Glue_Conditions_DetachForced()
		{
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			if (G_CustomForceDetach)
			{
				return true;
			}
			if (G_RequestRepose != 0)
			{
				if (G_RequestRepose != GlueReposeRequest.ReposeIfFar)
				{
					G_RequestRepose = GlueReposeRequest.None;
					return true;
				}
				G_RequestRepose = GlueReposeRequest.None;
				if (G_Attached && Vector3.Distance(_GluePosition, ankleAlignedOnGroundHitWorldPos) > ScaleRef * 0.1f)
				{
					return true;
				}
			}
			return false;
		}

		private void ExtraProcessingApply()
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (G_LegAnimation.LegAdjustementYOffset != 0f)
			{
				_FinalIKPos += RootSpaceToWorldVec(new Vector3(0f, G_LegAnimation.LegAdjustementYOffset * LegRaiseMultiplier * _glueTargetBlend, 0f));
			}
			if (Owner.AnimateFeet)
			{
				PostCalculate_LimitFootYaw();
			}
		}

		private void ExtraIKPostProcessingApply()
		{
			if (Owner._stepPointsOverlapRadius > 0f)
			{
				PostCalculate_FeetOverlapRadius();
			}
			if (Owner.FeetYOffset != 0f)
			{
				PostCalculate_FeetYOffset();
			}
		}

		public void PostCalculate_LimitFootYaw()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = ankleAlignedOnGroundHitRotation * AnkleIK.forward;
			val = ToRootLocalSpaceDir(val);
			val.y = 0f;
			val = RootSpaceToWorldVec(val);
			Vector3 worldDir = _FinalIKRot * AnkleIK.forward;
			val = ToRootLocalSpaceDir(val);
			val.y = 0f;
			worldDir = ToRootLocalSpaceDir(worldDir);
			worldDir.y = 0f;
			float num = (lastFootForwardAngleDiffABS = Mathf.Abs(Vector3.SignedAngle(((Vector3)(ref val)).normalized, ((Vector3)(ref worldDir)).normalized, Vector3.up)));
			if (Owner.LimitFeetYaw > 0f && Owner.LimitFeetYaw < 90f && num > Owner.LimitFeetYaw)
			{
				float num2 = num - Owner.LimitFeetYaw;
				Quaternion val2 = (A_WasAligning ? ankleAlignedOnGroundHitRotation : AnkleIK.srcRotation);
				_FinalIKRot = Quaternion.LerpUnclamped(val2, _FinalIKRot, 1f - num2 / (90f - Owner.LimitFeetYaw));
			}
		}

		private void PostCalculate_FeetOverlapRadius()
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			float num = Owner._stepPointsOverlapRadius * GlueThresholdMultiplier;
			Vector3 val = ToRootLocalSpace(IKProcessor.IKTargetPosition);
			Leg leg = Owner.Legs[0];
			while (leg != null)
			{
				if (leg == this)
				{
					leg = leg.NextLeg;
					continue;
				}
				Vector3 val2 = ToRootLocalSpace(leg.IKProcessor.IKTargetPosition);
				Vector2 val3 = new Vector2(val2.x, val2.z) - new Vector2(val.x, val.z);
				float magnitude = ((Vector2)(ref val3)).magnitude;
				if (magnitude < num)
				{
					Vector2 val4 = -val3 * (num - magnitude) * 2f;
					FimpIK_Limb iKProcessor = IKProcessor;
					iKProcessor.IKTargetPosition += RootSpaceToWorldVec(new Vector3(val4.x, 0f, val4.y));
				}
				leg = leg.NextLeg;
			}
		}

		private void PostCalculate_FeetYOffset()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			FimpIK_Limb iKProcessor = IKProcessor;
			iKProcessor.IKTargetPosition += _FinalIKRot * (Owner.FeetYOffset * Owner.Scale * A_AligningHelperBlend * AnkleIK.up);
		}

		private void AlignStep_Init()
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			A_PreWasAligning = false;
			A_PreWasAligningNearGround = false;
			A_WasAligning = false;
			A_AligningHelperBlend = 0f;
			A_LastTargetAlignRot = BoneEnd.rotation;
			A_LastApppliedAlignRot = BoneEnd.rotation;
			A_PreIKPosForGluing = _FinalIKPos;
		}

		private void AlignStep_CheckAlignStatePre()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			A_PreIKPosForGluing = _FinalIKPos;
			if (_noRaycast_skipFeetCalcs)
			{
				return;
			}
			bool flag = false;
			A_PreWasAligningNearGround = false;
			if (RaycastHitted)
			{
				float hips_StepHeightAdjustOffset = ParentHub._Hips_StepHeightAdjustOffset;
				hips_StepHeightAdjustOffset = ((!(hips_StepHeightAdjustOffset < 0f)) ? 0f : (hips_StepHeightAdjustOffset * -0.03f));
				A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
				A_LastAlignHeightCompareValue = ScaleRef * (0.002f + Owner.AnimationFloorLevel) + hips_StepHeightAdjustOffset;
				if (Owner.FootAlignRapidity > 0.9999f)
				{
					if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
					{
						flag = true;
						A_PreWasAligningNearGround = true;
					}
				}
				else if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue + ScaleRef * (0.04f + (1f - Owner.FootAlignRapidity) * 0.04f))
				{
					A_PreWasAligningNearGround = true;
					if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
					{
						flag = true;
					}
				}
			}
			else
			{
				A_LastAlignHeightDiff = 100f;
			}
			A_PreWasAligning = flag;
			if (flag)
			{
				Vector3 val = ankleAlignedOnGroundHitWorldPos;
				if (A_AligningHelperBlend > 0.99f)
				{
					_FinalIKPos = val;
				}
				else
				{
					_FinalIKPos = Vector3.Lerp(_FinalIKPos, val, A_AligningHelperBlend * 8f);
				}
				A_PreIKPosForGluing = val;
			}
			else if (A_AligningHelperBlend > 0.01f)
			{
				_FinalIKPos = Vector3.Lerp(_FinalIKPos, RootSpaceToWorld(A_LastApppliedAlignPosLocal), A_AligningHelperBlend);
			}
		}

		private void AlignStep_ValidateFootRotation()
		{
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			if (!Owner.AnimateFeet || _noRaycast_skipFeetCalcs)
			{
				return;
			}
			if (A_PreWasAligningNearGround)
			{
				float num = Owner.FootRotationBlend * A_AligningHelperBlend;
				if (A_LastElevateH < 0.02f)
				{
					if (num >= 1f)
					{
						A_LastTargetAlignRot = ankleAlignedOnGroundHitRotation;
					}
					else
					{
						A_LastTargetAlignRot = Quaternion.LerpUnclamped(_FinalIKRot, ankleAlignedOnGroundHitRotation, num);
					}
				}
				else
				{
					float num2 = A_LastElevateH / (ScaleRef * 0.15f);
					if (A_LastElevateH > 1f)
					{
						A_LastElevateH = 1f;
					}
					A_LastTargetAlignRot = Quaternion.LerpUnclamped(ankleAlignedOnGroundHitRotation, _FinalIKRot, num2 * num);
				}
			}
			else if (A_AligningHelperBlend < 0.001f)
			{
				A_LastTargetAlignRot = _FinalIKRot;
			}
			else
			{
				A_LastTargetAlignRot = Quaternion.Lerp(_FinalIKRot, A_LastTargetAlignRot, A_AligningHelperBlend);
			}
			if (Owner.FootAlignRapidity >= 1f)
			{
				A_LastApppliedAlignRot = A_LastTargetAlignRot;
			}
			else
			{
				A_LastApppliedAlignRot = Quaternion.Lerp(A_LastApppliedAlignRot, A_LastTargetAlignRot, DeltaTime * (8f + Owner.FootAlignRapidity * 26f));
			}
			_FinalIKRot = A_LastApppliedAlignRot;
		}

		private void AlignStep_OnGroundAlign()
		{
			//IL_021a: Unknown result type (might be due to invalid IL or missing references)
			//IL_021f: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0279: Unknown result type (might be due to invalid IL or missing references)
			//IL_027e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_020c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			if (_noRaycast_skipFeetCalcs)
			{
				A_WasAligning = A_PreWasAligning;
				if (A_PreWasAligning)
				{
					if (A_AligningHelperBlend < 0.05f)
					{
						A_AligningHelperBlend = 0.05f;
					}
					A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
					if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
					{
						A_WasFullAlign = true;
						if (!Owner.UseGluing)
						{
							SendStepEvent();
						}
					}
				}
				else
				{
					if (A_AligningHelperBlend > 0.5f)
					{
						A_AligningHelperBlend = 0.5f;
					}
					A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 14f);
				}
				if (A_AligningHelperBlend < 0.65f)
				{
					A_WasFullAlign = false;
				}
				return;
			}
			A_aligningBlendByGluing = 1f;
			if (Owner.UseGluing)
			{
				A_aligningBlendByGluing = 1f - _glueTargetBlend * G_GlueAnimationBlend;
			}
			if (A_PreWasAligning)
			{
				if (A_WasAligning)
				{
					A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
				}
				float num = A_aligningBlendByGluing * A_AligningHelperBlend;
				if (num >= 1f)
				{
					_FinalIKPos = ankleAlignedOnGroundHitWorldPos;
				}
				else
				{
					_FinalIKPos = Vector3.LerpUnclamped(_FinalIKPos, ankleAlignedOnGroundHitWorldPos, num);
				}
				if (A_AligningHelperBlend < 0.05f)
				{
					A_AligningHelperBlend = 0.05f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
				if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
				{
					A_WasFullAlign = true;
					if (!Owner.UseGluing)
					{
						SendStepEvent();
					}
				}
				A_LastApppliedAlignPosLocal = ToRootLocalSpace(_FinalIKPos);
			}
			else
			{
				A_PreviousRelevantAnklePos = _SourceIKPosUnchangedY;
				if (A_AligningHelperBlend > 0.75f)
				{
					A_AligningHelperBlend = 0.75f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 18f);
			}
			if (A_AligningHelperBlend < 0.6f)
			{
				A_WasFullAlign = false;
			}
			A_LastApppliedAlignPos = _FinalIKPos;
			A_WasAligning = A_PreWasAligning;
		}

		private void AlignStep_LegElevation()
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0281: Unknown result type (might be due to invalid IL or missing references)
			//IL_0286: Unknown result type (might be due to invalid IL or missing references)
			//IL_028b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0292: Unknown result type (might be due to invalid IL or missing references)
			//IL_0298: Unknown result type (might be due to invalid IL or missing references)
			//IL_029d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.LegElevateBlend < 0.001f)
			{
				return;
			}
			if (_noRaycast_skipFeetCalcs)
			{
				A_LastElevation = Vector3.zero;
				return;
			}
			float scaleRef = ScaleRef;
			float num = groundHitRootSpacePos.y - A_LastSuddenSmoothYOffset - ParentHub._Hips_StepHeightAdjustOffset;
			float num2 = Owner.AnimationFloorLevel * scaleRef;
			float c_Local_FootElevateInAnimation = C_Local_FootElevateInAnimation;
			if (c_Local_FootElevateInAnimation > num2 && num > 0.001f * scaleRef + num2 + 0.1f)
			{
				c_Local_FootElevateInAnimation -= num2;
				float num3 = c_Local_FootElevateInAnimation;
				float num4 = c_Local_FootElevateInAnimation - num;
				float num5 = scaleRef * 0.015f;
				float num6 = scaleRef * 0.35f;
				float num7 = num4 / num6;
				num7 = Mathf.Clamp01(num7);
				if (num4 > num5)
				{
					num3 *= 1f - num7;
					if (A_AligningFor < 0f)
					{
						A_AligningFor = DeltaTime;
					}
					if (A_AligningFor < 0.3f)
					{
						A_AligningFor += DeltaTime;
					}
					else
					{
						A_AligningFor = 0.3f;
					}
				}
				else if (A_AligningFor > 0f)
				{
					A_AligningFor -= DeltaTime;
				}
				else
				{
					A_AligningFor = 0f;
				}
				float num8 = num3;
				float num9 = scaleRef * Mathf.LerpUnclamped(0.1f, 0.9f, Owner.LegElevateHeightLimit);
				if (num8 > num9)
				{
					num8 = num9;
				}
				if (groundHitRootSpacePos.y > 0f)
				{
					float num10 = ScaleRef * 0.2f;
					if (num10 > 0f)
					{
						float num11 = groundHitRootSpacePos.y / num10;
						if (num11 > 0.8f)
						{
							num8 = Mathf.LerpUnclamped(num8, 0f, Mathf.InverseLerp(0.8f, 1.1f, num11));
						}
					}
				}
				if (Mathf.Abs(num8 - A_LastElevateH) > scaleRef * Adj_A_ElevateSpeedupMargin)
				{
					A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedAfter);
				}
				else
				{
					A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedStart);
				}
				if (A_LastElevateH < 0f)
				{
					A_LastElevateH = 0f;
				}
			}
			else
			{
				A_LastElevateH = Mathf.SmoothDamp(A_LastElevateH, 0f, ref _sd_A_Elev, 0.02f, 100000f, DeltaTime);
			}
			A_LastElevation = RootSpaceToWorldVec(new Vector3(0f, A_LastElevateH * Owner.LegElevateBlend * A_aligningBlendByGluing, 0f));
			_FinalIKPos += A_LastElevation;
		}

		private void AlignStep_SmoothSuddenSteps()
		{
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0217: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_0288: Unknown result type (might be due to invalid IL or missing references)
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			//IL_029e: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.SmoothSuddenSteps < 0.0001f)
			{
				return;
			}
			if (_noRaycast_skipFeetCalcs || G_Attached)
			{
				A_WasAligningFrameBack = A_WasAligning;
				A_WasSmoothing = false;
				return;
			}
			float scaleRef = ScaleRef;
			if (A_WasAligning || A_WasAligningFrameBack)
			{
				if (!A_WasAligning)
				{
					A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
				}
				Vector3 val = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
				Vector3 val2 = ((!A_WasSmoothing) ? ToRootLocalSpace(A_PreviousRelevantAnklePos) : ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos));
				float num = val2.y - val.y;
				num = Mathf.Abs(num);
				float num2 = scaleRef * 0.006f;
				if ((raycastSlopeAngle < 17f || raycastSlopeAngle > 80f || Owner.RaycastShape == ERaycastMode.Spherecast) && num > num2)
				{
					float num3 = num / (scaleRef * 0.275f);
					if (num3 > 1f)
					{
						num3 = 1f;
					}
					if (num3 > Mathf.LerpUnclamped(0.25f, 0.1f, Owner.SmoothSuddenSteps))
					{
						float num4 = Mathf.LerpUnclamped(0.3f, 0.1f, Owner.SmoothSuddenSteps);
						if (A_lastSuddenSmoothingDiff == 0f || A_SuddenSmoothing < num3)
						{
							A_lastSuddenSmoothingDiff = num;
							A_LastAlignRootSpacePos = ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos);
							num4 *= 0.7f;
						}
						else if (Owner.SmoothSuddenSteps < 0.5f)
						{
							float num5 = Mathf.LerpUnclamped(0.5f, 0f, Owner.SmoothSuddenSteps);
							A_lastSuddenSmoothingDiff = Mathf.LerpUnclamped(A_lastSuddenSmoothingDiff, num, num5);
						}
						A_SuddenSmoothing += Mathf.Clamp01(A_lastSuddenSmoothingDiff / (scaleRef * num4));
						float num6 = 0.85f + Owner.SmoothSuddenSteps * 0.165f;
						if (A_SuddenSmoothing > num6)
						{
							A_SuddenSmoothing = num6;
						}
					}
				}
			}
			if (A_SuddenSmoothing > 0f)
			{
				Vector3 val3 = ToRootLocalSpace(_FinalIKPos);
				A_LastSuddenSmoothYOffset = val3.y;
				A_SuddenSmoothing -= Owner.DeltaTime * Mathf.LerpUnclamped(60f, 7.5f, Owner.SmoothSuddenSteps);
				val3.y = Mathf.Lerp(val3.y, A_LastAlignRootSpacePos.y, A_SuddenSmoothing);
				A_LastSuddenSmoothYOffset = val3.y - A_LastSuddenSmoothYOffset;
				A_LastSmoothTargetedPosLocal = val3;
				A_SmoothedIKPos = RootSpaceToWorld(val3);
				_FinalIKPos = A_SmoothedIKPos;
				if (A_SuddenSmoothing < 0f)
				{
					A_SuddenSmoothing = 0f;
				}
				A_WasSmoothing = true;
			}
			else
			{
				A_LastSuddenSmoothYOffset = 0f;
				A_WasSmoothing = false;
			}
		}

		private void AlignStep_Complete()
		{
			A_WasAligningFrameBack = A_WasAligning;
		}

		private void Gluing_Init()
		{
			G_AttachementHandler = new GlueAttachementHandler(this);
			Glue_Reset(initializing: true);
		}

		public void Glue_Reset(bool initializing)
		{
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			G_Attached = false;
			if (initializing)
			{
				_GlueLastAttachPosition = BoneEnd.position;
				_GlueLastAttachRotation = BoneEnd.rotation;
				_GluePosition = BoneEnd.position;
				_GlueLastAttachPositionRootLocal = ToRootLocalSpace(BoneEnd.position);
				_G_LastPreGlueSourceLocalIKPos = _GlueLastAttachPosition;
				_G_PreGlueSourceLocalIKPos = _SourceIKPos;
				A_PreIKPosForGluing = BoneEnd.position;
				_G_LasGroundedPosLocal = _GlueLastAttachPositionRootLocal;
			}
			GlueAttachement g_Attachement = default(GlueAttachement);
			g_Attachement.PosInAttachementLocal = _FinalIKPos;
			g_Attachement.RotInAttachementLocal = _FinalIKRot;
			G_Attachement = g_Attachement;
			_G_RefernceSwing = Vector3.zero;
			_G_WasDisabled = true;
			G_AttachementHandler.Reset(initializing);
		}

		private void Gluing_Update()
		{
			//IL_0257: Unknown result type (might be due to invalid IL or missing references)
			//IL_0262: Unknown result type (might be due to invalid IL or missing references)
			//IL_0267: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01db: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_021f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			_glueTargetBlend = Owner.GlueBlend * ExtraGluingBlend * Owner.RagdolledDisablerBlend * Owner.NotSlidingBlend;
			if (Owner.GlueOnlyOnIdle)
			{
				_glueTargetBlend *= 1f - Owner.IsMovingBlend;
			}
			if (Owner.IsGrounded)
			{
				if (Owner.GroundedTime < 0.25f)
				{
					G_JustLanded = true;
					_glueTargetBlend *= 0.1f + Mathf.InverseLerp(0f, 0.25f, Owner.GroundedTime) * 0.9f;
				}
				else
				{
					G_JustLanded = false;
				}
			}
			else
			{
				G_JustLanded = false;
				_glueTargetBlend *= Owner.IsGroundedBlend;
			}
			if (_glueTargetBlend < 0.0001f)
			{
				_glueTargetBlend = 0f;
				_G_WasDisabled = true;
				return;
			}
			if (_G_WasDisabled)
			{
				Glue_Reset(initializing: false);
				_G_WasDisabled = false;
			}
			if (_gluingCulldown > 0f)
			{
				_gluingCulldown -= Owner.DeltaTime;
			}
			if (!Owner.IsGrounded)
			{
				if (_G_WasGrounded)
				{
					_G_WasGrounded = false;
					_G_LasGroundedPosLocal = ToRootLocalSpace(_GluePosition);
					_G_LasGroundedRotLocal = _GlueRotation;
					G_AttachementHandler.legMoveAnimation.Reset();
				}
				_GluePosition = RootSpaceToWorld(_G_LasGroundedPosLocal);
				_GlueRotation = _G_LasGroundedRotLocal;
				return;
			}
			_G_WasGrounded = true;
			if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f)
			{
				Vector3 val = AnkleH.LastKeyframeRootPos - _G_LastPreGlueSourceLocalIKPos;
				if (((Vector3)(ref val)).magnitude > Owner.ScaleReferenceNoScale * 0.001f)
				{
					_G_LastPreGlueSourceLocalIKPos = _G_PreGlueSourceLocalIKPos;
				}
				_G_PreGlueSourceLocalIKPos = AnkleH.LastKeyframeRootPos;
				_G_RefernceSwing = Vector3.SmoothDamp(_G_RefernceSwing, val * 2f, ref _G_sd_RefSwing, 0.04f, 100000f, Owner.DeltaTime);
			}
			else
			{
				_G_RefernceSwing = Vector3.zero;
				_G_sd_RefSwing = Vector3.zero;
			}
			_Glue_AskingForDetach = false;
			if (G_Attached)
			{
				bool flag = !Glue_CheckDetachement();
				if (!flag)
				{
					flag = !Glue_CheckIdleDetachementConfirm();
				}
				if (!flag)
				{
					G_Attached = flag;
					G_AttachementHandler.OnLegRequireRepose();
					flag = Glue_Conditions_Attach();
				}
				else if (!Glue_Conditions_Attach())
				{
					flag = false;
				}
				if (flag)
				{
					G_AttachementHandler.TransitionToGlueAnimation();
				}
				else
				{
					G_AttachementHandler.TransitionToDisableGlueAnimation();
				}
			}
			else if (Glue_Conditions_Attach())
			{
				G_AttachementHandler.TransitionToGlueAnimation();
			}
			else
			{
				G_AttachementHandler.TransitionToDisableGlueAnimation();
			}
			if (G_InstantReglue)
			{
				G_AttachementHandler.SheduleInstantTransition();
				G_InstantReglue = false;
			}
			G_AttachementHandler.UpdateTransitioning(G_DuringAttaching);
			Gluing_UpdateAttachement();
		}

		private bool Glue_TriggerFinalAttach()
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref legGroundHit)).transform) || _UsingEmptyRaycast)
			{
				G_Attached = true;
				G_Attachement = new GlueAttachement(this, legGroundHit);
				return true;
			}
			return false;
		}

		private void Gluing_UpdateAttachement()
		{
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			if (!G_Attachement.NoTransform && (Object)(object)G_Attachement.AttachedTo == (Object)null)
			{
				G_Attachement = default(GlueAttachement);
				G_AttachementHandler.OnLegRequireRepose();
				G_Attached = false;
			}
			if (!G_Attached)
			{
				_GluePosition = G_AttachementHandler.GetGluePosition();
				Gluing_DragStretchApply();
				if (Owner.AnimateFeet)
				{
					if (Owner.LimitFeetYaw > 0f)
					{
						_GlueRotation = G_AttachementHandler.GetGlueRotation();
					}
					else
					{
						_GlueRotation = A_LastApppliedAlignRot;
					}
				}
			}
			else
			{
				_GlueLastAttachPosition = G_Attachement.GetRelevantAlignedHitPoint(this);
				_GlueLastAttachPositionRootLocal = ToRootLocalSpace(_GlueLastAttachPosition);
				Quaternion relevantAttachementRotation = G_Attachement.GetRelevantAttachementRotation();
				_GlueLastAttachRotation = relevantAttachementRotation;
				_GluePosition = G_AttachementHandler.GetGluePosition();
				Gluing_DragStretchApply();
				if (Owner.AnimateFeet)
				{
					if (Owner.LimitFeetYaw > 0f)
					{
						_GlueRotation = G_AttachementHandler.GetGlueRotation();
					}
					else
					{
						_GlueRotation = A_LastApppliedAlignRot;
					}
				}
			}
			G_AttachementHandler.PostUpdate();
		}

		private void Gluing_DragStretchApply()
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.AllowGlueDrag > 0f)
			{
				float stretchValue = IKProcessor.GetStretchValue(_GluePosition - Owner._LastAppliedHipsStabilityOffset);
				float num = Mathf.LerpUnclamped(1f, 0.825f, Owner.AllowGlueDrag);
				float num2 = num * Mathf.LerpUnclamped(1f, LegStretchLimit, Owner.AllowGlueDrag);
				if (num2 > num)
				{
					num2 = num;
				}
				Vector3 val = _GluePosition;
				if (stretchValue > num2 * 1.1f)
				{
					float num3 = (stretchValue - num2 * 1.1f) * 2f * Mathf.Min(1f, Owner.AllowGlueDrag);
					val = ((!A_PreWasAligning) ? Vector3.Lerp(_GluePosition, A_PreIKPosForGluing, num3) : Vector3.Lerp(_GluePosition, ankleAlignedOnGroundHitWorldPos, num3));
				}
				Vector3 val2 = val - _GluePosition;
				G_GlueDragOffset = Vector3.Lerp(G_GlueDragOffset, val2, Owner.DeltaTime * 14f);
				if (float.IsNaN(G_GlueDragOffset.x) || float.IsNaN(G_GlueDragOffset.z))
				{
					G_GlueDragOffset = Vector3.zero;
				}
			}
		}

		private void Gluing_ApplyCoords()
		{
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			if (_glueTargetBlend < 0.0001f)
			{
				return;
			}
			float num = _glueTargetBlend * G_AttachementHandler.glueAnimationBlend;
			if (num >= 1f)
			{
				_FinalIKPos = _GluePosition + G_GlueDragOffset;
				if (Owner.AnimateFeet)
				{
					_FinalIKRot = _GlueRotation;
				}
			}
			else
			{
				_FinalIKPos = Vector3.LerpUnclamped(A_PreIKPosForGluing, _GluePosition + G_GlueDragOffset, num);
				if (Owner.AnimateFeet)
				{
					_FinalIKRot = Quaternion.LerpUnclamped(_FinalIKRot, _GlueRotation, num);
				}
			}
		}

		private void Controll_Init()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			C_AnkleToHeelRootSpace = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
			ThighH.Calibrate(this, ThighH.Bone.position);
			AnkleH.Calibrate(this, AnkleH.Bone.position);
		}

		private Vector3 TransformVectorAnkleWithAlignedRotation(Vector3 offset)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			return ankleAlignedOnGroundHitRotation * Vector3.Scale(offset, BoneEnd.lossyScale);
		}

		private void Controll_Calibrate()
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_0166: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_0187: Unknown result type (might be due to invalid IL or missing references)
			_C_DynamicYScale = Owner.DynamicYScale;
			ThighH.Calibrate(this, ThighH.Bone.position);
			AnkleH.Calibrate(this, _SourceIKPosUnchangedY);
			Vector3 ankleToHeel = AnkleToHeel;
			Vector3 val = TransformVectorAnkleWithAlignedRotation(AnkleToHeel);
			C_LastFootEndWorldPos = _SourceIKPosUnchangedY + TransformVectorAnkleWithAlignedRotation(ankleToHeel);
			C_LastFootEndRootSpacePos = ToRootLocalSpace(C_LastFootEndWorldPos);
			C_AnimatedAnkleFlatHeight = ToRootLocalSpaceDir(val).y;
			C_LastHeelWorldPos = _SourceIKPosUnchangedY + val;
			C_LastHeelRootSpacePos = ToRootLocalSpace(C_LastHeelWorldPos);
			if (Owner.AnimateFeet)
			{
				C_LastMidRefFootWorldPos = Vector3.LerpUnclamped(C_LastFootEndWorldPos, C_LastHeelWorldPos, FootMiddlePosition);
				C_LastMidRefFootRootSpacePos = Vector3.LerpUnclamped(C_LastFootEndRootSpacePos, C_LastHeelRootSpacePos, FootMiddlePosition);
			}
			else
			{
				C_LastMidRefFootRootSpacePos = C_LastHeelRootSpacePos;
				C_LastMidRefFootWorldPos = C_LastHeelWorldPos;
			}
			C_Local_MidFootPosVsGroundHit = C_LastMidRefFootRootSpacePos - groundHitRootSpacePos;
			C_Local_FootElevateInAnimation = C_LastMidRefFootRootSpacePos.y - ParentHub._Hips_LastHipsOffset;
			C_Local_AnkleToHeelRotated = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
			Vector3 val2 = BoneEnd.TransformVector(AnkleToHeel);
			C_AnkleToHeelWorldHeight = ((Vector3)(ref val2)).magnitude;
		}

		private Vector3 RootSpaceToWorldVec(Vector3 localVec)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.RootToWorldSpaceVec(localVec);
		}

		private Vector3 RootSpaceToWorld(Vector3 rootLocal)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.RootToWorldSpace(rootLocal);
		}

		private Vector3 ToRootLocalSpaceDir(Vector3 worldDir)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.ToRootLocalSpaceVec(worldDir);
		}

		private Vector3 ToRootLocalSpace(Vector3 worldPos)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.ToRootLocalSpace(worldPos);
		}

		private Vector3 ChangeLocalY(Vector3 worldPos, float targetLocalY)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			worldPos = ToRootLocalSpace(worldPos);
			worldPos.y = targetLocalY;
			return RootSpaceToWorld(worldPos);
		}

		private Vector3 ChangeLocalPosExceptY(Vector3 worldPos, Vector3 targetWorldPos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			worldPos = ToRootLocalSpace(worldPos);
			Vector3 val = ToRootLocalSpace(targetWorldPos);
			worldPos.x = val.x;
			worldPos.z = val.z;
			return RootSpaceToWorld(worldPos);
		}

		private void Control_StepEventCalcs()
		{
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			StepEventRestore();
			if (!Owner.UseGluing || _StepSent)
			{
				return;
			}
			if (Owner._glueModeExecuted == EGlueMode.Idle)
			{
				if (G_GlueInternalTransition >= 0.85f - Owner.EventExecuteSooner)
				{
					if (_ToConfirmStepEvent > 0.1f)
					{
						SendStepEvent(G_AttachementHandler.legMoveDistanceFactor);
						return;
					}
					float num = Mathf.InverseLerp(1f, 0f, LegAnimatingSettings.RaiseYAxisCurve.Evaluate(G_GlueInternalTransition));
					_ToConfirmStepEvent += DeltaTime * (3f + 3f * num);
				}
				else
				{
					_ToConfirmStepEvent = 0f;
				}
			}
			else
			{
				if (G_HandlerExecutingLegAnimationMode != EGlueMode.Moving || !Owner.SendOnMovingGlue || G_CustomForceNOTAttach)
				{
					return;
				}
				float num2 = FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.5f + A_LastAlignHeightCompareValue * (1.65f + Owner.EventExecuteSooner);
				if (G_CustomForceAttach)
				{
					_ToConfirmStepEvent += DeltaTime * 5f;
					num2 += ScaleRef * 0.1f;
				}
				if (A_LastAlignHeightDiff <= num2)
				{
					if (_ToConfirmStepEvent > 0.2f)
					{
						SendStepEvent(1f, EStepType.MovementGluing);
						_ToConfirmStepEvent = 0f;
						return;
					}
					_ToConfirmStepEvent += DeltaTime;
					if (A_LastAlignHeightDiff < num2 * 0.75f)
					{
						_ToConfirmStepEvent += DeltaTime * 1f;
					}
					if (A_LastAlignHeightDiff < num2 * 0.5f)
					{
						_ToConfirmStepEvent += DeltaTime * 1f;
					}
				}
				else
				{
					_ToConfirmStepEvent = 0f;
				}
			}
		}

		internal void StepEventSentInCustomWay()
		{
			_StepSent = true;
			_StepSentAt = Time.unscaledTime;
		}

		public void InitLegBasics(LegsAnimator creator, int index, Leg nextLeg)
		{
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)creator != (Object)null)
			{
				Owner = creator;
			}
			PlaymodeIndex = index;
			NextLeg = nextLeg;
			LegStretchLimit = 1f;
			BlendWeight = 1f;
			InternalModuleBlendWeight = 1f;
			EnsureAxesNormalization();
			_h_boneStart = new LegHelper(this, BoneStart);
			_h_boneMid = new LegHelper(this, BoneMid);
			_h_boneEnd = new LegHelper(this, BoneEnd);
			_h_boneStart.Child = _h_boneMid;
			_h_boneMid.Child = _h_boneEnd;
			Gluing_Init();
			Reset();
			Controll_Init();
			Raycasting_Init();
			Stability_Init();
			AlignStep_Init();
			RefreshHasOppositeLeg();
			targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : creator.LegAnimatingSettings);
			ankleAlignedOnGroundHitWorldPos = _FinalIKPos;
		}

		public void RefreshHasOppositeLeg()
		{
			hasOppositeleg = false;
			if (GetOppositeLeg() != null)
			{
				hasOppositeleg = true;
			}
		}

		public void Leg_UpdateParams()
		{
			targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : Owner.LegAnimatingSettings);
			IK_UpdateParams();
		}

		internal void AssignParentHub(HipsReference hipsReference)
		{
			ParentHub = hipsReference;
		}

		internal void Reset()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			_SourceIKPos = BoneEnd.position;
			_SourceIKRot = BoneEnd.rotation;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
			_PreviousFinalIKPos = _FinalIKPos;
			_PreviousFinalIKRot = _FinalIKRot;
			legGroundHit = default(RaycastHit);
			((RaycastHit)(ref legGroundHit)).point = _FinalIKPos;
			((RaycastHit)(ref legGroundHit)).normal = Owner.Up;
			_PreviousFinalIKPosForStability = _SourceIKPos;
			ankleAlignedOnGroundHitRotation = _SourceIKRot;
			A_LastApppliedAlignRot = _SourceIKRot;
			A_LastTargetAlignRot = _SourceIKRot;
			groundHitRootSpacePos = ToRootLocalSpace(_SourceIKPos);
			_SourceIKPosUnchangedY = groundHitRootSpacePos;
			RaycastHit val = default(RaycastHit);
			((RaycastHit)(ref val)).point = _FinalIKPos;
			((RaycastHit)(ref val)).normal = Owner.Up;
			legGroundHit = val;
			Glue_Reset(initializing: true);
		}

		public void PreCalibrate()
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			BlendWeight *= InternalModuleBlendWeight;
			finalBoneBlend = BlendWeight * Owner._MainBlend;
			if (finalBoneBlend < 0.0001f)
			{
				if (!_G_WasDisabled)
				{
					G_Attached = false;
					G_AttachementHandler.Reset(initializing: false);
					G_Attachement = default(GlueAttachement);
					_G_WasDisabled = true;
					legGroundHit = default(RaycastHit);
					RaycastHitted = false;
				}
			}
			else if (Owner.Calibrate == ECalibrateMode.Calibrate)
			{
				IKProcessor.PreCalibrate();
			}
			else if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
			{
				if (!_wasFixedCalibrateAnimationCaptured)
				{
					IKProcessor.PreCalibrate();
					return;
				}
				BoneStart.localRotation = _AnimatorStartBoneLocRot;
				BoneMid.localRotation = _AnimatorMidBoneLocRot;
				BoneEnd.localRotation = _AnimatorEndBoneLocRot;
			}
		}

		public void CheckAnimatorPose()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			_AnimatorStartBonePos = BoneStart.position;
			_AnimatorMidBonePos = BoneMid.position;
			_AnimatorEndBonePos = BoneEnd.position;
			if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
			{
				_wasFixedCalibrateAnimationCaptured = true;
				_AnimatorStartBoneLocRot = BoneStart.localRotation;
				_AnimatorMidBoneLocRot = BoneMid.localRotation;
				_AnimatorEndBoneLocRot = BoneEnd.localRotation;
			}
		}

		public void BeginLateUpdate()
		{
			if (!(finalBoneBlend < 0.0001f))
			{
				G_CustomForceAttach = false;
				G_CustomForceNOTDetach = false;
				G_CustomForceDetach = false;
				G_CustomForceNOTAttach = false;
				IK_PreUpdate();
				LegStretchLimit = Owner.LimitLegStretch * LegStretchMultiplier;
			}
		}

		public void PreLateUpdate()
		{
			if (!customOverwritingIKPos && (!_G_WasDisabled || !(finalBoneBlend < 0.0001f)))
			{
				Owner.Modules_LegBeforeRaycastingUpdate(this);
				Raycasting_PreLateUpdate();
				Controll_Calibrate();
			}
		}

		public void LateUpdate()
		{
			if (!(finalBoneBlend < 0.0001f) && !customOverwritingIKPos)
			{
				Owner.Modules_Leg_LateUpdate(this);
				AlignStep_CheckAlignStatePre();
				AlignStep_ValidateFootRotation();
				Gluing_Update();
				Gluing_ApplyCoords();
				AlignStep_OnGroundAlign();
				AlignStep_SmoothSuddenSteps();
				AlignStep_LegElevation();
				AlignStep_Complete();
				Control_StepEventCalcs();
				ExtraProcessingApply();
			}
		}

		public void LateUpdate_Apply()
		{
			IK_PostUpdate();
		}

		public void FixedUpdate()
		{
		}

		public float LegLimbLength()
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)BoneStart == (Object)null || (Object)(object)BoneMid == (Object)null || (Object)(object)BoneEnd == (Object)null)
			{
				return Owner.HipsToGroundDistance();
			}
			return 0f + Vector3.Distance(BoneStart.position, BoneMid.position) + Vector3.Distance(BoneEnd.position, BoneMid.position);
		}

		public bool HasAllBonesSet()
		{
			if ((Object)(object)BoneStart == (Object)null)
			{
				return false;
			}
			if ((Object)(object)BoneMid == (Object)null)
			{
				return false;
			}
			if ((Object)(object)BoneEnd == (Object)null)
			{
				return false;
			}
			return true;
		}

		public float R(float toRound, int digits = 2)
		{
			return (float)Math.Round(toRound, digits);
		}

		private void SendStepEvent(float factor = 1f, EStepType type = EStepType.IdleGluing)
		{
			if (!_StepSent)
			{
				if (Owner.GroundedTime < 0.1f)
				{
					type = EStepType.OnLanding;
				}
				else if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
				{
					type = EStepType.OnStopping;
				}
				Owner.Events_OnStep(this, factor, type);
				_StepSent = true;
				_StepSentAt = Time.unscaledTime;
				if (hasOppositeleg)
				{
					_OppositeLegStepped = true;
					GetOppositeLeg()._OppositeLegStepped = !Owner.IsMoving;
				}
			}
		}

		private void SendRaiseEvent(float distanceToNew = 1f)
		{
			if (!(Time.unscaledTime - _RaiseSentAt < 0.05f))
			{
				_RaiseSentAt = Time.unscaledTime;
				EStepType type = EStepType.IdleGluing;
				if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
				{
					type = EStepType.OnStopping;
				}
				Owner.Events_OnRaise(this, distanceToNew, type);
			}
		}

		private void StepEventRestore()
		{
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			if (!Owner.UseEvents || !_StepSent || Time.unscaledTime - _StepSentAt < 0.1f || Owner.GroundedTime < 0.1f)
			{
				return;
			}
			if (Owner.UseGluing)
			{
				if (G_AttachementHandler.glueAnimationBlend > 0.5f && G_GlueInternalTransition > 0.25f)
				{
					return;
				}
				if (Owner._glueModeExecuted == EGlueMode.Idle)
				{
					if (!G_DuringAttaching || (Owner.GlueMode == EGlueMode.Automatic && (Owner.IsMoving || Owner.Helper_WasMoving)) || (!Owner.SendOnStopping && Owner.StoppedTime < 0.155f) || G_AttachementHandler.lasGlueModeOnAttaching != 0 || G_AttachementHandler.legMoveDistanceFactor < 0.05f)
					{
						return;
					}
				}
				else
				{
					if ((Owner.GlueMode == EGlueMode.Automatic && !Owner.IsMoving) || Owner.MovingTime < 0.06f || A_PreWasAligning || A_AligningHelperBlend > 0.5f - Owner.EventExecuteSooner || (hasOppositeleg && !GetOppositeLeg()._OppositeLegStepped))
					{
						return;
					}
					float num = (0f - ScaleRef) * 0.2f + FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.75f + A_LastAlignHeightCompareValue * (3f + Owner.EventExecuteSooner);
					if (A_LastAlignHeightDiff < num)
					{
						return;
					}
				}
			}
			else
			{
				if (A_PreWasAligning || A_AligningHelperBlend > 0.05f)
				{
					return;
				}
				if (Owner.IsMovingBlend < 0.05f)
				{
					_StepSent = true;
					return;
				}
				if (!Owner.Helper_WasMoving)
				{
					_StepSent = true;
					return;
				}
				if (!Owner.IsMoving)
				{
					_StepSent = true;
					return;
				}
			}
			_StepSent = false;
		}

		public void IK_Initialize(bool generateNew = true)
		{
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_017b: Unknown result type (might be due to invalid IL or missing references)
			if (generateNew)
			{
				IKProcessor = new FimpIK_Limb();
			}
			if (Object.op_Implicit((Object)(object)BoneFeet))
			{
				IKProcessor.SetLegWithFeet(BoneStart, BoneMid, BoneEnd, BoneFeet);
			}
			else
			{
				IKProcessor.SetBones(BoneStart, BoneMid, BoneEnd);
			}
			IKProcessor.Init(Owner.BaseTransform);
			IKProcessor.UseEndBoneMapping = false;
			IKProcessor.IKWeight = 1f;
			IKProcessor.IKPositionWeight = 1f;
			IKProcessor.FootRotationWeight = 1f;
			IKProcessor.ManualHintPositionWeight = 0f;
			IKProcessor.FeetStretchSensitivity = 0.9f;
			IKProcessor.FeetFadeQuicker = 1.1f;
			IKProcessor.FeetStretchLimit = 0.8f;
			IKProcessor.HumanoidAnimator = Owner.Mecanim;
			IKProcessor.IsRight = Side == ELegSide.Right;
			_FinalIKPos = IKProcessor.EndIKBone.transform.position;
			_PreviousFinalIKPos = _FinalIKPos;
			_PreviousFinalIKPosForStability = _FinalIKPos;
			_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_FinalIKPos);
			IKProcessor.IKTargetPosition = _FinalIKPos;
			IKProcessor.IKTargetRotation = _FinalIKRot;
		}

		public void AssignCustomIKProcessor(FimpIK_Limb ik)
		{
			IKProcessor = ik;
			IK_Initialize(generateNew: false);
		}

		public void OverrideTargetIKPosition(Vector3? targetIKPos)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			if (!targetIKPos.HasValue)
			{
				customOverwritingIKPos = false;
				return;
			}
			customOverwritingIKPos = true;
			customOverwritePos = targetIKPos.Value;
		}

		public void OverrideTargetIKRotation(Quaternion? targetIKRot)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			if (!targetIKRot.HasValue)
			{
				if (customOverwritingIKRot)
				{
					IKProcessor.FootRotationWeight = 1f;
				}
				customOverwritingIKRot = false;
			}
			else
			{
				customOverwritingIKRot = true;
				customOverwriteRot = targetIKRot.Value;
			}
		}

		public void OverrideFinalIKPos(Vector3 pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_FinalIKPos = pos;
		}

		public void OverrideFinalAndSourceIKPos(Vector3 pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			_FinalIKPos = pos;
			_SourceIKPos = pos;
		}

		public Vector3 GetFinalIKPos()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _FinalIKPos;
		}

		public Vector3 GetSourceIKPos()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _SourceIKPos;
		}

		public Quaternion GetFinalIKRot()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _FinalIKRot;
		}

		public Quaternion GetSourceIKRot()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _SourceIKRot;
		}

		public void OverrideFinalIKRot(Quaternion rot)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_FinalIKRot = rot;
		}

		public void IK_PreUpdate()
		{
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			IKProcessor.CallPreCalibrate = Owner.Calibrate == ECalibrateMode.Calibrate;
			if (!Owner.IsGrounded)
			{
				if (_wasGrounded)
				{
					_ungroundLocalIKCache = ToRootLocalSpace(_PreviousFinalIKPos);
					_wasGrounded = false;
				}
				_SourceIKPos = RootSpaceToWorld(_ungroundLocalIKCache);
				_SourceIKPos = Vector3.Lerp(_SourceIKPos, IKProcessor.EndIKBone.transform.position, 1f - Owner.IsGroundedBlend);
				_ungroundLocalIKCache = ToRootLocalSpace(_SourceIKPos);
				_SourceIKRot = BoneEnd.rotation;
				_SourceIKPosUnchangedY = _SourceIKPos;
				_FinalIKPos = _SourceIKPos;
				_FinalIKRot = _SourceIKRot;
			}
			else
			{
				_wasGrounded = true;
				if (!_overwrittenSourceIKPos)
				{
					_SourceIKPos = IKProcessor.EndIKBone.transform.position;
				}
				else
				{
					_overwrittenSourceIKPos = false;
				}
				_SourceIKRot = BoneEnd.rotation;
				_SourceIKPosUnchangedY = _SourceIKPos;
				_FinalIKPos = _SourceIKPos;
				_FinalIKRot = _SourceIKRot;
			}
		}

		public void IK_PostUpdate()
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			if (customOverwritingIKPos)
			{
				_FinalIKPos = customOverwritePos;
				if (customOverwritingIKRot)
				{
					IKProcessor.FootRotationWeight = 1f;
					_FinalIKRot = customOverwriteRot;
				}
				else
				{
					IKProcessor.FootRotationWeight = 0f;
				}
			}
			else if (G_LegAnimation.LegAdjustementFootAngleOffset != 0f || FootPitchOffset != 0f)
			{
				_FinalIKRot = Quaternion.AngleAxis(G_LegAnimation.LegAdjustementFootAngleOffset + FootPitchOffset, _SourceIKRot * AnkleIK.right) * _FinalIKRot;
			}
			if (float.IsNaN(_FinalIKPos.x) || float.IsNaN(_FinalIKPos.y) || float.IsNaN(_FinalIKPos.z))
			{
				Reset();
				_FinalIKPos = RootSpaceToWorld(InitialPosInRootSpace);
				Gluing_Init();
			}
			_PreviousFinalIKPosForStability = _FinalIKPos;
			IKProcessor.IKTargetPosition = _FinalIKPos;
			IKProcessor.IKTargetRotation = _FinalIKRot;
			if (IKProcessor.IKWeight > 0f)
			{
				if (!Owner.UseCustomIK && LegStretchLimit < 1.1f)
				{
					IKProcessor.ApplyMaxStretchingPreprocessing(LegStretchLimit, 3f);
				}
				ExtraIKPostProcessingApply();
				if (!Owner.UseCustomIK)
				{
					IKProcessor.Update();
				}
			}
			_PreviousFinalIKPos = IKProcessor.IKTargetPosition;
			_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_PreviousFinalIKPos);
			if (Owner.AnimateFeet)
			{
				_PreviousFinalIKRot = IKProcessor.IKTargetRotation;
			}
		}

		public void IK_UpdateParamsBase()
		{
			IKProcessor.IKWeight = Owner._MainBlend * LegBlendWeight * InternalModuleBlendWeight;
			BlendWeight = IKProcessor.IKWeight;
			IKProcessor.InverseHint = InverseHint;
		}

		public void IK_UpdateParams()
		{
			IK_UpdateParamsBase();
			IKProcessor.AutoHintMode = Owner.IKHintMode;
			IKProcessor.FeetStretchSensitivity = 0.7f + 0.6f * FeetSensitivity;
			IKProcessor.FeetFadeQuicker = 0.95f + 0.35f * FeetSensitivity;
			IKProcessor.FeetStretchLimit = 0.8f + 0.2f * FeetSensitivity;
			IKProcessor.disableFeet = !UseFeet;
		}

		public void RandomizeIndividualSettings(float from, float to)
		{
			GlueThresholdMultiplier = Random.Range(Mathf.Lerp(from, to, 0.4f), to);
			LegMoveSpeedMultiplier = Random.Range(from, to);
			LegRaiseMultiplier = Random.Range(from, to);
		}

		public void OverrideAnimatorAnklePosition(Vector3 targetPos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			_overwrittenSourceIKPos = true;
			_AnimatorEndBonePos = targetPos + (Owner._LastAppliedHipsFinalPosition - ParentHub.LastKeyframePosition);
			_SourceIKPos = _AnimatorEndBonePos;
		}

		public void User_OverrideRaycastHit(Transform tr, bool disableSourceRaycast = true)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 0f;
				_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
			}
			_disableSourceRaycast = disableSourceRaycast;
			_UsingCustomRaycast = true;
			RaycastHit hit = default(RaycastHit);
			((RaycastHit)(ref hit)).point = tr.position;
			((RaycastHit)(ref hit)).normal = tr.up;
			_CustomRaycastOnBlendIn(hit);
		}

		public void User_OverrideRaycastHit(RaycastHit hit, bool disableSourceRaycast = true)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 0f;
				_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
			}
			_disableSourceRaycast = disableSourceRaycast;
			_UsingCustomRaycast = true;
			_CustomRaycastOnBlendIn(hit);
		}

		public void User_RestoreRaycasting()
		{
			if (_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 1f;
			}
			_UsingCustomRaycast = false;
			_disableSourceRaycast = false;
		}

		private void _CustomRaycastOnBlendIn(RaycastHit hit)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			_CustomRaycastBlendIn += Owner.DeltaTime * 6f;
			if (_CustomRaycastBlendIn > 1f)
			{
				_CustomRaycastBlendIn = 1f;
			}
			((RaycastHit)(ref hit)).point = Vector3.LerpUnclamped(_PreviousCustomRaycastingStartIKPos, ((RaycastHit)(ref hit)).point, _CustomRaycastBlendIn);
			_CustomRaycastHit = hit;
			_PreviousCustomRaycastingIKPos = ((RaycastHit)(ref hit)).point;
		}

		private void _CustomRaycastOnBlendOut()
		{
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			if (!_UsingCustomRaycast && !(_CustomRaycastBlendIn <= 0f))
			{
				_CustomRaycastBlendIn -= Owner.DeltaTime * 8f;
				if (_CustomRaycastBlendIn < 0f)
				{
					_CustomRaycastBlendIn = 0f;
				}
				if (!RaycastHitted)
				{
					legGroundHit = _CustomRaycastHit;
					return;
				}
				RaycastHit val = legGroundHit;
				((RaycastHit)(ref val)).point = Vector3.LerpUnclamped(((RaycastHit)(ref val)).point, _PreviousCustomRaycastingIKPos, _CustomRaycastBlendIn);
				((RaycastHit)(ref val)).normal = Vector3.SlerpUnclamped(((RaycastHit)(ref val)).normal, ((RaycastHit)(ref _CustomRaycastHit)).normal, _CustomRaycastBlendIn);
				legGroundHit = val;
			}
		}

		private void Raycasting_Init()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			ankleAlignedOnGroundHitWorldPos = BoneEnd.position;
			raycastSlopeAngle = 0f;
		}

		public void OverrideControlPositionsWithCurrentIKState()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			AnkleH.LastKeyframeRootPos = ToRootLocalSpace(_FinalIKPos);
			_AnimatorEndBonePos = _FinalIKPos;
		}

		public void OverrideSourceIKPos()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			OverrideSourceIKPos(_FinalIKPos);
		}

		public void OverrideSourceIKPos(Vector3 newSrc)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_SourceIKPos = newSrc;
		}

		public void Raycasting_PreLateUpdate()
		{
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			RaycastHitted = false;
			_noRaycast_skipFeetCalcs = false;
			if (!_disableSourceRaycast)
			{
				if (Owner.RaycastStyle == ERaycastStyle.NoRaycasting)
				{
					GenerateZeroFloorRaycastHit();
					CustomRaycastValidate();
					_noRaycast_skipFeetCalcs = true;
					_UsingEmptyRaycast = true;
					ankleAlignedOnGroundHitRotation = _SourceIKRot;
				}
				else
				{
					_UsingEmptyRaycast = false;
					if (Owner.RaycastStyle == ERaycastStyle.StraightDown)
					{
						Raycast_StraightDown();
					}
					else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot)
					{
						Raycast_OriginToFoot();
					}
					else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot_DownOnNeed)
					{
						Raycast_OriginToFoot();
						if (!RaycastHitted)
						{
							Raycast_StraightDown();
						}
					}
					else if (Owner.RaycastStyle == ERaycastStyle.AlongBones)
					{
						Raycast_AlongBones();
						if (!RaycastHitted)
						{
							Raycast_StraightDown();
						}
					}
					if (!RaycastHitted)
					{
						NoRaycastBehaviour();
					}
				}
				User_RaycastHittedSource = RaycastHitted;
				_CustomRaycastOnBlendOut();
			}
			if (_UsingCustomRaycast)
			{
				RaycastHitted = true;
				legGroundHit = _CustomRaycastHit;
				groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
				_UsingEmptyRaycast = true;
				_noRaycast_skipFeetCalcs = true;
				_Raycasting_CalculateBasis();
				ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
			}
			if (!_noRaycast_skipFeetCalcs)
			{
				if (RaycastHitted)
				{
					lastGroundHitWithTarget = legGroundHit;
					ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
				}
				else
				{
					ankleAlignedOnGroundHitRotation = _SourceIKRot;
				}
			}
		}

		private void NoRaycastBehaviour()
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.Detach)
			{
				return;
			}
			if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.ZeroFloorSteps)
			{
				_noRaycast_skipFeetCalcs = true;
				_UsingEmptyRaycast = true;
				GenerateZeroFloorRaycastHit();
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
			else if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.KeepAttached)
			{
				if (IKProcessor.GetStretchValue(_PreviousFinalIKPos) > Owner.NoRaycast_KeepAttachedUntilStretch)
				{
					lastGroundHitWithTarget = default(RaycastHit);
				}
				else if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastGroundHitWithTarget)).transform))
				{
					_noRaycast_skipFeetCalcs = true;
					legGroundHit = lastGroundHitWithTarget;
					RaycastHitted = true;
					_Raycasting_CalculateBasis();
					Vector3 val = ToRootLocalSpace(((RaycastHit)(ref lastGroundHitWithTarget)).point);
					val.y = 0f;
					groundHitRootSpacePos = val;
				}
			}
		}

		private void GenerateZeroFloorRaycastHit()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			RaycastHit val = default(RaycastHit);
			Vector3 rootLocal = (ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(_SourceIKPos));
			rootLocal.y = 0f;
			Vector3 point = RootSpaceToWorld(rootLocal);
			((RaycastHit)(ref val)).point = point;
			((RaycastHit)(ref val)).normal = Owner.Up;
			legGroundHit = val;
			RaycastHitted = true;
			groundHitRootSpacePos = rootLocal;
		}

		private void CustomRaycastValidate()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			_Raycasting_CalculateBasis();
			raycastSlopeAngle = 0f;
			A_WasAligning = true;
			A_WasAligningFrameBack = true;
			A_LastTargetAlignRot = _SourceIKRot;
			A_LastApppliedAlignRot = _SourceIKRot;
			A_PreviousRelevantAnklePos = _SourceIKPos;
			A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
			A_LastAlignHeightCompareValue = ScaleRef * 0.002f + ParentHub._Hips_StepHeightAdjustOffset;
		}

		private Vector3 Raycast_RefreshOrigin()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
			return lastRaycastingOrigin = RootSpaceToWorld(lastRootLocalPos);
		}

		private void Raycast_OriginToFoot()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Raycast_RefreshOrigin();
			Vector3 val2 = RootSpaceToWorld(AnkleH.LastKeyframeRootPos) - Owner.Up * C_AnkleToHeelWorldHeight - val;
			float num = ((Vector3)(ref val2)).magnitude * 1.05f;
			((Vector3)(ref val2)).Normalize();
			Vector3 val3 = val + val2 * num;
			if (Physics.Linecast(val, val3, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		private void Raycast_AlongBones()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			Raycast_RefreshOrigin();
			if (DoRaycasting(_AnimatorStartBonePos, _AnimatorMidBonePos))
			{
				CaptureRaycastHitForLeg();
				return;
			}
			Vector3 rayEnd = _AnimatorEndBonePos + (_AnimatorEndBonePos - _AnimatorMidBonePos) * 0.1f;
			if (DoRaycasting(_AnimatorMidBonePos, rayEnd))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		private void Raycast_StraightDown()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 lastKeyframeRootPos = AnkleH.LastKeyframeRootPos;
			Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
			float num;
			if (Owner.RaycastStartHeight == ERaycastStartHeight.FirstBone)
			{
				lastRootLocalPos = BoneStart.position;
				num = IKProcessor.fullLength;
			}
			else
			{
				lastRootLocalPos.x = lastKeyframeRootPos.x;
				lastRootLocalPos.z = lastKeyframeRootPos.z;
				num = Owner.ScaleReference * (Owner.RaycastStartHeightMul / Root.lossyScale.y);
				if (Owner.RaycastStartHeight == ERaycastStartHeight.StaticScaleReference)
				{
					lastRootLocalPos.y = num;
				}
				lastRootLocalPos = RootSpaceToWorld(lastRootLocalPos);
			}
			lastRaycastingOrigin = lastRootLocalPos;
			Vector3 val = -Owner.Up;
			Vector3 val2 = lastRootLocalPos + val * num;
			float num2 = ScaleRef * Owner.CastDistance;
			Vector3 rayEnd = (lastRaycastingEndPoint = val2 + val * num2);
			if (DoRaycasting(lastRootLocalPos, rayEnd))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		internal bool DoRaycasting(Vector3 origin, Vector3 rayEnd)
		{
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			bool flag;
			if (Owner.RaycastShape == ERaycastMode.Linecast)
			{
				flag = Physics.Linecast(origin, rayEnd, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
			}
			else
			{
				float num = Owner.ScaleReference * 0.065f * Owner.SpherecastResize;
				Vector3 val = rayEnd - origin;
				float num2 = ((Vector3)(ref val)).magnitude - num;
				flag = Physics.SphereCast(origin, num, ((Vector3)(ref val)).normalized, ref legGroundHit, num2 - num, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
				if (flag && Owner.SpherecastRealign > 0f)
				{
					Vector3 val2 = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
					val2.x = Mathf.LerpUnclamped(val2.x, AnkleH.LastKeyframeRootPos.x, Owner.SpherecastRealign);
					val2.z = Mathf.LerpUnclamped(val2.z, AnkleH.LastKeyframeRootPos.z, Owner.SpherecastRealign);
					((RaycastHit)(ref legGroundHit)).point = RootSpaceToWorld(val2);
				}
			}
			return flag;
		}

		private void CaptureRaycastHitForLeg()
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			RaycastHitted = true;
			groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
			raycastSlopeAngle = Vector3.Angle(Owner.Up, ((RaycastHit)(ref legGroundHit)).normal);
			if (raycastSlopeAngle > 45f)
			{
				RaycastHit val = legGroundHit;
				((RaycastHit)(ref val)).normal = Vector3.Slerp(((RaycastHit)(ref legGroundHit)).normal, Owner.Up, Mathf.InverseLerp(45f, 90f, raycastSlopeAngle) * 0.5f);
				legGroundHit = val;
			}
			_Raycasting_CalculateBasis();
		}

		private void _Raycasting_CalculateBasis()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			previousAnkleAlignedOnGroundHitWorldPos = ankleAlignedOnGroundHitWorldPos;
			ankleAlignedOnGroundHitWorldPos = GetAlignedOnGroundHitPos(groundHitRootSpacePos, ((RaycastHit)(ref legGroundHit)).point, ((RaycastHit)(ref legGroundHit)).normal);
			ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
		}

		private Vector3 GetAlignedOnGroundHitPos(Vector3 rootSpaceHitPos, Vector3 worldHit, Vector3 normal)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			Vector3 rootLocal = rootSpaceHitPos;
			rootLocal.y = ToRootLocalSpace(worldHit + normal * C_AnkleToHeelWorldHeight).y;
			return RootSpaceToWorld(rootLocal);
		}

		private Quaternion GetAlignedOnGroundHitRot(Quaternion sourceRotation, Vector3 normal)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			return Quaternion.FromToRotation(sourceRotation * AnkleIK.up, normal) * sourceRotation;
		}

		private void Stability_Init()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			Vector3 initialPosInRootSpace = ToRootLocalSpace(BoneEnd.position);
			InitialPosInRootSpace = initialPosInRootSpace;
		}

		public void DefineLegSide(LegsAnimator get, Leg knownOppositeLeg = null)
		{
			if (knownOppositeLeg != null && knownOppositeLeg.Side != 0)
			{
				if (knownOppositeLeg.Side == ELegSide.Left)
				{
					Side = ELegSide.Right;
				}
				else
				{
					Side = ELegSide.Left;
				}
			}
			else if ((Object)(object)BoneStart != (Object)null)
			{
				if (get.Util_OnLeftSide(BoneStart))
				{
					Side = ELegSide.Left;
				}
				else
				{
					Side = ELegSide.Right;
				}
			}
		}

		public void AssignOppositeLegIndex(int oppositeIndex)
		{
			if (oppositeIndex != OppositeLegIndex)
			{
				if (Object.op_Implicit((Object)(object)Owner) && Owner.Legs.ContainsIndex(oppositeIndex, falseIfNull: true))
				{
					Owner.Legs[oppositeIndex].OppositeLegIndex = Owner.Leg_GetIndex(this);
				}
				OppositeLegIndex = oppositeIndex;
			}
		}

		public Leg GetOppositeLegReference(LegsAnimator legs)
		{
			if (OppositeLegIndex < 0)
			{
				return null;
			}
			if (!legs.Legs.ContainsIndex(OppositeLegIndex, falseIfNull: true))
			{
				return null;
			}
			return legs.Legs[OppositeLegIndex];
		}

		public void RefreshLegAnkleToHeelAndFeetAndAxes(Transform baseT)
		{
			RefreshLegAnkleToHeelAndFeet(baseT);
			RefreshLegAnkleAxes(baseT);
		}

		public void RefreshLegAnkleToHeelAndFeet(Transform baseT)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)BoneEnd == (Object)null))
			{
				Vector3 position = BoneEnd.position;
				position.y = baseT.position.y;
				AnkleToHeel = BoneEnd.InverseTransformPoint(position);
				AnkleToFeetEnd = BoneEnd.InverseTransformPoint(position + baseT.forward * ScaleRef * 0.15f);
			}
		}

		public void RefreshLegAnkleAxes(Transform baseT)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)BoneEnd))
			{
				Quaternion val = baseT.rotation * Quaternion.Euler(0f, AnkleYawCorrection, 0f);
				AnkleForward = BoneEnd.InverseTransformDirection(val * Vector3.forward);
				AnkleUp = BoneEnd.InverseTransformDirection(val * Vector3.up);
				AnkleRight = BoneEnd.InverseTransformDirection(val * Vector3.right);
			}
		}

		private void EnsureAxesNormalization()
		{
			((Vector3)(ref AnkleRight)).Normalize();
			((Vector3)(ref AnkleUp)).Normalize();
			((Vector3)(ref AnkleForward)).Normalize();
		}
	}

	public enum ELegSide
	{
		Undefined,
		Left,
		Right
	}

	[Serializable]
	public class LegStepAnimatingParameters
	{
		[Range(0.1f, 1f)]
		[Tooltip("Average duration of the automatic leg animation")]
		public float StepMoveDuration = 0.375f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1.25f, 0.4f, 0.5f, 1f, 1f)]
		[Tooltip("Curve of ik point going towards desired position (just XZ movement, to Y - no leg rise curve)")]
		public AnimationCurve MoveToGoalCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

		[Tooltip("Making foot motion move towards target not in full linear straight towards target motion but adding a bit curve back (positive value) or forward (negative values) making movement a bit more natural")]
		[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.4f, 0.6f, 0.9f, 1f)]
		public AnimationCurve SpherizeTrack = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

		[Range(0f, 2f)]
		public float SpherizePower = 0.3f;

		[Range(0f, 1f)]
		[Tooltip("Minimum leg raise height. If distance of target step animation is small, then foot raise is smaller - down to this minimum raise value.")]
		public float MinFootRaise = 0.1f;

		[Range(0f, 1f)]
		[Tooltip("Maximum leg raise height. If distance of target step animation is very big, then foot raise is bigger - up to this maximum raise value.")]
		public float MaxFootRaise = 0.4f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.5f, 1f, 0.5f, 1f)]
		[Tooltip("Raise height step animation curve evaluated on step animation duration.")]
		public AnimationCurve RaiseYAxisCurve;

		[Range(0f, 1f)]
		[Tooltip("Allowing to speed up leg adjusting animation when leg is getting stretched, when opposite leg is requesting adjustement or when main character is rotating in place quickly")]
		[Space(3f)]
		public float AllowSpeedups = 0.4f;

		[Range(0.1f, 1f)]
		[Tooltip("You can allow to use opposite leg before idle glue leg adjustement finishes")]
		public float AllowDetachBefore = 1f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 1f, 0.6f, 0.6f, 1f)]
		[Tooltip("Extra hips push power animation curve evaluated on step animation duration.")]
		public AnimationCurve PushHipsOnMoveCurve;

		[Tooltip("Extra foot ankle rotation animation curve evaluated on step animation duration.")]
		[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve FootRotationCurve;

		public void RefreshDefaultCurves()
		{
			Curves_RefreshMoveToGoalCurve();
			Curves_RefreshRaiseYAxisCurve();
			Curves_RefreshSpherizeTrack();
			Curves_RefreshFootRotationCurve();
			Curves_RefreshPushHipsOnMoveCurve();
		}

		public void Curves_RefreshRaiseYAxisCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			RaiseYAxisCurve = new AnimationCurve();
			RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.505118f, 0.5f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.9110107f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
		}

		public void Curves_RefreshRaiseYAxisCurveSpiderPreset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			RaiseYAxisCurve = new AnimationCurve();
			RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.5943514f, 0.7946472f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
			RaiseYAxisCurve.AddKey(new Keyframe(1f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
		}

		public void Curves_RefreshMoveToGoalCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			MoveToGoalCurve = new AnimationCurve();
			MoveToGoalCurve.AddKey(new Keyframe(0f, 0f, 0f, 0f, 0f, 0.1842105f));
			MoveToGoalCurve.AddKey(new Keyframe(0.4885197f, 0.8972011f, 1.38764f, 1.38764f, 0.3333333f, 0.3333333f));
			MoveToGoalCurve.AddKey(new Keyframe(1f, 1f, 0f, 0f, 0f, 0f));
		}

		public void Curves_RefreshFootRotationCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			FootRotationCurve = new AnimationCurve();
			FootRotationCurve.AddKey(new Keyframe(0f, 0f, 0.5764588f, 0.5764588f, 0f, 0.4956417f));
			FootRotationCurve.AddKey(new Keyframe(0.4378169f, 0.2035736f, -0.2411275f, -0.2411275f, 0.3333333f, 0.4033037f));
			FootRotationCurve.AddKey(new Keyframe(0.7841034f, -0.1339308f, 0.3331003f, 0.3331003f, 0.3333333f, 0.3333333f));
			FootRotationCurve.AddKey(new Keyframe(1f, 0f, 0.3498169f, 0.3498169f, 0.5534658f, 0f));
		}

		public void Curves_RefreshPushHipsOnMoveCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			PushHipsOnMoveCurve = new AnimationCurve();
			PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.383f, 0.3733972f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.7075226f, 0.1460427f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
		}

		public void Curves_RefreshPushHipsOnMoveCurveSpiderPreset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			PushHipsOnMoveCurve = new AnimationCurve();
			PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.320017f, 0.654645f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.6681702f, 0.2174691f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
		}

		public void Curves_RefreshSpherizeTrack()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			SpherizeTrack = new AnimationCurve();
			SpherizeTrack.AddKey(new Keyframe(0f, 0f, 0.6958197f, 0.6958197f, 0f, 0.460011f));
			SpherizeTrack.AddKey(new Keyframe(0.4f, 0.3f, -0.04204308f, -0.04204308f, 0.333f, 0.3410656f));
			SpherizeTrack.AddKey(new Keyframe(0.85f, 0f, -0.2721428f, -0.2721428f, 0.3953607f, 0f));
		}

		public void LogCurve(string name, AnimationCurve c)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			string text = "";
			IFormatProvider invariantCulture = CultureInfo.InvariantCulture;
			for (int i = 0; i < c.keys.Length; i++)
			{
				Keyframe val = c.keys[i];
				text = text + "\n" + name + ".AddKey(new Keyframe(" + ((Keyframe)(ref val)).time.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).value.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inWeight.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outWeight.ToString(invariantCulture) + "f));";
			}
			Debug.Log((object)text);
		}
	}

	public enum EGlueMode
	{
		[Tooltip("Idle Mode is applying leg animation with extra motion and is checking some extra conditions like opposite leg grounded state etc.")]
		Idle,
		[Tooltip("Moving Mode is dedicated to be applied during playing animations with dynamic legs, it's checking less conditions than Idle Mode and is snapping glue points in a more straight forward slide animation.")]
		Moving,
		[Tooltip("Automatic mode is syncing with IsMoving/IsIdling LegsAnimator flags.")]
		Automatic
	}

	[Serializable]
	public class Variable
	{
		public enum EVariableType
		{
			Number,
			Bool,
			Vector2,
			Vector3,
			String,
			Curve,
			UnityObject,
			CustomObject
		}

		public string VariableName = "Variable";

		[SerializeField]
		private string Tooltip = "";

		private bool _tooltipWasSet;

		[SerializeField]
		private Vector4 _value = Vector4.zero;

		[SerializeField]
		private string _string = "";

		[SerializeField]
		private AnimationCurve _curve;

		[SerializeField]
		private Object _uObject;

		[SerializeField]
		private object _object;

		[NonSerialized]
		private int nameHash;

		public EVariableType VariableType;

		[SerializeField]
		private Vector4 _rangeHelper = Vector4.zero;

		public bool TooltipAssigned => _tooltipWasSet;

		public int GetNameHash
		{
			get
			{
				if (nameHash == 0)
				{
					nameHash = VariableName.GetHashCode();
				}
				return nameHash;
			}
		}

		public void AssignTooltip(string tooltip)
		{
			if (!_tooltipWasSet)
			{
				Tooltip = tooltip;
				_tooltipWasSet = true;
			}
		}

		public Variable(string name, object value)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			VariableName = name;
			SetValue(value);
		}

		public void SetValue(object o)
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			if (o is int)
			{
				_value = new Vector4((float)(int)o, 0f, 0f, 1f);
				VariableType = EVariableType.Number;
			}
			else if (o is float)
			{
				_value = new Vector4((float)o, 0f, 0f, 0f);
				VariableType = EVariableType.Number;
			}
			else if (o is bool)
			{
				if ((bool)o)
				{
					_value.x = 1f;
				}
				else
				{
					_value.x = 0f;
				}
				VariableType = EVariableType.Bool;
			}
			else if (o is Vector2 val)
			{
				_value = Vector4.op_Implicit(val);
				VariableType = EVariableType.Vector2;
			}
			else if (o is Vector3 val2)
			{
				_value = Vector4.op_Implicit(val2);
				VariableType = EVariableType.Vector3;
			}
			else if (o is string)
			{
				_string = o as string;
				VariableType = EVariableType.String;
			}
			else if (o is AnimationCurve)
			{
				_curve = (AnimationCurve)((o is AnimationCurve) ? o : null);
				VariableType = EVariableType.Curve;
			}
			else if (o is Object)
			{
				_uObject = (Object)((o is Object) ? o : null);
				VariableType = EVariableType.UnityObject;
			}
			else
			{
				_object = o;
				VariableType = EVariableType.CustomObject;
			}
		}

		public int GetInt()
		{
			return (int)_value.x;
		}

		public float GetFloat()
		{
			return _value.x;
		}

		public bool GetBool()
		{
			return _value.x == 1f;
		}

		public Vector2 GetVector2()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			return new Vector2(_value.x, _value.y);
		}

		public Vector3 GetVector3()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3(_value.x, _value.y, _value.z);
		}

		public string GetString()
		{
			return _string;
		}

		public AnimationCurve GetCurve()
		{
			return _curve;
		}

		public Object GetUnityObject()
		{
			return _uObject;
		}

		public object GetObject()
		{
			return _object;
		}

		public void SetMinMaxSlider(float min, float max)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			_rangeHelper = new Vector4(min, max, 0f, 0f);
		}

		public void SetCurveFixedRange(float startTime, float startValue, float endTime, float endValue)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			_rangeHelper = new Vector4(startTime, startValue, endTime, endValue);
		}

		public bool Editor_DisplayVariableGUI()
		{
			return false;
		}
	}

	[Serializable]
	public class ReferencePose
	{
		[Serializable]
		public class LegPoseReference
		{
			public BonePoseReference UpperLegPose = new BonePoseReference();

			public BonePoseReference LowerLegPose = new BonePoseReference();

			public BonePoseReference AnklePose = new BonePoseReference();

			public BonePoseReference FeetPose = new BonePoseReference();

			public void SaveLegPose(Leg leg, LegsAnimator animator)
			{
				UpperLegPose.SavePose(leg.BoneStart, animator);
				LowerLegPose.SavePose(leg.BoneMid, animator);
				AnklePose.SavePose(leg.BoneEnd, animator);
				FeetPose.SavePose(leg.BoneFeet, animator);
			}

			public void RestoreLegPose(LegsAnimator animator)
			{
				UpperLegPose.RestorePose(animator);
				LowerLegPose.RestorePose(animator);
				AnklePose.RestorePose(animator);
				FeetPose.RestorePose(animator);
			}
		}

		[Serializable]
		public class BonePoseReference
		{
			public Transform SourceTransform;

			public Quaternion RotationInRoot;

			public Vector3 PositionInRoot;

			public void SavePose(Transform transform, LegsAnimator animator)
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
				{
					SourceTransform = transform;
					PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
					RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
				}
			}

			public void RestorePose(LegsAnimator animator)
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_004c: Unknown result type (might be due to invalid IL or missing references)
				if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
				{
					SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
					SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
				}
			}
		}

		public BonePoseReference MainHipsPose = new BonePoseReference();

		public List<BonePoseReference> HipsPoses = new List<BonePoseReference>();

		public List<LegPoseReference> LegPoses = new List<LegPoseReference>();

		public bool IsSet(LegsAnimator animator)
		{
			if ((Object)(object)MainHipsPose.SourceTransform != (Object)null && HipsPoses.Count == animator.ExtraHipsHubs.Count)
			{
				return LegPoses.Count == animator.Legs.Count;
			}
			return false;
		}

		public void TweakListsFor(LegsAnimator animator)
		{
			while (HipsPoses.Count > animator.ExtraHipsHubs.Count)
			{
				HipsPoses.RemoveAt(HipsPoses.Count - 1);
			}
			while (HipsPoses.Count < animator.ExtraHipsHubs.Count)
			{
				HipsPoses.Add(new BonePoseReference());
			}
			while (LegPoses.Count > animator.Legs.Count)
			{
				LegPoses.RemoveAt(LegPoses.Count - 1);
			}
			while (LegPoses.Count < animator.Legs.Count)
			{
				LegPoses.Add(new LegPoseReference());
			}
		}

		public void Clear()
		{
			MainHipsPose.SourceTransform = null;
			HipsPoses.Clear();
			LegPoses.Clear();
		}
	}

	public enum ELegsScaleReference
	{
		PelvisToGroundDistance,
		FirstLegLength,
		Custom,
		PelvisLegAverage
	}

	public enum ECalibrateMode
	{
		[Tooltip("No Extra overhead")]
		None,
		[Tooltip("Resetting bones local rotations to the initialized state")]
		Calibrate,
		[Tooltip("Resetting bones local rotations to the captured animator state (can fix trigger colliders detection when colliders added on legs)")]
		FixedCalibrate
	}

	public enum ERaycastPrecision
	{
		Linecast,
		BoxcastPrecision
	}

	public enum ERaycastStartHeight
	{
		[Tooltip("Casting ray starting from current hips height position of the character. Can be bad for insect creatures!")]
		Hips,
		[Tooltip("Good for spiders! Casting raycast on defined height of the character")]
		StaticScaleReference,
		[Tooltip("Casting ray starting from first bone of the leg (it's affecting height + start raycast position).")]
		FirstBone
	}

	public enum ERaycastStyle
	{
		[Tooltip("Launching raycast from foot above origin point. Good for bipeds with whole body step down/up features.")]
		StraightDown,
		[Tooltip("Launching raycast from pelvis towards foot, good for spider like creatures to detect steep ground more effectively. Body step down/up will not work as precise with this option.")]
		OriginToFoot,
		[Tooltip("Doing raycast like OriginToFoot : but if no ground is found - using another raycast in StraightDown style to find ground below and allow to execute body step down/up feature.")]
		OriginToFoot_DownOnNeed,
		[Tooltip("Doing raycasts per bone : from start bone towards mid bone, mid bone towards end bone, then down. Best precision for insect creatures.")]
		AlongBones,
		[Tooltip("No Raycasting : provide raycast hits custom using code, or leave it custom for just gluing legs animation.")]
		NoRaycasting
	}

	public enum ERaycastMode
	{
		Linecast,
		Spherecast
	}

	public enum ENoRaycastBehviour
	{
		[Tooltip("If ground raycast is lost, leg will detach and switch to ungrounded state")]
		Detach,
		[Tooltip("If no raycast hit detected, should character still animate leg steps in air on zero height floor level? (fake floor)")]
		ZeroFloorSteps,
		[Tooltip("If ground raycast is lost, leg will stick to lastest found raycast hit until leg get stretched")]
		KeepAttached
	}

	[Tooltip("Optional reference to unity's Animator. Legs Animator can use animator's variables to read state of your character movement, like IsGrounded or IsMoving + other extra helpers for custom modules and special calculations.")]
	public Animator Mecanim;

	[Tooltip("Animator parameter to read value for auto-define grounded state of the character (you can use LegAnimator.User_SetIsGrounded() through code instead)")]
	public string GroundedParameter = "";

	[Tooltip("Animator parameter (bool or float - Bool recommended for quicker Not-Moving reaction) to read value for auto-define movement state of the character (you can use LegAnimator.User_SetIsMoving() through code instead)")]
	public string MovingParameter = "";

	private int _hash_Grounded = -1;

	private int _hash_Moving = -1;

	private bool _hash_MovingIsFloat;

	[Range(0f, 0.5f)]
	[HideInInspector]
	public float User_IsMovingMecanim_NotMovingFloat_Threshold = 0.1f;

	private int _hash_Sliding = -1;

	[Tooltip("Optional Rigidbody which is used for few helper calculations. If rigidbody is assigned, then rigidbody velocity will drive 'Desired Move Direction' value (! only if .IsMoving is true !), unless you use 'User_SetDesiredMovementDirection'")]
	public Rigidbody Rigidbody;

	[Tooltip("Use rigidboy velocity state to automatically drive Leg Animator's helper 'IsMoving' flag")]
	public bool UseRigidbodyVelocityForIsMoving;

	[Tooltip("Use leg raycasts to automatically define Leg Animator's helper 'IsGrounded' flag")]
	public bool UseRaycastsForIsGrounded;

	[Tooltip("Animator parameter to read value for auto-define sliding state of the character - auto fading off gluing (you can use LegAnimator.User_SetIsSliding() through code instead)")]
	public string SlidingParameter = "";

	[Tooltip("Optional bone for modules if needed")]
	public Transform SpineBone;

	[Tooltip("Optional bone for modules if needed")]
	public Transform ChestBone;

	private CalibrateTransform _spineBoneCalibrate;

	private CalibrateTransform _ChestBoneCalibrate;

	[Tooltip("Animator parameter to read value for auto-define calculations state of the character. The ragdolled parameter is disabling legs, and other algorithms which can conflict with physical animations. (you can use LegAnimator.User_SetIsRagdolled() through code instead)")]
	public string RagdolledParameter = "";

	private int _hash_Ragdolled = -1;

	private bool _ragdolled;

	[NonSerialized]
	public float MinNonRagdolledForBlendOut;

	[Space(5f)]
	[Tooltip("Calculating leg swing velocity in order to prevent gluing foot when swinging forward during movement forward (during forward swing, foot sometimes is touching ground which can result in gluing foot too soon, especially with ground level increased)\nWhen this value is high, foot will detect gluing less oftem.")]
	[Range(0f, 1f)]
	public float SwingHelper;

	[Tooltip("Local height value for the glue algorithm. You can try adjusting it's value during character movement and idling, to detect glue more effectively.")]
	public float GluingFloorLevel = 0.05f;

	public bool GluingFloorLevelUseOnMoving;

	public float GluingFloorLevelOnMoving;

	private float _glueingFloorLevel;

	[Space(5f)]
	[Tooltip("If you want to push out legs out of each other if their IK points are overlapping in one placement")]
	public float StepPointsOverlapRadius;

	public bool UseStepPointsOverlapRadiusOnMoving;

	public float StepPointsOverlapRadiusOnMoving;

	public MotionInfluenceProcessor MotionInfluence = new MotionInfluenceProcessor();

	public UnityEvent Event_OnStep = new UnityEvent();

	[Range(0f, 0.3f)]
	[Tooltip("Increase to execute step event sooner (speed up step confirmation). Useful if step events are executed too late.")]
	public float EventExecuteSooner = 0.05f;

	[Tooltip("If you want to send step events also during movement idle (in case you already use animation clip events for it)")]
	public bool SendOnMovingGlue;

	[Tooltip("When false, it will not allow to send step event when character is stopped")]
	public bool SendOnStopping;

	[Tooltip("Enabling triggering step events when character just switched grounded state")]
	public bool StepEventOnLanding;

	[Space(5f)]
	[Tooltip("Game Object with attached component implementing LegsAnimator.ILegStepInfoReceiver interface to receiver detailed info about leg step")]
	public Transform StepInfoReceiver;

	private ILegStepReceiver _StepReceiver;

	private ILegRaiseReceiver _RaiseReceiver;

	[Tooltip("Additional pelvis position push in local space. Can be accesed for custom pelvis offset animation or for constant model pose correction.")]
	public Vector3 ExtraPelvisOffset = Vector3.zero;

	[Tooltip("Time which needs to elapse after character stop, to trigger legs repose to most relevant pose in comparison to played idle animation")]
	[FPD_Suffix(0f, 2f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float ReposeGluingAfter;

	[Tooltip("Enable if you want to use gluing only when character is idling. Useful when it's too much work needed to setup dynamic gluing during movement for your character. (it will still use feet ground align)")]
	public bool GlueOnlyOnIdle;

	[Tooltip("Raycasting down direction will be synced with base transform up axis when this feature is enabled.")]
	public bool LocalWorldUp = true;

	private float reposeGluingTimer;

	private bool reposedGluing;

	private Quaternion IK_UseIKRotatorQuat = Quaternion.identity;

	[Tooltip("Completely turning off all custom modules scripts execution.")]
	public bool DisableCustomModules;

	[Tooltip("Custom coded legs animator modules to change component behaviour without affecting core code")]
	public List<LegsAnimatorCustomModuleHelper> CustomModules = new List<LegsAnimatorCustomModuleHelper>();

	private bool UsingControlModules;

	[Tooltip("Power multiplier for pelvis push events")]
	public float ImpulsesPowerMultiplier = 1f;

	public float ImpulsesDurationMultiplier = 1f;

	[Tooltip("Damping impulses which are pushing body above ground level")]
	[Range(0f, 1f)]
	public float ImpulsesDampUpPushes;

	public PelvisImpulseSettings DebugPushHipsImpulse = new PelvisImpulseSettings(Vector3.down, 0.6f, 1f);

	protected List<ImpulseExecutor> Impulses = new List<ImpulseExecutor>();

	private bool _ImpulsesDoWorld;

	private bool _ImpulsesDoLocal;

	private bool _ImpulsesDoHips;

	private Vector3 _ImpulsesWorldPush = Vector3.zero;

	private Vector3 _ImpulsesWorldPushInherit = Vector3.zero;

	private Vector3 _ImpulsesLocalPush = Vector3.zero;

	private Vector3 _ImpulsesLocalPushInherit = Vector3.zero;

	private Vector3 _ImpulsesHipsRotation = Vector3.zero;

	private Vector3 _ImpulsesRotationElastic = Vector3.zero;

	private Vector3 _Hips_RotationElasticLocalOffset = Vector3.zero;

	[Tooltip("Use hips step adjustements and the stability algorithms")]
	public bool UseHips = true;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Whole body lift effect blend")]
	public float HipsHeightStepBlend = 1f;

	[Range(0f, 1f)]
	[Tooltip("How fast body should adjust up/down")]
	public float HipsHeightStepSpeed = 0.7f;

	public EHipsAdjustStyle HipsAdjustStyle;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Adjusting hips to keep body balance pose")]
	public float StabilizeCenterOfMass = 0.45f;

	[Range(0f, 1f)]
	[Tooltip("Blend stability pose reference from: initial pose to: current animator pose")]
	public float AnimationIsStablePose = 0.75f;

	[Tooltip("How fast body should adjust to the stability pose / to stretch preventer pose")]
	[Range(0f, 1f)]
	public float StabilizingSpeed = 0.375f;

	[Tooltip("Simulating body behaviour when doing leg steps")]
	[Range(0f, 1f)]
	public float PushHipsOnLegMove = 0.1f;

	[Tooltip("If your setup contains more than 2 legs it can be helpful to prevent overlapping pushes of multiple legs")]
	public bool NormalizePush;

	[Tooltip("Related with 'Push Hips On Leg Move' parameter above. How rapidly the pelvis push effect should be animated.")]
	[Range(0f, 1f)]
	public float PushReactionSpeed = 0.3f;

	[Tooltip("If Push in Y axis seems to be too strong, you can calm it down with this parameter")]
	[Range(0f, 2f)]
	public float PushYBlend = 1f;

	[Space(3f)]
	[Range(0f, 1f)]
	[Tooltip("Auto adjust hips to prevent leg stretching poses")]
	public float HipsStretchPreventer = 0.15f;

	public float StretchPreventerSpeed = 0.8f;

	[Space(7f)]
	[Tooltip("Some of the stabilizing features may be not wanted when your character is running, you can blend them automatically to desired amount with this slider (you need to implement IsGrounded/IsMoving controls to give Legs Animator information about your character movement state)")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float StabilizeOnIsMoving = 0.5f;

	private Vector3 _LastAppliedHipsStabilityOffset = Vector3.zero;

	internal Vector3 _LastAppliedHipsFinalPosition = Vector3.zero;

	internal Vector3 _LastAppliedHipsFinalOffset = Vector3.zero;

	internal Quaternion _LastAppliedHipsFinalRotationOffset = Quaternion.identity;

	internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

	public Vector3 _Hips_Modules_ExtraWOffset = Vector3.zero;

	public Vector3 _Hips_Modules_ExtraRotOffset = Vector3.zero;

	private bool _updateHipsAdjustements = true;

	[Tooltip("If this model is created out of multiple leg bones hubs, you can define it here")]
	public List<Transform> ExtraHipsHubs = new List<Transform>();

	[Tooltip("Enter on the selected option on the right to see description")]
	public EHipsHubsHandling HipsHubsHandling = EHipsHubsHandling.Detailed;

	[Range(0f, 1f)]
	public float HipsHubsBlend = 1f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 3f, 0f, 1f, 1f, 1f)]
	[Tooltip("If leg hub is having backbones to compensate target rotation, you can controll the spine bend style with this curve")]
	public AnimationCurve HubsBackBonesBlend = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	[Range(0f, 1f)]
	[Tooltip("Adding elasticity effect to the hub spine backbones adjustement animation")]
	public float HubBackBonesElasticity = 0.1f;

	private bool _hipsHubs_using;

	public HipsReference HipsSetup = new HipsReference();

	public EStabilityMode StabilityAlgorithm = EStabilityMode.Universal;

	private Vector3 _Hips_StabilityLocalOffset = Vector3.zero;

	private FMuscle_Eulers _Hips_RotationMuscle;

	private Vector3 _Hips_FinalStabilityOffset = Vector3.zero;

	public List<Leg> Legs = new List<Leg>();

	public LegStepAnimatingParameters BaseLegAnimating = new LegStepAnimatingParameters();

	[Tooltip("Using algorithm responsive for attaching feet to the ground when detected grounded foot in the played animation.")]
	public bool UseGluing = true;

	[Tooltip("You can smoothly change Glue Blend down to transition into sliding if your character is walking on ice or sliding on steep ground.")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float MainGlueBlend = 1f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AdditionalGlueBlend = 1f;

	[Space(3f)]
	[Range(0f, 1f)]
	[Tooltip("If distance from the last attach point exceeds this distance (check scene gizmos) the leg will be detached.")]
	public float GlueRangeThreshold = 0.375f;

	[Range(0f, 1f)]
	[Tooltip("How quickly leg attachement transition should be proceeded.")]
	public float GlueFadeInSpeed = 0.85f;

	[Range(0f, 1f)]
	[Tooltip("If foot animation in original played clip is not reaching floor soon enough, increase it to attach for position slightly below current foot positioning.")]
	public float AllowGlueBelowFoot = 0.2f;

	[Range(0f, 1f)]
	[Tooltip("How quickly leg detachement transition should be proceeded.")]
	public float GlueFadeOutSpeed = 0.5f;

	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "", true, 0)]
	[Tooltip("If leg rotation exceeds this angle during being attach, the leg will be detached.")]
	[Space(5f)]
	public float UnglueOn = 30f;

	[Space(1f)]
	[Range(0f, 1f)]
	[Tooltip("When leg glue target position is stretching leg too much it will shift leg target towards source animation leg position.")]
	public float AllowGlueDrag = 0.7f;

	[NonSerialized]
	public float DontGlueAttachIfTooNearOppositeLeg;

	[Tooltip("Enter on the value field on the right to see tooltip.")]
	public EGlueMode GlueMode = EGlueMode.Automatic;

	[Tooltip("Making Gluing animations only local space, which can be helpful when character is standing on the moving platform.")]
	public bool OnlyLocalAnimation;

	[Range(0f, 1f)]
	[Tooltip("Smoothing leg align motion when sudden uneven terrain step occurs")]
	public float SmoothSuddenSteps = 0.85f;

	[Tooltip("Making leg rise a bit over ground when character leg overlaps collision (it's mostly visible on steep slopes)")]
	[Range(0f, 2f)]
	[Space(3f)]
	public float LegElevateBlend = 0.7f;

	[Range(0f, 1f)]
	public float LegElevateHeightLimit = 0.6f;

	[Space(6f)]
	[Tooltip("Overall foot rotation blend on the slope step align.")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float FootRotationBlend = 1f;

	[Space(4f)]
	[Tooltip("How quickly foot should align it's rotation to the slopes")]
	[Range(0f, 1f)]
	public float FootAlignRapidity = 0.75f;

	[Tooltip("If it's human leg limb with foot, then turn it on for the foot bone animation and alignments. But if it's something like spider leg, then disable it")]
	public bool AnimateFeet = true;

	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "", true, 0)]
	[Tooltip("If feet rotation is above this value, feet rotation will be limited to avoid weird foot rotation pose")]
	public float LimitFeetYaw = 30f;

	[Range(-0.05f, 0.15f)]
	[Tooltip("Local space ANKLE-step height detection level. It's detail parameter to adjust feet aligning sooner/later when foot is near to ground.")]
	public float AnimationFloorLevel = 0.001f;

	public static LegsAnimator _Editor_LastSelectedLA;

	private bool _wasInstantTriggered = true;

	[HideInInspector]
	[SerializeField]
	private ReferencePose setupPose = new ReferencePose();

	[SerializeField]
	[HideInInspector]
	public List<ReferencePose> ExtraSetupPoses = new List<ReferencePose>();

	private bool _grounded = true;

	private bool _moving;

	private bool _sliding;

	protected float NotSlidingBlend = 1f;

	private bool? _wasFadingOn;

	protected bool legsWasDisabled;

	[Tooltip("Algorithm selector which controls how leg is bent - knee hint.")]
	public FimpIK_Limb.FIK_HintMode IKHintMode;

	[Tooltip("Dragging Leg if stretched too much, for humanoids this vlaue should be high (around 0.9 - 1.1) for spider or similar creatures it should be lower.\nUsing feet bones can be really helpful to enchance the leg stretch length range!")]
	[Range(0.4f, 1.1f)]
	public float LimitLegStretch = 0.99f;

	[Tooltip("Pushing feet up/down if required for model correction.")]
	public float FeetYOffset;

	[Tooltip("Adjust the visual size of feet in order to make foot aligning calculations more precise.")]
	[Range(-1f, 1f)]
	public float FeetLengthAdjust;

	[Tooltip("When not assigned, component will use this transform as 'Base Transform', but if your movement controller core is located in different transform, assign it here to be fully synchronized.")]
	[SerializeField]
	private Transform baseTransform;

	[Tooltip("The anchor bone for all other limbs.\n! It needs to be parent of Leg Bones !")]
	public Transform Hips;

	private Vector3 InitialBaseScale = Vector3.one;

	[Tooltip("Define helper value for the algorithm, to define raycasting distance - scale for the algorithms to animate model in the correct way.\n\nCheck scene gizmos to adjust this value.")]
	public ELegsScaleReference ScaleReferenceMode = ELegsScaleReference.PelvisLegAverage;

	[SerializeField]
	private float finalScaleReference = 0.5f;

	[SerializeField]
	private float finalScaleReferenceSqrt = 0.1f;

	[SerializeField]
	private float customScaleReferenceValue = 0.5f;

	[Tooltip("Do component init after few frames of the game (can be useful when waiting for some of the components to be generated, or to initialize component not during T-pose)")]
	public bool DelayedInitialization;

	[Tooltip("Hard refresh bones on update: it's required when any of procedurally animated bones is not handled by keyframe animation.\nIf you're sure, your animations are always keyframe animated, you can disable this feature for small performance boost.")]
	public ECalibrateMode Calibrate = ECalibrateMode.Calibrate;

	[Tooltip("If your Unity Animator is using 'Animate Physics' update mode, you should enable this parameter.")]
	public bool AnimatePhysics;

	[Tooltip("If time.scale should or shouldn't affect legs animation")]
	public bool UnscaledDeltaTime;

	[Tooltip("Disable Legs Animator calculations when this renderer is not seen by any camera (including scene view camera!)")]
	public Renderer DisableIfInvisible;

	public List<Renderer> DisableIfInvisibleExtraRenderers = new List<Renderer>();

	[Tooltip("Smoothly fade out Legs Animator when far from the camera")]
	public float FadeOffAtDistance;

	[NonSerialized]
	public Transform FadeOff_DistanceToCamera;

	private Vector3 _worldUpAxisVector = Vector3.up;

	[Tooltip("Physics layer mask for leg raycasting. Which objects should be considered as steps.")]
	public LayerMask GroundMask = LayerMask.op_Implicit(1);

	public QueryTriggerInteraction RaycastHitTrigger = (QueryTriggerInteraction)1;

	[Tooltip("Maximum raycasting check range. Check Gizmos on the scene view")]
	[Range(0f, 2f)]
	public float CastDistance = 1f;

	public ERaycastStartHeight RaycastStartHeight;

	[Tooltip("Origin height point for raycasts. Check Gizmos on the scene view")]
	[Range(0.5f, 2.5f)]
	public float RaycastStartHeightMul = 1f;

	[Tooltip("How physical raycasting should be done. Enter on the selected style to see tooltip.")]
	public ERaycastStyle RaycastStyle;

	[Tooltip("Physics detection ray volume size. Sphere Cast can provide more smooth transitions on the edges but costs a bit more.")]
	public ERaycastMode RaycastShape;

	[Tooltip("Shift spherecast hit point result towards original XZ position instead of hit position. Can be helpful to prevent spider legs from being bent too much in narrow spaces.")]
	[Range(0f, 1f)]
	public float SpherecastRealign;

	[Tooltip("Shift spherecast hit point result towards original XZ position instead of hit position. Can be helpful to prevent spider legs from being bent too much in narrow spaces.")]
	public float SpherecastResize = 1f;

	[Tooltip("If foot will not find ground beneath, you can trigger different leg behavior in such scenario")]
	public ENoRaycastBehviour NoRaycastGroundBehaviour;

	[Tooltip("DEPRECATED - Used just for back compatibility - if true, switching NoRaycastGroundBehaviour to ZeroFloorSteps and changing this value to false.")]
	public bool ZeroStepsOnNoRaycast;

	public float NoRaycast_KeepAttachedUntilStretch = 1.1f;

	[Tooltip("How low whole body can be pulled down when one of the legs raycast hit is lower than default object position.")]
	[Range(0f, 1f)]
	public float BodyStepDown = 0.5f;

	[Range(0f, 1f)]
	[Tooltip("How high whole body can be pulled up when all legs raycast hits are higher than default object position. (rare case for special character controllers).\nIt can also help out extra spine hubs to adjust on higher steps (for quadrupeds).")]
	[Space(3f)]
	public float MaxBodyStepUp;

	[Space(3f)]
	[Tooltip("How fast should be applied fade-out when character starts being ungrounded. (jumping/falling)")]
	[Range(0f, 1f)]
	public float UngroundFadeSpeed = 0.1f;

	[Range(0f, 1f)]
	public float IsMovingFadeSpeed = 0.4f;

	private float _calc_rayGrounding;

	private float _calc_lastGrounded = -1f;

	private float _lastMainBlend = 1f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Total blend of the plugin effects. When zero it disables most of the calculations (but not all)")]
	public float LegsAnimatorBlend = 1f;

	protected float cullingBlend = 1f;

	protected float protectedBlend = 1f;

	protected bool AllowUpdate;

	protected bool _started;

	private bool _fixedUpdated;

	public Vector3 DesiredMovementDirection { get; private set; }

	public bool usingCustomDesiredMovementDirection { get; private set; }

	public bool IsRagdolled => _ragdolled;

	public float RagdolledTime { get; private set; }

	public bool Helper_WasMoving { get; private set; }

	public float _stepPointsOverlapRadius { get; private set; }

	protected bool UseEvents { get; private set; }

	public bool JustGrounded { get; private set; }

	public Vector3 IK_CustomIKRotatorVector { get; private set; } = Vector3.zero;

	private float HipsBlendWeight => _MainBlend * HipsAdjustingBlend * HipsHeightStepBlend;

	public float HipsAdjustingBlend
	{
		get
		{
			if (!UseHips)
			{
				return 0f;
			}
			return 1f;
		}
	}

	public List<HipsReference> HipsHubs { get; private set; }

	public Vector3 _Get_Hips_StabilityLocalOffset => _Hips_StabilityLocalOffset;

	public Vector3 _Get_Hips_StabilityLocalAdjustement => HipsSetup._Get_Hips_StabilityLocalAdjustement;

	public LegStepAnimatingParameters LegAnimatingSettings => BaseLegAnimating;

	public float GlueBlend
	{
		get
		{
			if (!UseGluing)
			{
				return 0f;
			}
			return _MainBlend * MainGlueBlend * AdditionalGlueBlend;
		}
	}

	public EGlueMode _glueModeExecuted { get; set; }

	protected virtual bool UseCustomIK => false;

	public virtual string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Legs Animator/SPR_LegsCrop";
		}
	}

	public bool LegsInitialized { get; private set; }

	public ReferencePose SetupPose => setupPose;

	public bool IsGrounded => _grounded;

	public bool IsInAir => !_grounded;

	public float IsGroundedBlend { get; private set; }

	public float RagdolledDisablerBlend { get; protected set; } = 1f;

	public bool IsMoving => _moving;

	public bool IsIdling => !_moving;

	public float IsMovingBlend { get; private set; }

	public bool IsSliding => _sliding;

	public float IsSlidingBlend => 1f - NotSlidingBlend;

	public float DeltaTime { get; private set; }

	public float Scale { get; private set; }

	public Matrix4x4 CastMx { get; private set; }

	public Matrix4x4 InvCastMx { get; private set; }

	public float DynamicYScale => BaseTransform.lossyScale.y / InitialBaseScale.y;

	public float ScaleReference => finalScaleReference * BaseTransform.lossyScale.x;

	public float ScaleReferenceNoScale => finalScaleReference;

	public float ScaleReferenceSqrt => finalScaleReferenceSqrt;

	public float FadeOff_lastCameraDistance { get; protected set; }

	public Vector3 Up
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _worldUpAxisVector;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_worldUpAxisVector = value;
		}
	}

	public float GroundedTime { get; private set; }

	public float InAirTime => 0f - GroundedTime;

	public float MovingTime { get; private set; }

	public float StoppedTime => 0f - MovingTime;

	public Transform BaseTransform => baseTransform;

	public float _MainBlend { get; protected set; }

	protected bool _lastMainBlendChanged { get; private set; }

	public float _MainBlendNoRagdolling { get; protected set; }

	public float _MainBlendPlusGrounded { get; protected set; }

	public void User_SetIsRagdolled(bool isRagdolled)
	{
		if (isRagdolled != _ragdolled)
		{
			if (_ragdolled)
			{
				OnLegsReactivate();
			}
			_ragdolled = isRagdolled;
		}
	}

	public void User_SetDesiredMovementDirection(Vector3 worldDirection)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		usingCustomDesiredMovementDirection = true;
		DesiredMovementDirection = worldDirection;
	}

	public void User_SetDesiredMovementDirection(Vector3 worldDirection, bool removeYspeed)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (removeYspeed)
		{
			worldDirection = ToRootLocalSpaceVec(worldDirection);
			worldDirection.y = 0f;
			worldDirection = RootToWorldSpaceVec(worldDirection);
		}
		User_SetDesiredMovementDirection(worldDirection);
	}

	public void User_SetDesiredMovementDirectionOff()
	{
		usingCustomDesiredMovementDirection = false;
	}

	public virtual void Controll_DefineHashes()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Invalid comparison between Unknown and I4
		if ((Object)(object)Mecanim == (Object)null)
		{
			return;
		}
		if (!string.IsNullOrWhiteSpace(GroundedParameter))
		{
			_hash_Grounded = Animator.StringToHash(GroundedParameter);
		}
		else
		{
			_hash_Grounded = -1;
		}
		if (!string.IsNullOrWhiteSpace(MovingParameter))
		{
			_hash_Moving = Animator.StringToHash(MovingParameter);
			if ((Object)(object)Mecanim.runtimeAnimatorController != (Object)null)
			{
				for (int i = 0; i < Mecanim.parameterCount; i++)
				{
					if (Mecanim.GetParameter(i).nameHash == _hash_Moving && (int)Mecanim.GetParameter(i).type == 1)
					{
						_hash_MovingIsFloat = true;
						break;
					}
				}
			}
		}
		else
		{
			_hash_Moving = -1;
		}
		if (!string.IsNullOrWhiteSpace(SlidingParameter))
		{
			_hash_Sliding = Animator.StringToHash(SlidingParameter);
		}
		else
		{
			_hash_Sliding = -1;
		}
		if (!string.IsNullOrWhiteSpace(RagdolledParameter))
		{
			_hash_Ragdolled = Animator.StringToHash(RagdolledParameter);
		}
		else
		{
			_hash_Ragdolled = -1;
		}
	}

	protected virtual void Controll_Update()
	{
		if (_hash_Ragdolled != -1)
		{
			User_SetIsRagdolled(Mecanim.GetBool(_hash_Ragdolled));
		}
		if (IsRagdolled)
		{
			if (RagdolledTime < 0f)
			{
				RagdolledTime = 0f;
			}
			RagdolledTime += DeltaTime;
			RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 0f, DeltaTime * 6f);
			UpdateBeingRagdolled();
		}
		else
		{
			if (RagdolledTime > 0f)
			{
				RagdolledTime = 0f;
			}
			RagdolledTime -= DeltaTime;
			bool flag = false;
			if (MinNonRagdolledForBlendOut > 0f)
			{
				if (0f - RagdolledTime > MinNonRagdolledForBlendOut)
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				float ragdolledDisablerBlend = RagdolledDisablerBlend;
				RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 1f, DeltaTime * 4f);
				if (ragdolledDisablerBlend != RagdolledDisablerBlend)
				{
					UpdateBeingRagdolled();
				}
			}
			else
			{
				RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 0f, DeltaTime * 6f);
			}
		}
		if (IsMoving || IsMovingBlend > 0.5f)
		{
			Helper_WasMoving = true;
		}
		else
		{
			Helper_WasMoving = false;
		}
		if (_hash_Grounded != -1)
		{
			User_SetIsGrounded(Mecanim.GetBool(_hash_Grounded));
		}
		if (_hash_Moving != -1)
		{
			if (_hash_MovingIsFloat)
			{
				User_SetIsMoving(Mecanim.GetFloat(_hash_Moving) > ScaleReference * User_IsMovingMecanim_NotMovingFloat_Threshold);
			}
			else
			{
				User_SetIsMoving(Mecanim.GetBool(_hash_Moving));
			}
		}
		if (_hash_Sliding != -1)
		{
			User_SetIsSliding(Mecanim.GetBool(_hash_Sliding));
		}
		if (GlueMode == EGlueMode.Automatic)
		{
			if (GroundedTime < 0.1f)
			{
				_glueModeExecuted = EGlueMode.Moving;
			}
			else if (IsMoving)
			{
				_glueModeExecuted = EGlueMode.Moving;
			}
			else
			{
				_glueModeExecuted = EGlueMode.Idle;
			}
		}
		else
		{
			_glueModeExecuted = GlueMode;
		}
		if (IsGrounded && GroundedTime < 0.2f)
		{
			_glueModeExecuted = EGlueMode.Moving;
		}
		if (IsGrounded)
		{
			if (GroundedTime < 0f)
			{
				GroundedTime = 0f;
			}
			GroundedTime += DeltaTime;
		}
		else
		{
			if (GroundedTime > 0f)
			{
				GroundedTime = 0f;
			}
			GroundedTime -= DeltaTime;
		}
		if (IsMoving)
		{
			if (MovingTime < 0f)
			{
				MovingTime = 0f;
			}
			MovingTime += DeltaTime;
		}
		else
		{
			if (MovingTime > 0f)
			{
				MovingTime = 0f;
			}
			MovingTime -= DeltaTime;
		}
		if (GluingFloorLevelUseOnMoving)
		{
			_glueingFloorLevel = Mathf.LerpUnclamped(GluingFloorLevel, GluingFloorLevelOnMoving, IsMovingBlend);
		}
		else
		{
			_glueingFloorLevel = GluingFloorLevel;
		}
		if (UseStepPointsOverlapRadiusOnMoving)
		{
			_stepPointsOverlapRadius = Mathf.LerpUnclamped(StepPointsOverlapRadius, StepPointsOverlapRadiusOnMoving, IsMovingBlend);
		}
		else
		{
			_stepPointsOverlapRadius = StepPointsOverlapRadius;
		}
	}

	private void BaseObject_MotionUpdate()
	{
		MotionInfluence.Update();
	}

	private void MotionInfluence_Init()
	{
		MotionInfluence.Init(BaseTransform);
	}

	protected virtual void Control_OnLand()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!StepEventOnLanding)
		{
			return;
		}
		float num = float.MaxValue;
		Leg leg = null;
		for (int i = 0; i < Legs.Count; i++)
		{
			float y = ToRootLocalSpace(Legs[i]._PreviousFinalIKPos).y;
			if (y < num)
			{
				num = y;
				leg = Legs[i];
				Legs[i].StepEventSentInCustomWay();
			}
		}
		if (leg != null)
		{
			Events_OnStep(leg, 1f, EStepType.OnLanding);
		}
	}

	protected virtual void Control_OnLooseGround()
	{
	}

	protected virtual void Control_OnStopMoving()
	{
	}

	protected virtual void Control_OnStartMoving()
	{
	}

	private void RefreshTargetMovementDirectionHelper()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (usingCustomDesiredMovementDirection)
		{
			return;
		}
		if (!IsMoving)
		{
			DesiredMovementDirection = Vector3.zero;
		}
		else if (Object.op_Implicit((Object)(object)Rigidbody))
		{
			Vector3 velocity = Rigidbody.velocity;
			if (((Vector3)(ref velocity)).magnitude < ScaleReference * 0.1f)
			{
				DesiredMovementDirection = Vector3.zero;
				return;
			}
			velocity = Rigidbody.velocity;
			DesiredMovementDirection = ((Vector3)(ref velocity)).normalized;
		}
	}

	private void UpdateBeingRagdolled()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Leg_UpdateParams();
		}
	}

	private void Events_TriggerStepUnityEvent()
	{
		Event_OnStep.Invoke();
	}

	private void Events_OnStep(Leg leg, float stepFactor = 1f, EStepType type = EStepType.IdleGluing)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (StepEventOnLanding || !(IsGroundedBlend * RagdolledDisablerBlend < 0.99f))
		{
			Events_TriggerStepUnityEvent();
			if (_StepReceiver != null)
			{
				Vector3 position = leg._PreviousFinalIKPos + leg.BoneEnd.TransformVector((leg.AnkleToFeetEnd + leg.AnkleToHeel) * 0.5f);
				Quaternion rotation = Quaternion.LookRotation(leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.forward, leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.up);
				_StepReceiver.LegAnimatorStepEvent(leg, stepFactor, leg.Side == ELegSide.Right, position, rotation, type);
			}
		}
	}

	private void Events_OnRaise(Leg leg, float distanceToNewLegPosition = 1f, EStepType type = EStepType.IdleGluing)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if ((StepEventOnLanding || !(IsGroundedBlend * RagdolledDisablerBlend < 0.99f)) && _RaiseReceiver != null)
		{
			Vector3 position = leg._PreviousFinalIKPos + leg.BoneEnd.TransformVector((leg.AnkleToFeetEnd + leg.AnkleToHeel) * 0.5f);
			Quaternion rotation = Quaternion.LookRotation(leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.forward, leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.up);
			_RaiseReceiver.LegAnimatorRaiseEvent(leg, distanceToNewLegPosition, leg.Side == ELegSide.Right, position, rotation, type);
		}
	}

	private void ExtraControls_Update()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (IsGrounded && GroundedTime < 0.2f)
		{
			JustGrounded = true;
		}
		else
		{
			JustGrounded = false;
		}
		if (ReposeGluingAfter > 0f)
		{
			Vector3 rootOffset = MotionInfluence.rootOffset;
			if (((Vector3)(ref rootOffset)).magnitude > ScaleReference * 0.05f || IsMoving)
			{
				reposeGluingTimer = 0f;
				reposedGluing = false;
			}
			else
			{
				reposeGluingTimer += DeltaTime;
			}
			if (!reposedGluing && reposeGluingTimer > ReposeGluingAfter)
			{
				IK_TriggerReglue();
				reposedGluing = true;
			}
		}
	}

	public void DisableCustomIKRotatorVector()
	{
	}

	public void SetCustomIKRotatorVector(Vector3 localVector)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		IK_CustomIKRotatorVector = localVector;
	}

	private void InitializeModules()
	{
		bool usingControlModules = false;
		if (CustomModules == null)
		{
			return;
		}
		for (int num = CustomModules.Count - 1; num >= 0; num--)
		{
			if (CustomModules[num] == null)
			{
				CustomModules.RemoveAt(num);
			}
			else if ((Object)(object)CustomModules[num].ModuleReference == (Object)null)
			{
				CustomModules.RemoveAt(num);
			}
			else
			{
				CustomModules[num].PreparePlaymodeModule(this);
				usingControlModules = true;
			}
		}
		UsingControlModules = usingControlModules;
	}

	private void DisposeModules()
	{
		if (CustomModules == null)
		{
			return;
		}
		for (int num = CustomModules.Count - 1; num >= 0; num--)
		{
			if (CustomModules[num] == null)
			{
				CustomModules.RemoveAt(num);
			}
			else if ((Object)(object)CustomModules[num].ModuleReference == (Object)null)
			{
				CustomModules.RemoveAt(num);
			}
			else
			{
				CustomModules[num].DisposeModule();
			}
		}
	}

	public T GetModule<T>() where T : LegsAnimatorControlModuleBase
	{
		if (CustomModules == null)
		{
			return null;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].ModuleReference is T)
			{
				return CustomModules[i].PlaymodeModule as T;
			}
		}
		return null;
	}

	public LegsAnimatorCustomModuleHelper GetModuleHelper<T>() where T : LegsAnimatorControlModuleBase
	{
		if (CustomModules == null)
		{
			return null;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].ModuleReference is T)
			{
				return CustomModules[i];
			}
		}
		return null;
	}

	private void Modules_OnReInitialize()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnReInitialize(CustomModules[i]);
			}
		}
	}

	private void Modules_Update()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_UpdateAfterManualChanges()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnValidateAfterManualChanges(CustomModules[i]);
			}
		}
	}

	private void Modules_LegBeforeRaycastingUpdate(Leg leg)
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.Leg_LatePreRaycastingUpdate(CustomModules[i], leg);
			}
		}
	}

	private void Modules_AfterAnimatorCaptureUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnAfterAnimatorCaptureUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_PreLateUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnPreLateUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_LateUpdatePreApply()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnLateUpdatePreApply(CustomModules[i]);
			}
		}
	}

	private void Modules_PostLateUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnPostLateUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_Leg_LateUpdate(Leg leg)
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.Leg_LateUpdate(CustomModules[i], leg);
			}
		}
	}

	private void Hips_Calc_UpdateImpulses()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		_ImpulsesDoLocal = false;
		_ImpulsesDoWorld = false;
		_ImpulsesDoHips = false;
		if (Impulses.Count == 0)
		{
			return;
		}
		if ((double)ImpulsesDurationMultiplier < 0.001)
		{
			ImpulsesDurationMultiplier = 1f;
		}
		_ImpulsesWorldPush = Vector3.zero;
		_ImpulsesWorldPushInherit = Vector3.zero;
		_ImpulsesLocalPush = Vector3.zero;
		_ImpulsesLocalPushInherit = Vector3.zero;
		_ImpulsesHipsRotation = Vector3.zero;
		Vector3 val = DesiredMovementDirection;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < Impulses.Count; i++)
		{
			ImpulseExecutor value = Impulses[i];
			value.Update(DeltaTime / ImpulsesDurationMultiplier);
			if (value.WorldTranslation != Vector3.zero)
			{
				Vector3 val2 = value.CurrentWorldOffset * ImpulsesPowerMultiplier;
				if (value.Elastic <= 0f)
				{
					_ImpulsesWorldPush += val2;
				}
				else if (value.Elastic >= 1f)
				{
					_ImpulsesWorldPushInherit += val2;
				}
				else
				{
					_ImpulsesWorldPush += (1f - value.Elastic) * val2;
					_ImpulsesWorldPushInherit += value.Elastic * val2;
				}
			}
			if (value.LocalTranslation != Vector3.zero)
			{
				Vector3 val3 = value.CurrentLocalOffset * (ImpulsesPowerMultiplier * ScaleReferenceNoScale);
				val3.y *= value.CurrentLocalYAxisMultiplier;
				bool flag = true;
				if (value.AlignDesired && DesiredMovementDirection != Vector3.zero)
				{
					flag = false;
					Quaternion rotation = BaseTransform.rotation;
					val = BaseTransform.forward;
					val3 = rotation * Quaternion.FromToRotation(((Vector3)(ref val)).normalized, normalized) * val3;
					if (value.Elastic <= 0f)
					{
						_ImpulsesWorldPush += val3;
					}
					else if (value.Elastic >= 1f)
					{
						_ImpulsesWorldPushInherit += val3;
					}
					else
					{
						_ImpulsesWorldPush += (1f - value.Elastic) * val3;
						_ImpulsesWorldPushInherit += value.Elastic * val3;
					}
				}
				if (flag)
				{
					if (value.Elastic <= 0f)
					{
						_ImpulsesLocalPush += val3;
					}
					else if (value.Elastic >= 1f)
					{
						_ImpulsesLocalPushInherit += val3;
					}
					else
					{
						_ImpulsesLocalPush += (1f - value.Elastic) * val3;
						_ImpulsesLocalPushInherit += value.Elastic * val3;
					}
				}
			}
			if (value.HipsRotation != Vector3.zero)
			{
				Vector3 hipsRotation = value.HipsRotation;
				if (value.AlignDesired)
				{
					val = BaseTransform.forward;
					if (Vector3.Dot(((Vector3)(ref val)).normalized, normalized) < 0f)
					{
						hipsRotation.z = 0f - hipsRotation.z;
					}
				}
				_ImpulsesHipsRotation += hipsRotation * (ImpulsesPowerMultiplier * value.Evaluation * value.Power);
			}
			Impulses[i] = value;
		}
		for (int num = Impulses.Count - 1; num >= 0; num--)
		{
			if (Impulses[num].Finished)
			{
				Impulses.RemoveAt(num);
			}
		}
		if (_ImpulsesWorldPush != Vector3.zero || _ImpulsesWorldPushInherit != Vector3.zero)
		{
			_ImpulsesDoWorld = true;
		}
		if (_ImpulsesLocalPush != Vector3.zero || _ImpulsesLocalPushInherit != Vector3.zero)
		{
			_ImpulsesDoLocal = true;
		}
		if (_ImpulsesHipsRotation != Vector3.zero)
		{
			_ImpulsesDoHips = true;
		}
	}

	private void Hips_Calc_ApplyImpulsesInherit()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (_ImpulsesDoLocal)
		{
			_Hips_StabilityLocalOffset += _ImpulsesLocalPushInherit * _MainBlend;
		}
		if (_ImpulsesDoWorld)
		{
			_Hips_StabilityLocalOffset += ToRootLocalSpaceVec(_ImpulsesWorldPushInherit * _MainBlend);
		}
		if (_ImpulsesDoHips || _ImpulsesRotationElastic != Vector3.zero)
		{
			_Hips_RotationMuscle.Update(DeltaTime, _ImpulsesHipsRotation);
			_ImpulsesRotationElastic = _Hips_RotationMuscle.ProceduralEulerAngles;
			_Hips_Modules_ExtraRotOffset += _ImpulsesRotationElastic;
		}
	}

	private void Hips_Calc_ApplyImpulses()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (_ImpulsesDoLocal)
		{
			_LastAppliedHipsFinalPosition += RootToWorldSpaceVec(_ImpulsesLocalPush * _MainBlend);
		}
		if (_ImpulsesDoWorld)
		{
			_LastAppliedHipsFinalPosition += _ImpulsesWorldPush * _MainBlend;
		}
	}

	public float GetLandingBoost()
	{
		float result = HipsHeightStepSpeed;
		if (IsGrounded && GroundedTime < 0.2f)
		{
			result = Mathf.Max(HipsHeightStepSpeed, Mathf.LerpUnclamped(HipsHeightStepSpeed, 0.95f, 0.9f));
		}
		return result;
	}

	private void Hips_Calc_BodyAdjust()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (HipsHeightStepBlend <= 0f)
		{
			return;
		}
		float num = HipsSetup.CalculateBodyAdjust();
		Vector3 val = Vector3.zero;
		if (num != 0f && !float.IsNaN(num))
		{
			val = Up * num;
			Transform hips = Hips;
			hips.position += val;
		}
		if (!_hipsHubs_using || HipsHubsBlend < 0.0001f)
		{
			return;
		}
		for (int i = 0; i < HipsHubs.Count; i++)
		{
			HipsHubs[i]._PreHipsAdjustPosition = HipsHubs[i].bone.position;
			float num2 = HipsHubs[i].CalculateBodyAdjust();
			if (num2 != 0f && !float.IsNaN(num2))
			{
				Vector3 val2 = Up * num2;
				val2 -= val;
				Transform bone = HipsHubs[i].bone;
				bone.position += val2;
			}
		}
	}

	public void Hips_PreLateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			HipsSetup.Calibrate();
			HipsHubs_CaptureAnimation();
		}
	}

	public void Hips_LateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			Hips_Calc_BodyAdjust();
		}
	}

	public void Hips_PostLateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			Hips_Calc_Stabilize();
			Hips_Calc_UpdateImpulses();
			Hips_Calc_ApplyImpulsesInherit();
			Hips_Calc_Elasticity();
			Hips_Calc_Apply();
			Hips_Calc_ApplyImpulses();
			Hips_ApplyTransformations();
		}
	}

	protected virtual void Hips_ApplyTransformations()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		if (float.IsNaN(_LastAppliedHipsFinalPosition.x) || float.IsNaN(_LastAppliedHipsFinalPosition.y) || float.IsNaN(_LastAppliedHipsFinalPosition.z))
		{
			_LastAppliedHipsFinalPosition = RootToWorldSpace(HipsSetup.InitHipsPositionRootSpace);
			if (float.IsNaN(_LastAppliedHipsFinalPosition.x) || float.IsNaN(_LastAppliedHipsFinalPosition.y) || float.IsNaN(_LastAppliedHipsFinalPosition.z))
			{
				_LastAppliedHipsFinalPosition = Vector3.zero;
			}
		}
		if (_Hips_Modules_ExtraRotOffset != Vector3.zero)
		{
			float num = _MainBlend * ImpulsesPowerMultiplier;
			Vector3 hips_Modules_ExtraRotOffset = _Hips_Modules_ExtraRotOffset;
			Quaternion val = Quaternion.identity;
			if (hips_Modules_ExtraRotOffset.z != 0f)
			{
				val *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.z * num, BaseTransform.right);
			}
			if (hips_Modules_ExtraRotOffset.x != 0f)
			{
				val *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.x * num, BaseTransform.forward);
			}
			if (hips_Modules_ExtraRotOffset.y != 0f)
			{
				val *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.y * num, BaseTransform.up);
			}
			_LastAppliedHipsFinalRotationOffset = val;
			Quaternion val2 = val * Hips.rotation;
			Hips.SetPositionAndRotation(_LastAppliedHipsFinalPosition, val2);
		}
		else
		{
			Hips.position = _LastAppliedHipsFinalPosition;
		}
		_LastAppliedHipsFinalOffset = _LastAppliedHipsFinalPosition - HipsSetup.LastKeyframePosition;
		HipsHubs_ApplyTransformations();
		Hips_Finalize();
	}

	protected virtual void Hips_Finalize()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		_LastHipsRotationOffsetOutsideInfo = Quaternion.identity;
	}

	private void Hips_Calc_Apply()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		_LastAppliedHipsFinalOffset = Vector3.zero;
		_LastAppliedHipsFinalRotationOffset = Quaternion.identity;
		_LastAppliedHipsFinalPosition = Hips.position;
		_LastAppliedHipsStabilityOffset = _Hips_FinalStabilityOffset * _MainBlendPlusGrounded * HipsAdjustingBlend;
		_LastAppliedHipsFinalPosition += _LastAppliedHipsStabilityOffset;
		_LastAppliedHipsFinalPosition += _Hips_Modules_ExtraWOffset;
		_Hips_Modules_ExtraWOffset = Vector3.zero;
	}

	protected void Hips_PreCalibrate()
	{
		_updateHipsAdjustements = true;
		HipsSetup.PreCalibrate();
		if (Calibrate != 0 && (Object)(object)SpineBone != (Object)null)
		{
			if ((Object)(object)_spineBoneCalibrate.Transform == (Object)null)
			{
				_spineBoneCalibrate = new CalibrateTransform(SpineBone);
			}
			_spineBoneCalibrate.Calibrate();
			if ((Object)(object)ChestBone != (Object)null)
			{
				if ((Object)(object)_ChestBoneCalibrate.Transform == (Object)null)
				{
					_ChestBoneCalibrate = new CalibrateTransform(ChestBone);
				}
				_ChestBoneCalibrate.Calibrate();
			}
		}
		Hips_Calc_PreRefreshVariables();
		HipsHubs_PreCalibrate();
	}

	private void Hips_Calc_Elasticity()
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (HipsSetup.HipsElasticityBlend > 0f)
		{
			Vector3 val = HipsSetup.HipsMuscle.Update(DeltaTime, _Hips_StabilityLocalOffset);
			if (val.y > 0f)
			{
				val.y *= 1f - ImpulsesDampUpPushes;
			}
			if (HipsSetup.HipsElasticityBlend < 1f)
			{
				_Hips_FinalStabilityOffset = Vector3.LerpUnclamped(_Hips_StabilityLocalOffset, val, HipsSetup.HipsElasticityBlend);
			}
			else
			{
				_Hips_FinalStabilityOffset = val;
			}
		}
		else
		{
			_Hips_FinalStabilityOffset = _Hips_StabilityLocalOffset;
		}
		_Hips_FinalStabilityOffset = RootToWorldSpaceVec(_Hips_FinalStabilityOffset);
	}

	private void HipsHubs_Init()
	{
		_hipsHubs_using = false;
		HipsHubs = new List<HipsReference>();
		for (int i = 0; i < ExtraHipsHubs.Count; i++)
		{
			if (!((Object)(object)ExtraHipsHubs[i] == (Object)null))
			{
				HipsReference hipsReference = new HipsReference();
				hipsReference.Initialize(this, ExtraHipsHubs[i], BaseTransform);
				hipsReference.CopyMuscleSettingsFrom(HipsSetup);
				HipsHubs.Add(hipsReference);
			}
		}
		if (ExtraHipsHubs.Count > 0)
		{
			_hipsHubs_using = true;
		}
		HipsSetup.PrepareLegs();
		for (int j = 0; j < HipsHubs.Count; j++)
		{
			HipsHubs[j].PrepareHubBones();
		}
	}

	private void HipsHubs_PreCalibrate()
	{
		if (_hipsHubs_using)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs[i].PreCalibrate();
			}
		}
	}

	private void HipsHubs_CaptureAnimation()
	{
		if (_hipsHubs_using)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs[i].Calibrate();
			}
		}
	}

	private void HipsHubs_ApplyTransformations()
	{
		if (!_hipsHubs_using)
		{
			return;
		}
		if (HipsHubsHandling == EHipsHubsHandling.FixDisconnected)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs_ApplyBasic(HipsHubs[i]);
			}
		}
		else
		{
			for (int j = 0; j < HipsHubs.Count; j++)
			{
				HipsHubs_ApplyDetailed(HipsHubs[j]);
			}
		}
	}

	private void HipsHubs_ApplyBasic(HipsReference hub)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Transform bone = hub.bone;
		bone.position += _LastAppliedHipsFinalOffset * HipsHubsBlend;
		Quaternion val = _LastAppliedHipsFinalRotationOffset * _LastHipsRotationOffsetOutsideInfo * hub.bone.rotation;
		if (HipsHubsBlend > 0.999f)
		{
			hub.bone.rotation = val;
		}
		else
		{
			hub.bone.rotation = Quaternion.Lerp(hub.bone.rotation, val, HipsHubsBlend);
		}
	}

	private void HipsHubs_ApplyDetailed(HipsReference hub)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		if (HipsHubsBlend < 0.0001f)
		{
			return;
		}
		float num = HipsHubsBlend * _MainBlend * IsGroundedBlend;
		float num2 = Mathf.LerpUnclamped(1f, StabilizeOnIsMoving, IsMovingBlend);
		Vector3 zero = Vector3.zero;
		zero += hub.CalculateCenterOfMassStability(num2);
		Vector3 pushLocalOffset = hub.CalculateGlueMovePush() * PushHipsOnLegMove;
		pushLocalOffset = hub.SmoothPushOffset(pushLocalOffset, Mathf.LerpUnclamped(0.125f, 0.025f, PushReactionSpeed));
		zero += _MainBlendPlusGrounded * RootToWorldSpaceVec(pushLocalOffset);
		Vector3 val = hub.CalculateStretchPreventerOffset();
		zero += _MainBlendPlusGrounded * val * HipsStretchPreventer * num2;
		zero = hub.AnimateOffset(zero);
		hub.HipsMuscle.Update(DeltaTime, zero);
		zero = hub.HipsMuscle.ProceduralPosition;
		zero += hub.ExtraNonElasticOffset;
		hub.ExtraNonElasticOffset = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		if (HipsSetup._Hips_LastHipsOffset > 0f)
		{
			zero2.y -= HipsSetup._Hips_LastHipsOffset * 0.1f;
		}
		if (hub._Hips_LastHipsOffset < 0f)
		{
			zero2.y += hub._Hips_LastHipsOffset * 0.1f;
		}
		Vector3 val2 = hub.CalculateStretchReadjust();
		Vector3 val3 = RootToWorldSpaceVec(zero + zero2 + val2);
		Vector3 val4 = hub.bone.position + val3;
		hub.bone.localPosition = hub.LastKeyframeLocalPosition;
		Transform bone = hub.bone;
		bone.position += RootToWorldSpaceVec(zero2);
		Quaternion rotation = hub.bone.rotation;
		float num3 = 1f;
		if (num3 > 0f && hub.HubBackBones.Count > 0)
		{
			float num4 = (float)hub.HubBackBones.Count - 1f;
			if (num4 == 0f)
			{
				num4 = 1f;
			}
			float num5 = 0f;
			for (int num6 = hub.HubBackBones.Count - 1; num6 >= 0; num6--)
			{
				HipsReference.HipsHubBackbone hipsHubBackbone = hub.HubBackBones[num6];
				Vector3 val5 = hipsHubBackbone.frontBone.position - hipsHubBackbone.bone.position;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				val5 = val4 - hipsHubBackbone.bone.position;
				Vector3 val6 = ((Vector3)(ref val5)).normalized;
				float num7 = Vector3.Dot(normalized, val6);
				float num8 = 0f;
				if (num7 < 0.985f)
				{
					Vector3 val7 = ToRootLocalSpaceVec(normalized);
					Vector3 val8 = ToRootLocalSpaceVec(val6);
					val7.y = 0f;
					val8.y = 0f;
					float num9 = Vector3.Dot(((Vector3)(ref val7)).normalized, ((Vector3)(ref val8)).normalized);
					num8 = Mathf.InverseLerp(0.985f, 0.5f, num9);
					val6 = Vector3.Slerp(val6, normalized, num8);
				}
				val6 = hipsHubBackbone.AnimateTargetDirection(val6);
				Vector3 val9 = Vector3.LerpUnclamped(normalized, val6, num3 * num / num4 * HubsBackBonesBlend.Evaluate(num5 / num4) * (1f - num8));
				Quaternion val10 = Quaternion.FromToRotation(normalized, val9);
				hipsHubBackbone.bone.rotation = val10 * hipsHubBackbone.bone.rotation;
				num5 += 1f;
			}
		}
		Quaternion val11 = Quaternion.Inverse(hub._LastHipsRotationOffsetOutsideInfo);
		hub.bone.rotation = val11 * Quaternion.SlerpUnclamped(hub.bone.rotation, rotation, 0.75f * HipsHubsBlend);
		hub._LastHipsRotationOffsetOutsideInfo = Quaternion.identity;
	}

	private void Initialize_Stability()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_Hips_RotationMuscle = new FMuscle_Eulers();
		_Hips_RotationMuscle.Initialize(Vector3.zero);
	}

	private void Hips_Calc_PreRefreshVariables()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_Hips_StabilityLocalOffset = Vector3.zero;
		_Hips_Modules_ExtraRotOffset = Vector3.zero;
	}

	private void Hips_Calc_Stabilize()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		float mainBlendPlusGrounded = _MainBlendPlusGrounded;
		float num = Mathf.LerpUnclamped(1f, StabilizeOnIsMoving, IsMovingBlend);
		HipsSetup.CalculateCenterOfMassStability(num);
		float pushDuration = 0f;
		if (PushReactionSpeed < 1f)
		{
			pushDuration = Mathf.LerpUnclamped(0.125f, 0.025f, PushReactionSpeed);
		}
		Vector3 pushLocalOffset = HipsSetup.CalculateGlueMovePush();
		Vector3 val = HipsSetup.SmoothPushOffset(pushLocalOffset, pushDuration);
		if (HipsStretchPreventer > 0f)
		{
			Vector3 val2 = HipsSetup.CalculateStretchPreventerOffset();
			_Hips_StabilityLocalOffset += _MainBlendPlusGrounded * val2 * HipsStretchPreventer * num;
		}
		if (MotionInfluence.AdvancedInfluence || MotionInfluence.AxisMotionInfluence.x > 0f)
		{
			_Hips_StabilityLocalOffset += MotionInfluence.CalculateInversedInfluence();
		}
		_Hips_StabilityLocalOffset += _Get_Hips_StabilityLocalAdjustement;
		_Hips_StabilityLocalOffset += val * PushHipsOnLegMove;
		if (ExtraPelvisOffset != Vector3.zero && IsGroundedBlend > 0f)
		{
			Transform hips = Hips;
			hips.position += RootToWorldSpaceVec(ExtraPelvisOffset * mainBlendPlusGrounded);
		}
	}

	private void ValueTowards(ref Vector3 value, Vector3 target, ref Vector3 sd, float duration)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ValueTowards(ref value, target, ref sd, duration, DeltaTime);
	}

	private void ValueTowards(ref Vector3 value, Vector3 target, ref Vector3 sd, float duration, float delta)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (duration < 1f)
		{
			value = Vector3.SmoothDamp(value, target, ref sd, duration, 10000000f, delta);
		}
		else
		{
			value = target;
		}
	}

	public Leg Setup_TryAutoLegSetup(Leg scheme, Transform toSetup, bool apply = true)
	{
		if (scheme == null)
		{
			return null;
		}
		if ((Object)(object)toSetup == (Object)null)
		{
			return null;
		}
		Transform bottomMostChildTransform = SkeletonRecognize.GetBottomMostChildTransform(scheme.BoneStart);
		int depth = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneStart);
		Transform bottomMostChildTransform2 = SkeletonRecognize.GetBottomMostChildTransform(toSetup);
		int depth2 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform2, toSetup);
		if ((Object)(object)bottomMostChildTransform2 == (Object)null)
		{
			return null;
		}
		if ((Object)(object)bottomMostChildTransform == (Object)null)
		{
			return null;
		}
		if (depth2 != depth)
		{
			return null;
		}
		if (depth == 0)
		{
			return null;
		}
		if (depth2 == 0)
		{
			return null;
		}
		int depth3 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneEnd);
		Transform val = bottomMostChildTransform2;
		for (int i = 0; i < depth3; i++)
		{
			if ((Object)(object)val.parent == (Object)null)
			{
				return null;
			}
			val = val.parent;
		}
		depth3 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneMid);
		Transform val2 = bottomMostChildTransform2;
		for (int j = 0; j < depth3; j++)
		{
			if ((Object)(object)val.parent == (Object)null)
			{
				return null;
			}
			val2 = val2.parent;
		}
		if ((Object)(object)toSetup == (Object)(object)val2)
		{
			return null;
		}
		if ((Object)(object)toSetup == (Object)(object)val)
		{
			return null;
		}
		if ((Object)(object)val2 == (Object)(object)val)
		{
			return null;
		}
		float num = scheme.LegLimbLength();
		Leg leg = new Leg();
		leg.BoneStart = toSetup;
		leg.BoneMid = val2;
		leg.BoneEnd = val;
		leg.Owner = this;
		if (leg.LegLimbLength() < num * 0.2f)
		{
			return null;
		}
		bool flag = true;
		for (int k = 0; k < Legs.Count; k++)
		{
			if ((Object)(object)Legs[k].BoneStart == (Object)(object)leg.BoneStart)
			{
				flag = false;
				break;
			}
			if ((Object)(object)Legs[k].BoneStart == (Object)(object)leg.BoneMid)
			{
				flag = false;
				break;
			}
			if ((Object)(object)Legs[k].BoneMid == (Object)(object)leg.BoneStart)
			{
				flag = false;
				break;
			}
			if ((Object)(object)Legs[k].BoneMid == (Object)(object)leg.BoneMid)
			{
				flag = false;
				break;
			}
		}
		if (!flag)
		{
			return null;
		}
		if (apply)
		{
			Legs.Add(leg);
			leg.DefineLegSide(this);
			leg.RefreshLegAnkleToHeelAndFeetAndAxes(BaseTransform);
		}
		return leg;
	}

	public void Setup_TryAutoLegsSetup(Leg scheme, Transform parentOfLegs)
	{
		if (!((Object)(object)parentOfLegs == (Object)null))
		{
			for (int i = 0; i < parentOfLegs.childCount; i++)
			{
				Setup_TryAutoLegSetup(scheme, parentOfLegs.GetChild(i));
			}
		}
	}

	public void Legs_AddNewLeg()
	{
		Leg leg = new Leg();
		leg.Owner = this;
		Legs.Add(leg);
	}

	public void Legs_RefreshLegsOwner()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Owner = this;
		}
	}

	public int Leg_GetIndex(Leg leg)
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			if (leg == Legs[i])
			{
				return i;
			}
		}
		return -1;
	}

	public Leg Leg_GetLeg(int index)
	{
		if (index < 0)
		{
			return null;
		}
		if (index >= Legs.Count)
		{
			return null;
		}
		return Legs[index];
	}

	protected virtual void Finder_EnsureLegsCount(int legsCount)
	{
		for (int i = 0; i < legsCount; i++)
		{
			if (Legs.Count <= i)
			{
				Legs_AddNewLeg();
			}
		}
	}

	public virtual void Finder_AutoFindLegsIfHuman(Animator anim)
	{
		if (Object.op_Implicit((Object)(object)anim) && anim.isHuman)
		{
			Finder_EnsureLegsCount(2);
			if ((Object)(object)Legs[0].BoneStart == (Object)null)
			{
				Legs[0].BoneStart = anim.GetBoneTransform((HumanBodyBones)1);
				Legs[0].Side = ELegSide.Left;
			}
			if ((Object)(object)Legs[0].BoneMid == (Object)null)
			{
				Legs[0].BoneMid = anim.GetBoneTransform((HumanBodyBones)3);
			}
			if ((Object)(object)Legs[0].BoneEnd == (Object)null)
			{
				Legs[0].BoneEnd = anim.GetBoneTransform((HumanBodyBones)5);
			}
			if ((Object)(object)Legs[1].BoneStart == (Object)null)
			{
				Legs[1].BoneStart = anim.GetBoneTransform((HumanBodyBones)2);
				Legs[1].Side = ELegSide.Right;
			}
			if ((Object)(object)Legs[1].BoneMid == (Object)null)
			{
				Legs[1].BoneMid = anim.GetBoneTransform((HumanBodyBones)4);
			}
			if ((Object)(object)Legs[1].BoneEnd == (Object)null)
			{
				Legs[1].BoneEnd = anim.GetBoneTransform((HumanBodyBones)6);
			}
			if (Legs[0].OppositeLegIndex < 0)
			{
				Legs[1].AssignOppositeLegIndex(0);
			}
			if (Legs[0].Side == ELegSide.Undefined)
			{
				Legs[0].Side = ELegSide.Left;
			}
			if (Legs[1].Side == ELegSide.Undefined)
			{
				Legs[1].Side = ELegSide.Right;
			}
			if ((Object)(object)SpineBone == (Object)null)
			{
				SpineBone = anim.GetBoneTransform((HumanBodyBones)7);
			}
			Finders_RefreshAllLegsAnkleAxes();
			User_RefreshHelperVariablesOnParametersChange();
		}
	}

	public Animator Finding_TryFindMecanim()
	{
		if (!Object.op_Implicit((Object)(object)Mecanim))
		{
			Mecanim = FTransformMethods.FindComponentInAllChildren<Animator>(BaseTransform);
			if (!Object.op_Implicit((Object)(object)Mecanim))
			{
				Mecanim = ((Component)BaseTransform).GetComponentInParent<Animator>();
			}
		}
		return Mecanim;
	}

	public virtual void Finder_AutoDefineOppositeLegs()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < Legs.Count; i++)
		{
			if ((Object)(object)Legs[i].BoneEnd == (Object)null)
			{
				return;
			}
			list.Add(BaseTransform.InverseTransformPoint(Legs[i].BoneEnd.position));
		}
		for (int j = 0; j < Legs.Count; j++)
		{
			if (Legs[j].OppositeLegIndex > -1)
			{
				continue;
			}
			int num = -1;
			float num2 = float.MaxValue;
			for (int k = 0; k < Legs.Count; k++)
			{
				if (j == k || Mathf.Sign(list[j].x) == Mathf.Sign(list[k].x))
				{
					continue;
				}
				float num3 = Mathf.Abs(list[j].z - list[k].z);
				if (Legs[k].Side == ELegSide.Undefined)
				{
					if (list[k].x < 0f)
					{
						Legs[k].Side = ELegSide.Left;
					}
					else
					{
						Legs[k].Side = ELegSide.Right;
					}
				}
				if (num3 < num2)
				{
					num2 = num3;
					num = k;
				}
			}
			if (num != -1)
			{
				Legs[j].AssignOppositeLegIndex(num);
			}
		}
	}

	public virtual void Finding_LegBonesByNamesAndParenting()
	{
		Finding_TryFindMecanim();
		if (Legs == null)
		{
			Legs = new List<Leg>();
		}
		if (Object.op_Implicit((Object)(object)Mecanim) && Mecanim.isHuman)
		{
			Finder_AutoFindLegsIfHuman(Mecanim);
		}
		else if (Legs.Count < 2)
		{
			Finder_EnsureLegsCount(2);
		}
	}

	public virtual void Finding_SearchForHips()
	{
		if (!Object.op_Implicit((Object)(object)Hips))
		{
			Finding_TryFindMecanim();
			if (Object.op_Implicit((Object)(object)Mecanim) && Mecanim.isHuman)
			{
				Hips = Mecanim.GetBoneTransform((HumanBodyBones)0);
			}
		}
	}

	public Transform Finders_QuickHipsSearch()
	{
		Transform val = BaseTransform;
		Animator val2 = FTransformMethods.FindComponentInAllChildren<Animator>(val);
		if (Object.op_Implicit((Object)(object)val2) && val2.isHuman)
		{
			Finder_AutoFindLegsIfHuman(val2);
			return val2.GetBoneTransform((HumanBodyBones)0);
		}
		Transform val3 = FTransformMethods.FindChildByNameInDepth("pelv", val);
		if (Object.op_Implicit((Object)(object)val3))
		{
			SkinnedMeshRenderer componentInChildren = ((Component)val).GetComponentInChildren<SkinnedMeshRenderer>();
			if (!Object.op_Implicit((Object)(object)componentInChildren))
			{
				return val3;
			}
			if ((Object)(object)val3 == (Object)(object)componentInChildren.rootBone || componentInChildren.bones.Contains(val3) || val3.childCount >= 3)
			{
				return val3;
			}
		}
		val3 = FTransformMethods.FindChildByNameInDepth("hips", val);
		if (Object.op_Implicit((Object)(object)val3))
		{
			if (val3.childCount >= 3)
			{
				return val3;
			}
			if ((Object)(object)val3.parent != (Object)null)
			{
				val3 = val3.parent;
				if (val3.childCount >= 3)
				{
					return val3;
				}
				if ((Object)(object)val3.parent != (Object)null)
				{
					val3 = val3.parent;
					if (val3.childCount >= 3)
					{
						return val3;
					}
				}
			}
		}
		return null;
	}

	private void Finding_UpperLegsWithPelvis()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)Hips))
		{
			return;
		}
		Finder_EnsureLegsCount(2);
		Leg leg = Legs[0];
		Leg leg2 = Legs[1];
		if (Legs[0].Side == ELegSide.Right)
		{
			leg = Legs[1];
			leg2 = Legs[0];
		}
		if (leg == null)
		{
			return;
		}
		if ((Object)(object)leg.BoneStart == (Object)null)
		{
			Transform val = null;
			Vector3 val2 = BaseTransform.InverseTransformPoint(Hips.position);
			for (int i = 0; i < Hips.childCount; i++)
			{
				if (Object.op_Implicit((Object)(object)val))
				{
					break;
				}
				Vector3 val3 = BaseTransform.InverseTransformPoint(Hips.GetChild(i).position);
				if (val3.x < val2.x && val3.y < val2.y)
				{
					val = Hips.GetChild(i);
				}
			}
			leg.BoneStart = val;
		}
		if (leg2 == null || !((Object)(object)leg2.BoneStart == (Object)null))
		{
			return;
		}
		Transform val4 = null;
		Vector3 val5 = BaseTransform.InverseTransformPoint(Hips.position);
		for (int j = 0; j < Hips.childCount; j++)
		{
			if (Object.op_Implicit((Object)(object)val4))
			{
				break;
			}
			Vector3 val6 = BaseTransform.InverseTransformPoint(Hips.GetChild(j).position);
			if (val6.x > val5.x && val6.y < val5.y)
			{
				val4 = Hips.GetChild(j);
			}
		}
		leg2.BoneStart = val4;
	}

	private Transform Finding_FindUpperLeg(Transform foot)
	{
		Transform result = null;
		if (!Object.op_Implicit((Object)(object)Hips))
		{
			Transform val = null;
			Transform parent = foot.parent;
			if (Object.op_Implicit((Object)(object)parent) && Object.op_Implicit((Object)(object)parent.parent))
			{
				parent = parent.parent;
				if (Object.op_Implicit((Object)(object)parent))
				{
					if (parent.childCount > 2)
					{
						val = parent;
					}
					if (!Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)parent.parent))
					{
						parent = parent.parent;
						if (parent.childCount > 2)
						{
							val = parent;
						}
						if (!Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)parent.parent))
						{
							parent = parent.parent;
							if (parent.childCount > 2)
							{
								val = parent;
							}
							if (!Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)parent.parent))
							{
								parent = parent.parent;
								if (parent.childCount > 2)
								{
									val = parent;
								}
							}
						}
					}
				}
			}
			result = parent;
			if (Object.op_Implicit((Object)(object)val))
			{
				Hips = val;
			}
		}
		return result;
	}

	private void Finding_FindLowerLegsWithUpper()
	{
		Finder_EnsureLegsCount(2);
		Leg leg = Legs[0];
		Leg leg2 = Legs[1];
		if (Legs[0].Side == ELegSide.Right)
		{
			leg = Legs[1];
			leg2 = Legs[0];
		}
		if ((Object)(object)leg.BoneStart != (Object)null)
		{
			if (leg.BoneStart.childCount > 0 && !Object.op_Implicit((Object)(object)leg.BoneMid))
			{
				leg.BoneMid = Finders_GetRelevantChildOf(leg.BoneStart);
			}
			if (Object.op_Implicit((Object)(object)leg.BoneMid) && leg.BoneMid.childCount > 0 && (Object)(object)leg.BoneEnd == (Object)null)
			{
				leg.BoneEnd = Finders_GetRelevantChildOf(leg.BoneMid);
			}
		}
		if ((Object)(object)leg2.BoneStart != (Object)null)
		{
			if (leg2.BoneStart.childCount > 0 && !Object.op_Implicit((Object)(object)leg2.BoneMid))
			{
				leg2.BoneMid = Finders_GetRelevantChildOf(leg2.BoneStart);
			}
			if (Object.op_Implicit((Object)(object)leg2.BoneMid) && leg2.BoneMid.childCount > 0 && (Object)(object)leg2.BoneEnd == (Object)null)
			{
				leg2.BoneEnd = Finders_GetRelevantChildOf(leg2.BoneMid);
			}
		}
	}

	public Transform Finders_GetRelevantChildOf(Transform parent)
	{
		Transform val = null;
		for (int i = 0; i < parent.childCount; i++)
		{
			Transform child = parent.GetChild(i);
			if ((Object)(object)val == (Object)null)
			{
				val = child;
			}
			else if (child.childCount > val.childCount)
			{
				val = child;
			}
		}
		return val;
	}

	protected static bool? Finders_IsRightOrLeft(Transform child, Transform itsRoot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = itsRoot.InverseTransformPoint(child.position);
		if (val.x < 0f)
		{
			return false;
		}
		if (val.x > 0f)
		{
			return true;
		}
		return null;
	}

	public void Finders_RefreshAllLegsAnkleAxes()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].RefreshLegAnkleToHeelAndFeetAndAxes(BaseTransform);
		}
	}

	protected virtual void CustomIK_Initialize()
	{
	}

	protected virtual void CustomIK_ApplyIK()
	{
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private void MeasurePerformanceUpdate(bool start)
	{
	}

	private void MeasurePerformancePreLateUpdate(bool start)
	{
	}

	private void MeasurePerformanceMain(bool start)
	{
	}

	protected virtual void Initialize()
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Invalid comparison between Unknown and I4
		if (LegsInitialized)
		{
			return;
		}
		ReferencePose referencePose = null;
		if (SetupPose != null && SetupPose.IsSet(this))
		{
			referencePose = new ReferencePose();
			StoreSetupPose(referencePose);
			RestoreSetupPose(SetupPose);
		}
		GroundedTime = 0f;
		MovingTime = 0f;
		IsMovingBlend = 0f;
		IsGroundedBlend = 1f;
		RagdolledDisablerBlend = 1f;
		_MainBlendNoRagdolling = 1f;
		DeltaTime = 0.05f;
		usingCustomDesiredMovementDirection = false;
		RagdolledDisablerBlend = 1f;
		RagdolledTime = -100f;
		DoBackCompatibilityChecks();
		Initialize_BaseTransform();
		RefreshMatrices();
		_wasInstantTriggered = true;
		Legs_RefreshLegsOwner();
		User_RefreshHelperVariablesOnParametersChange();
		Controll_DefineHashes();
		Initialize_Stability();
		finalScaleReferenceSqrt = ScaleReference * ScaleReference;
		HipsSetup.Initialize(this, Hips, BaseTransform);
		_LastAppliedHipsFinalPosition = Hips.position;
		HipsHubs_Init();
		if (CheckIfSomeOfTheLegsHasNullBone())
		{
			Debug.LogError((object)("[Legs Animator] One of the legs has unassigned bone! (" + ((Object)this).name + ")"));
			AllowUpdate = false;
			LegsInitialized = false;
			return;
		}
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].InitLegBasics(this, i, (i + 1 < Legs.Count) ? Legs[i + 1] : null);
		}
		IK_Initialize();
		LegsInitialized = true;
		AllowUpdate = true;
		InitializeGetStepInfoReceiver();
		if (Object.op_Implicit((Object)(object)Mecanim))
		{
			AnimatePhysics = (int)Mecanim.updateMode == 1;
		}
		InitializeModules();
		PrepareValues(Time.deltaTime);
		User_UpdateParametersAfterManualChange();
		User_RefreshHelperVariablesOnParametersChange();
		if (referencePose != null)
		{
			RestoreSetupPose(referencePose);
		}
	}

	public void InitializeGetStepInfoReceiver()
	{
		if ((Object)(object)StepInfoReceiver != (Object)null)
		{
			_StepReceiver = ((Component)StepInfoReceiver).GetComponent<ILegStepReceiver>();
			_RaiseReceiver = ((Component)StepInfoReceiver).GetComponent<ILegRaiseReceiver>();
		}
	}

	public void Initialize_BaseTransform()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)baseTransform == (Object)null)
		{
			baseTransform = ((Component)this).transform;
		}
		InitialBaseScale = baseTransform.lossyScale;
		if (InitialBaseScale.y == 0f)
		{
			InitialBaseScale = Vector3.one;
		}
		User_RefreshHelperVariablesOnParametersChange();
		MotionInfluence_Init();
	}

	public void Initialize_BaseTransform(Transform newTransform)
	{
		baseTransform = newTransform;
		Initialize_BaseTransform();
	}

	public bool IsSetupValid()
	{
		if (Legs.Count == 0)
		{
			return false;
		}
		if ((Object)(object)Hips == (Object)null)
		{
			return false;
		}
		bool result = true;
		for (int i = 0; i < Legs.Count; i++)
		{
			if ((Object)(object)Legs[i].BoneStart == (Object)null)
			{
				result = false;
				break;
			}
			if ((Object)(object)Legs[i].BoneEnd == (Object)null)
			{
				result = false;
				break;
			}
		}
		return result;
	}

	protected virtual void OnLegsReactivate()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		RefreshMatrices();
		MotionInfluence.Reset();
		Modules_OnReInitialize();
		HipsSetup.HipsMuscle.OverrideProceduralPosition(Vector3.zero);
		HipsSetup.HipsRotMuscle.OverrideProceduralRotation(Quaternion.identity);
		_LastAppliedHipsStabilityOffset = Vector3.zero;
		_LastAppliedHipsFinalPosition = Hips.position;
		_Hips_StabilityLocalOffset = Vector3.zero;
		_Hips_FinalStabilityOffset = Vector3.zero;
		HipsSetup.Reset();
		_glueModeExecuted = EGlueMode.Moving;
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Reset();
		}
	}

	public void StoreSetupPose()
	{
		StoreSetupPose(setupPose);
	}

	public void StoreSetupPose(ReferencePose referencePose)
	{
		referencePose.TweakListsFor(this);
		referencePose.MainHipsPose.SavePose(((Component)Hips).transform, this);
		for (int i = 0; i < referencePose.HipsPoses.Count; i++)
		{
			referencePose.HipsPoses[i].SavePose(ExtraHipsHubs[i], this);
		}
		for (int j = 0; j < referencePose.LegPoses.Count; j++)
		{
			referencePose.LegPoses[j].SaveLegPose(Legs[j], this);
		}
	}

	public void RestoreSetupPose()
	{
		RestoreSetupPose(setupPose);
	}

	public void RestoreSetupPose(ReferencePose referencePose)
	{
		referencePose.MainHipsPose.RestorePose(this);
		for (int i = 0; i < referencePose.HipsPoses.Count; i++)
		{
			referencePose.HipsPoses[i].RestorePose(this);
		}
		for (int j = 0; j < referencePose.LegPoses.Count; j++)
		{
			referencePose.LegPoses[j].RestoreLegPose(this);
		}
	}

	public void ApplyCustomReferencePose(ReferencePose pose)
	{
		if (pose != null && pose.IsSet(this))
		{
			ReferencePose referencePose = new ReferencePose();
			StoreSetupPose(referencePose);
			RestoreSetupPose(pose);
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].IKProcessor.Init(BaseTransform);
			}
			RestoreSetupPose(referencePose);
		}
	}

	public void User_SetIsGrounded(bool grounded)
	{
		if (grounded != _grounded)
		{
			if (grounded)
			{
				Control_OnLand();
			}
			else
			{
				Control_OnLooseGround();
			}
		}
		_grounded = grounded;
	}

	public void User_SetIsMoving(bool moving)
	{
		if (moving != _moving)
		{
			if (moving)
			{
				Control_OnStartMoving();
			}
			else
			{
				Control_OnStopMoving();
			}
		}
		_moving = moving;
	}

	public void User_SetIsSliding(bool moving)
	{
		_sliding = moving;
	}

	public void User_FadeLeg(int legIndex, float blend, float duration)
	{
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			((MonoBehaviour)this).StartCoroutine(IEFadeLegTo(Legs[legIndex], 0f, duration));
		}
	}

	public void User_FadeToDisabled(float duration)
	{
		((MonoBehaviour)this).StopAllCoroutines();
		if (duration <= 0f)
		{
			LegsAnimatorBlend = 0f;
			((Behaviour)this).enabled = false;
		}
		else
		{
			_wasFadingOn = false;
			((MonoBehaviour)this).StartCoroutine(IEFadeLegsAnimatorTo(0f, duration));
		}
	}

	public void User_FadeEnabled(float duration)
	{
		if (!((Behaviour)this).enabled)
		{
			((Behaviour)this).enabled = true;
		}
		((MonoBehaviour)this).StopAllCoroutines();
		if (duration <= 0f)
		{
			LegsAnimatorBlend = 1f;
		}
		else
		{
			_wasFadingOn = true;
			((MonoBehaviour)this).StartCoroutine(IEFadeLegsAnimatorTo(1f, duration));
		}
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].LegBlendWeight = 1f;
		}
	}

	public void User_MoveLegTo(int legIndex, Transform transform)
	{
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_OverrideRaycastHit(transform);
		}
	}

	public void User_MoveLegTo(int legIndex, Vector3 position, Vector3 normal)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit = default(RaycastHit);
		((RaycastHit)(ref hit)).point = position;
		((RaycastHit)(ref hit)).normal = normal;
		User_MoveLegTo(legIndex, hit);
	}

	public void User_MoveLegTo(int legIndex, RaycastHit hit)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_OverrideRaycastHit(hit);
		}
	}

	public void User_MoveLegTo_Restore(int legIndex)
	{
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_RestoreRaycasting();
		}
	}

	protected IEnumerator IEFadeLegsAnimatorTo(float blend, float duration)
	{
		float startBlend = LegsAnimatorBlend;
		float elapsed = 0f;
		while (elapsed < duration)
		{
			elapsed += DeltaTime;
			LegsAnimatorBlend = Mathf.Lerp(startBlend, blend, elapsed / duration);
			yield return null;
			if (blend == 0f)
			{
				if (_wasFadingOn == true)
				{
					_wasFadingOn = null;
					yield break;
				}
			}
			else if (blend == 1f && _wasFadingOn == false)
			{
				_wasFadingOn = null;
				yield break;
			}
		}
		LegsAnimatorBlend = blend;
		if (blend <= 0f)
		{
			((Behaviour)this).enabled = false;
		}
	}

	protected IEnumerator IEFadeLegTo(Leg leg, float blend, float duration)
	{
		float startBlend = leg.LegBlendWeight;
		float elapsed = 0f;
		while (elapsed < duration)
		{
			elapsed += DeltaTime;
			leg.LegBlendWeight = Mathf.Lerp(startBlend, blend, elapsed / duration);
			yield return null;
		}
		leg.LegBlendWeight = blend;
	}

	public void User_Teleport(Vector3 toPosition)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		((Behaviour)this).enabled = false;
		((Component)this).transform.position = toPosition;
		((Behaviour)this).enabled = true;
		CheckActivation();
		PrepareValues(1f);
		UpdateStack(1f);
	}

	public void User_HipsPushDown(float power)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		User_AddImpulse(new ImpulseExecutor(Vector3.down * power, 0.3f + power * 0.3f));
	}

	public void User_HipsPushDownLong(float power)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		User_AddImpulse(new ImpulseExecutor(Vector3.down * power, 0.5f + power * 0.5f));
	}

	protected void OnDisable()
	{
		legsWasDisabled = true;
	}

	public void User_OverwriteCastMatrix(Matrix4x4 mx)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Matrix4x4)(ref mx)).MultiplyVector(Vector3.up);
		Up = ((Vector3)(ref val)).normalized;
		CastMx = mx;
		InvCastMx = ((Matrix4x4)(ref mx)).inverse;
	}

	private void RefreshMatrices()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (LocalWorldUp)
		{
			Up = BaseTransform.up;
			CastMx = baseTransform.localToWorldMatrix;
			InvCastMx = baseTransform.worldToLocalMatrix;
		}
		else
		{
			Quaternion val = Quaternion.FromToRotation(Vector3.ProjectOnPlane(baseTransform.forward, Up), Vector3.forward);
			CastMx = Matrix4x4.TRS(BaseTransform.position, val, BaseTransform.lossyScale);
			Matrix4x4 castMx = CastMx;
			InvCastMx = ((Matrix4x4)(ref castMx)).inverse;
		}
	}

	public bool Util_OnLeftSide(Transform t)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return BaseTransform.InverseTransformPoint(t.position).x < 0f;
	}

	public float Util_SideMul(Transform t)
	{
		if (!Util_OnLeftSide(t))
		{
			return 1f;
		}
		return -1f;
	}

	public float HipsToGroundDistance()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Hips == (Object)null)
		{
			return 0.1f;
		}
		return Vector3.Distance(BaseTransform.position, Hips.position);
	}

	public float HipsToGroundDistanceLocal()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Hips == (Object)null)
		{
			return 0.1f;
		}
		return BaseTransform.InverseTransformPoint(Hips.position).y;
	}

	private void UpdateGroundedBlend()
	{
		if (IsGrounded)
		{
			if (UngroundFadeSpeed >= 1f)
			{
				IsGroundedBlend = 1f;
			}
			else
			{
				IsGroundedBlend = Mathf.MoveTowards(IsGroundedBlend, 1f, DeltaTime * Mathf.LerpUnclamped(20f, 60f, UngroundFadeSpeed));
			}
			return;
		}
		if (UngroundFadeSpeed >= 1f)
		{
			IsGroundedBlend = 0f;
			return;
		}
		IsGroundedBlend = Mathf.Lerp(IsGroundedBlend, -0.01f, DeltaTime * Mathf.LerpUnclamped(6f, 20f, UngroundFadeSpeed));
		if (IsGroundedBlend < 0f)
		{
			IsGroundedBlend = 0f;
		}
	}

	private void UpdateMovingBlend()
	{
		if (IsMoving)
		{
			if (IsMovingFadeSpeed >= 1f)
			{
				IsMovingBlend = 1f;
			}
			else
			{
				IsMovingBlend = Mathf.MoveTowards(IsMovingBlend, 1f, DeltaTime * Mathf.LerpUnclamped(5f, 60f, IsMovingFadeSpeed));
			}
		}
		else if (IsMovingFadeSpeed >= 1f)
		{
			IsMovingBlend = 0f;
		}
		else
		{
			IsMovingBlend = Mathf.MoveTowards(IsMovingBlend, 0f, DeltaTime * Mathf.LerpUnclamped(5f, 60f, IsMovingFadeSpeed));
		}
	}

	private void UpdateSlidingBlend()
	{
		if (IsSliding)
		{
			NotSlidingBlend = Mathf.MoveTowards(NotSlidingBlend, 0f, DeltaTime * 6f);
		}
		else
		{
			NotSlidingBlend = Mathf.MoveTowards(NotSlidingBlend, 1f, DeltaTime * 6f);
		}
	}

	public Vector3 ToRootLocalSpaceVec(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 invCastMx = InvCastMx;
		return ((Matrix4x4)(ref invCastMx)).MultiplyVector(vec);
	}

	internal float User_GetLocalRotationAngle(Vector3 worldMoveDirection, Vector3 currentWorldLookForwardDirection)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ToRootLocalSpaceVec(worldMoveDirection);
		val.y = 0f;
		Vector3 val2 = ToRootLocalSpaceVec(currentWorldLookForwardDirection);
		val2.y = 0f;
		((Vector3)(ref val)).Normalize();
		((Vector3)(ref val2)).Normalize();
		return 0f - Vector3.SignedAngle(val, val2, Vector3.up);
	}

	public Vector3 ToRootLocalSpace(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 invCastMx = InvCastMx;
		return ((Matrix4x4)(ref invCastMx)).MultiplyPoint3x4(worldPos);
	}

	public Vector3 RootToWorldSpaceVec(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 castMx = CastMx;
		return ((Matrix4x4)(ref castMx)).MultiplyVector(vec);
	}

	public void User_AddImpulse(PelvisImpulseSettings debugPushHipsImpulse, float multiplyPower = 1f, float multiplyDuration = 1f)
	{
		User_AddImpulse(new ImpulseExecutor(debugPushHipsImpulse, multiplyPower, multiplyDuration));
	}

	public void User_AddImpulse(ImpulseExecutor newImpulse)
	{
		if (!(newImpulse.ImpulseDuration <= 0f))
		{
			Impulses.Add(newImpulse);
		}
	}

	public Vector3 RootToWorldSpace(Vector3 localPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 castMx = CastMx;
		return ((Matrix4x4)(ref castMx)).MultiplyPoint3x4(localPos);
	}

	public void User_OverwriteIKCoords(int legID, Vector3? position, Quaternion? rotation = null)
	{
		if (Legs.ContainsIndex(legID, falseIfNull: true))
		{
			Legs[legID].OverrideTargetIKPosition(position);
			Legs[legID].OverrideTargetIKRotation(rotation);
		}
	}

	public void DoBackCompatibilityChecks()
	{
		if (ZeroStepsOnNoRaycast)
		{
			ZeroStepsOnNoRaycast = false;
			NoRaycastGroundBehaviour = ENoRaycastBehviour.ZeroFloorSteps;
		}
	}

	public bool CheckIfSomeOfTheLegsHasNullBone()
	{
		bool result = false;
		for (int i = 0; i < Legs.Count; i++)
		{
			Leg leg = Legs[i];
			if ((Object)(object)leg.BoneStart == (Object)null || (Object)(object)leg.BoneMid == (Object)null || (Object)(object)leg.BoneEnd == (Object)null)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	private void IK_Initialize()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].IK_Initialize();
		}
		if (UseCustomIK)
		{
			CustomIK_Initialize();
		}
	}

	private void IK_TriggerGlueReinitialize()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Glue_Reset(initializing: true);
		}
	}

	private void IK_TriggerGlueInstantTransition()
	{
		_wasInstantTriggered = true;
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].G_InstantReglue = true;
		}
	}

	public void IK_TriggerReglue(bool onlyIfFar = true)
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.G_RequestRepose = ((!onlyIfFar) ? Leg.GlueReposeRequest.Repose : Leg.GlueReposeRequest.ReposeIfFar);
		}
	}

	public void User_RefreshHelperVariablesOnParametersChange()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		if (!IsSetupValid())
		{
			return;
		}
		if (ScaleReferenceMode == ELegsScaleReference.PelvisToGroundDistance)
		{
			finalScaleReference = HipsToGroundDistanceLocal();
		}
		else if (ScaleReferenceMode == ELegsScaleReference.FirstLegLength)
		{
			finalScaleReference = Legs[0].LegLimbLength() / Mathf.Max(0.001f, BaseTransform.lossyScale.x);
		}
		else if (ScaleReferenceMode == ELegsScaleReference.Custom)
		{
			if (customScaleReferenceValue < 0f)
			{
				customScaleReferenceValue = 0.2f;
			}
			finalScaleReference = customScaleReferenceValue;
		}
		else if (ScaleReferenceMode == ELegsScaleReference.PelvisLegAverage)
		{
			finalScaleReference = HipsToGroundDistanceLocal();
			finalScaleReference = Mathf.LerpUnclamped(finalScaleReference, Legs[0].LegLimbLength() / Mathf.Max(0.001f, BaseTransform.lossyScale.x), 0.5f);
		}
	}

	protected void Legs_PreCalibrate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.PreCalibrate();
		}
	}

	private void Legs_CheckAnimatorPose()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.CheckAnimatorPose();
		}
	}

	private void Legs_BeginLateUpdate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.BeginLateUpdate();
		}
	}

	private void Legs_LateUpdate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.LateUpdate();
		}
	}

	private void Legs_LateUpdate_Apply()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.LateUpdate_Apply();
		}
		if (UseCustomIK)
		{
			CustomIK_ApplyIK();
		}
	}

	private void Legs_MidLateUpdateAndRaycasting()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (UseRaycastsForIsGrounded)
		{
			bool flag = false;
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].PreLateUpdate();
				if (!flag)
				{
					if (Legs[i].A_PreWasAligning)
					{
						flag = true;
					}
					else if (Legs[i].RaycastHitted && Legs[i].groundHitRootSpacePos.y > (0f - ScaleReference) * 0.05f)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				RaycastHit legGroundHit = Legs[0].legGroundHit;
				if (Legs[0].DoRaycasting(_LastAppliedHipsFinalPosition, _LastAppliedHipsFinalPosition - Up * (HipsSetup.LastHipsHeightDiff * BaseTransform.lossyScale.y * 1.01f + ScaleReference * 0.075f)))
				{
					flag = true;
				}
				Legs[0].legGroundHit = legGroundHit;
			}
			if (flag)
			{
				if (_calc_rayGrounding < 0f)
				{
					_calc_rayGrounding = 0f;
				}
				_calc_rayGrounding += DeltaTime;
				if (_calc_rayGrounding < 0.05f)
				{
					flag = _grounded;
				}
			}
			else
			{
				if (_calc_rayGrounding > 0f)
				{
					_calc_rayGrounding = 0f;
				}
				_calc_rayGrounding -= DeltaTime;
				if (_calc_rayGrounding > 0.005f)
				{
					flag = _grounded;
				}
			}
			if (flag == _grounded)
			{
				return;
			}
			if (flag)
			{
				if (!(Time.time - _calc_lastGrounded > 0.05f))
				{
					return;
				}
				_calc_lastGrounded = Time.time;
			}
			User_SetIsGrounded(flag);
		}
		else
		{
			for (int j = 0; j < Legs.Count; j++)
			{
				Legs[j].PreLateUpdate();
			}
		}
	}

	public float GetCurrentCullingBlend()
	{
		return cullingBlend;
	}

	private void Start()
	{
		_started = true;
		AllowUpdate = false;
		if (!DelayedInitialization)
		{
			Initialize();
		}
		((MonoBehaviour)this).StartCoroutine(IEStart());
	}

	private IEnumerator IEStart()
	{
		yield return null;
		yield return null;
		if ((Object)(object)Rigidbody == (Object)null)
		{
			Rigidbody = ((Component)BaseTransform).GetComponent<Rigidbody>();
			if (!Object.op_Implicit((Object)(object)Rigidbody))
			{
				Rigidbody = ((Component)BaseTransform).GetComponentInChildren<Rigidbody>();
			}
			if (!Object.op_Implicit((Object)(object)Rigidbody))
			{
				Rigidbody = ((Component)BaseTransform).GetComponentInParent<Rigidbody>();
			}
		}
		Initialize();
	}

	private void OnEnable()
	{
		if (_started)
		{
			if (!LegsInitialized)
			{
				Initialize();
			}
			else
			{
				_wasInstantTriggered = false;
			}
		}
	}

	private void ReInitialize()
	{
		LegsInitialized = false;
		DisposeModules();
		Start();
	}

	private void CheckActivation()
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (FadeOffAtDistance < 0.01f)
		{
			cullingBlend = 1f;
		}
		else
		{
			bool flag = true;
			if ((Object)(object)FadeOff_DistanceToCamera == (Object)null && (Object)(object)Camera.main != (Object)null)
			{
				FadeOff_DistanceToCamera = ((Component)Camera.main).transform;
			}
			if ((Object)(object)FadeOff_DistanceToCamera != (Object)null)
			{
				FadeOff_lastCameraDistance = Vector3.Distance(BaseTransform.position, FadeOff_DistanceToCamera.position);
				if (FadeOff_lastCameraDistance > FadeOffAtDistance)
				{
					flag = false;
				}
			}
			if (flag)
			{
				if (cullingBlend < 1f)
				{
					cullingBlend = Mathf.Min(1f, Mathf.Lerp(cullingBlend, 1.05f, Time.unscaledDeltaTime * 6f));
					cullingBlend = Mathf.MoveTowards(cullingBlend, 1f, Time.unscaledDeltaTime);
				}
			}
			else
			{
				cullingBlend = Mathf.MoveTowards(cullingBlend, 0f, Time.unscaledDeltaTime * 1.5f);
			}
		}
		if ((Object)(object)DisableIfInvisible != (Object)null)
		{
			bool flag2 = !DisableIfInvisible.isVisible;
			for (int i = 0; i < DisableIfInvisibleExtraRenderers.Count; i++)
			{
				if (DisableIfInvisibleExtraRenderers[i].isVisible)
				{
					flag2 = false;
					break;
				}
			}
			if (flag2)
			{
				legsWasDisabled = true;
				return;
			}
		}
		if (legsWasDisabled && _MainBlendNoRagdolling > 0f && LegsInitialized)
		{
			OnLegsReactivate();
			legsWasDisabled = false;
		}
	}

	private void Update()
	{
		if (LegsInitialized)
		{
			CheckActivation();
			float delta = (UnscaledDeltaTime ? Time.unscaledDeltaTime : Time.deltaTime);
			PrepareValues(delta);
			if (AllowUpdate && !AnimatePhysics && !legsWasDisabled)
			{
				UpdateStack(delta);
			}
		}
	}

	protected virtual void ExtraFixedUpdate()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (UseRigidbodyVelocityForIsMoving && Object.op_Implicit((Object)(object)Rigidbody))
		{
			Vector3 val = ToRootLocalSpaceVec(Rigidbody.velocity);
			val.y = 0f;
			bool moving = ((Vector3)(ref val)).magnitude > ScaleReferenceNoScale * 0.02f;
			User_SetIsMoving(moving);
		}
	}

	private void LateUpdate()
	{
		if (!AllowUpdate || legsWasDisabled)
		{
			return;
		}
		if (AnimatePhysics)
		{
			if (!_fixedUpdated)
			{
				return;
			}
			_fixedUpdated = false;
		}
		PreLateUpdateStack();
		LateUpdateStack();
	}

	protected virtual void PrepareValues(float delta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Invalid comparison between Unknown and I4
		_MainBlendNoRagdolling = LegsAnimatorBlend * cullingBlend * protectedBlend;
		_MainBlend = _MainBlendNoRagdolling * RagdolledDisablerBlend;
		_MainBlendPlusGrounded = _MainBlend * IsGroundedBlend;
		if ((Object)(object)Mecanim != (Object)null)
		{
			AnimatePhysics = (int)Mecanim.updateMode == 1;
		}
		if (_lastMainBlend != _MainBlend)
		{
			_lastMainBlendChanged = true;
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].IK_UpdateParamsBase();
			}
		}
		else
		{
			_lastMainBlendChanged = false;
		}
		_lastMainBlend = _MainBlend;
	}

	protected virtual void UpdateStack(float delta)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		MeasurePerformanceUpdate(start: true);
		DeltaTime = delta;
		Scale = baseTransform.lossyScale.y;
		if (_MainBlend > 0f)
		{
			if (!_wasInstantTriggered)
			{
				IK_TriggerGlueInstantTransition();
			}
			RefreshTargetMovementDirectionHelper();
			Controll_Update();
			UpdateGroundedBlend();
			UpdateMovingBlend();
			UpdateSlidingBlend();
			Hips_PreCalibrate();
			Legs_PreCalibrate();
			ExtraControls_Update();
			Modules_Update();
		}
		else
		{
			Controll_Update();
			Legs_PreCalibrate();
			legsWasDisabled = true;
		}
		MeasurePerformanceUpdate(start: false);
	}

	protected virtual void PreLateUpdateStack()
	{
		MeasurePerformancePreLateUpdate(start: true);
		RefreshMatrices();
		Legs_CheckAnimatorPose();
		Modules_AfterAnimatorCaptureUpdate();
		BaseObject_MotionUpdate();
		Hips_PreLateUpdate();
		Hips_LateUpdate();
		Legs_BeginLateUpdate();
		MeasurePerformancePreLateUpdate(start: false);
	}

	protected virtual void LateUpdateStack()
	{
		MeasurePerformanceMain(start: true);
		if (_MainBlend > 0.001f)
		{
			Legs_MidLateUpdateAndRaycasting();
		}
		Modules_PreLateUpdate();
		Legs_LateUpdate();
		Hips_PostLateUpdate();
		Modules_LateUpdatePreApply();
		Legs_LateUpdate_Apply();
		Modules_PostLateUpdate();
		MeasurePerformanceMain(start: false);
	}

	public virtual void User_UpdateParametersAfterManualChange()
	{
		if (AllowUpdate)
		{
			Modules_UpdateAfterManualChanges();
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].Leg_UpdateParams();
			}
			if (((UnityEventBase)Event_OnStep).GetPersistentEventCount() > 0 || Object.op_Implicit((Object)(object)StepInfoReceiver))
			{
				UseEvents = true;
			}
			else
			{
				UseEvents = false;
			}
		}
	}

	public void OnAddedReset()
	{
		MotionInfluence = new MotionInfluenceProcessor();
		MotionInfluence.AxisMotionInfluence.x = 0f;
		BaseLegAnimating = new LegStepAnimatingParameters();
		LegAnimatingSettings.RefreshDefaultCurves();
		CustomModules = new List<LegsAnimatorCustomModuleHelper>();
	}
}


using UnityEngine;

private struct CalibrateTransform
{
	public Transform Transform;

	private Quaternion initLocalRot;

	public CalibrateTransform(Transform t)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		Transform = t;
		initLocalRot = t.localRotation;
	}

	public void Calibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Transform.localRotation = initLocalRot;
	}
}


public enum EStepType
{
	IdleGluing,
	MovementGluing,
	OnLanding,
	OnStopping
}


using UnityEngine;

public interface ILegStepReceiver
{
	void LegAnimatorStepEvent(Leg leg, float power, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
}


using UnityEngine;

public interface ILegRaiseReceiver
{
	void LegAnimatorRaiseEvent(Leg leg, float predictedDistance, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class LegsAnimatorCustomModuleHelper
{
	public bool Enabled = true;

	public LegsAnimator Parent;

	public LegsAnimatorControlModuleBase ModuleReference;

	[SerializeField]
	[HideInInspector]
	public List<string> customStringList;

	[SerializeField]
	[HideInInspector]
	public List<Object> customObjectList;

	[SerializeField]
	private List<Variable> variables = new List<Variable>();

	public LegsAnimatorControlModuleBase PlaymodeModule { get; private set; }

	public LegsAnimatorControlModuleBase CurrentModule => PlaymodeModule;

	public LegsAnimatorCustomModuleHelper(LegsAnimator get)
	{
		Parent = get;
	}

	public void PreparePlaymodeModule(LegsAnimator parent)
	{
		if (!((Object)(object)PlaymodeModule != (Object)null) && !((Object)(object)ModuleReference == (Object)null))
		{
			PlaymodeModule = Object.Instantiate<LegsAnimatorControlModuleBase>(ModuleReference);
			PlaymodeModule.Base_Init(parent, this);
		}
	}

	public void DisposeModule()
	{
		if ((Object)(object)PlaymodeModule != (Object)null)
		{
			Object.Destroy((Object)(object)PlaymodeModule);
		}
		PlaymodeModule = null;
	}

	public Variable RequestVariable(string name, object defaultValue)
	{
		if (variables == null)
		{
			variables = new List<Variable>();
		}
		int hashCode = name.GetHashCode();
		for (int i = 0; i < variables.Count; i++)
		{
			if (variables[i].GetNameHash == hashCode)
			{
				return variables[i];
			}
		}
		Variable variable = new Variable(name, defaultValue);
		variables.Add(variable);
		return variable;
	}
}


using System;
using UnityEngine;

[Serializable]
public class PelvisImpulseSettings
{
	public string OptionalName = "Impulse";

	[Space(3f)]
	public float PowerMultiplier = 1f;

	[Tooltip("Duration of translation impulse in seconds")]
	public float ImpulseDuration = 0.5f;

	[Space(5f)]
	public Vector3 WorldTranslation = Vector3.zero;

	public Vector3 LocalTranslation = new Vector3(0f, -0.2f, 0.1f);

	[Space(5f)]
	public Vector3 HipsRotate = Vector3.zero;

	[Space(5f)]
	[Range(0f, 1f)]
	public float InheritElasticness = 0.75f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
	public AnimationCurve ImpulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
	public AnimationCurve YAxisMultiplyCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	[Space(5f)]
	[Tooltip("Local Offset Z-forward will bo rotated to face the legs animator's current desired move direction value")]
	public bool AlignWithDesiredMoveDirection;

	public PelvisImpulseSettings Copy()
	{
		return (PelvisImpulseSettings)MemberwiseClone();
	}

	public PelvisImpulseSettings()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		ImpulseCurve = GetDefaultCurveInstance();
	}

	public static AnimationCurve GetDefaultCurveInstance()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve obj = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);
		obj.AddKey(new Keyframe(0.2f, 1f));
		obj.SmoothTangents(1, 0.5f);
		return obj;
	}

	public PelvisImpulseSettings(Vector3 vector3, float duration, float power)
		: this()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		LocalTranslation = vector3;
		ImpulseDuration = duration;
		PowerMultiplier = power;
	}
}


using UnityEngine;

public struct ImpulseExecutor
{
	public float Elapsed;

	public float PowerMultiplier;

	public float ImpulseDuration;

	public Vector3 WorldTranslation;

	public Vector3 LocalTranslation;

	public float InheritElasticness;

	public Vector3 HipsRotation;

	public bool AlignDesired;

	public AnimationCurve ImpulseCurve;

	public AnimationCurve YAxisMultiplyCurve;

	private static AnimationCurve _defaultCurve;

	private static AnimationCurve _defaultCurve11;

	public static AnimationCurve DefaultCurve
	{
		get
		{
			if (_defaultCurve == null)
			{
				_defaultCurve = PelvisImpulseSettings.GetDefaultCurveInstance();
			}
			return _defaultCurve;
		}
	}

	public static AnimationCurve DefaultCurve11
	{
		get
		{
			if (_defaultCurve11 == null)
			{
				_defaultCurve11 = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			}
			return _defaultCurve11;
		}
	}

	public bool Finished => Elapsed >= ImpulseDuration;

	public float Progress
	{
		get
		{
			if (ImpulseDuration != 0f)
			{
				return Elapsed / ImpulseDuration;
			}
			return 1f;
		}
	}

	public float Evaluation => ImpulseCurve.Evaluate(Progress);

	public float Elastic => InheritElasticness;

	public float Power => PowerMultiplier;

	public Vector3 CurrentLocalOffset => LocalTranslation * Evaluation * Power;

	public float CurrentLocalYAxisMultiplier => YAxisMultiplyCurve.Evaluate(Progress);

	public Vector3 CurrentWorldOffset => WorldTranslation * Evaluation * Power;

	public ImpulseExecutor(PelvisImpulseSettings settings, float powerMultiplier = 1f, float durationMultiplier = 1f)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = settings.PowerMultiplier * powerMultiplier;
		ImpulseDuration = settings.ImpulseDuration * durationMultiplier;
		WorldTranslation = settings.WorldTranslation;
		LocalTranslation = settings.LocalTranslation;
		InheritElasticness = settings.InheritElasticness;
		HipsRotation = settings.HipsRotate;
		ImpulseCurve = settings.ImpulseCurve;
		YAxisMultiplyCurve = settings.YAxisMultiplyCurve;
		AlignDesired = settings.AlignWithDesiredMoveDirection;
	}

	public ImpulseExecutor(Vector3 localOffset, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = 1f;
		ImpulseDuration = duration;
		WorldTranslation = Vector3.zero;
		LocalTranslation = localOffset;
		InheritElasticness = elastic;
		ImpulseCurve = curve;
		if (curve == null)
		{
			ImpulseCurve = DefaultCurve;
		}
		YAxisMultiplyCurve = DefaultCurve11;
		HipsRotation = Vector3.zero;
		AlignDesired = alignWithDesiredDir;
	}

	public ImpulseExecutor(Vector3 localOffset, Vector3 hipsRotation, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = 1f;
		ImpulseDuration = duration;
		WorldTranslation = Vector3.zero;
		HipsRotation = hipsRotation;
		LocalTranslation = localOffset;
		InheritElasticness = elastic;
		ImpulseCurve = curve;
		if (curve == null)
		{
			ImpulseCurve = DefaultCurve;
		}
		YAxisMultiplyCurve = DefaultCurve11;
		AlignDesired = alignWithDesiredDir;
	}

	public ImpulseExecutor(float duration, Vector3 worldOffset, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = 1f;
		ImpulseDuration = duration;
		WorldTranslation = worldOffset;
		HipsRotation = Vector3.zero;
		LocalTranslation = Vector3.zero;
		InheritElasticness = elastic;
		ImpulseCurve = curve;
		if (curve == null)
		{
			ImpulseCurve = DefaultCurve;
		}
		YAxisMultiplyCurve = DefaultCurve11;
		AlignDesired = alignWithDesiredDir;
	}

	public void Update(float delta)
	{
		Elapsed += delta;
	}
}


public enum EHipsAdjustStyle
{
	SmoothDamp,
	FollowLegHeight
}


using UnityEngine;

public enum EHipsHubsHandling
{
	[Tooltip("Applying hips movement offset to the selected hub, in order to fix disconnected hips bones (rare case)")]
	FixDisconnected,
	[Tooltip("Detailed mode is computing hips hub offsets individually, giving more realistic effect but costs a bit more")]
	Detailed
}


using System;
using System.Collections.Generic;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class HipsReference
{
	public class HipsHubBackbone
	{
		public Transform frontBone;

		private Vector3 _dir = Vector3.zero;

		private Vector3 _sd_dir = Vector3.zero;

		private FMuscle_Vector3 _FMuscle;

		public LegsAnimator Owner { get; private set; }

		public Transform bone { get; private set; }

		public Quaternion initialLocalRotation { get; private set; }

		public Vector3 keyframePosition { get; private set; }

		public Quaternion TargetRotation { get; internal set; }

		public HipsHubBackbone(LegsAnimator owner, Transform b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Owner = owner;
			bone = b;
			initialLocalRotation = b.localRotation;
			_FMuscle = new FMuscle_Vector3();
			_FMuscle.Initialize(Vector3.zero);
		}

		public void PreCalibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			bone.localRotation = initialLocalRotation;
		}

		public void Calibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			keyframePosition = bone.position;
		}

		public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.HubBackBonesElasticity < 0.0001f)
			{
				return toHubNewB;
			}
			if (Owner.HubBackBonesElasticity <= 0.1f)
			{
				_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
			}
			else
			{
				_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
			}
			return _dir;
		}
	}

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Applying elasticity algorithm on the pelvis bone align motion, to make it look more organic.")]
	public float HipsElasticityBlend = 1f;

	public FMuscle_Vector3 HipsMuscle;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsRotElasticityBlend;

	public FMuscle_Quaternion HipsRotMuscle;

	[NonSerialized]
	public Vector3 LastKeyframePosition;

	[NonSerialized]
	public Vector3 LastKeyframeLocalPosition;

	[NonSerialized]
	public Quaternion LastKeyframeRotation;

	[NonSerialized]
	public Quaternion LastKeyframeLocalRotation;

	[NonSerialized]
	public Vector3 LastRootLocalPos;

	[NonSerialized]
	public float LastHipsHeightDiff;

	[NonSerialized]
	public Vector3 InitHipsPositionRootSpace;

	[NonSerialized]
	public float InitialHipsHeightLocal;

	[NonSerialized]
	internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

	private Transform root;

	private Vector3 initLocalPos;

	private Quaternion initLocalRot;

	private Vector3 _Hips_StabilityLocalAdjustement = Vector3.zero;

	private Vector3 _Hips_sd_StabilAdjustm = Vector3.zero;

	private Vector3 _stretchPreventerOff = Vector3.zero;

	private float _sd_Hips_StepHeightAdjustOffset;

	private int _h_lowestHitLeg = -1;

	private Vector3 _reAdjustLocal = Vector3.zero;

	private Vector3 _sd_readj = Vector3.zero;

	private Vector3 _pushSmoothed = Vector3.zero;

	private Vector3 _sd_pushSmoothed = Vector3.zero;

	public LegsAnimator Owner { get; private set; }

	public List<Leg> ChildLegs { get; private set; }

	public Transform bone { get; private set; }

	public UniRotateBone UniRotate { get; private set; }

	public List<HipsHubBackbone> HubBackBones { get; private set; }

	public Vector3 _Get_Hips_StabilityLocalAdjustement => _Hips_StabilityLocalAdjustement;

	public float _Hips_LastHipsOffset { get; private set; }

	public float _Hips_StepHeightAdjustOffset { get; private set; }

	public Vector3 ExtraNonElasticOffset { get; internal set; }

	public Vector3 _PreHipsAdjustPosition { get; internal set; }

	public void Initialize(LegsAnimator owner, Transform bone, Transform root)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		Owner = owner;
		this.bone = bone;
		this.root = root;
		initLocalPos = bone.localPosition;
		initLocalRot = bone.localRotation;
		ExtraNonElasticOffset = Vector3.zero;
		_Hips_StabilityLocalAdjustement = Vector3.zero;
		_Hips_sd_StabilAdjustm = Vector3.zero;
		InitHipsPositionRootSpace = root.InverseTransformPoint(bone.position);
		InitialHipsHeightLocal = InitHipsPositionRootSpace.y;
		if (HipsMuscle == null)
		{
			HipsMuscle = new FMuscle_Vector3();
		}
		if (HipsRotMuscle == null)
		{
			HipsRotMuscle = new FMuscle_Quaternion();
		}
		HipsMuscle.Initialize(Vector3.zero);
		HipsRotMuscle.Initialize(Quaternion.identity);
		UniRotate = new UniRotateBone(bone, root);
		Calibrate();
	}

	internal void PrepareLegs()
	{
		ChildLegs = new List<Leg>();
		if (!Owner._hipsHubs_using)
		{
			ChildLegs = Owner.Legs;
		}
		else
		{
			for (int i = 0; i < Owner.Legs.Count; i++)
			{
				bool? flag = IsFirstParent(Owner.Legs[i], bone);
				if (flag == true)
				{
					ChildLegs.Add(Owner.Legs[i]);
				}
				else if (!flag.HasValue && this == Owner.HipsSetup)
				{
					ChildLegs.Add(Owner.Legs[i]);
				}
			}
		}
		for (int j = 0; j < ChildLegs.Count; j++)
		{
			ChildLegs[j].AssignParentHub(this);
		}
	}

	internal void PrepareHubBones()
	{
		PrepareLegs();
		HubBackBones = new List<HipsHubBackbone>();
		Transform frontBone = bone;
		Transform parent = bone.parent;
		while ((Object)(object)parent != (Object)null)
		{
			bool flag = false;
			for (int i = 0; i < Owner.HipsHubs.Count; i++)
			{
				if ((Object)(object)parent == (Object)(object)Owner.HipsHubs[i].bone)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				HipsHubBackbone hipsHubBackbone = new HipsHubBackbone(Owner, parent);
				hipsHubBackbone.frontBone = frontBone;
				HubBackBones.Add(hipsHubBackbone);
				if (!((Object)(object)parent == (Object)(object)Owner.HipsSetup.bone))
				{
					frontBone = parent;
					parent = parent.parent;
					continue;
				}
				break;
			}
			break;
		}
	}

	private bool? IsFirstParent(Leg leg, Transform hub)
	{
		if ((Object)(object)leg.BoneStart == (Object)null)
		{
			return false;
		}
		Transform val = leg.BoneStart;
		while ((Object)(object)val != (Object)null)
		{
			if ((Object)(object)val == (Object)(object)hub)
			{
				return true;
			}
			if ((Object)(object)val == (Object)(object)Owner.Hips)
			{
				return false;
			}
			for (int i = 0; i < Owner.ExtraHipsHubs.Count; i++)
			{
				if ((Object)(object)val == (Object)(object)Owner.ExtraHipsHubs[i])
				{
					return false;
				}
			}
			val = val.parent;
		}
		return null;
	}

	public void Reset()
	{
		Calibrate();
		_Hips_LastHipsOffset = 0f;
	}

	public void PreCalibrate()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		UniRotate.PreCalibrate();
		if (Owner.Calibrate != ECalibrateMode.FixedCalibrate)
		{
			UniRotate.PreCalibrate();
		}
		else
		{
			bone.localPosition = LastKeyframeLocalPosition;
			bone.localRotation = LastKeyframeLocalRotation;
		}
		if (HubBackBones != null)
		{
			for (int i = 0; i < HubBackBones.Count; i++)
			{
				HubBackBones[i].PreCalibrate();
			}
		}
	}

	public void Calibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframePosition = bone.position;
		LastKeyframeLocalPosition = bone.localPosition;
		LastKeyframeLocalRotation = bone.localRotation;
		LastKeyframeRotation = bone.rotation;
		LastRootLocalPos = Owner.ToRootLocalSpace(LastKeyframePosition);
		LastHipsHeightDiff = GetHeightDiff(LastRootLocalPos.y);
		if (HubBackBones != null)
		{
			for (int i = 0; i < HubBackBones.Count; i++)
			{
				HubBackBones[i].Calibrate();
			}
		}
	}

	public float GetHeightDiff(float rootSpaceHeight)
	{
		return Mathf.InverseLerp(0f, InitialHipsHeightLocal, rootSpaceHeight);
	}

	public void CopyMuscleSettingsFrom(HipsReference hipsSetup)
	{
		HipsMuscle.Acceleration = hipsSetup.HipsMuscle.Acceleration;
		HipsMuscle.AccelerationLimit = hipsSetup.HipsMuscle.AccelerationLimit;
		HipsMuscle.Damping = hipsSetup.HipsMuscle.Damping;
		HipsMuscle.BrakePower = hipsSetup.HipsMuscle.BrakePower;
	}

	public Vector3 CalculateCenterOfMassStability(float stabilizingMultiplier)
	{
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.StabilizeCenterOfMass > 0f)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(0f, 0f, 0f);
			float num = ChildLegs.Count;
			if (Owner.StabilityAlgorithm == EStabilityMode.Biped_Deprecated)
			{
				for (int i = 0; i < ChildLegs.Count; i++)
				{
					Leg leg = ChildLegs[i];
					Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
					Vector3 previousFinalIKPosForStability = leg._PreviousFinalIKPosForStability;
					Vector3 val3 = Owner.ToRootLocalSpace(previousFinalIKPosForStability + val2);
					Vector3 initialPosInRootSpace = leg.InitialPosInRootSpace;
					initialPosInRootSpace.y += _Hips_LastHipsOffset;
					Vector3 val4 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace, leg.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace) : leg.AnkleH.LastKeyframeRootPos);
					Vector3 val5 = val3 - val4;
					val5.y *= 0.25f;
					val += val5 * leg.BlendWeight * 0.5f * (stabilizingMultiplier * Owner.StabilizeCenterOfMass);
				}
				val.y /= num;
			}
			else if (Owner.StabilityAlgorithm == EStabilityMode.Universal)
			{
				Vector3 lastRootLocalPos = LastRootLocalPos;
				for (int j = 0; j < ChildLegs.Count; j++)
				{
					Leg leg2 = ChildLegs[j];
					Vector3 initialPosInRootSpace2 = leg2.InitialPosInRootSpace;
					initialPosInRootSpace2.y += _Hips_LastHipsOffset;
					Vector3 val6 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace2, leg2.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace2) : leg2.AnkleH.LastKeyframeRootPos);
					Vector3 val7 = lastRootLocalPos - val6;
					Vector3 val8 = Owner.ToRootLocalSpace(leg2._PreviousFinalIKPosForStability);
					Vector3 val9 = lastRootLocalPos - val8;
					Vector3 val10 = val7 - val9;
					val10.y *= 0.25f;
					val += val10 * leg2.BlendWeight * (stabilizingMultiplier * Owner.StabilizeCenterOfMass) / num;
				}
			}
			if (val.y > 0f)
			{
				val.y = 0f;
			}
			if (Owner.StabilizingSpeed < 1f)
			{
				float duration = 0f;
				if (Owner.StabilizingSpeed < 1f)
				{
					duration = 0.001f + (1f - Owner.StabilizingSpeed) * 0.4f;
				}
				Owner.ValueTowards(ref _Hips_StabilityLocalAdjustement, val, ref _Hips_sd_StabilAdjustm, duration);
			}
			else
			{
				_Hips_StabilityLocalAdjustement = val;
			}
		}
		else
		{
			_Hips_StabilityLocalAdjustement = Vector3.zero;
		}
		return _Hips_StabilityLocalAdjustement;
	}

	public Vector3 CalculateStretchPreventerOffset()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.HipsStretchPreventer < 0.0001f)
		{
			return Vector3.zero;
		}
		Vector3 val = Vector3.zero;
		float num = 0f;
		Vector3 lastRootLocalPos = LastRootLocalPos;
		lastRootLocalPos.y = 0f;
		lastRootLocalPos = Owner.baseTransform.TransformPoint(lastRootLocalPos);
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			float stretchValue = leg.IKProcessor.GetStretchValue(leg._PreviousFinalIKPosForStability);
			if (stretchValue > Owner.LimitLegStretch * 0.975f)
			{
				num += 1f;
				float num2 = stretchValue - Owner.LimitLegStretch * 0.975f;
				Vector3 vec = lastRootLocalPos - leg._PreviousFinalIKPosForStability;
				vec = Owner.ToRootLocalSpaceVec(vec);
				if (vec.y > 0f)
				{
					vec.y = 0f;
				}
				vec.x *= -0.6f;
				vec.z *= -0.6f;
				val += vec * Mathf.Clamp(num2 * 3f, 0f, 0.5f);
			}
		}
		if (Owner.StretchPreventerSpeed < 1f)
		{
			float num3 = Mathf.Lerp(8f, 40f, Owner.StretchPreventerSpeed) * Owner.DeltaTime;
			if (num > 0f)
			{
				_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, val / num, num3);
			}
			else
			{
				_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, Vector3.zero, num3 * 0.7f);
			}
		}
		else
		{
			_stretchPreventerOff = val;
		}
		return _stretchPreventerOff;
	}

	public Vector3 CalculateGlueMovePush()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (Owner.GlueBlend < 0.0001f)
		{
			return val;
		}
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			if ((leg.G_Attached || leg.G_DuringLegAdjustMovement) && leg.G_LastLegMoveDistanceFactor > 0.055f && leg.G_GlueInternalTransition > 0f && leg.G_GlueInternalTransition < 1f && leg.G_HandlerExecutingLegAnimationMode == EGlueMode.Idle)
			{
				Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd);
				Vector3 val3 = Owner.ToRootLocalSpace(leg._PreviousFinalIKPosForStability + val2);
				val3.z = 0f - val3.z;
				float num = Owner.BaseLegAnimating.PushHipsOnMoveCurve.Evaluate(leg.G_GlueInternalTransition);
				Vector3 val4 = -val3 * num * 1f;
				val4.y -= num * leg.G_LastLegMoveDistanceFactor * Owner.ScaleReferenceNoScale * 0.75f;
				Vector3 val5;
				if (Owner.NormalizePush)
				{
					float num2 = Mathf.Min(1f, ((Vector3)(ref val4)).magnitude / (Owner.ScaleReferenceNoScale * 0.33f));
					num2 *= num2;
					val5 = ((Vector3)(ref val4)).normalized * Owner.ScaleReferenceNoScale * 0.33f * num2;
				}
				else
				{
					val5 = val4;
				}
				val5.y *= Owner.PushYBlend;
				val += val5 * leg.BlendWeight;
			}
		}
		return val;
	}

	private void AnimateStepAdjustTo(float yOffset)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.HipsHeightStepSpeed >= 1f)
		{
			_Hips_StepHeightAdjustOffset = yOffset;
			return;
		}
		float landingBoost = Owner.GetLandingBoost();
		if (Owner.HipsAdjustStyle == EHipsAdjustStyle.FollowLegHeight && yOffset < _Hips_StepHeightAdjustOffset && _h_lowestHitLeg != -1)
		{
			Vector3 previousFinalIKPos = Owner.Legs[_h_lowestHitLeg]._PreviousFinalIKPos;
			previousFinalIKPos = Owner.ToRootLocalSpace(previousFinalIKPos);
			previousFinalIKPos.y -= Owner.ScaleReferenceNoScale * 0.325f;
			if (previousFinalIKPos.y > yOffset)
			{
				yOffset = previousFinalIKPos.y;
			}
		}
		_Hips_StepHeightAdjustOffset = Mathf.SmoothDamp(_Hips_StepHeightAdjustOffset, yOffset, ref _sd_Hips_StepHeightAdjustOffset, Mathf.LerpUnclamped(0.4f, 0.01f, landingBoost), 1000000f, Owner.DeltaTime);
		_h_lowestHitLeg = -1;
	}

	public float CalculateBodyAdjust()
	{
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		_Hips_LastHipsOffset = 0f;
		if (Owner.HipsHeightStepBlend <= 0f)
		{
			return 0f;
		}
		if (Owner.IsGrounded)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				if (!leg.RaycastHitted)
				{
					continue;
				}
				RaycastHit lastGroundHit = leg.LastGroundHit;
				Vector3 point = ((RaycastHit)(ref lastGroundHit)).point;
				point = Owner.ToRootLocalSpace(point);
				if (point.y <= 0f)
				{
					if (0f - point.y < Owner.BodyStepDown * Owner.ScaleReferenceNoScale && point.y < val.y)
					{
						val = point;
						_h_lowestHitLeg = i;
					}
				}
				else if (point.y < Owner.MaxBodyStepUp * Owner.ScaleReferenceNoScale && point.y < val.y)
				{
					val2 = point;
				}
			}
			bool flag = false;
			if (val.x != float.MaxValue && Owner.BodyStepDown > 0f && val.y <= 0f)
			{
				AnimateStepAdjustTo(val.y);
				flag = true;
			}
			if (!flag && Owner.MaxBodyStepUp > 0f && val2.x != float.MaxValue)
			{
				AnimateStepAdjustTo(val2.y);
				flag = true;
			}
			if (!flag)
			{
				AnimateStepAdjustTo(0f);
			}
		}
		else
		{
			AnimateStepAdjustTo(0f);
		}
		float num = Owner.HipsBlendWeight * Owner._MainBlend * Owner.IsGroundedBlend * Owner.RagdolledDisablerBlend;
		_Hips_LastHipsOffset = _Hips_StepHeightAdjustOffset * Owner.baseTransform.lossyScale.y * num;
		return _Hips_LastHipsOffset;
	}

	public Vector3 CalculateStretchReadjust()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			Vector3 val2 = leg._FinalIKPos - val;
			if (leg.IKProcessor.GetStretchValue(val2) > Owner.LimitLegStretch)
			{
				Vector3 notStretchedPositionTowards = leg.IKProcessor.GetNotStretchedPositionTowards(val2, Owner.LimitLegStretch);
				Vector3 val3 = val2 - notStretchedPositionTowards;
				val += val3;
			}
		}
		val = Owner.ToRootLocalSpaceVec(val);
		_reAdjustLocal = Vector3.SmoothDamp(_reAdjustLocal, val, ref _sd_readj, 0.1f, 10000000f, Owner.DeltaTime);
		return _reAdjustLocal;
	}

	public Vector3 SmoothPushOffset(Vector3 pushLocalOffset, float pushDuration)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Owner.ValueTowards(ref _pushSmoothed, pushLocalOffset, ref _sd_pushSmoothed, pushDuration);
		return _pushSmoothed;
	}

	public Vector3 AnimateOffset(Vector3 hubOffset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return hubOffset;
	}
}


using FIMSpace.FTools;
using UnityEngine;

public class HipsHubBackbone
{
	public Transform frontBone;

	private Vector3 _dir = Vector3.zero;

	private Vector3 _sd_dir = Vector3.zero;

	private FMuscle_Vector3 _FMuscle;

	public LegsAnimator Owner { get; private set; }

	public Transform bone { get; private set; }

	public Quaternion initialLocalRotation { get; private set; }

	public Vector3 keyframePosition { get; private set; }

	public Quaternion TargetRotation { get; internal set; }

	public HipsHubBackbone(LegsAnimator owner, Transform b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Owner = owner;
		bone = b;
		initialLocalRotation = b.localRotation;
		_FMuscle = new FMuscle_Vector3();
		_FMuscle.Initialize(Vector3.zero);
	}

	public void PreCalibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		bone.localRotation = initialLocalRotation;
	}

	public void Calibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		keyframePosition = bone.position;
	}

	public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.HubBackBonesElasticity < 0.0001f)
		{
			return toHubNewB;
		}
		if (Owner.HubBackBonesElasticity <= 0.1f)
		{
			_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
		}
		else
		{
			_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
		}
		return _dir;
	}
}


public enum EStabilityMode
{
	Biped_Deprecated,
	Universal
}


using System;
using System.Collections.Generic;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class Leg
{
	private struct GlueAttachement
	{
		public RaycastHit AttachHit;

		public Transform AttachedTo;

		public Vector3 PosInAttachementLocal;

		public Vector3 NormalInAttachementLocal;

		public Quaternion RotInAttachementLocal;

		public bool NoTransform { get; private set; }

		public GlueAttachement(Leg leg, RaycastHit legGroundHit)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			AttachHit = legGroundHit;
			AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
			if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
			{
				NoTransform = true;
				PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
				NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
				RotInAttachementLocal = leg._PreviousFinalIKRot;
				return;
			}
			NoTransform = false;
			PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
			NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
			if (!leg.Owner.AnimateFeet)
			{
				RotInAttachementLocal = Quaternion.identity;
			}
			else
			{
				RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
			}
		}

		internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			Vector3 relevantHitPoint = GetRelevantHitPoint();
			return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
		}

		internal Vector3 GetRelevantHitPoint()
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (NoTransform || (Object)(object)AttachedTo == (Object)null)
			{
				return PosInAttachementLocal;
			}
			return AttachedTo.TransformPoint(PosInAttachementLocal);
		}

		internal Vector3 GetRelevantNormal()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (NoTransform)
			{
				return NormalInAttachementLocal;
			}
			return AttachedTo.TransformDirection(NormalInAttachementLocal);
		}

		internal Quaternion GetRelevantAttachementRotation()
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (NoTransform)
			{
				return RotInAttachementLocal;
			}
			return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
		}

		internal void OverwritePosition(Vector3 legAnimPos)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)AttachedTo == (Object)null)
			{
				PosInAttachementLocal = legAnimPos;
			}
			else
			{
				PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
			}
		}
	}

	private class GlueAttachementHandler
	{
		public class LegTransitionAnimation
		{
			private enum EMoveType
			{
				FromAnimation,
				FromLastAttachement
			}

			private GlueAttachementHandler handler;

			public float LegAdjustementYOffset;

			public float LegAdjustementFootAngleOffset;

			private Vector3 _legSpherizeLocalVector = Vector3.zero;

			private float _legMoveDurMul = 1f;

			private Quaternion baseRotationOnStepUp;

			public float legMoveDistanceFactor;

			private float sd_trProgress;

			private Vector3 previousPositionLocal;

			private Vector3 previousPositionWorld;

			private Quaternion previousRotationWorld;

			private Vector3 lastAppliedGluePosition;

			private Vector3 lastAppliedGluePositionLocal;

			private Quaternion lastAppliedGlueRotation;

			private float lastSpeedup;

			private EMoveType animationMoveType;

			private bool _instantTransition;

			private bool _wasAnimatingLeg;

			private LegsAnimator Owner => handler.Owner;

			private Leg leg => handler.leg;

			public bool duringLegAdjustMovement { get; private set; }

			public bool wasAttaching { get; private set; }

			public bool attached { get; private set; }

			public float transitionProgress { get; private set; }

			public float lastAttachCompleteTime { get; private set; }

			public float transitionProgressLastFrame { get; private set; }

			public EGlueMode LastAnimationGlueMode
			{
				get
				{
					if (animationMoveType != 0)
					{
						return EGlueMode.Idle;
					}
					return EGlueMode.Moving;
				}
			}

			public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				handler = glueTransitionHelper;
				Reset();
			}

			public void Reset()
			{
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				//IL_004e: Unknown result type (might be due to invalid IL or missing references)
				animationMoveType = EMoveType.FromAnimation;
				transitionProgress = 0f;
				transitionProgressLastFrame = 0f;
				baseRotationOnStepUp = Owner.BaseTransform.rotation;
				duringLegAdjustMovement = false;
				wasAttaching = false;
				attached = false;
				_legSpherizeLocalVector = Vector3.zero;
				ReInitialize();
			}

			public void ReInitialize()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_003a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0051: Unknown result type (might be due to invalid IL or missing references)
				//IL_0056: Unknown result type (might be due to invalid IL or missing references)
				//IL_005b: Unknown result type (might be due to invalid IL or missing references)
				lastAppliedGluePosition = leg._SourceIKPos;
				lastAppliedGlueRotation = leg._SourceIKRot;
				previousPositionWorld = leg._SourceIKPos;
				previousRotationWorld = leg._SourceIKRot;
				previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
			}

			internal void ScheduleInstantTransition()
			{
				_instantTransition = true;
			}

			internal void DoAttaching(bool canAttach)
			{
				if (canAttach != wasAttaching)
				{
					wasAttaching = canAttach;
					if (canAttach)
					{
						OnChangeTargetPosition();
					}
					else
					{
						attached = false;
						if (transitionProgress != 0f)
						{
							OnChangeTargetPosition();
						}
					}
				}
				if (duringLegAdjustMovement && transitionProgress >= 1f)
				{
					duringLegAdjustMovement = false;
				}
			}

			internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
			{
				//IL_0099: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_005d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0070: Unknown result type (might be due to invalid IL or missing references)
				//IL_0076: Unknown result type (might be due to invalid IL or missing references)
				//IL_006f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0080: Unknown result type (might be due to invalid IL or missing references)
				//IL_0091: Unknown result type (might be due to invalid IL or missing references)
				//IL_0092: Unknown result type (might be due to invalid IL or missing references)
				//IL_0097: Unknown result type (might be due to invalid IL or missing references)
				if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
				{
					Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
					Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
					if (val.y < val2.y)
					{
						val.y = val2.y;
						legAnimPos = Owner.RootToWorldSpace(val);
					}
				}
				return legAnimPos;
			}

			public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
			{
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				//IL_001f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				//IL_0056: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_007d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0082: Unknown result type (might be due to invalid IL or missing references)
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_012a: Unknown result type (might be due to invalid IL or missing references)
				LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
				Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
				if (legAnimatingSettings.SpherizeTrack.length > 1)
				{
					float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
					val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
				}
				if (Owner.AnimateFeet)
				{
					LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
					LegAdjustementFootAngleOffset /= lastSpeedup;
				}
				float num2 = Owner.ScaleReferenceNoScale * 0.75f;
				float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
				num3 *= num2;
				LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
				_wasAnimatingLeg = true;
				return val;
			}

			internal Vector3 GetTargetPosition()
			{
				//IL_0122: Unknown result type (might be due to invalid IL or missing references)
				//IL_0127: Unknown result type (might be due to invalid IL or missing references)
				//IL_0107: Unknown result type (might be due to invalid IL or missing references)
				//IL_010c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0111: Unknown result type (might be due to invalid IL or missing references)
				//IL_0038: Unknown result type (might be due to invalid IL or missing references)
				//IL_003d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0138: Unknown result type (might be due to invalid IL or missing references)
				//IL_0144: Unknown result type (might be due to invalid IL or missing references)
				//IL_0149: Unknown result type (might be due to invalid IL or missing references)
				//IL_0154: Unknown result type (might be due to invalid IL or missing references)
				//IL_0159: Unknown result type (might be due to invalid IL or missing references)
				//IL_0135: Unknown result type (might be due to invalid IL or missing references)
				//IL_011f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0050: Unknown result type (might be due to invalid IL or missing references)
				//IL_0177: Unknown result type (might be due to invalid IL or missing references)
				//IL_017e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0183: Unknown result type (might be due to invalid IL or missing references)
				//IL_0188: Unknown result type (might be due to invalid IL or missing references)
				//IL_016d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0172: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				//IL_006d: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
				//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
				//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
				//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_0197: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00de: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
				//IL_008e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_0098: Unknown result type (might be due to invalid IL or missing references)
				float glueAnimationBlend = handler.glueAnimationBlend;
				if (animationMoveType == EMoveType.FromAnimation)
				{
					if (glueAnimationBlend < 0.0001f)
					{
						return Owner.RootToWorldSpace(previousPositionLocal);
					}
					Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
					if (transitionProgress < 0.0001f)
					{
						return val;
					}
					Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
					if (transitionProgress > 0.9995f)
					{
						return val2;
					}
					return Vector3.LerpUnclamped(val, val2, transitionProgress);
				}
				Vector3 val3;
				if (leg.Owner.OnlyLocalAnimation)
				{
					val3 = Owner.RootToWorldSpace(previousPositionLocal);
					if (transitionProgress < 0.0001f)
					{
						return val3;
					}
				}
				else
				{
					val3 = previousPositionWorld;
					if (transitionProgress < 0.0001f)
					{
						return val3;
					}
					val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
				}
				Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
				if (transitionProgress >= 1f)
				{
					return val4;
				}
				float num = 1f - transitionProgress;
				return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
			}

			internal void RequireRepose()
			{
				if (attached)
				{
					attached = false;
					OnChangeTargetPosition();
				}
			}

			internal Quaternion GetTargetRotation()
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				//IL_004c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0053: Unknown result type (might be due to invalid IL or missing references)
				//IL_0058: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_0059: Unknown result type (might be due to invalid IL or missing references)
				Quaternion val = previousRotationWorld;
				if (transitionProgress < 0.001f)
				{
					return val;
				}
				Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
				if (transitionProgress > 0.9995f)
				{
					return val2;
				}
				return Quaternion.LerpUnclamped(val, val2, transitionProgress);
			}

			internal void OnChangeTargetPosition()
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
				//IL_0100: Unknown result type (might be due to invalid IL or missing references)
				//IL_0105: Unknown result type (might be due to invalid IL or missing references)
				//IL_010a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0141: Unknown result type (might be due to invalid IL or missing references)
				//IL_0146: Unknown result type (might be due to invalid IL or missing references)
				//IL_014d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0152: Unknown result type (might be due to invalid IL or missing references)
				//IL_0153: Unknown result type (might be due to invalid IL or missing references)
				//IL_0158: Unknown result type (might be due to invalid IL or missing references)
				//IL_0197: Unknown result type (might be due to invalid IL or missing references)
				//IL_019c: Unknown result type (might be due to invalid IL or missing references)
				//IL_019d: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
				//IL_0247: Unknown result type (might be due to invalid IL or missing references)
				//IL_024c: Unknown result type (might be due to invalid IL or missing references)
				//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
				//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
				//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
				//IL_0201: Unknown result type (might be due to invalid IL or missing references)
				//IL_0211: Unknown result type (might be due to invalid IL or missing references)
				//IL_0213: Unknown result type (might be due to invalid IL or missing references)
				//IL_0223: Unknown result type (might be due to invalid IL or missing references)
				//IL_022d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0232: Unknown result type (might be due to invalid IL or missing references)
				handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
				baseRotationOnStepUp = Owner.BaseTransform.rotation;
				if (handler.glueAnimationBlend < 0.2f)
				{
					animationMoveType = EMoveType.FromAnimation;
				}
				else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
				{
					animationMoveType = EMoveType.FromAnimation;
				}
				else if (animationMoveType == EMoveType.FromLastAttachement)
				{
					animationMoveType = EMoveType.FromLastAttachement;
				}
				else if (handler.glueAnimationBlend > 0.75f)
				{
					if (transitionProgress < 0.1f || transitionProgress > 0.9f)
					{
						animationMoveType = EMoveType.FromLastAttachement;
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
					}
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
				}
				if (leg.Owner.OnlyLocalAnimation)
				{
					previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
				}
				else
				{
					previousPositionWorld = lastAppliedGluePosition;
				}
				previousRotationWorld = lastAppliedGlueRotation;
				previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
				if (animationMoveType == EMoveType.FromLastAttachement)
				{
					if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
					{
						transitionProgress = 0f;
					}
					Vector3 val = previousPositionWorld;
					Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
					float magnitude = ((Vector3)(ref val2)).magnitude;
					legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
					legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
					Vector3 val3 = ((Vector3)(ref val2)).normalized;
					val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
					((Vector3)(ref val3)).Normalize();
					leg.SendRaiseEvent(magnitude);
					if (legMoveDistanceFactor > 0.0401f)
					{
						_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
						Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
						((Vector3)(ref worldDir)).Normalize();
						_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
						duringLegAdjustMovement = true;
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
						_legSpherizeLocalVector = Vector3.zero;
						duringLegAdjustMovement = false;
					}
				}
				else
				{
					duringLegAdjustMovement = false;
					transitionProgress = 0f;
				}
			}

			public void UpdateAnimation()
			{
				//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
				//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
				//IL_0201: Unknown result type (might be due to invalid IL or missing references)
				//IL_0211: Unknown result type (might be due to invalid IL or missing references)
				//IL_011a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0107: Unknown result type (might be due to invalid IL or missing references)
				//IL_010c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0111: Unknown result type (might be due to invalid IL or missing references)
				//IL_0192: Unknown result type (might be due to invalid IL or missing references)
				//IL_0197: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
				float num = (Owner.JustGrounded ? 0.2f : 1f);
				float num2 = (Owner.JustGrounded ? 5f : 1f);
				transitionProgressLastFrame = transitionProgress;
				if (_instantTransition)
				{
					_instantTransition = false;
					transitionProgress = 1f;
					lastAttachCompleteTime = Time.time;
				}
				if (!Owner.IsGrounded)
				{
					return;
				}
				if (animationMoveType == EMoveType.FromLastAttachement)
				{
					float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
					float num4 = 1f;
					lastSpeedup = 1f;
					if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
					{
						if (leg.hasOppositeleg)
						{
							Leg oppositeLeg = leg.GetOppositeLeg();
							Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
							if (leg.Owner.OnlyLocalAnimation)
							{
								targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
							}
							float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
							if (stretchValue > leg.LegStretchLimit * 0.95f)
							{
								float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
								if (num5 < 0f)
								{
									num5 = 0f;
								}
								num4 += num5;
							}
							if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
							{
								Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
								float magnitude = ((Vector3)(ref val)).magnitude;
								float num6 = Owner.ScaleReference * 0.4f;
								if (magnitude > num6)
								{
									float num7 = magnitude - num6;
									num4 += num7 / num6 * 2f;
								}
							}
						}
						if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
						{
							float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
							if (num8 > 12f)
							{
								float num9 = Mathf.InverseLerp(30f, 135f, num8);
								num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
								transitionProgress += Owner.DeltaTime * num9 * num2;
							}
						}
						num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
					}
					lastSpeedup = num4;
					transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
					if (transitionProgress > 0.9995f && duringLegAdjustMovement)
					{
						TriggerAttach();
					}
				}
				else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
				{
					TriggerAttach();
				}
				else
				{
					transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
				}
			}

			private void TriggerAttach()
			{
				if (!attached)
				{
					transitionProgress = 1f;
					lastAttachCompleteTime = Time.time;
					attached = leg.Glue_TriggerFinalAttach();
					duringLegAdjustMovement = false;
				}
			}

			public void PostUpdate()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				lastAppliedGluePosition = leg._GluePosition;
				lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
				lastAppliedGlueRotation = leg._GlueRotation;
				if (!_wasAnimatingLeg)
				{
					LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
					LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
				}
				else
				{
					_wasAnimatingLeg = false;
				}
			}
		}

		private LegsAnimator Owner;

		private Leg ParentLeg;

		private float _sd_glueAnimationBlend;

		private bool _instantTransition;

		private Vector3 lastGluePosition = Vector3.zero;

		private Quaternion lastGlueRotation = Quaternion.identity;

		public LegTransitionAnimation legMoveAnimation { get; private set; }

		private Leg leg => ParentLeg;

		public float glueAnimationBlend { get; private set; }

		public float attachTransitionProgress => legMoveAnimation.transitionProgress;

		public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

		public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

		public EGlueMode lasGlueModeOnAttaching { get; private set; }

		public GlueAttachementHandler(Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			ParentLeg = leg;
			Owner = leg.Owner;
			legMoveAnimation = new LegTransitionAnimation(this);
			lasGlueModeOnAttaching = Owner._glueModeExecuted;
			Reset(initializing: true);
		}

		public void Reset(bool initializing)
		{
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			glueAnimationBlend = 0f;
			_sd_glueAnimationBlend = 0f;
			if (initializing)
			{
				lastGluePosition = leg.BoneEnd.position;
				lastGlueRotation = leg.BoneEnd.rotation;
			}
			legMoveAnimation.Reset();
		}

		public void SheduleInstantTransition()
		{
			_instantTransition = true;
			legMoveAnimation.ScheduleInstantTransition();
		}

		public void TransitionToGlueAnimation()
		{
			legMoveAnimation.DoAttaching(canAttach: true);
			ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
		}

		public void TransitionToDisableGlueAnimation()
		{
			legMoveAnimation.DoAttaching(canAttach: false);
			ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
		}

		public Vector3 GetGluePosition()
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if (glueAnimationBlend > 0.9995f)
			{
				lastGluePosition = legMoveAnimation.GetTargetPosition();
			}
			else if (glueAnimationBlend < 0.0001f)
			{
				lastGluePosition = leg.A_PreIKPosForGluing;
			}
			else
			{
				lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
			}
			return lastGluePosition;
		}

		public Quaternion GetGlueRotation()
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if (glueAnimationBlend > 0.999f)
			{
				lastGlueRotation = legMoveAnimation.GetTargetRotation();
			}
			else if (glueAnimationBlend < 0f)
			{
				lastGlueRotation = leg._FinalIKRot;
			}
			else
			{
				lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
			}
			return lastGlueRotation;
		}

		public void UpdateTransitioning(bool attaching)
		{
			legMoveAnimation.UpdateAnimation();
		}

		public void PostUpdate()
		{
			legMoveAnimation.PostUpdate();
		}

		internal void OnLegRequireRepose()
		{
			legMoveAnimation.RequireRepose();
		}

		private void ChangeGlueAnimationBlendTo(float target, float speed)
		{
			if (Owner.GroundedTime < 0f)
			{
				speed = 0.99f;
			}
			if (_instantTransition && target > 0f)
			{
				glueAnimationBlend = target;
				_instantTransition = false;
				return;
			}
			if (speed >= 1f)
			{
				glueAnimationBlend = target;
				return;
			}
			if (leg.G_JustLanded)
			{
				glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
			}
			glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
			if (float.IsNaN(_sd_glueAnimationBlend))
			{
				_sd_glueAnimationBlend = 0f;
			}
		}
	}

	public enum GlueReposeRequest
	{
		None,
		Repose,
		ReposeIfFar
	}

	public class LegHelper
	{
		public Transform Bone;

		public LegHelper Child;

		public Vector3 InitPositionRootSpace;

		public Vector3 LastKeyframeRootPos;

		public LegHelper(Leg leg, Transform bone)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			Bone = bone;
			InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
		}

		public void Calibrate(Leg leg, Vector3 wPos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0003: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
		}
	}

	private GlueAttachement G_Attachement;

	public bool G_CustomForceAttach;

	public bool G_CustomForceNOTDetach;

	public bool G_CustomForceDetach;

	public bool G_CustomForceNOTAttach;

	private float lastFootForwardAngleDiffABS;

	private GlueAttachementHandler G_AttachementHandler;

	private Vector3 A_PreviousRelevantAnklePos;

	private Vector3 A_LastApppliedAlignPos;

	private Vector3 A_LastApppliedAlignPosLocal;

	private Vector3 A_PreIKPosForGluing;

	private Quaternion A_LastApppliedAlignRot;

	private Quaternion A_LastTargetAlignRot;

	private bool A_WasFullAlign;

	private float A_aligningBlendByGluing = 1f;

	private Vector3 A_LastElevation;

	private float A_LastElevateH;

	private float _sd_A_Elev;

	[NonSerialized]
	public float Adj_A_ElevateLerpSpeedStart = 8f;

	[NonSerialized]
	public float Adj_A_ElevateLerpSpeedAfter = 5f;

	[NonSerialized]
	public float Adj_A_ElevateSpeedupMargin = 0.014f;

	private float A_AligningFor;

	private Vector3 A_LastAlignRootSpacePos;

	private Vector3 A_LastSmoothTargetedPosLocal;

	private float A_LastSuddenSmoothYOffset;

	private float A_SuddenSmoothing;

	private float A_lastSuddenSmoothingDiff;

	private bool A_WasSmoothing;

	private bool A_WasAligningFrameBack;

	private Vector3 A_SmoothedIKPos;

	[NonSerialized]
	public bool G_InstantReglue;

	private float _glueTargetBlend = 1f;

	private float _gluingCulldown;

	protected bool G_JustLanded;

	[NonSerialized]
	public float ExtraGluingBlend = 1f;

	private Vector3 _GlueLastAttachPosition;

	private Vector3 _GlueLastAttachPositionRootLocal;

	private Quaternion _GlueLastAttachRotation;

	private Vector3 _GluePosition;

	private Quaternion _GlueRotation;

	private Vector3 _G_LastPreGlueSourceLocalIKPos;

	private Vector3 _G_PreGlueSourceLocalIKPos;

	private Vector3 _G_sd_RefSwing = Vector3.zero;

	private bool _G_WasDisabled = true;

	[NonSerialized]
	public GlueReposeRequest G_RequestRepose;

	private bool _G_WasGrounded = true;

	private Vector3 _G_LasGroundedPosLocal;

	private Quaternion _G_LasGroundedRotLocal;

	private Vector3 G_GlueDragOffset = Vector3.zero;

	private LegHelper _h_boneStart;

	private LegHelper _h_boneMid;

	private LegHelper _h_boneEnd;

	private Vector3 C_AnkleToHeelRootSpace = Vector3.one;

	private Vector3 C_LastHeelWorldPos;

	private Vector3 C_LastHeelRootSpacePos;

	private Vector3 C_LastFootEndWorldPos;

	private Vector3 C_LastFootEndRootSpacePos;

	private Vector3 C_Local_AnkleToHeelRotated;

	private float _C_DynamicYScale = 1f;

	public LegsAnimator Owner;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float LegBlendWeight = 1f;

	internal float InternalModuleBlendWeight = 1f;

	private float finalBoneBlend = 1f;

	[Tooltip("Make idle glue animation motion faster for this single leg")]
	public float LegMoveSpeedMultiplier = 1f;

	public float LegRaiseMultiplier = 1f;

	[Space(3f)]
	public float GlueThresholdMultiplier = 1f;

	public Vector2 GluePointOffset = Vector2.zero;

	[Space(3f)]
	[Range(0f, 1f)]
	public float LegStretchMultiplier = 1f;

	[Tooltip("Motion preset for the leg to be animated with different character than the other legs ('Idle Glue Motion' settings)")]
	public LegMotionSettingsPreset CustomLegAnimating;

	[Range(-40f, 40f)]
	public float FootPitchOffset;

	public Transform BoneStart;

	public Transform BoneMid;

	public Transform BoneEnd;

	public ELegSide Side;

	public int OppositeLegIndex = -1;

	public ERaycastPrecision RaycastPrecision;

	[Tooltip("(Experimental) If you want to animate in additional feet bone which in some cases can add nice animation feeling")]
	public bool UseFeet;

	public Transform BoneFeet;

	[Tooltip("Defining how quick heel should get up if leg gets stretched (change max stretching param under IK tab to be lower value that 1.1)")]
	[Range(0f, 1f)]
	public float FeetSensitivity = 0.5f;

	private bool hasOppositeleg;

	private LegStepAnimatingParameters targetLegAnimating;

	[Tooltip("Apply IK hint inversion, in case leg is bending in wrong direction.")]
	public bool InverseHint;

	public Vector3 AnkleToHeel = Vector3.zero;

	public Vector3 AnkleToFeetEnd = Vector3.zero;

	public Vector3 AnkleRight = Vector3.right;

	public Vector3 AnkleUp = Vector3.up;

	public Vector3 AnkleForward = Vector3.forward;

	[Range(0f, 1.001f)]
	public float FootMiddlePosition = 0.5f;

	[Space(5f)]
	[FPD_Suffix(-45f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "", true, 0)]
	public float AnkleYawCorrection;

	private bool _StepSent = true;

	private float _StepSentAt = -100f;

	private float _RaiseSentAt = -100f;

	private bool _OppositeLegStepped = true;

	private float _ToConfirmStepEvent;

	private Vector3 _SourceIKPosUnchangedY;

	private Vector3 _SourceIKPos;

	public Vector3 _FinalIKPos;

	private Quaternion _SourceIKRot;

	private Quaternion _FinalIKRot;

	private bool customOverwritingIKPos;

	private Vector3 customOverwritePos = Vector3.zero;

	private bool customOverwritingIKRot;

	private Quaternion customOverwriteRot = Quaternion.identity;

	private bool _wasFixedCalibrateAnimationCaptured;

	private bool _wasGrounded = true;

	private Vector3 _ungroundLocalIKCache;

	private bool _overwrittenSourceIKPos;

	public RaycastHit legGroundHit;

	public RaycastHit lastGroundHitWithTarget;

	private Vector3 previousAnkleAlignedOnGroundHitWorldPos;

	private Vector3 ankleAlignedOnGroundHitRootLocal;

	private Quaternion ankleAlignedOnGroundHitRotation;

	private RaycastHit replacementHit;

	private bool _UsingEmptyRaycast;

	private bool _UsingCustomRaycast;

	private bool _disableSourceRaycast;

	private float _CustomRaycastBlendIn;

	private RaycastHit _CustomRaycastHit;

	private Vector3 _PreviousCustomRaycastingStartIKPos;

	private Vector3 _PreviousCustomRaycastingIKPos;

	private bool _noRaycast_skipFeetCalcs;

	public bool G_AttachPossible
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (RaycastHitted)
			{
				return C_Local_MidFootPosVsGroundHit.y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel;
			}
			return false;
		}
	}

	public bool _Glue_AskingForDetach { get; private set; }

	public float BelowFootRange => ScaleRef * _C_DynamicYScale * 0.2f;

	private GlueAttachementHandler.LegTransitionAnimation G_LegAnimation => G_AttachementHandler.legMoveAnimation;

	public Vector3 G_GluePosition => _GluePosition;

	public float G_GlueAnimationBlend => G_AttachementHandler.glueAnimationBlend;

	public float G_GlueInternalTransition => G_AttachementHandler.attachTransitionProgress;

	public float G_LastAttachCompleteTime => G_AttachementHandler.legMoveAnimation.lastAttachCompleteTime;

	public float G_GlueInternalTransitionLastFrame => G_AttachementHandler.attachTransitionProgressLastFrame;

	public float G_LastLegMoveDistanceFactor => G_AttachementHandler.legMoveDistanceFactor;

	public bool G_DuringLegAdjustMovement => G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement;

	public EGlueMode G_HandlerExecutingLegAnimationMode => G_AttachementHandler.legMoveAnimation.LastAnimationGlueMode;

	public bool A_PreWasAligning { get; private set; }

	public bool A_PreWasAligningNearGround { get; private set; }

	public bool A_WasAligning { get; private set; }

	public float A_AligningHelperBlend { get; private set; }

	public float A_LastAlignHeightDiff { get; private set; }

	public float A_LastAlignHeightCompareValue { get; private set; }

	public bool G_Attached { get; private set; }

	public bool G_DuringAttaching => G_LegAnimation.duringLegAdjustMovement;

	public bool G_FadingIn => G_LegAnimation.duringLegAdjustMovement;

	public Vector3 _G_RefernceSwing { get; private set; }

	private float G_GlueTesholdRange => Owner.ScaleReferenceNoScale * GlueThresholdMultiplier * Owner.GlueRangeThreshold * 0.5f;

	private Transform Root => Owner.BaseTransform;

	private float ScaleRef => Owner.ScaleReference;

	private float FloorLevel => Owner._glueingFloorLevel;

	private float DeltaTime => Owner.DeltaTime;

	public LegHelper ThighH => _h_boneStart;

	private FimpIK_Limb.IKBone ThighIK => IKProcessor.StartIKBone;

	public LegHelper LowerLegH => _h_boneMid;

	private FimpIK_Limb.IKBone LowerLegIK => IKProcessor.MiddleIKBone;

	public LegHelper AnkleH => _h_boneEnd;

	public FimpIK_Limb.IKBone AnkleIK => IKProcessor.EndIKBone;

	public Vector3 C_LastMidRefFootWorldPos { get; private set; }

	public Vector3 C_LastMidRefFootRootSpacePos { get; private set; }

	public Vector3 C_Local_MidFootPosVsGroundHit { get; private set; }

	public float C_Local_FootElevateInAnimation { get; private set; }

	public float C_AnkleToHeelWorldHeight { get; private set; }

	public float C_AnimatedAnkleFlatHeight { get; private set; }

	public int PlaymodeIndex { get; private set; }

	public float BlendWeight { get; private set; }

	[field: NonSerialized]
	public Leg NextLeg { get; private set; }

	[field: NonSerialized]
	public HipsReference ParentHub { get; private set; }

	public LegStepAnimatingParameters LegAnimatingSettings => targetLegAnimating;

	public float LegStretchLimit { get; private set; } = 1f;

	public FimpIK_Limb IKProcessor { get; private set; }

	public Vector3 _PreviousFinalIKPos { get; private set; }

	public Vector3 _PreviousFinalIKPosRootLocal { get; private set; }

	public Vector3 _PreviousFinalIKPosForStability { get; private set; }

	public Quaternion _PreviousFinalIKRot { get; private set; }

	public Vector3 _AnimatorStartBonePos { get; private set; }

	public Vector3 _AnimatorMidBonePos { get; private set; }

	public Vector3 _AnimatorEndBonePos { get; private set; }

	public Quaternion _AnimatorStartBoneLocRot { get; private set; }

	public Quaternion _AnimatorMidBoneLocRot { get; private set; }

	public Quaternion _AnimatorEndBoneLocRot { get; private set; }

	public bool RaycastHitted { get; private set; }

	public RaycastHit LastGroundHit => legGroundHit;

	public Vector3 groundHitRootSpacePos { get; private set; }

	public Vector3 lastRaycastingOrigin { get; private set; }

	public Vector3 lastRaycastingEndPoint { get; private set; }

	public Vector3 ankleAlignedOnGroundHitWorldPos { get; private set; }

	public bool User_RaycastHittedSource { get; private set; }

	public float raycastSlopeAngle { get; private set; }

	public Vector3 InitialPosInRootSpace { get; private set; }

	public List<Leg> Legs => Owner.Legs;

	public bool Glue_CheckDetachement()
	{
		bool flag = Glue_Conditions_Detach();
		if (!flag)
		{
			flag = Glue_Conditions_DetachForced();
		}
		_Glue_AskingForDetach = flag;
		return flag;
	}

	public bool Glue_CheckIdleDetachementConfirm()
	{
		if (Owner._glueModeExecuted != 0)
		{
			return true;
		}
		if (hasOppositeleg)
		{
			Leg oppositeLeg = GetOppositeLeg();
			if (Glue_CheckOppositeLegMovementRestriction(oppositeLeg))
			{
				return false;
			}
		}
		return true;
	}

	private bool Glue_Conditions_Attach()
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (!Owner.IsGrounded)
		{
			return false;
		}
		if (_glueTargetBlend < 0.0001f)
		{
			return false;
		}
		if (!RaycastHitted)
		{
			return false;
		}
		if (G_CustomForceNOTDetach)
		{
			return true;
		}
		if (_gluingCulldown > 0f)
		{
			return false;
		}
		if (G_CustomForceAttach)
		{
			return true;
		}
		if (Owner.DontGlueAttachIfTooNearOppositeLeg > 0f && hasOppositeleg)
		{
			Vector3 val = ToRootLocalSpace(_PreviousFinalIKPos);
			Leg oppositeLeg = GetOppositeLeg();
			Vector3 val2 = ToRootLocalSpace(oppositeLeg._PreviousFinalIKPos);
			float num = Owner.DontGlueAttachIfTooNearOppositeLeg * Owner.ScaleReference;
			if (Vector2.Distance(new Vector2(val.x, val.z), new Vector2(val2.x, val2.z)) < num)
			{
				return false;
			}
		}
		if (G_HandlerExecutingLegAnimationMode == EGlueMode.Moving)
		{
			bool flag = false;
			float y = C_Local_MidFootPosVsGroundHit.y;
			if (y > FloorLevel)
			{
				if (y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel)
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (!flag)
			{
				return false;
			}
		}
		if (G_CustomForceNOTAttach)
		{
			return false;
		}
		if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f && Owner.DesiredMovementDirection != Vector3.zero)
		{
			Vector3 val3 = ToRootLocalSpaceDir(Owner.DesiredMovementDirection);
			Vector3 g_RefernceSwing = _G_RefernceSwing;
			if (Vector3.Dot(((Vector3)(ref val3)).normalized, ((Vector3)(ref g_RefernceSwing)).normalized) > 1f - Owner.SwingHelper)
			{
				return false;
			}
		}
		return true;
	}

	private bool Glue_CheckOppositeLegMovementRestriction(Leg oppositeLeg)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!RaycastHitted)
		{
			return false;
		}
		if (!Owner.IsGrounded)
		{
			return false;
		}
		if (C_Local_MidFootPosVsGroundHit.y > BelowFootRange)
		{
			return false;
		}
		if (G_CustomForceNOTDetach)
		{
			return true;
		}
		if (!oppositeLeg.RaycastHitted)
		{
			return false;
		}
		if (oppositeLeg.C_Local_MidFootPosVsGroundHit.y > oppositeLeg.BelowFootRange)
		{
			return false;
		}
		if (oppositeLeg.G_GlueInternalTransition < LegAnimatingSettings.AllowDetachBefore)
		{
			return true;
		}
		return false;
	}

	private Leg GetOppositeLeg()
	{
		if (OppositeLegIndex < 0)
		{
			return null;
		}
		if (OppositeLegIndex >= Owner.Legs.Count)
		{
			return null;
		}
		return Owner.Legs[OppositeLegIndex];
	}

	private void Gluing_SetCulldown(float minDuration = 0.01f)
	{
		_gluingCulldown = Mathf.Max(_gluingCulldown, minDuration + (0.02f - Owner.GlueFadeOutSpeed * 0.03f));
	}

	public bool Glue_Conditions_Detach()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (G_CustomForceNOTDetach)
		{
			return flag;
		}
		if (G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement)
		{
			return false;
		}
		if (!Glue_Conditions_Attach())
		{
			flag = true;
		}
		if (Owner.AnimateFeet && lastFootForwardAngleDiffABS > Owner.UnglueOn && !G_JustLanded)
		{
			if (Owner._glueModeExecuted != 0)
			{
				Gluing_SetCulldown();
			}
			flag = true;
		}
		if (!flag && !G_JustLanded)
		{
			Vector3 val = Vector3.zero;
			if (GluePointOffset != Vector2.zero)
			{
				val = -GetGluePointOffset();
			}
			if (Vector3.Distance(ankleAlignedOnGroundHitRootLocal + val, _GlueLastAttachPositionRootLocal) > G_GlueTesholdRange)
			{
				if (Owner._glueModeExecuted != 0)
				{
					Gluing_SetCulldown();
				}
				flag = true;
			}
		}
		return flag;
	}

	public Vector3 GetGluePointOffset()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		float num = Owner.ScaleReferenceNoScale * Owner.GlueRangeThreshold;
		return Owner.RootToWorldSpaceVec(new Vector3(GluePointOffset.x * num, 0f, GluePointOffset.y * num));
	}

	private bool Glue_Conditions_DetachForced()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (G_CustomForceDetach)
		{
			return true;
		}
		if (G_RequestRepose != 0)
		{
			if (G_RequestRepose != GlueReposeRequest.ReposeIfFar)
			{
				G_RequestRepose = GlueReposeRequest.None;
				return true;
			}
			G_RequestRepose = GlueReposeRequest.None;
			if (G_Attached && Vector3.Distance(_GluePosition, ankleAlignedOnGroundHitWorldPos) > ScaleRef * 0.1f)
			{
				return true;
			}
		}
		return false;
	}

	private void ExtraProcessingApply()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (G_LegAnimation.LegAdjustementYOffset != 0f)
		{
			_FinalIKPos += RootSpaceToWorldVec(new Vector3(0f, G_LegAnimation.LegAdjustementYOffset * LegRaiseMultiplier * _glueTargetBlend, 0f));
		}
		if (Owner.AnimateFeet)
		{
			PostCalculate_LimitFootYaw();
		}
	}

	private void ExtraIKPostProcessingApply()
	{
		if (Owner._stepPointsOverlapRadius > 0f)
		{
			PostCalculate_FeetOverlapRadius();
		}
		if (Owner.FeetYOffset != 0f)
		{
			PostCalculate_FeetYOffset();
		}
	}

	public void PostCalculate_LimitFootYaw()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ankleAlignedOnGroundHitRotation * AnkleIK.forward;
		val = ToRootLocalSpaceDir(val);
		val.y = 0f;
		val = RootSpaceToWorldVec(val);
		Vector3 worldDir = _FinalIKRot * AnkleIK.forward;
		val = ToRootLocalSpaceDir(val);
		val.y = 0f;
		worldDir = ToRootLocalSpaceDir(worldDir);
		worldDir.y = 0f;
		float num = (lastFootForwardAngleDiffABS = Mathf.Abs(Vector3.SignedAngle(((Vector3)(ref val)).normalized, ((Vector3)(ref worldDir)).normalized, Vector3.up)));
		if (Owner.LimitFeetYaw > 0f && Owner.LimitFeetYaw < 90f && num > Owner.LimitFeetYaw)
		{
			float num2 = num - Owner.LimitFeetYaw;
			Quaternion val2 = (A_WasAligning ? ankleAlignedOnGroundHitRotation : AnkleIK.srcRotation);
			_FinalIKRot = Quaternion.LerpUnclamped(val2, _FinalIKRot, 1f - num2 / (90f - Owner.LimitFeetYaw));
		}
	}

	private void PostCalculate_FeetOverlapRadius()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		float num = Owner._stepPointsOverlapRadius * GlueThresholdMultiplier;
		Vector3 val = ToRootLocalSpace(IKProcessor.IKTargetPosition);
		Leg leg = Owner.Legs[0];
		while (leg != null)
		{
			if (leg == this)
			{
				leg = leg.NextLeg;
				continue;
			}
			Vector3 val2 = ToRootLocalSpace(leg.IKProcessor.IKTargetPosition);
			Vector2 val3 = new Vector2(val2.x, val2.z) - new Vector2(val.x, val.z);
			float magnitude = ((Vector2)(ref val3)).magnitude;
			if (magnitude < num)
			{
				Vector2 val4 = -val3 * (num - magnitude) * 2f;
				FimpIK_Limb iKProcessor = IKProcessor;
				iKProcessor.IKTargetPosition += RootSpaceToWorldVec(new Vector3(val4.x, 0f, val4.y));
			}
			leg = leg.NextLeg;
		}
	}

	private void PostCalculate_FeetYOffset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		FimpIK_Limb iKProcessor = IKProcessor;
		iKProcessor.IKTargetPosition += _FinalIKRot * (Owner.FeetYOffset * Owner.Scale * A_AligningHelperBlend * AnkleIK.up);
	}

	private void AlignStep_Init()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		A_PreWasAligning = false;
		A_PreWasAligningNearGround = false;
		A_WasAligning = false;
		A_AligningHelperBlend = 0f;
		A_LastTargetAlignRot = BoneEnd.rotation;
		A_LastApppliedAlignRot = BoneEnd.rotation;
		A_PreIKPosForGluing = _FinalIKPos;
	}

	private void AlignStep_CheckAlignStatePre()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		A_PreIKPosForGluing = _FinalIKPos;
		if (_noRaycast_skipFeetCalcs)
		{
			return;
		}
		bool flag = false;
		A_PreWasAligningNearGround = false;
		if (RaycastHitted)
		{
			float hips_StepHeightAdjustOffset = ParentHub._Hips_StepHeightAdjustOffset;
			hips_StepHeightAdjustOffset = ((!(hips_StepHeightAdjustOffset < 0f)) ? 0f : (hips_StepHeightAdjustOffset * -0.03f));
			A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
			A_LastAlignHeightCompareValue = ScaleRef * (0.002f + Owner.AnimationFloorLevel) + hips_StepHeightAdjustOffset;
			if (Owner.FootAlignRapidity > 0.9999f)
			{
				if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
				{
					flag = true;
					A_PreWasAligningNearGround = true;
				}
			}
			else if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue + ScaleRef * (0.04f + (1f - Owner.FootAlignRapidity) * 0.04f))
			{
				A_PreWasAligningNearGround = true;
				if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
				{
					flag = true;
				}
			}
		}
		else
		{
			A_LastAlignHeightDiff = 100f;
		}
		A_PreWasAligning = flag;
		if (flag)
		{
			Vector3 val = ankleAlignedOnGroundHitWorldPos;
			if (A_AligningHelperBlend > 0.99f)
			{
				_FinalIKPos = val;
			}
			else
			{
				_FinalIKPos = Vector3.Lerp(_FinalIKPos, val, A_AligningHelperBlend * 8f);
			}
			A_PreIKPosForGluing = val;
		}
		else if (A_AligningHelperBlend > 0.01f)
		{
			_FinalIKPos = Vector3.Lerp(_FinalIKPos, RootSpaceToWorld(A_LastApppliedAlignPosLocal), A_AligningHelperBlend);
		}
	}

	private void AlignStep_ValidateFootRotation()
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (!Owner.AnimateFeet || _noRaycast_skipFeetCalcs)
		{
			return;
		}
		if (A_PreWasAligningNearGround)
		{
			float num = Owner.FootRotationBlend * A_AligningHelperBlend;
			if (A_LastElevateH < 0.02f)
			{
				if (num >= 1f)
				{
					A_LastTargetAlignRot = ankleAlignedOnGroundHitRotation;
				}
				else
				{
					A_LastTargetAlignRot = Quaternion.LerpUnclamped(_FinalIKRot, ankleAlignedOnGroundHitRotation, num);
				}
			}
			else
			{
				float num2 = A_LastElevateH / (ScaleRef * 0.15f);
				if (A_LastElevateH > 1f)
				{
					A_LastElevateH = 1f;
				}
				A_LastTargetAlignRot = Quaternion.LerpUnclamped(ankleAlignedOnGroundHitRotation, _FinalIKRot, num2 * num);
			}
		}
		else if (A_AligningHelperBlend < 0.001f)
		{
			A_LastTargetAlignRot = _FinalIKRot;
		}
		else
		{
			A_LastTargetAlignRot = Quaternion.Lerp(_FinalIKRot, A_LastTargetAlignRot, A_AligningHelperBlend);
		}
		if (Owner.FootAlignRapidity >= 1f)
		{
			A_LastApppliedAlignRot = A_LastTargetAlignRot;
		}
		else
		{
			A_LastApppliedAlignRot = Quaternion.Lerp(A_LastApppliedAlignRot, A_LastTargetAlignRot, DeltaTime * (8f + Owner.FootAlignRapidity * 26f));
		}
		_FinalIKRot = A_LastApppliedAlignRot;
	}

	private void AlignStep_OnGroundAlign()
	{
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		if (_noRaycast_skipFeetCalcs)
		{
			A_WasAligning = A_PreWasAligning;
			if (A_PreWasAligning)
			{
				if (A_AligningHelperBlend < 0.05f)
				{
					A_AligningHelperBlend = 0.05f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
				if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
				{
					A_WasFullAlign = true;
					if (!Owner.UseGluing)
					{
						SendStepEvent();
					}
				}
			}
			else
			{
				if (A_AligningHelperBlend > 0.5f)
				{
					A_AligningHelperBlend = 0.5f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 14f);
			}
			if (A_AligningHelperBlend < 0.65f)
			{
				A_WasFullAlign = false;
			}
			return;
		}
		A_aligningBlendByGluing = 1f;
		if (Owner.UseGluing)
		{
			A_aligningBlendByGluing = 1f - _glueTargetBlend * G_GlueAnimationBlend;
		}
		if (A_PreWasAligning)
		{
			if (A_WasAligning)
			{
				A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
			}
			float num = A_aligningBlendByGluing * A_AligningHelperBlend;
			if (num >= 1f)
			{
				_FinalIKPos = ankleAlignedOnGroundHitWorldPos;
			}
			else
			{
				_FinalIKPos = Vector3.LerpUnclamped(_FinalIKPos, ankleAlignedOnGroundHitWorldPos, num);
			}
			if (A_AligningHelperBlend < 0.05f)
			{
				A_AligningHelperBlend = 0.05f;
			}
			A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
			if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
			{
				A_WasFullAlign = true;
				if (!Owner.UseGluing)
				{
					SendStepEvent();
				}
			}
			A_LastApppliedAlignPosLocal = ToRootLocalSpace(_FinalIKPos);
		}
		else
		{
			A_PreviousRelevantAnklePos = _SourceIKPosUnchangedY;
			if (A_AligningHelperBlend > 0.75f)
			{
				A_AligningHelperBlend = 0.75f;
			}
			A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 18f);
		}
		if (A_AligningHelperBlend < 0.6f)
		{
			A_WasFullAlign = false;
		}
		A_LastApppliedAlignPos = _FinalIKPos;
		A_WasAligning = A_PreWasAligning;
	}

	private void AlignStep_LegElevation()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.LegElevateBlend < 0.001f)
		{
			return;
		}
		if (_noRaycast_skipFeetCalcs)
		{
			A_LastElevation = Vector3.zero;
			return;
		}
		float scaleRef = ScaleRef;
		float num = groundHitRootSpacePos.y - A_LastSuddenSmoothYOffset - ParentHub._Hips_StepHeightAdjustOffset;
		float num2 = Owner.AnimationFloorLevel * scaleRef;
		float c_Local_FootElevateInAnimation = C_Local_FootElevateInAnimation;
		if (c_Local_FootElevateInAnimation > num2 && num > 0.001f * scaleRef + num2 + 0.1f)
		{
			c_Local_FootElevateInAnimation -= num2;
			float num3 = c_Local_FootElevateInAnimation;
			float num4 = c_Local_FootElevateInAnimation - num;
			float num5 = scaleRef * 0.015f;
			float num6 = scaleRef * 0.35f;
			float num7 = num4 / num6;
			num7 = Mathf.Clamp01(num7);
			if (num4 > num5)
			{
				num3 *= 1f - num7;
				if (A_AligningFor < 0f)
				{
					A_AligningFor = DeltaTime;
				}
				if (A_AligningFor < 0.3f)
				{
					A_AligningFor += DeltaTime;
				}
				else
				{
					A_AligningFor = 0.3f;
				}
			}
			else if (A_AligningFor > 0f)
			{
				A_AligningFor -= DeltaTime;
			}
			else
			{
				A_AligningFor = 0f;
			}
			float num8 = num3;
			float num9 = scaleRef * Mathf.LerpUnclamped(0.1f, 0.9f, Owner.LegElevateHeightLimit);
			if (num8 > num9)
			{
				num8 = num9;
			}
			if (groundHitRootSpacePos.y > 0f)
			{
				float num10 = ScaleRef * 0.2f;
				if (num10 > 0f)
				{
					float num11 = groundHitRootSpacePos.y / num10;
					if (num11 > 0.8f)
					{
						num8 = Mathf.LerpUnclamped(num8, 0f, Mathf.InverseLerp(0.8f, 1.1f, num11));
					}
				}
			}
			if (Mathf.Abs(num8 - A_LastElevateH) > scaleRef * Adj_A_ElevateSpeedupMargin)
			{
				A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedAfter);
			}
			else
			{
				A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedStart);
			}
			if (A_LastElevateH < 0f)
			{
				A_LastElevateH = 0f;
			}
		}
		else
		{
			A_LastElevateH = Mathf.SmoothDamp(A_LastElevateH, 0f, ref _sd_A_Elev, 0.02f, 100000f, DeltaTime);
		}
		A_LastElevation = RootSpaceToWorldVec(new Vector3(0f, A_LastElevateH * Owner.LegElevateBlend * A_aligningBlendByGluing, 0f));
		_FinalIKPos += A_LastElevation;
	}

	private void AlignStep_SmoothSuddenSteps()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.SmoothSuddenSteps < 0.0001f)
		{
			return;
		}
		if (_noRaycast_skipFeetCalcs || G_Attached)
		{
			A_WasAligningFrameBack = A_WasAligning;
			A_WasSmoothing = false;
			return;
		}
		float scaleRef = ScaleRef;
		if (A_WasAligning || A_WasAligningFrameBack)
		{
			if (!A_WasAligning)
			{
				A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
			}
			Vector3 val = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
			Vector3 val2 = ((!A_WasSmoothing) ? ToRootLocalSpace(A_PreviousRelevantAnklePos) : ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos));
			float num = val2.y - val.y;
			num = Mathf.Abs(num);
			float num2 = scaleRef * 0.006f;
			if ((raycastSlopeAngle < 17f || raycastSlopeAngle > 80f || Owner.RaycastShape == ERaycastMode.Spherecast) && num > num2)
			{
				float num3 = num / (scaleRef * 0.275f);
				if (num3 > 1f)
				{
					num3 = 1f;
				}
				if (num3 > Mathf.LerpUnclamped(0.25f, 0.1f, Owner.SmoothSuddenSteps))
				{
					float num4 = Mathf.LerpUnclamped(0.3f, 0.1f, Owner.SmoothSuddenSteps);
					if (A_lastSuddenSmoothingDiff == 0f || A_SuddenSmoothing < num3)
					{
						A_lastSuddenSmoothingDiff = num;
						A_LastAlignRootSpacePos = ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos);
						num4 *= 0.7f;
					}
					else if (Owner.SmoothSuddenSteps < 0.5f)
					{
						float num5 = Mathf.LerpUnclamped(0.5f, 0f, Owner.SmoothSuddenSteps);
						A_lastSuddenSmoothingDiff = Mathf.LerpUnclamped(A_lastSuddenSmoothingDiff, num, num5);
					}
					A_SuddenSmoothing += Mathf.Clamp01(A_lastSuddenSmoothingDiff / (scaleRef * num4));
					float num6 = 0.85f + Owner.SmoothSuddenSteps * 0.165f;
					if (A_SuddenSmoothing > num6)
					{
						A_SuddenSmoothing = num6;
					}
				}
			}
		}
		if (A_SuddenSmoothing > 0f)
		{
			Vector3 val3 = ToRootLocalSpace(_FinalIKPos);
			A_LastSuddenSmoothYOffset = val3.y;
			A_SuddenSmoothing -= Owner.DeltaTime * Mathf.LerpUnclamped(60f, 7.5f, Owner.SmoothSuddenSteps);
			val3.y = Mathf.Lerp(val3.y, A_LastAlignRootSpacePos.y, A_SuddenSmoothing);
			A_LastSuddenSmoothYOffset = val3.y - A_LastSuddenSmoothYOffset;
			A_LastSmoothTargetedPosLocal = val3;
			A_SmoothedIKPos = RootSpaceToWorld(val3);
			_FinalIKPos = A_SmoothedIKPos;
			if (A_SuddenSmoothing < 0f)
			{
				A_SuddenSmoothing = 0f;
			}
			A_WasSmoothing = true;
		}
		else
		{
			A_LastSuddenSmoothYOffset = 0f;
			A_WasSmoothing = false;
		}
	}

	private void AlignStep_Complete()
	{
		A_WasAligningFrameBack = A_WasAligning;
	}

	private void Gluing_Init()
	{
		G_AttachementHandler = new GlueAttachementHandler(this);
		Glue_Reset(initializing: true);
	}

	public void Glue_Reset(bool initializing)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		G_Attached = false;
		if (initializing)
		{
			_GlueLastAttachPosition = BoneEnd.position;
			_GlueLastAttachRotation = BoneEnd.rotation;
			_GluePosition = BoneEnd.position;
			_GlueLastAttachPositionRootLocal = ToRootLocalSpace(BoneEnd.position);
			_G_LastPreGlueSourceLocalIKPos = _GlueLastAttachPosition;
			_G_PreGlueSourceLocalIKPos = _SourceIKPos;
			A_PreIKPosForGluing = BoneEnd.position;
			_G_LasGroundedPosLocal = _GlueLastAttachPositionRootLocal;
		}
		GlueAttachement g_Attachement = default(GlueAttachement);
		g_Attachement.PosInAttachementLocal = _FinalIKPos;
		g_Attachement.RotInAttachementLocal = _FinalIKRot;
		G_Attachement = g_Attachement;
		_G_RefernceSwing = Vector3.zero;
		_G_WasDisabled = true;
		G_AttachementHandler.Reset(initializing);
	}

	private void Gluing_Update()
	{
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		_glueTargetBlend = Owner.GlueBlend * ExtraGluingBlend * Owner.RagdolledDisablerBlend * Owner.NotSlidingBlend;
		if (Owner.GlueOnlyOnIdle)
		{
			_glueTargetBlend *= 1f - Owner.IsMovingBlend;
		}
		if (Owner.IsGrounded)
		{
			if (Owner.GroundedTime < 0.25f)
			{
				G_JustLanded = true;
				_glueTargetBlend *= 0.1f + Mathf.InverseLerp(0f, 0.25f, Owner.GroundedTime) * 0.9f;
			}
			else
			{
				G_JustLanded = false;
			}
		}
		else
		{
			G_JustLanded = false;
			_glueTargetBlend *= Owner.IsGroundedBlend;
		}
		if (_glueTargetBlend < 0.0001f)
		{
			_glueTargetBlend = 0f;
			_G_WasDisabled = true;
			return;
		}
		if (_G_WasDisabled)
		{
			Glue_Reset(initializing: false);
			_G_WasDisabled = false;
		}
		if (_gluingCulldown > 0f)
		{
			_gluingCulldown -= Owner.DeltaTime;
		}
		if (!Owner.IsGrounded)
		{
			if (_G_WasGrounded)
			{
				_G_WasGrounded = false;
				_G_LasGroundedPosLocal = ToRootLocalSpace(_GluePosition);
				_G_LasGroundedRotLocal = _GlueRotation;
				G_AttachementHandler.legMoveAnimation.Reset();
			}
			_GluePosition = RootSpaceToWorld(_G_LasGroundedPosLocal);
			_GlueRotation = _G_LasGroundedRotLocal;
			return;
		}
		_G_WasGrounded = true;
		if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f)
		{
			Vector3 val = AnkleH.LastKeyframeRootPos - _G_LastPreGlueSourceLocalIKPos;
			if (((Vector3)(ref val)).magnitude > Owner.ScaleReferenceNoScale * 0.001f)
			{
				_G_LastPreGlueSourceLocalIKPos = _G_PreGlueSourceLocalIKPos;
			}
			_G_PreGlueSourceLocalIKPos = AnkleH.LastKeyframeRootPos;
			_G_RefernceSwing = Vector3.SmoothDamp(_G_RefernceSwing, val * 2f, ref _G_sd_RefSwing, 0.04f, 100000f, Owner.DeltaTime);
		}
		else
		{
			_G_RefernceSwing = Vector3.zero;
			_G_sd_RefSwing = Vector3.zero;
		}
		_Glue_AskingForDetach = false;
		if (G_Attached)
		{
			bool flag = !Glue_CheckDetachement();
			if (!flag)
			{
				flag = !Glue_CheckIdleDetachementConfirm();
			}
			if (!flag)
			{
				G_Attached = flag;
				G_AttachementHandler.OnLegRequireRepose();
				flag = Glue_Conditions_Attach();
			}
			else if (!Glue_Conditions_Attach())
			{
				flag = false;
			}
			if (flag)
			{
				G_AttachementHandler.TransitionToGlueAnimation();
			}
			else
			{
				G_AttachementHandler.TransitionToDisableGlueAnimation();
			}
		}
		else if (Glue_Conditions_Attach())
		{
			G_AttachementHandler.TransitionToGlueAnimation();
		}
		else
		{
			G_AttachementHandler.TransitionToDisableGlueAnimation();
		}
		if (G_InstantReglue)
		{
			G_AttachementHandler.SheduleInstantTransition();
			G_InstantReglue = false;
		}
		G_AttachementHandler.UpdateTransitioning(G_DuringAttaching);
		Gluing_UpdateAttachement();
	}

	private bool Glue_TriggerFinalAttach()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref legGroundHit)).transform) || _UsingEmptyRaycast)
		{
			G_Attached = true;
			G_Attachement = new GlueAttachement(this, legGroundHit);
			return true;
		}
		return false;
	}

	private void Gluing_UpdateAttachement()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!G_Attachement.NoTransform && (Object)(object)G_Attachement.AttachedTo == (Object)null)
		{
			G_Attachement = default(GlueAttachement);
			G_AttachementHandler.OnLegRequireRepose();
			G_Attached = false;
		}
		if (!G_Attached)
		{
			_GluePosition = G_AttachementHandler.GetGluePosition();
			Gluing_DragStretchApply();
			if (Owner.AnimateFeet)
			{
				if (Owner.LimitFeetYaw > 0f)
				{
					_GlueRotation = G_AttachementHandler.GetGlueRotation();
				}
				else
				{
					_GlueRotation = A_LastApppliedAlignRot;
				}
			}
		}
		else
		{
			_GlueLastAttachPosition = G_Attachement.GetRelevantAlignedHitPoint(this);
			_GlueLastAttachPositionRootLocal = ToRootLocalSpace(_GlueLastAttachPosition);
			Quaternion relevantAttachementRotation = G_Attachement.GetRelevantAttachementRotation();
			_GlueLastAttachRotation = relevantAttachementRotation;
			_GluePosition = G_AttachementHandler.GetGluePosition();
			Gluing_DragStretchApply();
			if (Owner.AnimateFeet)
			{
				if (Owner.LimitFeetYaw > 0f)
				{
					_GlueRotation = G_AttachementHandler.GetGlueRotation();
				}
				else
				{
					_GlueRotation = A_LastApppliedAlignRot;
				}
			}
		}
		G_AttachementHandler.PostUpdate();
	}

	private void Gluing_DragStretchApply()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.AllowGlueDrag > 0f)
		{
			float stretchValue = IKProcessor.GetStretchValue(_GluePosition - Owner._LastAppliedHipsStabilityOffset);
			float num = Mathf.LerpUnclamped(1f, 0.825f, Owner.AllowGlueDrag);
			float num2 = num * Mathf.LerpUnclamped(1f, LegStretchLimit, Owner.AllowGlueDrag);
			if (num2 > num)
			{
				num2 = num;
			}
			Vector3 val = _GluePosition;
			if (stretchValue > num2 * 1.1f)
			{
				float num3 = (stretchValue - num2 * 1.1f) * 2f * Mathf.Min(1f, Owner.AllowGlueDrag);
				val = ((!A_PreWasAligning) ? Vector3.Lerp(_GluePosition, A_PreIKPosForGluing, num3) : Vector3.Lerp(_GluePosition, ankleAlignedOnGroundHitWorldPos, num3));
			}
			Vector3 val2 = val - _GluePosition;
			G_GlueDragOffset = Vector3.Lerp(G_GlueDragOffset, val2, Owner.DeltaTime * 14f);
			if (float.IsNaN(G_GlueDragOffset.x) || float.IsNaN(G_GlueDragOffset.z))
			{
				G_GlueDragOffset = Vector3.zero;
			}
		}
	}

	private void Gluing_ApplyCoords()
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (_glueTargetBlend < 0.0001f)
		{
			return;
		}
		float num = _glueTargetBlend * G_AttachementHandler.glueAnimationBlend;
		if (num >= 1f)
		{
			_FinalIKPos = _GluePosition + G_GlueDragOffset;
			if (Owner.AnimateFeet)
			{
				_FinalIKRot = _GlueRotation;
			}
		}
		else
		{
			_FinalIKPos = Vector3.LerpUnclamped(A_PreIKPosForGluing, _GluePosition + G_GlueDragOffset, num);
			if (Owner.AnimateFeet)
			{
				_FinalIKRot = Quaternion.LerpUnclamped(_FinalIKRot, _GlueRotation, num);
			}
		}
	}

	private void Controll_Init()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		C_AnkleToHeelRootSpace = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
		ThighH.Calibrate(this, ThighH.Bone.position);
		AnkleH.Calibrate(this, AnkleH.Bone.position);
	}

	private Vector3 TransformVectorAnkleWithAlignedRotation(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return ankleAlignedOnGroundHitRotation * Vector3.Scale(offset, BoneEnd.lossyScale);
	}

	private void Controll_Calibrate()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		_C_DynamicYScale = Owner.DynamicYScale;
		ThighH.Calibrate(this, ThighH.Bone.position);
		AnkleH.Calibrate(this, _SourceIKPosUnchangedY);
		Vector3 ankleToHeel = AnkleToHeel;
		Vector3 val = TransformVectorAnkleWithAlignedRotation(AnkleToHeel);
		C_LastFootEndWorldPos = _SourceIKPosUnchangedY + TransformVectorAnkleWithAlignedRotation(ankleToHeel);
		C_LastFootEndRootSpacePos = ToRootLocalSpace(C_LastFootEndWorldPos);
		C_AnimatedAnkleFlatHeight = ToRootLocalSpaceDir(val).y;
		C_LastHeelWorldPos = _SourceIKPosUnchangedY + val;
		C_LastHeelRootSpacePos = ToRootLocalSpace(C_LastHeelWorldPos);
		if (Owner.AnimateFeet)
		{
			C_LastMidRefFootWorldPos = Vector3.LerpUnclamped(C_LastFootEndWorldPos, C_LastHeelWorldPos, FootMiddlePosition);
			C_LastMidRefFootRootSpacePos = Vector3.LerpUnclamped(C_LastFootEndRootSpacePos, C_LastHeelRootSpacePos, FootMiddlePosition);
		}
		else
		{
			C_LastMidRefFootRootSpacePos = C_LastHeelRootSpacePos;
			C_LastMidRefFootWorldPos = C_LastHeelWorldPos;
		}
		C_Local_MidFootPosVsGroundHit = C_LastMidRefFootRootSpacePos - groundHitRootSpacePos;
		C_Local_FootElevateInAnimation = C_LastMidRefFootRootSpacePos.y - ParentHub._Hips_LastHipsOffset;
		C_Local_AnkleToHeelRotated = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
		Vector3 val2 = BoneEnd.TransformVector(AnkleToHeel);
		C_AnkleToHeelWorldHeight = ((Vector3)(ref val2)).magnitude;
	}

	private Vector3 RootSpaceToWorldVec(Vector3 localVec)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.RootToWorldSpaceVec(localVec);
	}

	private Vector3 RootSpaceToWorld(Vector3 rootLocal)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.RootToWorldSpace(rootLocal);
	}

	private Vector3 ToRootLocalSpaceDir(Vector3 worldDir)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.ToRootLocalSpaceVec(worldDir);
	}

	private Vector3 ToRootLocalSpace(Vector3 worldPos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.ToRootLocalSpace(worldPos);
	}

	private Vector3 ChangeLocalY(Vector3 worldPos, float targetLocalY)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		worldPos = ToRootLocalSpace(worldPos);
		worldPos.y = targetLocalY;
		return RootSpaceToWorld(worldPos);
	}

	private Vector3 ChangeLocalPosExceptY(Vector3 worldPos, Vector3 targetWorldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		worldPos = ToRootLocalSpace(worldPos);
		Vector3 val = ToRootLocalSpace(targetWorldPos);
		worldPos.x = val.x;
		worldPos.z = val.z;
		return RootSpaceToWorld(worldPos);
	}

	private void Control_StepEventCalcs()
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		StepEventRestore();
		if (!Owner.UseGluing || _StepSent)
		{
			return;
		}
		if (Owner._glueModeExecuted == EGlueMode.Idle)
		{
			if (G_GlueInternalTransition >= 0.85f - Owner.EventExecuteSooner)
			{
				if (_ToConfirmStepEvent > 0.1f)
				{
					SendStepEvent(G_AttachementHandler.legMoveDistanceFactor);
					return;
				}
				float num = Mathf.InverseLerp(1f, 0f, LegAnimatingSettings.RaiseYAxisCurve.Evaluate(G_GlueInternalTransition));
				_ToConfirmStepEvent += DeltaTime * (3f + 3f * num);
			}
			else
			{
				_ToConfirmStepEvent = 0f;
			}
		}
		else
		{
			if (G_HandlerExecutingLegAnimationMode != EGlueMode.Moving || !Owner.SendOnMovingGlue || G_CustomForceNOTAttach)
			{
				return;
			}
			float num2 = FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.5f + A_LastAlignHeightCompareValue * (1.65f + Owner.EventExecuteSooner);
			if (G_CustomForceAttach)
			{
				_ToConfirmStepEvent += DeltaTime * 5f;
				num2 += ScaleRef * 0.1f;
			}
			if (A_LastAlignHeightDiff <= num2)
			{
				if (_ToConfirmStepEvent > 0.2f)
				{
					SendStepEvent(1f, EStepType.MovementGluing);
					_ToConfirmStepEvent = 0f;
					return;
				}
				_ToConfirmStepEvent += DeltaTime;
				if (A_LastAlignHeightDiff < num2 * 0.75f)
				{
					_ToConfirmStepEvent += DeltaTime * 1f;
				}
				if (A_LastAlignHeightDiff < num2 * 0.5f)
				{
					_ToConfirmStepEvent += DeltaTime * 1f;
				}
			}
			else
			{
				_ToConfirmStepEvent = 0f;
			}
		}
	}

	internal void StepEventSentInCustomWay()
	{
		_StepSent = true;
		_StepSentAt = Time.unscaledTime;
	}

	public void InitLegBasics(LegsAnimator creator, int index, Leg nextLeg)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)creator != (Object)null)
		{
			Owner = creator;
		}
		PlaymodeIndex = index;
		NextLeg = nextLeg;
		LegStretchLimit = 1f;
		BlendWeight = 1f;
		InternalModuleBlendWeight = 1f;
		EnsureAxesNormalization();
		_h_boneStart = new LegHelper(this, BoneStart);
		_h_boneMid = new LegHelper(this, BoneMid);
		_h_boneEnd = new LegHelper(this, BoneEnd);
		_h_boneStart.Child = _h_boneMid;
		_h_boneMid.Child = _h_boneEnd;
		Gluing_Init();
		Reset();
		Controll_Init();
		Raycasting_Init();
		Stability_Init();
		AlignStep_Init();
		RefreshHasOppositeLeg();
		targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : creator.LegAnimatingSettings);
		ankleAlignedOnGroundHitWorldPos = _FinalIKPos;
	}

	public void RefreshHasOppositeLeg()
	{
		hasOppositeleg = false;
		if (GetOppositeLeg() != null)
		{
			hasOppositeleg = true;
		}
	}

	public void Leg_UpdateParams()
	{
		targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : Owner.LegAnimatingSettings);
		IK_UpdateParams();
	}

	internal void AssignParentHub(HipsReference hipsReference)
	{
		ParentHub = hipsReference;
	}

	internal void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		_SourceIKPos = BoneEnd.position;
		_SourceIKRot = BoneEnd.rotation;
		_FinalIKPos = _SourceIKPos;
		_FinalIKRot = _SourceIKRot;
		_PreviousFinalIKPos = _FinalIKPos;
		_PreviousFinalIKRot = _FinalIKRot;
		legGroundHit = default(RaycastHit);
		((RaycastHit)(ref legGroundHit)).point = _FinalIKPos;
		((RaycastHit)(ref legGroundHit)).normal = Owner.Up;
		_PreviousFinalIKPosForStability = _SourceIKPos;
		ankleAlignedOnGroundHitRotation = _SourceIKRot;
		A_LastApppliedAlignRot = _SourceIKRot;
		A_LastTargetAlignRot = _SourceIKRot;
		groundHitRootSpacePos = ToRootLocalSpace(_SourceIKPos);
		_SourceIKPosUnchangedY = groundHitRootSpacePos;
		RaycastHit val = default(RaycastHit);
		((RaycastHit)(ref val)).point = _FinalIKPos;
		((RaycastHit)(ref val)).normal = Owner.Up;
		legGroundHit = val;
		Glue_Reset(initializing: true);
	}

	public void PreCalibrate()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		BlendWeight *= InternalModuleBlendWeight;
		finalBoneBlend = BlendWeight * Owner._MainBlend;
		if (finalBoneBlend < 0.0001f)
		{
			if (!_G_WasDisabled)
			{
				G_Attached = false;
				G_AttachementHandler.Reset(initializing: false);
				G_Attachement = default(GlueAttachement);
				_G_WasDisabled = true;
				legGroundHit = default(RaycastHit);
				RaycastHitted = false;
			}
		}
		else if (Owner.Calibrate == ECalibrateMode.Calibrate)
		{
			IKProcessor.PreCalibrate();
		}
		else if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
		{
			if (!_wasFixedCalibrateAnimationCaptured)
			{
				IKProcessor.PreCalibrate();
				return;
			}
			BoneStart.localRotation = _AnimatorStartBoneLocRot;
			BoneMid.localRotation = _AnimatorMidBoneLocRot;
			BoneEnd.localRotation = _AnimatorEndBoneLocRot;
		}
	}

	public void CheckAnimatorPose()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		_AnimatorStartBonePos = BoneStart.position;
		_AnimatorMidBonePos = BoneMid.position;
		_AnimatorEndBonePos = BoneEnd.position;
		if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
		{
			_wasFixedCalibrateAnimationCaptured = true;
			_AnimatorStartBoneLocRot = BoneStart.localRotation;
			_AnimatorMidBoneLocRot = BoneMid.localRotation;
			_AnimatorEndBoneLocRot = BoneEnd.localRotation;
		}
	}

	public void BeginLateUpdate()
	{
		if (!(finalBoneBlend < 0.0001f))
		{
			G_CustomForceAttach = false;
			G_CustomForceNOTDetach = false;
			G_CustomForceDetach = false;
			G_CustomForceNOTAttach = false;
			IK_PreUpdate();
			LegStretchLimit = Owner.LimitLegStretch * LegStretchMultiplier;
		}
	}

	public void PreLateUpdate()
	{
		if (!customOverwritingIKPos && (!_G_WasDisabled || !(finalBoneBlend < 0.0001f)))
		{
			Owner.Modules_LegBeforeRaycastingUpdate(this);
			Raycasting_PreLateUpdate();
			Controll_Calibrate();
		}
	}

	public void LateUpdate()
	{
		if (!(finalBoneBlend < 0.0001f) && !customOverwritingIKPos)
		{
			Owner.Modules_Leg_LateUpdate(this);
			AlignStep_CheckAlignStatePre();
			AlignStep_ValidateFootRotation();
			Gluing_Update();
			Gluing_ApplyCoords();
			AlignStep_OnGroundAlign();
			AlignStep_SmoothSuddenSteps();
			AlignStep_LegElevation();
			AlignStep_Complete();
			Control_StepEventCalcs();
			ExtraProcessingApply();
		}
	}

	public void LateUpdate_Apply()
	{
		IK_PostUpdate();
	}

	public void FixedUpdate()
	{
	}

	public float LegLimbLength()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)BoneStart == (Object)null || (Object)(object)BoneMid == (Object)null || (Object)(object)BoneEnd == (Object)null)
		{
			return Owner.HipsToGroundDistance();
		}
		return 0f + Vector3.Distance(BoneStart.position, BoneMid.position) + Vector3.Distance(BoneEnd.position, BoneMid.position);
	}

	public bool HasAllBonesSet()
	{
		if ((Object)(object)BoneStart == (Object)null)
		{
			return false;
		}
		if ((Object)(object)BoneMid == (Object)null)
		{
			return false;
		}
		if ((Object)(object)BoneEnd == (Object)null)
		{
			return false;
		}
		return true;
	}

	public float R(float toRound, int digits = 2)
	{
		return (float)Math.Round(toRound, digits);
	}

	private void SendStepEvent(float factor = 1f, EStepType type = EStepType.IdleGluing)
	{
		if (!_StepSent)
		{
			if (Owner.GroundedTime < 0.1f)
			{
				type = EStepType.OnLanding;
			}
			else if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
			{
				type = EStepType.OnStopping;
			}
			Owner.Events_OnStep(this, factor, type);
			_StepSent = true;
			_StepSentAt = Time.unscaledTime;
			if (hasOppositeleg)
			{
				_OppositeLegStepped = true;
				GetOppositeLeg()._OppositeLegStepped = !Owner.IsMoving;
			}
		}
	}

	private void SendRaiseEvent(float distanceToNew = 1f)
	{
		if (!(Time.unscaledTime - _RaiseSentAt < 0.05f))
		{
			_RaiseSentAt = Time.unscaledTime;
			EStepType type = EStepType.IdleGluing;
			if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
			{
				type = EStepType.OnStopping;
			}
			Owner.Events_OnRaise(this, distanceToNew, type);
		}
	}

	private void StepEventRestore()
	{
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		if (!Owner.UseEvents || !_StepSent || Time.unscaledTime - _StepSentAt < 0.1f || Owner.GroundedTime < 0.1f)
		{
			return;
		}
		if (Owner.UseGluing)
		{
			if (G_AttachementHandler.glueAnimationBlend > 0.5f && G_GlueInternalTransition > 0.25f)
			{
				return;
			}
			if (Owner._glueModeExecuted == EGlueMode.Idle)
			{
				if (!G_DuringAttaching || (Owner.GlueMode == EGlueMode.Automatic && (Owner.IsMoving || Owner.Helper_WasMoving)) || (!Owner.SendOnStopping && Owner.StoppedTime < 0.155f) || G_AttachementHandler.lasGlueModeOnAttaching != 0 || G_AttachementHandler.legMoveDistanceFactor < 0.05f)
				{
					return;
				}
			}
			else
			{
				if ((Owner.GlueMode == EGlueMode.Automatic && !Owner.IsMoving) || Owner.MovingTime < 0.06f || A_PreWasAligning || A_AligningHelperBlend > 0.5f - Owner.EventExecuteSooner || (hasOppositeleg && !GetOppositeLeg()._OppositeLegStepped))
				{
					return;
				}
				float num = (0f - ScaleRef) * 0.2f + FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.75f + A_LastAlignHeightCompareValue * (3f + Owner.EventExecuteSooner);
				if (A_LastAlignHeightDiff < num)
				{
					return;
				}
			}
		}
		else
		{
			if (A_PreWasAligning || A_AligningHelperBlend > 0.05f)
			{
				return;
			}
			if (Owner.IsMovingBlend < 0.05f)
			{
				_StepSent = true;
				return;
			}
			if (!Owner.Helper_WasMoving)
			{
				_StepSent = true;
				return;
			}
			if (!Owner.IsMoving)
			{
				_StepSent = true;
				return;
			}
		}
		_StepSent = false;
	}

	public void IK_Initialize(bool generateNew = true)
	{
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		if (generateNew)
		{
			IKProcessor = new FimpIK_Limb();
		}
		if (Object.op_Implicit((Object)(object)BoneFeet))
		{
			IKProcessor.SetLegWithFeet(BoneStart, BoneMid, BoneEnd, BoneFeet);
		}
		else
		{
			IKProcessor.SetBones(BoneStart, BoneMid, BoneEnd);
		}
		IKProcessor.Init(Owner.BaseTransform);
		IKProcessor.UseEndBoneMapping = false;
		IKProcessor.IKWeight = 1f;
		IKProcessor.IKPositionWeight = 1f;
		IKProcessor.FootRotationWeight = 1f;
		IKProcessor.ManualHintPositionWeight = 0f;
		IKProcessor.FeetStretchSensitivity = 0.9f;
		IKProcessor.FeetFadeQuicker = 1.1f;
		IKProcessor.FeetStretchLimit = 0.8f;
		IKProcessor.HumanoidAnimator = Owner.Mecanim;
		IKProcessor.IsRight = Side == ELegSide.Right;
		_FinalIKPos = IKProcessor.EndIKBone.transform.position;
		_PreviousFinalIKPos = _FinalIKPos;
		_PreviousFinalIKPosForStability = _FinalIKPos;
		_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_FinalIKPos);
		IKProcessor.IKTargetPosition = _FinalIKPos;
		IKProcessor.IKTargetRotation = _FinalIKRot;
	}

	public void AssignCustomIKProcessor(FimpIK_Limb ik)
	{
		IKProcessor = ik;
		IK_Initialize(generateNew: false);
	}

	public void OverrideTargetIKPosition(Vector3? targetIKPos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!targetIKPos.HasValue)
		{
			customOverwritingIKPos = false;
			return;
		}
		customOverwritingIKPos = true;
		customOverwritePos = targetIKPos.Value;
	}

	public void OverrideTargetIKRotation(Quaternion? targetIKRot)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (!targetIKRot.HasValue)
		{
			if (customOverwritingIKRot)
			{
				IKProcessor.FootRotationWeight = 1f;
			}
			customOverwritingIKRot = false;
		}
		else
		{
			customOverwritingIKRot = true;
			customOverwriteRot = targetIKRot.Value;
		}
	}

	public void OverrideFinalIKPos(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_FinalIKPos = pos;
	}

	public void OverrideFinalAndSourceIKPos(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		_FinalIKPos = pos;
		_SourceIKPos = pos;
	}

	public Vector3 GetFinalIKPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _FinalIKPos;
	}

	public Vector3 GetSourceIKPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _SourceIKPos;
	}

	public Quaternion GetFinalIKRot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _FinalIKRot;
	}

	public Quaternion GetSourceIKRot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _SourceIKRot;
	}

	public void OverrideFinalIKRot(Quaternion rot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_FinalIKRot = rot;
	}

	public void IK_PreUpdate()
	{
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		IKProcessor.CallPreCalibrate = Owner.Calibrate == ECalibrateMode.Calibrate;
		if (!Owner.IsGrounded)
		{
			if (_wasGrounded)
			{
				_ungroundLocalIKCache = ToRootLocalSpace(_PreviousFinalIKPos);
				_wasGrounded = false;
			}
			_SourceIKPos = RootSpaceToWorld(_ungroundLocalIKCache);
			_SourceIKPos = Vector3.Lerp(_SourceIKPos, IKProcessor.EndIKBone.transform.position, 1f - Owner.IsGroundedBlend);
			_ungroundLocalIKCache = ToRootLocalSpace(_SourceIKPos);
			_SourceIKRot = BoneEnd.rotation;
			_SourceIKPosUnchangedY = _SourceIKPos;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
		}
		else
		{
			_wasGrounded = true;
			if (!_overwrittenSourceIKPos)
			{
				_SourceIKPos = IKProcessor.EndIKBone.transform.position;
			}
			else
			{
				_overwrittenSourceIKPos = false;
			}
			_SourceIKRot = BoneEnd.rotation;
			_SourceIKPosUnchangedY = _SourceIKPos;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
		}
	}

	public void IK_PostUpdate()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		if (customOverwritingIKPos)
		{
			_FinalIKPos = customOverwritePos;
			if (customOverwritingIKRot)
			{
				IKProcessor.FootRotationWeight = 1f;
				_FinalIKRot = customOverwriteRot;
			}
			else
			{
				IKProcessor.FootRotationWeight = 0f;
			}
		}
		else if (G_LegAnimation.LegAdjustementFootAngleOffset != 0f || FootPitchOffset != 0f)
		{
			_FinalIKRot = Quaternion.AngleAxis(G_LegAnimation.LegAdjustementFootAngleOffset + FootPitchOffset, _SourceIKRot * AnkleIK.right) * _FinalIKRot;
		}
		if (float.IsNaN(_FinalIKPos.x) || float.IsNaN(_FinalIKPos.y) || float.IsNaN(_FinalIKPos.z))
		{
			Reset();
			_FinalIKPos = RootSpaceToWorld(InitialPosInRootSpace);
			Gluing_Init();
		}
		_PreviousFinalIKPosForStability = _FinalIKPos;
		IKProcessor.IKTargetPosition = _FinalIKPos;
		IKProcessor.IKTargetRotation = _FinalIKRot;
		if (IKProcessor.IKWeight > 0f)
		{
			if (!Owner.UseCustomIK && LegStretchLimit < 1.1f)
			{
				IKProcessor.ApplyMaxStretchingPreprocessing(LegStretchLimit, 3f);
			}
			ExtraIKPostProcessingApply();
			if (!Owner.UseCustomIK)
			{
				IKProcessor.Update();
			}
		}
		_PreviousFinalIKPos = IKProcessor.IKTargetPosition;
		_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_PreviousFinalIKPos);
		if (Owner.AnimateFeet)
		{
			_PreviousFinalIKRot = IKProcessor.IKTargetRotation;
		}
	}

	public void IK_UpdateParamsBase()
	{
		IKProcessor.IKWeight = Owner._MainBlend * LegBlendWeight * InternalModuleBlendWeight;
		BlendWeight = IKProcessor.IKWeight;
		IKProcessor.InverseHint = InverseHint;
	}

	public void IK_UpdateParams()
	{
		IK_UpdateParamsBase();
		IKProcessor.AutoHintMode = Owner.IKHintMode;
		IKProcessor.FeetStretchSensitivity = 0.7f + 0.6f * FeetSensitivity;
		IKProcessor.FeetFadeQuicker = 0.95f + 0.35f * FeetSensitivity;
		IKProcessor.FeetStretchLimit = 0.8f + 0.2f * FeetSensitivity;
		IKProcessor.disableFeet = !UseFeet;
	}

	public void RandomizeIndividualSettings(float from, float to)
	{
		GlueThresholdMultiplier = Random.Range(Mathf.Lerp(from, to, 0.4f), to);
		LegMoveSpeedMultiplier = Random.Range(from, to);
		LegRaiseMultiplier = Random.Range(from, to);
	}

	public void OverrideAnimatorAnklePosition(Vector3 targetPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		_overwrittenSourceIKPos = true;
		_AnimatorEndBonePos = targetPos + (Owner._LastAppliedHipsFinalPosition - ParentHub.LastKeyframePosition);
		_SourceIKPos = _AnimatorEndBonePos;
	}

	public void User_OverrideRaycastHit(Transform tr, bool disableSourceRaycast = true)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!_UsingCustomRaycast)
		{
			_CustomRaycastBlendIn = 0f;
			_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
		}
		_disableSourceRaycast = disableSourceRaycast;
		_UsingCustomRaycast = true;
		RaycastHit hit = default(RaycastHit);
		((RaycastHit)(ref hit)).point = tr.position;
		((RaycastHit)(ref hit)).normal = tr.up;
		_CustomRaycastOnBlendIn(hit);
	}

	public void User_OverrideRaycastHit(RaycastHit hit, bool disableSourceRaycast = true)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!_UsingCustomRaycast)
		{
			_CustomRaycastBlendIn = 0f;
			_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
		}
		_disableSourceRaycast = disableSourceRaycast;
		_UsingCustomRaycast = true;
		_CustomRaycastOnBlendIn(hit);
	}

	public void User_RestoreRaycasting()
	{
		if (_UsingCustomRaycast)
		{
			_CustomRaycastBlendIn = 1f;
		}
		_UsingCustomRaycast = false;
		_disableSourceRaycast = false;
	}

	private void _CustomRaycastOnBlendIn(RaycastHit hit)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		_CustomRaycastBlendIn += Owner.DeltaTime * 6f;
		if (_CustomRaycastBlendIn > 1f)
		{
			_CustomRaycastBlendIn = 1f;
		}
		((RaycastHit)(ref hit)).point = Vector3.LerpUnclamped(_PreviousCustomRaycastingStartIKPos, ((RaycastHit)(ref hit)).point, _CustomRaycastBlendIn);
		_CustomRaycastHit = hit;
		_PreviousCustomRaycastingIKPos = ((RaycastHit)(ref hit)).point;
	}

	private void _CustomRaycastOnBlendOut()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!_UsingCustomRaycast && !(_CustomRaycastBlendIn <= 0f))
		{
			_CustomRaycastBlendIn -= Owner.DeltaTime * 8f;
			if (_CustomRaycastBlendIn < 0f)
			{
				_CustomRaycastBlendIn = 0f;
			}
			if (!RaycastHitted)
			{
				legGroundHit = _CustomRaycastHit;
				return;
			}
			RaycastHit val = legGroundHit;
			((RaycastHit)(ref val)).point = Vector3.LerpUnclamped(((RaycastHit)(ref val)).point, _PreviousCustomRaycastingIKPos, _CustomRaycastBlendIn);
			((RaycastHit)(ref val)).normal = Vector3.SlerpUnclamped(((RaycastHit)(ref val)).normal, ((RaycastHit)(ref _CustomRaycastHit)).normal, _CustomRaycastBlendIn);
			legGroundHit = val;
		}
	}

	private void Raycasting_Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		ankleAlignedOnGroundHitWorldPos = BoneEnd.position;
		raycastSlopeAngle = 0f;
	}

	public void OverrideControlPositionsWithCurrentIKState()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		AnkleH.LastKeyframeRootPos = ToRootLocalSpace(_FinalIKPos);
		_AnimatorEndBonePos = _FinalIKPos;
	}

	public void OverrideSourceIKPos()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		OverrideSourceIKPos(_FinalIKPos);
	}

	public void OverrideSourceIKPos(Vector3 newSrc)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_SourceIKPos = newSrc;
	}

	public void Raycasting_PreLateUpdate()
	{
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		RaycastHitted = false;
		_noRaycast_skipFeetCalcs = false;
		if (!_disableSourceRaycast)
		{
			if (Owner.RaycastStyle == ERaycastStyle.NoRaycasting)
			{
				GenerateZeroFloorRaycastHit();
				CustomRaycastValidate();
				_noRaycast_skipFeetCalcs = true;
				_UsingEmptyRaycast = true;
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
			else
			{
				_UsingEmptyRaycast = false;
				if (Owner.RaycastStyle == ERaycastStyle.StraightDown)
				{
					Raycast_StraightDown();
				}
				else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot)
				{
					Raycast_OriginToFoot();
				}
				else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot_DownOnNeed)
				{
					Raycast_OriginToFoot();
					if (!RaycastHitted)
					{
						Raycast_StraightDown();
					}
				}
				else if (Owner.RaycastStyle == ERaycastStyle.AlongBones)
				{
					Raycast_AlongBones();
					if (!RaycastHitted)
					{
						Raycast_StraightDown();
					}
				}
				if (!RaycastHitted)
				{
					NoRaycastBehaviour();
				}
			}
			User_RaycastHittedSource = RaycastHitted;
			_CustomRaycastOnBlendOut();
		}
		if (_UsingCustomRaycast)
		{
			RaycastHitted = true;
			legGroundHit = _CustomRaycastHit;
			groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
			_UsingEmptyRaycast = true;
			_noRaycast_skipFeetCalcs = true;
			_Raycasting_CalculateBasis();
			ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
		}
		if (!_noRaycast_skipFeetCalcs)
		{
			if (RaycastHitted)
			{
				lastGroundHitWithTarget = legGroundHit;
				ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
			}
			else
			{
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
		}
	}

	private void NoRaycastBehaviour()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.Detach)
		{
			return;
		}
		if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.ZeroFloorSteps)
		{
			_noRaycast_skipFeetCalcs = true;
			_UsingEmptyRaycast = true;
			GenerateZeroFloorRaycastHit();
			ankleAlignedOnGroundHitRotation = _SourceIKRot;
		}
		else if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.KeepAttached)
		{
			if (IKProcessor.GetStretchValue(_PreviousFinalIKPos) > Owner.NoRaycast_KeepAttachedUntilStretch)
			{
				lastGroundHitWithTarget = default(RaycastHit);
			}
			else if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastGroundHitWithTarget)).transform))
			{
				_noRaycast_skipFeetCalcs = true;
				legGroundHit = lastGroundHitWithTarget;
				RaycastHitted = true;
				_Raycasting_CalculateBasis();
				Vector3 val = ToRootLocalSpace(((RaycastHit)(ref lastGroundHitWithTarget)).point);
				val.y = 0f;
				groundHitRootSpacePos = val;
			}
		}
	}

	private void GenerateZeroFloorRaycastHit()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		Vector3 rootLocal = (ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(_SourceIKPos));
		rootLocal.y = 0f;
		Vector3 point = RootSpaceToWorld(rootLocal);
		((RaycastHit)(ref val)).point = point;
		((RaycastHit)(ref val)).normal = Owner.Up;
		legGroundHit = val;
		RaycastHitted = true;
		groundHitRootSpacePos = rootLocal;
	}

	private void CustomRaycastValidate()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		_Raycasting_CalculateBasis();
		raycastSlopeAngle = 0f;
		A_WasAligning = true;
		A_WasAligningFrameBack = true;
		A_LastTargetAlignRot = _SourceIKRot;
		A_LastApppliedAlignRot = _SourceIKRot;
		A_PreviousRelevantAnklePos = _SourceIKPos;
		A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
		A_LastAlignHeightCompareValue = ScaleRef * 0.002f + ParentHub._Hips_StepHeightAdjustOffset;
	}

	private Vector3 Raycast_RefreshOrigin()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
		return lastRaycastingOrigin = RootSpaceToWorld(lastRootLocalPos);
	}

	private void Raycast_OriginToFoot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Raycast_RefreshOrigin();
		Vector3 val2 = RootSpaceToWorld(AnkleH.LastKeyframeRootPos) - Owner.Up * C_AnkleToHeelWorldHeight - val;
		float num = ((Vector3)(ref val2)).magnitude * 1.05f;
		((Vector3)(ref val2)).Normalize();
		Vector3 val3 = val + val2 * num;
		if (Physics.Linecast(val, val3, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger))
		{
			CaptureRaycastHitForLeg();
		}
		else
		{
			ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
		}
	}

	private void Raycast_AlongBones()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		Raycast_RefreshOrigin();
		if (DoRaycasting(_AnimatorStartBonePos, _AnimatorMidBonePos))
		{
			CaptureRaycastHitForLeg();
			return;
		}
		Vector3 rayEnd = _AnimatorEndBonePos + (_AnimatorEndBonePos - _AnimatorMidBonePos) * 0.1f;
		if (DoRaycasting(_AnimatorMidBonePos, rayEnd))
		{
			CaptureRaycastHitForLeg();
		}
		else
		{
			ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
		}
	}

	private void Raycast_StraightDown()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastKeyframeRootPos = AnkleH.LastKeyframeRootPos;
		Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
		float num;
		if (Owner.RaycastStartHeight == ERaycastStartHeight.FirstBone)
		{
			lastRootLocalPos = BoneStart.position;
			num = IKProcessor.fullLength;
		}
		else
		{
			lastRootLocalPos.x = lastKeyframeRootPos.x;
			lastRootLocalPos.z = lastKeyframeRootPos.z;
			num = Owner.ScaleReference * (Owner.RaycastStartHeightMul / Root.lossyScale.y);
			if (Owner.RaycastStartHeight == ERaycastStartHeight.StaticScaleReference)
			{
				lastRootLocalPos.y = num;
			}
			lastRootLocalPos = RootSpaceToWorld(lastRootLocalPos);
		}
		lastRaycastingOrigin = lastRootLocalPos;
		Vector3 val = -Owner.Up;
		Vector3 val2 = lastRootLocalPos + val * num;
		float num2 = ScaleRef * Owner.CastDistance;
		Vector3 rayEnd = (lastRaycastingEndPoint = val2 + val * num2);
		if (DoRaycasting(lastRootLocalPos, rayEnd))
		{
			CaptureRaycastHitForLeg();
		}
		else
		{
			ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
		}
	}

	internal bool DoRaycasting(Vector3 origin, Vector3 rayEnd)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		bool flag;
		if (Owner.RaycastShape == ERaycastMode.Linecast)
		{
			flag = Physics.Linecast(origin, rayEnd, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
		}
		else
		{
			float num = Owner.ScaleReference * 0.065f * Owner.SpherecastResize;
			Vector3 val = rayEnd - origin;
			float num2 = ((Vector3)(ref val)).magnitude - num;
			flag = Physics.SphereCast(origin, num, ((Vector3)(ref val)).normalized, ref legGroundHit, num2 - num, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
			if (flag && Owner.SpherecastRealign > 0f)
			{
				Vector3 val2 = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
				val2.x = Mathf.LerpUnclamped(val2.x, AnkleH.LastKeyframeRootPos.x, Owner.SpherecastRealign);
				val2.z = Mathf.LerpUnclamped(val2.z, AnkleH.LastKeyframeRootPos.z, Owner.SpherecastRealign);
				((RaycastHit)(ref legGroundHit)).point = RootSpaceToWorld(val2);
			}
		}
		return flag;
	}

	private void CaptureRaycastHitForLeg()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		RaycastHitted = true;
		groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
		raycastSlopeAngle = Vector3.Angle(Owner.Up, ((RaycastHit)(ref legGroundHit)).normal);
		if (raycastSlopeAngle > 45f)
		{
			RaycastHit val = legGroundHit;
			((RaycastHit)(ref val)).normal = Vector3.Slerp(((RaycastHit)(ref legGroundHit)).normal, Owner.Up, Mathf.InverseLerp(45f, 90f, raycastSlopeAngle) * 0.5f);
			legGroundHit = val;
		}
		_Raycasting_CalculateBasis();
	}

	private void _Raycasting_CalculateBasis()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		previousAnkleAlignedOnGroundHitWorldPos = ankleAlignedOnGroundHitWorldPos;
		ankleAlignedOnGroundHitWorldPos = GetAlignedOnGroundHitPos(groundHitRootSpacePos, ((RaycastHit)(ref legGroundHit)).point, ((RaycastHit)(ref legGroundHit)).normal);
		ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
	}

	private Vector3 GetAlignedOnGroundHitPos(Vector3 rootSpaceHitPos, Vector3 worldHit, Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Vector3 rootLocal = rootSpaceHitPos;
		rootLocal.y = ToRootLocalSpace(worldHit + normal * C_AnkleToHeelWorldHeight).y;
		return RootSpaceToWorld(rootLocal);
	}

	private Quaternion GetAlignedOnGroundHitRot(Quaternion sourceRotation, Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.FromToRotation(sourceRotation * AnkleIK.up, normal) * sourceRotation;
	}

	private void Stability_Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Vector3 initialPosInRootSpace = ToRootLocalSpace(BoneEnd.position);
		InitialPosInRootSpace = initialPosInRootSpace;
	}

	public void DefineLegSide(LegsAnimator get, Leg knownOppositeLeg = null)
	{
		if (knownOppositeLeg != null && knownOppositeLeg.Side != 0)
		{
			if (knownOppositeLeg.Side == ELegSide.Left)
			{
				Side = ELegSide.Right;
			}
			else
			{
				Side = ELegSide.Left;
			}
		}
		else if ((Object)(object)BoneStart != (Object)null)
		{
			if (get.Util_OnLeftSide(BoneStart))
			{
				Side = ELegSide.Left;
			}
			else
			{
				Side = ELegSide.Right;
			}
		}
	}

	public void AssignOppositeLegIndex(int oppositeIndex)
	{
		if (oppositeIndex != OppositeLegIndex)
		{
			if (Object.op_Implicit((Object)(object)Owner) && Owner.Legs.ContainsIndex(oppositeIndex, falseIfNull: true))
			{
				Owner.Legs[oppositeIndex].OppositeLegIndex = Owner.Leg_GetIndex(this);
			}
			OppositeLegIndex = oppositeIndex;
		}
	}

	public Leg GetOppositeLegReference(LegsAnimator legs)
	{
		if (OppositeLegIndex < 0)
		{
			return null;
		}
		if (!legs.Legs.ContainsIndex(OppositeLegIndex, falseIfNull: true))
		{
			return null;
		}
		return legs.Legs[OppositeLegIndex];
	}

	public void RefreshLegAnkleToHeelAndFeetAndAxes(Transform baseT)
	{
		RefreshLegAnkleToHeelAndFeet(baseT);
		RefreshLegAnkleAxes(baseT);
	}

	public void RefreshLegAnkleToHeelAndFeet(Transform baseT)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)BoneEnd == (Object)null))
		{
			Vector3 position = BoneEnd.position;
			position.y = baseT.position.y;
			AnkleToHeel = BoneEnd.InverseTransformPoint(position);
			AnkleToFeetEnd = BoneEnd.InverseTransformPoint(position + baseT.forward * ScaleRef * 0.15f);
		}
	}

	public void RefreshLegAnkleAxes(Transform baseT)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)BoneEnd))
		{
			Quaternion val = baseT.rotation * Quaternion.Euler(0f, AnkleYawCorrection, 0f);
			AnkleForward = BoneEnd.InverseTransformDirection(val * Vector3.forward);
			AnkleUp = BoneEnd.InverseTransformDirection(val * Vector3.up);
			AnkleRight = BoneEnd.InverseTransformDirection(val * Vector3.right);
		}
	}

	private void EnsureAxesNormalization()
	{
		((Vector3)(ref AnkleRight)).Normalize();
		((Vector3)(ref AnkleUp)).Normalize();
		((Vector3)(ref AnkleForward)).Normalize();
	}
}


using UnityEngine;

private struct GlueAttachement
{
	public RaycastHit AttachHit;

	public Transform AttachedTo;

	public Vector3 PosInAttachementLocal;

	public Vector3 NormalInAttachementLocal;

	public Quaternion RotInAttachementLocal;

	public bool NoTransform { get; private set; }

	public GlueAttachement(Leg leg, RaycastHit legGroundHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		AttachHit = legGroundHit;
		AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
		if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
		{
			NoTransform = true;
			PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
			NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
			RotInAttachementLocal = leg._PreviousFinalIKRot;
			return;
		}
		NoTransform = false;
		PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
		NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
		if (!leg.Owner.AnimateFeet)
		{
			RotInAttachementLocal = Quaternion.identity;
		}
		else
		{
			RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
		}
	}

	internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Vector3 relevantHitPoint = GetRelevantHitPoint();
		return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
	}

	internal Vector3 GetRelevantHitPoint()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform || (Object)(object)AttachedTo == (Object)null)
		{
			return PosInAttachementLocal;
		}
		return AttachedTo.TransformPoint(PosInAttachementLocal);
	}

	internal Vector3 GetRelevantNormal()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform)
		{
			return NormalInAttachementLocal;
		}
		return AttachedTo.TransformDirection(NormalInAttachementLocal);
	}

	internal Quaternion GetRelevantAttachementRotation()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform)
		{
			return RotInAttachementLocal;
		}
		return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
	}

	internal void OverwritePosition(Vector3 legAnimPos)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)AttachedTo == (Object)null)
		{
			PosInAttachementLocal = legAnimPos;
		}
		else
		{
			PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
		}
	}
}


using UnityEngine;

private class GlueAttachementHandler
{
	public class LegTransitionAnimation
	{
		private enum EMoveType
		{
			FromAnimation,
			FromLastAttachement
		}

		private GlueAttachementHandler handler;

		public float LegAdjustementYOffset;

		public float LegAdjustementFootAngleOffset;

		private Vector3 _legSpherizeLocalVector = Vector3.zero;

		private float _legMoveDurMul = 1f;

		private Quaternion baseRotationOnStepUp;

		public float legMoveDistanceFactor;

		private float sd_trProgress;

		private Vector3 previousPositionLocal;

		private Vector3 previousPositionWorld;

		private Quaternion previousRotationWorld;

		private Vector3 lastAppliedGluePosition;

		private Vector3 lastAppliedGluePositionLocal;

		private Quaternion lastAppliedGlueRotation;

		private float lastSpeedup;

		private EMoveType animationMoveType;

		private bool _instantTransition;

		private bool _wasAnimatingLeg;

		private LegsAnimator Owner => handler.Owner;

		private Leg leg => handler.leg;

		public bool duringLegAdjustMovement { get; private set; }

		public bool wasAttaching { get; private set; }

		public bool attached { get; private set; }

		public float transitionProgress { get; private set; }

		public float lastAttachCompleteTime { get; private set; }

		public float transitionProgressLastFrame { get; private set; }

		public EGlueMode LastAnimationGlueMode
		{
			get
			{
				if (animationMoveType != 0)
				{
					return EGlueMode.Idle;
				}
				return EGlueMode.Moving;
			}
		}

		public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			handler = glueTransitionHelper;
			Reset();
		}

		public void Reset()
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			animationMoveType = EMoveType.FromAnimation;
			transitionProgress = 0f;
			transitionProgressLastFrame = 0f;
			baseRotationOnStepUp = Owner.BaseTransform.rotation;
			duringLegAdjustMovement = false;
			wasAttaching = false;
			attached = false;
			_legSpherizeLocalVector = Vector3.zero;
			ReInitialize();
		}

		public void ReInitialize()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			lastAppliedGluePosition = leg._SourceIKPos;
			lastAppliedGlueRotation = leg._SourceIKRot;
			previousPositionWorld = leg._SourceIKPos;
			previousRotationWorld = leg._SourceIKRot;
			previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
		}

		internal void ScheduleInstantTransition()
		{
			_instantTransition = true;
		}

		internal void DoAttaching(bool canAttach)
		{
			if (canAttach != wasAttaching)
			{
				wasAttaching = canAttach;
				if (canAttach)
				{
					OnChangeTargetPosition();
				}
				else
				{
					attached = false;
					if (transitionProgress != 0f)
					{
						OnChangeTargetPosition();
					}
				}
			}
			if (duringLegAdjustMovement && transitionProgress >= 1f)
			{
				duringLegAdjustMovement = false;
			}
		}

		internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
		{
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
			{
				Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
				Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
				if (val.y < val2.y)
				{
					val.y = val2.y;
					legAnimPos = Owner.RootToWorldSpace(val);
				}
			}
			return legAnimPos;
		}

		public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
			Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
			if (legAnimatingSettings.SpherizeTrack.length > 1)
			{
				float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
				val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
			}
			if (Owner.AnimateFeet)
			{
				LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
				LegAdjustementFootAngleOffset /= lastSpeedup;
			}
			float num2 = Owner.ScaleReferenceNoScale * 0.75f;
			float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
			num3 *= num2;
			LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
			_wasAnimatingLeg = true;
			return val;
		}

		internal Vector3 GetTargetPosition()
		{
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0183: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			float glueAnimationBlend = handler.glueAnimationBlend;
			if (animationMoveType == EMoveType.FromAnimation)
			{
				if (glueAnimationBlend < 0.0001f)
				{
					return Owner.RootToWorldSpace(previousPositionLocal);
				}
				Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
				if (transitionProgress < 0.0001f)
				{
					return val;
				}
				Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
				if (transitionProgress > 0.9995f)
				{
					return val2;
				}
				return Vector3.LerpUnclamped(val, val2, transitionProgress);
			}
			Vector3 val3;
			if (leg.Owner.OnlyLocalAnimation)
			{
				val3 = Owner.RootToWorldSpace(previousPositionLocal);
				if (transitionProgress < 0.0001f)
				{
					return val3;
				}
			}
			else
			{
				val3 = previousPositionWorld;
				if (transitionProgress < 0.0001f)
				{
					return val3;
				}
				val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
			}
			Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
			if (transitionProgress >= 1f)
			{
				return val4;
			}
			float num = 1f - transitionProgress;
			return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
		}

		internal void RequireRepose()
		{
			if (attached)
			{
				attached = false;
				OnChangeTargetPosition();
			}
		}

		internal Quaternion GetTargetRotation()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = previousRotationWorld;
			if (transitionProgress < 0.001f)
			{
				return val;
			}
			Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
			if (transitionProgress > 0.9995f)
			{
				return val2;
			}
			return Quaternion.LerpUnclamped(val, val2, transitionProgress);
		}

		internal void OnChangeTargetPosition()
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0223: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0232: Unknown result type (might be due to invalid IL or missing references)
			handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
			baseRotationOnStepUp = Owner.BaseTransform.rotation;
			if (handler.glueAnimationBlend < 0.2f)
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			else if (animationMoveType == EMoveType.FromLastAttachement)
			{
				animationMoveType = EMoveType.FromLastAttachement;
			}
			else if (handler.glueAnimationBlend > 0.75f)
			{
				if (transitionProgress < 0.1f || transitionProgress > 0.9f)
				{
					animationMoveType = EMoveType.FromLastAttachement;
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
				}
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			if (leg.Owner.OnlyLocalAnimation)
			{
				previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
			}
			else
			{
				previousPositionWorld = lastAppliedGluePosition;
			}
			previousRotationWorld = lastAppliedGlueRotation;
			previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
			if (animationMoveType == EMoveType.FromLastAttachement)
			{
				if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
				{
					transitionProgress = 0f;
				}
				Vector3 val = previousPositionWorld;
				Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
				float magnitude = ((Vector3)(ref val2)).magnitude;
				legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
				legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
				Vector3 val3 = ((Vector3)(ref val2)).normalized;
				val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
				((Vector3)(ref val3)).Normalize();
				leg.SendRaiseEvent(magnitude);
				if (legMoveDistanceFactor > 0.0401f)
				{
					_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
					Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
					((Vector3)(ref worldDir)).Normalize();
					_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
					duringLegAdjustMovement = true;
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
					_legSpherizeLocalVector = Vector3.zero;
					duringLegAdjustMovement = false;
				}
			}
			else
			{
				duringLegAdjustMovement = false;
				transitionProgress = 0f;
			}
		}

		public void UpdateAnimation()
		{
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			float num = (Owner.JustGrounded ? 0.2f : 1f);
			float num2 = (Owner.JustGrounded ? 5f : 1f);
			transitionProgressLastFrame = transitionProgress;
			if (_instantTransition)
			{
				_instantTransition = false;
				transitionProgress = 1f;
				lastAttachCompleteTime = Time.time;
			}
			if (!Owner.IsGrounded)
			{
				return;
			}
			if (animationMoveType == EMoveType.FromLastAttachement)
			{
				float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
				float num4 = 1f;
				lastSpeedup = 1f;
				if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
				{
					if (leg.hasOppositeleg)
					{
						Leg oppositeLeg = leg.GetOppositeLeg();
						Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
						if (leg.Owner.OnlyLocalAnimation)
						{
							targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
						}
						float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
						if (stretchValue > leg.LegStretchLimit * 0.95f)
						{
							float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
							if (num5 < 0f)
							{
								num5 = 0f;
							}
							num4 += num5;
						}
						if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
						{
							Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
							float magnitude = ((Vector3)(ref val)).magnitude;
							float num6 = Owner.ScaleReference * 0.4f;
							if (magnitude > num6)
							{
								float num7 = magnitude - num6;
								num4 += num7 / num6 * 2f;
							}
						}
					}
					if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
					{
						float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
						if (num8 > 12f)
						{
							float num9 = Mathf.InverseLerp(30f, 135f, num8);
							num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
							transitionProgress += Owner.DeltaTime * num9 * num2;
						}
					}
					num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
				}
				lastSpeedup = num4;
				transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
				if (transitionProgress > 0.9995f && duringLegAdjustMovement)
				{
					TriggerAttach();
				}
			}
			else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
			{
				TriggerAttach();
			}
			else
			{
				transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
			}
		}

		private void TriggerAttach()
		{
			if (!attached)
			{
				transitionProgress = 1f;
				lastAttachCompleteTime = Time.time;
				attached = leg.Glue_TriggerFinalAttach();
				duringLegAdjustMovement = false;
			}
		}

		public void PostUpdate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			lastAppliedGluePosition = leg._GluePosition;
			lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
			lastAppliedGlueRotation = leg._GlueRotation;
			if (!_wasAnimatingLeg)
			{
				LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
				LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
			}
			else
			{
				_wasAnimatingLeg = false;
			}
		}
	}

	private LegsAnimator Owner;

	private Leg ParentLeg;

	private float _sd_glueAnimationBlend;

	private bool _instantTransition;

	private Vector3 lastGluePosition = Vector3.zero;

	private Quaternion lastGlueRotation = Quaternion.identity;

	public LegTransitionAnimation legMoveAnimation { get; private set; }

	private Leg leg => ParentLeg;

	public float glueAnimationBlend { get; private set; }

	public float attachTransitionProgress => legMoveAnimation.transitionProgress;

	public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

	public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

	public EGlueMode lasGlueModeOnAttaching { get; private set; }

	public GlueAttachementHandler(Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ParentLeg = leg;
		Owner = leg.Owner;
		legMoveAnimation = new LegTransitionAnimation(this);
		lasGlueModeOnAttaching = Owner._glueModeExecuted;
		Reset(initializing: true);
	}

	public void Reset(bool initializing)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		glueAnimationBlend = 0f;
		_sd_glueAnimationBlend = 0f;
		if (initializing)
		{
			lastGluePosition = leg.BoneEnd.position;
			lastGlueRotation = leg.BoneEnd.rotation;
		}
		legMoveAnimation.Reset();
	}

	public void SheduleInstantTransition()
	{
		_instantTransition = true;
		legMoveAnimation.ScheduleInstantTransition();
	}

	public void TransitionToGlueAnimation()
	{
		legMoveAnimation.DoAttaching(canAttach: true);
		ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
	}

	public void TransitionToDisableGlueAnimation()
	{
		legMoveAnimation.DoAttaching(canAttach: false);
		ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
	}

	public Vector3 GetGluePosition()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (glueAnimationBlend > 0.9995f)
		{
			lastGluePosition = legMoveAnimation.GetTargetPosition();
		}
		else if (glueAnimationBlend < 0.0001f)
		{
			lastGluePosition = leg.A_PreIKPosForGluing;
		}
		else
		{
			lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
		}
		return lastGluePosition;
	}

	public Quaternion GetGlueRotation()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (glueAnimationBlend > 0.999f)
		{
			lastGlueRotation = legMoveAnimation.GetTargetRotation();
		}
		else if (glueAnimationBlend < 0f)
		{
			lastGlueRotation = leg._FinalIKRot;
		}
		else
		{
			lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
		}
		return lastGlueRotation;
	}

	public void UpdateTransitioning(bool attaching)
	{
		legMoveAnimation.UpdateAnimation();
	}

	public void PostUpdate()
	{
		legMoveAnimation.PostUpdate();
	}

	internal void OnLegRequireRepose()
	{
		legMoveAnimation.RequireRepose();
	}

	private void ChangeGlueAnimationBlendTo(float target, float speed)
	{
		if (Owner.GroundedTime < 0f)
		{
			speed = 0.99f;
		}
		if (_instantTransition && target > 0f)
		{
			glueAnimationBlend = target;
			_instantTransition = false;
			return;
		}
		if (speed >= 1f)
		{
			glueAnimationBlend = target;
			return;
		}
		if (leg.G_JustLanded)
		{
			glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
		}
		glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
		if (float.IsNaN(_sd_glueAnimationBlend))
		{
			_sd_glueAnimationBlend = 0f;
		}
	}
}


using UnityEngine;

public class LegTransitionAnimation
{
	private enum EMoveType
	{
		FromAnimation,
		FromLastAttachement
	}

	private GlueAttachementHandler handler;

	public float LegAdjustementYOffset;

	public float LegAdjustementFootAngleOffset;

	private Vector3 _legSpherizeLocalVector = Vector3.zero;

	private float _legMoveDurMul = 1f;

	private Quaternion baseRotationOnStepUp;

	public float legMoveDistanceFactor;

	private float sd_trProgress;

	private Vector3 previousPositionLocal;

	private Vector3 previousPositionWorld;

	private Quaternion previousRotationWorld;

	private Vector3 lastAppliedGluePosition;

	private Vector3 lastAppliedGluePositionLocal;

	private Quaternion lastAppliedGlueRotation;

	private float lastSpeedup;

	private EMoveType animationMoveType;

	private bool _instantTransition;

	private bool _wasAnimatingLeg;

	private LegsAnimator Owner => handler.Owner;

	private Leg leg => handler.leg;

	public bool duringLegAdjustMovement { get; private set; }

	public bool wasAttaching { get; private set; }

	public bool attached { get; private set; }

	public float transitionProgress { get; private set; }

	public float lastAttachCompleteTime { get; private set; }

	public float transitionProgressLastFrame { get; private set; }

	public EGlueMode LastAnimationGlueMode
	{
		get
		{
			if (animationMoveType != 0)
			{
				return EGlueMode.Idle;
			}
			return EGlueMode.Moving;
		}
	}

	public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		handler = glueTransitionHelper;
		Reset();
	}

	public void Reset()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		animationMoveType = EMoveType.FromAnimation;
		transitionProgress = 0f;
		transitionProgressLastFrame = 0f;
		baseRotationOnStepUp = Owner.BaseTransform.rotation;
		duringLegAdjustMovement = false;
		wasAttaching = false;
		attached = false;
		_legSpherizeLocalVector = Vector3.zero;
		ReInitialize();
	}

	public void ReInitialize()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		lastAppliedGluePosition = leg._SourceIKPos;
		lastAppliedGlueRotation = leg._SourceIKRot;
		previousPositionWorld = leg._SourceIKPos;
		previousRotationWorld = leg._SourceIKRot;
		previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
	}

	internal void ScheduleInstantTransition()
	{
		_instantTransition = true;
	}

	internal void DoAttaching(bool canAttach)
	{
		if (canAttach != wasAttaching)
		{
			wasAttaching = canAttach;
			if (canAttach)
			{
				OnChangeTargetPosition();
			}
			else
			{
				attached = false;
				if (transitionProgress != 0f)
				{
					OnChangeTargetPosition();
				}
			}
		}
		if (duringLegAdjustMovement && transitionProgress >= 1f)
		{
			duringLegAdjustMovement = false;
		}
	}

	internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
		{
			Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
			Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
			if (val.y < val2.y)
			{
				val.y = val2.y;
				legAnimPos = Owner.RootToWorldSpace(val);
			}
		}
		return legAnimPos;
	}

	public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
		Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
		if (legAnimatingSettings.SpherizeTrack.length > 1)
		{
			float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
			val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
		}
		if (Owner.AnimateFeet)
		{
			LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
			LegAdjustementFootAngleOffset /= lastSpeedup;
		}
		float num2 = Owner.ScaleReferenceNoScale * 0.75f;
		float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
		num3 *= num2;
		LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
		_wasAnimatingLeg = true;
		return val;
	}

	internal Vector3 GetTargetPosition()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		float glueAnimationBlend = handler.glueAnimationBlend;
		if (animationMoveType == EMoveType.FromAnimation)
		{
			if (glueAnimationBlend < 0.0001f)
			{
				return Owner.RootToWorldSpace(previousPositionLocal);
			}
			Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
			if (transitionProgress < 0.0001f)
			{
				return val;
			}
			Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
			if (transitionProgress > 0.9995f)
			{
				return val2;
			}
			return Vector3.LerpUnclamped(val, val2, transitionProgress);
		}
		Vector3 val3;
		if (leg.Owner.OnlyLocalAnimation)
		{
			val3 = Owner.RootToWorldSpace(previousPositionLocal);
			if (transitionProgress < 0.0001f)
			{
				return val3;
			}
		}
		else
		{
			val3 = previousPositionWorld;
			if (transitionProgress < 0.0001f)
			{
				return val3;
			}
			val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
		}
		Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
		if (transitionProgress >= 1f)
		{
			return val4;
		}
		float num = 1f - transitionProgress;
		return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
	}

	internal void RequireRepose()
	{
		if (attached)
		{
			attached = false;
			OnChangeTargetPosition();
		}
	}

	internal Quaternion GetTargetRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = previousRotationWorld;
		if (transitionProgress < 0.001f)
		{
			return val;
		}
		Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
		if (transitionProgress > 0.9995f)
		{
			return val2;
		}
		return Quaternion.LerpUnclamped(val, val2, transitionProgress);
	}

	internal void OnChangeTargetPosition()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
		baseRotationOnStepUp = Owner.BaseTransform.rotation;
		if (handler.glueAnimationBlend < 0.2f)
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		else if (animationMoveType == EMoveType.FromLastAttachement)
		{
			animationMoveType = EMoveType.FromLastAttachement;
		}
		else if (handler.glueAnimationBlend > 0.75f)
		{
			if (transitionProgress < 0.1f || transitionProgress > 0.9f)
			{
				animationMoveType = EMoveType.FromLastAttachement;
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
			}
		}
		else
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		if (leg.Owner.OnlyLocalAnimation)
		{
			previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
		}
		else
		{
			previousPositionWorld = lastAppliedGluePosition;
		}
		previousRotationWorld = lastAppliedGlueRotation;
		previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
		if (animationMoveType == EMoveType.FromLastAttachement)
		{
			if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
			{
				transitionProgress = 0f;
			}
			Vector3 val = previousPositionWorld;
			Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
			float magnitude = ((Vector3)(ref val2)).magnitude;
			legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
			legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
			((Vector3)(ref val3)).Normalize();
			leg.SendRaiseEvent(magnitude);
			if (legMoveDistanceFactor > 0.0401f)
			{
				_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
				Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
				((Vector3)(ref worldDir)).Normalize();
				_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
				duringLegAdjustMovement = true;
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
				_legSpherizeLocalVector = Vector3.zero;
				duringLegAdjustMovement = false;
			}
		}
		else
		{
			duringLegAdjustMovement = false;
			transitionProgress = 0f;
		}
	}

	public void UpdateAnimation()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		float num = (Owner.JustGrounded ? 0.2f : 1f);
		float num2 = (Owner.JustGrounded ? 5f : 1f);
		transitionProgressLastFrame = transitionProgress;
		if (_instantTransition)
		{
			_instantTransition = false;
			transitionProgress = 1f;
			lastAttachCompleteTime = Time.time;
		}
		if (!Owner.IsGrounded)
		{
			return;
		}
		if (animationMoveType == EMoveType.FromLastAttachement)
		{
			float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
			float num4 = 1f;
			lastSpeedup = 1f;
			if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
			{
				if (leg.hasOppositeleg)
				{
					Leg oppositeLeg = leg.GetOppositeLeg();
					Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
					if (leg.Owner.OnlyLocalAnimation)
					{
						targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
					}
					float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
					if (stretchValue > leg.LegStretchLimit * 0.95f)
					{
						float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
						if (num5 < 0f)
						{
							num5 = 0f;
						}
						num4 += num5;
					}
					if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
					{
						Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
						float magnitude = ((Vector3)(ref val)).magnitude;
						float num6 = Owner.ScaleReference * 0.4f;
						if (magnitude > num6)
						{
							float num7 = magnitude - num6;
							num4 += num7 / num6 * 2f;
						}
					}
				}
				if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
				{
					float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
					if (num8 > 12f)
					{
						float num9 = Mathf.InverseLerp(30f, 135f, num8);
						num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
						transitionProgress += Owner.DeltaTime * num9 * num2;
					}
				}
				num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
			}
			lastSpeedup = num4;
			transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
			if (transitionProgress > 0.9995f && duringLegAdjustMovement)
			{
				TriggerAttach();
			}
		}
		else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
		{
			TriggerAttach();
		}
		else
		{
			transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
		}
	}

	private void TriggerAttach()
	{
		if (!attached)
		{
			transitionProgress = 1f;
			lastAttachCompleteTime = Time.time;
			attached = leg.Glue_TriggerFinalAttach();
			duringLegAdjustMovement = false;
		}
	}

	public void PostUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		lastAppliedGluePosition = leg._GluePosition;
		lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
		lastAppliedGlueRotation = leg._GlueRotation;
		if (!_wasAnimatingLeg)
		{
			LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
			LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
		}
		else
		{
			_wasAnimatingLeg = false;
		}
	}
}


private enum EMoveType
{
	FromAnimation,
	FromLastAttachement
}


public enum GlueReposeRequest
{
	None,
	Repose,
	ReposeIfFar
}


using UnityEngine;

public class LegHelper
{
	public Transform Bone;

	public LegHelper Child;

	public Vector3 InitPositionRootSpace;

	public Vector3 LastKeyframeRootPos;

	public LegHelper(Leg leg, Transform bone)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Bone = bone;
		InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
	}

	public void Calibrate(Leg leg, Vector3 wPos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
	}
}


public enum ELegSide
{
	Undefined,
	Left,
	Right
}


using System;
using System.Globalization;
using UnityEngine;

[Serializable]
public class LegStepAnimatingParameters
{
	[Range(0.1f, 1f)]
	[Tooltip("Average duration of the automatic leg animation")]
	public float StepMoveDuration = 0.375f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1.25f, 0.4f, 0.5f, 1f, 1f)]
	[Tooltip("Curve of ik point going towards desired position (just XZ movement, to Y - no leg rise curve)")]
	public AnimationCurve MoveToGoalCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Tooltip("Making foot motion move towards target not in full linear straight towards target motion but adding a bit curve back (positive value) or forward (negative values) making movement a bit more natural")]
	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.4f, 0.6f, 0.9f, 1f)]
	public AnimationCurve SpherizeTrack = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

	[Range(0f, 2f)]
	public float SpherizePower = 0.3f;

	[Range(0f, 1f)]
	[Tooltip("Minimum leg raise height. If distance of target step animation is small, then foot raise is smaller - down to this minimum raise value.")]
	public float MinFootRaise = 0.1f;

	[Range(0f, 1f)]
	[Tooltip("Maximum leg raise height. If distance of target step animation is very big, then foot raise is bigger - up to this maximum raise value.")]
	public float MaxFootRaise = 0.4f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.5f, 1f, 0.5f, 1f)]
	[Tooltip("Raise height step animation curve evaluated on step animation duration.")]
	public AnimationCurve RaiseYAxisCurve;

	[Range(0f, 1f)]
	[Tooltip("Allowing to speed up leg adjusting animation when leg is getting stretched, when opposite leg is requesting adjustement or when main character is rotating in place quickly")]
	[Space(3f)]
	public float AllowSpeedups = 0.4f;

	[Range(0.1f, 1f)]
	[Tooltip("You can allow to use opposite leg before idle glue leg adjustement finishes")]
	public float AllowDetachBefore = 1f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 1f, 0.6f, 0.6f, 1f)]
	[Tooltip("Extra hips push power animation curve evaluated on step animation duration.")]
	public AnimationCurve PushHipsOnMoveCurve;

	[Tooltip("Extra foot ankle rotation animation curve evaluated on step animation duration.")]
	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0f, 1f, 1f, 1f)]
	public AnimationCurve FootRotationCurve;

	public void RefreshDefaultCurves()
	{
		Curves_RefreshMoveToGoalCurve();
		Curves_RefreshRaiseYAxisCurve();
		Curves_RefreshSpherizeTrack();
		Curves_RefreshFootRotationCurve();
		Curves_RefreshPushHipsOnMoveCurve();
	}

	public void Curves_RefreshRaiseYAxisCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		RaiseYAxisCurve = new AnimationCurve();
		RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.505118f, 0.5f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.9110107f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
	}

	public void Curves_RefreshRaiseYAxisCurveSpiderPreset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		RaiseYAxisCurve = new AnimationCurve();
		RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.5943514f, 0.7946472f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
		RaiseYAxisCurve.AddKey(new Keyframe(1f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
	}

	public void Curves_RefreshMoveToGoalCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		MoveToGoalCurve = new AnimationCurve();
		MoveToGoalCurve.AddKey(new Keyframe(0f, 0f, 0f, 0f, 0f, 0.1842105f));
		MoveToGoalCurve.AddKey(new Keyframe(0.4885197f, 0.8972011f, 1.38764f, 1.38764f, 0.3333333f, 0.3333333f));
		MoveToGoalCurve.AddKey(new Keyframe(1f, 1f, 0f, 0f, 0f, 0f));
	}

	public void Curves_RefreshFootRotationCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		FootRotationCurve = new AnimationCurve();
		FootRotationCurve.AddKey(new Keyframe(0f, 0f, 0.5764588f, 0.5764588f, 0f, 0.4956417f));
		FootRotationCurve.AddKey(new Keyframe(0.4378169f, 0.2035736f, -0.2411275f, -0.2411275f, 0.3333333f, 0.4033037f));
		FootRotationCurve.AddKey(new Keyframe(0.7841034f, -0.1339308f, 0.3331003f, 0.3331003f, 0.3333333f, 0.3333333f));
		FootRotationCurve.AddKey(new Keyframe(1f, 0f, 0.3498169f, 0.3498169f, 0.5534658f, 0f));
	}

	public void Curves_RefreshPushHipsOnMoveCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		PushHipsOnMoveCurve = new AnimationCurve();
		PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.383f, 0.3733972f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.7075226f, 0.1460427f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
	}

	public void Curves_RefreshPushHipsOnMoveCurveSpiderPreset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		PushHipsOnMoveCurve = new AnimationCurve();
		PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.320017f, 0.654645f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.6681702f, 0.2174691f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
	}

	public void Curves_RefreshSpherizeTrack()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		SpherizeTrack = new AnimationCurve();
		SpherizeTrack.AddKey(new Keyframe(0f, 0f, 0.6958197f, 0.6958197f, 0f, 0.460011f));
		SpherizeTrack.AddKey(new Keyframe(0.4f, 0.3f, -0.04204308f, -0.04204308f, 0.333f, 0.3410656f));
		SpherizeTrack.AddKey(new Keyframe(0.85f, 0f, -0.2721428f, -0.2721428f, 0.3953607f, 0f));
	}

	public void LogCurve(string name, AnimationCurve c)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		string text = "";
		IFormatProvider invariantCulture = CultureInfo.InvariantCulture;
		for (int i = 0; i < c.keys.Length; i++)
		{
			Keyframe val = c.keys[i];
			text = text + "\n" + name + ".AddKey(new Keyframe(" + ((Keyframe)(ref val)).time.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).value.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inWeight.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outWeight.ToString(invariantCulture) + "f));";
		}
		Debug.Log((object)text);
	}
}


using UnityEngine;

public enum EGlueMode
{
	[Tooltip("Idle Mode is applying leg animation with extra motion and is checking some extra conditions like opposite leg grounded state etc.")]
	Idle,
	[Tooltip("Moving Mode is dedicated to be applied during playing animations with dynamic legs, it's checking less conditions than Idle Mode and is snapping glue points in a more straight forward slide animation.")]
	Moving,
	[Tooltip("Automatic mode is syncing with IsMoving/IsIdling LegsAnimator flags.")]
	Automatic
}


using System;
using UnityEngine;

[Serializable]
public class Variable
{
	public enum EVariableType
	{
		Number,
		Bool,
		Vector2,
		Vector3,
		String,
		Curve,
		UnityObject,
		CustomObject
	}

	public string VariableName = "Variable";

	[SerializeField]
	private string Tooltip = "";

	private bool _tooltipWasSet;

	[SerializeField]
	private Vector4 _value = Vector4.zero;

	[SerializeField]
	private string _string = "";

	[SerializeField]
	private AnimationCurve _curve;

	[SerializeField]
	private Object _uObject;

	[SerializeField]
	private object _object;

	[NonSerialized]
	private int nameHash;

	public EVariableType VariableType;

	[SerializeField]
	private Vector4 _rangeHelper = Vector4.zero;

	public bool TooltipAssigned => _tooltipWasSet;

	public int GetNameHash
	{
		get
		{
			if (nameHash == 0)
			{
				nameHash = VariableName.GetHashCode();
			}
			return nameHash;
		}
	}

	public void AssignTooltip(string tooltip)
	{
		if (!_tooltipWasSet)
		{
			Tooltip = tooltip;
			_tooltipWasSet = true;
		}
	}

	public Variable(string name, object value)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		VariableName = name;
		SetValue(value);
	}

	public void SetValue(object o)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (o is int)
		{
			_value = new Vector4((float)(int)o, 0f, 0f, 1f);
			VariableType = EVariableType.Number;
		}
		else if (o is float)
		{
			_value = new Vector4((float)o, 0f, 0f, 0f);
			VariableType = EVariableType.Number;
		}
		else if (o is bool)
		{
			if ((bool)o)
			{
				_value.x = 1f;
			}
			else
			{
				_value.x = 0f;
			}
			VariableType = EVariableType.Bool;
		}
		else if (o is Vector2 val)
		{
			_value = Vector4.op_Implicit(val);
			VariableType = EVariableType.Vector2;
		}
		else if (o is Vector3 val2)
		{
			_value = Vector4.op_Implicit(val2);
			VariableType = EVariableType.Vector3;
		}
		else if (o is string)
		{
			_string = o as string;
			VariableType = EVariableType.String;
		}
		else if (o is AnimationCurve)
		{
			_curve = (AnimationCurve)((o is AnimationCurve) ? o : null);
			VariableType = EVariableType.Curve;
		}
		else if (o is Object)
		{
			_uObject = (Object)((o is Object) ? o : null);
			VariableType = EVariableType.UnityObject;
		}
		else
		{
			_object = o;
			VariableType = EVariableType.CustomObject;
		}
	}

	public int GetInt()
	{
		return (int)_value.x;
	}

	public float GetFloat()
	{
		return _value.x;
	}

	public bool GetBool()
	{
		return _value.x == 1f;
	}

	public Vector2 GetVector2()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(_value.x, _value.y);
	}

	public Vector3 GetVector3()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(_value.x, _value.y, _value.z);
	}

	public string GetString()
	{
		return _string;
	}

	public AnimationCurve GetCurve()
	{
		return _curve;
	}

	public Object GetUnityObject()
	{
		return _uObject;
	}

	public object GetObject()
	{
		return _object;
	}

	public void SetMinMaxSlider(float min, float max)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		_rangeHelper = new Vector4(min, max, 0f, 0f);
	}

	public void SetCurveFixedRange(float startTime, float startValue, float endTime, float endValue)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		_rangeHelper = new Vector4(startTime, startValue, endTime, endValue);
	}

	public bool Editor_DisplayVariableGUI()
	{
		return false;
	}
}


public enum EVariableType
{
	Number,
	Bool,
	Vector2,
	Vector3,
	String,
	Curve,
	UnityObject,
	CustomObject
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ReferencePose
{
	[Serializable]
	public class LegPoseReference
	{
		public BonePoseReference UpperLegPose = new BonePoseReference();

		public BonePoseReference LowerLegPose = new BonePoseReference();

		public BonePoseReference AnklePose = new BonePoseReference();

		public BonePoseReference FeetPose = new BonePoseReference();

		public void SaveLegPose(Leg leg, LegsAnimator animator)
		{
			UpperLegPose.SavePose(leg.BoneStart, animator);
			LowerLegPose.SavePose(leg.BoneMid, animator);
			AnklePose.SavePose(leg.BoneEnd, animator);
			FeetPose.SavePose(leg.BoneFeet, animator);
		}

		public void RestoreLegPose(LegsAnimator animator)
		{
			UpperLegPose.RestorePose(animator);
			LowerLegPose.RestorePose(animator);
			AnklePose.RestorePose(animator);
			FeetPose.RestorePose(animator);
		}
	}

	[Serializable]
	public class BonePoseReference
	{
		public Transform SourceTransform;

		public Quaternion RotationInRoot;

		public Vector3 PositionInRoot;

		public void SavePose(Transform transform, LegsAnimator animator)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
			{
				SourceTransform = transform;
				PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
				RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
			}
		}

		public void RestorePose(LegsAnimator animator)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
			{
				SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
				SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
			}
		}
	}

	public BonePoseReference MainHipsPose = new BonePoseReference();

	public List<BonePoseReference> HipsPoses = new List<BonePoseReference>();

	public List<LegPoseReference> LegPoses = new List<LegPoseReference>();

	public bool IsSet(LegsAnimator animator)
	{
		if ((Object)(object)MainHipsPose.SourceTransform != (Object)null && HipsPoses.Count == animator.ExtraHipsHubs.Count)
		{
			return LegPoses.Count == animator.Legs.Count;
		}
		return false;
	}

	public void TweakListsFor(LegsAnimator animator)
	{
		while (HipsPoses.Count > animator.ExtraHipsHubs.Count)
		{
			HipsPoses.RemoveAt(HipsPoses.Count - 1);
		}
		while (HipsPoses.Count < animator.ExtraHipsHubs.Count)
		{
			HipsPoses.Add(new BonePoseReference());
		}
		while (LegPoses.Count > animator.Legs.Count)
		{
			LegPoses.RemoveAt(LegPoses.Count - 1);
		}
		while (LegPoses.Count < animator.Legs.Count)
		{
			LegPoses.Add(new LegPoseReference());
		}
	}

	public void Clear()
	{
		MainHipsPose.SourceTransform = null;
		HipsPoses.Clear();
		LegPoses.Clear();
	}
}


using System;

[Serializable]
public class LegPoseReference
{
	public BonePoseReference UpperLegPose = new BonePoseReference();

	public BonePoseReference LowerLegPose = new BonePoseReference();

	public BonePoseReference AnklePose = new BonePoseReference();

	public BonePoseReference FeetPose = new BonePoseReference();

	public void SaveLegPose(Leg leg, LegsAnimator animator)
	{
		UpperLegPose.SavePose(leg.BoneStart, animator);
		LowerLegPose.SavePose(leg.BoneMid, animator);
		AnklePose.SavePose(leg.BoneEnd, animator);
		FeetPose.SavePose(leg.BoneFeet, animator);
	}

	public void RestoreLegPose(LegsAnimator animator)
	{
		UpperLegPose.RestorePose(animator);
		LowerLegPose.RestorePose(animator);
		AnklePose.RestorePose(animator);
		FeetPose.RestorePose(animator);
	}
}


using System;
using UnityEngine;

[Serializable]
public class BonePoseReference
{
	public Transform SourceTransform;

	public Quaternion RotationInRoot;

	public Vector3 PositionInRoot;

	public void SavePose(Transform transform, LegsAnimator animator)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
		{
			SourceTransform = transform;
			PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
			RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
		}
	}

	public void RestorePose(LegsAnimator animator)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
		{
			SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
			SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
		}
	}
}


public enum ELegsScaleReference
{
	PelvisToGroundDistance,
	FirstLegLength,
	Custom,
	PelvisLegAverage
}


using UnityEngine;

public enum ECalibrateMode
{
	[Tooltip("No Extra overhead")]
	None,
	[Tooltip("Resetting bones local rotations to the initialized state")]
	Calibrate,
	[Tooltip("Resetting bones local rotations to the captured animator state (can fix trigger colliders detection when colliders added on legs)")]
	FixedCalibrate
}


public enum ERaycastPrecision
{
	Linecast,
	BoxcastPrecision
}


using UnityEngine;

public enum ERaycastStartHeight
{
	[Tooltip("Casting ray starting from current hips height position of the character. Can be bad for insect creatures!")]
	Hips,
	[Tooltip("Good for spiders! Casting raycast on defined height of the character")]
	StaticScaleReference,
	[Tooltip("Casting ray starting from first bone of the leg (it's affecting height + start raycast position).")]
	FirstBone
}


using UnityEngine;

public enum ERaycastStyle
{
	[Tooltip("Launching raycast from foot above origin point. Good for bipeds with whole body step down/up features.")]
	StraightDown,
	[Tooltip("Launching raycast from pelvis towards foot, good for spider like creatures to detect steep ground more effectively. Body step down/up will not work as precise with this option.")]
	OriginToFoot,
	[Tooltip("Doing raycast like OriginToFoot : but if no ground is found - using another raycast in StraightDown style to find ground below and allow to execute body step down/up feature.")]
	OriginToFoot_DownOnNeed,
	[Tooltip("Doing raycasts per bone : from start bone towards mid bone, mid bone towards end bone, then down. Best precision for insect creatures.")]
	AlongBones,
	[Tooltip("No Raycasting : provide raycast hits custom using code, or leave it custom for just gluing legs animation.")]
	NoRaycasting
}


public enum ERaycastMode
{
	Linecast,
	Spherecast
}


using UnityEngine;

public enum ENoRaycastBehviour
{
	[Tooltip("If ground raycast is lost, leg will detach and switch to ungrounded state")]
	Detach,
	[Tooltip("If no raycast hit detected, should character still animate leg steps in air on zero height floor level? (fake floor)")]
	ZeroFloorSteps,
	[Tooltip("If ground raycast is lost, leg will stick to lastest found raycast hit until leg get stretched")]
	KeepAttached
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public abstract class LAM_FadeOnAnimatorStatusBase : LegsAnimatorControlModuleBase
{
	private enum ELayerSelectMode
	{
		ByIndex,
		Auto
	}

	private LegsAnimator.Variable _fadeSpeedV;

	private LegsAnimator.Variable _layerV;

	private float enabledMultiplier = 1f;

	private float sd_eneMul;

	private List<int> stateHashes;

	private List<int> tagHashes;

	private LegsAnimator.Variable _layerMode;

	private LegsAnimator.Variable _layerSkip;

	private List<int> layersToCheck;

	private int lastAutoWeightIndex;

	private bool InitLayerCheck(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)helper.Parent.Mecanim == (Object)null)
		{
			return false;
		}
		if (_layerMode.GetInt() == 0)
		{
			return false;
		}
		if (_layerMode == null || _layerSkip == null)
		{
			return false;
		}
		layersToCheck = new List<int>();
		string[] array = _layerSkip.GetString().Split(',');
		for (int i = 0; i < helper.Parent.Mecanim.layerCount; i++)
		{
			layersToCheck.Add(i);
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (int.TryParse(array[j], out var result))
			{
				layersToCheck.Remove(result);
				continue;
			}
			int num = -1;
			for (int k = 0; k < helper.Parent.Mecanim.layerCount; k++)
			{
				if (helper.Parent.Mecanim.GetLayerName(k) == array[j])
				{
					num = k;
					break;
				}
			}
			if (num != -1)
			{
				layersToCheck.Remove(num);
			}
		}
		return true;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)base.LA.Mecanim == (Object)null)
		{
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: Not found animator reference in legs animator Extra/Control!");
			helper.Enabled = false;
			return;
		}
		_layerV = helper.RequestVariable("Animation Layer", 0);
		_fadeSpeedV = helper.RequestVariable("Fade Speed", 0.75f);
		LegsAnimator.Variable variable = helper.RequestVariable("Animation State Tag", "");
		string[] array = helper.RequestVariable("Animation State Name", "").GetString().Split(',');
		stateHashes = new List<int>();
		if (array.Length != 0)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (!string.IsNullOrWhiteSpace(array[i]))
				{
					stateHashes.Add(Animator.StringToHash(array[i]));
				}
			}
		}
		string[] array2 = variable.GetString().Split(',');
		tagHashes = new List<int>();
		if (array2.Length != 0)
		{
			for (int j = 0; j < array2.Length; j++)
			{
				if (!string.IsNullOrWhiteSpace(array2[j]))
				{
					tagHashes.Add(Animator.StringToHash(array2[j]));
				}
			}
		}
		if (stateHashes.Count == 0 && tagHashes.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No assigned animation state names/tags to control module on!");
			return;
		}
		if (_layerV.GetInt() < 0)
		{
			_layerV.SetValue(0);
		}
		if (_layerV.GetInt() > base.LA.Mecanim.layerCount - 1)
		{
			_layerV.SetValue(base.LA.Mecanim.layerCount - 1);
		}
		_layerMode = helper.RequestVariable("Mode", 0);
		_layerSkip = helper.RequestVariable("Skip", "");
		if (_layerMode.GetInt() == 1 && !InitLayerCheck(helper))
		{
			_layerMode.SetValue(0);
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Animator mecanim = base.LA.Mecanim;
		if ((Object)(object)mecanim == (Object)null)
		{
			return;
		}
		int num = _layerV.GetInt();
		if (_layerMode.GetInt() == 1)
		{
			float num2 = 0f;
			int num3 = -1;
			for (int num4 = layersToCheck.Count - 1; num4 >= 0; num4--)
			{
				int num5 = layersToCheck[num4];
				float layerWeight = helper.Parent.Mecanim.GetLayerWeight(num5);
				if (layerWeight > 0.95f)
				{
					num3 = num5;
					break;
				}
				if (layerWeight > num2)
				{
					num2 = layerWeight;
					num3 = num5;
				}
			}
			num = (lastAutoWeightIndex = num3);
		}
		AnimatorStateInfo val = (mecanim.IsInTransition(num) ? mecanim.GetNextAnimatorStateInfo(num) : mecanim.GetCurrentAnimatorStateInfo(num));
		bool flag = false;
		for (int i = 0; i < stateHashes.Count; i++)
		{
			if (((AnimatorStateInfo)(ref val)).shortNameHash == stateHashes[i])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int j = 0; j < tagHashes.Count; j++)
			{
				if (((AnimatorStateInfo)(ref val)).tagHash == tagHashes[j])
				{
					flag = true;
					break;
				}
			}
		}
		float num6 = 0.3f - _fadeSpeedV.GetFloat() * 0.299f;
		if (flag)
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, -0.001f, ref sd_eneMul, num6 * 0.9f, 100000f, base.LA.DeltaTime);
		}
		else
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, 1.01f, ref sd_eneMul, num6, 100000f, base.LA.DeltaTime);
		}
		enabledMultiplier = Mathf.Clamp01(enabledMultiplier);
		OnFadeAction(helper, enabledMultiplier);
	}

	protected abstract void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue);
}


private enum ELayerSelectMode
{
	ByIndex,
	Auto
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public abstract class LegsAnimatorControlModuleBase : ScriptableObject
{
	protected Transform Transform => Owner.BaseTransform;

	protected LegsAnimator LA => Owner;

	protected LegsAnimator LegsAnim => Owner;

	protected LegsAnimator Owner { get; private set; }

	protected bool Initialized { get; private set; }

	public virtual bool AskForSpineBone => false;

	public virtual bool AskForChestBone => false;

	public float ModuleBlend { get; set; }

	public float EffectBlend => ModuleBlend * LA._MainBlend;

	public void Base_Init(LegsAnimator legs, LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		ModuleBlend = 1f;
		Owner = legs;
		OnInit(helper);
		Initialized = true;
	}

	public virtual void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnValidateAfterManualChanges(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
	}

	public virtual void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
	}
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AnimationCurvesGlueCondition : LegsAnimatorControlModuleBase
{
	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_FloorValueBelow;

	private LegsAnimator.Variable _play_IgnoreMidConditions;

	private LegsAnimator.Variable _play_AllowHeightGlueOnLevels;

	private List<int> animatorHashes;

	private bool initialized;

	private LegsAnimator.Variable FloorValueBelowVar => _useHelper.RequestVariable("Floor Value Below", 0.01f);

	private LegsAnimator.Variable IgnoreMidConditionsVar => _useHelper.RequestVariable("Ignore Mid Conditions", false);

	private LegsAnimator.Variable AllowHeightGlueOnLevelVar => _useHelper.RequestVariable("Allow Height Glue On Level", -1f);

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (!((Object)(object)base.LA.Mecanim == (Object)null) && helper.customStringList != null)
		{
			_useHelper = helper;
			_play_FloorValueBelow = FloorValueBelowVar;
			_play_IgnoreMidConditions = IgnoreMidConditionsVar;
			_play_AllowHeightGlueOnLevels = AllowHeightGlueOnLevelVar;
			animatorHashes = new List<int>();
			for (int i = 0; i < base.LA.Legs.Count && i < helper.customStringList.Count; i++)
			{
				animatorHashes.Add(Animator.StringToHash(helper.customStringList[i]));
			}
			initialized = true;
		}
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		if (!initialized || leg.G_CustomForceAttach)
		{
			return;
		}
		float num = base.LA.Mecanim.GetFloat(animatorHashes[leg.PlaymodeIndex]);
		if (num <= _play_AllowHeightGlueOnLevels.GetFloat() && leg.A_PreWasAligning)
		{
			num = _play_FloorValueBelow.GetFloat() - 0.01f;
		}
		if (num <= _play_FloorValueBelow.GetFloat())
		{
			leg.G_CustomForceAttach = base.LA.GroundedTime > 0.2f;
			if (_play_IgnoreMidConditions.GetBool())
			{
				leg.G_CustomForceNOTDetach = true;
			}
		}
		else
		{
			leg.G_CustomForceNOTAttach = true;
			if (_play_IgnoreMidConditions.GetBool())
			{
				leg.G_CustomForceDetach = true;
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AutoGroundAlignBodyMatrix : LegsAnimatorControlModuleBase
{
	private Vector3 averageNormal;

	private Vector3 animatedAverageNormal;

	private Quaternion lastOrientation;

	private LegsAnimator.Variable _blendV;

	private LegsAnimator.Variable _rotateV;

	private LegsAnimator.Variable _alignSpdV;

	private LegsAnimator.Variable _alignDownV;

	private LegsAnimator.Variable _AxisBlendV;

	private float _blend = 1f;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		animatedAverageNormal = base.LA.Up;
		lastOrientation = base.LA.BaseTransform.rotation;
		_blendV = helper.RequestVariable("Matrix Blend", 1f);
		_rotateV = helper.RequestVariable("Rotate Hips", 1f);
		_alignSpdV = helper.RequestVariable("Aligning Speed", 0.7f);
		_alignDownV = helper.RequestVariable("Spine Restore", 0.5f);
		_AxisBlendV = helper.RequestVariable("Rotation Axis Blend", Vector3.one);
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		_blend = base.EffectBlend;
		if (leg.RaycastHitted)
		{
			Vector3 val = averageNormal;
			RaycastHit lastGroundHit = leg.LastGroundHit;
			averageNormal = val + ((RaycastHit)(ref lastGroundHit)).normal;
		}
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = lastOrientation;
		float num = _blend * _blendV.GetFloat();
		if (num < 1f)
		{
			val = Quaternion.SlerpUnclamped(Quaternion.identity, lastOrientation, num);
		}
		Matrix4x4 mx = Matrix4x4.TRS(base.LA.BaseTransform.position, val * base.LA.BaseTransform.rotation, base.LA.BaseTransform.lossyScale);
		base.LA.User_OverwriteCastMatrix(mx);
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		float num = _blend * _rotateV.GetFloat();
		if (!(num < 0.001f))
		{
			Vector3 eulerAngles = ((Quaternion)(ref lastOrientation)).eulerAngles;
			eulerAngles.x = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.x);
			eulerAngles.y = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.y);
			eulerAngles.z = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.z);
			Quaternion identity = Quaternion.identity;
			identity *= Quaternion.AngleAxis(eulerAngles.x * num, Vector3.right);
			identity *= Quaternion.AngleAxis(eulerAngles.y * num, Vector3.up);
			identity *= Quaternion.AngleAxis(eulerAngles.z * num, Vector3.forward);
			LegsAnimator lA = base.LA;
			lA._LastHipsRotationOffsetOutsideInfo *= identity;
			if (Object.op_Implicit((Object)(object)base.LA.SpineBone))
			{
				Quaternion rotation = base.LA.SpineBone.rotation;
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
				base.LA.SpineBone.rotation = Quaternion.Slerp(base.LA.SpineBone.rotation, rotation, _alignDownV.GetFloat());
			}
			else
			{
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
			}
		}
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		if (averageNormal == Vector3.zero)
		{
			averageNormal = base.LA.Up;
		}
		else
		{
			((Vector3)(ref averageNormal)).Normalize();
		}
		if (_alignSpdV.GetFloat() < 0.999f)
		{
			float num = Mathf.LerpUnclamped(5f, 20f, _alignSpdV.GetFloat());
			animatedAverageNormal = Vector3.Slerp(animatedAverageNormal, averageNormal, base.LA.DeltaTime * num);
		}
		else
		{
			animatedAverageNormal = averageNormal;
		}
		lastOrientation = Quaternion.FromToRotation(Vector3.up, animatedAverageNormal);
		Vector3 vector = _AxisBlendV.GetVector3();
		if (vector != Vector3.one)
		{
			Vector3 eulerAngles = ((Quaternion)(ref lastOrientation)).eulerAngles;
			vector = helper.Parent.BaseTransform.TransformDirection(vector);
			lastOrientation = Quaternion.Euler(eulerAngles.x * vector.x, eulerAngles.y * vector.y, eulerAngles.z * vector.z);
		}
		averageNormal = Vector3.zero;
	}
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_BasicPoseAdjust : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _AdjustPowerX;

	private LegsAnimator.Variable _AdjustPowerZ;

	[NonSerialized]
	private LegsAnimator.Leg[] legs;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_AdjustPowerX = helper.RequestVariable("Adjust X Positioning", 1f);
		_AdjustPowerZ = helper.RequestVariable("Adjust Z Positioning", 1f);
		List<LegsAnimator.Leg> list = new List<LegsAnimator.Leg>();
		if (helper.customStringList == null || helper.customStringList.Count == 0)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				list.Add(base.LA.Legs[i]);
			}
		}
		else
		{
			for (int j = 0; j < helper.customStringList.Count; j++)
			{
				if (helper.customStringList[j] == "1")
				{
					list.Add(base.LA.Legs[j]);
				}
			}
		}
		if (list.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
		}
		else
		{
			legs = list.ToArray();
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (legs == null)
		{
			return;
		}
		float effectBlend = base.EffectBlend;
		for (int i = 0; i < legs.Length; i++)
		{
			LegsAnimator.Leg leg = legs[i];
			Vector3 val = base.LA.ToRootLocalSpace(leg._AnimatorEndBonePos);
			Vector3 val2 = val;
			val2.x *= _AdjustPowerX.GetFloat();
			val2.z *= _AdjustPowerZ.GetFloat();
			if (effectBlend < 1f)
			{
				val2 = Vector3.LerpUnclamped(val, val2, effectBlend);
			}
			leg.OverrideAnimatorAnklePosition(base.LA.RootToWorldSpace(val2));
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_DesiredDirectionFromTransform : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _Reaction;

	private LegsAnimator.Variable _Thres;

	private LegsAnimator.Variable _IsMov;

	private Vector3 calculatedVelo = Vector3.zero;

	private Vector3 _sd_average = Vector3.zero;

	private Vector3 previousPosition = Vector3.zero;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		_Reaction = helper.RequestVariable("Reaction Speed", 0.8f);
		_IsMov = helper.RequestVariable("Control 'IsMoving'", false);
		_Thres = helper.RequestVariable("Not Moving Threshold", 0.2f);
		previousPosition = base.LA.BaseTransform.position;
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = base.LA.BaseTransform.position - previousPosition;
		previousPosition = base.LA.BaseTransform.position;
		Vector3 val2 = val / base.LA.DeltaTime;
		val2 = base.LA.ToRootLocalSpaceVec(val2);
		val2.y = 0f;
		val2 = base.LA.RootToWorldSpaceVec(val2);
		float magnitude = ((Vector3)(ref calculatedVelo)).magnitude;
		val2 = Vector3.Slerp(val2, ((Vector3)(ref val2)).normalized, Mathf.InverseLerp(0f, magnitude, base.LA.ScaleReference));
		calculatedVelo = Vector3.SmoothDamp(calculatedVelo, val2, ref _sd_average, 5E-05f + (1f - _Reaction.GetFloat()) * 0.15f, 100000f, base.LA.DeltaTime);
		if (_IsMov.GetBool())
		{
			base.LA.User_SetIsMoving(magnitude > base.LA.ScaleReference * _Thres.GetFloat());
		}
		base.LA.User_SetDesiredMovementDirection(calculatedVelo);
	}
}


using System;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_DirectionalMovement", menuName = "FImpossible Creations/Legs Animator/Module - 360 Movement Animation", order = 2)]
public class LAM_DirectionalMovement : LegsAnimatorControlModuleBase
{
	[Serializable]
	public class AnglesSetup
	{
		public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips rotations on reaching 45 angle movement")]
		public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

		[Tooltip(" Hips rotations on reaching 90 angle movement")]
		public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

		[Tooltip(" Hips rotations on reaching 135 angle movement")]
		public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

		[Tooltip(" Hips rotations on reaching 180 angle movement")]
		public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

		[Space(8f)]
		public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips position offset on reaching 45 angle movement")]
		public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

		[Tooltip(" Hips position offset on reaching 90 angle movement")]
		public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

		[Tooltip(" Hips position offset on reaching 135 angle movement")]
		public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

		[Tooltip(" Hips position offset on reaching 180 angle movement")]
		public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

		[Space(8f)]
		public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

		[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

		[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

		[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
	}

	private class LegRedirectHelper
	{
		private LAM_DirectionalMovement parent;

		private LegsAnimator.Leg leg;

		internal LegRedirectHelper oppositeHelper;

		private Vector3 computedPosLocal = Vector3.zero;

		private Quaternion _footRedirCache = Quaternion.identity;

		private LegsAnimator LA => parent.LA;

		public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

		public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			this.parent = parent;
			this.leg = leg;
			LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
			computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
		}

		public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_027a: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			float @float = parent._play_TrDur.GetFloat();
			Vector3 val = parent._calc_LocalRotDir * localPos;
			float num = Vector3.Magnitude(val - computedPosLocal);
			float num2 = num / leg.Owner.ScaleReferenceNoScale;
			float num3 = 0f;
			if (num > 0.2f)
			{
				num3 = Mathf.InverseLerp(0.2f, 1f, num);
				num3 *= 0.1f;
				if (@float < 0.1f)
				{
					num3 *= @float / 0.1f;
				}
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				Vector3 val2 = localPos;
				val2.x *= -1f;
				Vector3 val3 = parent._calc_LocalRotDir * val2;
				val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
			}
			float num4 = 0f;
			if (!(smoother >= 3f))
			{
				if (smoother > 0f)
				{
					if (num2 < 0.1f / smoother)
					{
						computedPosLocal = val;
					}
					else
					{
						num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
					}
					num4 = Mathf.Max(0f, num4);
				}
				else
				{
					computedPosLocal = val;
				}
			}
			computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
			if (parent._var_raiseLimit > 0f)
			{
				float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
				float num5 = 0f;
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
				}
				if (parent._calc_toNegativeXProgress > 0f)
				{
					num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
				}
				computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
			}
			LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
			return computedPosLocal;
		}

		internal Quaternion FootRedirectSmoother(Quaternion target)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
			return _footRedirCache;
		}
	}

	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_HipsRedir;

	private LegsAnimator.Variable _play_FeetRedir;

	private LegsAnimator.Variable _play_KneesRedir;

	private LegsAnimator.Variable _play_TrDur;

	private LegsAnimator.Variable _play_LimitRaise;

	private LegsAnimator.Variable _play_FixFeet;

	private LegsAnimator.Variable _play_AdjustStretch;

	private LegsAnimator.Variable _play_RestoreSpine;

	private LegsAnimator.Variable _play_Smoother;

	private LegsAnimator.Variable _play_reAdj;

	private LegsAnimator.Variable _play_offInAir;

	private int _hash_xDir = -1;

	private int _hash_zDir = -1;

	private Vector3 _calc_WorldDir = Vector3.zero;

	private Vector3 _calc_LocalDir = Vector3.zero;

	private Quaternion _calc_LocalRotDir = Quaternion.identity;

	private float _localTargetAngle;

	private float _wrappedAngle;

	private float _smoothedWrappedAngle;

	private float _calc_smoothedTargetAngle;

	private float _calc_angleDiffFactor;

	private float _calc_toNegativeXProgress;

	internal float _calc_backAngleOff;

	private float _calc_sideFactorL;

	private float _calc_sideFactorR;

	internal float _calc_sideFactor;

	private float _calc_deltaSpeed;

	private float _calc_deltaSpeedSlow;

	private float _var_raiseLimit;

	private float _var_fixFeet;

	private Vector3 _calc_hipsPositionOffsets = Vector3.zero;

	private Vector3 _calc_hipsRotationOffsets = Vector3.zero;

	private Vector3 _calc_hipsStretchOffset = Vector3.zero;

	private Vector3 _sd_hipsStretchOff = Vector3.zero;

	private Vector3 _calc_ikOff = Vector3.zero;

	private List<LegRedirectHelper> legRedirectHelpers;

	[NonSerialized]
	public Transform SpineBone;

	[NonSerialized]
	public Vector3 User_MultiplyHipsOffsets = Vector3.one;

	[FPD_Header("Angles setup to drive procedural animation", 6f, 4f, 2)]
	public AnglesSetup Animation360Angles;

	[NonSerialized]
	public float User_StretchRotatorAnglePower = 30f;

	[NonSerialized]
	public float User_StretchPositionMultiplier = 1f;

	private float _mainBlend = 1f;

	private bool _wasUpdated;

	private Vector3 overridingDirection = Vector3.zero;

	private bool useOverridingDirection;

	[NonSerialized]
	public float overrideDirectionFadeSpeed = 6f;

	private float overrideDirectionBlend;

	private float _calc_lStretch;

	private float _calc_rStretch;

	private LegsAnimator.Variable HipsRedirVar => _useHelper.RequestVariable("Redirect Hips", 0.8f);

	private LegsAnimator.Variable FeetRedirVar => _useHelper.RequestVariable("Redirect Feet", 0.8f);

	private LegsAnimator.Variable KneesRedirVar => _useHelper.RequestVariable("Redirect Knees", 0.4f);

	private LegsAnimator.Variable TrDurationVar => _useHelper.RequestVariable("Transitions Duration", 0.25f);

	private LegsAnimator.Variable LimitRaiseVar => _useHelper.RequestVariable("Limit Leg Raise", 0.1f);

	private LegsAnimator.Variable FixFeetVar => _useHelper.RequestVariable("Fix Backward Feet", 1f);

	private LegsAnimator.Variable AdjustStretchVar => _useHelper.RequestVariable("Adjust Stretched", 0.2f);

	private LegsAnimator.Variable RestoreSpineVar => _useHelper.RequestVariable("Restore Spine", 0.5f);

	private LegsAnimator.Variable ExtraSmootherVar => _useHelper.RequestVariable("Extra Smoother", 0f);

	private LegsAnimator.Variable ReAdjVar => _useHelper.RequestVariable("Re-adjust with hips offset", false);

	private LegsAnimator.Variable FadeOffInAirVar => _useHelper.RequestVariable("Disable When Jumping", false);

	private LegsAnimator.Variable XDirAnimVarVar => _useHelper.RequestVariable("Animator World X Dir", "");

	private LegsAnimator.Variable ZDirAnimVarVar => _useHelper.RequestVariable("Animator World Z Dir", "");

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_useHelper = helper;
		_play_HipsRedir = HipsRedirVar;
		_play_TrDur = TrDurationVar;
		_play_LimitRaise = LimitRaiseVar;
		_play_FeetRedir = FeetRedirVar;
		_play_KneesRedir = KneesRedirVar;
		_play_FixFeet = FixFeetVar;
		_play_AdjustStretch = AdjustStretchVar;
		_play_RestoreSpine = RestoreSpineVar;
		_play_Smoother = ExtraSmootherVar;
		_play_offInAir = FadeOffInAirVar;
		_play_reAdj = ReAdjVar;
		_wasUpdated = false;
		legRedirectHelpers = new List<LegRedirectHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegRedirectHelper item = new LegRedirectHelper(this, base.LA.Legs[i]);
			legRedirectHelpers.Add(item);
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			if (base.LA.Legs[j].OppositeLegIndex >= 0)
			{
				legRedirectHelpers[j].oppositeHelper = legRedirectHelpers[base.LA.Legs[j].OppositeLegIndex];
			}
		}
		if ((Object)(object)SpineBone == (Object)null && base.LA.Hips.childCount > 0)
		{
			if (base.LA.Hips.childCount == 1)
			{
				SpineBone = base.LA.Hips.GetChild(0);
			}
			else
			{
				for (int k = 0; k < base.LA.Hips.childCount; k++)
				{
					if (((Object)base.LA.Hips.GetChild(k)).name.ToLower().Contains("spin"))
					{
						SpineBone = base.LA.Hips.GetChild(k);
						break;
					}
				}
				if ((Object)(object)SpineBone == (Object)null)
				{
					SpineBone = base.LA.Hips.GetChild(0);
				}
			}
		}
		if (Object.op_Implicit((Object)(object)base.LA.Mecanim))
		{
			LegsAnimator.Variable xDirAnimVarVar = XDirAnimVarVar;
			if (!string.IsNullOrWhiteSpace(xDirAnimVarVar.GetString()))
			{
				_hash_xDir = Animator.StringToHash(xDirAnimVarVar.GetString());
				LegsAnimator.Variable zDirAnimVarVar = ZDirAnimVarVar;
				_hash_zDir = Animator.StringToHash(zDirAnimVarVar.GetString());
			}
		}
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		_mainBlend = base.LA._MainBlend * base.ModuleBlend;
		if (_play_offInAir.GetBool())
		{
			_mainBlend *= base.LA.IsGroundedBlend;
		}
		float @float = _play_TrDur.GetFloat();
		if (_mainBlend < 0.001f)
		{
			return;
		}
		if (useOverridingDirection)
		{
			if (overrideDirectionFadeSpeed < 0.0001f)
			{
				overrideDirectionBlend = 1f;
			}
			else
			{
				overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 1f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
			}
		}
		else if (overrideDirectionFadeSpeed < 0.0001f)
		{
			overrideDirectionBlend = 0f;
		}
		else
		{
			overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 0f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
		}
		Vector3 calc_WorldDir;
		if (_hash_zDir != -1)
		{
			Vector3 val = new Vector3(base.LA.Mecanim.GetFloat(_hash_xDir), 0f, base.LA.Mecanim.GetFloat(_hash_zDir));
			calc_WorldDir = ((Vector3)(ref val)).normalized;
		}
		else
		{
			calc_WorldDir = base.LA.DesiredMovementDirection;
			calc_WorldDir.y = 0f;
			if (((Vector3)(ref calc_WorldDir)).magnitude < 0.1f)
			{
				calc_WorldDir = Vector3.zero;
			}
		}
		_calc_WorldDir = calc_WorldDir;
		if (overrideDirectionBlend > 0.0001f)
		{
			if (overrideDirectionBlend >= 1f)
			{
				_calc_WorldDir = overridingDirection;
			}
			else
			{
				_calc_WorldDir = Vector3.Slerp(_calc_WorldDir, overridingDirection, overrideDirectionBlend);
			}
		}
		_calc_LocalDir = base.LA.ToRootLocalSpaceVec(_calc_WorldDir);
		_var_raiseLimit = _play_LimitRaise.GetFloat();
		_var_fixFeet = _play_FixFeet.GetFloat();
		if (((Vector3)(ref _calc_LocalDir)).sqrMagnitude < 1E-05f)
		{
			_localTargetAngle = 0f;
		}
		_localTargetAngle = FEngineering.GetAngleRad(_calc_LocalDir.x, _calc_LocalDir.z);
		float num = ((!(@float <= 0f)) ? (3f * Mathf.Lerp(5f, 0.5f, @float / 0.6f)) : 1000f);
		_calc_deltaSpeed = base.LA.DeltaTime * num;
		_calc_deltaSpeedSlow = base.LA.DeltaTime * (num * 0.6f);
		_calc_smoothedTargetAngle = Mathf.LerpAngle(_calc_smoothedTargetAngle, _localTargetAngle, _calc_deltaSpeedSlow);
		_calc_angleDiffFactor = Mathf.InverseLerp(0.0001f, 0.25f, Mathf.Abs((_localTargetAngle - _calc_smoothedTargetAngle) / MathF.PI));
		_localTargetAngle *= 57.29578f;
		_wrappedAngle = FormatAngleToPM180(_localTargetAngle);
		_smoothedWrappedAngle = Mathf.LerpAngle(_smoothedWrappedAngle, _wrappedAngle, _calc_deltaSpeed * 1.25f);
		_smoothedWrappedAngle = FormatAngleToPM180(_smoothedWrappedAngle);
		if (_smoothedWrappedAngle < -179.9f && _wrappedAngle > 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		if (_smoothedWrappedAngle > 179.9f && _wrappedAngle < 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		float wrappedAngle = _wrappedAngle;
		float num2 = ((!(_wrappedAngle < 90f)) ? Mathf.InverseLerp(180f, 90f, wrappedAngle) : Mathf.InverseLerp(0f, 90f, wrappedAngle));
		_calc_sideFactorR = Mathf.Lerp(_calc_sideFactorR, num2, _calc_deltaSpeed * 2f);
		num2 = ((!(_wrappedAngle > -90f)) ? Mathf.InverseLerp(-180f, -90f, wrappedAngle) : Mathf.InverseLerp(0f, -90f, wrappedAngle));
		_calc_sideFactorL = Mathf.Lerp(_calc_sideFactorL, num2, _calc_deltaSpeed * 2f);
		if (_wrappedAngle < 0f)
		{
			_calc_sideFactor = _calc_sideFactorL;
		}
		else
		{
			_calc_sideFactor = _calc_sideFactorR;
		}
		_calc_toNegativeXProgress = 0f;
		float wrappedAngle2 = _wrappedAngle;
		if (wrappedAngle2 < -90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(-90f, -135f, wrappedAngle2);
		}
		else if (wrappedAngle2 > 90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(90f, 135f, wrappedAngle2);
		}
		_calc_LocalRotDir = Quaternion.Euler(0f, _localTargetAngle, 0f);
		_wasUpdated = true;
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float smoother = _play_Smoother.GetFloat() + 1f;
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			Vector3 animatorEndBonePos = leg._AnimatorEndBonePos;
			Vector3 localPos = base.LA.ToRootLocalSpace(animatorEndBonePos);
			LegRedirectHelper legRedirectHelper = legRedirectHelpers[leg.PlaymodeIndex];
			legRedirectHelper.ComputeIKOffset(localPos, smoother);
			Vector3 val = legRedirectHelper.LastComputedWorldSpaceLegPos;
			if (_mainBlend < 1f)
			{
				val = Vector3.LerpUnclamped(animatorEndBonePos, val, _mainBlend);
			}
			Vector3 calc_ikOff = _calc_ikOff;
			if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Left)
			{
				calc_ikOff.x = 0f - calc_ikOff.x;
			}
			else if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Right)
			{
				calc_ikOff.z = 0f - calc_ikOff.z;
			}
			calc_ikOff = base.LA.RootToWorldSpaceVec(calc_ikOff);
			val += calc_ikOff;
			leg.OverrideAnimatorAnklePosition(val);
		}
	}

	public void OverrideMoveDirection(Vector3? direction)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!direction.HasValue)
		{
			useOverridingDirection = false;
			return;
		}
		useOverridingDirection = true;
		overridingDirection = direction.Value;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06de: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_074c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0758: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0781: Unknown result type (might be due to invalid IL or missing references)
		//IL_0786: Unknown result type (might be due to invalid IL or missing references)
		//IL_0788: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_0819: Unknown result type (might be due to invalid IL or missing references)
		//IL_0820: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0854: Unknown result type (might be due to invalid IL or missing references)
		//IL_0859: Unknown result type (might be due to invalid IL or missing references)
		//IL_0865: Unknown result type (might be due to invalid IL or missing references)
		//IL_086f: Unknown result type (might be due to invalid IL or missing references)
		//IL_087f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0884: Unknown result type (might be due to invalid IL or missing references)
		//IL_088f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0894: Unknown result type (might be due to invalid IL or missing references)
		//IL_089d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0470: Unknown result type (might be due to invalid IL or missing references)
		//IL_0484: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0525: Unknown result type (might be due to invalid IL or missing references)
		//IL_0539: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0907: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float @float = _play_HipsRedir.GetFloat();
		float float2 = _play_FeetRedir.GetFloat();
		float float3 = _play_KneesRedir.GetFloat();
		float float4 = _play_AdjustStretch.GetFloat();
		float num = Mathf.Abs(_wrappedAngle);
		float num2 = Mathf.InverseLerp(0f, 45f, num);
		float wrappedAngle = _wrappedAngle;
		float num3 = wrappedAngle;
		if (float2 > 0f)
		{
			if (wrappedAngle < -90f)
			{
				num3 = ((!(wrappedAngle > -135f)) ? Mathf.Lerp(40f, 0f, Mathf.InverseLerp(-135f, -180f, wrappedAngle)) : Mathf.Lerp(-90f, 40f, Mathf.InverseLerp(-90f, -135f, wrappedAngle)));
			}
			else if (wrappedAngle > 90f)
			{
				num3 = ((!(wrappedAngle < 135f)) ? Mathf.Lerp(-40f, 0f, Mathf.InverseLerp(135f, 180f, wrappedAngle)) : Mathf.Lerp(90f, -40f, Mathf.InverseLerp(90f, 135f, wrappedAngle)));
			}
		}
		Vector3 val = Vector3.zero;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		num6 = ((!(num > 135f)) ? Mathf.InverseLerp(90f, 135f, num) : Mathf.InverseLerp(180f, 135f, num));
		num6 = Mathf.Lerp(1f, -0.5f, num6);
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			if (float2 > 0f)
			{
				float num7 = num3;
				float num8 = 1f - float2;
				num8 = num8 * num8 * num8;
				Quaternion target = Quaternion.AngleAxis(num7 * (1f - num8) * 0.8f * _mainBlend, base.LA.BaseTransform.up);
				target = legRedirectHelpers[i].FootRedirectSmoother(target);
				leg.OverrideFinalIKRot(target * leg.GetFinalIKRot());
			}
			if (float3 > 0f)
			{
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorR) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorL) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
			}
			else
			{
				leg.IKProcessor.StartBoneRotationOffset = Quaternion.identity;
			}
			if (!(float4 > 0.01f))
			{
				continue;
			}
			float stretchValue = leg.IKProcessor.GetStretchValue(legRedirectHelpers[i].LastComputedWorldSpaceLegPos);
			if (stretchValue > 0.9f)
			{
				float num9 = Mathf.InverseLerp(0.9f, 1.125f, stretchValue);
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num4 += num9;
				}
				else
				{
					num5 += num9;
				}
				Vector3 vec = leg._PreviousFinalIKPos - base.LA.BaseTransform.position;
				vec = base.LA.ToRootLocalSpaceVec(vec);
				vec.y *= -0.8f;
				vec = base.LA.RootToWorldSpaceVec(vec);
				val += vec * (num9 * 1f);
			}
		}
		Vector3 val2 = Animation360Angles.AnglesOn0;
		Vector3 val3 = Animation360Angles.HipsOffsetOn0;
		Vector3 val4 = Animation360Angles.IKsOffsetOn0;
		if (num > 0f)
		{
			if (num < 90f)
			{
				float t = InverseLerpDoubleSide(0f, 45f, num, 90f);
				LerpIt(ref val2, Animation360Angles.AnglesOn45, t);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn45, t);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn45, t);
			}
			if (num > 45f && num < 135f)
			{
				float t2 = InverseLerpDoubleSide(45f, 90f, num, 135f);
				LerpIt(ref val2, Animation360Angles.AnglesOn90, t2);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn90, t2);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn90, t2);
			}
			if (num > 90f)
			{
				float t3 = InverseLerpDoubleSide(90f, 135f, num, 180f);
				LerpIt(ref val2, Animation360Angles.AnglesOn135, t3);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn135, t3);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn135, t3);
			}
			if (num > 135f)
			{
				float t4 = Mathf.InverseLerp(135f, 180f, num);
				LerpIt(ref val2, Animation360Angles.AnglesOn180, t4);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn180, t4);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn180, t4);
			}
			if (_wrappedAngle < 0f)
			{
				val2.y = 0f - val2.y;
				val2.z = 0f - val2.z;
				val3.x = 0f - val3.x;
				val4.z = 0f - val4.z;
			}
			val2 *= @float;
			val3 *= 0.7f * @float;
			val2 = Vector3.Scale(val2, User_MultiplyHipsOffsets);
		}
		val4 *= @float * _mainBlend * base.LA.ScaleReference;
		_calc_ikOff = val4;
		float num10 = 0.25f + float4 * 0.75f;
		_calc_lStretch = Mathf.Lerp(_calc_lStretch, num4, _calc_deltaSpeed);
		_calc_rStretch = Mathf.Lerp(_calc_rStretch, num5, _calc_deltaSpeed);
		val2.y -= _calc_lStretch * User_StretchRotatorAnglePower * @float * num10;
		val2.y += _calc_rStretch * User_StretchRotatorAnglePower * @float * num10;
		_calc_hipsRotationOffsets.x = Mathf.LerpAngle(_calc_hipsRotationOffsets.x, val2.x, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.y = Mathf.LerpAngle(_calc_hipsRotationOffsets.y, val2.y, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.z = Mathf.LerpAngle(_calc_hipsRotationOffsets.z, val2.z, _calc_deltaSpeed);
		_calc_hipsPositionOffsets = Vector3.Lerp(_calc_hipsPositionOffsets, val3, _calc_deltaSpeed);
		val3 *= User_StretchPositionMultiplier;
		Quaternion val5 = Quaternion.identity;
		float num11 = _play_RestoreSpine.GetFloat();
		if ((Object)(object)SpineBone != (Object)null)
		{
			val5 = SpineBone.rotation;
		}
		else
		{
			num11 = 0f;
		}
		Quaternion val6 = Quaternion.AngleAxis(_calc_hipsRotationOffsets.y * _mainBlend, base.LA.BaseTransform.up);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.z * _mainBlend, base.LA.BaseTransform.forward);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.x * _mainBlend, base.LA.BaseTransform.right);
		base.LA.Hips.rotation = val6 * base.LA.Hips.rotation;
		if (num11 > 0f)
		{
			SpineBone.rotation = Quaternion.Slerp(SpineBone.rotation, val5, Mathf.Lerp(1f, num11, _mainBlend));
		}
		_calc_hipsStretchOffset = Vector3.SmoothDamp(_calc_hipsStretchOffset, num2 * val, ref _sd_hipsStretchOff, 0.2f + 0.3f * _play_TrDur.GetFloat(), 100000f, base.LA.DeltaTime);
		Vector3 val7 = base.LA.RootToWorldSpaceVec(_calc_hipsPositionOffsets * 0.5f * base.LA.ScaleReference) * _mainBlend;
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += val7 + _calc_hipsStretchOffset * float4 * _mainBlend;
		if (_play_reAdj.GetBool())
		{
			for (int j = 0; j < base.LA.Legs.Count; j++)
			{
				base.LA.Legs[j].OverrideFinalIKPos(base.LA.Legs[j].GetFinalIKPos() - val7);
			}
		}
	}

	public override void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (!(_mainBlend < 0.001f) && _wasUpdated && _var_fixFeet > 0f)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				Quaternion rotation = leg.IKProcessor.EndIKBone.transform.rotation;
				Quaternion val = leg.IKProcessor.EndIKBone.transform.parent.rotation * leg.IKProcessor.EndIKBone.InitialLocalRotation;
				val = Quaternion.LerpUnclamped(rotation, val, (1f - leg.A_AligningHelperBlend) * _var_fixFeet * base.LA.IsMovingBlend * _calc_toNegativeXProgress);
				leg.IKProcessor.EndIKBone.transform.rotation = val;
			}
		}
	}

	public static float FormatAngleToPM180(float angle)
	{
		float num = angle % 360f;
		if (num > 180f)
		{
			num -= 360f;
		}
		if (num < -180f)
		{
			num += 360f;
		}
		return num;
	}

	private static float InverseLerpDoubleSide(float from, float to, float t, float toRange)
	{
		if (t > to)
		{
			return Mathf.InverseLerp(toRange, to, t);
		}
		return Mathf.InverseLerp(from, to, t);
	}

	private static void LerpIt(ref Vector3 val, Vector3 to, float t)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		val = Vector3.LerpUnclamped(val, to, t);
	}
}


using System;
using UnityEngine;

[Serializable]
public class AnglesSetup
{
	public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Hips rotations on reaching 45 angle movement")]
	public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

	[Tooltip(" Hips rotations on reaching 90 angle movement")]
	public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

	[Tooltip(" Hips rotations on reaching 135 angle movement")]
	public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

	[Tooltip(" Hips rotations on reaching 180 angle movement")]
	public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

	[Space(8f)]
	public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Hips position offset on reaching 45 angle movement")]
	public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

	[Tooltip(" Hips position offset on reaching 90 angle movement")]
	public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

	[Tooltip(" Hips position offset on reaching 135 angle movement")]
	public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

	[Tooltip(" Hips position offset on reaching 180 angle movement")]
	public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

	[Space(8f)]
	public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

	[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

	[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

	[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
}


using UnityEngine;

private class LegRedirectHelper
{
	private LAM_DirectionalMovement parent;

	private LegsAnimator.Leg leg;

	internal LegRedirectHelper oppositeHelper;

	private Vector3 computedPosLocal = Vector3.zero;

	private Quaternion _footRedirCache = Quaternion.identity;

	private LegsAnimator LA => parent.LA;

	public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

	public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		this.parent = parent;
		this.leg = leg;
		LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
		computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
	}

	public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		float @float = parent._play_TrDur.GetFloat();
		Vector3 val = parent._calc_LocalRotDir * localPos;
		float num = Vector3.Magnitude(val - computedPosLocal);
		float num2 = num / leg.Owner.ScaleReferenceNoScale;
		float num3 = 0f;
		if (num > 0.2f)
		{
			num3 = Mathf.InverseLerp(0.2f, 1f, num);
			num3 *= 0.1f;
			if (@float < 0.1f)
			{
				num3 *= @float / 0.1f;
			}
		}
		if (parent._calc_toNegativeXProgress > 0f)
		{
			Vector3 val2 = localPos;
			val2.x *= -1f;
			Vector3 val3 = parent._calc_LocalRotDir * val2;
			val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
		}
		float num4 = 0f;
		if (!(smoother >= 3f))
		{
			if (smoother > 0f)
			{
				if (num2 < 0.1f / smoother)
				{
					computedPosLocal = val;
				}
				else
				{
					num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
				}
				num4 = Mathf.Max(0f, num4);
			}
			else
			{
				computedPosLocal = val;
			}
		}
		computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
		computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
		if (parent._var_raiseLimit > 0f)
		{
			float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
			float num5 = 0f;
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
			}
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
		}
		LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
		return computedPosLocal;
	}

	internal Quaternion FootRedirectSmoother(Quaternion target)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
		return _footRedirCache;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_EdgeStepDetector : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable iterationsV;

	private float initTime;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		initTime = Time.time;
		iterationsV = helper.RequestVariable("Iterations", 5);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		initTime = Time.time;
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time - initTime < 0.1f)
		{
			return;
		}
		if (leg.User_RaycastHittedSource)
		{
			leg.User_RestoreRaycasting();
			return;
		}
		Vector3 val = base.LegsAnim.ToRootLocalSpace(leg.ParentHub.LastKeyframePosition);
		Vector3 val2 = base.LegsAnim.ToRootLocalSpace(leg.lastRaycastingOrigin);
		val.y = val2.y;
		val.z = val2.z;
		RaycastHit hit = default(RaycastHit);
		float num = Vector3.Distance(leg.lastRaycastingOrigin, leg.lastRaycastingEndPoint);
		float num2 = iterationsV.GetInt();
		for (float num3 = 1f; num3 <= num2; num3 += 1f)
		{
			Vector3 localPos = Vector3.LerpUnclamped(val2, val, 0.1f + num3 / num2);
			localPos = base.LegsAnim.RootToWorldSpace(localPos);
			if (Physics.Raycast(localPos, -base.LegsAnim.Up, ref hit, num * 1.01f, LayerMask.op_Implicit(base.LegsAnim.GroundMask), (QueryTriggerInteraction)1))
			{
				break;
			}
		}
		if ((Object)(object)((RaycastHit)(ref hit)).transform == (Object)null)
		{
			leg.User_RestoreRaycasting();
		}
		else
		{
			leg.User_OverrideRaycastHit(hit, disableSourceRaycast: false);
		}
	}
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_FadeLegOnAnimator : LegsAnimatorControlModuleBase
{
	private enum ELayerSelectMode
	{
		ByIndex,
		Auto
	}

	private LegsAnimator.Variable _fadeSpeedV;

	private LegsAnimator.Variable _layerV;

	private LegsAnimator.Variable _idleGlueV;

	private float enabledMultiplier = 1f;

	private float sd_eneMul;

	[NonSerialized]
	private LegsAnimator.Leg[] legs;

	private List<int> stateHashes;

	private List<int> tagHashes;

	private LegsAnimator.Variable _layerMode;

	private LegsAnimator.Variable _layerSkip;

	private List<int> layersToCheck;

	private int lastAutoWeightIndex;

	private bool InitLayerCheck(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)helper.Parent.Mecanim == (Object)null)
		{
			return false;
		}
		if (_layerMode.GetInt() == 0)
		{
			return false;
		}
		if (_layerMode == null || _layerSkip == null)
		{
			return false;
		}
		layersToCheck = new List<int>();
		string[] array = _layerSkip.GetString().Split(',');
		for (int i = 0; i < helper.Parent.Mecanim.layerCount; i++)
		{
			layersToCheck.Add(i);
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (int.TryParse(array[j], out var result))
			{
				layersToCheck.Remove(result);
				continue;
			}
			int num = -1;
			for (int k = 0; k < helper.Parent.Mecanim.layerCount; k++)
			{
				if (helper.Parent.Mecanim.GetLayerName(k) == array[j])
				{
					num = k;
					break;
				}
			}
			if (num != -1)
			{
				layersToCheck.Remove(num);
			}
		}
		return true;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)base.LA.Mecanim == (Object)null)
		{
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: Not found animator reference in legs animator Extra/Control!");
			helper.Enabled = false;
			return;
		}
		_layerV = helper.RequestVariable("Animation Layer", 0);
		_fadeSpeedV = helper.RequestVariable("Fade Speed", 0.75f);
		_idleGlueV = helper.RequestVariable("Idle Glue During Fade", false);
		LegsAnimator.Variable variable = helper.RequestVariable("Animation State Tag", "");
		string[] array = helper.RequestVariable("Animation State Name", "").GetString().Split(',');
		if (array.Length != 0)
		{
			stateHashes = new List<int>();
			for (int i = 0; i < array.Length; i++)
			{
				if (!string.IsNullOrWhiteSpace(array[i]))
				{
					stateHashes.Add(Animator.StringToHash(array[i]));
				}
			}
		}
		string[] array2 = variable.GetString().Split(',');
		if (array2.Length != 0)
		{
			tagHashes = new List<int>();
			for (int j = 0; j < array2.Length; j++)
			{
				if (!string.IsNullOrWhiteSpace(array2[j]))
				{
					tagHashes.Add(Animator.StringToHash(array2[j]));
				}
			}
		}
		if (stateHashes.Count == 0 && tagHashes.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No assigned animation state names/tags to control module on!");
			return;
		}
		if (helper.customStringList == null)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
			return;
		}
		List<LegsAnimator.Leg> list = new List<LegsAnimator.Leg>();
		for (int k = 0; k < helper.customStringList.Count; k++)
		{
			if (helper.customStringList[k] == "1")
			{
				list.Add(base.LA.Legs[k]);
			}
		}
		if (list.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
			return;
		}
		legs = list.ToArray();
		if (_layerV.GetInt() < 0)
		{
			_layerV.SetValue(0);
		}
		if (_layerV.GetInt() > base.LA.Mecanim.layerCount - 1)
		{
			_layerV.SetValue(base.LA.Mecanim.layerCount - 1);
		}
		_layerMode = helper.RequestVariable("Mode", 0);
		_layerSkip = helper.RequestVariable("Skip", "");
		if (_layerMode.GetInt() == 1 && !InitLayerCheck(helper))
		{
			_layerMode.SetValue(0);
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Animator mecanim = base.LA.Mecanim;
		if ((Object)(object)mecanim == (Object)null)
		{
			return;
		}
		int num = _layerV.GetInt();
		if (_layerMode.GetInt() == 1)
		{
			float num2 = 0f;
			int num3 = -1;
			for (int num4 = layersToCheck.Count - 1; num4 >= 0; num4--)
			{
				int num5 = layersToCheck[num4];
				float layerWeight = helper.Parent.Mecanim.GetLayerWeight(num5);
				if (layerWeight > 0.95f)
				{
					num3 = num5;
					break;
				}
				if (layerWeight > num2)
				{
					num2 = layerWeight;
					num3 = num5;
				}
			}
			num = (lastAutoWeightIndex = num3);
		}
		AnimatorStateInfo val = (mecanim.IsInTransition(num) ? mecanim.GetNextAnimatorStateInfo(num) : mecanim.GetCurrentAnimatorStateInfo(num));
		bool flag = false;
		for (int i = 0; i < stateHashes.Count; i++)
		{
			if (((AnimatorStateInfo)(ref val)).shortNameHash == stateHashes[i])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int j = 0; j < tagHashes.Count; j++)
			{
				if (((AnimatorStateInfo)(ref val)).tagHash == tagHashes[j])
				{
					flag = true;
					break;
				}
			}
		}
		float num6 = 0.3f - _fadeSpeedV.GetFloat() * 0.299f;
		if (flag)
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, -0.001f, ref sd_eneMul, num6 * 0.9f, 100000f, base.LA.DeltaTime);
		}
		else
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, 1.01f, ref sd_eneMul, num6, 100000f, base.LA.DeltaTime);
		}
		enabledMultiplier = Mathf.Clamp01(enabledMultiplier);
		for (int k = 0; k < legs.Length; k++)
		{
			legs[k].InternalModuleBlendWeight = enabledMultiplier;
			legs[k].IK_UpdateParamsBase();
		}
		if (_idleGlueV.GetBool() && enabledMultiplier < 0.5f)
		{
			base.LA._glueModeExecuted = LegsAnimator.EGlueMode.Idle;
		}
	}
}


private enum ELayerSelectMode
{
	ByIndex,
	Auto
}


using FIMSpace.FProceduralAnimation;

public class LAM_HardGlueOnStop : LegsAnimatorControlModuleBase
{
	public float FrontMargin = 0.3f;

	public float ForceForSeconds = 0.6f;

	private LegsAnimator.Variable _beforeV;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_beforeV = helper.RequestVariable("Hard Glue Before Move", 0f);
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if (!base.LA.IsMoving && base.LA.IsGrounded && base.LA.StoppedTime < ForceForSeconds)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				if (leg.AnkleH.LastKeyframeRootPos.z > (0f - base.LA.ScaleReferenceNoScale) * FrontMargin)
				{
					leg.G_CustomForceAttach = true;
				}
			}
		}
		if (!(_beforeV.GetFloat() > 0f) || !base.LA.IsMoving || !base.LA.IsGrounded || !(base.LA.MovingTime < _beforeV.GetFloat()))
		{
			return;
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			LegsAnimator.Leg leg2 = base.LA.Legs[j];
			if (leg2.IKProcessor.GetStretchValue(leg2.IKProcessor.IKTargetPosition) < 1.01f)
			{
				leg2.G_CustomForceAttach = true;
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_HeightStabilizer : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _reactV;

	private LegsAnimator.Variable _thresV;

	private LegsAnimator.Variable _extrV;

	private Vector3 adjustement = Vector3.zero;

	private Vector3 sd_adjustement = Vector3.zero;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.OnInit(helper);
		_powerV = helper.RequestVariable("Blend", 1f);
		_reactV = helper.RequestVariable("Reaction Speed", 0.7f);
		_thresV = helper.RequestVariable("Blend Y", 0.5f);
		_extrV = helper.RequestVariable("Extra Push Down Blend", 0.1f);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		adjustement = Vector3.zero;
		sd_adjustement = Vector3.zero;
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastAppliedHipsFinalPosition = base.LA._LastAppliedHipsFinalPosition;
		Vector3 val = base.LA.ToRootLocalSpace(lastAppliedHipsFinalPosition);
		Vector3 lastKeyframeLocalPosition = base.LA.HipsSetup.LastKeyframeLocalPosition;
		val.y = 0f;
		lastKeyframeLocalPosition.y = 0f;
		Vector3 val2 = lastKeyframeLocalPosition - val;
		float magnitude = ((Vector3)(ref val2)).magnitude;
		val2.y -= magnitude * _thresV.GetFloat();
		val2 *= _powerV.GetFloat();
		val2.y -= Mathf.InverseLerp(base.LA.ScaleReferenceNoScale * 0.001f, base.LA.ScaleReferenceNoScale * (0.15f + _extrV.GetFloat() * 0.1f), magnitude) * _extrV.GetFloat() * 0.25f;
		val2 *= base.EffectBlend;
		adjustement = Vector3.SmoothDamp(adjustement, val2, ref sd_adjustement, Mathf.Lerp(0.4f, 0.005f, _reactV.GetFloat()), 1000000f, base.LA.DeltaTime);
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += base.LA.RootToWorldSpaceVec(adjustement);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "Module Settings-Impulses On Stop And On Land", menuName = "FImpossible Creations/Legs Animator/Module - Impulses on Stop and Land Setup", order = 4)]
public class LAM_ImpulsesOnStopAndOnLand : LegsAnimatorControlModuleBase
{
	[FPD_Header("Triggering hips push impulses", 6f, 4f, 2)]
	public LegsAnimator.PelvisImpulseSettings OnStopImpulse;

	public LegsAnimator.PelvisImpulseSettings OnLandImpulse;

	[FPD_Header("Set Zero Power to Not Use", 6f, 4f, 2)]
	public LegsAnimator.PelvisImpulseSettings OnStartMoveImpulse;

	private readonly string powerMulStrN = "Power Multiplier";

	private readonly string durMulStrN = "Duration Multiplier";

	private readonly string spdLandPower = "Speed Affects Land";

	private bool lastGrounded = true;

	private bool lastMoving;

	private float lastMovingTime;

	private float lastUngroundedTime;

	private LegsAnimator.Variable _powerMulVar;

	private LegsAnimator.Variable _durMulVar;

	private LegsAnimator.Variable _spdAffectsLand;

	protected float customMul = 1f;

	private void Reset()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		OnStartMoveImpulse = new LegsAnimator.PelvisImpulseSettings();
		OnStartMoveImpulse.PowerMultiplier = 0f;
		OnStartMoveImpulse.LocalTranslation = new Vector3(0f, -0.05f, -0.001f);
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		lastGrounded = true;
		lastMoving = false;
		_powerMulVar = helper.RequestVariable(powerMulStrN, 1f);
		_durMulVar = helper.RequestVariable(durMulStrN, 1f);
		_spdAffectsLand = helper.RequestVariable(spdLandPower, false);
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		LegsAnimator lA = base.LA;
		if (lA.IsInAir && lA.InAirTime > 0f)
		{
			lastUngroundedTime = lA.InAirTime;
		}
		if (lA.IsGrounded != lastGrounded && OnLandImpulse.PowerMultiplier != 0f && lA.IsGrounded && lastUngroundedTime > 0.1f)
		{
			Impact_OnLanding(lA);
		}
		if (lA.IsMoving && lA.MovingTime > 0f)
		{
			lastMovingTime = lA.MovingTime;
		}
		if (lA.IsMoving != lastMoving && OnStopImpulse.PowerMultiplier != 0f)
		{
			if (!lA.IsMoving)
			{
				if (lastMovingTime > 0.3f && lA.GroundedTime > 0.25f)
				{
					Impact_OnEndsMove(lA);
				}
			}
			else if (OnStartMoveImpulse.PowerMultiplier != 0f && lA.GroundedTime > 0.1f)
			{
				Impact_OnStartMove(lA);
			}
		}
		lastGrounded = lA.IsGrounded;
		lastMoving = lA.IsMoving;
	}

	protected virtual void Impact_OnStartMove(LegsAnimator l)
	{
		l.User_AddImpulse(OnStartMoveImpulse, _powerMulVar.GetFloat() * customMul, _durMulVar.GetFloat());
	}

	protected virtual void Impact_OnEndsMove(LegsAnimator l)
	{
		l.User_AddImpulse(OnStopImpulse, _powerMulVar.GetFloat() * customMul, _durMulVar.GetFloat());
	}

	protected virtual void Impact_OnLanding(LegsAnimator l)
	{
		if (_spdAffectsLand.GetBool())
		{
			l.User_AddImpulse(OnLandImpulse, _powerMulVar.GetFloat() * customMul, _durMulVar.GetFloat());
		}
		else
		{
			l.User_AddImpulse(OnLandImpulse, _powerMulVar.GetFloat() * ((customMul <= 0f) ? 1f : customMul), _durMulVar.GetFloat());
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_InsectBodyElevateHelper : LegsAnimatorControlModuleBase
{
	private float currentHeightAdjust;

	private float sd_currentHeightAdjust;

	private LegsAnimator.Variable _AdjustPowerV;

	private LegsAnimator.Variable _AdjustingSpeedV;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_AdjustPowerV = helper.RequestVariable("Adjust Power", 1f);
		_AdjustingSpeedV = helper.RequestVariable("Adjusting Speed", 1f);
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		float hips_LastHipsOffset = base.LA.HipsSetup._Hips_LastHipsOffset;
		hips_LastHipsOffset = ((!(hips_LastHipsOffset < 0f)) ? 0f : (0f - hips_LastHipsOffset));
		if (_AdjustingSpeedV.GetFloat() >= 1f)
		{
			currentHeightAdjust = hips_LastHipsOffset;
		}
		else
		{
			currentHeightAdjust = Mathf.SmoothDamp(currentHeightAdjust, hips_LastHipsOffset, ref sd_currentHeightAdjust, Mathf.Lerp(0.16f, 0.005f, _AdjustingSpeedV.GetFloat()));
		}
		Transform hips = base.LA.Hips;
		hips.position += base.LA.Up * currentHeightAdjust * base.EffectBlend * _AdjustPowerV.GetFloat();
	}
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_InsectLegsHelper : LegsAnimatorControlModuleBase
{
	private class LegHelper
	{
		public bool WasAttaching;

		public bool DetachTrigger;

		public float FullyAttachedAt = -1f;

		public LegsAnimator.Leg legRef { get; private set; }

		public LegHelper(LegsAnimator.Leg leg)
		{
			legRef = leg;
			WasAttaching = false;
			DetachTrigger = false;
			FullyAttachedAt = -1f;
		}
	}

	private LegsAnimator.Variable _onOneSideV;

	private LegsAnimator.Variable _onStepCulldownV;

	private LegsAnimator.Variable _legSideCulldownV;

	private LegsAnimator.Variable _afterFullCulldownV;

	private LegsAnimator.Variable _modeV;

	private readonly string minSideS = "Minimum Standing Legs On One Side";

	private readonly string stepculldS = "On Step Culldown";

	private readonly string sideculldV = "Leg Side Culldown";

	private readonly string waitV = "On Full Attach Culldown";

	private readonly string modeV = "Mode";

	private float mainCulldown;

	private float sideLCulldown;

	private float sideRCulldown;

	private List<LegHelper> legHelpers;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper hlp)
	{
		_onOneSideV = hlp.RequestVariable(minSideS, 2);
		_onStepCulldownV = hlp.RequestVariable(stepculldS, 0.025f);
		_legSideCulldownV = hlp.RequestVariable(sideculldV, 0.015f);
		_afterFullCulldownV = hlp.RequestVariable(waitV, 0f);
		_modeV = hlp.RequestVariable(modeV, 0);
		legHelpers = new List<LegHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegHelper item = new LegHelper(base.LA.Legs[i]);
			legHelpers.Add(item);
		}
		if (_onOneSideV.GetInt() >= base.LA.Legs.Count)
		{
			_onOneSideV.SetValue(base.LA.Legs.Count / 2);
		}
	}

	private bool AllowDetach(LegHelper leg)
	{
		if (mainCulldown > 0f)
		{
			return false;
		}
		if (leg.legRef.Side == LegsAnimator.ELegSide.Left)
		{
			if (sideLCulldown > 0f)
			{
				return false;
			}
		}
		else if (leg.legRef.Side == LegsAnimator.ELegSide.Right && sideRCulldown > 0f)
		{
			return false;
		}
		if (_onOneSideV.GetFloat() > 0f)
		{
			int num = 0;
			for (int i = 0; i < legHelpers.Count; i++)
			{
				LegsAnimator.Leg legRef = legHelpers[i].legRef;
				if (legRef.Side == leg.legRef.Side && (!legRef.G_DuringAttaching || legRef.G_Attached))
				{
					num++;
				}
			}
			if ((float)num < _onOneSideV.GetFloat())
			{
				return false;
			}
		}
		if (Time.time - leg.FullyAttachedAt < _afterFullCulldownV.GetFloat())
		{
			return false;
		}
		return true;
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (legHelpers != null)
		{
			mainCulldown -= base.LA.DeltaTime;
			sideLCulldown -= base.LA.DeltaTime;
			sideRCulldown -= base.LA.DeltaTime;
		}
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper hlp, LegsAnimator.Leg leg)
	{
		if (_modeV.GetInt() == 2)
		{
			CheckConditionsV2(hlp, leg);
			return;
		}
		LegHelper legHelper = legHelpers[leg.PlaymodeIndex];
		if (leg.G_DuringAttaching && !legHelper.WasAttaching)
		{
			mainCulldown = _onStepCulldownV.GetFloat();
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				sideRCulldown = _legSideCulldownV.GetFloat();
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				sideLCulldown = _legSideCulldownV.GetFloat();
			}
		}
		if (leg.G_Attached)
		{
			if (legHelper.FullyAttachedAt == -1f)
			{
				legHelper.FullyAttachedAt = Time.time;
			}
		}
		else
		{
			legHelper.FullyAttachedAt = -1f;
		}
		legHelper.legRef.G_CustomForceNOTDetach = !AllowDetach(legHelper);
		legHelper.WasAttaching = leg.G_DuringAttaching;
	}

	private void CheckConditionsV2(LegsAnimator.LegsAnimatorCustomModuleHelper hlp, LegsAnimator.Leg leg)
	{
		LegHelper legHelper = legHelpers[leg.PlaymodeIndex];
		if (leg.G_Attached)
		{
			if (legHelper.FullyAttachedAt == -1f)
			{
				legHelper.FullyAttachedAt = Time.time;
				legHelper.DetachTrigger = false;
			}
		}
		else
		{
			legHelper.FullyAttachedAt = -1f;
		}
		bool g_CustomForceNOTDetach = leg.G_CustomForceNOTDetach;
		leg.G_CustomForceNOTDetach = false;
		bool flag = false;
		bool flag2 = false;
		if (leg.G_Attached && leg.Glue_CheckDetachement() && leg.Glue_CheckIdleDetachementConfirm())
		{
			flag2 = true;
		}
		if (flag2 && !legHelper.WasAttaching && !legHelper.DetachTrigger && AllowDetach(legHelper))
		{
			flag = true;
			g_CustomForceNOTDetach = false;
			legHelper.DetachTrigger = true;
			leg.G_CustomForceDetach = true;
			mainCulldown = _onStepCulldownV.GetFloat();
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				sideRCulldown = _legSideCulldownV.GetFloat();
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				sideLCulldown = _legSideCulldownV.GetFloat();
			}
		}
		leg.G_CustomForceNOTDetach = g_CustomForceNOTDetach;
		if (!flag)
		{
			legHelper.legRef.G_CustomForceNOTDetach = !AllowDetach(legHelper);
		}
		legHelper.WasAttaching = leg.G_DuringAttaching;
	}
}


private class LegHelper
{
	public bool WasAttaching;

	public bool DetachTrigger;

	public float FullyAttachedAt = -1f;

	public LegsAnimator.Leg legRef { get; private set; }

	public LegHelper(LegsAnimator.Leg leg)
	{
		legRef = leg;
		WasAttaching = false;
		DetachTrigger = false;
		FullyAttachedAt = -1f;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_ParamChanger_UnglueOnAngle : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _UnglueAngleOnMoving;

	private float initialUnglueOn = 30f;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_UnglueAngleOnMoving = helper.RequestVariable("Unglue Angle On Moving", 70f);
		initialUnglueOn = base.LA.UnglueOn;
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.LA.UnglueOn = Mathf.Lerp(initialUnglueOn, _UnglueAngleOnMoving.GetFloat(), base.LA.IsMovingBlend);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_RedirectRaycasting", menuName = "FImpossible Creations/Legs Animator/Control Module - Redirect Raycasting", order = 1)]
public class LAM_RedirectRaycasting : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _LocalDirection;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.OnInit(helper);
		_LocalDirection = helper.RequestVariable("Rotate Raycast", (object)new Vector3(75f, 0f, 0f));
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.Euler(_LocalDirection.GetVector3());
		Matrix4x4 mx = Matrix4x4.TRS(base.LA.BaseTransform.position, val * base.LA.BaseTransform.rotation, base.LA.BaseTransform.lossyScale);
		base.LA.User_OverwriteCastMatrix(mx);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_RotationStability : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _compenV;

	private LegsAnimator.Variable _sideV;

	private LegsAnimator.Variable _forwV;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.OnInit(helper);
		_powerV = helper.RequestVariable("Rotation Power", 0.4f);
		_compenV = helper.RequestVariable("Compensate Spine", 0.5f);
		_sideV = helper.RequestVariable("Side Multiplier", -1f);
		_forwV = helper.RequestVariable("Forward Multiplier", 1f);
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		float num = _powerV.GetFloat() * base.EffectBlend;
		if (num == 0f)
		{
			return;
		}
		Vector3 zero = Vector3.zero;
		zero += base.LA._Get_Hips_StabilityLocalOffset;
		zero += base.LA._Get_Hips_StabilityLocalAdjustement;
		zero.x /= base.LA.ScaleReferenceNoScale;
		zero.z += zero.y * 0.4f;
		zero.z /= base.LA.ScaleReferenceNoScale;
		zero.x *= 60f;
		zero.z *= 60f;
		Quaternion identity = Quaternion.identity;
		float num2 = 1f / Mathf.Max(0.15f, base.LA.StabilizeCenterOfMass) * 0.5f;
		identity *= Quaternion.AngleAxis(zero.z * num * _forwV.GetFloat() * num2, base.LA.BaseTransform.right);
		identity *= Quaternion.AngleAxis(zero.x * num * _sideV.GetFloat() * num2, base.LA.BaseTransform.forward);
		LegsAnimator lA = base.LA;
		lA._LastHipsRotationOffsetOutsideInfo *= identity;
		for (int i = 0; i < base.LA.HipsHubs.Count; i++)
		{
			LegsAnimator.HipsReference hipsReference = base.LA.HipsHubs[i];
			hipsReference._LastHipsRotationOffsetOutsideInfo *= identity;
		}
		if ((Object)(object)base.LA.SpineBone != (Object)null)
		{
			Quaternion val = Quaternion.identity;
			if ((Object)(object)base.LA.SpineBone != (Object)null)
			{
				val = base.LA.SpineBone.rotation;
			}
			base.LA.Hips.rotation = identity * base.LA.Hips.rotation;
			base.LA.SpineBone.rotation = Quaternion.Lerp(base.LA.SpineBone.rotation, val, _compenV.GetFloat());
		}
		else
		{
			base.LA.Hips.rotation = identity * base.LA.Hips.rotation;
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_SlopePusher : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _thresV;

	private LegsAnimator.Variable _rapidV;

	private LegsAnimator.Variable _pushBackV;

	private Vector3 offsetV = Vector3.zero;

	private Vector3 _Sd_offsetV = Vector3.zero;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_powerV = helper.RequestVariable("Offset Power", 0.6f);
		_thresV = helper.RequestVariable("Push Threshold", 0.5f);
		_rapidV = helper.RequestVariable("Offset Rapidity", 0.5f);
		_pushBackV = helper.RequestVariable("Push Back", 0f);
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (leg.A_WasAligning)
		{
			float num = base.LA.ScaleReferenceNoScale * 0.25f * _thresV.GetFloat();
			if (leg.groundHitRootSpacePos.y > num)
			{
				float num2 = Mathf.InverseLerp(5f, 50f, leg.raycastSlopeAngle);
				float num3 = (leg.groundHitRootSpacePos.y - num) / (num * 1.5f);
				Vector2 val2 = new Vector2(leg.groundHitRootSpacePos.x, leg.groundHitRootSpacePos.z);
				Vector2 normalized = ((Vector2)(ref val2)).normalized;
				val -= new Vector3(normalized.x, -0.033f, normalized.y) * (num3 * num) * _powerV.GetFloat() * 2f * num2;
			}
			if (_pushBackV.GetFloat() > 0f && base.LA.DesiredMovementDirection != Vector3.zero)
			{
				float num4 = _powerV.GetFloat();
				if (num4 <= 0f)
				{
					num4 = 1f;
				}
				Vector3 normalized2 = ((Vector3)(ref val)).normalized;
				Vector3 desiredMovementDirection = base.LA.DesiredMovementDirection;
				float num5 = 0f - Vector3.Dot(normalized2, ((Vector3)(ref desiredMovementDirection)).normalized);
				if (num5 < 0f)
				{
					val *= Mathf.Max(-1f, num5 * 2f) * (_pushBackV.GetFloat() / num4);
				}
			}
		}
		offsetV = Vector3.SmoothDamp(offsetV, val, ref _Sd_offsetV, 0.2f - _rapidV.GetFloat() * 0.199f, 1000000f, base.LA.DeltaTime);
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += base.LA.RootToWorldSpaceVec(offsetV);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_StabilizePoseOnIdle : LegsAnimatorControlModuleBase
{
	private Vector3 currentHeightAdjust = Vector3.zero;

	private Vector3 sd_currentHeightAdjust = Vector3.zero;

	private LegsAnimator.Variable _blendV;

	private LegsAnimator.Variable _adjSpeed;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_blendV = helper.RequestVariable("Blend", 1f);
		_adjSpeed = helper.RequestVariable("Adjusting Speed", 1f);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		currentHeightAdjust = Vector3.zero;
		sd_currentHeightAdjust = Vector3.zero;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		if (base.LA.Legs.Count < 2)
		{
			return;
		}
		bool flag = false;
		if (!base.LA.IsMoving)
		{
			flag = true;
			if (base.LA.UseGluing)
			{
				for (int i = 0; i < base.LA.Legs.Count; i++)
				{
					if (!base.LA.Legs[i].G_Attached)
					{
						flag = false;
						break;
					}
				}
			}
		}
		if (flag)
		{
			LegsAnimator.Leg leg = base.LA.Legs[0];
			Vector3 val = leg._PreviousFinalIKPos + leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
			for (int j = 1; j < base.LA.Legs.Count; j++)
			{
				leg = base.LA.Legs[j];
				Vector3 val2 = leg._PreviousFinalIKPos + leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
				val = Vector3.LerpUnclamped(val, val2, 0.5f);
			}
			val = base.LA.ToRootLocalSpace(val);
			val.y = 0f;
			Vector3 val3 = base.LA.ToRootLocalSpace(base.LA._LastAppliedHipsFinalPosition);
			val3.y = 0f;
			val -= val3;
			val = base.LA.RootToWorldSpaceVec(val);
			currentHeightAdjust = Vector3.SmoothDamp(currentHeightAdjust, val, ref sd_currentHeightAdjust, 0.05f + _adjSpeed.GetFloat() * 0.3f, 1000000f, base.LA.DeltaTime);
		}
		else
		{
			currentHeightAdjust = Vector3.SmoothDamp(currentHeightAdjust, Vector3.zero, ref sd_currentHeightAdjust, 0.05f + _adjSpeed.GetFloat() * 0.3f, 1000000f, base.LA.DeltaTime);
		}
		Transform hips = base.LA.Hips;
		hips.position += currentHeightAdjust * base.EffectBlend * _blendV.GetFloat() * base.LA._MainBlend;
		Vector3 val4 = base.LA.BaseTransform.position + currentHeightAdjust + Vector3.up * 2.4f;
		val4.y = base.LA._LastAppliedHipsFinalPosition.y + 2f;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_StepFurther : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _hipsV;

	private LegsAnimator.Variable _powerV;

	private LegsAnimator.Variable _mulV;

	private Vector3 customVelo = Vector3.zero;

	private Vector3 velo = Vector3.zero;

	private Vector3 finalVelo = Vector3.zero;

	private Vector3 _sd_velo = Vector3.zero;

	private Vector3 lastPos;

	public bool UsingCustomVelo { get; set; }

	public void ProvideVelocity(Vector3 velocity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		UsingCustomVelo = true;
		customVelo = velo;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.OnInit(helper);
		UsingCustomVelo = false;
		_powerV = helper.RequestVariable("Predict Forward Offset", 0.1f);
		_hipsV = helper.RequestVariable("Predict Forward Hips Offset", 0f);
		_mulV = helper.RequestVariable("Extra Multiplier", 1f);
		lastPos = ((Component)base.LA).transform.position;
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vec = (UsingCustomVelo ? base.LA.ToRootLocalSpaceVec(customVelo) : ((Object.op_Implicit((Object)(object)base.LA.Rigidbody) && !base.LA.Rigidbody.isKinematic) ? base.LA.ToRootLocalSpaceVec(base.LA.Rigidbody.velocity) : (base.LA.usingCustomDesiredMovementDirection ? base.LA.ToRootLocalSpaceVec(base.LA.DesiredMovementDirection * base.LA.IsMovingBlend) : ((!(base.LA.DeltaTime > 0f)) ? Vector3.zero : base.LA.ToRootLocalSpaceVec((base.LegsAnim.BaseTransform.position - lastPos) / base.LA.DeltaTime)))));
		lastPos = base.LegsAnim.BaseTransform.position;
		vec.y = 0f;
		vec = base.LA.RootToWorldSpaceVec(vec);
		velo = Vector3.SmoothDamp(velo, vec, ref _sd_velo, 0.1f, 1000000f, base.LA.DeltaTime);
		finalVelo = velo * (_powerV.GetFloat() * _mulV.GetFloat() * base.EffectBlend);
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (_powerV.GetFloat() > 0f)
		{
			leg.OverrideFinalAndSourceIKPos(leg.GetFinalIKPos() + finalVelo);
			leg.OverrideControlPositionsWithCurrentIKState();
		}
		if (leg.PlaymodeIndex == 0 && _hipsV.GetFloat() > 0f)
		{
			LegsAnimator lA = base.LA;
			lA._Hips_Modules_ExtraWOffset += velo * (_hipsV.GetFloat() * base.EffectBlend);
		}
	}
}


using System;
using FIMSpace;
using FIMSpace.AnimationTools;
using FIMSpace.FProceduralAnimation;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class AxisLockableIK : FimpIK_Limb
{
	public enum EIKAxisLock
	{
		None = 0,
		X = 2,
		Y = 4,
		Z = 8
	}

	public EIKAxisLock FirstBoneAxisLock;

	public override void Update()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.Initialized)
		{
			return;
		}
		Refresh();
		float num = IKPositionWeight * IKWeight;
		IKBone startIKBone = base.StartIKBone;
		Vector3 val = base.MiddleIKBone.transform.position - base.StartIKBone.transform.position;
		startIKBone.sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		IKBone middleIKBone = base.MiddleIKBone;
		val = base.EndIKBone.transform.position - base.MiddleIKBone.transform.position;
		middleIKBone.sqrMagn = ((Vector3)(ref val)).sqrMagnitude;
		targetElbowNormal = GetDefaultFlexNormal();
		if (ExtraHintAdjustementOffset != Vector3.zero)
		{
			val = Vector3.Lerp(targetElbowNormal, CalculateElbowNormalToPosition(base.EndIKBone.transform.position + base.EndIKBone.transform.rotation * ExtraHintAdjustementOffset), ((Vector3)(ref ExtraHintAdjustementOffset)).magnitude);
			targetElbowNormal = ((Vector3)(ref val)).normalized;
		}
		Vector3 val2 = GetOrientationDirection(IKTargetPosition, InverseHint ? (-targetElbowNormal) : targetElbowNormal);
		if (val2 == Vector3.zero)
		{
			val2 = base.MiddleIKBone.transform.position - base.StartIKBone.transform.position;
		}
		if (num > 0f)
		{
			Quaternion targetRotation = base.StartIKBone.GetRotation(val2, targetElbowNormal) * base.StartBoneRotationOffset;
			if (num < 1f)
			{
				targetRotation = Quaternion.LerpUnclamped(base.StartIKBone.srcRotation, targetRotation, num);
			}
			if (FirstBoneAxisLock != 0)
			{
				ApplyAxisLock(FirstBoneAxisLock, base.StartIKBone, ref targetRotation);
			}
			base.StartIKBone.transform.rotation = targetRotation;
			Quaternion val3 = base.MiddleIKBone.GetRotation(IKTargetPosition - base.MiddleIKBone.transform.position, base.MiddleIKBone.GetCurrentOrientationNormal());
			if (num < 1f)
			{
				val3 = Quaternion.LerpUnclamped(base.MiddleIKBone.srcRotation, val3, num);
			}
			base.MiddleIKBone.transform.rotation = val3;
		}
		postIKAnimatorEndBoneRot = base.EndIKBone.transform.rotation;
		EndBoneRotation();
	}

	private void ApplyAxisLock(EIKAxisLock axisLock, IKBone ikBone, ref Quaternion targetRotation)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = ikBone.transform.parent.rotation.QToLocal(targetRotation);
		Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		if ((axisLock & EIKAxisLock.X) != 0)
		{
			eulerAngles.x = ((Quaternion)(ref ikBone.LastKeyLocalRotation)).eulerAngles.x;
		}
		if ((axisLock & EIKAxisLock.Y) != 0)
		{
			eulerAngles.y = ((Quaternion)(ref ikBone.LastKeyLocalRotation)).eulerAngles.y;
		}
		if ((axisLock & EIKAxisLock.Z) != 0)
		{
			eulerAngles.z = ((Quaternion)(ref ikBone.LastKeyLocalRotation)).eulerAngles.z;
		}
		targetRotation = ikBone.transform.parent.rotation.QToWorld(AnimationGenerateUtils.EnsureQuaternionContinuity(targetRotation, Quaternion.Euler(eulerAngles)));
	}
}


public enum EIKAxisLock
{
	None = 0,
	X = 2,
	Y = 4,
	Z = 8
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;

public class LAM_IKAlgorithmSwitch : LegsAnimatorControlModuleBase
{
	public bool lockX = true;

	public bool lockY;

	public bool lockZ;

	[NonSerialized]
	private List<AxisLockableIK> playmodeIKProcessors;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		base.OnInit(helper);
		playmodeIKProcessors = new List<AxisLockableIK>();
		for (int i = 0; i < base.LegsAnim.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LegsAnim.Legs[i];
			AxisLockableIK axisLockableIK = new AxisLockableIK();
			playmodeIKProcessors.Add(axisLockableIK);
			leg.AssignCustomIKProcessor(axisLockableIK);
		}
		OnValidateAfterManualChanges(helper);
	}

	private AxisLockableIK.EIKAxisLock GetLock()
	{
		AxisLockableIK.EIKAxisLock eIKAxisLock = AxisLockableIK.EIKAxisLock.None;
		if (lockX)
		{
			eIKAxisLock |= AxisLockableIK.EIKAxisLock.X;
		}
		if (lockY)
		{
			eIKAxisLock |= AxisLockableIK.EIKAxisLock.Y;
		}
		if (lockZ)
		{
			eIKAxisLock |= AxisLockableIK.EIKAxisLock.Z;
		}
		return eIKAxisLock;
	}

	private void OnValidate()
	{
		OnValidateAfterManualChanges(null);
	}

	public override void OnValidateAfterManualChanges(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (helper != null)
		{
			base.OnValidateAfterManualChanges(helper);
		}
		if (playmodeIKProcessors != null)
		{
			for (int i = 0; i < playmodeIKProcessors.Count; i++)
			{
				playmodeIKProcessors[i].FirstBoneAxisLock = GetLock();
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;

public class LAM_FadeGluingOnAnimator : LAM_FadeOnAnimatorStatusBase
{
	protected override void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue)
	{
		helper.Parent.MainGlueBlend = fadeValue;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_FadeGluingOnAnimatorParam : LegsAnimatorControlModuleBase
{
	private int _hash = -1;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		string @string = helper.RequestVariable("Disable Gluing On Bool Param", "Animator Param Name").GetString();
		_hash = Animator.StringToHash(@string);
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (helper.Parent.Mecanim.GetBool(_hash))
		{
			helper.Parent.MainGlueBlend = Mathf.MoveTowards(helper.Parent.MainGlueBlend, 0.001f, Time.deltaTime * 7f);
		}
		else
		{
			helper.Parent.MainGlueBlend = Mathf.MoveTowards(helper.Parent.MainGlueBlend, 1f, Time.deltaTime * 7f);
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_FadeLegsSystemOnAnimator : LAM_FadeOnAnimatorStatusBase
{
	protected override void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue)
	{
		helper.Parent.LegsAnimatorBlend = Mathf.Max(0.001f, fadeValue);
	}
}


using System;
using UnityEngine;

[Serializable]
public class MotionInfluenceProcessor
{
	public bool AdvancedInfluence;

	public Vector3 AxisMotionInfluence = Vector3.one;

	public Vector3 AxisMotionInfluenceBackwards = Vector3.one;

	private float MultiplyBlend = 1f;

	[NonSerialized]
	public float ExtraBoost = 1f;

	private float _sd_mb;

	private Transform root;

	public Vector3 OutputInfluenceOffset { get; private set; }

	public Vector3 previousPosition { get; private set; }

	public Vector3 rootOffset { get; private set; }

	public Vector3 localOffset { get; private set; }

	public void TransitionBlend(float target, float duration, float delta)
	{
		MultiplyBlend = Mathf.SmoothDamp(MultiplyBlend, target, ref _sd_mb, duration, 10000000f, delta);
	}

	public void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		previousPosition = root.position;
		localOffset = Vector3.zero;
		rootOffset = Vector3.zero;
	}

	public void Init(Transform root)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		this.root = root;
		previousPosition = root.position;
		localOffset = Vector3.zero;
	}

	public void Update()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		rootOffset = root.position - previousPosition;
		previousPosition = root.position;
		localOffset = root.InverseTransformVector(rootOffset);
		float num = MultiplyBlend * ExtraBoost;
		if (num != 1f)
		{
			localOffset *= num;
		}
		Motion_MotionInfluence();
	}

	public void OverrideOffset(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		rootOffset = offset;
		localOffset = root.InverseTransformVector(rootOffset);
		Motion_MotionInfluence();
	}

	private void Motion_MotionInfluence()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!AdvancedInfluence)
		{
			if (AxisMotionInfluence != Vector3.one)
			{
				OutputInfluenceOffset = root.TransformVector(ScaleMotionInfluence(localOffset, AxisMotionInfluence));
			}
		}
		else
		{
			OutputInfluenceOffset = root.TransformVector(ScaleMotionInfluence(localOffset, AxisMotionInfluence, AxisMotionInfluenceBackwards));
		}
	}

	private Vector3 ScaleMotionInfluence(Vector3 toScale, Vector3 influenceMul)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(toScale.x * (1f - influenceMul.x), toScale.y * (1f - influenceMul.y), toScale.z * (1f - influenceMul.z));
	}

	private Vector3 ScaleMotionInfluence(Vector3 toScale, Vector3 influenceMulForw, Vector3 influenceMulBack)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		if (toScale.x > 0f)
		{
			toScale.x *= 1f - influenceMulForw.x;
		}
		else
		{
			toScale.x *= 1f - influenceMulBack.x;
		}
		if (toScale.y > 0f)
		{
			toScale.y *= 1f - influenceMulForw.y;
		}
		else
		{
			toScale.y *= 1f - influenceMulBack.y;
		}
		if (toScale.z > 0f)
		{
			toScale.z *= 1f - influenceMulForw.z;
		}
		else
		{
			toScale.z *= 1f - influenceMulBack.z;
		}
		return toScale;
	}

	public Vector3 CalculateInversedInfluence()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!AdvancedInfluence)
		{
			if (AxisMotionInfluence != Vector3.one)
			{
				return root.TransformVector(ScaleMotionInfluenceInverse(localOffset, AxisMotionInfluence));
			}
			return rootOffset;
		}
		return root.TransformVector(ScaleMotionInfluenceInverse(localOffset, AxisMotionInfluence, AxisMotionInfluenceBackwards));
	}

	private Vector3 ScaleMotionInfluenceInverse(Vector3 toScale, Vector3 influenceMul)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(toScale.x * influenceMul.x, toScale.y * influenceMul.y, toScale.z * influenceMul.z);
	}

	private Vector3 ScaleMotionInfluenceInverse(Vector3 toScale, Vector3 influenceMulForw, Vector3 influenceMulBack)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (toScale.x > 0f)
		{
			toScale.x *= influenceMulForw.x;
		}
		else
		{
			toScale.x *= influenceMulBack.x;
		}
		if (toScale.y > 0f)
		{
			toScale.y *= influenceMulForw.y;
		}
		else
		{
			toScale.y *= influenceMulBack.y;
		}
		if (toScale.z > 0f)
		{
			toScale.z *= influenceMulForw.z;
		}
		else
		{
			toScale.z *= influenceMulBack.z;
		}
		return toScale;
	}
}


using FIMSpace;
using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent))]
public class FGroundFitter_Demo_NavMesh : MonoBehaviour
{
	public FGroundFitter_Base TargetGroundFitter;

	[Range(0.5f, 50f)]
	public float RotationSpeed = 3f;

	[Range(0f, 1f)]
	[Tooltip("Moving Accordingly to rotation after acceleration")]
	public float DirectMovement = 0.8f;

	public float AnimationSpeedScale = 1f;

	private NavMeshAgent agent;

	private FAnimationClips animationClips;

	private bool reachedDestination;

	private Vector3 lastAgentPosition;

	private string movementClip;

	private float dirMov;

	private float sd_dirMov;

	public bool moving { get; private set; }

	private void Reset()
	{
		TargetGroundFitter = ((Component)this).GetComponent<FGroundFitter_Base>();
		if (Object.op_Implicit((Object)(object)TargetGroundFitter))
		{
			TargetGroundFitter.GlueToGround = false;
		}
		agent = ((Component)this).GetComponent<NavMeshAgent>();
		if (Object.op_Implicit((Object)(object)agent))
		{
			agent.acceleration = 1000f;
			agent.angularSpeed = 100f;
		}
	}

	protected virtual void Start()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TargetGroundFitter == (Object)null)
		{
			TargetGroundFitter = ((Component)this).GetComponent<FGroundFitter_Base>();
		}
		if (Object.op_Implicit((Object)(object)TargetGroundFitter))
		{
			TargetGroundFitter.GlueToGround = false;
		}
		agent = ((Component)this).GetComponent<NavMeshAgent>();
		agent.Warp(((Component)this).transform.position);
		agent.SetDestination(((Component)this).transform.position);
		moving = false;
		lastAgentPosition = ((Component)this).transform.position;
		reachedDestination = true;
		animationClips = new FAnimationClips(((Component)this).GetComponentInChildren<Animator>());
		animationClips.AddClip("Idle");
		if (animationClips.Animator.StateExists("Move") || animationClips.Animator.StateExists("move"))
		{
			movementClip = "Move";
		}
		else
		{
			movementClip = "Walk";
		}
		animationClips.AddClip(movementClip);
	}

	protected virtual void Update()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		FAnimationClips fAnimationClips = animationClips;
		Vector3 val = agent.desiredVelocity;
		fAnimationClips.SetFloat("AnimationSpeed", ((Vector3)(ref val)).magnitude * AnimationSpeedScale, 8f);
		IsMovingCheck();
		Vector3 val2 = agent.nextPosition - lastAgentPosition;
		val = agent.velocity;
		float magnitude = ((Vector3)(ref val)).magnitude;
		_ = ((Vector3)(ref val2)).normalized;
		Vector3 val3 = agent.nextPosition;
		if (DirectMovement > 0f)
		{
			if (magnitude > 0f)
			{
				Vector3 val4 = lastAgentPosition + ((Component)this).transform.forward * magnitude * Time.deltaTime;
				float num = 0.25f;
				float num2 = 1f;
				if (agent.remainingDistance <= agent.stoppingDistance * 1.1f + 0.1f)
				{
					num = 0.1f;
					num2 = 0f;
				}
				dirMov = Mathf.SmoothDamp(dirMov, num2, ref sd_dirMov, num, 1000f, Time.deltaTime);
				val3 = Vector3.LerpUnclamped(val3, val4, dirMov);
			}
			else
			{
				dirMov = Mathf.SmoothDamp(dirMov, 0f, ref sd_dirMov, 0.1f, 1000f, Time.deltaTime);
			}
		}
		val3.y = agent.nextPosition.y;
		((Component)this).transform.position = val3;
		if (moving)
		{
			Vector3 val5 = agent.nextPosition + agent.desiredVelocity;
			Quaternion val6 = Quaternion.LookRotation(new Vector3(val5.x, 0f, val5.z) - ((Component)this).transform.position);
			float y = ((Quaternion)(ref val6)).eulerAngles.y;
			TargetGroundFitter.UpAxisRotation = Mathf.LerpAngle(TargetGroundFitter.UpAxisRotation, y, Time.deltaTime * RotationSpeed);
		}
		lastAgentPosition = val3;
	}

	private bool IsMovingCheck()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		bool num = moving;
		moving = true;
		if (!agent.pathPending && agent.remainingDistance <= agent.stoppingDistance)
		{
			if (agent.hasPath)
			{
				Vector3 velocity = agent.velocity;
				if (((Vector3)(ref velocity)).sqrMagnitude != 0f)
				{
					goto IL_006e;
				}
			}
			if (!reachedDestination)
			{
				OnReachDestination();
			}
			moving = false;
		}
		goto IL_006e;
		IL_006e:
		if (num != moving)
		{
			OnStartMoving();
		}
		return moving;
	}

	protected virtual void OnReachDestination()
	{
		reachedDestination = true;
		animationClips.CrossFadeInFixedTime("Idle");
	}

	protected virtual void OnStartMoving()
	{
		reachedDestination = false;
		animationClips.CrossFadeInFixedTime(movementClip);
	}
}


using UnityEngine;
using UnityEngine.AI;

public class FGroundFitter_Demo_NavMeshInput : MonoBehaviour
{
	public NavMeshAgent TargetAgent;

	private void Update()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetMouseButtonDown(0) && Object.op_Implicit((Object)(object)TargetAgent))
		{
			Ray val = Camera.main.ScreenPointToRay(Input.mousePosition);
			RaycastHit val2 = default(RaycastHit);
			NavMeshHit val3 = default(NavMeshHit);
			if (Physics.Raycast(((Ray)(ref val)).origin, ((Ray)(ref val)).direction, ref val2) && NavMesh.SamplePosition(((RaycastHit)(ref val2)).point, ref val3, 1f, 1))
			{
				TargetAgent.SetDestination(((NavMeshHit)(ref val3)).position);
			}
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_Patrolling : MonoBehaviour
{
	public Vector4 MovementRandomPointRange = new Vector4(25f, -25f, 25f, -25f);

	public float speed = 1f;

	private Transform bodyTransform;

	private float bodyRotateSpeed = 5f;

	private Animator animator;

	private FGroundFitter fitter;

	private float timer;

	private Vector3 targetPoint;

	private bool onDestination;

	private FAnimationClips clips;

	private void Start()
	{
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		fitter = ((Component)this).GetComponent<FGroundFitter>();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		timer = Random.Range(1f, 5f);
		if (((Object)this).name.Contains("Fpider"))
		{
			bodyTransform = ((Component)this).transform.GetChild(0).Find("BSkeleton").GetChild(0)
				.Find("Body_Shield");
		}
		((Component)this).transform.rotation = Quaternion.Euler(0f, Random.Range(-180f, 180f), 0f);
		FGroundFitter fGroundFitter = fitter;
		Quaternion rotation = ((Component)this).transform.rotation;
		fGroundFitter.UpAxisRotation = ((Quaternion)(ref rotation)).eulerAngles.y;
		onDestination = true;
		((Component)this).transform.localScale = Vector3.one * Random.Range(0.5f, 1f);
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Move");
	}

	private void Update()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		if (onDestination)
		{
			timer -= Time.deltaTime;
			if (timer < 0f)
			{
				ChooseNewDestination();
			}
			bodyRotateSpeed = Mathf.Lerp(bodyRotateSpeed, 50f, Time.deltaTime * 2f);
		}
		else
		{
			RaycastHit lastRaycast = fitter.LastRaycast;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				Transform transform = ((Component)this).transform;
				lastRaycast = fitter.LastRaycast;
				transform.position = ((RaycastHit)(ref lastRaycast)).point;
			}
			Transform transform2 = ((Component)this).transform;
			transform2.position += ((Component)this).transform.forward * speed * Time.deltaTime;
			if (Vector3.Distance(((Component)this).transform.position, targetPoint) < 2f)
			{
				ReachDestination();
			}
			Quaternion val = Quaternion.LookRotation(targetPoint - ((Component)this).transform.position);
			fitter.UpAxisRotation = Mathf.LerpAngle(fitter.UpAxisRotation, ((Quaternion)(ref val)).eulerAngles.y, Time.deltaTime * 7f);
			bodyRotateSpeed = Mathf.Lerp(bodyRotateSpeed, -250f, Time.deltaTime * 3f);
		}
		if (Object.op_Implicit((Object)(object)bodyTransform))
		{
			bodyTransform.Rotate(0f, 0f, Time.deltaTime * bodyRotateSpeed);
		}
	}

	private void ChooseNewDestination()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		targetPoint = new Vector3(Random.Range(MovementRandomPointRange.x, MovementRandomPointRange.y), 0f, Random.Range(MovementRandomPointRange.z, MovementRandomPointRange.w));
		RaycastHit val = default(RaycastHit);
		Physics.Raycast(targetPoint + Vector3.up * 1000f, Vector3.down, ref val, float.PositiveInfinity, LayerMask.op_Implicit(fitter.GroundLayerMask), (QueryTriggerInteraction)1);
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
		{
			targetPoint = ((RaycastHit)(ref val)).point;
		}
		animator.CrossFadeInFixedTime(clips["Move"], 0.25f);
		onDestination = false;
	}

	private void ReachDestination()
	{
		timer = Random.Range(1f, 5f);
		onDestination = true;
		animator.CrossFadeInFixedTime(clips["Idle"], 0.15f);
	}
}


using FIMSpace;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_RootMotionExample : FGroundFitter_Movement
{
	protected override void Start()
	{
		base.Start();
		clips.AddClip("RotateL");
		clips.AddClip("RotateR");
	}

	protected override void HandleAnimations()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetKey((KeyCode)97))
		{
			CrossfadeTo("RotateL");
			MoveVector = Vector3.zero;
		}
		else if (Input.GetKey((KeyCode)100))
		{
			CrossfadeTo("RotateR");
			MoveVector = Vector3.zero;
		}
		else if (ActiveSpeed > 0.15f)
		{
			if (Sprint)
			{
				CrossfadeTo("Run");
			}
			else
			{
				CrossfadeTo("Walk");
			}
		}
		else
		{
			CrossfadeTo("Idle");
		}
		if (animatorHaveAnimationSpeedProp)
		{
			if (inAir)
			{
				animator.LerpFloatValue("AnimationSpeed");
			}
			else
			{
				animator.LerpFloatValue("AnimationSpeed", MultiplySprintAnimation ? (ActiveSpeed / BaseSpeed) : Mathf.Min(1f, ActiveSpeed / BaseSpeed));
			}
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter : FGroundFitter_Base_RootMotion
{
	[Header("< Specific Parameters >")]
	public EFUpdateClock UpdateClock;

	protected override void Reset()
	{
		base.Reset();
		RelativeLookUp = true;
		RelativeLookUpBias = 0.25f;
	}

	private void Update()
	{
		if (UpdateClock == EFUpdateClock.Update)
		{
			deltaTime = Time.deltaTime;
			FitToGround();
		}
	}

	private void FixedUpdate()
	{
		if (UpdateClock == EFUpdateClock.FixedUpdate)
		{
			deltaTime = Time.fixedDeltaTime;
			FitToGround();
		}
	}

	private void LateUpdate()
	{
		if (UpdateClock == EFUpdateClock.LateUpdate)
		{
			deltaTime = Time.deltaTime;
			FitToGround();
		}
	}

	public void RefreshDelta()
	{
		switch (UpdateClock)
		{
		case EFUpdateClock.Update:
			deltaTime = Time.deltaTime;
			break;
		case EFUpdateClock.LateUpdate:
			deltaTime = Time.deltaTime;
			break;
		case EFUpdateClock.FixedUpdate:
			deltaTime = Time.fixedDeltaTime;
			break;
		}
	}

	protected override void FitToGround()
	{
		HandleRootMotionSupport();
		base.FitToGround();
	}

	protected override void HandleRootMotionSupport()
	{
		base.HandleRootMotionSupport();
		if (HandleRootMotion)
		{
			UpdateClock = EFUpdateClock.LateUpdate;
		}
	}
}


using System;
using FIMSpace;
using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

[RequireComponent(typeof(FGroundFitter))]
public class FGroundFitter_Movement : MonoBehaviour
{
	[Header("> Main Tweak Variables <")]
	public float BaseSpeed = 3f;

	public float RotateToTargetSpeed = 6f;

	public float SprintingSpeed = 10f;

	protected float ActiveSpeed;

	public float AccelerationSpeed = 10f;

	public float DecelerationSpeed = 10f;

	[Header("> Additional Options <")]
	public float JumpPower = 7f;

	public float gravity = 15f;

	public bool MultiplySprintAnimation;

	[Range(0f, 20f)]
	public float RotateBackInAir;

	[Tooltip("Protecting from going through walls when slope is very big and ground fitter is jumping into it")]
	public bool NotFallingThrough;

	[Header("(experimental)")]
	[Tooltip("You need collider and rigidbody on object to make it work right - ALSO CHANGE YOUR CAMERA UPDATE CLOCK TO FIXED UPDATE AND USE TIME.fixedDeltaTime - ! For now it can cause errors when jumping, character can go through floor sometimes ! - Will be upgraded in future versions")]
	public bool UsePhysics;

	[Tooltip("Disabling translating object from code and running animation without need to hold minimum movement speed")]
	public bool UseRootMotionTranslation;

	public bool UseRootMotionRotation;

	internal float YVelocity;

	protected bool inAir;

	protected float gravitUpOffset;

	internal Vector3 lastNotZeroMoveVector = Vector3.zero;

	internal Vector3 MoveVector = Vector3.zero;

	internal bool Sprint;

	internal float RotationOffset;

	protected string lastAnim = "";

	protected Animator animator;

	protected FGroundFitter fitter;

	protected Rigidbody rigb;

	protected bool animatorHaveAnimationSpeedProp;

	protected float initialUpOffset;

	protected Vector3 holdJumpPosition;

	protected float freezeJumpYPosition;

	protected float delta;

	protected Vector3 lastVelocity;

	protected Collider itsCollider;

	protected FAnimationClips clips;

	internal static int _hash_animSp = Animator.StringToHash("AnimationSpeed");

	private int _hash_IsGrounded = -1;

	private int _hash_IsMov = -1;

	private bool slidingAssigned;

	private float? yAdjustPos;

	[HideInInspector]
	[Tooltip("If you want to set some animator parameter during being grounded")]
	public string SetIsGroundedParam = "";

	[HideInInspector]
	[Tooltip("If you want to set some animator parameter during accelerating moving")]
	public string SetIsMovingParam = "";

	[HideInInspector]
	[Tooltip("If using physical move with collider, assigning to the collider sliding material")]
	public bool UseSlidingMat = true;

	private static PhysicMaterial pm_Sliding = null;

	private void Reset()
	{
		if (!Object.op_Implicit((Object)(object)((Component)this).gameObject.GetComponent<FGroundFitter_Input>()))
		{
			((Component)this).gameObject.AddComponent<FGroundFitter_Input>();
		}
	}

	protected virtual void Start()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		fitter = ((Component)this).GetComponent<FGroundFitter>();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		rigb = ((Component)this).GetComponent<Rigidbody>();
		itsCollider = ((Component)this).GetComponentInChildren<Collider>();
		if (!string.IsNullOrEmpty(SetIsGroundedParam))
		{
			_hash_IsGrounded = Animator.StringToHash(SetIsGroundedParam);
		}
		if (!string.IsNullOrEmpty(SetIsMovingParam))
		{
			_hash_IsMov = Animator.StringToHash(SetIsMovingParam);
		}
		if (Object.op_Implicit((Object)(object)animator))
		{
			if (HasParameter(animator, "AnimationSpeed"))
			{
				animatorHaveAnimationSpeedProp = true;
			}
			animator.applyRootMotion = false;
		}
		FGroundFitter fGroundFitter = fitter;
		Quaternion rotation = ((Component)this).transform.rotation;
		fGroundFitter.UpAxisRotation = ((Quaternion)(ref rotation)).eulerAngles.y;
		initialUpOffset = fitter.UpOffset;
		fitter.RefreshLastRaycast();
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Walk");
		clips.AddClip("Run");
	}

	protected virtual void Update()
	{
		HandleBaseVariables();
		HandleGravity();
		HandleAnimations();
		HandleTransforming();
		if (!UsePhysics)
		{
			ApplyTransforming();
		}
	}

	protected virtual void FixedUpdate()
	{
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected O, but got Unknown
		if (Object.op_Implicit((Object)(object)rigb))
		{
			if (UsePhysics)
			{
				rigb.useGravity = false;
				rigb.isKinematic = false;
				if (!slidingAssigned)
				{
					Collider componentInChildren = ((Component)this).GetComponentInChildren<Collider>();
					if (Object.op_Implicit((Object)(object)componentInChildren))
					{
						if ((Object)(object)pm_Sliding == (Object)null)
						{
							pm_Sliding = new PhysicMaterial("Sliding");
							pm_Sliding.bounciness = 0f;
							pm_Sliding.frictionCombine = (PhysicMaterialCombine)2;
							pm_Sliding.dynamicFriction = 0f;
							pm_Sliding.staticFriction = 0f;
						}
						componentInChildren.material = pm_Sliding;
						slidingAssigned = true;
					}
				}
			}
			else
			{
				rigb.isKinematic = true;
			}
		}
		if (!UsePhysics)
		{
			fitter.ApplyRotation = true;
			return;
		}
		ApplyTransforming();
		rigb.angularVelocity = Vector3.zero;
		rigb.freezeRotation = true;
		fitter.ApplyRotation = false;
		rigb.rotation = fitter.targetRotationToApply;
	}

	protected virtual void HandleBaseVariables()
	{
		delta = Time.deltaTime;
		if (UseRootMotionTranslation)
		{
			fitter.HandleRootMotion = false;
			if ((Object)(object)((Component)animator).gameObject != (Object)(object)((Component)this).gameObject && !animator.applyRootMotion && !Object.op_Implicit((Object)(object)((Component)animator).GetComponent<FGroundFitter_RootMotionHelper>()))
			{
				((Component)animator).gameObject.AddComponent<FGroundFitter_RootMotionHelper>().MovementController = this;
			}
			fitter.UpdateClock = EFUpdateClock.LateUpdate;
			animator.applyRootMotion = true;
		}
		else
		{
			animator.applyRootMotion = false;
		}
	}

	protected virtual void HandleGravity()
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)fitter).enabled)
		{
			if (fitter.UpOffset > initialUpOffset)
			{
				fitter.UpOffset += YVelocity * delta;
			}
			else
			{
				fitter.UpOffset = initialUpOffset;
			}
		}
		else
		{
			fitter.UpOffset += YVelocity * delta;
		}
		if (inAir)
		{
			YVelocity -= gravity * delta;
			fitter.RefreshDelta();
			fitter.RotateBack(RotateBackInAir);
		}
		if (((Behaviour)fitter).enabled)
		{
			RaycastHit lastRaycast = fitter.LastRaycast;
			if (!Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				if (!inAir)
				{
					inAir = true;
					holdJumpPosition = ((Component)this).transform.position;
					freezeJumpYPosition = holdJumpPosition.y;
					YVelocity = -1f;
					((Behaviour)fitter).enabled = false;
				}
			}
			else if (YVelocity > 0f)
			{
				inAir = true;
			}
		}
		if (!inAir)
		{
			return;
		}
		if (((Behaviour)fitter).enabled)
		{
			((Behaviour)fitter).enabled = false;
		}
		if (YVelocity < 0f)
		{
			RaycastHit val = fitter.CastRay();
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform) && ((Component)this).transform.position.y + YVelocity * delta <= ((RaycastHit)(ref val)).point.y + initialUpOffset + 0.05f)
			{
				fitter.UpOffset -= ((RaycastHit)(ref val)).point.y - freezeJumpYPosition;
				HitGround();
			}
		}
		else
		{
			RaycastHit val2 = fitter.CastRay();
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val2)).transform) && ((RaycastHit)(ref val2)).point.y - 0.1f > ((Component)this).transform.position.y)
			{
				fitter.UpOffset = initialUpOffset;
				YVelocity = -1f;
				HitGround();
			}
		}
		if (NotFallingThrough && inAir)
		{
			Vector3 forward = ((Component)fitter).transform.forward;
			float raycastCheckRange = fitter.RaycastCheckRange;
			if (Physics.Raycast(fitter.GetRaycastOrigin() - forward * raycastCheckRange * 0.1f, forward, raycastCheckRange * 1.11f, LayerMask.op_Implicit(fitter.GroundLayerMask), (QueryTriggerInteraction)1))
			{
				float raycastCheckRange2 = fitter.RaycastCheckRange;
				fitter.RaycastCheckRange *= 100f;
				fitter.UpOffset = initialUpOffset;
				YVelocity = -1f;
				HitGround();
				fitter.RaycastCheckRange = raycastCheckRange2;
			}
		}
	}

	protected virtual void HandleAnimations()
	{
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		float value = 1f;
		if (ActiveSpeed > 0.15f)
		{
			if (ActiveSpeed > (BaseSpeed + SprintingSpeed) * 0.25f)
			{
				value = ActiveSpeed / SprintingSpeed;
				CrossfadeTo("Run");
			}
			else
			{
				value = ActiveSpeed / BaseSpeed;
				CrossfadeTo("Walk");
			}
		}
		else
		{
			CrossfadeTo("Idle");
		}
		if (animatorHaveAnimationSpeedProp)
		{
			if (inAir)
			{
				animator.LerpFloatValue("AnimationSpeed");
			}
			else
			{
				animator.LerpFloatValue("AnimationSpeed", value);
			}
		}
		if (Object.op_Implicit((Object)(object)animator))
		{
			if (_hash_IsGrounded != -1)
			{
				animator.SetBool(_hash_IsGrounded, !inAir);
			}
			if (_hash_IsMov != -1)
			{
				animator.SetBool(_hash_IsMov, MoveVector != Vector3.zero);
			}
		}
	}

	protected void RefreshHitGroundVars(RaycastHit hit)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		holdJumpPosition = ((RaycastHit)(ref hit)).point;
		freezeJumpYPosition = ((RaycastHit)(ref hit)).point.y;
		fitter.UpOffset = Mathf.Abs(((RaycastHit)(ref hit)).point.y - ((Component)this).transform.position.y);
	}

	protected virtual void HandleTransforming()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		if (!UseRootMotionTranslation)
		{
			lastVelocity = ((Component)this).transform.TransformDirection(lastNotZeroMoveVector) * ActiveSpeed;
		}
		if (((Behaviour)fitter).enabled)
		{
			RaycastHit lastRaycast = fitter.LastRaycast;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				lastRaycast = fitter.LastRaycast;
				Vector3 val = ((RaycastHit)(ref lastRaycast)).point + fitter.UpOffset * Vector3.up;
				if (!UsePhysics)
				{
					((Component)this).transform.position = val;
				}
				else if (Object.op_Implicit((Object)(object)rigb))
				{
					yAdjustPos = val.y;
				}
				holdJumpPosition = ((Component)this).transform.position;
				freezeJumpYPosition = holdJumpPosition.y;
			}
			else
			{
				inAir = true;
			}
		}
		else
		{
			holdJumpPosition.y = freezeJumpYPosition + fitter.UpOffset;
		}
		if (MoveVector != Vector3.zero)
		{
			if (!UseRootMotionRotation)
			{
				if (!((Behaviour)fitter).enabled)
				{
					fitter.UpAxisRotation = Mathf.LerpAngle(fitter.UpAxisRotation, ((Component)Camera.main).transform.eulerAngles.y + RotationOffset, delta * RotateToTargetSpeed * 0.15f);
					fitter.RotationCalculations();
				}
				else
				{
					fitter.UpAxisRotation = Mathf.LerpAngle(fitter.UpAxisRotation, ((Component)Camera.main).transform.eulerAngles.y + RotationOffset, delta * RotateToTargetSpeed);
				}
			}
			if (!Sprint)
			{
				ActiveSpeed = Mathf.Lerp(ActiveSpeed, BaseSpeed, delta * AccelerationSpeed);
			}
			else
			{
				ActiveSpeed = Mathf.Lerp(ActiveSpeed, SprintingSpeed, delta * AccelerationSpeed);
			}
		}
		else if (ActiveSpeed > 0f)
		{
			ActiveSpeed = Mathf.Lerp(ActiveSpeed, -0.01f, delta * DecelerationSpeed);
		}
		else
		{
			ActiveSpeed = 0f;
		}
		holdJumpPosition += lastVelocity * delta;
		if (MoveVector != Vector3.zero)
		{
			lastNotZeroMoveVector = MoveVector;
		}
	}

	private void ApplyTransforming()
	{
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (UsePhysics && Object.op_Implicit((Object)(object)rigb))
		{
			float num = YVelocity;
			if (!inAir && yAdjustPos.HasValue)
			{
				num = (yAdjustPos.Value - rigb.position.y) / Time.fixedDeltaTime;
			}
			rigb.velocity = new Vector3(lastVelocity.x, num, lastVelocity.z);
		}
		else
		{
			((Component)this).transform.position = holdJumpPosition;
		}
	}

	internal virtual void OnAnimatorMove()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (UseRootMotionTranslation)
		{
			if (!inAir)
			{
				lastVelocity = animator.velocity;
			}
			animator.rootPosition = ((Component)this).transform.position;
			animator.rootRotation = fitter.LastRotation;
		}
		if (UseRootMotionRotation)
		{
			animator.rootRotation = fitter.LastRotation;
			Quaternion deltaRotation = animator.deltaRotation;
			float num = default(float);
			Vector3 val = default(Vector3);
			((Quaternion)(ref deltaRotation)).ToAngleAxis(ref num, ref val);
			float y = (val * num * (MathF.PI / 180f)).y;
			fitter.UpAxisRotation += y / Time.deltaTime;
		}
	}

	protected virtual void HitGround()
	{
		fitter.RefreshLastRaycast();
		((Behaviour)fitter).enabled = true;
		inAir = false;
		freezeJumpYPosition = 0f;
	}

	public virtual void Jump()
	{
		YVelocity = JumpPower;
		fitter.UpOffset += JumpPower * Time.deltaTime / 2f;
	}

	protected virtual void CrossfadeTo(string animation, float transitionTime = 0.25f)
	{
		if (!clips.ContainsKey(animation))
		{
			if (!(animation == "Run"))
			{
				return;
			}
			animation = "Walk";
		}
		if (lastAnim != animation)
		{
			animator.CrossFadeInFixedTime(clips[animation], transitionTime);
			lastAnim = animation;
		}
	}

	public static bool HasParameter(Animator animator, string paramName)
	{
		AnimatorControllerParameter[] parameters = animator.parameters;
		for (int i = 0; i < parameters.Length; i++)
		{
			if (parameters[i].name == paramName)
			{
				return true;
			}
		}
		return false;
	}
}


using FIMSpace;
using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundRotator : FGroundFitter_Base
{
	[Tooltip("Root transform should be first object in the hierarchy of your movement game object")]
	public Transform RootTransform;

	public EFUpdateClock UpdateClock;

	private Quaternion initLocalRotation;

	private Vector3 mappingRight;

	private Vector3 mappingUp;

	private Vector3 mappingForward;

	protected override void Reset()
	{
		base.Reset();
		RelativeLookUp = false;
		RelativeLookUpBias = 0f;
		GlueToGround = false;
	}

	protected override void Start()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		base.Start();
		initLocalRotation = TransformToRotate.localRotation;
		mappingForward = ((Component)this).transform.InverseTransformDirection(RootTransform.forward);
		mappingUp = ((Component)this).transform.InverseTransformDirection(RootTransform.up);
		mappingRight = ((Component)this).transform.InverseTransformDirection(RootTransform.right);
	}

	private void Update()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (UpdateClock != EFUpdateClock.FixedUpdate)
		{
			TransformToRotate.localRotation = initLocalRotation;
		}
	}

	private void FixedUpdate()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (UpdateClock == EFUpdateClock.FixedUpdate)
		{
			TransformToRotate.localRotation = initLocalRotation;
		}
	}

	private void LateUpdate()
	{
		deltaTime = Time.deltaTime;
		FitToGround();
	}

	internal override void RotationCalculations()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		targetRotationToApply = helperRotation;
		targetRotationToApply *= RootTransform.rotation;
		Vector3 eulerAngles = ((Quaternion)(ref targetRotationToApply)).eulerAngles;
		targetRotationToApply = Quaternion.Euler(Mathf.Clamp(FLogicMethods.WrapAngle(eulerAngles.x), 0f - MaxForwardRotation, MaxForwardRotation) * (1f - MildForwardValue), eulerAngles.y, Mathf.Clamp(FLogicMethods.WrapAngle(eulerAngles.z), 0f - MaxHorizontalRotation, MaxHorizontalRotation) * (1f - MildHorizontalValue));
		eulerAngles = ((Quaternion)(ref targetRotationToApply)).eulerAngles;
		Quaternion val = RootTransform.rotation.QToLocal(Quaternion.Euler(eulerAngles));
		eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		Quaternion val2 = TransformToRotate.rotation;
		if (eulerAngles.x != 0f)
		{
			val2 *= Quaternion.AngleAxis(eulerAngles.x, mappingRight);
		}
		if (eulerAngles.y != 0f)
		{
			val2 *= Quaternion.AngleAxis(eulerAngles.y, mappingUp);
		}
		if (eulerAngles.z != 0f)
		{
			val2 *= Quaternion.AngleAxis(eulerAngles.z, mappingForward);
		}
		TransformToRotate.rotation = val2;
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FSimpleFitter : FGroundFitter_Base_RootMotion
{
	protected override void Reset()
	{
		base.Reset();
		RelativeLookUp = false;
		RelativeLookUpBias = 0f;
	}

	private void LateUpdate()
	{
		deltaTime = Time.deltaTime;
		FitToGround();
	}

	protected override void FitToGround()
	{
		HandleRootMotionSupport();
		base.FitToGround();
	}

	protected override void HandleRootMotionSupport()
	{
		base.HandleRootMotionSupport();
	}
}


using System;
using System.Collections.Generic;
using FIMSpace;
using UnityEngine;

public abstract class FGroundFitter_Base : MonoBehaviour
{
	[Header("> Main Variables <", order = 0)]
	[Space(4f, order = 1)]
	[Tooltip("How quick rotation should be corrected to target")]
	[Range(1f, 30f)]
	public float FittingSpeed = 6f;

	[Tooltip("Smoothing whole rotation motion")]
	[Range(0f, 1f)]
	public float TotalSmoother;

	[HideInInspector]
	[Tooltip("Transform which will be rotated by script, usually it can be the same transform as component's")]
	[Space(3f)]
	public Transform TransformToRotate;

	[Tooltip("If you want this script only to change your object's rotation and do nothing with position, untoggle this")]
	[Space(3f)]
	public bool GlueToGround;

	[Space(4f, order = 1)]
	[Range(0f, 1f)]
	[Tooltip("If forward/pitch rotation value should go in lighter value than real normal hit direction")]
	[Header("> Tweaking Settings <", order = 0)]
	public float MildForwardValue;

	[Range(0f, 90f)]
	[Tooltip("Maximum rotation angle in rotation of x/pitch axis, so rotating forward - degrees value of maximum rotation")]
	public float MaxForwardRotation = 90f;

	[Tooltip("If side rotation value/roll should go in lighter value than real normal hit direction")]
	[Space(5f)]
	[Range(0f, 1f)]
	public float MildHorizontalValue;

	[Tooltip("Max roll rotation. If rotation should work on also on x axis - good for spiders, can look wrong on quadropeds etc.")]
	[Range(0f, 90f)]
	public float MaxHorizontalRotation = 90f;

	[Tooltip("We should cast raycast from position little higher than foots of your game object")]
	[Space(4f, order = 1)]
	[Header("> Advanced settings <", order = 0)]
	public float RaycastHeightOffset = 0.5f;

	[Tooltip("How far ray should cast to check if ground is under feet")]
	public float RaycastCheckRange = 5f;

	[Tooltip("If value is not equal 0 there will be casted second ray in front or back of gameObject")]
	public float LookAheadRaycast;

	[Tooltip("Blending with predicted forward raycast rotation")]
	public float AheadBlend = 0.5f;

	[HideInInspector]
	[Tooltip("Offset over ground")]
	public float UpOffset;

	[Tooltip("What collision layers should be included by algorithm")]
	[Space(8f)]
	public LayerMask GroundLayerMask = LayerMask.op_Implicit(1);

	[Tooltip("When casting down vector should adjust with transform's rotation")]
	public bool RelativeLookUp;

	[Range(0f, 1f)]
	public float RelativeLookUpBias;

	internal Vector3 WorldUp = Vector3.up;

	[Space(8f)]
	[Tooltip("Casting more raycsts under object to detect ground more precisely, then we use average from all casts to set new rotation")]
	public bool ZoneCast;

	public Vector2 ZoneCastDimensions = new Vector2(0.3f, 0.5f);

	public Vector3 ZoneCastOffset = Vector3.zero;

	[Range(0f, 10f)]
	public float ZoneCastBias;

	[Range(0f, 1f)]
	[Tooltip("More precision = more raycasts = lower performance")]
	public float ZoneCastPrecision = 0.25f;

	[NonSerialized]
	public float UpAxisRotation;

	protected Quaternion helperRotation = Quaternion.identity;

	protected Collider selfCollider;

	protected Vector3 castOffset = Vector3.zero;

	protected float deltaTime;

	internal bool ApplyRotation = true;

	internal Quaternion targetRotationToApply = Quaternion.identity;

	public RaycastHit LastRaycast { get; protected set; }

	public Vector3 LastRaycastOrigin { get; protected set; }

	public RaycastHit LastTransformRaycast { get; protected set; }

	public Quaternion LastRotation { get; protected set; }

	protected virtual void Start()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		selfCollider = ((Component)this).GetComponent<Collider>();
		if ((Object)(object)TransformToRotate == (Object)null)
		{
			TransformToRotate = ((Component)this).transform;
		}
		UpAxisRotation = ((Component)this).transform.localEulerAngles.y;
	}

	protected virtual void Reset()
	{
		TransformToRotate = ((Component)this).transform;
	}

	protected virtual void FitToGround()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)selfCollider))
		{
			selfCollider.enabled = false;
		}
		RaycastHit val = default(RaycastHit);
		if (LookAheadRaycast != 0f)
		{
			Physics.Raycast(TransformToRotate.position + GetUpVector(RaycastHeightOffset) + TransformToRotate.forward * LookAheadRaycast, -GetUpVector(), ref val, RaycastCheckRange, LayerMask.op_Implicit(GroundLayerMask), (QueryTriggerInteraction)1);
		}
		RefreshLastRaycast();
		RaycastHit lastRaycast = LastRaycast;
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
		{
			Vector3 up = Vector3.up;
			lastRaycast = LastRaycast;
			Quaternion val2 = Quaternion.FromToRotation(up, ((RaycastHit)(ref lastRaycast)).normal);
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
			{
				Quaternion val3 = Quaternion.FromToRotation(Vector3.up, ((RaycastHit)(ref val)).normal);
				val2 = Quaternion.Lerp(val2, val3, AheadBlend);
			}
			helperRotation = Quaternion.Slerp(helperRotation, val2, deltaTime * FittingSpeed);
		}
		else
		{
			helperRotation = Quaternion.Slerp(helperRotation, Quaternion.identity, deltaTime * FittingSpeed);
		}
		RotationCalculations();
		if (GlueToGround)
		{
			lastRaycast = LastRaycast;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
			{
				Transform transformToRotate = TransformToRotate;
				lastRaycast = LastRaycast;
				transformToRotate.position = ((RaycastHit)(ref lastRaycast)).point + Vector3.up * UpOffset;
			}
		}
		if (Object.op_Implicit((Object)(object)selfCollider))
		{
			selfCollider.enabled = true;
		}
	}

	internal virtual void RotationCalculations()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = helperRotation;
		val = Quaternion.Euler(Mathf.Clamp(FLogicMethods.WrapAngle(((Quaternion)(ref val)).eulerAngles.x), 0f - MaxForwardRotation, MaxForwardRotation) * (1f - MildForwardValue), ((Quaternion)(ref val)).eulerAngles.y, Mathf.Clamp(FLogicMethods.WrapAngle(((Quaternion)(ref val)).eulerAngles.z), 0f - MaxHorizontalRotation, MaxHorizontalRotation) * (1f - MildHorizontalValue));
		if (TotalSmoother == 0f)
		{
			targetRotationToApply = val * Quaternion.AngleAxis(UpAxisRotation, Vector3.up);
		}
		else
		{
			Quaternion val2 = Quaternion.AngleAxis(UpAxisRotation, Vector3.up);
			targetRotationToApply *= Quaternion.Inverse(val2);
			targetRotationToApply = Quaternion.Slerp(targetRotationToApply, val, deltaTime * Mathf.Lerp(50f, 1f, TotalSmoother));
			targetRotationToApply *= val2;
		}
		if (ApplyRotation)
		{
			TransformToRotate.rotation = targetRotationToApply;
		}
		LastRotation = TransformToRotate.rotation;
	}

	internal virtual RaycastHit CastRay()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		LastRaycastOrigin = GetRaycastOrigin() + castOffset;
		RaycastHit val = default(RaycastHit);
		Physics.Raycast(LastRaycastOrigin, -GetUpVector(), ref val, RaycastCheckRange + Mathf.Abs(UpOffset), LayerMask.op_Implicit(GroundLayerMask), (QueryTriggerInteraction)1);
		if (ZoneCast)
		{
			Vector3 val2 = TransformToRotate.position + GetRotation() * ZoneCastOffset + GetUpVector(RaycastHeightOffset);
			Vector3 val3 = TransformToRotate.right * ZoneCastDimensions.x;
			Vector3 val4 = TransformToRotate.forward * ZoneCastDimensions.y;
			List<RaycastHit> list = new List<RaycastHit>();
			list.Add(val);
			int num = 0;
			float num2 = 1f;
			RaycastHit item = default(RaycastHit);
			for (int i = 0; (float)i < Mathf.Lerp(4f, 24f, ZoneCastPrecision); i++)
			{
				Vector3 val5 = Vector3.zero;
				switch (num)
				{
				case 0:
					val5 = val3 - val4;
					break;
				case 1:
					val5 = val3 + val4;
					break;
				case 2:
					val5 = -val3 + val4;
					break;
				case 3:
					val5 = -val3 - val4;
					num2 += 0.75f;
					num = -1;
					break;
				}
				Physics.Raycast(val2 + val5 / num2, -GetUpVector() + val5 * ZoneCastBias + castOffset, ref item, RaycastCheckRange + Mathf.Abs(UpOffset), LayerMask.op_Implicit(GroundLayerMask), (QueryTriggerInteraction)1);
				if (Object.op_Implicit((Object)(object)((RaycastHit)(ref item)).transform))
				{
					list.Add(item);
				}
				num++;
			}
			Vector3 val6 = Vector3.zero;
			Vector3 val7 = Vector3.zero;
			for (int j = 0; j < list.Count; j++)
			{
				Vector3 val8 = val7;
				RaycastHit val9 = list[j];
				val7 = val8 + ((RaycastHit)(ref val9)).normal;
				Vector3 val10 = val6;
				val9 = list[j];
				val6 = val10 + ((RaycastHit)(ref val9)).point;
			}
			val6 /= (float)list.Count;
			val7 /= (float)list.Count;
			((RaycastHit)(ref val)).normal = val7;
			if (!Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
			{
				((RaycastHit)(ref val)).point = new Vector3(val6.x, TransformToRotate.position.y, val6.z);
			}
		}
		return val;
	}

	internal Vector3 GetRaycastOrigin()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return TransformToRotate.position + GetUpVector() * RaycastHeightOffset;
	}

	protected virtual Quaternion GetRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return TransformToRotate.rotation;
	}

	protected virtual Vector3 GetUpVector(float mulRange = 1f)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (RelativeLookUp)
		{
			Vector3 worldUp = WorldUp;
			Vector3 val = TransformToRotate.TransformDirection(Vector3.up);
			return Vector3.Lerp(worldUp, ((Vector3)(ref val)).normalized, RelativeLookUpBias) * mulRange;
		}
		return WorldUp * mulRange;
	}

	internal void RotateBack(float speed = 5f)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (!(speed <= 0f))
		{
			helperRotation = Quaternion.Slerp(helperRotation, Quaternion.identity, deltaTime * speed);
		}
	}

	internal void RefreshLastRaycast()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		LastRaycast = CastRay();
		RaycastHit lastRaycast = LastRaycast;
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastRaycast)).transform))
		{
			LastTransformRaycast = LastRaycast;
		}
	}

	internal void BackRaycast()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		LastRaycast = LastTransformRaycast;
	}
}


using System;
using FIMSpace.GroundFitter;
using UnityEngine;

public abstract class FGroundFitter_Base_RootMotion : FGroundFitter_Base
{
	[Tooltip("Making ground fitter translate with root motion")]
	[HideInInspector]
	public bool HandleRootMotion;

	[HideInInspector]
	[SerializeField]
	protected Transform parentTransform;

	[HideInInspector]
	[SerializeField]
	protected CharacterController optionalCharContr;

	[HideInInspector]
	[SerializeField]
	protected bool rootMotionRotation = true;

	protected Animator rootMAnimator;

	protected override void Reset()
	{
		base.Reset();
		parentTransform = ((Component)this).transform;
	}

	protected override void Start()
	{
		base.Start();
	}

	protected virtual void HandleRootMotionSupport()
	{
		if (HandleRootMotion)
		{
			if (!Object.op_Implicit((Object)(object)rootMAnimator))
			{
				rootMAnimator = ((Component)this).GetComponentInChildren<Animator>();
			}
			if ((Object)(object)((Component)rootMAnimator).gameObject != (Object)(object)((Component)this).gameObject && !rootMAnimator.applyRootMotion && !Object.op_Implicit((Object)(object)((Component)rootMAnimator).GetComponent<FGroundFitter_RootMotionHelper>()))
			{
				((Component)rootMAnimator).gameObject.AddComponent<FGroundFitter_RootMotionHelper>().OptionalFitter = this;
			}
			rootMAnimator.applyRootMotion = true;
		}
	}

	internal virtual void OnAnimatorMove()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)rootMAnimator))
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)optionalCharContr))
		{
			if (rootMAnimator.deltaPosition != Vector3.zero)
			{
				if ((Object)(object)TransformToRotate != (Object)(object)((Component)this).transform)
				{
					optionalCharContr.Move(TransformToRotate.rotation * rootMAnimator.deltaPosition);
				}
				else
				{
					optionalCharContr.Move(rootMAnimator.deltaPosition);
				}
			}
			rootMAnimator.rootPosition = TransformToRotate.position;
		}
		else if ((Object)(object)TransformToRotate != (Object)(object)((Component)this).transform)
		{
			Transform obj = parentTransform;
			obj.position += TransformToRotate.rotation * rootMAnimator.deltaPosition;
		}
		else
		{
			Transform obj2 = parentTransform;
			obj2.position += rootMAnimator.deltaPosition;
		}
		rootMAnimator.rootPosition = TransformToRotate.position;
		rootMAnimator.rootRotation = base.LastRotation;
		if (rootMotionRotation)
		{
			rootMAnimator.rootRotation = base.LastRotation;
			Quaternion deltaRotation = rootMAnimator.deltaRotation;
			float num = default(float);
			Vector3 val = default(Vector3);
			((Quaternion)(ref deltaRotation)).ToAngleAxis(ref num, ref val);
			float y = (val * num * (MathF.PI / 180f)).y;
			UpAxisRotation += y * 57.290154f;
		}
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Input : FGroundFitter_InputBase
{
	protected virtual void Update()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		if (Input.GetKeyDown((KeyCode)32))
		{
			TriggerJump();
		}
		Vector3 zero = Vector3.zero;
		if (Input.GetKey((KeyCode)119) || Input.GetKey((KeyCode)97) || Input.GetKey((KeyCode)115) || Input.GetKey((KeyCode)100))
		{
			if (Input.GetKey((KeyCode)304))
			{
				base.Sprint = true;
			}
			else
			{
				base.Sprint = false;
			}
			if (Input.GetKey((KeyCode)119))
			{
				zero.z += 1f;
			}
			if (Input.GetKey((KeyCode)97))
			{
				zero.x -= 1f;
			}
			if (Input.GetKey((KeyCode)100))
			{
				zero.x += 1f;
			}
			if (Input.GetKey((KeyCode)115))
			{
				zero.z -= 1f;
			}
			((Vector3)(ref zero)).Normalize();
			Quaternion val = Quaternion.LookRotation(zero);
			base.RotationOffset = ((Quaternion)(ref val)).eulerAngles.y;
			base.MoveVector = Vector3.forward;
		}
		else
		{
			base.Sprint = false;
			base.MoveVector = Vector3.zero;
		}
		if (Input.GetKey((KeyCode)120))
		{
			base.MoveVector -= Vector3.forward;
		}
		if (Input.GetKey((KeyCode)113))
		{
			base.MoveVector += Vector3.left;
		}
		if (Input.GetKey((KeyCode)101))
		{
			base.MoveVector += Vector3.right;
		}
		Vector3 moveVector = base.MoveVector;
		((Vector3)(ref moveVector)).Normalize();
		controller.Sprint = base.Sprint;
		controller.MoveVector = base.MoveVector;
		controller.RotationOffset = base.RotationOffset;
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

[RequireComponent(typeof(FGroundFitter_Movement))]
public abstract class FGroundFitter_InputBase : MonoBehaviour
{
	protected FGroundFitter fitter;

	protected FGroundFitter_Movement controller;

	public float RotationOffset { get; protected set; }

	public bool Sprint { get; protected set; }

	public Vector3 MoveVector { get; protected set; }

	public virtual void Start()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		fitter = ((Component)this).GetComponent<FGroundFitter>();
		controller = ((Component)this).GetComponent<FGroundFitter_Movement>();
		RotationOffset = 0f;
		Sprint = false;
		MoveVector = Vector3.zero;
	}

	protected virtual void TriggerJump()
	{
		controller.Jump();
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_MovementLook : FGroundFitter_Movement
{
	[Header("Movement Look Options")]
	public Transform targetOfLook;

	[Range(0f, 1f)]
	public float FollowSpeed = 1f;

	public bool localOffset;

	private Vector3 targetPos;

	protected override void HandleTransforming()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		base.HandleTransforming();
		if (MoveVector != Vector3.zero)
		{
			SetLookAtPosition(((Component)this).transform.position + Quaternion.Euler(0f, ((Component)Camera.main).transform.eulerAngles.y + RotationOffset, 0f) * Vector3.forward * 10f);
		}
		if (Object.op_Implicit((Object)(object)targetOfLook))
		{
			Vector3 val = targetPos;
			if (localOffset)
			{
				val = ((Component)this).transform.TransformPoint(targetPos);
			}
			if (FollowSpeed >= 1f)
			{
				targetOfLook.position = val;
			}
			else
			{
				targetOfLook.position = Vector3.Lerp(targetOfLook.position, val, Mathf.Lerp(1f, 30f, FollowSpeed) * Time.deltaTime);
			}
		}
	}

	private void SetLookAtPosition(Vector3 tPos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!localOffset)
		{
			targetPos = tPos + Vector3.up;
		}
		else
		{
			targetPos = ((Component)this).transform.InverseTransformPoint(tPos + Vector3.up);
		}
	}
}


using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_RootMotionHelper : MonoBehaviour
{
	public FGroundFitter_Movement MovementController;

	public FGroundFitter_Base_RootMotion OptionalFitter;

	private void OnAnimatorMove()
	{
		if (Object.op_Implicit((Object)(object)MovementController))
		{
			MovementController.OnAnimatorMove();
		}
		else if (Object.op_Implicit((Object)(object)OptionalFitter))
		{
			OptionalFitter.OnAnimatorMove();
		}
		else
		{
			Object.Destroy((Object)(object)this);
		}
	}
}


