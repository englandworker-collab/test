using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FIMSpace;
using FIMSpace.FTail;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.EventSystems;

[DefaultExecutionOrder(-4)]
[HelpURL("https://assetstore.unity.com/packages/tools/animation/tail-animator-121819")]
[AddComponentMenu("FImpossible Creations/Tail Animator 2")]
public class TailAnimator2 : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon, IClientComponent
{
	[Serializable]
	public class TailSegment
	{
		public Vector3 ProceduralPosition = Vector3.zero;

		public Vector3 ProceduralPositionWeightBlended = Vector3.zero;

		public Quaternion TrueTargetRotation = Quaternion.identity;

		public Quaternion PosRefRotation = Quaternion.identity;

		public Quaternion PreviousPosReferenceRotation = Quaternion.identity;

		public Vector3 PreviousPosition;

		public float BlendValue = 1f;

		public Vector3 BoneDimensionsScaled;

		public float BoneLengthScaled;

		public Vector3 InitialLocalPosition = Vector3.zero;

		public Vector3 InitialLocalPositionInRoot = Vector3.zero;

		public Quaternion InitialLocalRotationInRoot = Quaternion.identity;

		public Vector3 LocalOffset = Vector3.zero;

		public Quaternion InitialLocalRotation = Quaternion.identity;

		public float ColliderRadius = 1f;

		public bool CollisionContactFlag;

		public float CollisionContactRelevancy = -1f;

		public Collision collisionContacts;

		public Vector3 VelocityHelper = Vector3.zero;

		public Quaternion QVelocityHelper = Quaternion.identity;

		public Vector3 PreviousPush = Vector3.zero;

		public Quaternion Curving = Quaternion.identity;

		public Vector3 Gravity = Vector3.zero;

		public Vector3 GravityLookOffset = Vector3.zero;

		public float LengthMultiplier = 1f;

		public float PositionSpeed = 1f;

		public float RotationSpeed = 1f;

		public float Springiness;

		public float Slithery = 1f;

		public float Curling = 0.5f;

		public float Slippery = 1f;

		public Quaternion LastKeyframeLocalRotation;

		public Vector3 LastKeyframeLocalPosition;

		private float deflectionSmoothVelo;

		public TailSegment ParentBone { get; private set; }

		public TailSegment ChildBone { get; private set; }

		public Transform transform { get; private set; }

		public int Index { get; private set; }

		public float IndexOverlLength { get; private set; }

		public float BoneLength { get; private set; }

		public TailCollisionHelper CollisionHelper { get; internal set; }

		public bool IsDetachable { get; private set; }

		public Vector3 LastFinalPosition { get; private set; }

		public Quaternion LastFinalRotation { get; private set; }

		public float DeflectionFactor { get; private set; }

		public Vector3 Deflection { get; private set; }

		public float DeflectionSmooth { get; private set; }

		public Vector3 DeflectionWorldPosition { get; private set; }

		public int DeflectionRelevancy { get; private set; }

		public FImp_ColliderData_Base LatestSelectiveCollision { get; internal set; }

		public TailSegment()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Unknown result type (might be due to invalid IL or missing references)
			Index = -1;
			Curving = Quaternion.identity;
			Gravity = Vector3.zero;
			LengthMultiplier = 1f;
			Deflection = Vector3.zero;
			DeflectionFactor = 0f;
			DeflectionRelevancy = -1;
			deflectionSmoothVelo = 0f;
		}

		public TailSegment(Transform transform)
			: this()
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)transform == (Object)null))
			{
				this.transform = transform;
				ProceduralPosition = transform.position;
				PreviousPosition = transform.position;
				PosRefRotation = transform.rotation;
				PreviousPosReferenceRotation = PosRefRotation;
				TrueTargetRotation = PosRefRotation;
				ReInitializeLocalPosRot(transform.localPosition, transform.localRotation);
				BoneLength = 0.1f;
			}
		}

		public TailSegment(TailSegment copyFrom)
			: this(copyFrom.transform)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			transform = copyFrom.transform;
			Index = copyFrom.Index;
			IndexOverlLength = copyFrom.IndexOverlLength;
			ProceduralPosition = copyFrom.ProceduralPosition;
			PreviousPosition = copyFrom.PreviousPosition;
			ProceduralPositionWeightBlended = copyFrom.ProceduralPosition;
			PosRefRotation = copyFrom.PosRefRotation;
			PreviousPosReferenceRotation = PosRefRotation;
			TrueTargetRotation = copyFrom.TrueTargetRotation;
			ReInitializeLocalPosRot(copyFrom.InitialLocalPosition, copyFrom.InitialLocalRotation);
		}

		public void ReInitializeLocalPosRot(Vector3 initLocalPos, Quaternion initLocalRot)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			InitialLocalPosition = initLocalPos;
			InitialLocalRotation = initLocalRot;
		}

		public void SetIndex(int i, int tailSegments)
		{
			Index = i;
			if (i < 0)
			{
				IndexOverlLength = 0f;
			}
			else
			{
				IndexOverlLength = (float)i / (float)tailSegments;
			}
		}

		public void SetParentRef(TailSegment parent)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			ParentBone = parent;
			Vector3 val = ProceduralPosition - ParentBone.ProceduralPosition;
			BoneLength = ((Vector3)(ref val)).magnitude;
		}

		public void SetChildRef(TailSegment child)
		{
			ChildBone = child;
		}

		public float GetRadiusScaled()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return ColliderRadius * transform.lossyScale.x;
		}

		public void AssignDetachedRootCoords(Transform root)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			InitialLocalPositionInRoot = root.InverseTransformPoint(transform.position);
			InitialLocalRotationInRoot = root.rotation.QToLocal(transform.rotation);
			IsDetachable = true;
		}

		internal Vector3 BlendMotionWeight(Vector3 newPosition)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.LerpUnclamped(ParentBone.ProceduralPosition + ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition), newPosition, BlendValue);
		}

		internal void PreCalibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			transform.localPosition = InitialLocalPosition;
			transform.localRotation = InitialLocalRotation;
		}

		internal void Validate()
		{
			if (BoneLength == 0f)
			{
				BoneLength = 0.001f;
			}
		}

		public void RefreshKeyLocalPosition()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)transform))
			{
				LastKeyframeLocalRotation = transform.localRotation;
			}
			else
			{
				LastKeyframeLocalRotation = InitialLocalRotation;
			}
		}

		public void RefreshKeyLocalPositionAndRotation()
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)transform))
			{
				RefreshKeyLocalPositionAndRotation(transform.localPosition, transform.localRotation);
			}
			else
			{
				RefreshKeyLocalPositionAndRotation(InitialLocalPosition, InitialLocalRotation);
			}
		}

		public void RefreshKeyLocalPositionAndRotation(Vector3 p, Quaternion r)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			LastKeyframeLocalPosition = p;
			LastKeyframeLocalRotation = r;
		}

		internal Vector3 ParentToFrontOffset()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			return ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition);
		}

		public void RefreshFinalPos(Vector3 pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			LastFinalPosition = pos;
		}

		public void RefreshFinalRot(Quaternion rot)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			LastFinalRotation = rot;
		}

		public bool CheckDeflectionState(float zeroWhenLower, float smoothTime, float delta)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = LastKeyframeLocalPosition - ParentBone.transform.InverseTransformVector(ProceduralPosition - ParentBone.ProceduralPosition);
			DeflectionFactor = Vector3.Dot(((Vector3)(ref LastKeyframeLocalPosition)).normalized, ((Vector3)(ref val)).normalized);
			if (DeflectionFactor < zeroWhenLower)
			{
				if (smoothTime <= Mathf.Epsilon)
				{
					DeflectionSmooth = 0f;
				}
				else
				{
					DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 0f - Mathf.Epsilon, ref deflectionSmoothVelo, smoothTime / 1.5f, float.PositiveInfinity, delta);
				}
			}
			else if (smoothTime <= Mathf.Epsilon)
			{
				DeflectionSmooth = 1f;
			}
			else
			{
				DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 1f, ref deflectionSmoothVelo, smoothTime, float.PositiveInfinity, delta);
			}
			if (DeflectionSmooth <= Mathf.Epsilon)
			{
				return true;
			}
			if (ChildBone.ChildBone != null)
			{
				DeflectionWorldPosition = ChildBone.ChildBone.ProceduralPosition;
			}
			else
			{
				DeflectionWorldPosition = ChildBone.ProceduralPosition;
			}
			return false;
		}

		public bool DeflectionRelevant()
		{
			if (DeflectionRelevancy == -1)
			{
				DeflectionRelevancy = 3;
				return true;
			}
			DeflectionRelevancy = 3;
			return false;
		}

		public bool? DeflectionRestoreState()
		{
			if (DeflectionRelevancy > 0)
			{
				DeflectionRelevancy--;
				if (DeflectionRelevancy == 0)
				{
					DeflectionRelevancy = -1;
					return null;
				}
				return true;
			}
			return false;
		}

		internal void ParamsFrom(TailSegment other)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			BlendValue = other.BlendValue;
			ColliderRadius = other.ColliderRadius;
			Gravity = other.Gravity;
			LengthMultiplier = other.LengthMultiplier;
			BoneLength = other.BoneLength;
			BoneLengthScaled = other.BoneLengthScaled;
			BoneDimensionsScaled = other.BoneDimensionsScaled;
			collisionContacts = other.collisionContacts;
			CollisionHelper = other.CollisionHelper;
			PositionSpeed = other.PositionSpeed;
			RotationSpeed = other.RotationSpeed;
			Springiness = other.Springiness;
			Slithery = other.Slithery;
			Curling = other.Curling;
			Slippery = other.Slippery;
		}

		internal void ParamsFromAll(TailSegment other)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			ParamsFrom(other);
			InitialLocalPosition = other.InitialLocalPosition;
			InitialLocalRotation = other.InitialLocalRotation;
			LastFinalPosition = other.LastFinalPosition;
			LastFinalRotation = other.LastFinalRotation;
			ProceduralPosition = other.ProceduralPosition;
			ProceduralPositionWeightBlended = other.ProceduralPositionWeightBlended;
			TrueTargetRotation = other.TrueTargetRotation;
			PosRefRotation = other.PosRefRotation;
			PreviousPosReferenceRotation = other.PreviousPosReferenceRotation;
			PreviousPosition = other.PreviousPosition;
			BoneLength = other.BoneLength;
			BoneDimensionsScaled = other.BoneDimensionsScaled;
			BoneLengthScaled = other.BoneLengthScaled;
			LocalOffset = other.LocalOffset;
			ColliderRadius = other.ColliderRadius;
			VelocityHelper = other.VelocityHelper;
			QVelocityHelper = other.QVelocityHelper;
			PreviousPush = other.PreviousPush;
		}

		internal void User_ReassignTransform(Transform t)
		{
			transform = t;
		}

		public void Reset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			PreviousPush = Vector3.zero;
			VelocityHelper = Vector3.zero;
			QVelocityHelper = Quaternion.identity;
			if (Object.op_Implicit((Object)(object)transform))
			{
				ProceduralPosition = transform.position;
				PosRefRotation = transform.rotation;
				PreviousPosReferenceRotation = transform.rotation;
			}
			else if (Object.op_Implicit((Object)(object)ParentBone.transform))
			{
				ProceduralPosition = ParentBone.transform.position + ParentToFrontOffset();
			}
			PreviousPosition = ProceduralPosition;
			ProceduralPositionWeightBlended = ProceduralPosition;
		}
	}

	public enum ECollisionSpace
	{
		World_Slow,
		Selective_Fast
	}

	public enum ECollisionMode
	{
		m_3DCollision,
		m_2DCollision
	}

	[Serializable]
	public class IKBoneSettings
	{
		[Range(0f, 181f)]
		public float AngleLimit = 45f;

		[Range(0f, 181f)]
		public float TwistAngleLimit = 5f;

		public bool UseInChain = true;
	}

	public enum FEWavingType
	{
		Simple,
		Advanced
	}

	public enum EFDeltaType
	{
		DeltaTime,
		SmoothDeltaTime,
		UnscaledDeltaTime,
		FixedDeltaTime,
		SafeDelta
	}

	public enum EAnimationStyle
	{
		Quick,
		Accelerating,
		Linear
	}

	public enum ETailCategory
	{
		Setup,
		Tweak,
		Features,
		Shaping
	}

	public enum ETailFeaturesCategory
	{
		Main,
		Collisions,
		IK,
		Experimental
	}

	public enum EFixedMode
	{
		None,
		Basic,
		Late
	}

	private static ListHashSet<TailAnimator2> components = new ListHashSet<TailAnimator2>();

	[Tooltip("Using some simple calculations to make tail bend on colliders")]
	public bool UseCollision;

	[Tooltip("How collision should be detected, world gives you collision on all world colliders but with more use of cpu (using unity's rigidbodies), 'Selective' gives you possibility to detect collision on selected colliders without using Rigidbodies, it also gives smoother motion (deactivated colliders will still detect collision, unless its game object is disabled)")]
	public ECollisionSpace CollisionSpace = ECollisionSpace.Selective_Fast;

	public ECollisionMode CollisionMode;

	[Tooltip("If you want to stop checking collision if segment collides with one collider\n\nSegment collision with two or more colliders in the same time with this option enabled can result in stuttery motion")]
	public bool CheapCollision;

	[Tooltip("Using trigger collider to include encountered colliders into collide with list")]
	public bool DynamicWorldCollidersInclusion;

	[Tooltip("Radius of trigger collider for dynamic inclusion of colliders")]
	public float InclusionRadius = 1f;

	public bool IgnoreMeshColliders = true;

	public List<Collider> IncludedColliders;

	public List<Collider2D> IncludedColliders2D;

	protected List<FImp_ColliderData_Base> IncludedCollidersData;

	protected List<FImp_ColliderData_Base> CollidersDataToCheck;

	[Tooltip("Capsules can give much more precise collision detection")]
	public int CollidersType;

	public bool CollideWithOtherTails;

	[Tooltip("Collision with colliders even if they're disabled (but game object must be enabled)\nHelpful to setup character limbs collisions without need to create new Layer")]
	public bool CollideWithDisabledColliders = true;

	[Range(0f, 1f)]
	public float CollisionSlippery = 1f;

	[Tooltip("If tail colliding objects should fit to colliders (0) or be reflect from them (Reflecting Only with 'Slithery' parameter greater than ~0.2)")]
	[Range(0f, 1f)]
	public float ReflectCollision;

	public AnimationCurve CollidersScaleCurve = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public float CollidersScaleMul = 6.5f;

	[Range(0f, 1f)]
	public float CollisionsAutoCurve = 0.5f;

	public List<Collider> IgnoredColliders;

	public List<Collider2D> IgnoredColliders2D;

	public bool CollidersSameLayer = true;

	[Tooltip("If you add rigidbodies to each tail segment's collider, collision will work on everything but it will be less optimal, you don't have to add here rigidbodies but then you must have not kinematic rigidbodies on objects segments can collide")]
	public bool CollidersAddRigidbody = true;

	public float RigidbodyMass = 1f;

	[FPD_Layers]
	public int CollidersLayer;

	public bool UseSlitheryCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1.2f, 0.1f, 0.8f, 1f, 0.9f)]
	public AnimationCurve SlitheryCurve = AnimationCurve.EaseInOut(0f, 0.75f, 1f, 1f);

	private float lastSlithery = -1f;

	private Keyframe[] lastSlitheryCurvKeys;

	public bool UseCurlingCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.65f, 0.4f, 1f, 0.9f)]
	public AnimationCurve CurlingCurve = AnimationCurve.EaseInOut(0f, 0.7f, 1f, 0.3f);

	private float lastCurling = -1f;

	private Keyframe[] lastCurlingCurvKeys;

	public bool UseSpringCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.9f, 0.7f, 0.2f, 0.9f)]
	public AnimationCurve SpringCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

	private float lastSpringiness = -1f;

	private Keyframe[] lastSpringCurvKeys;

	public bool UseSlipperyCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 0.9f, 0.6f, 0.9f)]
	public AnimationCurve SlipperyCurve = AnimationCurve.EaseInOut(0f, 0.7f, 1f, 1f);

	private float lastSlippery = -1f;

	private Keyframe[] lastSlipperyCurvKeys;

	public bool UsePosSpeedCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 1f, 0.3f, 0.9f)]
	public AnimationCurve PosCurve = AnimationCurve.EaseInOut(0f, 0.7f, 1f, 1f);

	private float lastPosSpeeds = -1f;

	private Keyframe[] lastPosCurvKeys;

	public bool UseRotSpeedCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.7f, 0.7f, 0.7f, 0.9f)]
	public AnimationCurve RotCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.9f);

	private float lastRotSpeeds = -1f;

	private Keyframe[] lastRotCurvKeys;

	[Tooltip("Spreading Tail Animator motion weight over bones")]
	public bool UsePartialBlend;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 0.5f, 0.85f, 1f)]
	public AnimationCurve BlendCurve = AnimationCurve.EaseInOut(0f, 0.95f, 1f, 0.45f);

	private float lastTailAnimatorAmount = -1f;

	private Keyframe[] lastBlendCurvKeys;

	private TailSegment _ex_bone;

	public bool UseIK;

	private bool ikInitialized;

	[SerializeField]
	private FIK_CCDProcessor IK;

	[Tooltip("Target object to follow by IK")]
	public Transform IKTarget;

	public bool IKAutoWeights = true;

	[Range(0f, 1f)]
	public float IKBaseReactionWeight = 0.65f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.2f, 0.5f, 0.85f, 1f)]
	public AnimationCurve IKReactionWeightCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0.25f);

	public bool IKAutoAngleLimits = true;

	[FPD_Suffix(0f, 181f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float IKAutoAngleLimit = 40f;

	[Tooltip("If ik process should work referencing to previously computed CCDIK pose (can be more precise but need more adjusting in weights and angle limits)")]
	public bool IKContinousSolve;

	[Tooltip("Inverting ik iteration order to generate different pose results - more straight towards target")]
	public bool IkInvertOrder;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("How much IK motion sohuld be used in tail animator motion -> 0: turned off")]
	public float IKBlend = 1f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("If syncing with animator then applying motion of keyframe animation for IK")]
	public float IKAnimatorBlend = 0.5f;

	[Tooltip("How much iterations should do CCDIK algorithm in one frame")]
	[Range(1f, 32f)]
	public int IKReactionQuality = 2;

	[Range(0f, 1f)]
	[Tooltip("Smoothing reactions in CCD IK algorithm")]
	public float IKSmoothing;

	[Range(0f, 1.5f)]
	public float IKStretchToTarget;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.9f, 0.4f, 0.5f, 1f)]
	public AnimationCurve IKStretchCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public List<IKBoneSettings> IKLimitSettings;

	public bool IKSelectiveChain;

	private Vector3? _IKCustomPos;

	private List<TailSegment> _pp_reference;

	private TailSegment _pp_ref_rootParent;

	private TailSegment _pp_ref_lastChild;

	private bool _pp_initialized;

	[Tooltip("Rotation offset for tail (just first (root) bone is rotated)")]
	public Quaternion RotationOffset = Quaternion.identity;

	[Tooltip("Rotate each segment a bit to create curving effect")]
	public Quaternion Curving = Quaternion.identity;

	[Tooltip("Spread curving rotation offset weight over tail segments")]
	public bool UseCurvingCurve;

	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.75f, 0.75f, 0.75f, 0.85f)]
	public AnimationCurve CurvCurve = AnimationCurve.EaseInOut(0f, 0.75f, 1f, 1f);

	private Quaternion lastCurving = Quaternion.identity;

	private Keyframe[] lastCurvingKeys;

	[Tooltip("Make tail longer or shorter")]
	public float LengthMultiplier = 1f;

	[Tooltip("Spread length multiplier weight over tail segments")]
	public bool UseLengthMulCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 3f, 0f, 1f, 1f, 1f)]
	public AnimationCurve LengthMulCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	private float lastLengthMul = 1f;

	private Keyframe[] lastLengthKeys;

	[Tooltip("Spread gravity weight over tail segments")]
	public bool UseGravityCurve;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.85f, 0.35f, 0.25f, 0.85f)]
	[Tooltip("Spread gravity weight over tail segments")]
	public AnimationCurve GravityCurve = AnimationCurve.EaseInOut(0f, 0.65f, 1f, 1f);

	[Tooltip("Simulate gravity weight for tail logics")]
	public Vector3 Gravity = Vector3.zero;

	private Vector3 lastGravity = Vector3.zero;

	private Keyframe[] lastGravityKeys;

	[Tooltip("Using auto waving option to give floating effect")]
	public bool UseWaving = true;

	[Tooltip("Adding some variation to waving animation")]
	public bool CosinusAdd;

	[Tooltip("If you want few tails to wave in the same way you can set this sinus period cycle value")]
	public float FixedCycle;

	[Tooltip("How frequent swings should be")]
	public float WavingSpeed = 3f;

	[Tooltip("How big swings should be")]
	public float WavingRange = 0.8f;

	[Tooltip("What rotation axis should be used in auto waving")]
	public Vector3 WavingAxis = new Vector3(1f, 1f, 1f);

	[Tooltip("Type of waving animation algorithm, it can be simple trigonometric wave or animation based on noises (advanced)")]
	public FEWavingType WavingType = FEWavingType.Advanced;

	[Tooltip("Offsetting perlin noise to generate different variation of tail rotations")]
	public float AlternateWave = 1f;

	private float _waving_waveTime;

	private float _waving_cosTime;

	private Vector3 _waving_sustain = Vector3.zero;

	public bool UseWind;

	[FPD_Suffix(0f, 2.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float WindEffectPower = 1f;

	[FPD_Suffix(0f, 2.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float WindTurbulencePower = 1f;

	[FPD_Suffix(0f, 1.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	public float WindWorldNoisePower = 0.5f;

	public Vector3 WindEffect = Vector3.zero;

	public List<TailSegment> TailSegments;

	[SerializeField]
	private TailSegment GhostParent;

	[SerializeField]
	private TailSegment GhostChild;

	private Vector3 _limiting_limitPosition = Vector3.zero;

	private Vector3 _limiting_influenceOffset = Vector3.zero;

	private float _limiting_stretchingHelperTooLong;

	private float _limiting_stretchingHelperTooShort;

	private Quaternion _limiting_angle_ToTargetRot;

	private Quaternion _limiting_angle_targetInLocal;

	private Quaternion _limiting_angle_newLocal;

	private Vector3 _tc_segmentGravityOffset = Vector3.zero;

	private Vector3 _tc_segmentGravityToParentDir = Vector3.zero;

	private Vector3 _tc_preGravOff = Vector3.zero;

	[Tooltip("If you want to use max distance fade option to smoothly disable tail animator when object is going far away from camera")]
	public bool UseMaxDistance;

	[Tooltip("(By default camera transform) Measuring distance from this object to define if object is too far and not need to update tail animator")]
	public Transform DistanceFrom;

	[HideInInspector]
	public Transform _distanceFrom_Auto;

	[Tooltip("Max distance to main camera / target object to smoothly turn off tail animator.")]
	public float MaximumDistance = 35f;

	[Tooltip("If object in range should be detected only when is nearer than 'MaxDistance' to avoid stuttery enabled - disable switching")]
	[Range(0f, 1f)]
	public float MaxOutDistanceFactor;

	[Tooltip("If distance should be measured not using Up (y) axis")]
	public bool DistanceWithoutY;

	[Tooltip("Offsetting point from which we want to measure distance to target")]
	public Vector3 DistanceMeasurePoint;

	[Tooltip("Disable fade duration in seconds")]
	[Range(0.25f, 2f)]
	public float FadeDuration = 0.75f;

	private bool maxDistanceExceed;

	private Transform finalDistanceFrom;

	private bool wasCameraSearch;

	private float distanceWeight = 1f;

	private int _tc_startI;

	private int _tc_startII = 1;

	private TailSegment _tc_rootBone;

	private Quaternion _tc_lookRot = Quaternion.identity;

	private Quaternion _tc_targetParentRot = Quaternion.identity;

	private Quaternion _tc_startBoneRotOffset = Quaternion.identity;

	private float _tc_tangle = 1f;

	private float _sg_springVelo = 0.5f;

	private float _sg_curly = 0.5f;

	private Vector3 _sg_push;

	private Vector3 _sg_targetPos;

	private Vector3 _sg_targetChildWorldPosInParentFront;

	private Vector3 _sg_dirToTargetParentFront;

	private Quaternion _sg_orientation;

	private float _sg_slitFactor = 0.5f;

	private bool wasDisabled = true;

	private float justDelta = 0.016f;

	private float secPeriodDelta = 0.5f;

	private float deltaForLerps = 0.016f;

	private float rateDelta = 0.016f;

	protected float collectedDelta;

	protected int framesToSimulate = 1;

	protected int previousframesToSimulate = 1;

	private bool updateTailAnimator;

	private int startAfterTPoseCounter;

	private bool fixedUpdated;

	private bool lateFixedIsRunning;

	private bool fixedAllow = true;

	[Tooltip("Making tail segment deflection influence back segments")]
	[Range(0f, 1f)]
	public float Deflection;

	[FPD_Suffix(1f, 89f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float DeflectionStartAngle = 10f;

	[Range(0f, 1f)]
	public float DeflectionSmooth;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.65f, 0.4f, 1f, 0.9f)]
	public AnimationCurve DeflectionFalloff = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Tooltip("Deflection can be triggered every time tail is waving but you not always would want this feature be enabled (different behaviour of tail motion)")]
	public bool DeflectOnlyCollisions = true;

	private List<TailSegment> _defl_source;

	private float _defl_treshold = 0.01f;

	private bool _forceDisable;

	private float _forceDisableElapsed;

	public ETailCategory _Editor_Category;

	public ETailFeaturesCategory _Editor_FeaturesCategory;

	public bool DrawGizmos = true;

	[Tooltip("First bone of tail motion chain")]
	public Transform StartBone;

	[Tooltip("Finish bone of tail motion chain")]
	public Transform EndBone;

	[Tooltip("Adjusting end point for end tail bone motion")]
	public Vector3 EndBoneJointOffset = Vector3.zero;

	public List<Transform> _TransformsGhostChain;

	public int _GhostChainInitCount = -1;

	protected bool initialized;

	[Tooltip("Target FPS update rate for Tail Animator.\n\nIf you want Tail Animator to behave the same in low/high fps, set this value for example to 60.\nIt also can help optimizing if your game have more than 60 fps.")]
	public int UpdateRate;

	[Tooltip("If your character Unity's Animator have update mode set to 'Animate Physics' you should enable it here too")]
	public EFixedMode AnimatePhysics;

	[Tooltip("When using target fps rate you can interpolate coordinates for smoother effect when object with tail is moving a lot")]
	public bool InterpolateRate;

	[Tooltip("Simulating tail motion at initiation to prevent jiggle start")]
	public bool Prewarm;

	internal float OverrideWeight = 1f;

	protected float conditionalWeight = 1f;

	protected bool collisionInitialized;

	protected bool forceRefreshCollidersData;

	private Vector3 previousWorldPosition;

	protected Transform rootTransform;

	protected bool preAutoCorrect;

	[Range(0f, 1.2f)]
	[Tooltip("Blending Slithery - smooth & soft tentacle like movement (value = 1)\nwith more stiff & springy motion (value = 0)\n\n0: Stiff somewhat like tree branch\n1: Soft like squid tentacle / Animal tail")]
	public float Slithery = 1f;

	[Tooltip("How curly motion should be applied to tail segments")]
	[Range(0f, 1f)]
	public float Curling = 0.5f;

	[Range(0f, 1f)]
	[Tooltip("Elastic spring effect making motion more 'meaty'")]
	public float Springiness;

	[Tooltip("If you want to limit stretching/gumminess of position motion when object moves fast. Recommended adjust to go with it under 0.3 value.\nValue = 1: Unlimited stretching")]
	[Range(0f, 1f)]
	public float MaxStretching = 0.375f;

	[Tooltip("Limiting max rotation angle for each tail segment")]
	[FPD_Suffix(1f, 181f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float AngleLimit = 181f;

	[Tooltip("If you need specific axis to be limited.\nLeave unchanged to limit all axes.")]
	public Vector3 AngleLimitAxis = Vector3.zero;

	[Tooltip("If you want limit axes symmetrically leave this parameter unchanged, if you want limit one direction of axis more than reversed, tweak this parameter")]
	public Vector2 LimitAxisRange = Vector2.zero;

	[Tooltip("If limiting shouldn't be too rapidly performed")]
	[Range(0f, 1f)]
	public float LimitSmoothing = 0.5f;

	[FPD_Suffix(0f, 1.5f, FPD_SuffixAttribute.SuffixMode.PercentageUnclamped, "%", true, 0)]
	[Tooltip("If your object moves very fast making tail influenced by speed too much then you can controll it with this parameter")]
	public float MotionInfluence = 1f;

	[Tooltip("Additional Y influence controll useful when your character is jumping (works only when MotionInfluence value is other than 100%)")]
	[Range(0f, 1f)]
	public float MotionInfluenceInY = 1f;

	[Tooltip("If first bone of chain should also be affected with whole chain")]
	public bool IncludeParent = true;

	[Tooltip("By basic algorithm of Tail Animator different sized tails with different number of bones would animate with different bending thanks to this toggle every setup bends in very similar amount.\n\nShort tails will bend more and longer oner with bigger amount of bones less with this option enabled.")]
	[Range(0f, 1f)]
	public float UnifyBendiness;

	[Tooltip("Reaction Speed is defining how fast tail segments will return to target position, it gives animation more underwater/floaty feeling if it's lower")]
	[Range(0f, 1f)]
	public float ReactionSpeed = 0.9f;

	[Range(0f, 1f)]
	[Tooltip("Sustain is similar to reaction speed in reverse, but providing sustain motion effect when increased")]
	public float Sustain;

	[Tooltip("Rotation speed is defining how fast tail segments will return to target rotation, it gives animation more lazy feeling if it's lower")]
	[Range(0f, 1f)]
	public float RotationRelevancy = 1f;

	[Tooltip("Smoothing motion values change over time style to be applied for 'Reaction Speed' and 'Rotation Relevancy' parameters")]
	public EAnimationStyle SmoothingStyle = EAnimationStyle.Accelerating;

	[Tooltip("Slowmo or speedup tail animation reaction")]
	public float TimeScale = 1f;

	[Tooltip("Delta time type to be used by algorithm")]
	public EFDeltaType DeltaType = EFDeltaType.SafeDelta;

	[Tooltip("Useful when you use other components to affect bones hierarchy and you want this component to follow other component's changes\n\nIt can be really useful when working with 'Spine Animator'")]
	public bool UpdateAsLast = true;

	[Tooltip("Checking if keyframed animation has some empty keyframes which could cause unwanted twisting errors")]
	public bool DetectZeroKeyframes = true;

	[Tooltip("Initializing Tail Animator after first frames of game to not initialize with model's T-Pose but after playing some other animation")]
	public bool StartAfterTPose = true;

	[Tooltip("If you want Tail Animator to stop computing when choosed animator is not enabled")]
	public Animator OptimizeWithAnimator;

	[Tooltip("Blend Source Animation (keyframed / unanimated) and Tail Animator")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float TailAnimatorAmount = 1f;

	[Tooltip("Removing transforms hierachy structure to optimize Unity's calculations on Matrixes.\nIt can give very big boost in performance for long tails but it can't work with animated models!")]
	public bool DetachChildren;

	[Tooltip("If tail movement should not move in depth you can use this parameter")]
	public int Axis2D;

	[Range(-1f, 1f)]
	[Tooltip("[Experimental: Works only with Slithery Blend set to >= 1] Making each segment go to target pose in front of parent segment creating new animation effect")]
	public float Tangle;

	[Tooltip("Making tail animate also roll rotation like it was done in Tail Animator V1 ! Use Rotation Relevancy Parameter (set lower than 0.5) !")]
	public bool AnimateRoll;

	[Range(0f, 1f)]
	[Tooltip("Overriding keyframe animation with just Tail Animator option (keyframe animation treated as t-pose bones rotations)")]
	public float OverrideKeyframeAnimation;

	private Transform _baseTransform;

	public List<Component> DynamicAlwaysInclude { get; private set; }

	public Quaternion WavingRotationOffset { get; private set; }

	public float _TC_TailLength { get; private set; }

	public string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Tail Animator/Tail Animator Icon Small";
		}
	}

	public bool IsInitialized => initialized;

	public Transform BaseTransform
	{
		get
		{
			if (Object.op_Implicit((Object)(object)_baseTransform))
			{
				return _baseTransform;
			}
			if (_TransformsGhostChain != null && _TransformsGhostChain.Count > 0)
			{
				_baseTransform = _TransformsGhostChain[0];
			}
			if ((Object)(object)_baseTransform != (Object)null)
			{
				return _baseTransform;
			}
			return ((Component)this).transform;
		}
	}

	private void OnEnable()
	{
		components.TryAdd(this);
	}

	private void OnDisable()
	{
		components.Remove(this);
	}

	public static void TickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			TailAnimator2 tailAnimator = components[num];
			if (tailAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				tailAnimator.Tick();
			}
		}
	}

	public static void LateTickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			TailAnimator2 tailAnimator = components[num];
			if (tailAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				tailAnimator.LateTick();
			}
		}
	}

	public static void FixedTickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			TailAnimator2 tailAnimator = components[num];
			if (tailAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				tailAnimator.FixedTick();
			}
		}
	}

	private void RefreshSegmentsColliders()
	{
		if (CollisionSpace == ECollisionSpace.Selective_Fast && TailSegments != null && TailSegments.Count > 1)
		{
			for (int i = 0; i < TailSegments.Count; i++)
			{
				TailSegments[i].ColliderRadius = GetColliderSphereRadiusFor(i);
			}
		}
	}

	private void BeginCollisionsUpdate()
	{
		if (CollisionSpace != ECollisionSpace.Selective_Fast)
		{
			return;
		}
		RefreshIncludedCollidersDataList();
		CollidersDataToCheck.Clear();
		for (int i = 0; i < IncludedCollidersData.Count; i++)
		{
			if ((Object)(object)IncludedCollidersData[i].Transform == (Object)null)
			{
				forceRefreshCollidersData = true;
				break;
			}
			if (!((Component)IncludedCollidersData[i].Transform).gameObject.activeInHierarchy)
			{
				continue;
			}
			if (CollideWithDisabledColliders)
			{
				IncludedCollidersData[i].RefreshColliderData();
				CollidersDataToCheck.Add(IncludedCollidersData[i]);
			}
			else if (CollisionMode == ECollisionMode.m_3DCollision)
			{
				if ((Object)(object)IncludedCollidersData[i].Collider == (Object)null)
				{
					forceRefreshCollidersData = true;
					break;
				}
				if (IncludedCollidersData[i].Collider.enabled)
				{
					IncludedCollidersData[i].RefreshColliderData();
					CollidersDataToCheck.Add(IncludedCollidersData[i]);
				}
			}
			else
			{
				if ((Object)(object)IncludedCollidersData[i].Collider2D == (Object)null)
				{
					forceRefreshCollidersData = true;
					break;
				}
				if (((Behaviour)IncludedCollidersData[i].Collider2D).enabled)
				{
					IncludedCollidersData[i].RefreshColliderData();
					CollidersDataToCheck.Add(IncludedCollidersData[i]);
				}
			}
		}
	}

	private void SetupSphereColliders()
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		if (CollisionSpace == ECollisionSpace.World_Slow)
		{
			for (int i = 1; i < _TransformsGhostChain.Count; i++)
			{
				if (CollidersSameLayer)
				{
					((Component)_TransformsGhostChain[i]).gameObject.layer = ((Component)this).gameObject.layer;
				}
				else
				{
					((Component)_TransformsGhostChain[i]).gameObject.layer = CollidersLayer;
				}
			}
			if (CollidersType != 0)
			{
				for (int j = 1; j < _TransformsGhostChain.Count - 1; j++)
				{
					CapsuleCollider val = ((Component)_TransformsGhostChain[j]).gameObject.AddComponent<CapsuleCollider>();
					TailCollisionHelper tailCollisionHelper = ((Component)_TransformsGhostChain[j]).gameObject.AddComponent<TailCollisionHelper>().Init(CollidersAddRigidbody, RigidbodyMass);
					tailCollisionHelper.TailCollider = (Collider)(object)val;
					tailCollisionHelper.Index = j;
					tailCollisionHelper.ParentTail = this;
					val.radius = GetColliderSphereRadiusFor(_TransformsGhostChain, j);
					val.direction = 2;
					Vector3 val2 = _TransformsGhostChain[j].position - _TransformsGhostChain[j + 1].position;
					val.height = ((Vector3)(ref val2)).magnitude * 2f - val.radius;
					val.center = _TransformsGhostChain[j].InverseTransformPoint(Vector3.Lerp(_TransformsGhostChain[j].position, _TransformsGhostChain[j + 1].position, 0.5f));
					TailSegments[j].ColliderRadius = val.radius;
					TailSegments[j].CollisionHelper = tailCollisionHelper;
				}
			}
			else
			{
				for (int k = 1; k < _TransformsGhostChain.Count; k++)
				{
					SphereCollider val3 = ((Component)_TransformsGhostChain[k]).gameObject.AddComponent<SphereCollider>();
					TailCollisionHelper tailCollisionHelper2 = ((Component)_TransformsGhostChain[k]).gameObject.AddComponent<TailCollisionHelper>().Init(CollidersAddRigidbody, RigidbodyMass);
					tailCollisionHelper2.TailCollider = (Collider)(object)val3;
					tailCollisionHelper2.Index = k;
					tailCollisionHelper2.ParentTail = this;
					val3.radius = GetColliderSphereRadiusFor(_TransformsGhostChain, k);
					TailSegments[k].ColliderRadius = val3.radius;
					TailSegments[k].CollisionHelper = tailCollisionHelper2;
				}
			}
		}
		else
		{
			for (int l = 0; l < _TransformsGhostChain.Count; l++)
			{
				TailSegments[l].ColliderRadius = GetColliderSphereRadiusFor(l);
			}
			IncludedCollidersData = new List<FImp_ColliderData_Base>();
			CollidersDataToCheck = new List<FImp_ColliderData_Base>();
			if (DynamicWorldCollidersInclusion)
			{
				if (CollisionMode == ECollisionMode.m_3DCollision)
				{
					for (int m = 0; m < IncludedColliders.Count; m++)
					{
						DynamicAlwaysInclude.Add((Component)(object)IncludedColliders[m]);
					}
				}
				else
				{
					for (int n = 0; n < IncludedColliders2D.Count; n++)
					{
						DynamicAlwaysInclude.Add((Component)(object)IncludedColliders2D[n]);
					}
				}
				Transform transform = TailSegments[TailSegments.Count / 2].transform;
				float num = Vector3.Distance(_TransformsGhostChain[0].position, _TransformsGhostChain[_TransformsGhostChain.Count - 1].position);
				TailCollisionHelper tailCollisionHelper3 = ((Component)transform).gameObject.AddComponent<TailCollisionHelper>();
				tailCollisionHelper3.ParentTail = this;
				SphereCollider val4 = null;
				CircleCollider2D val5 = null;
				if (CollisionMode == ECollisionMode.m_3DCollision)
				{
					val4 = ((Component)transform).gameObject.AddComponent<SphereCollider>();
					((Collider)val4).isTrigger = true;
					tailCollisionHelper3.TailCollider = (Collider)(object)val4;
				}
				else
				{
					val5 = ((Component)transform).gameObject.AddComponent<CircleCollider2D>();
					((Collider2D)val5).isTrigger = true;
					tailCollisionHelper3.TailCollider2D = (Collider2D)(object)val5;
				}
				tailCollisionHelper3.Init(addRigidbody: true, 1f, kinematic: true);
				float num2 = Mathf.Abs(((Component)transform).transform.lossyScale.z);
				if (num2 == 0f)
				{
					num2 = 1f;
				}
				if ((Object)(object)val4 != (Object)null)
				{
					val4.radius = num / num2;
				}
				else
				{
					val5.radius = num / num2;
				}
				if (CollidersSameLayer)
				{
					((Component)transform).gameObject.layer = ((Component)this).gameObject.layer;
				}
				else
				{
					((Component)transform).gameObject.layer = CollidersLayer;
				}
			}
			RefreshIncludedCollidersDataList();
		}
		collisionInitialized = true;
	}

	internal void CollisionDetection(int index, Collision collision)
	{
		TailSegments[index].collisionContacts = collision;
	}

	internal void ExitCollision(int index)
	{
		TailSegments[index].collisionContacts = null;
	}

	protected bool UseCollisionContact(int index, ref Vector3 pos)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		if (TailSegments[index].collisionContacts == null)
		{
			return false;
		}
		if (TailSegments[index].collisionContacts.contacts.Length == 0)
		{
			return false;
		}
		Collision collisionContacts = TailSegments[index].collisionContacts;
		float num = FImp_ColliderData_Sphere.CalculateTrueRadiusOfSphereCollider(TailSegments[index].transform, TailSegments[index].ColliderRadius) * 0.95f;
		if (Object.op_Implicit((Object)(object)collisionContacts.collider))
		{
			Collider collider = collisionContacts.collider;
			SphereCollider val = (SphereCollider)(object)((collider is SphereCollider) ? collider : null);
			if (Object.op_Implicit((Object)(object)val))
			{
				FImp_ColliderData_Sphere.PushOutFromSphereCollider(val, num, ref pos, Vector3.zero);
			}
			else
			{
				Collider collider2 = collisionContacts.collider;
				CapsuleCollider val2 = (CapsuleCollider)(object)((collider2 is CapsuleCollider) ? collider2 : null);
				if (Object.op_Implicit((Object)(object)val2))
				{
					FImp_ColliderData_Capsule.PushOutFromCapsuleCollider(val2, num, ref pos, Vector3.zero);
				}
				else
				{
					Collider collider3 = collisionContacts.collider;
					BoxCollider val3 = (BoxCollider)(object)((collider3 is BoxCollider) ? collider3 : null);
					if (Object.op_Implicit((Object)(object)val3))
					{
						if (Object.op_Implicit((Object)(object)TailSegments[index].CollisionHelper.RigBody))
						{
							if (Object.op_Implicit((Object)(object)((Collider)val3).attachedRigidbody))
							{
								if (TailSegments[index].CollisionHelper.RigBody.mass > 1f)
								{
									FImp_ColliderData_Box.PushOutFromBoxCollider(val3, collisionContacts, num, ref pos);
									Vector3 val4 = pos;
									FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
									pos = Vector3.Lerp(pos, val4, TailSegments[index].CollisionHelper.RigBody.mass / 5f);
								}
								else
								{
									FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
								}
							}
							else
							{
								FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
							}
						}
						else
						{
							FImp_ColliderData_Box.PushOutFromBoxCollider(val3, num, ref pos);
						}
					}
					else
					{
						Collider collider4 = collisionContacts.collider;
						MeshCollider val5 = (MeshCollider)(object)((collider4 is MeshCollider) ? collider4 : null);
						if (Object.op_Implicit((Object)(object)val5))
						{
							FImp_ColliderData_Mesh.PushOutFromMeshCollider(val5, collisionContacts, num, ref pos);
						}
						else
						{
							Collider collider5 = collisionContacts.collider;
							FImp_ColliderData_Terrain.PushOutFromTerrain((TerrainCollider)(object)((collider5 is TerrainCollider) ? collider5 : null), num, ref pos);
						}
					}
				}
			}
		}
		return true;
	}

	public void RefreshIncludedCollidersDataList()
	{
		bool flag = false;
		if (CollisionMode == ECollisionMode.m_3DCollision)
		{
			if (IncludedColliders.Count != IncludedCollidersData.Count || forceRefreshCollidersData)
			{
				IncludedCollidersData.Clear();
				for (int num = IncludedColliders.Count - 1; num >= 0; num--)
				{
					if ((Object)(object)IncludedColliders[num] == (Object)null)
					{
						IncludedColliders.RemoveAt(num);
					}
					else
					{
						FImp_ColliderData_Base colliderDataFor = FImp_ColliderData_Base.GetColliderDataFor(IncludedColliders[num]);
						IncludedCollidersData.Add(colliderDataFor);
					}
				}
				flag = true;
			}
		}
		else if (IncludedColliders2D.Count != IncludedCollidersData.Count || forceRefreshCollidersData)
		{
			IncludedCollidersData.Clear();
			for (int num2 = IncludedColliders2D.Count - 1; num2 >= 0; num2--)
			{
				if ((Object)(object)IncludedColliders2D[num2] == (Object)null)
				{
					IncludedColliders2D.RemoveAt(num2);
				}
				else
				{
					FImp_ColliderData_Base colliderDataFor2 = FImp_ColliderData_Base.GetColliderDataFor(IncludedColliders2D[num2]);
					IncludedCollidersData.Add(colliderDataFor2);
				}
			}
			flag = true;
		}
		if (flag)
		{
			forceRefreshCollidersData = false;
		}
	}

	public bool PushIfSegmentInsideCollider(TailSegment bone, ref Vector3 targetPoint)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (!CheapCollision)
		{
			for (int i = 0; i < CollidersDataToCheck.Count; i++)
			{
				bool flag2 = CollidersDataToCheck[i].PushIfInside(ref targetPoint, bone.GetRadiusScaled(), Vector3.zero);
				if (!flag && flag2)
				{
					flag = true;
					bone.LatestSelectiveCollision = CollidersDataToCheck[i];
				}
			}
		}
		else
		{
			for (int j = 0; j < CollidersDataToCheck.Count; j++)
			{
				if (CollidersDataToCheck[j].PushIfInside(ref targetPoint, bone.GetRadiusScaled(), Vector3.zero))
				{
					bone.LatestSelectiveCollision = CollidersDataToCheck[j];
					return true;
				}
			}
		}
		return flag;
	}

	protected float GetColliderSphereRadiusFor(int i)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		_ = TailSegments[i];
		float num = 1f;
		if (i >= _TransformsGhostChain.Count)
		{
			return num;
		}
		if (_TransformsGhostChain.Count > 1)
		{
			num = Vector3.Distance(_TransformsGhostChain[1].position, _TransformsGhostChain[0].position);
		}
		float num2 = num;
		if (i != 0)
		{
			num2 = Mathf.Lerp(num, Vector3.Distance(_TransformsGhostChain[i - 1].position, _TransformsGhostChain[i].position) * 0.5f, CollisionsAutoCurve);
		}
		float num3 = _TransformsGhostChain.Count - 1;
		if (num3 <= 0f)
		{
			num3 = 1f;
		}
		float num4 = 1f / num3;
		return 0.5f * num2 * CollidersScaleMul * CollidersScaleCurve.Evaluate(num4 * (float)i);
	}

	protected float GetColliderSphereRadiusFor(List<Transform> transforms, int i)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		if (transforms.Count > 1)
		{
			num = Vector3.Distance(_TransformsGhostChain[1].position, _TransformsGhostChain[0].position);
		}
		float num2 = num;
		if (i != 0)
		{
			num2 = Vector3.Distance(_TransformsGhostChain[i - 1].position, _TransformsGhostChain[i].position);
		}
		float num3 = Mathf.Lerp(num, num2 * 0.5f, CollisionsAutoCurve);
		float num4 = 1f / (float)(transforms.Count - 1);
		return 0.5f * num3 * CollidersScaleMul * CollidersScaleCurve.Evaluate(num4 * (float)i);
	}

	public void AddCollider(Collider collider)
	{
		if (!IncludedColliders.Contains(collider))
		{
			IncludedColliders.Add(collider);
		}
	}

	public void AddCollider(Collider2D collider)
	{
		if (!IncludedColliders2D.Contains(collider))
		{
			IncludedColliders2D.Add(collider);
		}
	}

	public void CheckForColliderDuplicatesAndNulls()
	{
		for (int i = 0; i < IncludedColliders.Count; i++)
		{
			Collider col = IncludedColliders[i];
			if (IncludedColliders.Count((Collider o) => (Object)(object)o == (Object)(object)col) > 1)
			{
				IncludedColliders.RemoveAll((Collider o) => (Object)(object)o == (Object)(object)col);
				IncludedColliders.Add(col);
			}
		}
		for (int num = IncludedColliders.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)IncludedColliders[num] == (Object)null)
			{
				IncludedColliders.RemoveAt(num);
			}
		}
	}

	public void CheckForColliderDuplicatesAndNulls2D()
	{
		for (int i = 0; i < IncludedColliders2D.Count; i++)
		{
			Collider2D col = IncludedColliders2D[i];
			if (IncludedColliders2D.Count((Collider2D o) => (Object)(object)o == (Object)(object)col) > 1)
			{
				IncludedColliders2D.RemoveAll((Collider2D o) => (Object)(object)o == (Object)(object)col);
				IncludedColliders2D.Add(col);
			}
		}
	}

	private void TailCalculations_ComputeSegmentCollisions(TailSegment bone, ref Vector3 position)
	{
		if (bone.CollisionContactFlag)
		{
			bone.CollisionContactFlag = false;
		}
		else if (bone.CollisionContactRelevancy > 0f)
		{
			bone.CollisionContactRelevancy -= justDelta;
		}
		if (CollisionSpace == ECollisionSpace.Selective_Fast)
		{
			if (PushIfSegmentInsideCollider(bone, ref position))
			{
				bone.CollisionContactFlag = true;
				bone.CollisionContactRelevancy = justDelta * 7f;
				bone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3.5f);
				if (bone.ChildBone.ChildBone != null)
				{
					bone.ChildBone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3f);
				}
			}
		}
		else if (UseCollisionContact(bone.Index, ref position))
		{
			bone.CollisionContactFlag = true;
			bone.CollisionContactRelevancy = justDelta * 7f;
			bone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3.5f);
			if (bone.ChildBone.ChildBone != null)
			{
				bone.ChildBone.ChildBone.CollisionContactRelevancy = Mathf.Max(bone.ChildBone.CollisionContactRelevancy, justDelta * 3f);
			}
		}
	}

	private void ExpertParamsUpdate()
	{
		Expert_UpdatePosSpeed();
		Expert_UpdateRotSpeed();
		Expert_UpdateSpringiness();
		Expert_UpdateSlithery();
		Expert_UpdateCurling();
		Expert_UpdateSlippery();
		Expert_UpdateBlending();
	}

	private void ExpertCurvesEndUpdate()
	{
		lastPosSpeeds = ReactionSpeed;
		if (!UsePosSpeedCurve && lastPosCurvKeys != null)
		{
			lastPosCurvKeys = null;
			lastPosSpeeds += 0.001f;
		}
		lastRotSpeeds = RotationRelevancy;
		if (!UseRotSpeedCurve && lastRotCurvKeys != null)
		{
			lastRotCurvKeys = null;
			lastRotSpeeds += 0.001f;
		}
		lastSpringiness = Springiness;
		if (!UseSpringCurve && lastSpringCurvKeys != null)
		{
			lastSpringCurvKeys = null;
			lastSpringiness += 0.001f;
		}
		lastSlithery = Slithery;
		if (!UseSlitheryCurve && lastSlitheryCurvKeys != null)
		{
			lastSlitheryCurvKeys = null;
			lastSlithery += 0.001f;
		}
		lastCurling = Curling;
		if (!UseCurlingCurve && lastCurlingCurvKeys != null)
		{
			lastCurlingCurvKeys = null;
			lastCurling += 0.001f;
		}
		lastSlippery = CollisionSlippery;
		if (!UseSlipperyCurve && lastSlipperyCurvKeys != null)
		{
			lastSlipperyCurvKeys = null;
			lastSlippery += 0.001f;
		}
		lastTailAnimatorAmount = TailAnimatorAmount;
		if (!UsePartialBlend && lastBlendCurvKeys != null)
		{
			lastBlendCurvKeys = null;
			lastTailAnimatorAmount += 0.001f;
		}
	}

	private void Expert_UpdatePosSpeed()
	{
		if (UsePosSpeedCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.PositionSpeed = PosCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastPosSpeeds != ReactionSpeed)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.PositionSpeed = ReactionSpeed;
			}
		}
	}

	private void Expert_UpdateRotSpeed()
	{
		if (UseRotSpeedCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.RotationSpeed = RotCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastRotSpeeds != RotationRelevancy)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.RotationSpeed = RotationRelevancy;
			}
		}
	}

	private void Expert_UpdateSpringiness()
	{
		if (UseSpringCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Springiness = SpringCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastSpringiness != Springiness)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Springiness = Springiness;
			}
		}
	}

	private void Expert_UpdateSlithery()
	{
		if (UseSlitheryCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slithery = SlitheryCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastSlithery != Slithery)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slithery = Slithery;
			}
		}
	}

	private void Expert_UpdateCurling()
	{
		if (UseCurlingCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Curling = CurlingCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastCurling != Curling)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Curling = Curling;
			}
		}
	}

	private void Expert_UpdateSlippery()
	{
		if (UseSlipperyCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slippery = SlipperyCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastSlippery != CollisionSlippery)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.Slippery = CollisionSlippery;
			}
		}
	}

	private void Expert_UpdateBlending()
	{
		if (UsePartialBlend)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.BlendValue = BlendCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastTailAnimatorAmount != TailAnimatorAmount)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.BlendValue = TailAnimatorAmount;
			}
		}
	}

	private void InitIK()
	{
		if (!IKSelectiveChain)
		{
			IK = new FIK_CCDProcessor(_TransformsGhostChain.ToArray());
		}
		else
		{
			List<Transform> list = new List<Transform>();
			if (IKLimitSettings.Count != _TransformsGhostChain.Count)
			{
				list = _TransformsGhostChain;
			}
			else
			{
				for (int i = 0; i < _TransformsGhostChain.Count; i++)
				{
					if (IKLimitSettings[i].UseInChain)
					{
						list.Add(_TransformsGhostChain[i]);
					}
				}
			}
			IK = new FIK_CCDProcessor(list.ToArray());
		}
		if (IKAutoWeights)
		{
			IK.AutoWeightBones(IKBaseReactionWeight);
		}
		else
		{
			IK.AutoWeightBones(IKReactionWeightCurve);
		}
		if (IKAutoAngleLimits)
		{
			IK.AutoLimitAngle(IKAutoAngleLimit, 4f + IKAutoAngleLimit / 15f);
		}
		if (!IKSelectiveChain)
		{
			IK.Init(_TransformsGhostChain[0]);
		}
		else
		{
			IK.Init(IK.Bones[0].transform);
		}
		ikInitialized = true;
		IK_ApplyLimitBoneSettings();
	}

	public void IKSetCustomPosition(Vector3? tgt)
	{
		_IKCustomPos = tgt;
	}

	private void UpdateIK()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		if (!ikInitialized)
		{
			InitIK();
		}
		if (IKBlend <= Mathf.Epsilon)
		{
			return;
		}
		if (_IKCustomPos.HasValue)
		{
			IK.IKTargetPosition = _IKCustomPos.Value;
		}
		else if ((Object)(object)IKTarget == (Object)null)
		{
			IK.IKTargetPosition = TailSegments[TailSegments.Count - 1].ProceduralPosition;
		}
		else
		{
			IK.IKTargetPosition = IKTarget.position;
		}
		IK.Invert = IkInvertOrder;
		IK.IKWeight = IKBlend;
		IK.SyncWithAnimator = IKAnimatorBlend;
		IK.ReactionQuality = IKReactionQuality;
		IK.Smoothing = IKSmoothing;
		IK.StretchToTarget = IKStretchToTarget;
		IK.StretchCurve = IKStretchCurve;
		IK.ContinousSolving = IKContinousSolve;
		if (IK.StretchToTarget > 0f)
		{
			IK.ContinousSolving = false;
		}
		if (Axis2D == 3)
		{
			IK.Use2D = true;
		}
		else
		{
			IK.Use2D = false;
		}
		IK.Update();
		if (DetachChildren)
		{
			TailSegment tailSegment = TailSegments[0];
			tailSegment = TailSegments[1];
			if (!IncludeParent)
			{
				tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
				tailSegment = TailSegments[2];
			}
			while (tailSegment != GhostChild)
			{
				tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
				tailSegment = tailSegment.ChildBone;
			}
		}
		else
		{
			for (TailSegment tailSegment2 = TailSegments[0]; tailSegment2 != GhostChild; tailSegment2 = tailSegment2.ChildBone)
			{
				tailSegment2.RefreshKeyLocalPositionAndRotation();
			}
		}
	}

	public void IK_ApplyLimitBoneSettings()
	{
		if (!IKAutoAngleLimits)
		{
			if (IKLimitSettings.Count != _TransformsGhostChain.Count)
			{
				IK_RefreshLimitSettingsContainer();
			}
			if (IK.IKBones.Length != IKLimitSettings.Count)
			{
				Debug.Log((object)"[TAIL ANIMATOR IK] Wrong IK bone count!");
				return;
			}
			if (!IKAutoAngleLimits)
			{
				for (int i = 0; i < IKLimitSettings.Count; i++)
				{
					IK.IKBones[i].AngleLimit = IKLimitSettings[i].AngleLimit;
					IK.IKBones[i].TwistAngleLimit = IKLimitSettings[i].TwistAngleLimit;
				}
			}
		}
		if (ikInitialized)
		{
			if (IKAutoWeights)
			{
				IK.AutoWeightBones(IKBaseReactionWeight);
			}
			else
			{
				IK.AutoWeightBones(IKReactionWeightCurve);
			}
		}
		if (IKAutoAngleLimits)
		{
			IK.AutoLimitAngle(IKAutoAngleLimit, 10f + IKAutoAngleLimit / 10f);
		}
	}

	public void IK_RefreshLimitSettingsContainer()
	{
		IKLimitSettings = new List<IKBoneSettings>();
		for (int i = 0; i < _TransformsGhostChain.Count; i++)
		{
			IKLimitSettings.Add(new IKBoneSettings());
		}
	}

	private bool PostProcessingNeeded()
	{
		if (Deflection > Mathf.Epsilon)
		{
			return true;
		}
		return false;
	}

	private void PostProcessing_Begin()
	{
		TailSegments_UpdateCoordsForRootBone(_pp_reference[_tc_startI]);
		if (Deflection > Mathf.Epsilon)
		{
			Deflection_BeginUpdate();
		}
	}

	private void PostProcessing_ReferenceUpdate()
	{
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment;
		for (tailSegment = _pp_reference[_tc_startI]; tailSegment != _pp_ref_lastChild; tailSegment = tailSegment.ChildBone)
		{
			tailSegment.ParamsFrom(TailSegments[tailSegment.Index]);
			TailSegment_PrepareVelocity(tailSegment);
		}
		TailSegment_PrepareMotionParameters(_pp_ref_lastChild);
		TailSegment_PrepareVelocity(_pp_ref_lastChild);
		tailSegment = _pp_reference[_tc_startII];
		if (!DetachChildren)
		{
			while (tailSegment != _pp_ref_lastChild)
			{
				TailSegment_PrepareRotation(tailSegment);
				TailSegment_BaseSwingProcessing(tailSegment);
				TailCalculations_SegmentPreProcessingStack(tailSegment);
				TailSegment_PreRotationPositionBlend(tailSegment);
				tailSegment = tailSegment.ChildBone;
			}
		}
		else
		{
			while (tailSegment != _pp_ref_lastChild)
			{
				TailSegment_PrepareRotationDetached(tailSegment);
				TailSegment_BaseSwingProcessing(tailSegment);
				TailCalculations_SegmentPreProcessingStack(tailSegment);
				TailSegment_PreRotationPositionBlend(tailSegment);
				tailSegment = tailSegment.ChildBone;
			}
		}
		TailCalculations_UpdateArtificialChildBone(_pp_ref_lastChild);
		for (tailSegment = _pp_reference[_tc_startII]; tailSegment != _pp_ref_lastChild; tailSegment = tailSegment.ChildBone)
		{
			TailCalculations_SegmentRotation(tailSegment, tailSegment.LastKeyframeLocalPosition);
		}
		TailCalculations_SegmentRotation(tailSegment, tailSegment.LastKeyframeLocalPosition);
		tailSegment.ParentBone.RefreshFinalRot(tailSegment.ParentBone.TrueTargetRotation);
	}

	private void ShapingParamsUpdate()
	{
		Shaping_UpdateCurving();
		Shaping_UpdateGravity();
		Shaping_UpdateLengthMultiplier();
	}

	private void Shaping_UpdateCurving()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (!Curving.QIsZero())
		{
			if (UseCurvingCurve)
			{
				for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
				{
					_ex_bone.Curving = Quaternion.LerpUnclamped(Quaternion.identity, Curving, CurvCurve.Evaluate(_ex_bone.IndexOverlLength));
				}
			}
			else if (!Curving.QIsSame(lastCurving))
			{
				for (int i = 0; i < TailSegments.Count; i++)
				{
					TailSegments[i].Curving = Curving;
				}
			}
		}
		else if (!Curving.QIsSame(lastCurving))
		{
			for (int j = 0; j < TailSegments.Count; j++)
			{
				TailSegments[j].Curving = Quaternion.identity;
			}
		}
	}

	private void Shaping_UpdateGravity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		if (!Gravity.VIsZero())
		{
			if (UseGravityCurve)
			{
				for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
				{
					_ex_bone.Gravity = Gravity * 40f * GravityCurve.Evaluate(_ex_bone.IndexOverlLength);
				}
			}
			else if (!Gravity.VIsSame(lastGravity))
			{
				for (int i = 0; i < TailSegments.Count; i++)
				{
					TailSegments[i].Gravity = Gravity / 40f;
					TailSegment tailSegment = TailSegments[i];
					tailSegment.Gravity *= 1f + (float)TailSegments[i].Index / 2f * (1f - TailSegments[i].Slithery);
				}
			}
		}
		else if (!Gravity.VIsSame(lastGravity))
		{
			for (int j = 0; j < TailSegments.Count; j++)
			{
				TailSegments[j].Gravity = Vector3.zero;
				TailSegments[j].GravityLookOffset = Vector3.zero;
			}
		}
	}

	private void Shaping_UpdateLengthMultiplier()
	{
		if (UseLengthMulCurve)
		{
			for (_ex_bone = TailSegments[0]; _ex_bone != null; _ex_bone = _ex_bone.ChildBone)
			{
				_ex_bone.LengthMultiplier = LengthMulCurve.Evaluate(_ex_bone.IndexOverlLength);
			}
		}
		else if (lastLengthMul != LengthMultiplier)
		{
			for (int i = 0; i < TailSegments.Count; i++)
			{
				TailSegments[i].LengthMultiplier = LengthMultiplier;
			}
		}
	}

	private void ShapingEndUpdate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		lastCurving = Curving;
		if (!UseCurvingCurve && lastCurvingKeys != null)
		{
			lastCurvingKeys = null;
			lastCurving.x += 0.001f;
		}
		lastGravity = Gravity;
		if (!UseGravityCurve && lastGravityKeys != null)
		{
			lastGravityKeys = null;
			lastGravity.x += 0.001f;
		}
		lastLengthMul = LengthMultiplier;
		if (!UseLengthMulCurve && lastLengthKeys != null)
		{
			lastLengthKeys = null;
			lastLengthMul += 0.0001f;
		}
	}

	private void Waving_Initialize()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (FixedCycle == 0f)
		{
			_waving_waveTime = Random.Range(-MathF.PI, MathF.PI) * 100f;
			_waving_cosTime = Random.Range(-MathF.PI, MathF.PI) * 50f;
		}
		else
		{
			_waving_waveTime = FixedCycle;
			_waving_cosTime = FixedCycle;
		}
		_waving_sustain = Vector3.zero;
	}

	private void Waving_AutoSwingUpdate()
	{
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		_waving_waveTime += justDelta * (2f * WavingSpeed);
		if (WavingType == FEWavingType.Simple)
		{
			float num = Mathf.Sin(_waving_waveTime) * (30f * WavingRange);
			if (CosinusAdd)
			{
				_waving_cosTime += justDelta * (2.535f * WavingSpeed);
				num += Mathf.Cos(_waving_cosTime) * (27f * WavingRange);
			}
			WavingRotationOffset = Quaternion.Euler(num * WavingAxis * TailSegments[0].BlendValue);
		}
		else
		{
			float num2 = _waving_waveTime * 0.23f;
			float num3 = AlternateWave * -5f;
			float num4 = AlternateWave * 100f;
			float num5 = AlternateWave * 20f;
			float num6 = Mathf.PerlinNoise(num2, num3) * 2f - 1f;
			float num7 = Mathf.PerlinNoise(num4 + num2, num2 + num4) * 2f - 1f;
			float num8 = Mathf.PerlinNoise(num5, num2) * 2f - 1f;
			WavingRotationOffset = Quaternion.Euler(Vector3.Scale(WavingAxis * WavingRange * 35f * TailSegments[0].BlendValue, new Vector3(num6, num7, num8)));
		}
	}

	private void Waving_SustainUpdate()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment = TailSegments[0];
		float num = _TC_TailLength / (float)TailSegments.Count;
		num = Mathf.Pow(num, 1.65f);
		num = _sg_curly / num / 6f;
		if (num < 0.1f)
		{
			num = 0.1f;
		}
		else if (num > 1f)
		{
			num = 1f;
		}
		int num2 = (int)Mathf.LerpUnclamped((float)TailSegments.Count * 0.4f, (float)TailSegments.Count * 0.6f, Sustain);
		float end = FEasing.EaseOutExpo(1f, 0.09f, Sustain);
		float num3 = 1.5f;
		num3 *= 1f - TailSegments[0].Curling / 8f;
		num3 *= 1.5f - num / 1.65f;
		num3 *= Mathf.Lerp(0.7f, 1.2f, tailSegment.Slithery);
		num3 *= FEasing.EaseOutExpo(1f, end, tailSegment.Springiness);
		Vector3 val = TailSegments[num2].PreviousPush;
		if (num2 + 1 < TailSegments.Count)
		{
			val += TailSegments[num2 + 1].PreviousPush;
		}
		if (num2 - 1 > TailSegments.Count)
		{
			val += TailSegments[num2 - 1].PreviousPush;
		}
		_waving_sustain = val * Sustain * num3 * 2f;
	}

	private void WindEffectUpdate()
	{
		if (Object.op_Implicit((Object)(object)TailAnimatorWind.Instance))
		{
			TailAnimatorWind.Instance.AffectTailWithWind(this);
		}
	}

	protected virtual void Init()
	{
		//IL_0571: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0461: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		if (initialized)
		{
			return;
		}
		if (_TransformsGhostChain == null || _TransformsGhostChain.Count == 0)
		{
			_TransformsGhostChain = new List<Transform>();
			GetGhostChain();
		}
		TailSegments = new List<TailSegment>();
		for (int i = 0; i < _TransformsGhostChain.Count; i++)
		{
			if ((Object)(object)_TransformsGhostChain[i] == (Object)null)
			{
				Debug.Log((object)("[Tail Animator] Null bones in " + ((Object)this).name + " !"));
				continue;
			}
			TailSegment tailSegment = new TailSegment(_TransformsGhostChain[i]);
			tailSegment.SetIndex(i, _TransformsGhostChain.Count);
			TailSegments.Add(tailSegment);
		}
		if (TailSegments.Count == 0)
		{
			Debug.Log((object)("[Tail Animator] Could not create tail bones chain in " + ((Object)this).name + " !"));
			return;
		}
		_TC_TailLength = 0f;
		_baseTransform = _TransformsGhostChain[0];
		for (int j = 0; j < TailSegments.Count; j++)
		{
			TailSegment tailSegment2 = TailSegments[j];
			TailSegment tailSegment3;
			if (j == 0)
			{
				if (Object.op_Implicit((Object)(object)tailSegment2.transform.parent))
				{
					tailSegment3 = new TailSegment(tailSegment2.transform.parent);
					tailSegment3.SetParentRef(new TailSegment(tailSegment3.transform.parent));
				}
				else
				{
					tailSegment3 = new TailSegment(tailSegment2.transform);
					Vector3 val;
					if (_TransformsGhostChain.Count > 1)
					{
						val = _TransformsGhostChain[0].position - _TransformsGhostChain[1].position;
						if (((Vector3)(ref val)).magnitude == 0f)
						{
							val = ((Component)this).transform.position - _TransformsGhostChain[1].position;
						}
					}
					else
					{
						val = tailSegment2.transform.position - _TransformsGhostChain[0].position;
					}
					if (((Vector3)(ref val)).magnitude == 0f)
					{
						val = ((Component)this).transform.position - _TransformsGhostChain[0].position;
					}
					if (((Vector3)(ref val)).magnitude == 0f)
					{
						val = ((Component)this).transform.forward;
					}
					tailSegment3.LocalOffset = tailSegment3.transform.InverseTransformPoint(tailSegment3.transform.position + val);
					tailSegment3.SetParentRef(new TailSegment(tailSegment2.transform));
				}
				GhostParent = tailSegment3;
				GhostParent.Validate();
				tailSegment2.SetParentRef(GhostParent);
			}
			else
			{
				tailSegment3 = TailSegments[j - 1];
				tailSegment2.ReInitializeLocalPosRot(tailSegment3.transform.InverseTransformPoint(tailSegment2.transform.position), tailSegment2.transform.localRotation);
			}
			if (j == TailSegments.Count - 1)
			{
				Transform transform = null;
				if (tailSegment2.transform.childCount > 0)
				{
					transform = tailSegment2.transform.GetChild(0);
				}
				GhostChild = new TailSegment(transform);
				Vector3 val2 = ((!EndBoneJointOffset.VIsZero()) ? tailSegment2.transform.TransformVector(EndBoneJointOffset) : (Object.op_Implicit((Object)(object)tailSegment2.transform.parent) ? (tailSegment2.transform.position - tailSegment2.transform.parent.position) : ((tailSegment2.transform.childCount <= 0) ? (tailSegment2.transform.TransformDirection(Vector3.forward) * 0.05f) : (tailSegment2.transform.GetChild(0).position - tailSegment2.transform.position))));
				GhostChild.ProceduralPosition = tailSegment2.transform.position + val2;
				GhostChild.ProceduralPositionWeightBlended = GhostChild.ProceduralPosition;
				GhostChild.PreviousPosition = GhostChild.ProceduralPosition;
				GhostChild.PosRefRotation = Quaternion.identity;
				GhostChild.PreviousPosReferenceRotation = Quaternion.identity;
				GhostChild.ReInitializeLocalPosRot(tailSegment2.transform.InverseTransformPoint(GhostChild.ProceduralPosition), Quaternion.identity);
				GhostChild.RefreshFinalPos(GhostChild.ProceduralPosition);
				GhostChild.RefreshFinalRot(GhostChild.PosRefRotation);
				GhostChild.TrueTargetRotation = GhostChild.PosRefRotation;
				tailSegment2.TrueTargetRotation = tailSegment2.transform.rotation;
				tailSegment2.SetChildRef(GhostChild);
				GhostChild.SetParentRef(tailSegment2);
			}
			else
			{
				tailSegment2.SetChildRef(TailSegments[j + 1]);
			}
			tailSegment2.SetParentRef(tailSegment3);
			_TC_TailLength += Vector3.Distance(tailSegment2.ProceduralPosition, tailSegment3.ProceduralPosition);
			if ((Object)(object)tailSegment2.transform != (Object)(object)_baseTransform)
			{
				tailSegment2.AssignDetachedRootCoords(BaseTransform);
			}
		}
		GhostParent.SetIndex(-1, TailSegments.Count);
		GhostChild.SetIndex(TailSegments.Count, TailSegments.Count);
		GhostParent.SetChildRef(TailSegments[0]);
		previousWorldPosition = BaseTransform.position;
		WavingRotationOffset = Quaternion.identity;
		if (CollidersDataToCheck == null)
		{
			CollidersDataToCheck = new List<FImp_ColliderData_Base>();
		}
		DynamicAlwaysInclude = new List<Component>();
		if (UseCollision)
		{
			SetupSphereColliders();
		}
		if (_defl_source == null)
		{
			_defl_source = new List<TailSegment>();
		}
		Waving_Initialize();
		if (DetachChildren)
		{
			DetachChildrenTransforms();
		}
		initialized = true;
		if (TailSegments.Count == 1 && (Object)(object)TailSegments[0].transform.parent == (Object)null)
		{
			Debug.Log((object)"[Tail Animator] Can't initialize one-bone length chain on bone which don't have any parent!");
			Debug.LogError((object)"[Tail Animator] Can't initialize one-bone length chain on bone which don't have any parent!");
			TailAnimatorAmount = 0f;
			initialized = false;
			return;
		}
		if (UseWind)
		{
			TailAnimatorWind.Refresh();
		}
		if (PostProcessingNeeded() && !_pp_initialized)
		{
			InitializePostProcessing();
		}
		if (!Prewarm)
		{
			return;
		}
		ShapingParamsUpdate();
		ExpertParamsUpdate();
		Tick();
		LateTick();
		justDelta = rateDelta;
		secPeriodDelta = 1f;
		deltaForLerps = secPeriodDelta;
		rateDelta = 1f / 60f;
		CheckIfTailAnimatorShouldBeUpdated();
		if (updateTailAnimator)
		{
			int num = 60 + TailSegments.Count / 2;
			for (int k = 0; k < num; k++)
			{
				PreCalibrateBones();
				LateTick();
			}
		}
	}

	public void DetachChildrenTransforms()
	{
		int num = ((!IncludeParent) ? 1 : 0);
		for (int num2 = TailSegments.Count - 1; num2 >= num; num2--)
		{
			if (Object.op_Implicit((Object)(object)TailSegments[num2].transform))
			{
				TailSegments[num2].transform.DetachChildren();
			}
		}
	}

	private void InitializePostProcessing()
	{
		_pp_reference = new List<TailSegment>();
		_pp_ref_rootParent = new TailSegment(GhostParent);
		for (int i = 0; i < TailSegments.Count; i++)
		{
			TailSegment item = new TailSegment(TailSegments[i]);
			_pp_reference.Add(item);
		}
		_pp_ref_lastChild = new TailSegment(GhostChild);
		_pp_ref_rootParent.SetChildRef(_pp_reference[0]);
		_pp_ref_rootParent.SetParentRef(new TailSegment(GhostParent.ParentBone.transform));
		for (int j = 0; j < _pp_reference.Count; j++)
		{
			TailSegment tailSegment = _pp_reference[j];
			tailSegment.SetIndex(j, TailSegments.Count);
			if (j == 0)
			{
				tailSegment.SetParentRef(_pp_ref_rootParent);
				tailSegment.SetChildRef(_pp_reference[j + 1]);
			}
			else if (j == _pp_reference.Count - 1)
			{
				tailSegment.SetParentRef(_pp_reference[j - 1]);
				tailSegment.SetChildRef(_pp_ref_lastChild);
			}
			else
			{
				tailSegment.SetParentRef(_pp_reference[j - 1]);
				tailSegment.SetChildRef(_pp_reference[j + 1]);
			}
		}
		_pp_ref_lastChild.SetParentRef(_pp_reference[_pp_reference.Count - 1]);
		_pp_initialized = true;
	}

	protected void StretchingLimiting(TailSegment bone)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = bone.ParentBone.ProceduralPosition - bone.ProceduralPosition;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (!(magnitude > 0f))
		{
			return;
		}
		float num = bone.BoneLengthScaled + bone.BoneLengthScaled * 2.5f * MaxStretching;
		if (magnitude > num)
		{
			if (MaxStretching == 0f)
			{
				_limiting_limitPosition = bone.ProceduralPosition + val * ((magnitude - bone.BoneLengthScaled) / magnitude);
				bone.ProceduralPosition = _limiting_limitPosition;
				return;
			}
			_limiting_limitPosition = bone.ParentBone.ProceduralPosition - ((Vector3)(ref val)).normalized * num;
			float num2 = Mathf.InverseLerp(magnitude, 0f, num) + _limiting_stretchingHelperTooLong;
			if (num2 > 0.999f)
			{
				num2 = 0.99f;
			}
			if (ReactionSpeed < 0.5f)
			{
				num2 *= deltaForLerps * (10f + ReactionSpeed * 30f);
			}
			bone.ProceduralPosition = Vector3.Lerp(bone.ProceduralPosition, _limiting_limitPosition, num2);
			return;
		}
		num = bone.BoneLengthScaled + bone.BoneLengthScaled * 1.1f * MaxStretching;
		if (magnitude < num)
		{
			_limiting_limitPosition = bone.ProceduralPosition + val * ((magnitude - bone.BoneLengthScaled) / magnitude);
			if (MaxStretching == 0f)
			{
				bone.ProceduralPosition = _limiting_limitPosition;
			}
			else
			{
				bone.ProceduralPosition = Vector3.LerpUnclamped(bone.ProceduralPosition, _limiting_limitPosition, Mathf.InverseLerp(magnitude, 0f, num) + _limiting_stretchingHelperTooShort);
			}
		}
	}

	protected Vector3 AngleLimiting(TailSegment child, Vector3 targetPos)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		_limiting_limitPosition = targetPos;
		_limiting_angle_ToTargetRot = Quaternion.FromToRotation(child.ParentBone.transform.TransformDirection(child.LastKeyframeLocalPosition), targetPos - child.ParentBone.ProceduralPosition) * child.ParentBone.transform.rotation;
		_limiting_angle_targetInLocal = child.ParentBone.transform.rotation.QToLocal(_limiting_angle_ToTargetRot);
		float num2 = 0f;
		if (((Vector3)(ref AngleLimitAxis)).sqrMagnitude == 0f)
		{
			num2 = Quaternion.Angle(_limiting_angle_targetInLocal, child.LastKeyframeLocalRotation);
		}
		else
		{
			((Vector3)(ref AngleLimitAxis)).Normalize();
			Vector3 val;
			if (LimitAxisRange.x == LimitAxisRange.y)
			{
				val = Vector3.Scale(((Quaternion)(ref child.InitialLocalRotation)).eulerAngles, AngleLimitAxis);
				float magnitude = ((Vector3)(ref val)).magnitude;
				val = Vector3.Scale(((Quaternion)(ref _limiting_angle_targetInLocal)).eulerAngles, AngleLimitAxis);
				num2 = Mathf.DeltaAngle(magnitude, ((Vector3)(ref val)).magnitude);
				if (num2 < 0f)
				{
					num2 = 0f - num2;
				}
			}
			else
			{
				val = Vector3.Scale(((Quaternion)(ref child.InitialLocalRotation)).eulerAngles, AngleLimitAxis);
				float magnitude2 = ((Vector3)(ref val)).magnitude;
				val = Vector3.Scale(((Quaternion)(ref _limiting_angle_targetInLocal)).eulerAngles, AngleLimitAxis);
				num2 = Mathf.DeltaAngle(magnitude2, ((Vector3)(ref val)).magnitude);
				if (num2 > LimitAxisRange.x && num2 < LimitAxisRange.y)
				{
					num2 = 0f;
				}
				if (num2 < 0f)
				{
					num2 = 0f - num2;
				}
			}
		}
		if (num2 > AngleLimit)
		{
			float num3 = Mathf.Abs(Mathf.DeltaAngle(num2, AngleLimit));
			num = Mathf.InverseLerp(0f, AngleLimit, num3);
			if (LimitSmoothing > Mathf.Epsilon)
			{
				float num4 = Mathf.Lerp(55f, 15f, LimitSmoothing);
				_limiting_angle_newLocal = Quaternion.SlerpUnclamped(_limiting_angle_targetInLocal, child.LastKeyframeLocalRotation, deltaForLerps * num4 * num);
			}
			else
			{
				_limiting_angle_newLocal = Quaternion.SlerpUnclamped(_limiting_angle_targetInLocal, child.LastKeyframeLocalRotation, num);
			}
			_limiting_angle_ToTargetRot = child.ParentBone.transform.rotation.QToWorld(_limiting_angle_newLocal);
			_limiting_limitPosition = child.ParentBone.ProceduralPosition + _limiting_angle_ToTargetRot * Vector3.Scale(child.transform.lossyScale, child.LastKeyframeLocalPosition);
		}
		if (num > Mathf.Epsilon)
		{
			return _limiting_limitPosition;
		}
		return targetPos;
	}

	private void MotionInfluenceLimiting()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		if (MotionInfluence != 1f)
		{
			_limiting_influenceOffset = (BaseTransform.position - previousWorldPosition) * (1f - MotionInfluence);
			if (MotionInfluenceInY < 1f)
			{
				_limiting_influenceOffset.y = (BaseTransform.position.y - previousWorldPosition.y) * (1f - MotionInfluenceInY);
			}
			for (int i = 0; i < TailSegments.Count; i++)
			{
				TailSegment tailSegment = TailSegments[i];
				tailSegment.ProceduralPosition += _limiting_influenceOffset;
				TailSegment tailSegment2 = TailSegments[i];
				tailSegment2.PreviousPosition += _limiting_influenceOffset;
			}
			TailSegment ghostChild = GhostChild;
			ghostChild.ProceduralPosition += _limiting_influenceOffset;
			TailSegment ghostChild2 = GhostChild;
			ghostChild2.PreviousPosition += _limiting_influenceOffset;
		}
	}

	private void CalculateGravityPositionOffsetForSegment(TailSegment bone)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		_tc_segmentGravityOffset = (bone.Gravity + WindEffect) * bone.BoneLengthScaled;
		_tc_segmentGravityToParentDir = bone.ProceduralPosition - bone.ParentBone.ProceduralPosition;
		Vector3 val = _tc_segmentGravityToParentDir + _tc_segmentGravityOffset;
		_tc_preGravOff = ((Vector3)(ref val)).normalized * ((Vector3)(ref _tc_segmentGravityToParentDir)).magnitude;
		bone.ProceduralPosition = bone.ParentBone.ProceduralPosition + _tc_preGravOff;
	}

	private void Axis2DLimit(TailSegment child)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		child.ProceduralPosition -= child.ParentBone.transform.VAxis2DLimit(child.ParentBone.ProceduralPosition, child.ProceduralPosition, Axis2D);
	}

	public float GetDistanceMeasure(Vector3 targetPosition)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (DistanceWithoutY)
		{
			Vector3 val = BaseTransform.position + BaseTransform.TransformVector(DistanceMeasurePoint);
			return Vector2.Distance(new Vector2(val.x, val.z), new Vector2(targetPosition.x, targetPosition.z));
		}
		return Vector3.Distance(BaseTransform.position + BaseTransform.TransformVector(DistanceMeasurePoint), targetPosition);
	}

	private void MaxDistanceCalculations()
	{
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)DistanceFrom != (Object)null)
		{
			finalDistanceFrom = DistanceFrom;
		}
		else if ((Object)(object)finalDistanceFrom == (Object)null)
		{
			if ((Object)(object)_distanceFrom_Auto == (Object)null)
			{
				Camera main = Camera.main;
				if (Object.op_Implicit((Object)(object)main))
				{
					_distanceFrom_Auto = ((Component)main).transform;
				}
				else if (!wasCameraSearch)
				{
					main = Object.FindObjectOfType<Camera>();
					if (Object.op_Implicit((Object)(object)main))
					{
						_distanceFrom_Auto = ((Component)main).transform;
					}
					wasCameraSearch = true;
				}
			}
			finalDistanceFrom = _distanceFrom_Auto;
		}
		if (MaximumDistance > 0f && (Object)(object)finalDistanceFrom != (Object)null)
		{
			if (!maxDistanceExceed)
			{
				if (GetDistanceMeasure(finalDistanceFrom.position) > MaximumDistance + MaximumDistance * MaxOutDistanceFactor)
				{
					maxDistanceExceed = true;
				}
				distanceWeight += Time.unscaledDeltaTime * (1f / FadeDuration);
				if (distanceWeight > 1f)
				{
					distanceWeight = 1f;
				}
			}
			else
			{
				if (GetDistanceMeasure(finalDistanceFrom.position) <= MaximumDistance)
				{
					maxDistanceExceed = false;
				}
				distanceWeight -= Time.unscaledDeltaTime * (1f / FadeDuration);
				if (distanceWeight < 0f)
				{
					distanceWeight = 0f;
				}
			}
		}
		else
		{
			maxDistanceExceed = false;
			distanceWeight = 1f;
		}
	}

	private Vector3 TailCalculations_SmoothPosition(Vector3 from, Vector3 to, TailSegment bone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (SmoothingStyle == EAnimationStyle.Accelerating)
		{
			return TailCalculations_SmoothPositionSmoothDamp(from, to, ref bone.VelocityHelper, bone.PositionSpeed);
		}
		if (SmoothingStyle == EAnimationStyle.Quick)
		{
			return TailCalculations_SmoothPositionLerp(from, to, bone.PositionSpeed);
		}
		return TailCalculations_SmoothPositionLinear(from, to, bone.PositionSpeed);
	}

	private Vector3 TailCalculations_SmoothPositionLerp(Vector3 from, Vector3 to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Lerp(from, to, secPeriodDelta * speed);
	}

	private Vector3 TailCalculations_SmoothPositionSmoothDamp(Vector3 from, Vector3 to, ref Vector3 velo, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.SmoothDamp(from, to, ref velo, Mathf.LerpUnclamped(0.08f, 0.0001f, Mathf.Sqrt(Mathf.Sqrt(speed))), float.PositiveInfinity, rateDelta);
	}

	private Vector3 TailCalculations_SmoothPositionLinear(Vector3 from, Vector3 to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.MoveTowards(from, to, deltaForLerps * speed * 45f);
	}

	private Quaternion TailCalculations_SmoothRotation(Quaternion from, Quaternion to, TailSegment bone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (SmoothingStyle == EAnimationStyle.Accelerating)
		{
			return TailCalculations_SmoothRotationSmoothDamp(from, to, ref bone.QVelocityHelper, bone.RotationSpeed);
		}
		if (SmoothingStyle == EAnimationStyle.Quick)
		{
			return TailCalculations_SmoothRotationLerp(from, to, bone.RotationSpeed);
		}
		return TailCalculations_SmoothRotationLinear(from, to, bone.RotationSpeed);
	}

	private Quaternion TailCalculations_SmoothRotationLerp(Quaternion from, Quaternion to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Lerp(from, to, secPeriodDelta * speed);
	}

	private Quaternion TailCalculations_SmoothRotationSmoothDamp(Quaternion from, Quaternion to, ref Quaternion velo, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return from.SmoothDampRotation(to, ref velo, Mathf.LerpUnclamped(0.25f, 0.0001f, Mathf.Sqrt(Mathf.Sqrt(speed))), rateDelta);
	}

	private Quaternion TailCalculations_SmoothRotationLinear(Quaternion from, Quaternion to, float speed)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.RotateTowards(from, to, speed * deltaForLerps * 1600f);
	}

	private void TailCalculations_Begin()
	{
		if (IncludeParent)
		{
			_tc_startI = 0;
			_tc_rootBone = TailSegments[0];
		}
		else
		{
			_tc_startI = 1;
			if (TailSegments.Count > 1)
			{
				_tc_rootBone = TailSegments[1];
			}
			else
			{
				_tc_rootBone = TailSegments[0];
				_tc_startI = -1;
			}
		}
		_tc_startII = _tc_startI + 1;
		if (_tc_startII > TailSegments.Count - 1)
		{
			_tc_startII = -1;
		}
		if (Deflection > Mathf.Epsilon && !_pp_initialized)
		{
			InitializePostProcessing();
		}
		if (Tangle < 0f)
		{
			_tc_tangle = Mathf.LerpUnclamped(1f, 1.5f, Tangle + 1f);
		}
		else
		{
			_tc_tangle = Mathf.LerpUnclamped(1f, -4f, Tangle);
		}
	}

	private void TailSegments_UpdateRootFeatures()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (UseWaving)
		{
			Waving_AutoSwingUpdate();
			_tc_startBoneRotOffset = WavingRotationOffset * RotationOffset;
		}
		else
		{
			_tc_startBoneRotOffset = RotationOffset;
		}
		if (Sustain > Mathf.Epsilon)
		{
			Waving_SustainUpdate();
		}
		if (PostProcessingNeeded())
		{
			PostProcessing_Begin();
		}
	}

	private void TailCalculations_SegmentPreProcessingStack(TailSegment child)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		if (!UseCollision)
		{
			if (AngleLimit < 181f)
			{
				child.ProceduralPosition = AngleLimiting(child, child.ProceduralPosition);
			}
			if (child.PositionSpeed < 1f)
			{
				child.ProceduralPosition = TailCalculations_SmoothPosition(child.PreviousPosition, child.ProceduralPosition, child);
			}
		}
		else
		{
			if (child.PositionSpeed < 1f)
			{
				child.ProceduralPosition = TailCalculations_SmoothPosition(child.PreviousPosition, child.ProceduralPosition, child);
			}
			TailCalculations_ComputeSegmentCollisions(child, ref child.ProceduralPosition);
			if (AngleLimit < 181f)
			{
				child.ProceduralPosition = AngleLimiting(child, child.ProceduralPosition);
			}
		}
		if (MaxStretching < 1f)
		{
			StretchingLimiting(child);
		}
		if (!child.Gravity.VIsZero() || UseWind)
		{
			CalculateGravityPositionOffsetForSegment(child);
		}
		if (Axis2D > 0)
		{
			Axis2DLimit(child);
		}
	}

	private void TailCalculations_SegmentPostProcessing(TailSegment bone)
	{
		if (Deflection > Mathf.Epsilon)
		{
			Deflection_SegmentOffsetSimple(bone, ref bone.ProceduralPosition);
		}
	}

	private void TailCalculations_SegmentRotation(TailSegment child, Vector3 localOffset)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		_tc_lookRot = Quaternion.FromToRotation(child.ParentBone.transform.TransformDirection(localOffset), child.ProceduralPositionWeightBlended - child.ParentBone.ProceduralPositionWeightBlended);
		_tc_targetParentRot = _tc_lookRot * child.ParentBone.transform.rotation;
		if (AnimateRoll)
		{
			_tc_targetParentRot = Quaternion.Lerp(child.ParentBone.TrueTargetRotation, _tc_targetParentRot, deltaForLerps * Mathf.LerpUnclamped(10f, 60f, child.RotationSpeed));
		}
		child.ParentBone.TrueTargetRotation = _tc_targetParentRot;
		child.ParentBone.PreviousPosReferenceRotation = child.ParentBone.PosRefRotation;
		if (!AnimateRoll && child.RotationSpeed < 1f)
		{
			_tc_targetParentRot = TailCalculations_SmoothRotation(child.ParentBone.PosRefRotation, _tc_targetParentRot, child);
		}
		child.ParentBone.PosRefRotation = _tc_targetParentRot;
	}

	private void TailCalculations_SegmentRotationDetached(TailSegment child, Vector3 localOffset)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		_tc_lookRot = Quaternion.FromToRotation(child.ParentBone.transform.TransformDirection(localOffset), child.ProceduralPositionWeightBlended - child.ParentBone.ProceduralPositionWeightBlended);
		_tc_targetParentRot = _tc_lookRot * child.transform.rotation;
		if (AnimateRoll)
		{
			_tc_targetParentRot = Quaternion.Lerp(child.ParentBone.TrueTargetRotation, _tc_targetParentRot, deltaForLerps * Mathf.LerpUnclamped(10f, 60f, child.RotationSpeed));
		}
		child.ParentBone.TrueTargetRotation = _tc_targetParentRot;
		child.ParentBone.PreviousPosReferenceRotation = child.ParentBone.PosRefRotation;
		if (!AnimateRoll && child.RotationSpeed < 1f)
		{
			_tc_targetParentRot = TailCalculations_SmoothRotation(child.ParentBone.PosRefRotation, _tc_targetParentRot, child);
		}
		child.ParentBone.PosRefRotation = _tc_targetParentRot;
	}

	private void TailCalculations_ApplySegmentMotion(TailSegment child)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		child.ParentBone.transform.rotation = child.ParentBone.TrueTargetRotation;
		child.transform.position = child.ProceduralPositionWeightBlended;
		child.RefreshFinalPos(child.ProceduralPositionWeightBlended);
		child.ParentBone.RefreshFinalRot(child.ParentBone.TrueTargetRotation);
	}

	private void TailSegment_PrepareBoneLength(TailSegment child)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		child.BoneDimensionsScaled = Vector3.Scale(child.ParentBone.transform.lossyScale * child.LengthMultiplier, child.LastKeyframeLocalPosition);
		child.BoneLengthScaled = ((Vector3)(ref child.BoneDimensionsScaled)).magnitude;
	}

	private void TailSegment_PrepareMotionParameters(TailSegment child)
	{
		_sg_curly = Mathf.LerpUnclamped(0.5f, 0.125f, child.Curling);
		_sg_springVelo = Mathf.LerpUnclamped(0.65f, 0.9f, child.Springiness);
		_sg_curly = Mathf.Lerp(_sg_curly, Mathf.LerpUnclamped(0.95f, 0.135f, child.Curling), child.Slithery);
		_sg_springVelo = Mathf.Lerp(_sg_springVelo, Mathf.LerpUnclamped(0.1f, 0.85f, child.Springiness), child.Slithery);
	}

	private void TailSegment_PrepareVelocity(TailSegment child)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		_sg_push = child.ProceduralPosition - child.PreviousPosition;
		child.PreviousPosition = child.ProceduralPosition;
		float num = _sg_springVelo;
		if (child.CollisionContactFlag)
		{
			num *= child.Slippery;
		}
		child.ProceduralPosition += _sg_push * num;
		child.PreviousPush = _sg_push;
	}

	private void TailSegment_PrepareRotation(TailSegment child)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		_sg_targetChildWorldPosInParentFront = child.ParentBone.ProceduralPosition + TailSegment_GetSwingRotation(child, _sg_slitFactor) * child.BoneDimensionsScaled;
	}

	private void TailSegment_PrepareRotationDetached(TailSegment child)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		_sg_targetChildWorldPosInParentFront = child.ParentBone.ProceduralPosition + TailSegment_GetSwingRotationDetached(child, _sg_slitFactor) * child.BoneDimensionsScaled;
	}

	private void TailSegment_BaseSwingProcessing(TailSegment child)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		_sg_slitFactor = child.Slithery;
		if (child.CollisionContactRelevancy > 0f)
		{
			_sg_slitFactor = ReflectCollision;
		}
		_sg_dirToTargetParentFront = _sg_targetChildWorldPosInParentFront - child.ProceduralPosition;
		if (UnifyBendiness > 0f)
		{
			child.ProceduralPosition += _sg_dirToTargetParentFront * secPeriodDelta * _sg_curly * TailSegment_GetUnifiedBendinessMultiplier(child);
		}
		else
		{
			child.ProceduralPosition += _sg_dirToTargetParentFront * _sg_curly * secPeriodDelta;
		}
		if (Tangle != 0f && child.Slithery >= 1f)
		{
			child.ProceduralPosition = Vector3.LerpUnclamped(child.ProceduralPosition, _sg_targetChildWorldPosInParentFront, _tc_tangle);
		}
	}

	private void TailSegment_PreRotationPositionBlend(TailSegment child)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (child.BlendValue * conditionalWeight < 1f)
		{
			child.ProceduralPositionWeightBlended = Vector3.LerpUnclamped(child.transform.position, child.ProceduralPosition, child.BlendValue * conditionalWeight);
		}
		else
		{
			child.ProceduralPositionWeightBlended = child.ProceduralPosition;
		}
	}

	private Quaternion TailSegment_RotationSlithery(TailSegment child)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!child.Curving.QIsZero())
		{
			return GetSlitheryReferenceRotation(child) * child.Curving * child.ParentBone.LastKeyframeLocalRotation;
		}
		return GetSlitheryReferenceRotation(child) * child.ParentBone.LastKeyframeLocalRotation;
	}

	private Quaternion TailSegment_RotationSlitheryDetached(TailSegment child)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!child.Curving.QIsZero())
		{
			return GetSlitheryReferenceRotation(child) * child.Curving * child.ParentBone.InitialLocalRotation;
		}
		return GetSlitheryReferenceRotation(child) * child.ParentBone.InitialLocalRotation;
	}

	private Quaternion GetSlitheryReferenceRotation(TailSegment child)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (child.Slithery <= 1f)
		{
			return child.ParentBone.ParentBone.PosRefRotation;
		}
		return Quaternion.LerpUnclamped(child.ParentBone.ParentBone.PosRefRotation, child.ParentBone.ParentBone.PreviousPosReferenceRotation, (child.Slithery - 1f) * 5f);
	}

	private Quaternion TailSegment_RotationStiff(TailSegment child)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (!child.Curving.QIsZero())
		{
			return child.ParentBone.transform.rotation * MultiplyQ(child.Curving, (float)child.Index * 2f);
		}
		return child.ParentBone.transform.rotation;
	}

	private Quaternion TailSegment_GetSwingRotation(TailSegment child, float curlFactor)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (curlFactor >= 1f)
		{
			return TailSegment_RotationSlithery(child);
		}
		if (curlFactor > Mathf.Epsilon)
		{
			return Quaternion.LerpUnclamped(TailSegment_RotationStiff(child), TailSegment_RotationSlithery(child), curlFactor);
		}
		return TailSegment_RotationStiff(child);
	}

	private Quaternion TailSegment_GetSwingRotationDetached(TailSegment child, float curlFactor)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (curlFactor >= 1f)
		{
			return TailSegment_RotationSlitheryDetached(child);
		}
		if (curlFactor > Mathf.Epsilon)
		{
			return Quaternion.LerpUnclamped(TailSegment_RotationStiff(child), TailSegment_RotationSlitheryDetached(child), curlFactor);
		}
		return TailSegment_RotationStiff(child);
	}

	private float TailSegment_GetUnifiedBendinessMultiplier(TailSegment child)
	{
		float num = child.BoneLength / _TC_TailLength;
		num = Mathf.Pow(num, 0.5f);
		if (num == 0f)
		{
			num = 1f;
		}
		float num2 = _sg_curly / num / 2f;
		num2 = Mathf.LerpUnclamped(_sg_curly, num2, UnifyBendiness);
		if (num2 < 0.15f)
		{
			num2 = 0.15f;
		}
		else if (num2 > 1.4f)
		{
			num2 = 1.4f;
		}
		return num2;
	}

	public void TailSegments_UpdateCoordsForRootBone(TailSegment parent)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment = TailSegments[0];
		tailSegment.transform.localRotation = tailSegment.LastKeyframeLocalRotation * _tc_startBoneRotOffset;
		parent.PreviousPosReferenceRotation = parent.PosRefRotation;
		parent.PosRefRotation = parent.transform.rotation;
		parent.PreviousPosition = parent.ProceduralPosition;
		parent.ProceduralPosition = parent.transform.position;
		if (DetachChildren)
		{
			tailSegment.TrueTargetRotation = tailSegment.transform.rotation;
		}
		parent.RefreshFinalPos(parent.transform.position);
		parent.ProceduralPositionWeightBlended = parent.ProceduralPosition;
		if ((Object)(object)parent.ParentBone.transform != (Object)null)
		{
			parent.ParentBone.PreviousPosReferenceRotation = parent.ParentBone.PosRefRotation;
			parent.ParentBone.PreviousPosition = parent.ParentBone.ProceduralPosition;
			parent.ParentBone.ProceduralPosition = parent.ParentBone.transform.position;
			parent.ParentBone.PosRefRotation = parent.ParentBone.transform.rotation;
			parent.ParentBone.ProceduralPositionWeightBlended = parent.ParentBone.ProceduralPosition;
		}
		TailSegment childBone = TailSegments[_tc_startI].ChildBone;
		childBone.PreviousPosition += _waving_sustain;
		tailSegment.RefreshKeyLocalPosition();
	}

	public void TailCalculations_UpdateArtificialChildBone(TailSegment child)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		if (DetachChildren)
		{
			TailSegment_PrepareRotationDetached(child);
		}
		else
		{
			TailSegment_PrepareRotation(child);
		}
		TailSegment_BaseSwingProcessing(child);
		if (child.PositionSpeed < 1f)
		{
			child.ProceduralPosition = TailCalculations_SmoothPosition(child.PreviousPosition, child.ProceduralPosition, child);
		}
		if (MaxStretching < 1f)
		{
			StretchingLimiting(child);
		}
		if (!child.Gravity.VIsZero() || UseWind)
		{
			CalculateGravityPositionOffsetForSegment(child);
		}
		if (Axis2D > 0)
		{
			Axis2DLimit(child);
		}
		child.CollisionContactRelevancy = -1f;
		if (child.BlendValue * conditionalWeight < 1f)
		{
			child.ProceduralPositionWeightBlended = Vector3.LerpUnclamped(child.ParentBone.transform.TransformPoint(child.LastKeyframeLocalPosition), child.ProceduralPosition, child.BlendValue * conditionalWeight);
		}
		else
		{
			child.ProceduralPositionWeightBlended = child.ProceduralPosition;
		}
	}

	public void Editor_TailCalculations_RefreshArtificialParentBone()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		GhostParent.ProceduralPosition = GhostParent.transform.position + GhostParent.transform.rotation.TransformVector(GhostParent.transform.lossyScale, GhostParent.LocalOffset);
	}

	private void SimulateTailMotionFrame(bool pp)
	{
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		TailSegments_UpdateRootFeatures();
		TailSegments_UpdateCoordsForRootBone(_tc_rootBone);
		if (pp)
		{
			PostProcessing_ReferenceUpdate();
		}
		if (_tc_startI > -1)
		{
			TailSegment tailSegment = TailSegments[_tc_startI];
			if (!DetachChildren)
			{
				while (tailSegment != GhostChild)
				{
					tailSegment.BoneDimensionsScaled = Vector3.Scale(tailSegment.ParentBone.transform.lossyScale * tailSegment.LengthMultiplier, tailSegment.LastKeyframeLocalPosition);
					tailSegment.BoneLengthScaled = ((Vector3)(ref tailSegment.BoneDimensionsScaled)).magnitude;
					TailSegment_PrepareBoneLength(tailSegment);
					TailSegment_PrepareMotionParameters(tailSegment);
					TailSegment_PrepareVelocity(tailSegment);
					tailSegment = tailSegment.ChildBone;
				}
			}
			else
			{
				while (tailSegment != GhostChild)
				{
					tailSegment.BoneDimensionsScaled = Vector3.Scale(tailSegment.ParentBone.transform.lossyScale * tailSegment.LengthMultiplier, tailSegment.InitialLocalPosition);
					tailSegment.BoneLengthScaled = ((Vector3)(ref tailSegment.BoneDimensionsScaled)).magnitude;
					TailSegment_PrepareMotionParameters(tailSegment);
					TailSegment_PrepareVelocity(tailSegment);
					tailSegment = tailSegment.ChildBone;
				}
			}
		}
		TailSegment_PrepareBoneLength(GhostChild);
		TailSegment_PrepareMotionParameters(GhostChild);
		TailSegment_PrepareVelocity(GhostChild);
		if (_tc_startII > -1)
		{
			TailSegment tailSegment2 = TailSegments[_tc_startII];
			if (!DetachChildren)
			{
				while (tailSegment2 != GhostChild)
				{
					TailSegment_PrepareRotation(tailSegment2);
					TailSegment_BaseSwingProcessing(tailSegment2);
					TailCalculations_SegmentPreProcessingStack(tailSegment2);
					if (pp)
					{
						TailCalculations_SegmentPostProcessing(tailSegment2);
					}
					TailSegment_PreRotationPositionBlend(tailSegment2);
					tailSegment2 = tailSegment2.ChildBone;
				}
			}
			else
			{
				while (tailSegment2 != GhostChild)
				{
					TailSegment_PrepareRotationDetached(tailSegment2);
					TailSegment_BaseSwingProcessing(tailSegment2);
					TailCalculations_SegmentPreProcessingStack(tailSegment2);
					if (pp)
					{
						TailCalculations_SegmentPostProcessing(tailSegment2);
					}
					TailSegment_PreRotationPositionBlend(tailSegment2);
					tailSegment2 = tailSegment2.ChildBone;
				}
			}
		}
		TailCalculations_UpdateArtificialChildBone(GhostChild);
	}

	private void UpdateTailAlgorithm()
	{
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		TailCalculations_Begin();
		if (framesToSimulate != 0)
		{
			if (UseCollision)
			{
				BeginCollisionsUpdate();
			}
			bool pp = PostProcessingNeeded();
			MotionInfluenceLimiting();
			for (int i = 0; i < framesToSimulate; i++)
			{
				SimulateTailMotionFrame(pp);
			}
			TailSegments[_tc_startI].transform.position = TailSegments[_tc_startI].ProceduralPositionWeightBlended;
			TailSegments[_tc_startI].RefreshFinalPos(TailSegments[_tc_startI].ProceduralPositionWeightBlended);
			if (!DetachChildren)
			{
				if (_tc_startII > -1)
				{
					for (TailSegment tailSegment = TailSegments[_tc_startII]; tailSegment != GhostChild; tailSegment = tailSegment.ChildBone)
					{
						TailCalculations_SegmentRotation(tailSegment, tailSegment.LastKeyframeLocalPosition);
						TailCalculations_ApplySegmentMotion(tailSegment);
					}
				}
			}
			else if (_tc_startII > -1)
			{
				for (TailSegment tailSegment2 = TailSegments[_tc_startII]; tailSegment2 != GhostChild; tailSegment2 = tailSegment2.ChildBone)
				{
					TailCalculations_SegmentRotation(tailSegment2, tailSegment2.InitialLocalPosition);
					TailCalculations_ApplySegmentMotion(tailSegment2);
				}
			}
			TailCalculations_SegmentRotation(GhostChild, GhostChild.LastKeyframeLocalPosition);
			GhostChild.ParentBone.transform.rotation = GhostChild.ParentBone.TrueTargetRotation;
			GhostChild.ParentBone.RefreshFinalRot(GhostChild.ParentBone.TrueTargetRotation);
			if (Object.op_Implicit((Object)(object)GhostChild.transform))
			{
				GhostChild.RefreshFinalPos(GhostChild.transform.position);
				GhostChild.RefreshFinalRot(GhostChild.transform.rotation);
			}
		}
		else if (InterpolateRate)
		{
			secPeriodDelta = rateDelta / 24f;
			deltaForLerps = secPeriodDelta;
			SimulateTailMotionFrame(PostProcessingNeeded());
			if (_tc_startII > -1)
			{
				for (TailSegment tailSegment3 = TailSegments[_tc_startII]; tailSegment3 != GhostChild; tailSegment3 = tailSegment3.ChildBone)
				{
					TailCalculations_SegmentRotation(tailSegment3, tailSegment3.LastKeyframeLocalPosition);
					TailCalculations_ApplySegmentMotion(tailSegment3);
				}
			}
			TailCalculations_SegmentRotation(GhostChild, GhostChild.LastKeyframeLocalPosition);
			GhostChild.ParentBone.transform.rotation = GhostChild.ParentBone.TrueTargetRotation;
			GhostChild.ParentBone.RefreshFinalRot(GhostChild.ParentBone.TrueTargetRotation);
		}
		else if (_tc_startI > -1)
		{
			TailSegment tailSegment4 = TailSegments[_tc_startI];
			while (tailSegment4 != null && Object.op_Implicit((Object)(object)tailSegment4.transform))
			{
				tailSegment4.transform.position = tailSegment4.LastFinalPosition;
				tailSegment4.transform.rotation = tailSegment4.LastFinalRotation;
				tailSegment4 = tailSegment4.ChildBone;
			}
		}
	}

	private void CheckIfTailAnimatorShouldBeUpdated()
	{
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			if (StartAfterTPose)
			{
				startAfterTPoseCounter++;
				if (startAfterTPoseCounter > 6)
				{
					Init();
				}
			}
			updateTailAnimator = false;
			return;
		}
		if (UseMaxDistance)
		{
			MaxDistanceCalculations();
			conditionalWeight = OverrideWeight * distanceWeight;
		}
		else
		{
			conditionalWeight = OverrideWeight;
		}
		if (_forceDisable)
		{
			if (FadeDuration > 0f)
			{
				_forceDisableElapsed += Time.unscaledDeltaTime * (1f / FadeDuration);
				if (_forceDisableElapsed > 1f)
				{
					_forceDisableElapsed = 1f;
				}
			}
			else
			{
				_forceDisableElapsed = 1f;
			}
			conditionalWeight *= 1f - _forceDisableElapsed;
		}
		else if (_forceDisableElapsed > 0f && FadeDuration > 0f)
		{
			_forceDisableElapsed -= Time.unscaledDeltaTime * (1f / FadeDuration);
			if (_forceDisableElapsed < 0f)
			{
				_forceDisableElapsed = 0f;
			}
			conditionalWeight *= 1f - _forceDisableElapsed;
		}
		if (DisabledByInvisibility())
		{
			return;
		}
		if (UseCollision && !collisionInitialized)
		{
			SetupSphereColliders();
		}
		if (TailSegments.Count == 0)
		{
			Debug.LogError((object)("[TAIL ANIMATOR] No tail bones defined in " + ((Object)this).name + " !"));
			initialized = false;
			updateTailAnimator = false;
			return;
		}
		if (TailAnimatorAmount * conditionalWeight <= Mathf.Epsilon)
		{
			wasDisabled = true;
			updateTailAnimator = false;
			return;
		}
		if (wasDisabled)
		{
			User_ReposeTail();
			previousWorldPosition = ((Component)this).transform.position;
			wasDisabled = false;
		}
		if (IncludeParent && TailSegments.Count > 0 && !Object.op_Implicit((Object)(object)TailSegments[0].transform.parent))
		{
			IncludeParent = false;
		}
		if (TailSegments.Count < 1)
		{
			updateTailAnimator = false;
		}
		else
		{
			updateTailAnimator = true;
		}
	}

	public bool DisabledByInvisibility()
	{
		if ((Object)(object)OptimizeWithAnimator != (Object)null && !((Behaviour)OptimizeWithAnimator).enabled)
		{
			updateTailAnimator = false;
			return true;
		}
		return false;
	}

	private void DeltaTimeCalculations()
	{
		if (UpdateRate > 0)
		{
			switch (DeltaType)
			{
			case EFDeltaType.DeltaTime:
			case EFDeltaType.SafeDelta:
				justDelta = Time.deltaTime / Mathf.Clamp(Time.timeScale, 0.01f, 1f);
				break;
			case EFDeltaType.SmoothDeltaTime:
				justDelta = Time.smoothDeltaTime;
				break;
			case EFDeltaType.UnscaledDeltaTime:
				justDelta = Time.unscaledDeltaTime;
				break;
			case EFDeltaType.FixedDeltaTime:
				justDelta = Time.fixedDeltaTime;
				break;
			}
			justDelta *= TimeScale;
			secPeriodDelta = 1f;
			deltaForLerps = secPeriodDelta;
			rateDelta = 1f / (float)UpdateRate;
			StableUpdateRateCalculations();
			return;
		}
		switch (DeltaType)
		{
		case EFDeltaType.SafeDelta:
			justDelta = Mathf.Lerp(justDelta, GetClampedSmoothDelta(), 0.075f);
			break;
		case EFDeltaType.DeltaTime:
			justDelta = Time.deltaTime;
			break;
		case EFDeltaType.SmoothDeltaTime:
			justDelta = Time.smoothDeltaTime;
			break;
		case EFDeltaType.UnscaledDeltaTime:
			justDelta = Time.unscaledDeltaTime;
			break;
		case EFDeltaType.FixedDeltaTime:
			justDelta = Time.fixedDeltaTime;
			break;
		}
		rateDelta = justDelta;
		deltaForLerps = Mathf.Pow(secPeriodDelta, 0.1f) * 0.02f;
		justDelta *= TimeScale;
		secPeriodDelta = Mathf.Min(1f, justDelta * 60f);
		framesToSimulate = 1;
		previousframesToSimulate = 1;
	}

	private void StableUpdateRateCalculations()
	{
		previousframesToSimulate = framesToSimulate;
		collectedDelta += justDelta;
		framesToSimulate = 0;
		while (collectedDelta >= rateDelta)
		{
			collectedDelta -= rateDelta;
			framesToSimulate++;
			if (framesToSimulate >= 3)
			{
				collectedDelta = 0f;
				break;
			}
		}
	}

	private void PreCalibrateBones()
	{
		for (TailSegment tailSegment = TailSegments[0]; tailSegment != GhostChild; tailSegment = tailSegment.ChildBone)
		{
			tailSegment.PreCalibrate();
		}
	}

	private void CalibrateBones()
	{
		if (UseIK && IKBlend > 0f)
		{
			UpdateIK();
		}
		_limiting_stretchingHelperTooLong = Mathf.Lerp(0.4f, 0f, MaxStretching);
		_limiting_stretchingHelperTooShort = _limiting_stretchingHelperTooLong * 1.5f;
	}

	public void CheckForNullsInGhostChain()
	{
		if (_TransformsGhostChain == null)
		{
			_TransformsGhostChain = new List<Transform>();
		}
		for (int num = _TransformsGhostChain.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)_TransformsGhostChain[num] == (Object)null)
			{
				_TransformsGhostChain.RemoveAt(num);
			}
		}
	}

	private float GetClampedSmoothDelta()
	{
		return Mathf.Clamp(Time.smoothDeltaTime, 0f, 0.25f);
	}

	private Quaternion MultiplyQ(Quaternion rotation, float times)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.AngleAxis(rotation.x * 57.29578f * times, Vector3.right) * Quaternion.AngleAxis(rotation.z * 57.29578f * times, Vector3.forward) * Quaternion.AngleAxis(rotation.y * 57.29578f * times, Vector3.up);
	}

	public float GetValueFromCurve(int i, AnimationCurve c)
	{
		if (!initialized)
		{
			return c.Evaluate((float)i / (float)_TransformsGhostChain.Count);
		}
		return c.Evaluate(TailSegments[i].IndexOverlLength);
	}

	public AnimationCurve ClampCurve(AnimationCurve a, float timeStart, float timeEnd, float lowest, float highest)
	{
		Keyframe[] keys = a.keys;
		for (int i = 0; i < keys.Length; i++)
		{
			if (((Keyframe)(ref keys[i])).time < timeStart)
			{
				((Keyframe)(ref keys[i])).time = timeStart;
			}
			else if (((Keyframe)(ref keys[i])).time > timeEnd)
			{
				((Keyframe)(ref keys[i])).time = timeEnd;
			}
			if (((Keyframe)(ref keys[i])).value < lowest)
			{
				((Keyframe)(ref keys[i])).value = lowest;
			}
			else if (((Keyframe)(ref keys[i])).value > highest)
			{
				((Keyframe)(ref keys[i])).value = highest;
			}
		}
		a.keys = keys;
		return a;
	}

	public void RefreshTransformsList()
	{
		if (_TransformsGhostChain == null)
		{
			_TransformsGhostChain = new List<Transform>();
			return;
		}
		for (int num = _TransformsGhostChain.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)_TransformsGhostChain[0] == (Object)null)
			{
				_TransformsGhostChain.RemoveAt(num);
			}
		}
	}

	public TailSegment GetGhostChild()
	{
		return GhostChild;
	}

	private IEnumerator LateFixed()
	{
		lateFixedIsRunning = true;
		while (true)
		{
			yield return CoroutineEx.waitForFixedUpdate;
			PreCalibrateBones();
			fixedAllow = true;
		}
	}

	private void Deflection_BeginUpdate()
	{
		_defl_treshold = DeflectionStartAngle / 90f;
		float smoothTime = DeflectionSmooth / 9f;
		for (int i = _tc_startII; i < TailSegments.Count; i++)
		{
			TailSegment tailSegment = _pp_reference[i];
			if (!tailSegment.CheckDeflectionState(_defl_treshold, smoothTime, rateDelta))
			{
				bool flag = true;
				if (DeflectOnlyCollisions && tailSegment.CollisionContactRelevancy <= 0f)
				{
					flag = false;
				}
				if (flag)
				{
					Deflection_AddDeflectionSource(tailSegment);
				}
				else
				{
					Deflection_RemoveDeflectionSource(tailSegment);
				}
			}
			else
			{
				Deflection_RemoveDeflectionSource(tailSegment);
			}
		}
	}

	private void Deflection_RemoveDeflectionSource(TailSegment child)
	{
		if (!child.DeflectionRestoreState().HasValue && _defl_source.Contains(child))
		{
			_defl_source.Remove(child);
		}
	}

	private void Deflection_AddDeflectionSource(TailSegment child)
	{
		if (child.DeflectionRelevant() && !_defl_source.Contains(child))
		{
			_defl_source.Add(child);
		}
	}

	private void Deflection_SegmentOffsetSimple(TailSegment child, ref Vector3 position)
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		if (child.Index == _tc_startI)
		{
			return;
		}
		float num = 0f;
		for (int i = 0; i < _defl_source.Count; i++)
		{
			if (child.Index <= _defl_source[i].Index && child.Index != _defl_source[i].Index && !(_defl_source[i].DeflectionFactor < num))
			{
				num = _defl_source[i].DeflectionFactor;
				float num2 = 0f;
				if (i > 0)
				{
					num2 = _defl_source[i].Index;
				}
				float num3 = Mathf.InverseLerp(num2, (float)_defl_source[i].Index, (float)child.Index);
				Vector3 val = _defl_source[i].DeflectionWorldPosition - child.ParentBone.ProceduralPosition;
				Vector3 proceduralPosition = child.ParentBone.ProceduralPosition;
				proceduralPosition += ((Vector3)(ref val)).normalized * child.BoneLengthScaled;
				child.ProceduralPosition = Vector3.LerpUnclamped(child.ProceduralPosition, proceduralPosition, Deflection * DeflectionFalloff.Evaluate(num3) * _defl_source[i].DeflectionSmooth);
			}
		}
	}

	public void User_SetTailTransforms(List<Transform> list)
	{
		StartBone = list[0];
		EndBone = list[list.Count - 1];
		_TransformsGhostChain = list;
		StartAfterTPose = false;
		initialized = false;
		Init();
	}

	public TailSegment User_AddTailTransform(Transform transform)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		TailSegment tailSegment = new TailSegment(transform);
		TailSegment tailSegment2 = TailSegments[TailSegments.Count - 1];
		tailSegment.ParamsFromAll(tailSegment2);
		tailSegment.RefreshFinalPos(tailSegment.transform.position);
		tailSegment.RefreshFinalRot(tailSegment.transform.rotation);
		tailSegment.ProceduralPosition = tailSegment.transform.position;
		tailSegment.PosRefRotation = tailSegment.transform.rotation;
		_TransformsGhostChain.Add(transform);
		TailSegments.Add(tailSegment);
		tailSegment2.SetChildRef(tailSegment);
		tailSegment.SetParentRef(tailSegment2);
		tailSegment.SetChildRef(GhostChild);
		GhostChild.SetParentRef(tailSegment);
		for (int i = 0; i < TailSegments.Count; i++)
		{
			TailSegments[i].SetIndex(i, TailSegments.Count);
		}
		return tailSegment;
	}

	public void User_CutEndSegmentsTo(int fromLastTo)
	{
		if (fromLastTo < TailSegments.Count)
		{
			GhostChild = TailSegments[fromLastTo];
			GhostChild.SetChildRef(null);
			for (int num = TailSegments.Count - 1; num >= fromLastTo; num--)
			{
				TailSegments.RemoveAt(num);
				_TransformsGhostChain.RemoveAt(num);
			}
		}
		else
		{
			Debug.Log((object)("[Tail Animator Cutting] Wrong index, you want cut from end to " + fromLastTo + " segment but there are only " + TailSegments.Count + " segments!"));
		}
	}

	public void User_ReposeTail()
	{
		GhostParent.Reset();
		for (int i = 0; i < TailSegments.Count; i++)
		{
			TailSegments[i].Reset();
		}
		GhostChild.Reset();
	}

	public void User_ForceDisabled(bool disable)
	{
		_forceDisable = disable;
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private void OnValidate()
	{
		if (UpdateRate < 0)
		{
			UpdateRate = 0;
		}
		if (Application.isPlaying)
		{
			RefreshSegmentsColliders();
			if (UseIK)
			{
				IK_ApplyLimitBoneSettings();
			}
		}
		if (UsePartialBlend)
		{
			ClampCurve(BlendCurve, 0f, 1f, 0f, 1f);
		}
	}

	public void GetGhostChain()
	{
		if (_TransformsGhostChain == null)
		{
			_TransformsGhostChain = new List<Transform>();
		}
		if ((Object)(object)EndBone == (Object)null)
		{
			_TransformsGhostChain.Clear();
			Transform val = StartBone;
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).transform;
			}
			_TransformsGhostChain.Add(val);
			while (val.childCount > 0)
			{
				val = val.GetChild(0);
				if (!_TransformsGhostChain.Contains(val))
				{
					_TransformsGhostChain.Add(val);
				}
			}
			_GhostChainInitCount = _TransformsGhostChain.Count;
			return;
		}
		List<Transform> list = new List<Transform>();
		Transform val2 = StartBone;
		if ((Object)(object)val2 == (Object)null)
		{
			val2 = ((Component)this).transform;
		}
		Transform val3 = EndBone;
		list.Add(val3);
		while ((Object)(object)val3 != (Object)null && (Object)(object)val3 != (Object)(object)StartBone)
		{
			val3 = val3.parent;
			if (!list.Contains(val3))
			{
				list.Add(val3);
			}
		}
		if ((Object)(object)val3 == (Object)null)
		{
			Debug.Log((object)("[Tail Animator Editor] " + ((Object)EndBone).name + " is not child of " + ((Object)val2).name + "!"));
			Debug.LogError((object)("[Tail Animator Editor] " + ((Object)EndBone).name + " is not child of " + ((Object)val2).name + "!"));
		}
		else
		{
			if (!list.Contains(val3))
			{
				list.Add(val3);
			}
			_TransformsGhostChain.Clear();
			_TransformsGhostChain = list;
			_TransformsGhostChain.Reverse();
			_GhostChainInitCount = _TransformsGhostChain.Count;
		}
	}

	private void Start()
	{
		if (UpdateAsLast)
		{
			((Behaviour)this).enabled = false;
			((Behaviour)this).enabled = true;
		}
		if (StartAfterTPose)
		{
			startAfterTPoseCounter = 6;
		}
		else
		{
			Init();
		}
	}

	private void Reset()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Expected O, but got Unknown
		Keyframe val = default(Keyframe);
		((Keyframe)(ref val))..ctor(0f, 0f, 0.1f, 0.1f, 0f, 0.5f);
		Keyframe val2 = default(Keyframe);
		((Keyframe)(ref val2))..ctor(1f, 1f, 5f, 0f, 0.1f, 0f);
		DeflectionFalloff = new AnimationCurve((Keyframe[])(object)new Keyframe[2] { val, val2 });
	}

	private void Tick()
	{
		TimeWarning val = TimeWarning.New("TailAnimator2:Tick", 0);
		try
		{
			CheckIfTailAnimatorShouldBeUpdated();
			DeltaTimeCalculations();
			if (UseWind)
			{
				WindEffectUpdate();
			}
			if (AnimatePhysics != 0 || !updateTailAnimator)
			{
				return;
			}
			if (DetachChildren)
			{
				if (_tc_rootBone != null && Object.op_Implicit((Object)(object)_tc_rootBone.transform))
				{
					_tc_rootBone.PreCalibrate();
				}
			}
			else if (OverrideKeyframeAnimation < 1f)
			{
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FixedTick()
	{
		TimeWarning val = TimeWarning.New("TailAnimator2:FixedTick", 0);
		try
		{
			if (AnimatePhysics != EFixedMode.Basic || !updateTailAnimator)
			{
				return;
			}
			if (DetachChildren)
			{
				if (_tc_rootBone != null && Object.op_Implicit((Object)(object)_tc_rootBone.transform))
				{
					_tc_rootBone.PreCalibrate();
				}
			}
			else
			{
				fixedUpdated = true;
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LateTick()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TailAnimator2:LateTick", 0);
		try
		{
			if (!updateTailAnimator)
			{
				return;
			}
			if (AnimatePhysics == EFixedMode.Late)
			{
				if (!lateFixedIsRunning)
				{
					((MonoBehaviour)this).StartCoroutine(LateFixed());
				}
				if (!fixedAllow)
				{
					return;
				}
				fixedAllow = false;
			}
			else
			{
				if (lateFixedIsRunning)
				{
					((MonoBehaviour)this).StopCoroutine(LateFixed());
					lateFixedIsRunning = false;
				}
				if (AnimatePhysics == EFixedMode.Basic)
				{
					if (!fixedUpdated)
					{
						return;
					}
					fixedUpdated = false;
				}
			}
			if (DetachChildren)
			{
				TailSegment tailSegment = TailSegments[0];
				TailSegments[0].RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
				TailSegments[0].PreCalibrate();
				tailSegment = TailSegments[1];
				if (!IncludeParent)
				{
					tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
					tailSegment.PreCalibrate();
					tailSegment = TailSegments[2];
				}
				while (tailSegment != GhostChild)
				{
					tailSegment.RefreshKeyLocalPositionAndRotation(tailSegment.InitialLocalPosition, tailSegment.InitialLocalRotation);
					tailSegment.transform.position = _baseTransform.TransformPoint(tailSegment.InitialLocalPositionInRoot);
					tailSegment.transform.rotation = _baseTransform.rotation.QToWorld(tailSegment.InitialLocalRotationInRoot);
					tailSegment = tailSegment.ChildBone;
				}
			}
			else if (OverrideKeyframeAnimation > 0f)
			{
				if (OverrideKeyframeAnimation >= 1f)
				{
					PreCalibrateBones();
					for (TailSegment tailSegment2 = TailSegments[0]; tailSegment2 != GhostChild; tailSegment2 = tailSegment2.ChildBone)
					{
						tailSegment2.RefreshKeyLocalPositionAndRotation();
					}
				}
				else
				{
					for (TailSegment tailSegment3 = TailSegments[0]; tailSegment3 != GhostChild; tailSegment3 = tailSegment3.ChildBone)
					{
						tailSegment3.transform.localPosition = Vector3.LerpUnclamped(tailSegment3.transform.localPosition, tailSegment3.InitialLocalPosition, OverrideKeyframeAnimation);
						tailSegment3.transform.localRotation = Quaternion.LerpUnclamped(tailSegment3.transform.localRotation, tailSegment3.InitialLocalRotation, OverrideKeyframeAnimation);
						tailSegment3.RefreshKeyLocalPositionAndRotation();
					}
				}
			}
			else
			{
				for (TailSegment tailSegment4 = TailSegments[0]; tailSegment4 != GhostChild; tailSegment4 = tailSegment4.ChildBone)
				{
					tailSegment4.RefreshKeyLocalPositionAndRotation();
				}
			}
			ExpertParamsUpdate();
			ShapingParamsUpdate();
			CalibrateBones();
			UpdateTailAlgorithm();
			EndUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void EndUpdate()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ShapingEndUpdate();
		ExpertCurvesEndUpdate();
		previousWorldPosition = BaseTransform.position;
	}
}


using System;
using UnityEngine;

[Serializable]
public class TailSegment
{
	public Vector3 ProceduralPosition = Vector3.zero;

	public Vector3 ProceduralPositionWeightBlended = Vector3.zero;

	public Quaternion TrueTargetRotation = Quaternion.identity;

	public Quaternion PosRefRotation = Quaternion.identity;

	public Quaternion PreviousPosReferenceRotation = Quaternion.identity;

	public Vector3 PreviousPosition;

	public float BlendValue = 1f;

	public Vector3 BoneDimensionsScaled;

	public float BoneLengthScaled;

	public Vector3 InitialLocalPosition = Vector3.zero;

	public Vector3 InitialLocalPositionInRoot = Vector3.zero;

	public Quaternion InitialLocalRotationInRoot = Quaternion.identity;

	public Vector3 LocalOffset = Vector3.zero;

	public Quaternion InitialLocalRotation = Quaternion.identity;

	public float ColliderRadius = 1f;

	public bool CollisionContactFlag;

	public float CollisionContactRelevancy = -1f;

	public Collision collisionContacts;

	public Vector3 VelocityHelper = Vector3.zero;

	public Quaternion QVelocityHelper = Quaternion.identity;

	public Vector3 PreviousPush = Vector3.zero;

	public Quaternion Curving = Quaternion.identity;

	public Vector3 Gravity = Vector3.zero;

	public Vector3 GravityLookOffset = Vector3.zero;

	public float LengthMultiplier = 1f;

	public float PositionSpeed = 1f;

	public float RotationSpeed = 1f;

	public float Springiness;

	public float Slithery = 1f;

	public float Curling = 0.5f;

	public float Slippery = 1f;

	public Quaternion LastKeyframeLocalRotation;

	public Vector3 LastKeyframeLocalPosition;

	private float deflectionSmoothVelo;

	public TailSegment ParentBone { get; private set; }

	public TailSegment ChildBone { get; private set; }

	public Transform transform { get; private set; }

	public int Index { get; private set; }

	public float IndexOverlLength { get; private set; }

	public float BoneLength { get; private set; }

	public TailCollisionHelper CollisionHelper { get; internal set; }

	public bool IsDetachable { get; private set; }

	public Vector3 LastFinalPosition { get; private set; }

	public Quaternion LastFinalRotation { get; private set; }

	public float DeflectionFactor { get; private set; }

	public Vector3 Deflection { get; private set; }

	public float DeflectionSmooth { get; private set; }

	public Vector3 DeflectionWorldPosition { get; private set; }

	public int DeflectionRelevancy { get; private set; }

	public FImp_ColliderData_Base LatestSelectiveCollision { get; internal set; }

	public TailSegment()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		Index = -1;
		Curving = Quaternion.identity;
		Gravity = Vector3.zero;
		LengthMultiplier = 1f;
		Deflection = Vector3.zero;
		DeflectionFactor = 0f;
		DeflectionRelevancy = -1;
		deflectionSmoothVelo = 0f;
	}

	public TailSegment(Transform transform)
		: this()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)transform == (Object)null))
		{
			this.transform = transform;
			ProceduralPosition = transform.position;
			PreviousPosition = transform.position;
			PosRefRotation = transform.rotation;
			PreviousPosReferenceRotation = PosRefRotation;
			TrueTargetRotation = PosRefRotation;
			ReInitializeLocalPosRot(transform.localPosition, transform.localRotation);
			BoneLength = 0.1f;
		}
	}

	public TailSegment(TailSegment copyFrom)
		: this(copyFrom.transform)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		transform = copyFrom.transform;
		Index = copyFrom.Index;
		IndexOverlLength = copyFrom.IndexOverlLength;
		ProceduralPosition = copyFrom.ProceduralPosition;
		PreviousPosition = copyFrom.PreviousPosition;
		ProceduralPositionWeightBlended = copyFrom.ProceduralPosition;
		PosRefRotation = copyFrom.PosRefRotation;
		PreviousPosReferenceRotation = PosRefRotation;
		TrueTargetRotation = copyFrom.TrueTargetRotation;
		ReInitializeLocalPosRot(copyFrom.InitialLocalPosition, copyFrom.InitialLocalRotation);
	}

	public void ReInitializeLocalPosRot(Vector3 initLocalPos, Quaternion initLocalRot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		InitialLocalPosition = initLocalPos;
		InitialLocalRotation = initLocalRot;
	}

	public void SetIndex(int i, int tailSegments)
	{
		Index = i;
		if (i < 0)
		{
			IndexOverlLength = 0f;
		}
		else
		{
			IndexOverlLength = (float)i / (float)tailSegments;
		}
	}

	public void SetParentRef(TailSegment parent)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		ParentBone = parent;
		Vector3 val = ProceduralPosition - ParentBone.ProceduralPosition;
		BoneLength = ((Vector3)(ref val)).magnitude;
	}

	public void SetChildRef(TailSegment child)
	{
		ChildBone = child;
	}

	public float GetRadiusScaled()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return ColliderRadius * transform.lossyScale.x;
	}

	public void AssignDetachedRootCoords(Transform root)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		InitialLocalPositionInRoot = root.InverseTransformPoint(transform.position);
		InitialLocalRotationInRoot = root.rotation.QToLocal(transform.rotation);
		IsDetachable = true;
	}

	internal Vector3 BlendMotionWeight(Vector3 newPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.LerpUnclamped(ParentBone.ProceduralPosition + ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition), newPosition, BlendValue);
	}

	internal void PreCalibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		transform.localPosition = InitialLocalPosition;
		transform.localRotation = InitialLocalRotation;
	}

	internal void Validate()
	{
		if (BoneLength == 0f)
		{
			BoneLength = 0.001f;
		}
	}

	public void RefreshKeyLocalPosition()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)transform))
		{
			LastKeyframeLocalRotation = transform.localRotation;
		}
		else
		{
			LastKeyframeLocalRotation = InitialLocalRotation;
		}
	}

	public void RefreshKeyLocalPositionAndRotation()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)transform))
		{
			RefreshKeyLocalPositionAndRotation(transform.localPosition, transform.localRotation);
		}
		else
		{
			RefreshKeyLocalPositionAndRotation(InitialLocalPosition, InitialLocalRotation);
		}
	}

	public void RefreshKeyLocalPositionAndRotation(Vector3 p, Quaternion r)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframeLocalPosition = p;
		LastKeyframeLocalRotation = r;
	}

	internal Vector3 ParentToFrontOffset()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return ParentBone.LastKeyframeLocalRotation.TransformVector(ParentBone.transform.lossyScale, LastKeyframeLocalPosition);
	}

	public void RefreshFinalPos(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		LastFinalPosition = pos;
	}

	public void RefreshFinalRot(Quaternion rot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		LastFinalRotation = rot;
	}

	public bool CheckDeflectionState(float zeroWhenLower, float smoothTime, float delta)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = LastKeyframeLocalPosition - ParentBone.transform.InverseTransformVector(ProceduralPosition - ParentBone.ProceduralPosition);
		DeflectionFactor = Vector3.Dot(((Vector3)(ref LastKeyframeLocalPosition)).normalized, ((Vector3)(ref val)).normalized);
		if (DeflectionFactor < zeroWhenLower)
		{
			if (smoothTime <= Mathf.Epsilon)
			{
				DeflectionSmooth = 0f;
			}
			else
			{
				DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 0f - Mathf.Epsilon, ref deflectionSmoothVelo, smoothTime / 1.5f, float.PositiveInfinity, delta);
			}
		}
		else if (smoothTime <= Mathf.Epsilon)
		{
			DeflectionSmooth = 1f;
		}
		else
		{
			DeflectionSmooth = Mathf.SmoothDamp(DeflectionSmooth, 1f, ref deflectionSmoothVelo, smoothTime, float.PositiveInfinity, delta);
		}
		if (DeflectionSmooth <= Mathf.Epsilon)
		{
			return true;
		}
		if (ChildBone.ChildBone != null)
		{
			DeflectionWorldPosition = ChildBone.ChildBone.ProceduralPosition;
		}
		else
		{
			DeflectionWorldPosition = ChildBone.ProceduralPosition;
		}
		return false;
	}

	public bool DeflectionRelevant()
	{
		if (DeflectionRelevancy == -1)
		{
			DeflectionRelevancy = 3;
			return true;
		}
		DeflectionRelevancy = 3;
		return false;
	}

	public bool? DeflectionRestoreState()
	{
		if (DeflectionRelevancy > 0)
		{
			DeflectionRelevancy--;
			if (DeflectionRelevancy == 0)
			{
				DeflectionRelevancy = -1;
				return null;
			}
			return true;
		}
		return false;
	}

	internal void ParamsFrom(TailSegment other)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		BlendValue = other.BlendValue;
		ColliderRadius = other.ColliderRadius;
		Gravity = other.Gravity;
		LengthMultiplier = other.LengthMultiplier;
		BoneLength = other.BoneLength;
		BoneLengthScaled = other.BoneLengthScaled;
		BoneDimensionsScaled = other.BoneDimensionsScaled;
		collisionContacts = other.collisionContacts;
		CollisionHelper = other.CollisionHelper;
		PositionSpeed = other.PositionSpeed;
		RotationSpeed = other.RotationSpeed;
		Springiness = other.Springiness;
		Slithery = other.Slithery;
		Curling = other.Curling;
		Slippery = other.Slippery;
	}

	internal void ParamsFromAll(TailSegment other)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		ParamsFrom(other);
		InitialLocalPosition = other.InitialLocalPosition;
		InitialLocalRotation = other.InitialLocalRotation;
		LastFinalPosition = other.LastFinalPosition;
		LastFinalRotation = other.LastFinalRotation;
		ProceduralPosition = other.ProceduralPosition;
		ProceduralPositionWeightBlended = other.ProceduralPositionWeightBlended;
		TrueTargetRotation = other.TrueTargetRotation;
		PosRefRotation = other.PosRefRotation;
		PreviousPosReferenceRotation = other.PreviousPosReferenceRotation;
		PreviousPosition = other.PreviousPosition;
		BoneLength = other.BoneLength;
		BoneDimensionsScaled = other.BoneDimensionsScaled;
		BoneLengthScaled = other.BoneLengthScaled;
		LocalOffset = other.LocalOffset;
		ColliderRadius = other.ColliderRadius;
		VelocityHelper = other.VelocityHelper;
		QVelocityHelper = other.QVelocityHelper;
		PreviousPush = other.PreviousPush;
	}

	internal void User_ReassignTransform(Transform t)
	{
		transform = t;
	}

	public void Reset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		PreviousPush = Vector3.zero;
		VelocityHelper = Vector3.zero;
		QVelocityHelper = Quaternion.identity;
		if (Object.op_Implicit((Object)(object)transform))
		{
			ProceduralPosition = transform.position;
			PosRefRotation = transform.rotation;
			PreviousPosReferenceRotation = transform.rotation;
		}
		else if (Object.op_Implicit((Object)(object)ParentBone.transform))
		{
			ProceduralPosition = ParentBone.transform.position + ParentToFrontOffset();
		}
		PreviousPosition = ProceduralPosition;
		ProceduralPositionWeightBlended = ProceduralPosition;
	}
}


public enum ECollisionSpace
{
	World_Slow,
	Selective_Fast
}


public enum ECollisionMode
{
	m_3DCollision,
	m_2DCollision
}


using System;
using UnityEngine;

[Serializable]
public class IKBoneSettings
{
	[Range(0f, 181f)]
	public float AngleLimit = 45f;

	[Range(0f, 181f)]
	public float TwistAngleLimit = 5f;

	public bool UseInChain = true;
}


public enum FEWavingType
{
	Simple,
	Advanced
}


public enum EFDeltaType
{
	DeltaTime,
	SmoothDeltaTime,
	UnscaledDeltaTime,
	FixedDeltaTime,
	SafeDelta
}


public enum EAnimationStyle
{
	Quick,
	Accelerating,
	Linear
}


public enum ETailCategory
{
	Setup,
	Tweak,
	Features,
	Shaping
}


public enum ETailFeaturesCategory
{
	Main,
	Collisions,
	IK,
	Experimental
}


public enum EFixedMode
{
	None,
	Basic,
	Late
}


using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FTail;
using UnityEngine;

public static class FTail_Skinning
{
	public static FTail_SkinningVertexData[] CalculateVertexWeightingData(Mesh baseMesh, Transform[] bonesCoords, Vector3 spreadOffset, int weightBoneLimit = 2, float spreadValue = 0.8f, float spreadPower = 0.185f)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[bonesCoords.Length];
		Quaternion[] array2 = (Quaternion[])(object)new Quaternion[bonesCoords.Length];
		for (int i = 0; i < bonesCoords.Length; i++)
		{
			array[i] = bonesCoords[0].parent.InverseTransformPoint(bonesCoords[i].position);
			array2[i] = bonesCoords[0].parent.rotation.QToLocal(bonesCoords[i].rotation);
		}
		return CalculateVertexWeightingData(baseMesh, array, array2, spreadOffset, weightBoneLimit, spreadValue, spreadPower);
	}

	public static FTail_SkinningVertexData[] CalculateVertexWeightingData(Mesh baseMesh, Vector3[] bonesPos, Quaternion[] bonesRot, Vector3 spreadOffset, int weightBoneLimit = 2, float spreadValue = 0.8f, float spreadPower = 0.185f)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (weightBoneLimit < 1)
		{
			weightBoneLimit = 1;
		}
		if (weightBoneLimit > 2)
		{
			weightBoneLimit = 2;
		}
		int vertexCount = baseMesh.vertexCount;
		FTail_SkinningVertexData[] array = new FTail_SkinningVertexData[vertexCount];
		Vector3[] array2 = (Vector3[])(object)new Vector3[bonesPos.Length];
		for (int i = 0; i < bonesPos.Length - 1; i++)
		{
			array2[i] = bonesPos[i + 1] - bonesPos[i];
		}
		if (array2.Length > 1)
		{
			array2[^1] = array2[^2];
		}
		for (int j = 0; j < vertexCount; j++)
		{
			array[j] = new FTail_SkinningVertexData(baseMesh.vertices[j]);
			array[j].CalculateVertexParameters(bonesPos, bonesRot, array2, weightBoneLimit, spreadValue, spreadOffset, spreadPower);
		}
		return array;
	}

	public static SkinnedMeshRenderer SkinMesh(Mesh baseMesh, Transform skinParent, Transform[] bonesStructure, FTail_SkinningVertexData[] vertData)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[bonesStructure.Length];
		Quaternion[] array2 = (Quaternion[])(object)new Quaternion[bonesStructure.Length];
		for (int i = 0; i < bonesStructure.Length; i++)
		{
			array[i] = skinParent.InverseTransformPoint(bonesStructure[i].position);
			array2[i] = skinParent.rotation.QToLocal(bonesStructure[i].rotation);
		}
		return SkinMesh(baseMesh, array, array2, vertData);
	}

	public static SkinnedMeshRenderer SkinMesh(Mesh baseMesh, Vector3[] bonesPositions, Quaternion[] bonesRotations, FTail_SkinningVertexData[] vertData)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		if (bonesPositions == null)
		{
			return null;
		}
		if (bonesRotations == null)
		{
			return null;
		}
		if ((Object)(object)baseMesh == (Object)null)
		{
			return null;
		}
		if (vertData == null)
		{
			return null;
		}
		Mesh val = Object.Instantiate<Mesh>(baseMesh);
		((Object)val).name = ((Object)baseMesh).name + " [FSKINNED]";
		Transform transform = new GameObject(((Object)baseMesh).name + " [FSKINNED]").transform;
		SkinnedMeshRenderer val2 = ((Component)transform).gameObject.AddComponent<SkinnedMeshRenderer>();
		Transform[] array = (Transform[])(object)new Transform[bonesPositions.Length];
		Matrix4x4[] array2 = (Matrix4x4[])(object)new Matrix4x4[bonesPositions.Length];
		string text = ((((Object)baseMesh).name.Length >= 6) ? ((Object)baseMesh).name.Substring(0, 5) : ((Object)baseMesh).name);
		for (int i = 0; i < bonesPositions.Length; i++)
		{
			array[i] = new GameObject("BoneF-" + text + "[" + i + "]").transform;
			if (i == 0)
			{
				array[i].SetParent(transform, true);
			}
			else
			{
				array[i].SetParent(array[i - 1], true);
			}
			((Component)array[i]).transform.position = bonesPositions[i];
			((Component)array[i]).transform.rotation = bonesRotations[i];
			array2[i] = array[i].worldToLocalMatrix * transform.localToWorldMatrix;
		}
		BoneWeight[] array3 = (BoneWeight[])(object)new BoneWeight[val.vertexCount];
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j] = default(BoneWeight);
		}
		for (int k = 0; k < vertData.Length; k++)
		{
			for (int l = 0; l < vertData[k].weights.Length; l++)
			{
				array3[k] = SetWeightIndex(array3[k], l, vertData[k].bonesIndexes[l]);
				array3[k] = SetWeightToBone(array3[k], l, vertData[k].weights[l]);
			}
		}
		val.bindposes = array2;
		val.boneWeights = array3;
		List<Vector3> list = new List<Vector3>();
		List<Vector4> list2 = new List<Vector4>();
		baseMesh.GetNormals(list);
		baseMesh.GetTangents(list2);
		val.SetNormals(list);
		val.SetTangents(list2);
		val.bounds = baseMesh.bounds;
		val2.sharedMesh = val;
		val2.rootBone = array[0];
		val2.bones = array;
		return val2;
	}

	public static BoneWeight SetWeightIndex(BoneWeight weight, int bone = 0, int index = 0)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		switch (bone)
		{
		case 1:
			((BoneWeight)(ref weight)).boneIndex1 = index;
			break;
		case 2:
			((BoneWeight)(ref weight)).boneIndex2 = index;
			break;
		case 3:
			((BoneWeight)(ref weight)).boneIndex3 = index;
			break;
		default:
			((BoneWeight)(ref weight)).boneIndex0 = index;
			break;
		}
		return weight;
	}

	public static BoneWeight SetWeightToBone(BoneWeight weight, int bone = 0, float value = 1f)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		switch (bone)
		{
		case 1:
			((BoneWeight)(ref weight)).weight1 = value;
			break;
		case 2:
			((BoneWeight)(ref weight)).weight2 = value;
			break;
		case 3:
			((BoneWeight)(ref weight)).weight3 = value;
			break;
		default:
			((BoneWeight)(ref weight)).weight0 = value;
			break;
		}
		return weight;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FTail_SkinningVertexData
{
	public Vector3 position;

	public int[] bonesIndexes;

	public int allMeshBonesCount;

	public float[] weights;

	public float[] debugDists;

	public float[] debugDistWeights;

	public float[] debugWeights;

	public FTail_SkinningVertexData(Vector3 pos)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		position = pos;
	}

	public float DistanceToLine(Vector3 pos, Vector3 lineStart, Vector3 lineEnd)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - lineStart;
		Vector3 val2 = lineEnd - lineStart;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		float num = Vector3.Distance(lineStart, lineEnd);
		float num2 = Vector3.Dot(normalized, val);
		if (num2 <= 0f)
		{
			return Vector3.Distance(pos, lineStart);
		}
		if (num2 >= num)
		{
			return Vector3.Distance(pos, lineEnd);
		}
		Vector3 val3 = normalized * num2;
		Vector3 val4 = lineStart + val3;
		return Vector3.Distance(pos, val4);
	}

	public void CalculateVertexParameters(Vector3[] bonesPos, Quaternion[] bonesRot, Vector3[] boneAreas, int maxWeightedBones, float spread, Vector3 spreadOffset, float spreadPower = 1f)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		allMeshBonesCount = bonesPos.Length;
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < bonesPos.Length; i++)
		{
			Vector3 val = ((i == bonesPos.Length - 1) ? Vector3.Lerp(bonesPos[i], bonesPos[i] + (bonesPos[i] - bonesPos[i - 1]), 0.9f) : Vector3.Lerp(bonesPos[i], bonesPos[i + 1], 0.9f));
			val += bonesRot[i] * spreadOffset;
			float num = DistanceToLine(position, bonesPos[i], val);
			list.Add(new Vector2((float)i, num));
		}
		list.Sort((Vector2 a, Vector2 b) => a.y.CompareTo(b.y));
		int num2 = Mathf.Min(maxWeightedBones, bonesPos.Length);
		bonesIndexes = new int[num2];
		float[] array = new float[num2];
		for (int j = 0; j < num2; j++)
		{
			bonesIndexes[j] = (int)list[j].x;
			array[j] = list[j].y;
		}
		float[] array2 = new float[num2];
		AutoSetBoneWeights(array2, array, spread, spreadPower, boneAreas);
		float num3 = 1f;
		weights = new float[num2];
		for (int k = 0; k < num2 && (spread != 0f || k <= 0); k++)
		{
			if (num3 <= 0f)
			{
				weights[k] = 0f;
				continue;
			}
			float num4 = array2[k];
			num3 -= num4;
			if (num3 <= 0f)
			{
				num4 += num3;
			}
			else if (k == num2 - 1)
			{
				num4 += num3;
			}
			weights[k] = num4;
		}
	}

	public void AutoSetBoneWeights(float[] weightForBone, float[] distToBone, float spread, float spreadPower, Vector3[] boneAreas)
	{
		int num = weightForBone.Length;
		float[] array = new float[num];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = ((Vector3)(ref boneAreas[i])).magnitude;
		}
		float[] array2 = new float[num];
		for (int j = 0; j < weightForBone.Length; j++)
		{
			weightForBone[j] = 0f;
		}
		float num2 = 0f;
		for (int k = 0; k < num; k++)
		{
			num2 += distToBone[k];
		}
		for (int l = 0; l < num; l++)
		{
			array2[l] = 1f - distToBone[l] / num2;
		}
		debugDists = distToBone;
		if (num == 1 || spread == 0f)
		{
			weightForBone[0] = 1f;
			return;
		}
		if (num == 2)
		{
			float num3 = 1f;
			weightForBone[0] = 1f;
			float num4 = Mathf.InverseLerp(distToBone[0] + array[0] / 1.25f * spread, distToBone[0], distToBone[1]);
			debugDists[0] = num4;
			num3 += (weightForBone[1] = DistributionIn(Mathf.Lerp(0f, 1f, num4), Mathf.Lerp(1.5f, 16f, spreadPower)));
			debugDistWeights = new float[weightForBone.Length];
			weightForBone.CopyTo(debugDistWeights, 0);
			for (int m = 0; m < num; m++)
			{
				weightForBone[m] /= num3;
			}
			debugWeights = weightForBone;
			return;
		}
		float num5 = array[0] / 10f;
		float num6 = array[0] / 2f;
		float num7 = 0f;
		for (int n = 0; n < num; n++)
		{
			float num8 = Mathf.InverseLerp(0f, num5 + num6 * spread, distToBone[n]);
			float num9 = Mathf.Lerp(1f, 0f, num8);
			if (n == 0 && num9 == 0f)
			{
				num9 = 1f;
			}
			weightForBone[n] = num9;
			num7 += num9;
		}
		debugDistWeights = new float[weightForBone.Length];
		weightForBone.CopyTo(debugDistWeights, 0);
		for (int num10 = 0; num10 < num; num10++)
		{
			weightForBone[num10] /= num7;
		}
		debugWeights = weightForBone;
	}

	public static float DistributionIn(float k, float power)
	{
		return Mathf.Pow(k, power + 1f);
	}

	public static Color GetBoneIndicatorColor(int boneIndex, int bonesCount, float s = 0.9f, float v = 0.9f)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Color.HSVToRGB(((float)boneIndex * 1.125f / (float)bonesCount + 0.125f * (float)boneIndex + 0.3f) % 1f, s, v);
	}

	public Color GetWeightColor()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		Color val = GetBoneIndicatorColor(bonesIndexes[0], allMeshBonesCount, 1f, 1f);
		for (int i = 1; i < bonesIndexes.Length; i++)
		{
			val = Color.Lerp(val, GetBoneIndicatorColor(bonesIndexes[i], allMeshBonesCount, 1f, 1f), weights[i]);
		}
		return val;
	}
}


using FIMSpace;
using FIMSpace.FTail;
using UnityEngine;
using UnityEngine.EventSystems;

[AddComponentMenu("FImpossible Creations/Tail Animator Utilities/Tail Animator Wind")]
public class TailAnimatorWind : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon
{
	[Header("In playmode you will find this object in DontDestroyOnLoad")]
	[FPD_Header("Main Wind Setings", 2f, 4f, 2)]
	public float power = 1f;

	public float additionalTurbulence = 1f;

	public float additionalTurbSpeed = 1f;

	[Space(7f)]
	public WindZone SyncWithUnityWindZone;

	public float UnityWindZonePowerMul = 2f;

	public float UnityWindZoneTurbMul = 1f;

	[Header("Overriding wind if value below different than 0,0,0")]
	public Vector3 overrideWind = Vector3.zero;

	[FPD_Header("Procedural Wind Settings (if not syncing and not overriding)", 6f, 4f, 2)]
	[Range(0.1f, 1f)]
	public float rapidness = 0.95f;

	[FPD_Suffix(0f, 360f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float changesPower = 90f;

	[Range(0f, 10f)]
	[Header("Extra")]
	public float turbulenceSpeed = 1f;

	[FPD_Header("World Position Turbulence", 6f, 4f, 2)]
	[Tooltip("Increase to make objects next to each other wave in slightly different way")]
	public float worldTurb = 1f;

	[Tooltip("If higher no performance cost, it is just a number")]
	public float worldTurbScale = 512f;

	public float worldTurbSpeed = 5f;

	[Tooltip("When tail is longer then power of wind should be higher")]
	[FPD_Header("Tail Compoenents Related", 6f, 4f, 2)]
	public bool powerDependOnTailLength = true;

	[Tooltip("Don't destroy on load")]
	public bool persistThroughAllScenes;

	private Vector3 targetWind = Vector3.zero;

	private Vector3 smoothWind = Vector3.zero;

	private Vector3 windVeloHelper = Vector3.zero;

	private Quaternion windOrientation = Quaternion.identity;

	private Quaternion smoothWindOrient = Quaternion.identity;

	private Quaternion smoothWindOrientHelper = Quaternion.identity;

	private float[] randNumbers;

	private float[] randTimes;

	private float[] randSpeeds;

	private int frameOffset = 2;

	private Vector3 finalAddTurbulence = Vector3.zero;

	private Vector3 addTurbHelper = Vector3.zero;

	private Vector3 smoothAddTurbulence = Vector3.zero;

	public string EditorIconPath => "Tail Animator/TailAnimatorWindIconSmall";

	public static TailAnimatorWind Instance { get; private set; }

	public void OnDrop(PointerEventData data)
	{
	}

	private void Awake()
	{
		if (Application.isPlaying)
		{
			Instance = this;
			if (persistThroughAllScenes)
			{
				Object.DontDestroyOnLoad((Object)(object)((Component)this).gameObject);
			}
		}
	}

	public void OnValidate()
	{
		Instance = this;
	}

	private void Update()
	{
		if (frameOffset > 0)
		{
			frameOffset--;
		}
		else
		{
			ComputeWind();
		}
	}

	public static void Refresh()
	{
		if ((Object)(object)Instance == (Object)null)
		{
			Debug.Log((object)"[Tail Animator Wind] No Tail Animator Wind component on the scene!");
			Debug.LogWarning((object)"[Tail Animator Wind] No Tail Animator Wind component on the scene!");
		}
	}

	public void AffectTailWithWind(TailAnimator2 t)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		if (!t.UseWind || t.WindEffectPower <= 0f || t.TailSegments.Count <= 0)
		{
			return;
		}
		float num = 1f;
		if (powerDependOnTailLength)
		{
			num = t._TC_TailLength * t.TailSegments[0].transform.lossyScale.z / 5f;
			if (t.TailSegments.Count > 3)
			{
				num *= Mathf.Lerp(0.7f, 3f, (float)t.TailSegments.Count / 14f);
			}
		}
		if (t.WindWorldNoisePower > 0f)
		{
			float num2 = worldTurbSpeed;
			if (Object.op_Implicit((Object)(object)SyncWithUnityWindZone))
			{
				num2 *= SyncWithUnityWindZone.windTurbulence * UnityWindZoneTurbMul;
			}
			float num3 = 0.5f + Mathf.Sin(Time.time * num2 + t.TailSegments[0].ProceduralPosition.x * worldTurbScale) / 2f + (0.5f + Mathf.Cos(Time.time * num2 + t.TailSegments[0].ProceduralPosition.z * worldTurbScale) / 2f);
			num += num3 * worldTurb * t.WindWorldNoisePower;
		}
		num *= t.WindEffectPower;
		if (t.WindTurbulencePower > 0f)
		{
			t.WindEffect = new Vector3(targetWind.x * num + finalAddTurbulence.x * t.WindTurbulencePower, targetWind.y * num + finalAddTurbulence.y * t.WindTurbulencePower, targetWind.z * num + finalAddTurbulence.z * t.WindTurbulencePower);
		}
		else
		{
			t.WindEffect = new Vector3(targetWind.x * num, targetWind.y * num, targetWind.z * num);
		}
	}

	private void Start()
	{
		int num = 10;
		randNumbers = new float[num];
		randTimes = new float[num];
		randSpeeds = new float[num];
		for (int i = 0; i < 10; i++)
		{
			randNumbers[i] = Random.Range(-1000f, 1000f);
			randTimes[i] = Random.Range(-1000f, 1000f);
			randSpeeds[i] = Random.Range(0.18f, 0.7f);
		}
	}

	private void ComputeWind()
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val;
		if (Object.op_Implicit((Object)(object)SyncWithUnityWindZone))
		{
			val = ((Component)SyncWithUnityWindZone).transform.forward * SyncWithUnityWindZone.windMain * UnityWindZonePowerMul;
			((Component)this).transform.rotation = ((Component)SyncWithUnityWindZone).transform.rotation;
		}
		else if (overrideWind != Vector3.zero)
		{
			val = overrideWind;
		}
		else
		{
			for (int i = 0; i < 4; i++)
			{
				randTimes[i] += Time.deltaTime * randSpeeds[i] * turbulenceSpeed;
			}
			Quaternion val2 = windOrientation;
			float num = -1f + Mathf.PerlinNoise(randTimes[0], 256f + randTimes[1]) * 2f;
			float num2 = -1f + Mathf.PerlinNoise(0f - randTimes[1], 55f + randTimes[2]) * 2f;
			float num3 = -1f + Mathf.PerlinNoise(0f - randTimes[3], 55f + randTimes[0]) * 2f;
			val2 *= Quaternion.Euler(new Vector3(0f, num2, 0f) * changesPower);
			val2 = Quaternion.Euler(num * (changesPower / 6f), ((Quaternion)(ref val2)).eulerAngles.y, num3 * (changesPower / 6f));
			smoothWindOrient = smoothWindOrient.SmoothDampRotation(val2, ref smoothWindOrientHelper, 1f - rapidness, Time.deltaTime);
			((Component)this).transform.rotation = smoothWindOrient;
			val = smoothWindOrient * Vector3.forward;
		}
		smoothAddTurbulence = Vector3.SmoothDamp(smoothAddTurbulence, GetAddTurbulence() * additionalTurbulence, ref addTurbHelper, 0.05f, float.PositiveInfinity, Time.deltaTime);
		smoothWind = Vector3.SmoothDamp(smoothWind, val, ref windVeloHelper, 0.1f, float.PositiveInfinity, Time.deltaTime);
		for (int j = 7; j < 10; j++)
		{
			randTimes[j] += Time.deltaTime * randSpeeds[j] * turbulenceSpeed;
		}
		float num4 = power * 0.015f;
		num4 *= 0.5f + Mathf.PerlinNoise(randTimes[7] * 2f, 25f + randTimes[8] * 0.5f);
		finalAddTurbulence = smoothAddTurbulence * num4;
		targetWind = smoothWind * num4;
	}

	private Vector3 GetAddTurbulence()
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		float num = additionalTurbSpeed;
		if (Object.op_Implicit((Object)(object)SyncWithUnityWindZone))
		{
			num *= SyncWithUnityWindZone.windTurbulence * UnityWindZoneTurbMul;
		}
		for (int i = 4; i < 7; i++)
		{
			randTimes[i] += Time.deltaTime * randSpeeds[i] * num;
		}
		float num2 = -1f + Mathf.PerlinNoise(randTimes[4] + 7.123f, -2.324f + Time.time * 0.24f) * 2f;
		float num3 = -1f + Mathf.PerlinNoise(randTimes[5] - 4.7523f, -25.324f + Time.time * 0.54f) * 2f;
		float num4 = -1f + Mathf.PerlinNoise(randTimes[6] + 1.123f, -63.324f + Time.time * -0.49f) * 2f;
		return new Vector3(num2, num3, num4);
	}
}


using FIMSpace.FTail;
using UnityEngine;
using UnityEngine.Tilemaps;

[AddComponentMenu("FImpossible Creations/Hidden/Tail Collision Helper")]
public class TailCollisionHelper : MonoBehaviour
{
	public TailAnimator2 ParentTail;

	public Collider TailCollider;

	public Collider2D TailCollider2D;

	public int Index;

	private Transform previousCollision;

	internal Rigidbody RigBody { get; private set; }

	internal Rigidbody2D RigBody2D { get; private set; }

	internal TailCollisionHelper Init(bool addRigidbody = true, float mass = 1f, bool kinematic = false)
	{
		if ((Object)(object)TailCollider2D == (Object)null)
		{
			if (addRigidbody)
			{
				Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
				if (!Object.op_Implicit((Object)(object)val))
				{
					val = ((Component)this).gameObject.AddComponent<Rigidbody>();
				}
				val.interpolation = (RigidbodyInterpolation)1;
				val.useGravity = false;
				val.isKinematic = kinematic;
				val.constraints = (RigidbodyConstraints)126;
				val.mass = mass;
				RigBody = val;
			}
			else
			{
				RigBody = ((Component)this).GetComponent<Rigidbody>();
				if (Object.op_Implicit((Object)(object)RigBody))
				{
					RigBody.mass = mass;
				}
			}
		}
		else if (addRigidbody)
		{
			Rigidbody2D val2 = ((Component)this).GetComponent<Rigidbody2D>();
			if (!Object.op_Implicit((Object)(object)val2))
			{
				val2 = ((Component)this).gameObject.AddComponent<Rigidbody2D>();
			}
			val2.interpolation = (RigidbodyInterpolation2D)1;
			val2.gravityScale = 0f;
			val2.isKinematic = kinematic;
			val2.constraints = (RigidbodyConstraints2D)7;
			val2.mass = mass;
			RigBody2D = val2;
		}
		else
		{
			RigBody2D = ((Component)this).GetComponent<Rigidbody2D>();
			if (Object.op_Implicit((Object)(object)RigBody2D))
			{
				RigBody2D.mass = mass;
			}
		}
		return this;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if ((Object)(object)ParentTail == (Object)null)
		{
			Object.Destroy((Object)(object)this);
			return;
		}
		TailCollisionHelper component = ((Component)collision.transform).GetComponent<TailCollisionHelper>();
		if ((!Object.op_Implicit((Object)(object)component) || (ParentTail.CollideWithOtherTails && !((Object)(object)component.ParentTail == (Object)(object)ParentTail))) && !ParentTail._TransformsGhostChain.Contains(collision.transform) && !ParentTail.IgnoredColliders.Contains(collision.collider))
		{
			ParentTail.CollisionDetection(Index, collision);
			previousCollision = collision.transform;
		}
	}

	private void OnCollisionExit(Collision collision)
	{
		if ((Object)(object)collision.transform == (Object)(object)previousCollision)
		{
			ParentTail.ExitCollision(Index);
			previousCollision = null;
		}
	}

	private void OnTriggerEnter(Collider other)
	{
		if (!other.isTrigger && (!ParentTail.IgnoreMeshColliders || !(other is MeshCollider)) && !(other is CharacterController) && !ParentTail._TransformsGhostChain.Contains(((Component)other).transform) && !ParentTail.IgnoredColliders.Contains(other) && (ParentTail.CollideWithOtherTails || !Object.op_Implicit((Object)(object)((Component)((Component)other).transform).GetComponent<TailCollisionHelper>())))
		{
			ParentTail.AddCollider(other);
		}
	}

	private void OnTriggerExit(Collider other)
	{
		if (ParentTail.IncludedColliders.Contains(other) && !ParentTail.DynamicAlwaysInclude.Contains((Component)(object)other))
		{
			ParentTail.IncludedColliders.Remove(other);
		}
	}

	private void OnTriggerEnter2D(Collider2D other)
	{
		if (!other.isTrigger && !(other is CompositeCollider2D) && !(other is TilemapCollider2D) && !(other is EdgeCollider2D) && !ParentTail._TransformsGhostChain.Contains(((Component)other).transform) && !ParentTail.IgnoredColliders2D.Contains(other) && (ParentTail.CollideWithOtherTails || !Object.op_Implicit((Object)(object)((Component)((Component)other).transform).GetComponent<TailCollisionHelper>())))
		{
			ParentTail.AddCollider(other);
		}
	}

	private void OnTriggerExit2D(Collider2D other)
	{
		if (ParentTail.IncludedColliders2D.Contains(other) && !ParentTail.DynamicAlwaysInclude.Contains((Component)(object)other))
		{
			ParentTail.IncludedColliders2D.Remove(other);
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FIMSpace;
using FIMSpace.FSpine;
using UnityEngine;
using UnityEngine.EventSystems;

[DefaultExecutionOrder(-11)]
[AddComponentMenu("FImpossible Creations/Spine Animator 2")]
public class FSpineAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon, IClientComponent
{
	public enum EFSpineEditorCategory
	{
		Setup,
		Tweak,
		Adjust,
		Physical
	}

	public enum EFDeltaType
	{
		DeltaTime,
		SmoothDeltaTime,
		UnscaledDeltaTime,
		FixedDeltaTime,
		SafeDelta
	}

	public enum EParamChange
	{
		GoBackSpeed,
		SpineAnimatorAmount,
		AngleLimit,
		StraightenSpeed,
		PositionSmoother,
		RotationSmoother
	}

	public class HeadBone
	{
		public Transform baseTransform;

		public Transform transform;

		private Vector3 snapshotPoseBaseTrSpacePosition;

		public Vector3 SnapshotPosition;

		private Quaternion snapshotPoseBaseTrSpaceRotationF;

		private Quaternion snapshotPoseBaseTrSpaceRotationB;

		public Quaternion snapshotPoseLocalRotation;

		public Quaternion SnapshotRotation;

		public Vector3 InitialLocalPosition { get; private set; }

		public Quaternion InitialLocalRotation { get; private set; }

		public HeadBone(Transform t)
		{
			transform = t;
		}

		public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			TakePoseSnapshot(baseTransform, bones, index);
			InitialLocalPosition = transform.localPosition;
			InitialLocalRotation = transform.localRotation;
		}

		internal Quaternion GetLocalRotationDiff()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			return transform.rotation * Quaternion.Inverse(snapshotPoseLocalRotation);
		}

		public void SetCoordsForFrameForward()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
			SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationF;
		}

		public void SetCoordsForFrameBackward()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
			SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationB;
		}

		public void TakePoseSnapshot(Transform targetSpace, List<SpineBone> bones, int index)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			baseTransform = targetSpace;
			snapshotPoseBaseTrSpacePosition = targetSpace.InverseTransformPoint(transform.position);
			Vector3 val2;
			Vector3 val3;
			if (index == bones.Count - 1)
			{
				Vector3 val = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
				val2 = snapshotPoseBaseTrSpacePosition + val;
				val3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
			}
			else if (index == 0)
			{
				val2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
				Vector3 val4 = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
				val3 = snapshotPoseBaseTrSpacePosition + val4;
			}
			else
			{
				val2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
				val3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
			}
			snapshotPoseBaseTrSpaceRotationF = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(val2 - snapshotPoseBaseTrSpacePosition);
			snapshotPoseBaseTrSpaceRotationB = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(val3 - snapshotPoseBaseTrSpacePosition);
			snapshotPoseLocalRotation = Quaternion.Inverse(targetSpace.rotation) * transform.rotation;
		}
	}

	[Serializable]
	public class SpineBone
	{
		public Transform transform;

		public Vector3 ProceduralPosition;

		public Quaternion ProceduralRotation;

		public Vector3 HelperDiffPosition;

		public Quaternion HelperDiffRoation;

		public Vector3 PreviousPosition;

		public Vector3 DefaultForward;

		public float StraightenFactor;

		public float TargetStraightenFactor;

		private float boneLengthB = 0.1f;

		private float boneLengthF = 0.1f;

		private Vector3 boneLocalOffsetB;

		private Vector3 boneLocalOffsetF;

		public float MotionWeight = 1f;

		public Quaternion FinalRotation;

		public Vector3 FinalPosition;

		public Vector3 ManualPosOffset;

		public Quaternion ManualRotOffset;

		public Vector3 ReferencePosition;

		public Vector3 PreviousReferencePosition;

		public Quaternion ReferenceRotation;

		private Quaternion lastKeyframeRotation;

		private Vector3 lastKeyframePosition;

		private Vector3 lastFinalLocalPosition;

		private Quaternion lastFinalLocalRotation;

		public Vector3 forward;

		public Vector3 right;

		public Vector3 up;

		public bool Collide = true;

		public float CollisionRadius = 1f;

		public Vector3 ColliderOffset = Vector3.zero;

		public float BoneLength { get; private set; }

		public Vector3 BoneLocalOffset { get; private set; }

		public Vector3 InitialLocalPosition { get; private set; }

		public Quaternion InitialLocalRotation { get; private set; }

		public void UpdateReferencePosition(Vector3 pos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			PreviousReferencePosition = ReferencePosition;
			ReferencePosition = pos;
		}

		public void ZeroKeyframeCheck()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			if (lastFinalLocalRotation.QIsSame(transform.localRotation))
			{
				transform.localRotation = lastKeyframeRotation;
			}
			else
			{
				lastKeyframeRotation = transform.localRotation;
			}
			if (lastFinalLocalPosition.VIsSame(transform.localPosition))
			{
				transform.localPosition = lastKeyframePosition;
			}
			else
			{
				lastKeyframePosition = transform.localPosition;
			}
		}

		public void RefreshFinalLocalPose()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			lastFinalLocalPosition = transform.localPosition;
			lastFinalLocalRotation = transform.localRotation;
		}

		public SpineBone(Transform t)
		{
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			transform = t;
			ManualPosOffset = Vector3.zero;
			ColliderOffset = Vector3.zero;
			Collide = true;
			CollisionRadius = 1f;
		}

		public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0193: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			InitialLocalPosition = transform.localPosition;
			InitialLocalRotation = transform.localRotation;
			Vector3 val = ((index != bones.Count - 1) ? bones[index + 1].transform.position : ((bones[index].transform.childCount <= 0) ? bones[index - 1].transform.position : bones[index].transform.GetChild(0).position));
			if (index == 0)
			{
				val = bones[index + 1].transform.position;
			}
			if (Vector3.Distance(baseTransform.InverseTransformPoint(val), baseTransform.InverseTransformPoint(bones[index].transform.position)) < 0.01f)
			{
				int num = index + 2;
				if (num < bones.Count)
				{
					DefaultForward = transform.InverseTransformPoint(bones[num].transform.position);
				}
				else
				{
					DefaultForward = transform.InverseTransformPoint(val - baseTransform.position);
				}
			}
			else
			{
				DefaultForward = transform.InverseTransformPoint(val);
			}
			Vector3 val2 = baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(val);
			boneLengthB = ((Vector3)(ref val2)).magnitude;
			boneLocalOffsetB = baseTransform.InverseTransformPoint(val);
			val2 = baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(val);
			boneLengthF = ((Vector3)(ref val2)).magnitude;
			boneLocalOffsetF = baseTransform.InverseTransformPoint(val);
			if (((Vector3)(ref ManualPosOffset)).sqrMagnitude == 0f)
			{
				ManualPosOffset = Vector3.zero;
			}
			val2 = ((Quaternion)(ref ManualRotOffset)).eulerAngles;
			if (((Vector3)(ref val2)).sqrMagnitude == 0f)
			{
				ManualRotOffset = Quaternion.identity;
			}
			SetDistanceForFrameForward();
			PrepareAxes(baseTransform, bones, index);
		}

		public void SetDistanceForFrameForward()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			BoneLength = boneLengthF;
			BoneLocalOffset = boneLocalOffsetF;
		}

		public void SetDistanceForFrameBackward()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			BoneLength = boneLengthB;
			BoneLocalOffset = boneLocalOffsetB;
		}

		public float GetUnscalledBoneLength()
		{
			if (boneLengthF > boneLengthB)
			{
				return boneLengthF;
			}
			return boneLengthB;
		}

		private void PrepareAxes(Transform baseTransform, List<SpineBone> bonesList, int index)
		{
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_0118: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			Transform val;
			Vector3 position;
			Vector3 position2;
			if (index == bonesList.Count - 1)
			{
				if (transform.childCount == 1)
				{
					val = transform;
					Transform child = transform.GetChild(0);
					position = val.position;
					position2 = child.position;
				}
				else
				{
					val = transform;
					_ = transform;
					position = bonesList[index - 1].transform.position;
					position2 = transform.position;
				}
			}
			else
			{
				val = transform;
				Transform obj = bonesList[index + 1].transform;
				position = val.position;
				position2 = obj.position;
			}
			Vector3 val2 = val.InverseTransformDirection(position2) - val.InverseTransformDirection(position);
			Vector3 val3 = baseTransform.up;
			Vector3 val4 = transform.TransformDirection(val2);
			val4 = Vector3.ProjectOnPlane(val3, ((Vector3)(ref val4)).normalized);
			Vector3 normalized = ((Vector3)(ref val4)).normalized;
			Vector3 val5 = val.InverseTransformDirection(position + normalized) - val.InverseTransformDirection(position);
			Vector3 val6 = Vector3.Cross(transform.TransformDirection(val2), transform.TransformDirection(val5));
			Vector3 val7 = val.InverseTransformDirection(position + val6) - val.InverseTransformDirection(position);
			right = ((Vector3)(ref val7)).normalized;
			up = ((Vector3)(ref val5)).normalized;
			forward = ((Vector3)(ref val2)).normalized;
		}

		internal void CalculateDifferencePose(Vector3 upAxis, Vector3 rightAxis)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			HelperDiffPosition = ProceduralPosition - ReferencePosition;
			Quaternion val = ProceduralRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
			Quaternion val2 = ReferenceRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
			HelperDiffRoation = val * Quaternion.Inverse(val2);
		}

		internal void ApplyDifferencePose()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			FinalPosition = transform.position + HelperDiffPosition;
			FinalRotation = HelperDiffRoation * transform.rotation;
		}

		public void Editor_SetLength(float length)
		{
			if (!Application.isPlaying)
			{
				BoneLength = length;
			}
		}

		public float GetCollisionRadiusScaled()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return CollisionRadius * transform.lossyScale.x;
		}
	}

	public enum EFixedMode
	{
		None,
		Basic,
		Late
	}

	private static ListHashSet<FSpineAnimator> components = new ListHashSet<FSpineAnimator>();

	private bool collisionInitialized;

	private bool forceRefreshCollidersData;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	[Tooltip("You can use this variable to blend intensity of spine animator motion over skeleton animation\n\nValue = 1: Animation with spine Animator motion\nValue = 0: Only skeleton animation")]
	public float SpineAnimatorAmount = 1f;

	private Quaternion Rotate180 = Quaternion.Euler(0f, 180f, 0f);

	private int initAfterTPoseCounter;

	private bool fixedUpdated;

	private bool lateFixedIsRunning;

	private bool fixedAllow = true;

	private bool chainReverseFlag;

	public EFSpineEditorCategory _Editor_Category;

	public bool _Editor_PivotoffsetXYZ;

	private bool _editor_isQuitting;

	private int leadingBoneIndex;

	private int chainIndexDirection = 1;

	private int chainIndexOffset = 1;

	protected float delta = 0.016f;

	protected float unifiedDelta = 0.016f;

	protected float elapsedDeltaHelper;

	protected int updateLoops = 1;

	private bool initialized;

	private Vector3 previousPos;

	private bool wasBlendedOut;

	private List<FSpineBoneConnector> connectors;

	private float referenceDistance = 0.1f;

	public Vector3 ModelForwardAxis = Vector3.forward;

	public Vector3 ModelForwardAxisScaled = Vector3.forward;

	public Vector3 ModelUpAxis = Vector3.up;

	public Vector3 ModelUpAxisScaled = Vector3.up;

	internal Vector3 ModelRightAxis = Vector3.right;

	internal Vector3 ModelRightAxisScaled = Vector3.right;

	public List<SpineBone> SpineBones;

	public List<Transform> SpineTransforms;

	private HeadBone frontHead;

	private HeadBone backHead;

	private HeadBone headBone;

	[Tooltip("Main character object - by default it is game object to which Spine Animator is attached.\n\nYou can use it to control spine of character from different game object.")]
	public Transform BaseTransform;

	public Transform ForwardReference;

	[Tooltip("If your spine lead bone is in beggining of your hierarchy chain then toggle it.\n\nComponent's gizmos can help you out to define which bone should be leading (check head gizmo when you switch this toggle).")]
	public bool LastBoneLeading = true;

	[Tooltip("Sometimes spine chain can face in different direction than desired or you want your characters to move backward with spine motion.")]
	public bool ReverseForward;

	[Tooltip("If you're using 'Animate Physics' on animator you should set this variable to be enabled.")]
	public EFixedMode AnimatePhysics;

	public Transform AnchorRoot;

	[Tooltip("Connecting lead bone position to given transform, useful when it is tail and you already animating spine with other Spine Animator component.")]
	public Transform HeadAnchor;

	[Tooltip("Letting head anchor to animate rotation")]
	public bool AnimateAnchor = true;

	[Tooltip("If you need to offset leading bone rotation.")]
	public Vector3 LeadBoneRotationOffset = Vector3.zero;

	[Tooltip("If Lead Bone Rotation Offset should affect reference pose or bone rotation")]
	public bool LeadBoneOffsetReference = true;

	[Tooltip("List of bone positioning/rotation fixers if using paws positioning with IK controlls disconnected out of arms/legs in the hierarchy")]
	public List<SpineAnimator_FixIKControlledBones> BonesFixers = new List<SpineAnimator_FixIKControlledBones>();

	[Tooltip("Useful when you use few spine animators and want to rely on animated position and rotation by other spine animator.")]
	public bool UpdateAsLast;

	public bool QueueToLastUpdate;

	[Tooltip("If corrections should affect spine chain children.")]
	public bool ManualAffectChain;

	[Tooltip("Often when you drop model to scene, it's initial pose is much different than animations, which causes problems, this toggle solves it at start.")]
	public bool StartAfterTPose = true;

	[Tooltip("If you want spine animator to stop computing when choosed animator is not enabled")]
	public Animator OptimizeWithAnimator;

	[Tooltip("Delta Time for Spine Animator calculations")]
	public EFDeltaType DeltaType = EFDeltaType.SafeDelta;

	[Tooltip("Making update rate stable for target rate.\nIf this value is = 0 then update rate is unlimited.")]
	public float UpdateRate;

	[Tooltip("In some cases you need to use chain corrections, it will cost a bit more in performance, not much but always.")]
	public bool UseCorrections;

	[Tooltip("Sometimes offsetting model's pivot position gives better results using spine animator, offset forward axis so front legs are in centrum and see the difference (generating additional transform inside hierarchy)")]
	public Vector3 MainPivotOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("Generating offset runtime only, allows you to adjust it on prefabs on scene")]
	public bool PivotOffsetOnStart = true;

	[Tooltip("If animation of changing segments position should be smoothed - creating a little gumy effect.")]
	[Range(0f, 1f)]
	public float PosSmoother;

	[Range(0f, 1f)]
	[Tooltip("If animation of changing segments rotation should be smoothed - making it more soft, but don't overuse it!")]
	public float RotSmoother;

	[Range(0f, 1f)]
	[Tooltip("We stretching segments to bigger value than bones are by default to create some extra effect which looks good but sometimes it can stretch to much if you using position smoothing, you can adjust it here.")]
	public float MaxStretching = 1f;

	[Tooltip("Making algorithm referencing back to static rotation if value = 0f | at 1 motion have more range and is more slithery.")]
	[Range(0f, 1f)]
	public float Slithery = 1f;

	[Tooltip("Limiting rotation angle difference between each segment of spine.")]
	[Range(1f, 91f)]
	public float AngleLimit = 40f;

	[Tooltip("Smoothing how fast limiting should make segments go back to marginal pose.")]
	[Range(0f, 1f)]
	public float LimitSmoother = 0.35f;

	[Tooltip("How fast spine should be rotated to straight pose when your character moves.")]
	[Range(0f, 15f)]
	public float StraightenSpeed = 7.5f;

	public bool TurboStraighten;

	[Range(0f, 1f)]
	[Tooltip("Spine going back to straight position constantly with choosed speed intensity.")]
	public float GoBackSpeed;

	[Range(0f, 1f)]
	[Tooltip("Elastic spring effect good for tails to make them more 'meaty'.")]
	public float Springiness;

	[Range(0f, 1f)]
	[Tooltip("How much effect on spine chain should have character movement.")]
	public float MotionInfluence = 1f;

	[Tooltip("Useful when your creature jumps on moving platform, so when platform moves spine is not reacting, by default world space is used (null).")]
	public Transform MotionSpace;

	[Tooltip("Fade rotations to sides or rotation up/down with this parameter - can be helpful for character jump handling")]
	public Vector2 RotationsFade = Vector2.one;

	[SerializeField]
	[HideInInspector]
	private Transform mainPivotOffsetTransform;

	[Tooltip("<! Most models can not need this !> Offset for bones rotations, thanks to that animation is able to rotate to segments in a correct way, like from center of mass.")]
	public Vector3 SegmentsPivotOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("Multiplies distance value between bones segments - can be useful for use with humanoid skeletons")]
	public float DistancesMultiplier = 1f;

	[Tooltip("Pushing segments in world direction (should have included ground collider to collide with).")]
	public Vector3 GravityPower = Vector3.zero;

	protected Vector3 gravityScale = Vector3.zero;

	[Tooltip("[Experimental] Using some simple calculations to make spine bend on colliders.")]
	public bool UseCollisions;

	public List<Collider> IncludedColliders;

	protected List<FImp_ColliderData_Base> IncludedCollidersData;

	protected List<FImp_ColliderData_Base> CollidersDataToCheck;

	[Tooltip("If disabled Colliders can be offsetted a bit in wrong way - check pink spheres in scene view (playmode, with true positions disabled colliders are fitting to stiff reference pose) - but it gives more stable collision projection! But to avoid stuttery you can increase position smoothing.")]
	public bool UseTruePosition;

	public Vector3 OffsetAllColliders = Vector3.zero;

	public AnimationCurve CollidersScale = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public float CollidersScaleMul = 6.5f;

	[Range(0f, 1f)]
	public float DifferenceScaleFactor;

	[Tooltip("If you want to continue checking collision if segment collides with one collider (very useful for example when you using gravity power with ground)")]
	public bool DetailedCollision = true;

	[HideInInspector]
	[SerializeField]
	private bool _CheckedPivot;

	private bool updateSpineAnimator;

	private bool callSpineReposeCalculations = true;

	public string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Spine Animator/SpineAnimator_SmallIcon";
		}
	}

	[Obsolete("Use SpineAnimatorAmount instead, but remember that it works in reversed way -> SpineAnimatorAmount 1 = BlendToOriginal 0  and  SpineAnimatorAmount 0 = BlendToOriginal 1")]
	public float BlendToOriginal
	{
		get
		{
			return 1f - SpineAnimatorAmount;
		}
		set
		{
			SpineAnimatorAmount = 1f - value;
		}
	}

	public bool EndBoneIsHead
	{
		get
		{
			return LastBoneLeading;
		}
		set
		{
			LastBoneLeading = EndBoneIsHead;
		}
	}

	private void OnEnable()
	{
		components.TryAdd(this);
	}

	private void OnDisable()
	{
		components.Remove(this);
	}

	public static void TickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			FSpineAnimator fSpineAnimator = components[num];
			if (fSpineAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				fSpineAnimator.Tick();
			}
		}
	}

	public static void LateTickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			FSpineAnimator fSpineAnimator = components[num];
			if (fSpineAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				fSpineAnimator.LateTick();
			}
		}
	}

	public static void FixedTickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			FSpineAnimator fSpineAnimator = components[num];
			if (fSpineAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				fSpineAnimator.FixedTick();
			}
		}
	}

	private void RemovePivotOffset()
	{
		if (!Application.isPlaying && Object.op_Implicit((Object)(object)mainPivotOffsetTransform))
		{
			RestoreBasePivotChildren();
		}
	}

	public void UpdatePivotOffsetState()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (SpineBones.Count <= 1)
		{
			return;
		}
		if (MainPivotOffset == Vector3.zero)
		{
			if (Object.op_Implicit((Object)(object)mainPivotOffsetTransform) && mainPivotOffsetTransform.childCount > 0)
			{
				mainPivotOffsetTransform.localPosition = MainPivotOffset;
				RestoreBasePivotChildren();
			}
			return;
		}
		if (!Object.op_Implicit((Object)(object)mainPivotOffsetTransform))
		{
			mainPivotOffsetTransform = new GameObject("Main Pivot Offset-Spine Animator-" + ((Object)this).name).transform;
			mainPivotOffsetTransform.SetParent(GetBaseTransform(), false);
			mainPivotOffsetTransform.localPosition = Vector3.zero;
			mainPivotOffsetTransform.localRotation = Quaternion.identity;
			mainPivotOffsetTransform.localScale = Vector3.one;
		}
		if (mainPivotOffsetTransform.childCount == 0)
		{
			for (int num = GetBaseTransform().childCount - 1; num >= 0; num--)
			{
				if (!((Object)(object)GetBaseTransform().GetChild(num) == (Object)(object)mainPivotOffsetTransform))
				{
					GetBaseTransform().GetChild(num).SetParent(mainPivotOffsetTransform, true);
				}
			}
		}
		mainPivotOffsetTransform.localPosition = MainPivotOffset;
	}

	private void RestoreBasePivotChildren()
	{
		if (!_editor_isQuitting)
		{
			for (int num = mainPivotOffsetTransform.childCount - 1; num >= 0; num--)
			{
				mainPivotOffsetTransform.GetChild(num).SetParent(mainPivotOffsetTransform.parent, true);
			}
		}
	}

	private void PreMotionBoneOffsets()
	{
		if (UseCorrections && ManualAffectChain && callSpineReposeCalculations)
		{
			PreMotionNoHead();
			PreMotionHead();
		}
	}

	private void PreMotionNoHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; i++)
			{
				SegmentPreOffsetWithPivot(i);
			}
		}
		else
		{
			for (int j = 1 - chainIndexOffset; j < SpineBones.Count - chainIndexOffset; j++)
			{
				SegmentPreOffset(j);
			}
		}
	}

	private void PreMotionHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			SegmentPreOffsetWithPivot(leadingBoneIndex);
		}
		else
		{
			SegmentPreOffset(leadingBoneIndex);
		}
	}

	private void SegmentPreOffset(int i)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			Transform transform = SpineBones[i].transform;
			transform.position += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		Transform transform2 = SpineBones[i].transform;
		transform2.rotation *= SpineBones[i].ManualRotOffset;
	}

	private void SegmentPreOffsetWithPivot(int i)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			Transform transform = SpineBones[i].transform;
			transform.position += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		Transform transform2 = SpineBones[i].transform;
		transform2.position += SpineBones[i].ProceduralRotation * (SegmentsPivotOffset * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.z));
		Transform transform3 = SpineBones[i].transform;
		transform3.rotation *= SpineBones[i].ManualRotOffset;
	}

	private void PostMotionBoneOffsets()
	{
		if (UseCorrections && !ManualAffectChain)
		{
			PostMotionHead();
			PostMotionNoHead();
		}
	}

	private void PostMotionNoHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; i++)
			{
				SegmentPostOffsetWithPivot(i);
			}
		}
		else
		{
			for (int j = 1 - chainIndexOffset; j < SpineBones.Count - chainIndexOffset; j++)
			{
				SegmentPostOffset(j);
			}
		}
	}

	private void PostMotionHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			SegmentPostOffsetWithPivot(leadingBoneIndex);
		}
		else
		{
			SegmentPostOffset(leadingBoneIndex);
		}
	}

	private void SegmentPostOffset(int i)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			SpineBone spineBone = SpineBones[i];
			spineBone.FinalPosition += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		SpineBone spineBone2 = SpineBones[i];
		spineBone2.FinalRotation *= SpineBones[i].ManualRotOffset;
	}

	private void SegmentPostOffsetWithPivot(int i)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			SpineBone spineBone = SpineBones[i];
			spineBone.FinalPosition += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		SpineBone spineBone2 = SpineBones[i];
		spineBone2.FinalPosition += SpineBones[i].ProceduralRotation * (SegmentsPivotOffset * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.z));
		SpineBone spineBone3 = SpineBones[i];
		spineBone3.FinalRotation *= SpineBones[i].ManualRotOffset;
	}

	private void BeginPhysicsUpdate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		gravityScale = GravityPower * delta;
		if (!UseCollisions)
		{
			return;
		}
		if (!collisionInitialized)
		{
			InitColliders();
		}
		else
		{
			RefreshCollidersDataList();
		}
		CollidersDataToCheck.Clear();
		for (int i = 0; i < IncludedCollidersData.Count; i++)
		{
			if ((Object)(object)IncludedCollidersData[i].Collider == (Object)null)
			{
				forceRefreshCollidersData = true;
				break;
			}
			if (((Component)IncludedCollidersData[i].Collider).gameObject.activeInHierarchy)
			{
				IncludedCollidersData[i].RefreshColliderData();
				CollidersDataToCheck.Add(IncludedCollidersData[i]);
			}
		}
	}

	public void RefreshCollidersDataList()
	{
		if (IncludedColliders.Count == IncludedCollidersData.Count && !forceRefreshCollidersData)
		{
			return;
		}
		IncludedCollidersData.Clear();
		for (int num = IncludedColliders.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)IncludedColliders[num] == (Object)null)
			{
				IncludedColliders.RemoveAt(num);
			}
			else
			{
				FImp_ColliderData_Base colliderDataFor = FImp_ColliderData_Base.GetColliderDataFor(IncludedColliders[num]);
				IncludedCollidersData.Add(colliderDataFor);
			}
		}
		forceRefreshCollidersData = false;
	}

	private float GetColliderSphereRadiusFor(int i)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		int index = i - 1;
		if (LastBoneLeading)
		{
			if (i == SpineBones.Count - 1)
			{
				return 0f;
			}
			index = i + 1;
		}
		else if (i == 0)
		{
			return 0f;
		}
		float num = 1f;
		if (SpineBones.Count > 1)
		{
			num = Vector3.Distance(SpineBones[1].transform.position, SpineBones[0].transform.position);
		}
		float num2 = num;
		Vector3 val = SpineBones[i].transform.position - SpineBones[index].transform.position;
		float num3 = Mathf.Lerp(num2, ((Vector3)(ref val)).magnitude * 0.5f, DifferenceScaleFactor);
		float num4 = SpineBones.Count - 1;
		if (num4 <= 0f)
		{
			num4 = 1f;
		}
		float num5 = 1f / num4;
		return 0.5f * num3 * CollidersScaleMul * CollidersScale.Evaluate(num5 * (float)i);
	}

	public void AddCollider(Collider collider)
	{
		if (!IncludedColliders.Contains(collider))
		{
			IncludedColliders.Add(collider);
		}
	}

	private void InitColliders()
	{
		for (int i = 0; i < SpineBones.Count; i++)
		{
			SpineBones[i].CollisionRadius = GetColliderSphereRadiusFor(i);
		}
		IncludedCollidersData = new List<FImp_ColliderData_Base>();
		RefreshCollidersDataList();
		collisionInitialized = true;
	}

	public void CheckForColliderDuplicates()
	{
		for (int i = 0; i < IncludedColliders.Count; i++)
		{
			Collider col = IncludedColliders[i];
			if (IncludedColliders.Count((Collider o) => (Object)(object)o == (Object)(object)col) > 1)
			{
				IncludedColliders.RemoveAll((Collider o) => (Object)(object)o == (Object)(object)col);
				IncludedColliders.Add(col);
			}
		}
	}

	public void PushIfSegmentInsideCollider(SpineBone bone, ref Vector3 targetPoint)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointOffset;
		if (UseTruePosition)
		{
			Vector3 val = targetPoint;
			pointOffset = bone.FinalPosition - val + bone.transform.TransformVector(bone.ColliderOffset + OffsetAllColliders);
		}
		else
		{
			pointOffset = bone.transform.TransformVector(bone.ColliderOffset + OffsetAllColliders);
		}
		if (!DetailedCollision)
		{
			for (int i = 0; i < CollidersDataToCheck.Count && !CollidersDataToCheck[i].PushIfInside(ref targetPoint, bone.GetCollisionRadiusScaled(), pointOffset); i++)
			{
			}
			return;
		}
		for (int j = 0; j < CollidersDataToCheck.Count; j++)
		{
			CollidersDataToCheck[j].PushIfInside(ref targetPoint, bone.GetCollisionRadiusScaled(), pointOffset);
		}
	}

	private void CalculateBonesCoordinates()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (LastBoneLeading)
		{
			for (int num = SpineBones.Count - 2; num >= 0; num--)
			{
				CalculateTargetBoneRotation(num);
				CalculateTargetBonePosition(num);
				SpineBones[num].CalculateDifferencePose(ModelUpAxis, ModelRightAxis);
				SpineBones[num].ApplyDifferencePose();
			}
		}
		else
		{
			for (int i = 1; i < SpineBones.Count; i++)
			{
				CalculateTargetBoneRotation(i);
				CalculateTargetBonePosition(i);
				SpineBones[i].CalculateDifferencePose(ModelUpAxis, ModelRightAxis);
				SpineBones[i].ApplyDifferencePose();
			}
		}
	}

	private void CalculateTargetBonePosition(int index)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		SpineBone spineBone = SpineBones[index - chainIndexDirection];
		SpineBone spineBone2 = SpineBones[index];
		Vector3 targetPoint = spineBone.ProceduralPosition - spineBone2.ProceduralRotation * ModelForwardAxisScaled * (spineBone2.BoneLength * DistancesMultiplier);
		if (spineBone2.Collide)
		{
			targetPoint += gravityScale;
		}
		if (Springiness > 0f && !LastBoneLeading)
		{
			Vector3 val = spineBone2.ProceduralPosition - spineBone2.PreviousPosition;
			Vector3 proceduralPosition = spineBone2.ProceduralPosition;
			spineBone2.PreviousPosition = spineBone2.ProceduralPosition;
			proceduralPosition += val * (1f - Mathf.Lerp(0.05f, 0.25f, Springiness));
			Vector3 val2 = spineBone.ProceduralPosition - proceduralPosition;
			float magnitude = ((Vector3)(ref val2)).magnitude;
			Matrix4x4 localToWorldMatrix = spineBone.transform.localToWorldMatrix;
			((Matrix4x4)(ref localToWorldMatrix)).SetColumn(3, Vector4.op_Implicit(spineBone.ProceduralPosition));
			Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(spineBone2.transform.localPosition);
			Vector3 val4 = val3 - proceduralPosition;
			proceduralPosition += val4 * Mathf.Lerp(0.05f, 0.2f, Springiness);
			val4 = val3 - proceduralPosition;
			float magnitude2 = ((Vector3)(ref val4)).magnitude;
			float num = magnitude * (1f - Mathf.Lerp(0f, 0.2f, Springiness)) * 2f;
			if (magnitude2 > num)
			{
				proceduralPosition += val4 * ((magnitude2 - num) / magnitude2);
			}
			if (MaxStretching < 1f)
			{
				float num2 = Vector3.Distance(spineBone2.ProceduralPosition, proceduralPosition);
				if (num2 > 0f)
				{
					float num3 = spineBone2.BoneLength * 4f * MaxStretching;
					if (num2 > num3)
					{
						proceduralPosition = Vector3.Lerp(proceduralPosition, targetPoint, Mathf.InverseLerp(num2, 0f, num3));
					}
				}
			}
			targetPoint = Vector3.Lerp(targetPoint, proceduralPosition, Mathf.Lerp(0.3f, 0.9f, Springiness));
		}
		if (PosSmoother > 0f && MaxStretching < 1f)
		{
			float num4 = Vector3.Distance(spineBone2.ProceduralPosition, targetPoint);
			if (num4 > 0f)
			{
				float num5 = spineBone2.BoneLength * 4f * MaxStretching;
				if (num4 > num5)
				{
					spineBone2.ProceduralPosition = Vector3.Lerp(spineBone2.ProceduralPosition, targetPoint, Mathf.InverseLerp(num4, 0f, num5));
				}
			}
		}
		if (UseCollisions && spineBone2.Collide)
		{
			PushIfSegmentInsideCollider(spineBone2, ref targetPoint);
		}
		if (PosSmoother == 0f)
		{
			spineBone2.ProceduralPosition = targetPoint;
		}
		else
		{
			spineBone2.ProceduralPosition = Vector3.LerpUnclamped(spineBone2.ProceduralPosition, targetPoint, Mathf.LerpUnclamped(1f, unifiedDelta, PosSmoother));
		}
	}

	private void CalculateTargetBoneRotation(int index)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		SpineBone spineBone = SpineBones[index - chainIndexDirection];
		SpineBone spineBone2 = SpineBones[index];
		Quaternion val = ((Slithery >= 1f) ? spineBone.ProceduralRotation : ((!(Slithery > 0f)) ? spineBone2.ReferenceRotation : Quaternion.LerpUnclamped(spineBone2.ReferenceRotation, spineBone.ProceduralRotation, Slithery)));
		Vector3 val2 = spineBone.ProceduralPosition - spineBone2.ProceduralPosition;
		if (val2 == Vector3.zero)
		{
			val2 = spineBone2.transform.rotation * spineBone2.DefaultForward;
		}
		if (RotationsFade != Vector2.one)
		{
			val2.x *= RotationsFade.x;
			val2.z *= RotationsFade.x;
			val2.y *= RotationsFade.y;
		}
		Quaternion val3 = Quaternion.LookRotation(val2, spineBone.ProceduralRotation * ModelUpAxis);
		val3 = Quaternion.Inverse(((Component)this).transform.rotation) * val3;
		val3 = Quaternion.Euler(0f, ((Quaternion)(ref val3)).eulerAngles.y, 0f);
		val3 = ((Component)this).transform.rotation * val3;
		if (AngleLimit < 91f)
		{
			float num = Quaternion.Angle(val3, val);
			if (num > AngleLimit)
			{
				float num2 = 0f;
				num2 = Mathf.InverseLerp(0f, num, num - AngleLimit);
				Quaternion val4 = Quaternion.LerpUnclamped(val3, val, num2);
				float num3 = Mathf.Min(1f, num / (AngleLimit / 0.75f));
				num3 = Mathf.Sqrt(Mathf.Pow(num3, 4f)) * num3;
				val3 = ((LimitSmoother != 0f) ? Quaternion.LerpUnclamped(val3, val4, unifiedDelta * (1f - LimitSmoother) * 50f * num3) : Quaternion.LerpUnclamped(val3, val4, num3));
			}
		}
		if (GoBackSpeed <= 0f)
		{
			if (StraightenSpeed > 0f)
			{
				Vector3 val5 = spineBone2.ReferencePosition - spineBone2.PreviousReferencePosition;
				float num4 = ((Vector3)(ref val5)).magnitude / spineBone2.GetUnscalledBoneLength();
				if (num4 > 0.5f)
				{
					num4 = 0.5f;
				}
				float num5 = num4 * (1f + StraightenSpeed / 5f);
				spineBone2.StraightenFactor = Mathf.Lerp(spineBone2.StraightenFactor, num5, unifiedDelta * (7f + StraightenSpeed));
				if (num4 > 0.0001f)
				{
					val3 = Quaternion.Lerp(val3, val, unifiedDelta * spineBone2.StraightenFactor * (StraightenSpeed + 5f) * (TurboStraighten ? 6f : 1f));
				}
			}
		}
		else
		{
			float num6 = 0f;
			if (StraightenSpeed > 0f)
			{
				if (previousPos != RoundPosDiff(SpineBones[leadingBoneIndex].ProceduralPosition))
				{
					spineBone2.TargetStraightenFactor = 1f;
				}
				else if (spineBone2.TargetStraightenFactor > 0f)
				{
					spineBone2.TargetStraightenFactor -= delta * (5f + StraightenSpeed);
				}
				spineBone2.StraightenFactor = Mathf.Lerp(spineBone2.StraightenFactor, spineBone2.TargetStraightenFactor, unifiedDelta * (1f + StraightenSpeed));
				if (spineBone2.StraightenFactor > 0.025f)
				{
					num6 = spineBone2.StraightenFactor * StraightenSpeed * (TurboStraighten ? 6f : 1f);
				}
			}
			val3 = Quaternion.Lerp(val3, val, unifiedDelta * (Mathf.Lerp(0f, 55f, GoBackSpeed) + num6));
		}
		if (RotSmoother == 0f)
		{
			spineBone2.ProceduralRotation = val3;
		}
		else
		{
			spineBone2.ProceduralRotation = Quaternion.LerpUnclamped(spineBone2.ProceduralRotation, val3, Mathf.LerpUnclamped(0f, Mathf.LerpUnclamped(1f, unifiedDelta, RotSmoother), MotionInfluence));
		}
	}

	private void UpdateChainIndexHelperVariables()
	{
		if (chainReverseFlag == LastBoneLeading)
		{
			return;
		}
		chainReverseFlag = LastBoneLeading;
		if (LastBoneLeading)
		{
			leadingBoneIndex = SpineBones.Count - 1;
			chainIndexDirection = -1;
			chainIndexOffset = 1;
			headBone = backHead;
		}
		else
		{
			leadingBoneIndex = 0;
			chainIndexDirection = 1;
			chainIndexOffset = 0;
			headBone = frontHead;
		}
		if (LastBoneLeading)
		{
			for (int i = 0; i < SpineBones.Count; i++)
			{
				SpineBones[i].SetDistanceForFrameBackward();
			}
		}
		else
		{
			for (int j = 0; j < SpineBones.Count; j++)
			{
				SpineBones[j].SetDistanceForFrameForward();
			}
		}
	}

	private void RefreshReferencePose()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)HeadAnchor) && !AnimateAnchor)
		{
			SpineBones[leadingBoneIndex].transform.localRotation = SpineBones[leadingBoneIndex].InitialLocalRotation;
		}
		if (LastBoneLeading)
		{
			headBone.SetCoordsForFrameBackward();
			if (!Object.op_Implicit((Object)(object)HeadAnchor))
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.SnapshotPosition);
				SpineBones[leadingBoneIndex].ReferenceRotation = BaseTransform.rotation;
			}
			else
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.transform.position);
				SpineBones[leadingBoneIndex].ReferenceRotation = BaseTransform.rotation;
			}
			if (((Vector3)(ref LeadBoneRotationOffset)).sqrMagnitude != 0f && LeadBoneOffsetReference)
			{
				SpineBone spineBone = SpineBones[leadingBoneIndex];
				spineBone.ReferenceRotation *= Quaternion.Euler(LeadBoneRotationOffset);
			}
			if (ReverseForward)
			{
				SpineBone spineBone2 = SpineBones[leadingBoneIndex];
				spineBone2.ReferenceRotation *= Rotate180;
			}
			for (int num = SpineBones.Count - 2; num >= 0; num--)
			{
				SpineBones[num].ReferenceRotation = SpineBones[num + 1].ReferenceRotation;
				SpineBones[num].UpdateReferencePosition(SpineBones[num + 1].ReferencePosition - SpineBones[num].ReferenceRotation * ModelForwardAxis * (SpineBones[num].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.x));
			}
		}
		else
		{
			headBone.SetCoordsForFrameForward();
			if (!Object.op_Implicit((Object)(object)HeadAnchor))
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.SnapshotPosition);
				SpineBones[leadingBoneIndex].ReferenceRotation = BaseTransform.rotation;
			}
			else
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.transform.position);
				SpineBones[leadingBoneIndex].ReferenceRotation = headBone.GetLocalRotationDiff();
			}
			if (((Vector3)(ref LeadBoneRotationOffset)).sqrMagnitude != 0f && LeadBoneOffsetReference)
			{
				SpineBone spineBone3 = SpineBones[leadingBoneIndex];
				spineBone3.ReferenceRotation *= Quaternion.Euler(LeadBoneRotationOffset);
			}
			if (ReverseForward)
			{
				SpineBone spineBone4 = SpineBones[leadingBoneIndex];
				spineBone4.ReferenceRotation *= Rotate180;
			}
			for (int i = 1; i < SpineBones.Count; i++)
			{
				SpineBones[i].ReferenceRotation = SpineBones[i - 1].ReferenceRotation;
				SpineBones[i].UpdateReferencePosition(SpineBones[i - 1].ReferencePosition - SpineBones[i].ReferenceRotation * ModelForwardAxis * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.x));
			}
		}
	}

	private void ReposeSpine()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		UpdateChainIndexHelperVariables();
		RefreshReferencePose();
		for (int i = 0; i < SpineBones.Count; i++)
		{
			SpineBones[i].ProceduralPosition = SpineBones[i].ReferencePosition;
			SpineBones[i].ProceduralRotation = SpineBones[i].ReferenceRotation;
			SpineBones[i].PreviousPosition = SpineBones[i].ReferencePosition;
			SpineBones[i].FinalPosition = SpineBones[i].ReferencePosition;
			SpineBones[i].FinalRotation = SpineBones[i].ReferenceRotation;
		}
	}

	private void BeginBaseBonesUpdate()
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)HeadAnchor != (Object)null)
		{
			SpineBones[leadingBoneIndex].ProceduralRotation = headBone.GetLocalRotationDiff();
			SpineBones[leadingBoneIndex].ProceduralPosition = SpineBones[leadingBoneIndex].transform.position;
		}
		else
		{
			SpineBones[leadingBoneIndex].ProceduralPosition = SpineBones[leadingBoneIndex].ReferencePosition;
			SpineBones[leadingBoneIndex].ProceduralRotation = SpineBones[leadingBoneIndex].ReferenceRotation;
		}
		if (((Vector3)(ref LeadBoneRotationOffset)).sqrMagnitude != 0f && !LeadBoneOffsetReference)
		{
			SpineBone spineBone = SpineBones[leadingBoneIndex];
			spineBone.ProceduralRotation *= Quaternion.Euler(LeadBoneRotationOffset);
		}
		SpineBones[leadingBoneIndex].CalculateDifferencePose(ModelUpAxis, ModelRightAxis);
		SpineBones[leadingBoneIndex].ApplyDifferencePose();
	}

	private IEnumerator LateFixed()
	{
		WaitForFixedUpdate fixedWait = CoroutineEx.waitForFixedUpdate;
		lateFixedIsRunning = true;
		do
		{
			yield return fixedWait;
			PreCalibrateBones();
			fixedAllow = true;
		}
		while (lateFixedIsRunning);
	}

	public void OnDestroy()
	{
		RemovePivotOffset();
	}

	private void OnValidate()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!_CheckedPivot)
		{
			if (MainPivotOffset != Vector3.zero)
			{
				PivotOffsetOnStart = false;
			}
			_CheckedPivot = true;
		}
		if (SpineBones == null)
		{
			SpineBones = new List<SpineBone>();
		}
		if (!PivotOffsetOnStart)
		{
			UpdatePivotOffsetState();
		}
		if (UseCollisions)
		{
			CheckForColliderDuplicates();
		}
		if (UpdateRate < 0f)
		{
			UpdateRate = 0f;
		}
		ModelRightAxis = Vector3.Cross(ModelForwardAxis, ModelUpAxis);
	}

	public void AddConnector(FSpineBoneConnector connector)
	{
		if (connectors == null)
		{
			connectors = new List<FSpineBoneConnector>();
		}
		if (!connectors.Contains(connector))
		{
			connectors.Add(connector);
		}
	}

	public void Init()
	{
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		if (SpineBones.Count == 0)
		{
			if (SpineTransforms.Count <= 2)
			{
				Debug.Log((object)("[SPINE ANIMATOR] could not initialize Spine Animator inside '" + ((Object)this).name + "' because there are no bones to animate!"));
				return;
			}
			CreateSpineChain(SpineTransforms[0], SpineTransforms[SpineTransforms.Count - 1]);
			Debug.Log((object)("[SPINE ANIMATOR] Auto Bone Conversion from old version of Spine Animator! Please select your objects with Spine Animator to pre-convert it instead of automatically doing it when game Starts! (" + ((Object)this).name + ")"));
		}
		if (initialized)
		{
			Debug.Log((object)("[Spine Animator] " + ((Object)this).name + " is already initialized!"));
			return;
		}
		if ((Object)(object)BaseTransform == (Object)null)
		{
			BaseTransform = FindBaseTransform();
		}
		for (int i = 0; i < SpineBones.Count; i++)
		{
			Vector3 val = ((i != SpineBones.Count - 1) ? SpineBones[i + 1].transform.position : ((SpineBones[i].transform.childCount <= 0) ? (SpineBones[i - 1].transform.position + (SpineBones[i - 1].transform.position - SpineBones[i].transform.position)) : SpineBones[i].transform.GetChild(0).position));
			if (Vector3.Distance(SpineBones[i].transform.position, val) < 0.01f)
			{
				Vector3 val2 = SpineBones[SpineBones.Count - 1].transform.position - SpineBones[SpineBones.Count - 2].transform.parent.position;
				float magnitude = ((Vector3)(ref val2)).magnitude;
				Vector3 val3 = SpineBones[i].transform.position - BaseTransform.position;
				Vector3 val4 = BaseTransform.InverseTransformDirection(val3);
				val4.y = 0f;
				((Vector3)(ref val4)).Normalize();
				SpineBones[i + 1].DefaultForward = val4;
				SpineBones[i + 1].transform.position = SpineBones[i + 1].transform.position + BaseTransform.TransformDirection(val4) * magnitude * -0.125f;
			}
		}
		referenceDistance = 0f;
		for (int j = 0; j < SpineBones.Count; j++)
		{
			SpineBones[j].PrepareBone(BaseTransform, SpineBones, j);
			referenceDistance += SpineBones[j].BoneLength;
		}
		referenceDistance /= SpineBones.Count;
		frontHead = new HeadBone(SpineBones[0].transform);
		frontHead.PrepareBone(BaseTransform, SpineBones, 0);
		backHead = new HeadBone(SpineBones[SpineBones.Count - 1].transform);
		backHead.PrepareBone(BaseTransform, SpineBones, SpineBones.Count - 1);
		if (LastBoneLeading)
		{
			headBone = backHead;
		}
		else
		{
			headBone = frontHead;
		}
		CollidersDataToCheck = new List<FImp_ColliderData_Base>();
		chainReverseFlag = !LastBoneLeading;
		UpdateChainIndexHelperVariables();
		ReposeSpine();
		initialized = true;
	}

	public void CreateSpineChain(Transform start, Transform end)
	{
		if ((Object)(object)start == (Object)null || (Object)(object)end == (Object)null)
		{
			Debug.Log((object)"[SPINE ANIMATOR] Can't create spine chain if one of the bones is null!");
			return;
		}
		List<Transform> list = new List<Transform>();
		Transform val = end;
		while ((Object)(object)val != (Object)null && !((Object)(object)val == (Object)(object)start))
		{
			list.Add(val);
			val = val.parent;
		}
		if ((Object)(object)val == (Object)null)
		{
			Debug.Log((object)("[SPINE ANIMATOR] '" + ((Object)start).name + "' is not child of '" + ((Object)end).name + "' !"));
			return;
		}
		list.Add(start);
		list.Reverse();
		SpineBones = new List<SpineBone>();
		for (int i = 0; i < list.Count; i++)
		{
			SpineBone item = new SpineBone(list[i]);
			SpineBones.Add(item);
		}
	}

	private void PreCalibrateBones()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < SpineBones.Count; i++)
		{
			SpineBones[i].transform.localPosition = SpineBones[i].InitialLocalPosition;
			SpineBones[i].transform.localRotation = SpineBones[i].InitialLocalRotation;
		}
		if (BonesFixers.Count > 0)
		{
			for (int j = 0; j < BonesFixers.Count; j++)
			{
				BonesFixers[j].Calibration();
			}
		}
	}

	private void CalibrateBones()
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (BonesFixers.Count > 0)
		{
			for (int i = 0; i < BonesFixers.Count; i++)
			{
				BonesFixers[i].UpdateOnAnimator();
			}
		}
		if (connectors != null)
		{
			for (int j = 0; j < connectors.Count; j++)
			{
				connectors[j].RememberAnimatorState();
			}
		}
		ModelForwardAxisScaled = Vector3.Scale(ModelForwardAxis, BaseTransform.localScale);
		ModelUpAxisScaled = Vector3.Scale(ModelUpAxis, BaseTransform.localScale);
	}

	private void DeltaTimeCalculations()
	{
		switch (DeltaType)
		{
		case EFDeltaType.SafeDelta:
			delta = Mathf.Lerp(delta, GetClampedSmoothDelta(), 0.05f);
			break;
		case EFDeltaType.DeltaTime:
			delta = Time.deltaTime;
			break;
		case EFDeltaType.SmoothDeltaTime:
			delta = Time.smoothDeltaTime;
			break;
		case EFDeltaType.UnscaledDeltaTime:
			delta = Time.unscaledDeltaTime;
			break;
		case EFDeltaType.FixedDeltaTime:
			delta = Time.fixedDeltaTime;
			break;
		}
		unifiedDelta = Mathf.Pow(delta, 0.1f) * 0.04f;
	}

	private void StableUpdateRateCalculations()
	{
		updateLoops = 1;
		float num = 1f / UpdateRate;
		elapsedDeltaHelper += delta;
		updateLoops = 0;
		while (elapsedDeltaHelper >= num)
		{
			elapsedDeltaHelper -= num;
			if (++updateLoops >= 3)
			{
				elapsedDeltaHelper = 0f;
				break;
			}
		}
	}

	private void ApplyNewBonesCoordinates()
	{
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		if (SpineAnimatorAmount >= 1f)
		{
			SpineBones[leadingBoneIndex].transform.position = SpineBones[leadingBoneIndex].FinalPosition;
			SpineBones[leadingBoneIndex].transform.rotation = SpineBones[leadingBoneIndex].FinalRotation;
			for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; i++)
			{
				SpineBones[i].transform.position = SpineBones[i].FinalPosition;
				SpineBones[i].transform.rotation = SpineBones[i].FinalRotation;
				SpineBones[i].RefreshFinalLocalPose();
			}
			SpineBones[leadingBoneIndex].RefreshFinalLocalPose();
		}
		else
		{
			SpineBones[leadingBoneIndex].transform.position = Vector3.LerpUnclamped(SpineBones[leadingBoneIndex].transform.position, SpineBones[leadingBoneIndex].FinalPosition, SpineAnimatorAmount * SpineBones[leadingBoneIndex].MotionWeight);
			SpineBones[leadingBoneIndex].transform.rotation = Quaternion.LerpUnclamped(SpineBones[leadingBoneIndex].transform.rotation, SpineBones[leadingBoneIndex].FinalRotation, SpineAnimatorAmount * SpineBones[leadingBoneIndex].MotionWeight);
			for (int j = 1 - chainIndexOffset; j < SpineBones.Count - chainIndexOffset; j++)
			{
				SpineBones[j].transform.position = Vector3.LerpUnclamped(SpineBones[j].transform.position, SpineBones[j].FinalPosition, SpineAnimatorAmount * SpineBones[j].MotionWeight);
				SpineBones[j].transform.rotation = Quaternion.LerpUnclamped(SpineBones[j].transform.rotation, SpineBones[j].FinalRotation, SpineAnimatorAmount * SpineBones[j].MotionWeight);
				SpineBones[j].RefreshFinalLocalPose();
			}
			SpineBones[leadingBoneIndex].RefreshFinalLocalPose();
		}
	}

	private void EndUpdate()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		previousPos = SpineBones[leadingBoneIndex].ProceduralPosition;
		if (connectors != null)
		{
			for (int i = 0; i < connectors.Count; i++)
			{
				connectors[i].RefreshAnimatorState();
			}
		}
		if (BonesFixers.Count > 0)
		{
			for (int j = 0; j < BonesFixers.Count; j++)
			{
				BonesFixers[j].UpdateAfterProcedural();
			}
		}
	}

	public void OnDrop(PointerEventData data)
	{
	}

	public Transform FindBaseTransform()
	{
		Transform result = ((Component)this).transform;
		Transform val = ((Component)this).transform.parent;
		FSpineAnimator fSpineAnimator = null;
		if ((Object)(object)val != (Object)null)
		{
			for (int i = 0; i < 32; i++)
			{
				Transform parent = val.parent;
				fSpineAnimator = ((Component)val).GetComponent<FSpineAnimator>();
				if (Object.op_Implicit((Object)(object)fSpineAnimator))
				{
					break;
				}
				val = parent;
				if ((Object)(object)parent == (Object)null)
				{
					break;
				}
			}
		}
		if ((Object)(object)fSpineAnimator != (Object)null)
		{
			result = ((!((Object)(object)fSpineAnimator.BaseTransform != (Object)null)) ? ((Component)fSpineAnimator).transform : fSpineAnimator.BaseTransform);
			if ((Object)(object)((Component)fSpineAnimator).transform != (Object)(object)((Component)this).transform)
			{
				UpdateAsLast = true;
			}
		}
		return result;
	}

	public SpineBone GetLeadingBone()
	{
		if (SpineBones == null || SpineBones.Count == 0)
		{
			return null;
		}
		if (LastBoneLeading)
		{
			return SpineBones[SpineBones.Count - 1];
		}
		return SpineBones[0];
	}

	public SpineBone GetEndBone()
	{
		if (SpineBones == null || SpineBones.Count == 0)
		{
			return null;
		}
		if (LastBoneLeading)
		{
			return SpineBones[0];
		}
		return SpineBones[SpineBones.Count - 1];
	}

	public Transform GetHeadBone()
	{
		if (SpineBones.Count <= 0)
		{
			return ((Component)this).transform;
		}
		if (LastBoneLeading)
		{
			return SpineBones[SpineBones.Count - 1].transform;
		}
		return SpineBones[0].transform;
	}

	public SpineBone GetLeadBone()
	{
		if (LastBoneLeading)
		{
			return SpineBones[SpineBones.Count - 1];
		}
		return SpineBones[0];
	}

	public Transform GetBaseTransform()
	{
		if ((Object)(object)BaseTransform == (Object)null)
		{
			return ((Component)this).transform;
		}
		return BaseTransform;
	}

	private Vector3 RoundPosDiff(Vector3 pos, int digits = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)Math.Round(pos.x, digits), (float)Math.Round(pos.y, digits), (float)Math.Round(pos.z, digits));
	}

	private Vector3 RoundToBiggestValue(Vector3 vec)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (Mathf.Abs(vec.y) > Mathf.Abs(vec.x))
		{
			num = 1;
			if (Mathf.Abs(vec.z) > Mathf.Abs(vec.y))
			{
				num = 2;
			}
		}
		else if (Mathf.Abs(vec.z) > Mathf.Abs(vec.x))
		{
			num = 2;
		}
		switch (num)
		{
		case 0:
			((Vector3)(ref vec))..ctor(Mathf.Round(vec.x), 0f, 0f);
			break;
		case 1:
			((Vector3)(ref vec))..ctor(0f, Mathf.Round(vec.y), 0f);
			break;
		default:
			((Vector3)(ref vec))..ctor(0f, 0f, Mathf.Round(vec.z));
			break;
		}
		return vec;
	}

	private float GetClampedSmoothDelta()
	{
		return Mathf.Clamp(Time.smoothDeltaTime, 0f, 0.1f);
	}

	public List<Transform> GetOldSpineTransforms()
	{
		return SpineTransforms;
	}

	public void ClearOldSpineTransforms()
	{
		if (SpineTransforms != null)
		{
			SpineTransforms.Clear();
		}
	}

	public void User_ChangeParameter(EParamChange parameter, float to, float transitionDuration, float executionDelay = 0f)
	{
		if (transitionDuration <= 0f && executionDelay <= 0f)
		{
			SetValue(parameter, to);
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(IEChangeValue(parameter, to, transitionDuration, executionDelay));
		}
	}

	public void User_ChangeParameterAndRestore(EParamChange parameter, float to, float transitionDuration, float restoreAfter = 0f)
	{
		float value = GetValue(parameter);
		((MonoBehaviour)this).StartCoroutine(IEChangeValue(parameter, to, transitionDuration, 0f));
		((MonoBehaviour)this).StartCoroutine(IEChangeValue(parameter, value, transitionDuration, transitionDuration + restoreAfter));
	}

	public void User_ResetBones()
	{
		_ResetBones();
	}

	private IEnumerator IEChangeValue(EParamChange param, float to, float duration, float executionDelay)
	{
		if (executionDelay > 0f)
		{
			yield return CoroutineEx.waitForSeconds(executionDelay);
		}
		if (duration > 0f)
		{
			float elapsed = 0f;
			float startVal = GetValue(param);
			while (elapsed < duration)
			{
				elapsed += Time.deltaTime;
				float num = elapsed / duration;
				if (num > 1f)
				{
					num = 1f;
				}
				SetValue(param, Mathf.LerpUnclamped(startVal, to, num));
				yield return null;
			}
		}
		SetValue(param, to);
	}

	private float GetValue(EParamChange param)
	{
		return param switch
		{
			EParamChange.GoBackSpeed => GoBackSpeed, 
			EParamChange.SpineAnimatorAmount => SpineAnimatorAmount, 
			EParamChange.AngleLimit => AngleLimit, 
			EParamChange.StraightenSpeed => StraightenSpeed, 
			EParamChange.PositionSmoother => PosSmoother, 
			EParamChange.RotationSmoother => RotSmoother, 
			_ => 0f, 
		};
	}

	private void SetValue(EParamChange param, float val)
	{
		switch (param)
		{
		case EParamChange.GoBackSpeed:
			GoBackSpeed = val;
			break;
		case EParamChange.SpineAnimatorAmount:
			SpineAnimatorAmount = val;
			break;
		case EParamChange.AngleLimit:
			AngleLimit = val;
			break;
		case EParamChange.StraightenSpeed:
			StraightenSpeed = val;
			break;
		case EParamChange.PositionSmoother:
			PosSmoother = val;
			break;
		case EParamChange.RotationSmoother:
			RotSmoother = val;
			break;
		}
	}

	private void _ResetBones()
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!LastBoneLeading)
		{
			for (int num = SpineBones.Count - 1; num >= 0; num--)
			{
				SpineBones[num].ProceduralPosition = SpineBones[num].ReferencePosition;
				SpineBones[num].ProceduralRotation = SpineBones[num].ReferenceRotation;
				SpineBones[num].PreviousPosition = SpineBones[num].ReferencePosition;
				SpineBones[num].FinalPosition = SpineBones[num].ReferencePosition;
				SpineBones[num].FinalRotation = SpineBones[num].ReferenceRotation;
			}
		}
		else
		{
			for (int i = 0; i < SpineBones.Count; i++)
			{
				SpineBones[i].ProceduralPosition = SpineBones[i].ReferencePosition;
				SpineBones[i].ProceduralRotation = SpineBones[i].ReferenceRotation;
				SpineBones[i].PreviousPosition = SpineBones[i].ReferencePosition;
				SpineBones[i].FinalPosition = SpineBones[i].ReferencePosition;
				SpineBones[i].FinalRotation = SpineBones[i].ReferenceRotation;
			}
		}
		float goBackSpeed = GoBackSpeed;
		GoBackSpeed = 10f;
		Tick();
		FixedTick();
		delta = 0.25f;
		LateTick();
		GoBackSpeed = goBackSpeed;
	}

	private void Reset()
	{
		BaseTransform = FindBaseTransform();
		_CheckedPivot = true;
	}

	private void Start()
	{
		if (UpdateAsLast)
		{
			((Behaviour)this).enabled = false;
			((Behaviour)this).enabled = true;
		}
		if ((Object)(object)BaseTransform == (Object)null)
		{
			BaseTransform = ((Component)this).transform;
		}
		initialized = false;
		if (PivotOffsetOnStart && (Object)(object)mainPivotOffsetTransform == (Object)null)
		{
			UpdatePivotOffsetState();
		}
		if (!StartAfterTPose)
		{
			Init();
		}
		else
		{
			initAfterTPoseCounter = 0;
		}
	}

	internal void Tick()
	{
		TimeWarning val = TimeWarning.New("FSpineAnimator:Tick", 0);
		try
		{
			if (!initialized)
			{
				if (!StartAfterTPose)
				{
					updateSpineAnimator = false;
					return;
				}
				if (initAfterTPoseCounter <= 5)
				{
					initAfterTPoseCounter++;
					updateSpineAnimator = false;
					return;
				}
				Init();
			}
			if ((Object)(object)OptimizeWithAnimator != (Object)null && !((Behaviour)OptimizeWithAnimator).enabled)
			{
				updateSpineAnimator = false;
				return;
			}
			if (delta <= Mathf.Epsilon)
			{
				updateSpineAnimator = false;
			}
			if (SpineBones.Count == 0)
			{
				Debug.LogError((object)("[SPINE ANIMATOR] No spine bones defined in " + ((Object)this).name + " !"));
				initialized = false;
				updateSpineAnimator = false;
				return;
			}
			if ((Object)(object)BaseTransform == (Object)null)
			{
				BaseTransform = ((Component)this).transform;
			}
			UpdateChainIndexHelperVariables();
			if (SpineAnimatorAmount <= 0.01f)
			{
				wasBlendedOut = true;
				updateSpineAnimator = false;
				return;
			}
			if (wasBlendedOut)
			{
				ReposeSpine();
				wasBlendedOut = false;
			}
			updateSpineAnimator = true;
			if (AnimatePhysics == EFixedMode.None)
			{
				PreCalibrateBones();
				callSpineReposeCalculations = true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal void FixedTick()
	{
		TimeWarning val = TimeWarning.New("FSpineAnimator:FixedTick", 0);
		try
		{
			if (updateSpineAnimator && AnimatePhysics == EFixedMode.Basic)
			{
				PreCalibrateBones();
				callSpineReposeCalculations = true;
				fixedUpdated = true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal void LateTick()
	{
		TimeWarning val = TimeWarning.New("FSpineAnimator:LateTick", 0);
		try
		{
			if (!updateSpineAnimator)
			{
				return;
			}
			if (AnimatePhysics == EFixedMode.Late)
			{
				if (!lateFixedIsRunning)
				{
					((MonoBehaviour)this).StartCoroutine(LateFixed());
				}
				if (fixedAllow)
				{
					fixedAllow = false;
					callSpineReposeCalculations = true;
				}
			}
			else
			{
				if (lateFixedIsRunning)
				{
					lateFixedIsRunning = false;
				}
				if (AnimatePhysics == EFixedMode.Basic)
				{
					if (!fixedUpdated)
					{
						return;
					}
					fixedUpdated = false;
				}
			}
			CalibrateBones();
			DeltaTimeCalculations();
			if (UpdateRate > 0f)
			{
				StableUpdateRateCalculations();
				unifiedDelta = delta;
				if (UseCorrections && ManualAffectChain)
				{
					if (updateLoops > 0)
					{
						PreMotionNoHead();
					}
					PreMotionHead();
				}
				RefreshReferencePose();
				BeginBaseBonesUpdate();
				for (int i = 0; i < updateLoops; i++)
				{
					BeginPhysicsUpdate();
					if (callSpineReposeCalculations)
					{
						CalculateBonesCoordinates();
					}
				}
				if (UseCorrections && !ManualAffectChain && callSpineReposeCalculations)
				{
					if (updateLoops > 0)
					{
						PostMotionNoHead();
					}
					PostMotionHead();
				}
				if (callSpineReposeCalculations)
				{
					callSpineReposeCalculations = false;
				}
			}
			else
			{
				RefreshReferencePose();
				PreMotionBoneOffsets();
				BeginPhysicsUpdate();
				BeginBaseBonesUpdate();
				if (callSpineReposeCalculations)
				{
					CalculateBonesCoordinates();
					PostMotionBoneOffsets();
					callSpineReposeCalculations = false;
				}
			}
			ApplyNewBonesCoordinates();
			EndUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum EFSpineEditorCategory
{
	Setup,
	Tweak,
	Adjust,
	Physical
}


public enum EFDeltaType
{
	DeltaTime,
	SmoothDeltaTime,
	UnscaledDeltaTime,
	FixedDeltaTime,
	SafeDelta
}


public enum EParamChange
{
	GoBackSpeed,
	SpineAnimatorAmount,
	AngleLimit,
	StraightenSpeed,
	PositionSmoother,
	RotationSmoother
}


using System.Collections.Generic;
using UnityEngine;

public class HeadBone
{
	public Transform baseTransform;

	public Transform transform;

	private Vector3 snapshotPoseBaseTrSpacePosition;

	public Vector3 SnapshotPosition;

	private Quaternion snapshotPoseBaseTrSpaceRotationF;

	private Quaternion snapshotPoseBaseTrSpaceRotationB;

	public Quaternion snapshotPoseLocalRotation;

	public Quaternion SnapshotRotation;

	public Vector3 InitialLocalPosition { get; private set; }

	public Quaternion InitialLocalRotation { get; private set; }

	public HeadBone(Transform t)
	{
		transform = t;
	}

	public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		TakePoseSnapshot(baseTransform, bones, index);
		InitialLocalPosition = transform.localPosition;
		InitialLocalRotation = transform.localRotation;
	}

	internal Quaternion GetLocalRotationDiff()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return transform.rotation * Quaternion.Inverse(snapshotPoseLocalRotation);
	}

	public void SetCoordsForFrameForward()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
		SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationF;
	}

	public void SetCoordsForFrameBackward()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
		SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationB;
	}

	public void TakePoseSnapshot(Transform targetSpace, List<SpineBone> bones, int index)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		baseTransform = targetSpace;
		snapshotPoseBaseTrSpacePosition = targetSpace.InverseTransformPoint(transform.position);
		Vector3 val2;
		Vector3 val3;
		if (index == bones.Count - 1)
		{
			Vector3 val = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
			val2 = snapshotPoseBaseTrSpacePosition + val;
			val3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
		}
		else if (index == 0)
		{
			val2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
			Vector3 val4 = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
			val3 = snapshotPoseBaseTrSpacePosition + val4;
		}
		else
		{
			val2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
			val3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
		}
		snapshotPoseBaseTrSpaceRotationF = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(val2 - snapshotPoseBaseTrSpacePosition);
		snapshotPoseBaseTrSpaceRotationB = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(val3 - snapshotPoseBaseTrSpacePosition);
		snapshotPoseLocalRotation = Quaternion.Inverse(targetSpace.rotation) * transform.rotation;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class SpineBone
{
	public Transform transform;

	public Vector3 ProceduralPosition;

	public Quaternion ProceduralRotation;

	public Vector3 HelperDiffPosition;

	public Quaternion HelperDiffRoation;

	public Vector3 PreviousPosition;

	public Vector3 DefaultForward;

	public float StraightenFactor;

	public float TargetStraightenFactor;

	private float boneLengthB = 0.1f;

	private float boneLengthF = 0.1f;

	private Vector3 boneLocalOffsetB;

	private Vector3 boneLocalOffsetF;

	public float MotionWeight = 1f;

	public Quaternion FinalRotation;

	public Vector3 FinalPosition;

	public Vector3 ManualPosOffset;

	public Quaternion ManualRotOffset;

	public Vector3 ReferencePosition;

	public Vector3 PreviousReferencePosition;

	public Quaternion ReferenceRotation;

	private Quaternion lastKeyframeRotation;

	private Vector3 lastKeyframePosition;

	private Vector3 lastFinalLocalPosition;

	private Quaternion lastFinalLocalRotation;

	public Vector3 forward;

	public Vector3 right;

	public Vector3 up;

	public bool Collide = true;

	public float CollisionRadius = 1f;

	public Vector3 ColliderOffset = Vector3.zero;

	public float BoneLength { get; private set; }

	public Vector3 BoneLocalOffset { get; private set; }

	public Vector3 InitialLocalPosition { get; private set; }

	public Quaternion InitialLocalRotation { get; private set; }

	public void UpdateReferencePosition(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		PreviousReferencePosition = ReferencePosition;
		ReferencePosition = pos;
	}

	public void ZeroKeyframeCheck()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (lastFinalLocalRotation.QIsSame(transform.localRotation))
		{
			transform.localRotation = lastKeyframeRotation;
		}
		else
		{
			lastKeyframeRotation = transform.localRotation;
		}
		if (lastFinalLocalPosition.VIsSame(transform.localPosition))
		{
			transform.localPosition = lastKeyframePosition;
		}
		else
		{
			lastKeyframePosition = transform.localPosition;
		}
	}

	public void RefreshFinalLocalPose()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		lastFinalLocalPosition = transform.localPosition;
		lastFinalLocalRotation = transform.localRotation;
	}

	public SpineBone(Transform t)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		transform = t;
		ManualPosOffset = Vector3.zero;
		ColliderOffset = Vector3.zero;
		Collide = true;
		CollisionRadius = 1f;
	}

	public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		InitialLocalPosition = transform.localPosition;
		InitialLocalRotation = transform.localRotation;
		Vector3 val = ((index != bones.Count - 1) ? bones[index + 1].transform.position : ((bones[index].transform.childCount <= 0) ? bones[index - 1].transform.position : bones[index].transform.GetChild(0).position));
		if (index == 0)
		{
			val = bones[index + 1].transform.position;
		}
		if (Vector3.Distance(baseTransform.InverseTransformPoint(val), baseTransform.InverseTransformPoint(bones[index].transform.position)) < 0.01f)
		{
			int num = index + 2;
			if (num < bones.Count)
			{
				DefaultForward = transform.InverseTransformPoint(bones[num].transform.position);
			}
			else
			{
				DefaultForward = transform.InverseTransformPoint(val - baseTransform.position);
			}
		}
		else
		{
			DefaultForward = transform.InverseTransformPoint(val);
		}
		Vector3 val2 = baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(val);
		boneLengthB = ((Vector3)(ref val2)).magnitude;
		boneLocalOffsetB = baseTransform.InverseTransformPoint(val);
		val2 = baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(val);
		boneLengthF = ((Vector3)(ref val2)).magnitude;
		boneLocalOffsetF = baseTransform.InverseTransformPoint(val);
		if (((Vector3)(ref ManualPosOffset)).sqrMagnitude == 0f)
		{
			ManualPosOffset = Vector3.zero;
		}
		val2 = ((Quaternion)(ref ManualRotOffset)).eulerAngles;
		if (((Vector3)(ref val2)).sqrMagnitude == 0f)
		{
			ManualRotOffset = Quaternion.identity;
		}
		SetDistanceForFrameForward();
		PrepareAxes(baseTransform, bones, index);
	}

	public void SetDistanceForFrameForward()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		BoneLength = boneLengthF;
		BoneLocalOffset = boneLocalOffsetF;
	}

	public void SetDistanceForFrameBackward()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		BoneLength = boneLengthB;
		BoneLocalOffset = boneLocalOffsetB;
	}

	public float GetUnscalledBoneLength()
	{
		if (boneLengthF > boneLengthB)
		{
			return boneLengthF;
		}
		return boneLengthB;
	}

	private void PrepareAxes(Transform baseTransform, List<SpineBone> bonesList, int index)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Transform val;
		Vector3 position;
		Vector3 position2;
		if (index == bonesList.Count - 1)
		{
			if (transform.childCount == 1)
			{
				val = transform;
				Transform child = transform.GetChild(0);
				position = val.position;
				position2 = child.position;
			}
			else
			{
				val = transform;
				_ = transform;
				position = bonesList[index - 1].transform.position;
				position2 = transform.position;
			}
		}
		else
		{
			val = transform;
			Transform obj = bonesList[index + 1].transform;
			position = val.position;
			position2 = obj.position;
		}
		Vector3 val2 = val.InverseTransformDirection(position2) - val.InverseTransformDirection(position);
		Vector3 val3 = baseTransform.up;
		Vector3 val4 = transform.TransformDirection(val2);
		val4 = Vector3.ProjectOnPlane(val3, ((Vector3)(ref val4)).normalized);
		Vector3 normalized = ((Vector3)(ref val4)).normalized;
		Vector3 val5 = val.InverseTransformDirection(position + normalized) - val.InverseTransformDirection(position);
		Vector3 val6 = Vector3.Cross(transform.TransformDirection(val2), transform.TransformDirection(val5));
		Vector3 val7 = val.InverseTransformDirection(position + val6) - val.InverseTransformDirection(position);
		right = ((Vector3)(ref val7)).normalized;
		up = ((Vector3)(ref val5)).normalized;
		forward = ((Vector3)(ref val2)).normalized;
	}

	internal void CalculateDifferencePose(Vector3 upAxis, Vector3 rightAxis)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		HelperDiffPosition = ProceduralPosition - ReferencePosition;
		Quaternion val = ProceduralRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
		Quaternion val2 = ReferenceRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
		HelperDiffRoation = val * Quaternion.Inverse(val2);
	}

	internal void ApplyDifferencePose()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		FinalPosition = transform.position + HelperDiffPosition;
		FinalRotation = HelperDiffRoation * transform.rotation;
	}

	public void Editor_SetLength(float length)
	{
		if (!Application.isPlaying)
		{
			BoneLength = length;
		}
	}

	public float GetCollisionRadiusScaled()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return CollisionRadius * transform.lossyScale.x;
	}
}


public enum EFixedMode
{
	None,
	Basic,
	Late
}


using FIMSpace.FSpine;
using UnityEngine;
using UnityEngine.EventSystems;

[AddComponentMenu("FImpossible Creations/Spine Animator Utilities/FSpine Bone Connector")]
public class FSpineBoneConnector : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon
{
	[Space(5f)]
	public FSpineAnimator TargetSpineAnimator;

	public Transform TargetBone;

	[FPD_Width(130)]
	[Space(3f)]
	public bool PositionAnimated;

	[FPD_Width(130)]
	public bool RotationAnimated = true;

	[Space(3f)]
	public Vector3 RotationCorrection;

	public bool Mirror;

	private Vector3 animatorStatePosition;

	private Quaternion animatorStateRotation;

	private Quaternion targetBoneStateRotation;

	public string EditorIconPath => "Spine Animator/Spine Bone Connector Icon";

	public void OnDrop(PointerEventData data)
	{
	}

	private void Start()
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)TargetBone))
		{
			Debug.LogError((object)("No target bone in " + ((Object)this).name + " for Spine Bone Connector Component!"));
			Object.Destroy((Object)(object)this);
		}
		if (Object.op_Implicit((Object)(object)TargetSpineAnimator))
		{
			TargetSpineAnimator.AddConnector(this);
		}
		else
		{
			Debug.LogError((object)("No target SpineAnimator in " + ((Object)this).name + " for Spine Bone Connector Component!"));
			Object.Destroy((Object)(object)this);
		}
		if (!PositionAnimated)
		{
			animatorStatePosition = TargetBone.InverseTransformVector(((Component)this).transform.position - TargetBone.position);
		}
		if (!RotationAnimated)
		{
			animatorStateRotation = ((Component)this).transform.localRotation;
		}
		targetBoneStateRotation = TargetBone.localRotation;
	}

	internal void RememberAnimatorState()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (PositionAnimated)
		{
			animatorStatePosition = TargetBone.InverseTransformVector(((Component)this).transform.position - TargetBone.position);
		}
		if (RotationAnimated)
		{
			animatorStateRotation = ((Component)this).transform.localRotation;
		}
	}

	internal void RefreshAnimatorState()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)this).enabled)
		{
			((Component)this).transform.position = TargetBone.position + TargetBone.TransformVector(animatorStatePosition);
			((Component)this).transform.rotation = TargetBone.rotation * (animatorStateRotation * (Mirror ? targetBoneStateRotation : Quaternion.Inverse(targetBoneStateRotation))) * Quaternion.Euler(RotationCorrection);
		}
	}
}


using UnityEngine;

[AddComponentMenu("FImpossible Creations/Spine Animator Utilities/FSpine Draw Skeleton")]
public class FSpine_DrawSkeleton : MonoBehaviour
{
}


using FIMSpace.FSpine;
using UnityEngine;

public class FSpine_Reference : MonoBehaviour
{
	public FSpineAnimator SpineReference;
}


using System.Collections.Generic;
using FIMSpace.FSpine;
using UnityEngine;

[DefaultExecutionOrder(-12)]
[AddComponentMenu("FImpossible Creations/Spine Animator Utilities/Spine Animator Queuer")]
public class SpineAnimatorQueuer : MonoBehaviour
{
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Can be used to fade out all spine animators")]
	public float SpineAnimatorsAmount = 1f;

	[SerializeField]
	internal List<FSpineAnimator> updateOrder;

	private void Update()
	{
		for (int num = updateOrder.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)updateOrder[num] == (Object)null)
			{
				updateOrder.RemoveAt(num);
			}
			else
			{
				if (((Behaviour)updateOrder[num]).enabled)
				{
					((Behaviour)updateOrder[num]).enabled = false;
				}
				updateOrder[num].Tick();
			}
		}
	}

	private void FixedUpdate()
	{
		for (int num = updateOrder.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)updateOrder[num] == (Object)null)
			{
				updateOrder.RemoveAt(num);
			}
			else
			{
				if (((Behaviour)updateOrder[num]).enabled)
				{
					((Behaviour)updateOrder[num]).enabled = false;
				}
				updateOrder[num].FixedTick();
			}
		}
	}

	private void LateUpdate()
	{
		for (int i = 0; i < updateOrder.Count; i++)
		{
			if (SpineAnimatorsAmount < 1f)
			{
				updateOrder[i].SpineAnimatorAmount = SpineAnimatorsAmount;
			}
			updateOrder[i].LateTick();
		}
	}
}


using FIMSpace;
using UnityEngine;

[DefaultExecutionOrder(-12)]
[AddComponentMenu("FImpossible Creations/Spine Animator Utilities/Spine Animator IK Controlled Bone Fixer")]
public class SpineAnimator_FixIKControlledBones : MonoBehaviour
{
	public Transform SkeletonParentBone;

	[Tooltip("If bones are twisting with this option off you should turn it on (calibrating bone if it's animation don't use keyframes)")]
	public bool Calibrate = true;

	private Quaternion initLocalRot;

	private Vector3 initLocalPos;

	private Quaternion localRotation;

	private Vector3 localPosition;

	private void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		initLocalPos = ((Component)this).transform.localPosition;
		initLocalRot = ((Component)this).transform.localRotation;
	}

	public void Calibration()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (Calibrate)
		{
			((Component)this).transform.localPosition = initLocalPos;
			((Component)this).transform.localRotation = initLocalRot;
		}
	}

	public void UpdateOnAnimator()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)this).enabled)
		{
			localRotation = SkeletonParentBone.rotation.QToLocal(((Component)this).transform.rotation);
			localPosition = SkeletonParentBone.InverseTransformPoint(((Component)this).transform.position);
		}
	}

	public void UpdateAfterProcedural()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((Behaviour)this).enabled)
		{
			((Component)this).transform.rotation = SkeletonParentBone.rotation.QToWorld(localRotation);
			((Component)this).transform.position = SkeletonParentBone.TransformPoint(localPosition);
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FLook;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.EventSystems;

[DefaultExecutionOrder(-10)]
[AddComponentMenu("FImpossible Creations/Look Animator 2")]
public class FLookAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon, IClientComponent
{
	[Serializable]
	public class CompensationBone
	{
		public Transform Transform;

		private Vector3 compensatedPosition;

		private Quaternion compensatedRotation;

		private Quaternion lastFinalLocalRotation;

		private Quaternion lastKeyframeLocalRotation;

		private Vector3 lastFinalLocalPosition;

		private Vector3 lastKeyframeLocalPosition;

		public CompensationBone(Transform t)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			Transform = t;
			if (Object.op_Implicit((Object)(object)t))
			{
				lastKeyframeLocalPosition = t.localPosition;
				lastKeyframeLocalRotation = t.localRotation;
			}
		}

		public void RefreshCompensationFrame()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			compensatedPosition = Transform.position;
			compensatedRotation = Transform.rotation;
		}

		public void CheckForZeroKeyframes()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			if (lastFinalLocalRotation.QIsSame(Transform.localRotation))
			{
				Transform.localRotation = lastKeyframeLocalRotation;
				compensatedRotation = Transform.rotation;
			}
			else
			{
				lastKeyframeLocalRotation = Transform.localRotation;
			}
			if (lastFinalLocalPosition.VIsSame(Transform.localPosition))
			{
				Transform.localPosition = lastKeyframeLocalPosition;
				compensatedPosition = Transform.position;
			}
			else
			{
				lastKeyframeLocalPosition = Transform.localPosition;
			}
		}

		public void SetRotationCompensation(float weight)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			if (weight > 0f)
			{
				if (weight >= 1f)
				{
					Transform.rotation = compensatedRotation;
				}
				else
				{
					Transform.rotation = Quaternion.LerpUnclamped(Transform.rotation, compensatedRotation, weight);
				}
				lastFinalLocalRotation = Transform.localRotation;
			}
		}

		public void SetPositionCompensation(float weight)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			if (weight > 0f)
			{
				if (weight >= 1f)
				{
					Transform.position = compensatedPosition;
				}
				else
				{
					Transform.position = Vector3.LerpUnclamped(Transform.position, compensatedPosition, weight);
				}
				lastFinalLocalPosition = Transform.localPosition;
			}
		}
	}

	[Serializable]
	public class LookBone
	{
		public Transform Transform;

		public Quaternion animatedStaticRotation;

		public Quaternion targetStaticRotation;

		public Quaternion localStaticRotation;

		public Quaternion animatedTargetRotation;

		public Quaternion targetRotation;

		public Vector3 correctionOffset;

		public Quaternion finalRotation;

		public Quaternion lastKeyframeRotation;

		public Quaternion lastFinalLocalRotation;

		public Vector3 forward;

		public Vector3 right;

		public Vector3 up;

		public Vector3 initLocalPos = Vector3.zero;

		public Quaternion initLocalRot = Quaternion.identity;

		public Vector3 targetDelayPosition;

		public Vector3 animatedDelayPosition;

		public float lookWeight = 1f;

		public float lookWeightB = 1f;

		public float motionWeight = 1f;

		public Quaternion correctionOffsetQ => Quaternion.Euler(correctionOffset);

		public LookBone(Transform t)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			Transform = t;
			correctionOffset = Vector3.zero;
			if ((Object)(object)t != (Object)null)
			{
				initLocalPos = t.localPosition;
				initLocalRot = t.localRotation;
			}
		}

		public void RefreshBoneDirections(Transform baseTransform)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)Transform == (Object)null))
			{
				forward = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.forward), Vector3.forward) * Vector3.forward;
				up = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.up), Vector3.up) * Vector3.up;
				right = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.right), Vector3.right) * Vector3.right;
			}
		}

		public void RefreshStaticRotation(bool hard = true)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			targetStaticRotation = Transform.rotation;
			if (initLocalPos == Vector3.zero)
			{
				initLocalPos = Transform.localPosition;
			}
			if (hard)
			{
				animatedStaticRotation = targetStaticRotation;
			}
			localStaticRotation = Transform.localRotation;
		}

		internal void CalculateMotion(Quaternion targetLook, float overallWeightMultiplier, float delta, float mainWeight)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			targetRotation = GetTargetRot(targetLook, motionWeight * overallWeightMultiplier);
			if (delta < 1f)
			{
				animatedTargetRotation = Quaternion.LerpUnclamped(animatedTargetRotation, targetRotation, delta);
			}
			else
			{
				animatedTargetRotation = targetRotation;
			}
			finalRotation = Quaternion.LerpUnclamped(Transform.rotation, animatedTargetRotation * Transform.rotation, mainWeight);
		}

		internal Quaternion GetTargetRot(Quaternion targetLook, float weight)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Quaternion.LerpUnclamped(Quaternion.identity, targetLook, weight);
		}
	}

	public enum EEditorLookCategory
	{
		Setup,
		Tweak,
		Limit,
		Features,
		Corrections
	}

	public enum EFAxisFixOrder
	{
		Parental,
		FromBased,
		FullManual,
		ZYX
	}

	public enum EFHeadLookState
	{
		Null,
		Following,
		OutOfMaxRotation,
		ClampedAngle,
		OutOfMaxDistance
	}

	public enum EFFollowMode
	{
		FollowObject,
		LocalOffset,
		WorldOffset,
		ToFollowSpaceOffset,
		FollowJustPosition
	}

	public enum EFDeltaType
	{
		DeltaTime,
		SmoothDeltaTime,
		UnscaledDeltaTime,
		FixedDeltaTime
	}

	public enum EFAnimationStyle
	{
		SmoothDamp,
		FastLerp,
		Linear
	}

	private static ListHashSet<FLookAnimator> components = new ListHashSet<FLookAnimator>();

	private GameObject generatedMomentTarget;

	private bool wasMomentLookTransform;

	[Tooltip("Enabling laggy movement for head and delaying position")]
	public bool BirdMode;

	private bool birdModeInitialized;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Bird mode laggy movement for neck amount, lowering this value will cause crossfade motion of laggy movement and basic follow rotation")]
	public float LagRotation = 0.85f;

	[Tooltip("How often should be acquired new target position for laggy movement, time to trigger it will be slightly randomized")]
	[FPD_Suffix(0.1f, 1f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float LagEvery = 0.285f;

	[Tooltip("Bird mode keeping previous position until distance is reached")]
	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	public float DelayPosition;

	[Tooltip("How far distance to go back should have head to move (remind movement of pigeons to yourself)")]
	public float DelayMaxDistance = 0.25111f;

	[Range(0f, 1f)]
	[Tooltip("How quick head and neck should go back to right position after reaching distance")]
	public float DelayGoSpeed = 0.6f;

	public Vector3 BirdTargetPosition = Vector3.forward;

	private Vector3 birdTargetPositionMemory = Vector3.forward;

	private float lagTimer;

	private float preWeightFaloff = -1f;

	private float[] baseWeights;

	private float[] targetWeights;

	public bool UseEyes;

	[Tooltip("Target on which eyes will look, set to null if target should be the same as for head target")]
	public Transform EyesTarget;

	[Space(4f)]
	[Tooltip("Eyes transforms / bones (origin should be in center of the sphere")]
	public Transform LeftEye;

	public bool InvertLeftEye;

	[Tooltip("Eyes transforms / bones (origin should be in center of the sphere")]
	public Transform RightEye;

	public bool InvertRightEye;

	[Tooltip("Look clamping reference rotation transform, mostly parent of eye objects. If nothing is assigned then algorithm will use 'Lead Bone' as reference.")]
	public Transform HeadReference;

	public Vector3 EyesOffsetRotation;

	public Vector3 LeftEyeOffsetRotation = Vector3.zero;

	public Vector3 RightEyeOffsetRotation = Vector3.zero;

	[Tooltip("How fast eyes should follow target")]
	[Range(0f, 1f)]
	public float EyesSpeed = 0.5f;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	public float EyesBlend = 1f;

	[Tooltip("In what angle eyes should go back to deafult position")]
	[Range(0f, 180f)]
	public Vector2 EyesXRange = new Vector2(-60f, 60f);

	public Vector2 EyesYRange = new Vector2(-50f, 50f);

	[Tooltip("If your eyes don't have baked keyframes in animation this value should be enabled, otherwise eyes would go crazy")]
	public bool EyesNoKeyframes = true;

	public bool CustomEyesLogics;

	private float EyesOutOfRangeBlend = 1f;

	private Transform[] eyes;

	private Vector3[] eyeForwards;

	private Quaternion[] eyesInitLocalRotations;

	private Quaternion[] eyesLerpRotations;

	private float _eyesBlend;

	private Vector3 headForward;

	[Tooltip("When switching targets character will make small nod to make it look more natural, set higher value for toony effect")]
	[Range(-1f, 1f)]
	public float NoddingTransitions;

	public Vector3 NodAxis = Vector3.right;

	[Tooltip("Set zero to use only leading bone, set -1 to 1 to spread this motion over backbones")]
	[Range(-1f, 1f)]
	public float BackBonesNod = 0.15f;

	private float nodProgress;

	private float nodValue;

	private float nodPower;

	private float nodDuration = 1f;

	private float smoothingTimer;

	private float smoothingPower = 1f;

	private float smoothingTime = 1f;

	private float smoothingEffect = 1f;

	public int ParentalOffsetsV = 2;

	private Vector3 lookFreezeFocusPoint;

	private Vector3 smoothLookPosition = Vector3.zero;

	private Vector3 _velo_smoothLookPosition = Vector3.zero;

	private Vector3 finalLookPosition = Vector3.zero;

	private bool usingAxisCorrection;

	private Matrix4x4 axisCorrectionMatrix;

	private float delta;

	[Tooltip("If your neck bones are rotated in a wrong way, you can try putting here parent game object of last back bone in chain")]
	public Transform ParentalReferenceBone;

	private Quaternion _parentalBackParentRot;

	private Vector2 _parentalAngles = Vector2.zero;

	private bool animatePhysicsWorking;

	private bool triggerAnimatePhysics;

	private int startAfterTPoseCounter;

	private Vector3 unclampedLookAngles = Vector3.zero;

	private Vector3 targetLookAngles = Vector3.zero;

	private Vector3 animatedLookAngles = Vector3.zero;

	private Vector3 finalLookAngles = Vector3.zero;

	private Quaternion lastBaseRotation;

	private Vector3 _preLookAboveLookAngles = Vector3.zero;

	private Vector3 _velo_animatedLookAngles = Vector3.zero;

	private float _rememberSideLookHorizontalAngle;

	private Vector3 leadBoneInitLocalOffset = Vector3.zero;

	private EFHeadLookState previousState;

	private bool _stopLooking;

	private Transform activeLookTarget;

	private Vector3 activeLookPosition;

	private Transform preActiveLookTarget;

	private bool isLooking;

	[Tooltip("If moment transform should be destroyed when max distance range is exceed")]
	public bool DestroyMomentTargetOnMaxDistance = true;

	private float whenAboveGoBackDuration;

	private float whenAboveGoBackTimer;

	private float _whenAboveGoBackVelo;

	private float _whenAboveGoBackVerticalVelo;

	private Vector2 whenAboveGoBackAngles;

	[Range(0f, 1f)]
	[Tooltip("If you want to remove animator's keyframes and replace them by look animation")]
	public float OverrideRotations;

	private bool overrideRefInitialized;

	private UniRotateBone headOv;

	private int lastClipHash;

	private bool refreshReferencePose;

	private float monitorTransitionTime = 0.8f;

	private List<Quaternion> _monitorTransitionStart;

	public int BackBonesCount;

	public int _preBackBonesCount;

	public List<LookBone> LookBones;

	[Tooltip("When target to follow is null then head will stop moving instead of going back to look in forward direction")]
	public bool NoTargetHeadStops;

	private Quaternion targetLookRotation;

	private float finalMotionWeight = 1f;

	private float animatedMotionWeight = 1f;

	private float _velo_animatedMotionWeight = 1f;

	private float changeTargetSmootherWeight;

	private float changeTargetSmootherBones;

	private Vector3 preLookDir;

	public bool _editor_hideEyes;

	public string _editor_displayName = "Look Animator 2";

	public EEditorLookCategory _Editor_Category;

	[Tooltip("Lead / Head bone - head of look chain")]
	public Transform LeadBone;

	[Tooltip("Base root transform - object which moves / rotates - character transform / game object")]
	public Transform BaseTransform;

	[Tooltip("Faloff value of how weight of animation should be spread over bones")]
	public float FaloffValue = 0.35f;

	public float FaloffValueB = 1.1f;

	[Tooltip("When character is looking far back in big angle or far high, you can automate weights falloff value")]
	public bool BigAngleAutomation;

	[Tooltip("When character is looking far back in big angle or far high, you can automate compensation values")]
	public bool BigAngleAutomationCompensation;

	[Tooltip("If bone weights spread should be computed automatically or by hand")]
	public bool AutoBackbonesWeights = true;

	[Tooltip("When you want use curve for more custom falloff or define it by simple slider - 'FaloffValue'")]
	public bool CurveSpread;

	[Tooltip("Configurable rotation weight placed over back bones - when you will use for example spine bones, here you can define how much will they rotate towards target in reference to other animated bones")]
	public AnimationCurve BackBonesFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0.1f);

	[Header("bone is rotated by script (drag & drop here)", order = 3)]
	[Header("If you don't want arms to be rotated when spine", order = 1)]
	public List<CompensationBone> CompensationBones = new List<CompensationBone>();

	[Range(0f, 1f)]
	public float CompensationWeight = 0.5f;

	[Range(0f, 1f)]
	public float CompensationWeightB = 0.5f;

	[Range(0f, 1f)]
	public float CompensatePositions;

	[Range(0f, 1f)]
	public float CompensatePositionsB;

	private float targetCompensationWeight = 0.5f;

	private float targetCompensationPosWeight;

	[Tooltip("Making script start after first frame so initialization will not catch TPose initial bones rotations, which can cause some wrong offsets for rotations")]
	public bool StartAfterTPose = true;

	[Tooltip("Update with waiting for fixed update clock")]
	public bool AnimatePhysics;

	[Tooltip("If you want look animator to stop computing when choosed animator is not enabled")]
	public Animator OptimizeWithAnimator;

	[Tooltip("Object which will be main target of look.\n\nYou can use feature called 'Moment Target' to look at other object for a moment then look back on ObjectToFollow - check LookAnimator.SetMomentLookTarget()")]
	public Transform ObjectToFollow;

	[Tooltip("Position offset on 'ObjectToFollow'")]
	public Vector3 FollowOffset;

	[Tooltip("If 'FollowOffset' should be world position translation\n\nor target object local space translation\n\nor we don't want to use ObjectToFollow and use just 'FollowOffset' position.")]
	public EFFollowMode FollowMode;

	[Tooltip("How fast character should rotate towards focus direction.\n\nRotationSpeed = 2.5 -> Instant rotation\n\nIt is speed of transition for look direction (no bones rotations smoothing)")]
	[Range(0f, 2.5f)]
	public float RotationSpeed = 0.65f;

	private bool instantRotation;

	[Tooltip("This variable is making rotation animation become very smooth (but also slower).\nIt is enabling smooth rotation transition in bone rotations")]
	[Range(0f, 1f)]
	public float UltraSmoother;

	[Tooltip("If target is too much after transform's back we smooth rotating head back to default animation's rotation")]
	[Range(25f, 180f)]
	[Header("Look forward if this angle is exceeded", order = 1)]
	public float StopLookingAbove = 180f;

	[Range(0.1f, 1f)]
	[Tooltip("If object in rotation range should be detected only when is nearer than 'StopLookingAbove' to avoid stuttery target changes")]
	public float StopLookingAboveFactor = 1f;

	[Range(0f, 1f)]
	[Tooltip("If your character moves head too fast when loosing / changing target, here you can adjust it")]
	public float ChangeTargetSmoothing;

	[Tooltip("Switch to enable advanced settings for back bones falloff")]
	public bool AdvancedFalloff;

	[Tooltip("Max distance to target object to lost interest in it.\nValue = 0 -> Not using distance limits.\nWhen you have moment target - after exceeding distance moment target will be forgotten!")]
	public float MaximumDistance;

	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("When Character is looking at something on his back but more on his right he look to right, when target suddenly goes more on his left and again to right very frequently you can set with this variable range from which rotating head to opposide shoulder side should be triggered to prevent strange looking behaviour when looking at dynamic objects")]
	public float HoldRotateToOppositeUntil;

	[Range(0f, 1f)]
	[Tooltip("If object in range should be detected only when is nearer than 'MaxDistance' to avoid stuttery target changes")]
	public float MaxOutDistanceFactor;

	[Tooltip("If distance should be measured not using Up (y) axis")]
	public bool Distance2D;

	[Tooltip("Offsetting point from which we want to measure distance to target")]
	public Vector3 DistanceMeasurePoint;

	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Minimum angle needed to trigger head follow movement. Can be useful to make eyes move first and then head when angle is bigger")]
	public float LookWhenAbove;

	private float animatedLookWhenAbove;

	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Separated start look angle for vertical look axis\n\nWhen Zero it will have same value as 'LookWhenAbove'")]
	public float LookWhenAboveVertical;

	private float animatedLookWhenAboveVertical;

	[FPD_Suffix(0f, 3f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	[Tooltip("Head going back looking in front of target after this amount of seconds")]
	public float WhenAboveGoBackAfter;

	[Tooltip("Head going back looking in front of target after this amount of seconds")]
	[FPD_Suffix(0f, 3f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float WhenAboveGoBackAfterVertical;

	[FPD_Suffix(0.05f, 1f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	[Tooltip("Head going back looking in front of target after this amount of seconds")]
	public float WhenAboveGoBackDuration = 0.2f;

	[Tooltip("Rotating towards target slower when target don't need much angle to look at")]
	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float StartLookElasticRangeX;

	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Separated elastic start angle for vertical look axis\n\nIf zero then value will be same like 'StartLookElasticRange'")]
	public float StartLookElasticRangeY;

	[Header("Limits for rotation | Horizontal: X Vertical: Y")]
	public Vector2 XRotationLimits = new Vector2(-80f, 80f);

	[Tooltip("Making clamp ranges elastic, so when it starts to reach clamp value it slows like muscles needs more effort")]
	[FPD_Suffix(0f, 60f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float XElasticRange = 20f;

	[Tooltip("When head want go back to default state of looking, it will blend with default animation instead of changing values of rotation variables to go back")]
	public bool LimitHolder = true;

	public Vector2 YRotationLimits = new Vector2(-50f, 50f);

	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Making clamp ranges elastic, so when it starts to reach clamp value it slows like muscles needs more effort")]
	public float YElasticRange = 15f;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	[Tooltip("You can use this variable to blend intensity of look animator motion over skeleton animation\n\nValue = 1: Animation with Look Animator motion\nValue = 0: Only skeleton animation")]
	public float LookAnimatorAmount = 1f;

	[Tooltip("If head look seems to be calculated like it is not looking from center of head but far from bottom or over it - you can adjust it - check scene view gizmos")]
	public Vector3 StartLookPointOffset;

	[Tooltip("Freezes reference start look position in x and z axes to avoid re-reaching max rotation limits when hips etc. are rotating in animation clip.\n\nIf your character is crouching or so, you would like to have this parameter disabled")]
	public bool AnchorStartLookPoint = true;

	[Tooltip("In some cases you'll want to refresh anchor position during gameplay to make it more fitting to character's animation poses")]
	public bool RefreshStartLookPoint = true;

	[Tooltip("[When some of your bones are rotating making circles]\n\nDon't set hard rotations for bones, use animation rotation and add rotation offset to bones so animation's rotations are animated correctly (useful when using attack animations for example)")]
	public bool SyncWithAnimator = true;

	[Tooltip("When using above action, we need to keep remembered rotations of animation clip from first frame, with monitoring we will remember root rotations from each new animation played")]
	public bool MonitorAnimator;

	private Quaternion rootStaticRotation;

	[Tooltip("When you want create strange effects - this variable will overrotate bones")]
	[FPD_Percentage(0f, 3f, true, true, "%", false)]
	public float WeightsMultiplier = 1f;

	[Tooltip("If speed of looking toward target should be limited then lower this value")]
	[Range(0.1f, 2.5f)]
	public float MaxRotationSpeed = 2.5f;

	[Range(0f, 1f)]
	[Tooltip("When character is rotating and head is rotating with it instead of keep focusing on target, change this value higher")]
	public float BaseRotationCompensation;

	[Tooltip("If your skeleton have not animated keyframes in animation clip then bones would start doing circles with this option disabled\n\nIn most cases all keyframes are filled, if you're sure for baked keyframes you can disable this option to avoid some not needed calculations")]
	public bool DetectZeroKeyframes = true;

	[Range(0f, 1f)]
	[Tooltip("Target position to look can be smoothed out instead of immediate position changes")]
	public float LookAtPositionSmoother;

	[Tooltip("Delta Time for Look Animator calculations")]
	public EFDeltaType DeltaType;

	[Tooltip("Multiplier for delta time resulting in changed speed of calculations for Look Animator")]
	public float SimulationSpeed = 1f;

	[Tooltip("It will make head animation stiff but perfectly looking at target")]
	[Range(0f, 1f)]
	public float OverrideHeadForPerfectLookDirection;

	[Tooltip("Resetting bones before animators update to avoid bones twisting if bones are not animated using unity animator")]
	public bool Calibration = true;

	[Tooltip("With crazy flipped axes from models done in different modelling softwares, sometimes you have to change axes order for Quaternion.LookRotation to work correctly")]
	public EFAxisFixOrder FixingPreset;

	[Tooltip("If your model is not facing 'Z' axis (blue) you can adjust it with this value")]
	public Vector3 ModelForwardAxis = Vector3.forward;

	[Tooltip("If your model is not pointing up 'Y' axis (green) you can adjust it with this value")]
	public Vector3 ModelUpAxis = Vector3.up;

	[Tooltip("Defines model specific bones orientation in order to fix Quaternion.LookRotation axis usage")]
	public Vector3 ManualFromAxis = Vector3.forward;

	public Vector3 ManualToAxis = Vector3.forward;

	public Vector3 FromAuto;

	public Vector3 OffsetAuto;

	public Vector3 parentalReferenceLookForward;

	public Vector3 parentalReferenceUp;

	public Vector3 DynamicReferenceUp;

	[Tooltip("Additional degrees of rotations for head look - for simple correction, sometimes you have just to rotate head in y axis by 90 degrees")]
	public Vector3 RotationOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("Additional degrees of rotations for backones - for example when you have wolf and his neck is going up in comparison to keyfarmed animation\nVariable name 'BackBonesAddOffset'")]
	public Vector3 BackBonesAddOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("[ADVANCED] Axes multiplier for custom fixing flipped armature rotations")]
	public Vector3 RotCorrectionMultiplier = new Vector3(1f, 1f, 1f);

	[Tooltip("View debug rays in scene window")]
	public bool DebugRays;

	[Tooltip("Animation curve mode for rotating toward target")]
	public EFAnimationStyle AnimationStyle;

	[Tooltip("Updating reference axis for parental look rotation mode every frame")]
	public bool ConstantParentalAxisUpdate = true;

	private bool updateLookAnimator = true;

	private bool wasUpdating;

	public Transform MomentLookTransform { get; private set; }

	public EFHeadLookState LookState { get; protected set; }

	public bool initialized { get; protected set; }

	public string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Look Animator/LookAnimator_SmallIcon";
		}
	}

	public bool UseBoneOffsetRotation => SyncWithAnimator;

	[Obsolete("Use LookAnimatorAmount instead, but remember that it works in reversed way -> LookAnimatorAmount 1 = BlendToOriginal 0  and  LookAnimatorAmount 0 = BlendToOriginal 1, simply you can replace it by using '1 - LookAnimatorAmount'")]
	public float BlendToOriginal
	{
		get
		{
			return 1f - LookAnimatorAmount;
		}
		set
		{
			LookAnimatorAmount = 1f - value;
		}
	}

	[Obsolete("Now using StartLookPointOffset as more responsive naming")]
	public Vector3 LookReferenceOffset
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return StartLookPointOffset;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			StartLookPointOffset = value;
		}
	}

	[Obsolete("Now using AnchorStartLookPoint as more responsive naming")]
	public bool AnchorReferencePoint
	{
		get
		{
			return AnchorStartLookPoint;
		}
		set
		{
			AnchorStartLookPoint = value;
		}
	}

	[Obsolete("Now using RefreshStartLookPoint as more responsive naming")]
	public bool RefreshAnchor
	{
		get
		{
			return RefreshStartLookPoint;
		}
		set
		{
			RefreshStartLookPoint = value;
		}
	}

	[Obsolete("Now using LookWhenAbove as more responsive naming")]
	public float MinHeadLookAngle
	{
		get
		{
			return LookWhenAbove;
		}
		set
		{
			LookWhenAbove = value;
		}
	}

	[Obsolete("Now using StopLookingAbove as more responsive naming")]
	public float MaxRotationDiffrence
	{
		get
		{
			return StopLookingAbove;
		}
		set
		{
			StopLookingAbove = value;
		}
	}

	[Obsolete("Now using SyncWithAnimator as more responsive naming")]
	public bool AnimateWithSource
	{
		get
		{
			return SyncWithAnimator;
		}
		set
		{
			SyncWithAnimator = value;
		}
	}

	private void OnEnable()
	{
		components.TryAdd(this);
	}

	private void OnDisable()
	{
		wasUpdating = false;
		animatePhysicsWorking = false;
		components.Remove(this);
	}

	public static void TickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			FLookAnimator fLookAnimator = components[num];
			if (fLookAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				fLookAnimator.Tick();
			}
		}
	}

	public static void LateTickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			FLookAnimator fLookAnimator = components[num];
			if (fLookAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				fLookAnimator.LateTick();
			}
		}
	}

	public static void FixedTickAll()
	{
		for (int num = components.Count - 1; num >= 0; num--)
		{
			FLookAnimator fLookAnimator = components[num];
			if (fLookAnimator.IsUnityNull())
			{
				components.RemoveAt(num);
			}
			else
			{
				fLookAnimator.FixedTick();
			}
		}
	}

	public void SwitchLooking(bool? enableLooking = null, float transitionTime = 0.2f, Action callback = null)
	{
		bool enableAnimation = true;
		if (!enableLooking.HasValue)
		{
			if (LookAnimatorAmount > 0.5f)
			{
				enableAnimation = false;
			}
		}
		else if (enableLooking == false)
		{
			enableAnimation = false;
		}
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).StartCoroutine(SwitchLookingTransition(transitionTime, enableAnimation, callback));
	}

	public void SwitchLooking(bool enable = true)
	{
		SwitchLooking(enable, 0.5f);
	}

	public void SetLookTarget(Transform transform)
	{
		ObjectToFollow = transform;
		MomentLookTransform = null;
	}

	public void SetLookPosition(Vector3 targetPosition)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		FollowMode = EFFollowMode.FollowJustPosition;
		FollowOffset = targetPosition;
	}

	public Vector2 GetUnclampedLookAngles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(unclampedLookAngles);
	}

	public Vector2 GetLookAngles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(animatedLookAngles);
	}

	public Vector2 GetTargetLookAngles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(targetLookAngles);
	}

	public EFHeadLookState GetCurrentLookState()
	{
		return LookState;
	}

	public Vector2 ComputeAnglesTowards(Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPosition - GetLookStartMeasurePosition();
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Quaternion val3;
		if (usingAxisCorrection)
		{
			Matrix4x4 inverse = ((Matrix4x4)(ref axisCorrectionMatrix)).inverse;
			val = ((Matrix4x4)(ref inverse)).MultiplyVector(normalized);
			normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = normalized;
			val = ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(ModelUpAxis);
			val3 = Quaternion.LookRotation(val2, ((Vector3)(ref val)).normalized);
			normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
		}
		else
		{
			normalized = BaseTransform.InverseTransformDirection(normalized);
			val3 = Quaternion.LookRotation(normalized, BaseTransform.TransformDirection(ModelUpAxis));
			normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
		}
		return Vector2.op_Implicit(normalized);
	}

	public GameObject SetMomentLookTarget(Transform parent = null, Vector3? position = null, float? destroyTimer = null, bool worldPosition = false)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Expected O, but got Unknown
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Expected O, but got Unknown
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		_ = MomentLookTransform;
		if (Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			_ = MomentLookTransform.parent;
		}
		GameObject val;
		if (!destroyTimer.HasValue)
		{
			if (!Object.op_Implicit((Object)(object)generatedMomentTarget))
			{
				generatedMomentTarget = new GameObject(((Object)((Component)((Component)this).transform).gameObject).name + "-MomentLookTarget " + Time.frameCount);
			}
			else
			{
				((Object)generatedMomentTarget).name = ((Object)((Component)((Component)this).transform).gameObject).name + "-MomentLookTarget " + Time.frameCount;
			}
			val = generatedMomentTarget;
		}
		else
		{
			val = new GameObject(((Object)((Component)((Component)this).transform).gameObject).name + "-MomentLookTarget " + Time.frameCount);
		}
		if ((Object)(object)parent != (Object)null)
		{
			val.transform.SetParent(parent);
			if (position.HasValue)
			{
				if (worldPosition)
				{
					val.transform.position = position.Value;
				}
				else
				{
					val.transform.localPosition = position.Value;
				}
			}
			else
			{
				val.transform.localPosition = Vector3.zero;
			}
		}
		else if (position.HasValue)
		{
			val.transform.position = position.Value;
		}
		MomentLookTransform = val.transform;
		wasMomentLookTransform = true;
		TargetChangedMeasures();
		if (destroyTimer.HasValue)
		{
			Object.Destroy((Object)(object)val, destroyTimer.Value);
		}
		return val;
	}

	public void SetMomentLookTransform(Transform transform, float timeToLeft = 0f)
	{
		MomentLookTransform = transform;
		wasMomentLookTransform = true;
		TargetChangedMeasures();
		if (timeToLeft > 0f)
		{
			((MonoBehaviour)this).StartCoroutine(CResetMomentLookTransform(null, timeToLeft));
		}
	}

	public void ForceDestroyMomentTarget()
	{
		if (Object.op_Implicit((Object)(object)generatedMomentTarget))
		{
			Object.Destroy((Object)(object)generatedMomentTarget);
		}
		else if (Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			MomentLookTransform = null;
		}
	}

	private void InitBirdMode()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!birdModeInitialized)
		{
			lagTimer = 0f;
			birdTargetPositionMemory = GetLookAtPosition();
			BirdTargetPosition = birdTargetPositionMemory;
			birdModeInitialized = true;
		}
	}

	private void CalculateBirdMode()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		lagTimer -= delta;
		if (lagTimer < 0f)
		{
			birdTargetPositionMemory = smoothLookPosition;
		}
		if (LagRotation >= 1f)
		{
			BirdTargetPosition = birdTargetPositionMemory;
		}
		else
		{
			BirdTargetPosition = Vector3.Lerp(smoothLookPosition, birdTargetPositionMemory, LagRotation);
		}
		if (lagTimer < 0f)
		{
			lagTimer = Random.Range(LagEvery * 0.85f, LagEvery * 1.15f);
		}
		if (!(DelayPosition > 0f))
		{
			return;
		}
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].Transform.localPosition = LookBones[i].initLocalPos;
		}
		float num = Vector3.Distance(Vector3.Scale(LookBones[0].targetDelayPosition, new Vector3(1f, 0f, 1f)), Vector3.Scale(LeadBone.position, new Vector3(1f, 0f, 1f)));
		float num2 = Mathf.Abs(LookBones[0].targetDelayPosition.y - LeadBone.position.y);
		if (num > DelayMaxDistance || num2 > DelayMaxDistance / 1.65f)
		{
			for (int num3 = LookBones.Count - 1; num3 >= 0; num3--)
			{
				LookBones[num3].targetDelayPosition = LookBones[num3].Transform.position;
			}
		}
		for (int num4 = LookBones.Count - 1; num4 >= 0; num4--)
		{
			LookBones[num4].animatedDelayPosition = Vector3.Lerp(LookBones[num4].animatedDelayPosition, LookBones[num4].targetDelayPosition, delta * Mathf.Lerp(5f, 30f, DelayGoSpeed));
			LookBones[num4].Transform.position = Vector3.Lerp(LookBones[num4].Transform.position, LookBones[num4].animatedDelayPosition, LookBones[num4].lookWeight * DelayPosition * finalMotionWeight);
		}
	}

	public void SetAutoWeightsDefault()
	{
		CalculateRotationWeights(FaloffValue);
		if (!BigAngleAutomation)
		{
			for (int i = 1; i < LookBones.Count; i++)
			{
				LookBones[i].lookWeight = targetWeights[i];
				LookBones[i].motionWeight = targetWeights[i];
			}
		}
		else
		{
			for (int j = 1; j < LookBones.Count; j++)
			{
				LookBones[j].lookWeight = targetWeights[j];
			}
		}
	}

	public void UpdateAutomationWeights()
	{
		float num = Mathf.InverseLerp(45f, 170f, Mathf.Abs(unclampedLookAngles.y));
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].motionWeight = Mathf.LerpUnclamped(LookBones[i].lookWeight, LookBones[i].lookWeightB, num);
		}
	}

	public void RefreshBoneMotionWeights()
	{
		for (int i = 1; i < LookBones.Count; i++)
		{
			LookBones[i].motionWeight = LookBones[i].lookWeight;
		}
	}

	public float[] CalculateRotationWeights(float falloff)
	{
		if (LookBones.Count > 1)
		{
			float num = 0f;
			if (baseWeights == null)
			{
				baseWeights = new float[LookBones.Count];
			}
			if (baseWeights.Length != LookBones.Count)
			{
				baseWeights = new float[LookBones.Count];
			}
			if (targetWeights == null)
			{
				targetWeights = new float[LookBones.Count];
			}
			if (targetWeights.Length != LookBones.Count)
			{
				targetWeights = new float[LookBones.Count];
			}
			if (BackBonesFalloff.length < 2 || !CurveSpread)
			{
				CalculateWeights(baseWeights);
				for (int i = 0; i < baseWeights.Length; i++)
				{
					num += baseWeights[i];
				}
				float num2 = 1f / (float)(LookBones.Count - 1);
				for (int j = 1; j < LookBones.Count; j++)
				{
					targetWeights[j] = Mathf.LerpUnclamped(baseWeights[j - 1], num2, falloff * 1.25f);
				}
			}
			else
			{
				num = 0f;
				float num3 = 1f;
				float num4 = 1f / (float)(LookBones.Count - 1);
				for (int k = 1; k < LookBones.Count; k++)
				{
					targetWeights[k] = BackBonesFalloff.Evaluate(num4 * (float)k) / num3;
					num += targetWeights[k];
				}
				for (int l = 1; l < LookBones.Count; l++)
				{
					targetWeights[l] /= num;
				}
			}
		}
		return targetWeights;
	}

	private void CalculateWeights(float[] weights)
	{
		float num = 1f;
		float num2 = 0.75f;
		float num3 = num;
		weights[0] = num * num2 * 0.65f;
		num3 -= weights[0];
		for (int i = 1; i < weights.Length - 1; i++)
		{
			num3 -= (weights[i] = num3 / (1f + (1f - num2)) * num2);
		}
		weights[^1] = num3;
		num3 = 0f;
	}

	public Transform GetHeadReference()
	{
		if ((Object)(object)HeadReference != (Object)null)
		{
			return HeadReference;
		}
		return LeadBone;
	}

	public Transform GetEyesTarget()
	{
		if ((Object)(object)EyesTarget == (Object)null)
		{
			return GetLookAtTransform();
		}
		return EyesTarget;
	}

	[Obsolete("Now please use GetEyesTarget() or GetLookAtTransform() methods")]
	public Transform GetCurrentTarget()
	{
		return GetEyesTarget();
	}

	public Vector3 GetEyesTargetPosition()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)EyesTarget == (Object)null)
		{
			return GetLookAtPosition();
		}
		return EyesTarget.position;
	}

	private void InitEyesModule()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		eyes = (Transform[])(object)new Transform[0];
		if ((Object)(object)LeftEye != (Object)null || (Object)(object)RightEye != (Object)null)
		{
			if ((Object)(object)LeftEye != (Object)null && (Object)(object)RightEye != (Object)null)
			{
				eyes = (Transform[])(object)new Transform[2] { LeftEye, RightEye };
			}
			else if ((Object)(object)LeftEye != (Object)null)
			{
				eyes = (Transform[])(object)new Transform[1] { LeftEye };
			}
			else
			{
				eyes = (Transform[])(object)new Transform[1] { RightEye };
			}
		}
		eyeForwards = (Vector3[])(object)new Vector3[eyes.Length];
		eyesInitLocalRotations = (Quaternion[])(object)new Quaternion[eyes.Length];
		eyesLerpRotations = (Quaternion[])(object)new Quaternion[eyes.Length];
		for (int i = 0; i < eyeForwards.Length; i++)
		{
			Vector3 val = eyes[i].position + Vector3.Scale(BaseTransform.forward, ((Component)eyes[i]).transform.lossyScale);
			Vector3 position = eyes[i].position;
			Vector3[] array = eyeForwards;
			int num = i;
			Vector3 val2 = eyes[i].InverseTransformPoint(val) - eyes[i].InverseTransformPoint(position);
			array[num] = ((Vector3)(ref val2)).normalized;
			eyesInitLocalRotations[i] = eyes[i].localRotation;
			eyesLerpRotations[i] = eyes[i].rotation;
		}
		headForward = Quaternion.FromToRotation(GetHeadReference().InverseTransformDirection(BaseTransform.forward), Vector3.forward) * Vector3.forward;
	}

	private void UpdateEyesLogics()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042e: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		if (CustomEyesLogics)
		{
			return;
		}
		if (EyesNoKeyframes)
		{
			for (int i = 0; i < eyeForwards.Length; i++)
			{
				eyes[i].localRotation = eyesInitLocalRotations[i];
			}
		}
		Transform val = EyesTarget;
		if ((Object)(object)val == (Object)null)
		{
			val = ((!((Object)(object)MomentLookTransform != (Object)null)) ? ObjectToFollow : MomentLookTransform);
		}
		bool flag = false;
		if ((Object)(object)val == (Object)null)
		{
			flag = true;
		}
		else if ((Object)(object)EyesTarget == (Object)null && LookState != EFHeadLookState.ClampedAngle && LookState != EFHeadLookState.Following)
		{
			flag = true;
		}
		if (flag)
		{
			EyesOutOfRangeBlend = Mathf.Max(0f, EyesOutOfRangeBlend - delta);
		}
		else
		{
			EyesOutOfRangeBlend = Mathf.Min(1f, EyesOutOfRangeBlend + delta);
		}
		_eyesBlend = EyesBlend * EyesOutOfRangeBlend * LookAnimatorAmount;
		if (_eyesBlend <= 0f || !((Object)(object)val != (Object)null))
		{
			return;
		}
		Vector3 lookStartMeasurePosition = GetLookStartMeasurePosition();
		Quaternion val2 = Quaternion.LookRotation(val.position - lookStartMeasurePosition);
		Vector3 eulerAngles = ((Quaternion)(ref val2)).eulerAngles;
		Quaternion val3 = GetHeadReference().rotation * Quaternion.FromToRotation(headForward, Vector3.forward);
		Vector3 eulerAngles2 = ((Quaternion)(ref val3)).eulerAngles;
		Vector2 val4 = Vector2.op_Implicit(new Vector3(Mathf.DeltaAngle(eulerAngles.x, eulerAngles2.x), Mathf.DeltaAngle(eulerAngles.y, eulerAngles2.y)));
		if (val4.x > EyesYRange.y)
		{
			eulerAngles.x = eulerAngles2.x - EyesYRange.y;
		}
		else if (val4.x < EyesYRange.x)
		{
			eulerAngles.x = eulerAngles2.x - EyesYRange.x;
		}
		if (val4.y > 0f - EyesXRange.x)
		{
			eulerAngles.y = eulerAngles2.y - EyesXRange.y;
		}
		else if (val4.y < 0f - EyesXRange.y)
		{
			eulerAngles.y = eulerAngles2.y + EyesXRange.y;
		}
		for (int j = 0; j < eyes.Length; j++)
		{
			Quaternion rotation = eyes[j].rotation;
			Quaternion val5 = Quaternion.Euler(eulerAngles);
			float num = 1f;
			if ((Object)(object)eyes[j] == (Object)(object)LeftEye)
			{
				if (InvertLeftEye)
				{
					num = -1f;
				}
			}
			else if ((Object)(object)eyes[j] == (Object)(object)RightEye && InvertRightEye)
			{
				num = -1f;
			}
			val5 *= Quaternion.FromToRotation(eyeForwards[j], Vector3.forward * num);
			val5 *= eyesInitLocalRotations[j];
			eyes[j].rotation = val5;
			Transform obj = eyes[j];
			obj.rotation *= Quaternion.Inverse(eyesInitLocalRotations[j]);
			if (EyesOffsetRotation != Vector3.zero)
			{
				Transform obj2 = eyes[j];
				obj2.rotation *= Quaternion.Euler(EyesOffsetRotation);
			}
			switch (j)
			{
			case 0:
				if (LeftEyeOffsetRotation != Vector3.zero)
				{
					Transform obj4 = eyes[j];
					obj4.rotation *= Quaternion.Euler(LeftEyeOffsetRotation);
				}
				break;
			case 1:
				if (RightEyeOffsetRotation != Vector3.zero)
				{
					Transform obj3 = eyes[j];
					obj3.rotation *= Quaternion.Euler(RightEyeOffsetRotation);
				}
				break;
			}
			val5 = eyes[j].rotation;
			eyesLerpRotations[j] = Quaternion.Slerp(eyesLerpRotations[j], val5, delta * Mathf.Lerp(2f, 40f, EyesSpeed));
			eyes[j].rotation = Quaternion.Slerp(rotation, eyesLerpRotations[j], _eyesBlend);
		}
	}

	private void NoddingChangeTargetCalculations(float angleAmount)
	{
		if ((nodProgress < nodDuration / 10f || nodProgress > nodDuration * 0.85f) && NoddingTransitions != 0f)
		{
			nodProgress = 0f;
			nodDuration = Mathf.Lerp(1f, 0.45f, RotationSpeed / 2.5f);
			if (ChangeTargetSmoothing > 0f)
			{
				nodDuration *= Mathf.Lerp(1f, 1.55f, ChangeTargetSmoothing);
			}
			nodDuration *= Mathf.Lerp(0.8f, 1.4f, Mathf.InverseLerp(10f, 140f, angleAmount));
			nodPower = Mathf.Lerp(0.3f, 1f, Mathf.InverseLerp(8f, 55f, angleAmount));
		}
	}

	private void NoddingCalculations()
	{
		if (nodProgress < nodDuration)
		{
			if (nodProgress < nodDuration)
			{
				nodProgress += delta;
			}
			else
			{
				nodProgress = nodDuration;
			}
			float value = nodProgress / nodDuration;
			value = FEasing.EaseOutCubic(0f, 1f, value);
			if (value >= 1f)
			{
				nodValue = 0f;
			}
			else
			{
				nodValue = Mathf.Sin(value * MathF.PI);
			}
		}
	}

	public void SetRotationSmoothing(float smoothingDuration = 0.5f, float smoothingPower = 2f)
	{
		if (!(smoothingDuration <= 0f))
		{
			smoothingTimer = smoothingDuration;
			smoothingTime = smoothingDuration;
			this.smoothingPower = smoothingPower;
		}
	}

	private void UpdateSmoothing()
	{
		if (smoothingTimer > 0f)
		{
			smoothingTimer -= delta;
			smoothingEffect = 1f + smoothingTimer / smoothingTime * smoothingPower;
		}
		else
		{
			smoothingEffect = 1f;
		}
	}

	private void AnimateBonesUnsynced(Quaternion diffOnMain, Quaternion backTarget, float d)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (nodValue > 0f && BackBonesNod != 0f)
		{
			backTarget *= Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f) * BackBonesNod);
		}
		Quaternion targetLook;
		for (int i = 1; i < LookBones.Count; i++)
		{
			LookBones[i].Transform.localRotation = LookBones[i].localStaticRotation;
			targetLook = backTarget * LookBones[i].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[i].animatedStaticRotation);
			LookBones[i].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
		}
		LookBones[0].Transform.localRotation = LookBones[0].localStaticRotation;
		targetLook = ((!(nodValue <= 0f)) ? (targetLookRotation * LookBones[0].correctionOffsetQ * Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f)) * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)) : (targetLookRotation * LookBones[0].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)));
		LookBones[0].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
	}

	private void AnimateBonesSynced(Quaternion diffOnMain, Quaternion backTarget, float d)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		if (nodValue > 0f && BackBonesNod != 0f)
		{
			backTarget *= Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f) * BackBonesNod);
		}
		Quaternion targetLook;
		for (int num = LookBones.Count - 1; num >= 1; num--)
		{
			targetLook = backTarget * LookBones[num].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[num].animatedStaticRotation);
			LookBones[num].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
		}
		targetLook = ((!(nodValue <= 0f)) ? (targetLookRotation * (LookBones[0].correctionOffsetQ * Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f))) * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)) : (targetLookRotation * LookBones[0].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)));
		LookBones[0].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
	}

	private void AnimateBonesParental(float d)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_065e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0663: Unknown result type (might be due to invalid IL or missing references)
		//IL_0664: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05da: Unknown result type (might be due to invalid IL or missing references)
		//IL_05db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0606: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0610: Unknown result type (might be due to invalid IL or missing references)
		//IL_0615: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0650: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_050e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_054a: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0590: Unknown result type (might be due to invalid IL or missing references)
		//IL_0595: Unknown result type (might be due to invalid IL or missing references)
		//IL_059a: Unknown result type (might be due to invalid IL or missing references)
		float num = nodValue * nodPower * (0f - NoddingTransitions) * 40f;
		float num2 = num * BackBonesNod;
		bool flag = false;
		if (BackBonesAddOffset != Vector3.zero || NoddingTransitions != 0f)
		{
			flag = true;
		}
		for (int num3 = LookBones.Count - 1; num3 >= 1; num3--)
		{
			Quaternion val = Quaternion.identity;
			if (flag || LookBones[num3].correctionOffset != Vector3.zero)
			{
				if (ParentalOffsetsV == 2)
				{
					val *= Quaternion.AngleAxis(BackBonesAddOffset.x + LookBones[num3].correctionOffset.x + NodAxis.x * num2, LookBones[num3].right);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.y + LookBones[num3].correctionOffset.y + NodAxis.y * num2, LookBones[num3].up);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.z + LookBones[num3].correctionOffset.z + NodAxis.z * num2, LookBones[num3].forward);
				}
				else if (ParentalOffsetsV == 1)
				{
					val *= Quaternion.AngleAxis(BackBonesAddOffset.x + LookBones[num3].correctionOffset.x + NodAxis.x * num2, LookBones[num3].Transform.right);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.y + LookBones[num3].correctionOffset.y + NodAxis.y * num2, LookBones[num3].Transform.up);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.z + LookBones[num3].correctionOffset.z + NodAxis.z * num2, LookBones[num3].Transform.forward);
				}
				else
				{
					val *= Quaternion.AngleAxis(BackBonesAddOffset.x + LookBones[num3].correctionOffset.x + NodAxis.x * num2, BaseTransform.right);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.y + LookBones[num3].correctionOffset.y + NodAxis.y * num2, BaseTransform.up);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.z + LookBones[num3].correctionOffset.z + NodAxis.z * num2, BaseTransform.forward);
				}
			}
			LookBones[num3].CalculateMotion(targetLookRotation * val, WeightsMultiplier, d, finalMotionWeight);
		}
		Quaternion val2 = Quaternion.identity;
		if (LookBones[0].correctionOffset != Vector3.zero || NoddingTransitions != 0f)
		{
			if (ParentalOffsetsV == 2)
			{
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.x + NodAxis.x * num, LookBones[0].Transform.right);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.y + NodAxis.y * num, LookBones[0].Transform.up);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.z + NodAxis.z * num, LookBones[0].Transform.forward);
			}
			else if (ParentalOffsetsV == 1)
			{
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.x + NodAxis.x * num, LookBones[0].right);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.y + NodAxis.y * num, LookBones[0].up);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.z + NodAxis.z * num, LookBones[0].forward);
			}
			else
			{
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.x + NodAxis.x * num, BaseTransform.right);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.y + NodAxis.y * num, BaseTransform.up);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.z + NodAxis.z * num, BaseTransform.forward);
			}
		}
		LookBones[0].CalculateMotion(targetLookRotation * val2, WeightsMultiplier, d, finalMotionWeight);
	}

	private void CalculateLookAnimation()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		_stopLooking = false;
		if (FollowMode != EFFollowMode.FollowJustPosition && (Object)(object)ObjectToFollow == (Object)null && (Object)(object)MomentLookTransform == (Object)null)
		{
			_stopLooking = true;
		}
		LookPositionUpdate();
		LookWhenAboveGoBackCalculations();
		if (_stopLooking)
		{
			finalLookPosition = ((Component)this).transform.TransformPoint(lookFreezeFocusPoint);
		}
		else if (!BirdMode)
		{
			finalLookPosition = smoothLookPosition;
		}
		else
		{
			finalLookPosition = BirdTargetPosition;
		}
		Vector3 val;
		Quaternion val3;
		Vector3 val5;
		if (FixingPreset != 0)
		{
			if (LookState == EFHeadLookState.OutOfMaxDistance)
			{
				targetLookAngles = Vector3.MoveTowards(targetLookAngles, Vector3.zero, 1f + RotationSpeed);
			}
			else
			{
				val = finalLookPosition - GetLookStartMeasurePosition();
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				if (usingAxisCorrection)
				{
					Matrix4x4 inverse = ((Matrix4x4)(ref axisCorrectionMatrix)).inverse;
					val = ((Matrix4x4)(ref inverse)).MultiplyVector(normalized);
					normalized = ((Vector3)(ref val)).normalized;
					Vector3 val2 = normalized;
					val = ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(ModelUpAxis);
					val3 = Quaternion.LookRotation(val2, ((Vector3)(ref val)).normalized);
					normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
				}
				else
				{
					normalized = BaseTransform.InverseTransformDirection(normalized);
					val3 = Quaternion.LookRotation(normalized, BaseTransform.TransformDirection(ModelUpAxis));
					normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
				}
				targetLookAngles = normalized;
			}
			Vector2 angles = Vector2.op_Implicit(targetLookAngles);
			angles = LimitAnglesCalculations(angles);
			AnimateAnglesTowards(angles);
			if (usingAxisCorrection)
			{
				Quaternion val4 = Quaternion.FromToRotation(Vector3.right, Vector3.Cross(Vector3.up, ModelForwardAxis));
				val4 = Quaternion.Euler(finalLookAngles) * val4 * BaseTransform.rotation;
				val5 = ((Quaternion)(ref val4)).eulerAngles;
			}
			else
			{
				val5 = finalLookAngles + BaseTransform.eulerAngles;
			}
			val5 += RotationOffset;
			val5 = ConvertFlippedAxes(val5);
		}
		else
		{
			val = finalLookPosition - GetLookStartMeasurePosition();
			val3 = LookRotationParental(((Vector3)(ref val)).normalized);
			val5 = ((Quaternion)(ref val3)).eulerAngles;
		}
		if (!_stopLooking)
		{
			lookFreezeFocusPoint = BaseTransform.InverseTransformPoint(finalLookPosition);
		}
		targetLookRotation = Quaternion.Euler(val5);
		SetTargetBonesRotations();
	}

	private void SetTargetBonesRotations()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (FixingPreset == EFAxisFixOrder.Parental)
		{
			if (UltraSmoother <= 0f)
			{
				AnimateBonesParental(1f);
			}
			else
			{
				AnimateBonesParental(delta * Mathf.Lerp(21f, 3f, UltraSmoother));
			}
			return;
		}
		Quaternion backTarget = targetLookRotation * Quaternion.Euler(BackBonesAddOffset);
		Quaternion diffOnMain = BaseTransform.rotation * Quaternion.Inverse(rootStaticRotation);
		if (UseBoneOffsetRotation)
		{
			if (UltraSmoother <= 0f)
			{
				AnimateBonesSynced(diffOnMain, backTarget, 1f);
			}
			else
			{
				AnimateBonesSynced(diffOnMain, backTarget, delta * Mathf.Lerp(21f, 3f, UltraSmoother));
			}
		}
		else if (UltraSmoother <= 0f)
		{
			AnimateBonesUnsynced(diffOnMain, backTarget, 1f);
		}
		else
		{
			AnimateBonesUnsynced(diffOnMain, backTarget, delta * Mathf.Lerp(21f, 3f, UltraSmoother));
		}
	}

	private Quaternion LookRotationParental(Vector3 direction)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		if (!SyncWithAnimator)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].Transform.localRotation = LookBones[i].localStaticRotation;
			}
		}
		if ((Object)(object)ParentalReferenceBone == (Object)null)
		{
			_parentalBackParentRot = LeadBone.parent.rotation;
		}
		else
		{
			_parentalBackParentRot = ParentalReferenceBone.rotation;
		}
		Vector3 val = Quaternion.Inverse(_parentalBackParentRot) * ((Vector3)(ref direction)).normalized;
		_parentalAngles.y = AngleAroundAxis(parentalReferenceLookForward, val, parentalReferenceUp);
		Vector3 axis = Vector3.Cross(parentalReferenceUp, val);
		Vector3 firstDirection = val - Vector3.Project(val, parentalReferenceUp);
		_parentalAngles.x = AngleAroundAxis(firstDirection, val, axis);
		_parentalAngles = LimitAnglesCalculations(_parentalAngles);
		_parentalAngles = AnimateAnglesTowards(_parentalAngles);
		Vector3 referenceRightDir = Vector3.Cross(parentalReferenceUp, parentalReferenceLookForward);
		if (NoddingTransitions != 0f)
		{
			float num = nodValue * nodPower * 40f;
			_parentalAngles.x += num * BackBonesNod;
		}
		if (RotationOffset != Vector3.zero)
		{
			_parentalAngles += new Vector2(RotationOffset.x, RotationOffset.y);
		}
		return ParentalRotationMaths(referenceRightDir, _parentalAngles.x, _parentalAngles.y);
	}

	private Quaternion ParentalRotationMaths(Vector3 referenceRightDir, float xAngle, float yAngle)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.AngleAxis(yAngle, parentalReferenceUp) * Quaternion.AngleAxis(xAngle, referenceRightDir) * parentalReferenceLookForward;
		Vector3 dynamicReferenceUp = parentalReferenceUp;
		Vector3.OrthoNormalize(ref val, ref dynamicReferenceUp);
		Vector3 val2 = val;
		DynamicReferenceUp = dynamicReferenceUp;
		Vector3.OrthoNormalize(ref val2, ref DynamicReferenceUp);
		return _parentalBackParentRot * Quaternion.LookRotation(val2, DynamicReferenceUp) * Quaternion.Inverse(_parentalBackParentRot * Quaternion.LookRotation(parentalReferenceLookForward, parentalReferenceUp));
	}

	private void UpdateCorrectionMatrix()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (ModelUpAxis != Vector3.up || ModelForwardAxis != Vector3.forward)
		{
			usingAxisCorrection = true;
			axisCorrectionMatrix = Matrix4x4.TRS(BaseTransform.position, Quaternion.LookRotation(BaseTransform.TransformDirection(ModelForwardAxis), BaseTransform.TransformDirection(ModelUpAxis)), BaseTransform.lossyScale);
		}
		else
		{
			usingAxisCorrection = false;
		}
	}

	private IEnumerator AnimatePhysicsClock()
	{
		animatePhysicsWorking = true;
		while (true)
		{
			yield return CoroutineEx.waitForFixedUpdate;
			triggerAnimatePhysics = true;
		}
	}

	private IEnumerator SwitchLookingTransition(float transitionTime, bool enableAnimation, Action callback = null)
	{
		float time = 0f;
		float startBlend = LookAnimatorAmount;
		while (time < transitionTime)
		{
			time += delta;
			float num = time / transitionTime;
			if (enableAnimation)
			{
				LookAnimatorAmount = Mathf.Lerp(startBlend, 1f, num);
			}
			else
			{
				LookAnimatorAmount = Mathf.Lerp(startBlend, 0f, num);
			}
			yield return null;
		}
		callback?.Invoke();
	}

	private IEnumerator CResetMomentLookTransform(Transform transform, float time)
	{
		yield return null;
		yield return null;
		yield return CoroutineEx.waitForSeconds(time);
		yield return null;
		MomentLookTransform = transform;
	}

	public Vector2 LimitAnglesCalculations(Vector2 angles)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_0452: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		if (LookState == EFHeadLookState.OutOfMaxDistance)
		{
			angles = Vector2.MoveTowards(angles, Vector2.zero, 2.75f + RotationSpeed);
			return angles;
		}
		unclampedLookAngles = Vector2.op_Implicit(angles);
		if (LookState != EFHeadLookState.OutOfMaxRotation)
		{
			if (Mathf.Abs(angles.y) > StopLookingAbove)
			{
				LookState = EFHeadLookState.OutOfMaxRotation;
				return angles;
			}
		}
		else
		{
			if (!(Mathf.Abs(angles.y) <= StopLookingAbove * StopLookingAboveFactor))
			{
				angles = Vector2.op_Implicit(Vector3.MoveTowards(Vector2.op_Implicit(angles), Vector2.op_Implicit(Vector2.zero), 2.75f + RotationSpeed));
				return angles;
			}
			LookState = EFHeadLookState.Null;
		}
		if (LookState == EFHeadLookState.Null)
		{
			LookState = EFHeadLookState.Following;
		}
		if (LookState == EFHeadLookState.Following || LookState == EFHeadLookState.ClampedAngle)
		{
			if (angles.y < XRotationLimits.x)
			{
				angles.y = GetClampedAngle(unclampedLookAngles.y, XRotationLimits.x, XElasticRange, -1f);
				if (angles.y < unclampedLookAngles.y)
				{
					angles.y = unclampedLookAngles.y;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else if (angles.y > XRotationLimits.y)
			{
				angles.y = GetClampedAngle(unclampedLookAngles.y, XRotationLimits.y, XElasticRange);
				if (angles.y > unclampedLookAngles.y)
				{
					angles.y = unclampedLookAngles.y;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else
			{
				LookState = EFHeadLookState.Following;
			}
			if (angles.x < YRotationLimits.x)
			{
				angles.x = GetClampedAngle(angles.x, YRotationLimits.x, YElasticRange, -1f);
				if (angles.x < unclampedLookAngles.x)
				{
					angles.x = unclampedLookAngles.x;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else if (angles.x > YRotationLimits.y)
			{
				angles.x = GetClampedAngle(angles.x, YRotationLimits.y, YElasticRange);
				if (angles.x > unclampedLookAngles.x)
				{
					angles.x = unclampedLookAngles.x;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else if (LookState != EFHeadLookState.ClampedAngle)
			{
				LookState = EFHeadLookState.Following;
			}
		}
		if (StartLookElasticRangeX > 0f)
		{
			float num = Mathf.Abs(angles.y) / StartLookElasticRangeX;
			angles.y = Mathf.Lerp(0f, angles.y, num);
		}
		if (StartLookElasticRangeY > 0f)
		{
			float num2 = Mathf.Abs(angles.x) / StartLookElasticRangeY;
			angles.x = Mathf.Lerp(0f, angles.x, num2);
		}
		if (HoldRotateToOppositeUntil > 0f)
		{
			int num3 = 0;
			if (_rememberSideLookHorizontalAngle > 0f && unclampedLookAngles.y < 0f)
			{
				num3 = 1;
			}
			else if (_rememberSideLookHorizontalAngle < 0f && unclampedLookAngles.y > 0f)
			{
				num3 = -1;
			}
			if (num3 != 0)
			{
				if (num3 < 0)
				{
					if (unclampedLookAngles.y < 180f - HoldRotateToOppositeUntil)
					{
						_rememberSideLookHorizontalAngle = angles.y;
					}
					else
					{
						angles.y = _rememberSideLookHorizontalAngle;
					}
				}
				else if (0f - unclampedLookAngles.y < 180f - HoldRotateToOppositeUntil)
				{
					_rememberSideLookHorizontalAngle = angles.y;
				}
				else
				{
					angles.y = _rememberSideLookHorizontalAngle;
				}
			}
			else
			{
				_rememberSideLookHorizontalAngle = angles.y;
			}
		}
		if (LookWhenAbove > 0f)
		{
			whenAboveGoBackAngles = angles;
			float num4 = Mathf.Abs(Mathf.DeltaAngle(_preLookAboveLookAngles.y, angles.y));
			if (num4 < animatedLookWhenAbove)
			{
				angles.y = _preLookAboveLookAngles.y;
			}
			else
			{
				angles.y = Mathf.LerpUnclamped(_preLookAboveLookAngles.y, angles.y, (num4 - animatedLookWhenAbove) / num4);
				_preLookAboveLookAngles.y = angles.y;
			}
			float num5 = ((animatedLookWhenAboveVertical > 0f) ? animatedLookWhenAboveVertical : animatedLookWhenAbove);
			num4 = Mathf.Abs(Mathf.DeltaAngle(_preLookAboveLookAngles.x, angles.x));
			if (num4 < num5)
			{
				angles.x = _preLookAboveLookAngles.x;
			}
			else
			{
				angles.x = Mathf.LerpUnclamped(_preLookAboveLookAngles.x, angles.x, (num4 - num5) / num4);
				_preLookAboveLookAngles.x = angles.x;
			}
		}
		return angles;
	}

	public Vector2 AnimateAnglesTowards(Vector2 angles)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		if (!usingAxisCorrection)
		{
			Quaternion val = BaseTransform.rotation * Quaternion.Inverse(lastBaseRotation);
			Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
			eulerAngles = WrapVector(eulerAngles) * BaseRotationCompensation;
			animatedLookAngles -= eulerAngles;
		}
		if (!instantRotation)
		{
			switch (AnimationStyle)
			{
			case EFAnimationStyle.SmoothDamp:
			{
				float num4 = ((RotationSpeed < 0.8f) ? Mathf.Lerp(0.4f, 0.18f, RotationSpeed / 0.8f) : ((RotationSpeed < 1.7f) ? Mathf.Lerp(0.18f, 0.1f, (RotationSpeed - 0.8f) / 0.90000004f) : ((!(RotationSpeed < 2.15f)) ? Mathf.Lerp(0.05f, 0.02f, (RotationSpeed - 2.15f) / 0.3499999f) : Mathf.Lerp(0.1f, 0.05f, (RotationSpeed - 1.7f) / 0.45000005f))));
				num4 *= smoothingEffect;
				float num5 = ((MaxRotationSpeed >= 2.5f) ? float.PositiveInfinity : ((MaxRotationSpeed < 0.8f) ? Mathf.Lerp(100f, 430f, MaxRotationSpeed / 0.8f) : ((!(MaxRotationSpeed < 1.7f)) ? Mathf.Lerp(685f, 1250f, (MaxRotationSpeed - 1.7f) / 0.79999995f) : Mathf.Lerp(430f, 685f, (MaxRotationSpeed - 0.8f) / 0.90000004f))));
				animatedLookAngles = Vector3.SmoothDamp(animatedLookAngles, Vector2.op_Implicit(angles), ref _velo_animatedLookAngles, num4, num5, delta);
				break;
			}
			case EFAnimationStyle.FastLerp:
			{
				float num = ((RotationSpeed < 0.8f) ? Mathf.Lerp(2.85f, 4.5f, RotationSpeed / 0.8f) : ((RotationSpeed < 1.7f) ? Mathf.Lerp(4.5f, 10f, (RotationSpeed - 0.8f) / 0.90000004f) : ((!(RotationSpeed < 2.15f)) ? Mathf.Lerp(14f, 25f, (RotationSpeed - 2.15f) / 0.3499999f) : Mathf.Lerp(10f, 14f, (RotationSpeed - 1.7f) / 0.45000005f))));
				num /= smoothingEffect;
				Vector3 val2 = Vector3.Lerp(animatedLookAngles, Vector2.op_Implicit(angles), num * delta);
				if (MaxRotationSpeed < 2.5f)
				{
					float num2 = ((MaxRotationSpeed < 1.1f) ? Mathf.Lerp(5f, 9f, MaxRotationSpeed / 1.1f) : ((!(MaxRotationSpeed < 1.7f)) ? Mathf.Lerp(20f, 45f, (MaxRotationSpeed - 1.7f) / 0.79999995f) : Mathf.Lerp(9f, 20f, (MaxRotationSpeed - 1.1f) / 0.6f)));
					float num3 = Vector3.Distance(val2, animatedLookAngles);
					if (num3 > num2)
					{
						num /= 1f + (num3 - num2) / 3f;
					}
					val2 = Vector3.Lerp(animatedLookAngles, Vector2.op_Implicit(angles), num * delta);
				}
				animatedLookAngles = val2;
				break;
			}
			case EFAnimationStyle.Linear:
				animatedLookAngles = Vector3.MoveTowards(animatedLookAngles, Vector2.op_Implicit(angles), delta * (0.2f + RotationSpeed) * 300f);
				break;
			}
		}
		else
		{
			animatedLookAngles = Vector2.op_Implicit(angles);
		}
		finalLookAngles = Vector3.LerpUnclamped(Vector3.zero, animatedLookAngles, finalMotionWeight);
		return Vector2.op_Implicit(finalLookAngles);
	}

	public Vector3 GetDistanceMeasurePosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return BaseTransform.position + BaseTransform.TransformVector(DistanceMeasurePoint);
	}

	public Vector3 GetLookStartMeasurePosition()
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		_LOG_NoRefs();
		if (AnchorStartLookPoint)
		{
			if (usingAxisCorrection)
			{
				if (!Application.isPlaying)
				{
					UpdateCorrectionMatrix();
				}
				if (leadBoneInitLocalOffset == Vector3.zero)
				{
					return LeadBone.position + ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(StartLookPointOffset);
				}
				return ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyPoint(leadBoneInitLocalOffset) + ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(StartLookPointOffset);
			}
			if (leadBoneInitLocalOffset == Vector3.zero)
			{
				return LeadBone.position + BaseTransform.TransformVector(StartLookPointOffset);
			}
			return BaseTransform.TransformPoint(leadBoneInitLocalOffset) + BaseTransform.TransformVector(StartLookPointOffset);
		}
		if (!Application.isPlaying)
		{
			LookBones[0].finalRotation = ((Component)LeadBone).transform.rotation;
		}
		return LeadBone.position + LookBones[0].finalRotation * StartLookPointOffset;
	}

	public void RefreshLookStartPositionAnchor()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!usingAxisCorrection)
		{
			leadBoneInitLocalOffset = BaseTransform.InverseTransformPoint(LeadBone.position);
		}
		else
		{
			Matrix4x4 inverse = ((Matrix4x4)(ref axisCorrectionMatrix)).inverse;
			leadBoneInitLocalOffset = ((Matrix4x4)(ref inverse)).MultiplyPoint(LeadBone.position);
		}
		RefreshStartLookPoint = false;
	}

	private float GetDistanceMeasure(Vector3 targetPosition)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (Distance2D)
		{
			Vector3 distanceMeasurePosition = GetDistanceMeasurePosition();
			return Vector2.Distance(new Vector2(distanceMeasurePosition.x, distanceMeasurePosition.z), new Vector2(targetPosition.x, targetPosition.z));
		}
		return Vector3.Distance(GetDistanceMeasurePosition(), targetPosition);
	}

	private void UpdateLookAnimatorAmountWeight()
	{
		if (!_stopLooking && (LookState == EFHeadLookState.OutOfMaxDistance || LookState == EFHeadLookState.OutOfMaxRotation || LookState == EFHeadLookState.Null))
		{
			_stopLooking = true;
		}
		float num = (BirdMode ? RotationSpeed : 1f);
		if (_stopLooking)
		{
			animatedMotionWeight = Mathf.SmoothDamp(animatedMotionWeight, 0f, ref _velo_animatedMotionWeight, Mathf.Lerp(0.5f, 0.25f, RotationSpeed / 2.5f), float.PositiveInfinity, delta * num);
		}
		else
		{
			if (previousState == EFHeadLookState.OutOfMaxRotation)
			{
				OnRangeStateChanged();
			}
			animatedMotionWeight = Mathf.SmoothDamp(animatedMotionWeight, 1f, ref _velo_animatedMotionWeight, Mathf.Lerp(0.3f, 0.125f, RotationSpeed / 2.5f), float.PositiveInfinity, delta * num);
		}
		finalMotionWeight = animatedMotionWeight * LookAnimatorAmount;
		if (finalMotionWeight > 0.999f)
		{
			finalMotionWeight = 1f;
		}
	}

	private void EndUpdate()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		preActiveLookTarget = activeLookTarget;
		preWeightFaloff = FaloffValue;
		lastBaseRotation = BaseTransform.rotation;
		preLookDir = GetCurrentHeadForwardDirection();
	}

	private void LookPositionUpdate()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (LookAtPositionSmoother > 0f)
		{
			smoothLookPosition = Vector3.SmoothDamp(smoothLookPosition, activeLookPosition, ref _velo_smoothLookPosition, LookAtPositionSmoother / 2f, float.PositiveInfinity, delta);
		}
		else
		{
			smoothLookPosition = activeLookPosition;
		}
	}

	private void TargetingUpdate()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		activeLookTarget = GetLookAtTransform();
		activeLookPosition = GetLookAtPosition();
		if ((Object)(object)preActiveLookTarget != (Object)(object)activeLookTarget)
		{
			OnTargetChanged();
		}
	}

	public Vector3 GetLookAtPosition()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		_LOG_NoRefs();
		if (FollowMode == EFFollowMode.FollowJustPosition)
		{
			return FollowOffset;
		}
		Transform lookAtTransform = activeLookTarget;
		if ((Object)(object)lookAtTransform == (Object)null)
		{
			lookAtTransform = GetLookAtTransform();
		}
		if (!Object.op_Implicit((Object)(object)lookAtTransform))
		{
			return LeadBone.position + BaseTransform.TransformVector(ModelForwardAxis) * Vector3.Distance(LeadBone.position, BaseTransform.position);
		}
		if (FollowMode == EFFollowMode.ToFollowSpaceOffset)
		{
			return lookAtTransform.position + lookAtTransform.TransformVector(FollowOffset);
		}
		if (FollowMode == EFFollowMode.WorldOffset)
		{
			return lookAtTransform.position + FollowOffset;
		}
		if (FollowMode == EFFollowMode.LocalOffset)
		{
			return lookAtTransform.position + BaseTransform.TransformVector(FollowOffset);
		}
		return lookAtTransform.position;
	}

	public Transform GetLookAtTransform()
	{
		if (Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			if (!wasMomentLookTransform)
			{
				OnTargetChanged();
				wasMomentLookTransform = true;
			}
			return MomentLookTransform;
		}
		if (!Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			if (wasMomentLookTransform)
			{
				OnTargetChanged();
				wasMomentLookTransform = false;
			}
			if (Object.op_Implicit((Object)(object)ObjectToFollow))
			{
				return ObjectToFollow;
			}
		}
		return null;
	}

	public Vector3 GetForwardPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return LeadBone.position + BaseTransform.TransformDirection(ModelForwardAxis);
	}

	protected void TargetChangedMeasures()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentHeadForwardDirection = GetCurrentHeadForwardDirection();
		Vector3 normalized = ((Vector3)(ref preLookDir)).normalized;
		Quaternion val = Quaternion.LookRotation(currentHeadForwardDirection);
		Vector3 val2 = ((Quaternion)(ref val)).eulerAngles;
		Vector3 val3;
		if (!(normalized == Vector3.zero))
		{
			val = Quaternion.LookRotation(normalized);
			val3 = ((Quaternion)(ref val)).eulerAngles;
		}
		else
		{
			val3 = Vector3.zero;
		}
		Vector3 val4 = val3;
		val = Quaternion.LookRotation(((Component)this).transform.TransformVector(ModelForwardAxis));
		Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		Vector2 val5 = Vector2.op_Implicit(new Vector3(Mathf.DeltaAngle(val2.x, eulerAngles.x), Mathf.DeltaAngle(val2.y, eulerAngles.y)));
		float num = StopLookingAbove;
		if (Mathf.Abs(XRotationLimits.x) > StopLookingAbove)
		{
			num = Mathf.Abs(XRotationLimits.x);
		}
		if (Mathf.Abs(val5.y) > num)
		{
			val2 = eulerAngles;
		}
		else
		{
			if (val5.y < XRotationLimits.x)
			{
				val2.y = eulerAngles.y + XRotationLimits.y;
			}
			if (val5.y > XRotationLimits.y)
			{
				val2.y = eulerAngles.y + XRotationLimits.x;
			}
			if (val5.x < YRotationLimits.x)
			{
				val2.x = eulerAngles.x + XRotationLimits.x;
			}
			if (val5.x > YRotationLimits.y)
			{
				val2.x = eulerAngles.x + XRotationLimits.y;
			}
		}
		Vector2 val6 = Vector2.op_Implicit(new Vector3(Mathf.DeltaAngle(val2.x, val4.x), Mathf.DeltaAngle(val2.y, val4.y)));
		float num2 = Mathf.Abs(val6.x) + Mathf.Abs(val6.y);
		if (ChangeTargetSmoothing > 0f && num2 > 20f)
		{
			SetRotationSmoothing(Mathf.Lerp(0.15f + ChangeTargetSmoothing * 0.25f, 0.4f + ChangeTargetSmoothing * 0.2f, Mathf.InverseLerp(20f, 180f, num2)), Mathf.Lerp(0.7f, 3f, ChangeTargetSmoothing));
		}
		NoddingChangeTargetCalculations(num2);
	}

	private void MaxDistanceCalculations()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (MaximumDistance > 0f)
		{
			if (isLooking)
			{
				if (GetDistanceMeasure(activeLookPosition) > MaximumDistance + MaximumDistance * MaxOutDistanceFactor)
				{
					LookState = EFHeadLookState.OutOfMaxDistance;
					OnRangeStateChanged();
					if (DestroyMomentTargetOnMaxDistance)
					{
						ForceDestroyMomentTarget();
					}
				}
			}
			else if (LookState == EFHeadLookState.OutOfMaxDistance && GetDistanceMeasure(activeLookPosition) <= MaximumDistance)
			{
				LookState = EFHeadLookState.Null;
				OnRangeStateChanged();
			}
		}
		else if (LookState == EFHeadLookState.OutOfMaxDistance)
		{
			LookState = EFHeadLookState.Null;
		}
	}

	protected virtual void OnTargetChanged()
	{
		TargetChangedMeasures();
	}

	protected virtual void OnRangeStateChanged()
	{
		TargetChangedMeasures();
	}

	private void BeginStateCheck()
	{
		if ((Object)(object)activeLookTarget == (Object)null)
		{
			LookState = EFHeadLookState.Null;
		}
		else if (LookState == EFHeadLookState.Null)
		{
			LookState = EFHeadLookState.Following;
		}
		previousState = LookState;
		isLooking = LookState != EFHeadLookState.OutOfMaxDistance && LookState != EFHeadLookState.OutOfMaxRotation;
	}

	private void LookWhenAboveGoBackCalculations()
	{
		if (whenAboveGoBackDuration > 0f)
		{
			if (WhenAboveGoBackAfter > 0f)
			{
				animatedLookWhenAbove = Mathf.SmoothDamp(animatedLookWhenAbove, 0f, ref _whenAboveGoBackVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
				if (animatedLookWhenAbove <= 0.001f)
				{
					whenAboveGoBackDuration = 0f;
				}
				if (LookWhenAboveVertical <= 0f)
				{
					animatedLookWhenAboveVertical = animatedLookWhenAbove;
				}
				else
				{
					animatedLookWhenAboveVertical = Mathf.SmoothDamp(animatedLookWhenAboveVertical, 0f, ref _whenAboveGoBackVerticalVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
				}
			}
			return;
		}
		if (animatedLookWhenAbove < LookWhenAbove)
		{
			animatedLookWhenAbove = Mathf.SmoothDamp(animatedLookWhenAbove, LookWhenAbove, ref _whenAboveGoBackVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
		}
		if (LookWhenAboveVertical <= 0f)
		{
			animatedLookWhenAboveVertical = animatedLookWhenAbove;
		}
		else if (animatedLookWhenAboveVertical < LookWhenAboveVertical)
		{
			animatedLookWhenAboveVertical = Mathf.SmoothDamp(animatedLookWhenAboveVertical, LookWhenAboveVertical, ref _whenAboveGoBackVerticalVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
		}
		if (WhenAboveGoBackAfter > 0f)
		{
			float num = Mathf.Abs(_preLookAboveLookAngles.x - whenAboveGoBackAngles.x) + Mathf.Abs(_preLookAboveLookAngles.y - whenAboveGoBackAngles.y);
			whenAboveGoBackTimer += delta * Mathf.Lerp(0f, 1f, Mathf.InverseLerp(LookWhenAbove / 5f, LookWhenAbove, num));
			if (whenAboveGoBackTimer > WhenAboveGoBackAfter)
			{
				whenAboveGoBackTimer = 0f;
				whenAboveGoBackDuration = WhenAboveGoBackDuration;
			}
		}
	}

	private void PreCalibrateBones()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (Calibration)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].Transform.localRotation = LookBones[i].initLocalRot;
			}
		}
	}

	private void CalibrateBones()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (OverrideRotations > 0f)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].Transform.localRotation = Quaternion.LerpUnclamped(LookBones[i].Transform.localRotation, LookBones[i].initLocalRot, OverrideRotations * LookAnimatorAmount);
			}
		}
		if (ConstantParentalAxisUpdate)
		{
			RefreshParentalLookReferenceAxis();
		}
		if (RotationSpeed >= 2.5f)
		{
			instantRotation = true;
		}
		else
		{
			instantRotation = false;
		}
		if (refreshReferencePose)
		{
			RefreshReferencePose();
		}
		if (_preBackBonesCount != BackBonesCount)
		{
			if (BackBonesCount > _preBackBonesCount)
			{
				for (int j = _preBackBonesCount; j < LookBones.Count; j++)
				{
					LookBones[j].RefreshStaticRotation();
				}
			}
			preWeightFaloff = FaloffValue - 0.001f;
			_preBackBonesCount = BackBonesCount;
		}
		for (int k = 0; k < CompensationBones.Count; k++)
		{
			if (!((Object)(object)CompensationBones[k].Transform == (Object)null))
			{
				CompensationBones[k].RefreshCompensationFrame();
				CompensationBones[k].CheckForZeroKeyframes();
			}
		}
		if (!BigAngleAutomation)
		{
			if (AutoBackbonesWeights)
			{
				if (FaloffValue != preWeightFaloff)
				{
					SetAutoWeightsDefault();
				}
			}
			else
			{
				RefreshBoneMotionWeights();
			}
			LookBones[0].motionWeight = LookBones[0].lookWeight;
		}
		else
		{
			UpdateAutomationWeights();
		}
		switch (DeltaType)
		{
		case EFDeltaType.DeltaTime:
			delta = Time.deltaTime;
			break;
		case EFDeltaType.SmoothDeltaTime:
			delta = Time.smoothDeltaTime;
			break;
		case EFDeltaType.UnscaledDeltaTime:
			delta = Time.unscaledDeltaTime;
			break;
		case EFDeltaType.FixedDeltaTime:
			delta = Time.fixedDeltaTime;
			break;
		}
		delta *= SimulationSpeed;
		if (RefreshStartLookPoint)
		{
			RefreshLookStartPositionAnchor();
		}
		changeTargetSmootherWeight = Mathf.Min(1f, changeTargetSmootherWeight + delta * 0.6f);
		changeTargetSmootherBones = Mathf.Min(1f, changeTargetSmootherBones + delta * 0.6f);
	}

	private void ChangeBonesRotations()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].Transform.rotation = LookBones[i].finalRotation;
		}
		LookBones[0].Transform.rotation = LookBones[0].finalRotation;
		if (BigAngleAutomationCompensation)
		{
			float num = Mathf.InverseLerp(45f, 170f, Mathf.Abs(unclampedLookAngles.y));
			targetCompensationWeight = Mathf.Lerp(CompensationWeight, CompensationWeightB, num);
			targetCompensationPosWeight = Mathf.Lerp(CompensatePositions, CompensatePositionsB, num);
		}
		else
		{
			targetCompensationWeight = CompensationWeight;
			targetCompensationPosWeight = CompensatePositions;
		}
		for (int j = 0; j < CompensationBones.Count; j++)
		{
			if (!((Object)(object)CompensationBones[j].Transform == (Object)null))
			{
				CompensationBones[j].SetRotationCompensation(targetCompensationWeight);
				CompensationBones[j].SetPositionCompensation(targetCompensationPosWeight);
			}
		}
		if (UseBoneOffsetRotation)
		{
			for (int k = 0; k < LookBones.Count; k++)
			{
				LookBones[k].lastFinalLocalRotation = LookBones[k].Transform.localRotation;
			}
		}
	}

	private void CheckOverrideReference()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Expected O, but got Unknown
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!overrideRefInitialized)
		{
			GameObject val = new GameObject(((Object)LookBones[0].Transform).name + "-Overr");
			val.transform.SetParent(LookBones[0].Transform);
			val.transform.localRotation = Quaternion.identity;
			val.transform.localPosition = Vector3.zero;
			headOv = new UniRotateBone(val.transform, BaseTransform);
			headOv.RefreshCustomAxis(Vector3.up, Vector3.forward);
			overrideRefInitialized = true;
		}
	}

	private void PostAnimatingTweaks()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (OverrideHeadForPerfectLookDirection > 0f)
		{
			CheckOverrideReference();
			Quaternion rotation = LookBones[0].Transform.rotation;
			headOv.transform.localRotation = headOv.initialLocalRotation;
			Vector3 direction = activeLookPosition - headOv.transform.position;
			Vector2 customLookAngles = headOv.GetCustomLookAngles(direction, headOv);
			headOv.transform.rotation = headOv.RotateCustomAxis(customLookAngles.x + RotationOffset.x, customLookAngles.y + RotationOffset.y, headOv) * headOv.transform.rotation;
			LookBones[0].Transform.rotation = Quaternion.Lerp(rotation, headOv.transform.rotation, OverrideHeadForPerfectLookDirection);
		}
	}

	private void ResetBones(bool onlyIfNull = false)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (UseBoneOffsetRotation)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].animatedTargetRotation = Quaternion.identity;
				LookBones[i].targetRotation = LookBones[i].animatedTargetRotation;
				LookBones[i].finalRotation = LookBones[i].animatedTargetRotation;
			}
		}
		else
		{
			for (int j = 0; j < LookBones.Count; j++)
			{
				LookBones[j].animatedTargetRotation = LookBones[j].Transform.rotation;
				LookBones[j].targetRotation = LookBones[j].animatedTargetRotation;
				LookBones[j].finalRotation = LookBones[j].animatedTargetRotation;
			}
		}
	}

	internal void RefreshLookBones()
	{
		if (LookBones == null)
		{
			LookBones = new List<LookBone>();
			LookBones.Add(new LookBone(null));
		}
		if (LookBones.Count == 0)
		{
			LookBones.Add(new LookBone(null));
		}
		if (LookBones.Count > BackBonesCount + 1)
		{
			LookBones.RemoveRange(BackBonesCount + 1, LookBones.Count - (BackBonesCount + 1));
		}
		if (Object.op_Implicit((Object)(object)LeadBone))
		{
			if ((Object)(object)LookBones[0].Transform != (Object)(object)LeadBone)
			{
				LookBones[0] = new LookBone(LeadBone);
				if (Object.op_Implicit((Object)(object)BaseTransform))
				{
					LookBones[0].RefreshBoneDirections(BaseTransform);
				}
			}
			for (int i = 1; i < 1 + BackBonesCount; i++)
			{
				if (i >= LookBones.Count)
				{
					LookBone lookBone = new LookBone(LookBones[i - 1].Transform.parent);
					LookBones.Add(lookBone);
					if (Object.op_Implicit((Object)(object)BaseTransform))
					{
						lookBone.RefreshBoneDirections(BaseTransform);
					}
				}
				else if (LookBones[i] == null || (Object)(object)LookBones[i].Transform == (Object)null)
				{
					LookBones[i] = new LookBone(LookBones[i - 1].Transform.parent);
					if (Object.op_Implicit((Object)(object)BaseTransform))
					{
						LookBones[i].RefreshBoneDirections(BaseTransform);
					}
				}
			}
		}
		else
		{
			while (LookBones.Count > 1)
			{
				LookBones.RemoveAt(LookBones.Count - 1);
			}
		}
	}

	private void RefreshReferencePose()
	{
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].RefreshStaticRotation(!MonitorAnimator);
		}
		if (MonitorAnimator)
		{
			((MonoBehaviour)this).StopCoroutine(CRefreshReferencePose());
			((MonoBehaviour)this).StartCoroutine(CRefreshReferencePose());
		}
		refreshReferencePose = false;
	}

	private IEnumerator CRefreshReferencePose()
	{
		yield return null;
		yield return CoroutineEx.waitForSecondsRealtime(0.05f);
		if (_monitorTransitionStart == null)
		{
			_monitorTransitionStart = new List<Quaternion>();
		}
		if (_monitorTransitionStart.Count != LookBones.Count)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				_monitorTransitionStart.Add(LookBones[i].animatedStaticRotation);
			}
		}
		for (int j = 0; j < LookBones.Count; j++)
		{
			LookBones[j].RefreshStaticRotation(hard: false);
		}
		float elapsed = 0f;
		while (elapsed < monitorTransitionTime)
		{
			elapsed += delta;
			float num = FEasing.EaseInOutCubic(0f, 1f, elapsed / monitorTransitionTime);
			for (int k = 0; k < LookBones.Count; k++)
			{
				LookBones[k].animatedStaticRotation = Quaternion.Slerp(_monitorTransitionStart[k], LookBones[k].targetStaticRotation, num);
			}
			yield return null;
		}
		for (int l = 0; l < LookBones.Count; l++)
		{
			LookBones[l].animatedStaticRotation = LookBones[l].targetStaticRotation;
		}
	}

	public void InitializeBaseVariables()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		_LOG_NoRefs();
		LookState = EFHeadLookState.Null;
		if (AutoBackbonesWeights)
		{
			SetAutoWeightsDefault();
		}
		ComputeBonesRotationsFixVariables();
		InitBirdMode();
		ResetBones();
		smoothLookPosition = GetForwardPosition();
		lookFreezeFocusPoint = BaseTransform.InverseTransformPoint(smoothLookPosition);
		refreshReferencePose = true;
		RefreshStartLookPoint = true;
		rootStaticRotation = BaseTransform.rotation;
		_preBackBonesCount = BackBonesCount;
		lastBaseRotation = BaseTransform.rotation;
		for (int i = 0; i < LookBones.Count; i++)
		{
			if (LookBones[i].correctionOffset == Vector3.zero)
			{
				LookBones[i].correctionOffset = Vector3.zero;
			}
			LookBones[i].lastKeyframeRotation = LookBones[i].Transform.localRotation;
			LookBones[i].RefreshBoneDirections(BaseTransform);
		}
		CheckOverrideReference();
		if (UseEyes)
		{
			InitEyesModule();
		}
		initialized = true;
	}

	public void FindBaseTransform()
	{
		BaseTransform = ((Component)this).transform;
		if (!Object.op_Implicit((Object)(object)((Component)this).GetComponentInChildren<Animator>()) && !Object.op_Implicit((Object)(object)((Component)this).GetComponentInChildren<Animation>()))
		{
			Debug.LogWarning((object)(((Object)((Component)this).gameObject).name + " don't have animator. '" + ((Object)this).name + "' is it root transform for your character?"));
		}
	}

	public Vector3 TryFindHeadPositionInTarget(Transform other)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		FLookAnimator component = ((Component)other).GetComponent<FLookAnimator>();
		if (Object.op_Implicit((Object)(object)component) && Object.op_Implicit((Object)(object)component.LeadBone))
		{
			return component.GetLookStartMeasurePosition();
		}
		Animator componentInChildren = ((Component)other).GetComponentInChildren<Animator>();
		if (Object.op_Implicit((Object)(object)componentInChildren) && componentInChildren.isHuman)
		{
			if (Object.op_Implicit((Object)(object)componentInChildren.GetBoneTransform((HumanBodyBones)21)))
			{
				return componentInChildren.GetBoneTransform((HumanBodyBones)21).position;
			}
			if (Object.op_Implicit((Object)(object)componentInChildren.GetBoneTransform((HumanBodyBones)10)))
			{
				return componentInChildren.GetBoneTransform((HumanBodyBones)10).position;
			}
		}
		Renderer componentInChildren2 = ((Component)other).GetComponentInChildren<Renderer>();
		if (!Object.op_Implicit((Object)(object)componentInChildren2) && other.childCount > 0)
		{
			componentInChildren2 = ((Component)other.GetChild(0)).GetComponentInChildren<Renderer>();
		}
		if (Object.op_Implicit((Object)(object)componentInChildren2))
		{
			Vector3 position = other.position;
			Vector3 up = Vector3.up;
			Bounds bounds = componentInChildren2.bounds;
			Vector3 val = position + other.TransformVector(up * (((Bounds)(ref bounds)).max.y * 0.9f));
			Vector3 forward = Vector3.forward;
			bounds = componentInChildren2.bounds;
			return val + other.TransformVector(forward * (((Bounds)(ref bounds)).max.z * 0.75f));
		}
		return other.position;
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private float GetClampedAngle(float current, float limit, float elastic, float sign = 1f)
	{
		if (elastic <= 0f)
		{
			return limit;
		}
		float num = 0f;
		if (elastic > 0f)
		{
			num = FEasing.EaseOutCubic(0f, elastic, (current * sign - limit * sign) / (180f + limit * sign));
		}
		return limit + num * sign;
	}

	private void ComputeBonesRotationsFixVariables()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)BaseTransform != (Object)null)
		{
			Quaternion rotation = BaseTransform.rotation;
			BaseTransform.rotation = Quaternion.identity;
			FromAuto = LeadBone.rotation * -Vector3.forward;
			float num = Quaternion.Angle(Quaternion.identity, LeadBone.rotation);
			Quaternion val = LeadBone.rotation * Quaternion.Inverse(Quaternion.FromToRotation(FromAuto, ModelForwardAxis));
			Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
			Quaternion val2 = Quaternion.AngleAxis(num, ((Vector3)(ref eulerAngles)).normalized);
			OffsetAuto = ((Quaternion)(ref val2)).eulerAngles;
			BaseTransform.rotation = rotation;
			RefreshParentalLookReferenceAxis();
			headForward = Quaternion.FromToRotation(LeadBone.InverseTransformDirection(BaseTransform.TransformDirection(((Vector3)(ref ModelForwardAxis)).normalized)), Vector3.forward) * Vector3.forward;
		}
		else
		{
			Debug.LogWarning((object)"Base Transform isn't defined, so we can't use auto correction!");
		}
	}

	private void RefreshParentalLookReferenceAxis()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		parentalReferenceLookForward = Quaternion.Inverse(LeadBone.parent.rotation) * BaseTransform.rotation * ((Vector3)(ref ModelForwardAxis)).normalized;
		parentalReferenceUp = Quaternion.Inverse(LeadBone.parent.rotation) * BaseTransform.rotation * ((Vector3)(ref ModelUpAxis)).normalized;
	}

	public Vector3 GetCurrentHeadForwardDirection()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		return LeadBone.rotation * Quaternion.FromToRotation(headForward, Vector3.forward) * Vector3.forward;
	}

	private void _LOG_NoRefs()
	{
	}

	private void _Debug_Rays()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (DebugRays)
		{
			Debug.DrawRay(GetLookStartMeasurePosition() + Vector3.up * 0.01f, Quaternion.Euler(finalLookAngles) * BaseTransform.TransformDirection(ModelForwardAxis), Color.cyan);
		}
	}

	private Vector3 WrapVector(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(FLogicMethods.WrapAngle(v.x), FLogicMethods.WrapAngle(v.y), FLogicMethods.WrapAngle(v.z));
	}

	private Vector3 ConvertFlippedAxes(Vector3 rotations)
	{
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (FixingPreset != 0)
		{
			Quaternion val;
			if (FixingPreset == EFAxisFixOrder.FromBased)
			{
				rotations += OffsetAuto;
				val = Quaternion.Euler(rotations) * Quaternion.FromToRotation(FromAuto, ModelForwardAxis);
				rotations = ((Quaternion)(ref val)).eulerAngles;
			}
			else
			{
				if (FixingPreset == EFAxisFixOrder.FullManual)
				{
					rotations.x *= RotCorrectionMultiplier.x;
					rotations.y *= RotCorrectionMultiplier.y;
					rotations.z *= RotCorrectionMultiplier.z;
					val = Quaternion.Euler(rotations) * Quaternion.FromToRotation(ManualFromAxis, ManualToAxis);
					return ((Quaternion)(ref val)).eulerAngles;
				}
				if (FixingPreset == EFAxisFixOrder.ZYX)
				{
					val = Quaternion.Euler(rotations.z, rotations.y - 90f, 0f - rotations.x - 90f);
					return ((Quaternion)(ref val)).eulerAngles;
				}
			}
		}
		return rotations;
	}

	public static float AngleAroundAxis(Vector3 firstDirection, Vector3 secondDirection, Vector3 axis)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		firstDirection -= Vector3.Project(firstDirection, axis);
		secondDirection -= Vector3.Project(secondDirection, axis);
		return Vector3.Angle(firstDirection, secondDirection) * (float)((!(Vector3.Dot(axis, Vector3.Cross(firstDirection, secondDirection)) < 0f)) ? 1 : (-1));
	}

	private void Reset()
	{
		FindBaseTransform();
	}

	private void Awake()
	{
		_LOG_NoRefs();
	}

	protected virtual void Start()
	{
		initialized = false;
		if (!StartAfterTPose)
		{
			InitializeBaseVariables();
		}
		else
		{
			startAfterTPoseCounter = 0;
		}
	}

	public void ResetLook()
	{
		ResetBones();
		finalMotionWeight = 0f;
		_velo_animatedMotionWeight = 0f;
		animatedMotionWeight = 0f;
	}

	private void Tick()
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FLookAnimator:Tick", 0);
		try
		{
			if (!initialized)
			{
				if (StartAfterTPose)
				{
					startAfterTPoseCounter++;
					if (startAfterTPoseCounter > 6)
					{
						InitializeBaseVariables();
					}
				}
				updateLookAnimator = false;
				return;
			}
			if ((Object)(object)OptimizeWithAnimator != (Object)null && !((Behaviour)OptimizeWithAnimator).enabled)
			{
				updateLookAnimator = false;
				wasUpdating = false;
				return;
			}
			if (!wasUpdating)
			{
				ResetLook();
				wasUpdating = true;
			}
			if (AnimatePhysics)
			{
				if (!animatePhysicsWorking)
				{
					((MonoBehaviour)this).StartCoroutine(AnimatePhysicsClock());
				}
				if (!triggerAnimatePhysics)
				{
					updateLookAnimator = false;
					return;
				}
				triggerAnimatePhysics = false;
			}
			if (finalMotionWeight < 0.01f)
			{
				animatedLookAngles = Vector3.zero;
				if (LookAnimatorAmount <= 0f)
				{
					updateLookAnimator = false;
					return;
				}
			}
			UpdateCorrectionMatrix();
			updateLookAnimator = true;
			if (!AnimatePhysics)
			{
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FixedTick()
	{
		TimeWarning val = TimeWarning.New("FLookAnimator:FixedTick", 0);
		try
		{
			if (updateLookAnimator && AnimatePhysics)
			{
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void LateTick()
	{
		TimeWarning val = TimeWarning.New("FLookAnimator:LateTick", 0);
		try
		{
			if (updateLookAnimator)
			{
				CalibrateBones();
				TargetingUpdate();
				BeginStateCheck();
				UpdateSmoothing();
				MaxDistanceCalculations();
				NoddingCalculations();
				CalculateLookAnimation();
				UpdateLookAnimatorAmountWeight();
				ChangeBonesRotations();
				_Debug_Rays();
				if (BirdMode)
				{
					CalculateBirdMode();
				}
				if (UseEyes)
				{
					UpdateEyesLogics();
				}
				EndUpdate();
				PostAnimatingTweaks();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class CompensationBone
{
	public Transform Transform;

	private Vector3 compensatedPosition;

	private Quaternion compensatedRotation;

	private Quaternion lastFinalLocalRotation;

	private Quaternion lastKeyframeLocalRotation;

	private Vector3 lastFinalLocalPosition;

	private Vector3 lastKeyframeLocalPosition;

	public CompensationBone(Transform t)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Transform = t;
		if (Object.op_Implicit((Object)(object)t))
		{
			lastKeyframeLocalPosition = t.localPosition;
			lastKeyframeLocalRotation = t.localRotation;
		}
	}

	public void RefreshCompensationFrame()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		compensatedPosition = Transform.position;
		compensatedRotation = Transform.rotation;
	}

	public void CheckForZeroKeyframes()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if (lastFinalLocalRotation.QIsSame(Transform.localRotation))
		{
			Transform.localRotation = lastKeyframeLocalRotation;
			compensatedRotation = Transform.rotation;
		}
		else
		{
			lastKeyframeLocalRotation = Transform.localRotation;
		}
		if (lastFinalLocalPosition.VIsSame(Transform.localPosition))
		{
			Transform.localPosition = lastKeyframeLocalPosition;
			compensatedPosition = Transform.position;
		}
		else
		{
			lastKeyframeLocalPosition = Transform.localPosition;
		}
	}

	public void SetRotationCompensation(float weight)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (weight > 0f)
		{
			if (weight >= 1f)
			{
				Transform.rotation = compensatedRotation;
			}
			else
			{
				Transform.rotation = Quaternion.LerpUnclamped(Transform.rotation, compensatedRotation, weight);
			}
			lastFinalLocalRotation = Transform.localRotation;
		}
	}

	public void SetPositionCompensation(float weight)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (weight > 0f)
		{
			if (weight >= 1f)
			{
				Transform.position = compensatedPosition;
			}
			else
			{
				Transform.position = Vector3.LerpUnclamped(Transform.position, compensatedPosition, weight);
			}
			lastFinalLocalPosition = Transform.localPosition;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class LookBone
{
	public Transform Transform;

	public Quaternion animatedStaticRotation;

	public Quaternion targetStaticRotation;

	public Quaternion localStaticRotation;

	public Quaternion animatedTargetRotation;

	public Quaternion targetRotation;

	public Vector3 correctionOffset;

	public Quaternion finalRotation;

	public Quaternion lastKeyframeRotation;

	public Quaternion lastFinalLocalRotation;

	public Vector3 forward;

	public Vector3 right;

	public Vector3 up;

	public Vector3 initLocalPos = Vector3.zero;

	public Quaternion initLocalRot = Quaternion.identity;

	public Vector3 targetDelayPosition;

	public Vector3 animatedDelayPosition;

	public float lookWeight = 1f;

	public float lookWeightB = 1f;

	public float motionWeight = 1f;

	public Quaternion correctionOffsetQ => Quaternion.Euler(correctionOffset);

	public LookBone(Transform t)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Transform = t;
		correctionOffset = Vector3.zero;
		if ((Object)(object)t != (Object)null)
		{
			initLocalPos = t.localPosition;
			initLocalRot = t.localRotation;
		}
	}

	public void RefreshBoneDirections(Transform baseTransform)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)Transform == (Object)null))
		{
			forward = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.forward), Vector3.forward) * Vector3.forward;
			up = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.up), Vector3.up) * Vector3.up;
			right = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.right), Vector3.right) * Vector3.right;
		}
	}

	public void RefreshStaticRotation(bool hard = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		targetStaticRotation = Transform.rotation;
		if (initLocalPos == Vector3.zero)
		{
			initLocalPos = Transform.localPosition;
		}
		if (hard)
		{
			animatedStaticRotation = targetStaticRotation;
		}
		localStaticRotation = Transform.localRotation;
	}

	internal void CalculateMotion(Quaternion targetLook, float overallWeightMultiplier, float delta, float mainWeight)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		targetRotation = GetTargetRot(targetLook, motionWeight * overallWeightMultiplier);
		if (delta < 1f)
		{
			animatedTargetRotation = Quaternion.LerpUnclamped(animatedTargetRotation, targetRotation, delta);
		}
		else
		{
			animatedTargetRotation = targetRotation;
		}
		finalRotation = Quaternion.LerpUnclamped(Transform.rotation, animatedTargetRotation * Transform.rotation, mainWeight);
	}

	internal Quaternion GetTargetRot(Quaternion targetLook, float weight)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LerpUnclamped(Quaternion.identity, targetLook, weight);
	}
}


public enum EEditorLookCategory
{
	Setup,
	Tweak,
	Limit,
	Features,
	Corrections
}


public enum EFAxisFixOrder
{
	Parental,
	FromBased,
	FullManual,
	ZYX
}


public enum EFHeadLookState
{
	Null,
	Following,
	OutOfMaxRotation,
	ClampedAngle,
	OutOfMaxDistance
}


public enum EFFollowMode
{
	FollowObject,
	LocalOffset,
	WorldOffset,
	ToFollowSpaceOffset,
	FollowJustPosition
}


public enum EFDeltaType
{
	DeltaTime,
	SmoothDeltaTime,
	UnscaledDeltaTime,
	FixedDeltaTime
}


public enum EFAnimationStyle
{
	SmoothDamp,
	FastLerp,
	Linear
}


using FIMSpace.FLook;
using UnityEngine;

public class SM_SwitchLookAnimator : StateMachineBehaviour
{
	[Tooltip("Time of animation")]
	[Range(0f, 1f)]
	public float EnableBackAfter = 0.9f;

	public float TransitionDuration = 0.3f;

	private bool enableBackTriggered;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		SwitchLook(animator, enable: false);
		enableBackTriggered = false;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		if (!animator.IsInTransition(layerIndex) && ((AnimatorStateInfo)(ref stateInfo)).normalizedTime > EnableBackAfter && !enableBackTriggered)
		{
			SwitchLook(animator, enable: true);
			enableBackTriggered = true;
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex);
		if (!enableBackTriggered)
		{
			SwitchLook(animator, enable: true);
			enableBackTriggered = true;
		}
	}

	private void SwitchLook(Animator animator, bool enable)
	{
		((Component)animator).GetComponentInChildren<FLookAnimator>().SwitchLooking(enable, TransitionDuration);
	}
}


using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;

[Factory("ai")]
public class AI : ConsoleSystem
{
	[ReplicatedVar(Saved = true)]
	public static bool allowdesigning = true;

	[ReplicatedVar]
	public static bool npcBarksEnabled = false;

	public const float showCommandsRefreshInterval = 0.1f;

	public const float animFadeDuration = 0.25f;

	[ServerVar]
	public static bool think = true;

	[ServerVar]
	public static bool navthink = true;

	[ServerVar]
	public static bool ignoreplayers = false;

	[ServerVar]
	public static bool effectaiweapons = false;

	[ServerVar]
	public static bool groups = true;

	[ServerVar]
	public static bool spliceupdates = true;

	[ServerVar]
	public static bool setdestinationsamplenavmesh = true;

	[ServerVar]
	public static bool usecalculatepath = true;

	[ServerVar]
	public static bool usesetdestinationfallback = true;

	[ServerVar]
	public static bool npcswimming = true;

	[ServerVar]
	public static bool accuratevisiondistance = true;

	[ServerVar]
	public static bool move = true;

	[ServerVar]
	public static bool usegrid = true;

	[ServerVar]
	public static bool sleepwake = true;

	[ServerVar]
	public static float sensetime = 1f;

	[ServerVar]
	public static float frametime = 5f;

	[ServerVar]
	public static int ocean_patrol_path_iterations = 100000;

	[ServerVar(Help = "If npc_enable is set to false then npcs won't spawn. (default: true)")]
	public static bool npc_enable = true;

	[ServerVar(Help = "npc_max_population_military_tunnels defines the size of the npc population at military tunnels. (default: 3)")]
	public static int npc_max_population_military_tunnels = 3;

	[ServerVar(Help = "npc_spawn_per_tick_max_military_tunnels defines how many can maximum spawn at once at military tunnels. (default: 1)")]
	public static int npc_spawn_per_tick_max_military_tunnels = 1;

	[ServerVar(Help = "npc_spawn_per_tick_min_military_tunnels defineshow many will minimum spawn at once at military tunnels. (default: 1)")]
	public static int npc_spawn_per_tick_min_military_tunnels = 1;

	[ServerVar(Help = "npc_respawn_delay_max_military_tunnels defines the maximum delay between spawn ticks at military tunnels. (default: 1920)")]
	public static float npc_respawn_delay_max_military_tunnels = 1920f;

	[ServerVar(Help = "npc_respawn_delay_min_military_tunnels defines the minimum delay between spawn ticks at military tunnels. (default: 480)")]
	public static float npc_respawn_delay_min_military_tunnels = 480f;

	[ServerVar(Help = "npc_valid_aim_cone defines how close their aim needs to be on target in order to fire. (default: 0.8)")]
	public static float npc_valid_aim_cone = 0.8f;

	[ServerVar(Help = "npc_valid_mounted_aim_cone defines how close their aim needs to be on target in order to fire while mounted. (default: 0.92)")]
	public static float npc_valid_mounted_aim_cone = 0.92f;

	[ServerVar(Help = "npc_cover_compromised_cooldown defines how long a cover point is marked as compromised before it's cleared again for selection. (default: 10)")]
	public static float npc_cover_compromised_cooldown = 10f;

	[ServerVar(Help = "If npc_cover_use_path_distance is set to true then npcs will look at the distance between the cover point and their target using the path between the two, rather than the straight-line distance.")]
	public static bool npc_cover_use_path_distance = true;

	[ServerVar(Help = "npc_cover_path_vs_straight_dist_max_diff defines what the maximum difference between straight-line distance and path distance can be when evaluating cover points. (default: 2)")]
	public static float npc_cover_path_vs_straight_dist_max_diff = 2f;

	[ServerVar(Help = "npc_door_trigger_size defines the size of the trigger box on doors that opens the door as npcs walk close to it (default: 1.5)")]
	public static float npc_door_trigger_size = 1.5f;

	[ServerVar(Help = "npc_patrol_point_cooldown defines the cooldown time on a patrol point until it's available again (default: 5)")]
	public static float npc_patrol_point_cooldown = 5f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the walk state, and should be a number between 0 and 1. (Default: 0.18)")]
	public static float npc_speed_walk = 0.18f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the run state, and should be a number between 0 and 1. (Default: 0.4)")]
	public static float npc_speed_run = 0.4f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the sprint state, and should be a number between 0 and 1. (Default: 1.0)")]
	public static float npc_speed_sprint = 1f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the crouched walk state, and should be a number between 0 and 1. (Default: 0.1)")]
	public static float npc_speed_crouch_walk = 0.1f;

	[ServerVar(Help = "npc_speed_crouch_run define the speed of an npc when in the crouched run state, and should be a number between 0 and 1. (Default: 0.25)")]
	public static float npc_speed_crouch_run = 0.25f;

	[ServerVar(Help = "npc_alertness_drain_rate define the rate at which we drain the alertness level of an NPC when there are no enemies in sight. (Default: 0.01)")]
	public static float npc_alertness_drain_rate = 0.01f;

	[ServerVar(Help = "npc_alertness_zero_detection_mod define the threshold of visibility required to detect an enemy when alertness is zero. (Default: 0.5)")]
	public static float npc_alertness_zero_detection_mod = 0.5f;

	[ServerVar(Help = "defines the chance for scientists to spawn at NPC junkpiles. (Default: 0.1)")]
	public static float npc_junkpilespawn_chance = 0.07f;

	[ServerVar(Help = "npc_junkpile_dist_aggro_gate define at what range (or closer) a junkpile scientist will get aggressive. (Default: 8)")]
	public static float npc_junkpile_dist_aggro_gate = 8f;

	[ServerVar(Help = "npc_max_junkpile_count define how many npcs can spawn into the world at junkpiles at the same time (does not include monuments) (Default: 30)")]
	public static int npc_max_junkpile_count = 30;

	[ServerVar(Help = "If npc_families_no_hurt is true, npcs of the same family won't be able to hurt each other. (default: true)")]
	public static bool npc_families_no_hurt = true;

	[ServerVar(Help = "If npc_ignore_chairs is true, npcs won't care about seeking out and sitting in chairs. (default: true)")]
	public static bool npc_ignore_chairs = true;

	[ServerVar(Help = "The rate at which we tick the sensory system. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 5)")]
	public static float npc_sensory_system_tick_rate_multiplier = 5f;

	[ServerVar(Help = "The rate at which we gather information about available cover points. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 20)")]
	public static float npc_cover_info_tick_rate_multiplier = 20f;

	[ServerVar(Help = "The rate at which we tick the reasoning system. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 1)")]
	public static float npc_reasoning_system_tick_rate_multiplier = 1f;

	[ServerVar]
	public static bool npc_check_spawner_is_on_navmesh = true;

	[ServerVar(Help = "If animal_ignore_food is true, animals will not sense food sources or interact with them (server optimization). (default: true)")]
	public static bool animal_ignore_food = true;

	[ServerVar(Help = "The modifier by which a silencer reduce the noise that a gun makes when shot. (Default: 0.15)")]
	public static float npc_gun_noise_silencer_modifier = 0.15f;

	[ServerVar(Help = "If nav_carve_use_building_optimization is true, we attempt to reduce the amount of navmesh carves for a building. (default: false)")]
	public static bool nav_carve_use_building_optimization = false;

	[ServerVar(Help = "The minimum number of building blocks a building needs to consist of for this optimization to be applied. (default: 25)")]
	public static int nav_carve_min_building_blocks_to_apply_optimization = 25;

	[ServerVar(Help = "The minimum size we allow a carving volume to be. (default: 2)")]
	public static float nav_carve_min_base_size = 2f;

	[ServerVar(Help = "The size multiplier applied to the size of the carve volume. The smaller the value, the tighter the skirt around foundation edges, but too small and animals can attack through walls. (default: 4)")]
	public static float nav_carve_size_multiplier = 4f;

	[ServerVar(Help = "The height of the carve volume. (default: 2)")]
	public static float nav_carve_height = 2f;

	[ServerVar(Help = "If npc_only_hurt_active_target_in_safezone is true, npcs won't any player other than their actively targeted player when in a safe zone. (default: true)")]
	public static bool npc_only_hurt_active_target_in_safezone = true;

	[ServerVar(Help = "If npc_use_new_aim_system is true, npcs will miss on purpose on occasion, where the old system would randomize aim cone. (default: true)")]
	public static bool npc_use_new_aim_system = true;

	[ServerVar(Help = "If npc_use_thrown_weapons is true, npcs will throw grenades, etc. This is an experimental feature. (default: true)")]
	public static bool npc_use_thrown_weapons = true;

	[ServerVar(Help = "This is multiplied with the max roam range stat of an NPC to determine how far from its spawn point the NPC is allowed to roam. (default: 3)")]
	public static float npc_max_roam_multiplier = 3f;

	[ServerVar(Help = "This is multiplied with the current alertness (0-10) to decide how long it will take for the NPC to deliberately miss again. (default: 0.33)")]
	public static float npc_alertness_to_aim_modifier = 0.5f;

	[ServerVar(Help = "The time it takes for the NPC to deliberately miss to the time the NPC tries to hit its target. (default: 1.5)")]
	public static float npc_deliberate_miss_to_hit_alignment_time = 1.5f;

	[ServerVar(Help = "The offset with which the NPC will maximum miss the target. (default: 1.25)")]
	public static float npc_deliberate_miss_offset_multiplier = 1.25f;

	[ServerVar(Help = "The percentage away from a maximum miss the randomizer is allowed to travel when shooting to deliberately hit the target (we don't want perfect hits with every shot). (default: 0.85f)")]
	public static float npc_deliberate_hit_randomizer = 0.85f;

	[ServerVar(Help = "Baseline damage modifier for the new HTN Player NPCs to nerf their damage compared to the old NPCs. (default: 1.15f)")]
	public static float npc_htn_player_base_damage_modifier = 1.15f;

	[ServerVar(Help = "Spawn NPCs on the Cargo Ship. (default: true)")]
	public static bool npc_spawn_on_cargo_ship = true;

	[ServerVar(Help = "Spawn NPCs on junkpiles (default: true)")]
	public static bool npc_spawn_on_junkpile = true;

	[ServerVar(Help = "Spawn NPCs on deep sea islands (default: false)")]
	public static bool npc_spawn_on_deep_sea_islands = true;

	[ServerVar(Help = "Do any kind of scientists spawn on the map (default: true)")]
	public static bool scientist_spawners_enabled = true;

	[ServerVar(Help = "npc_htn_player_frustration_threshold defines where the frustration threshold for NPCs go, where they have the opportunity to change to a more aggressive tactic. (default: 3)")]
	public static int npc_htn_player_frustration_threshold = 3;

	[ServerVar]
	public static bool logIssues = false;

	[ServerVar]
	public static float tickrate = 5f;

	[ServerVar(Help = "The angle under which the AI will think it's being watched by another entity")]
	public static float watchedAngle = 50f;

	[ServerVar(Help = "The angle under which the AI will think it's being aimed at at by a player")]
	public static float aimedAtAngle = 10f;

	private const float npcDefaultReactionTime = 0.65f;

	public static float npcReactionTime = 0.65f;

	[ServerVar]
	public static float npcHealthMultiplier = 1f;

	public const float minDepthToBeConsideredInWater = 0.3f;

	[ServerVar]
	public static float defaultInterpolationDelay = 0.1f;

	[ServerVar]
	public static void showState(Arg arg)
	{
		arg.Player()?.ToggleShowFSMStateDebugInfo();
	}

	[ServerVar]
	public static void sleepwakestats(Arg args)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			if (!((Object)(object)zone == (Object)null) && zone.ShouldSleepAI)
			{
				num++;
				if (zone.Sleeping)
				{
					num2++;
					num3 += zone.SleepingCount;
				}
			}
		}
		args.ReplyWith("Sleeping AIZs: " + num2 + " / " + num + ". Total sleeping ents: " + num3);
	}

	[ServerVar]
	public static void wakesleepingai(Arg args)
	{
		int num = 0;
		int num2 = 0;
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			if (!((Object)(object)zone == (Object)null) && zone.ShouldSleepAI && zone.Sleeping)
			{
				num++;
				num2 += zone.SleepingCount;
				zone.WakeAI();
			}
		}
		args.ReplyWith("Woke " + num + " sleeping AIZs containing " + num2 + " sleeping entities.");
	}

	[ServerVar]
	public static void brainstats(Arg args)
	{
		int num = BaseEntity.Util.FindAll<BaseNPC2>().Length;
		int num2 = AnimalBrain.Count + ScientistBrain.Count + PetBrain.Count;
		args.ReplyWith($"Animal: {AnimalBrain.Count}. Scientist: {ScientistBrain.Count}. Pet: {PetBrain.Count}. NPC2:{num}. Total: {num2}");
	}

	[ServerVar]
	public static void aizonestats(Arg args)
	{
		args.ReplyWith("AIInformationZone count: " + AIInformationZone.zones.Count);
	}

	[ServerVar]
	public static void killscientists(Arg args)
	{
		ScientistNPC[] array = BaseEntity.Util.FindAll<ScientistNPC>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
		TunnelDweller[] array2 = BaseEntity.Util.FindAll<TunnelDweller>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].Kill();
		}
		BaseNPC2[] array3 = BaseEntity.Util.FindAll<BaseNPC2>();
		foreach (BaseNPC2 baseNPC in array3)
		{
			if (!baseNPC.IsAnimal)
			{
				baseNPC.Kill();
			}
		}
	}

	[ServerVar]
	public static void killanimals(Arg args)
	{
		BaseAnimalNPC[] array = BaseEntity.Util.FindAll<BaseAnimalNPC>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
		BaseNPC2[] array2 = BaseEntity.Util.FindAll<BaseNPC2>();
		foreach (BaseNPC2 baseNPC in array2)
		{
			if (baseNPC.IsAnimal)
			{
				baseNPC.Kill();
			}
		}
	}

	[ServerVar(Help = "Add a player (or command user if no player is specified) to the AIs ignore list.")]
	public static void addignoreplayer(Arg args)
	{
		BasePlayer basePlayer = null;
		basePlayer = (args.HasArgs(1) ? args.GetPlayerOrSleeper(0) : args.Player());
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null || basePlayer.net.connection == null)
		{
			args.ReplyWith("Player not found.");
		}
		else
		{
			SimpleAIMemory.AddIgnorePlayer(basePlayer);
		}
	}

	[ServerVar(Help = "Remove a player (or command user if no player is specified) from the AIs ignore list.")]
	public static void removeignoreplayer(Arg args)
	{
		BasePlayer basePlayer = null;
		basePlayer = (args.HasArgs(1) ? args.GetPlayerOrSleeper(0) : args.Player());
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null || basePlayer.net.connection == null)
		{
			args.ReplyWith("Player not found.");
		}
		else
		{
			SimpleAIMemory.RemoveIgnorePlayer(basePlayer);
		}
	}

	[ServerVar(Help = "Remove all players from the AIs ignore list.")]
	public static void clearignoredplayers(Arg args)
	{
		SimpleAIMemory.ClearIgnoredPlayers();
	}

	[ServerVar(Help = "Print a lost of all the players in the AI ignore list.")]
	public static void printignoredplayers(Arg args)
	{
		args.ReplyWith(SimpleAIMemory.GetIgnoredPlayers());
	}

	[ServerVar(Help = "The time it takes for a NPC to fully notice a player standing right in front of them, in seconds.")]
	public static void SetNpcReactionTime(Arg args)
	{
		npcReactionTime = Mathf.Clamp(args.GetFloat(0, 0.65f), 0.001f, 5f);
		args.ReplyWith($"NPC reaction time set to {npcReactionTime} seconds.");
	}

	public static float TickDelta()
	{
		return 1f / tickrate;
	}

	[ServerVar]
	public static void selectNPCLookatServer(Arg args)
	{
	}

	[ServerVar]
	public static void showDistributions(Arg args)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Newtonsoft.Json;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Scripting;

[Factory("global")]
public class Admin : ConsoleSystem
{
	private enum ChangeGradeMode
	{
		Upgrade,
		Downgrade
	}

	[Preserve]
	[JsonModel]
	public struct PlayerInfo
	{
		public string SteamID;

		public string OwnerSteamID;

		public string DisplayName;

		public int Ping;

		public string Address;

		public ulong EntityId;

		public int ConnectedSeconds;

		public float ViolationLevel;

		public float CurrentLevel;

		public float UnspentXp;

		public float Health;
	}

	[Preserve]
	[JsonModel]
	public struct PlayerIDInfo
	{
		public string SteamID;

		public string OwnerSteamID;

		public string DisplayName;

		public string Address;

		public ulong EntityId;
	}

	[JsonModel]
	[Preserve]
	public struct ServerInfoOutput
	{
		public string Hostname;

		public int MaxPlayers;

		public int Players;

		public int Queued;

		public int Joining;

		public int ReservedSlots;

		public int EntityCount;

		public string GameTime;

		public int Uptime;

		public string Map;

		public float Framerate;

		public int Memory;

		public int MemoryUsageSystem;

		public int Collections;

		public int NetworkIn;

		public int NetworkOut;

		public bool Restarting;

		public string SaveCreatedTime;

		public int Version;

		public string Protocol;
	}

	[JsonModel]
	[Preserve]
	public struct ServerConvarInfo
	{
		public string FullName;

		public string Value;

		public string Help;
	}

	[Preserve]
	[JsonModel]
	public struct ServerUGCInfo
	{
		public ulong entityId;

		public uint[] crcs;

		public UGCType contentType;

		public uint entityPrefabID;

		public string shortPrefabName;

		public ulong[] playerIds;

		public string contentString;

		public ServerUGCInfo(IUGCBrowserEntity fromEntity)
		{
			entityId = fromEntity.UgcEntity.net.ID.Value;
			crcs = fromEntity.GetContentCRCs;
			contentType = fromEntity.ContentType;
			entityPrefabID = fromEntity.UgcEntity.prefabID;
			shortPrefabName = fromEntity.UgcEntity.ShortPrefabName;
			playerIds = fromEntity.EditingHistory.ToArray();
			contentString = fromEntity.ContentString;
		}
	}

	private struct EntityAssociation
	{
		public BaseEntity TargetEntity;

		public EntityAssociationType AssociationType;
	}

	private enum EntityAssociationType
	{
		Owner,
		Auth,
		LockGuest
	}

	[ReplicatedVar(Help = "Controls whether the in-game admin UI is displayed to admins")]
	public static bool allowAdminUI = true;

	[ServerVar(Help = "Print out currently connected clients")]
	public static void status(Arg arg)
	{
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (@string == "--json")
		{
			@string = arg.GetString(1, "");
		}
		bool flag = arg.HasArg("--json", false);
		string text = string.Empty;
		if (!flag && @string.Length == 0)
		{
			text = text + "hostname: " + ConVar.Server.hostname + "\n";
			text = text + "version : " + 2621 + " secure (secure mode enabled, connected to Steam3)\n";
			text = text + "map     : " + ConVar.Server.level + "\n";
			text += $"players : {((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Count()} ({ConVar.Server.maxplayers} max) ({SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued} queued) ({SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining} joining)\n\n";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("ping");
			val.AddColumn("connected");
			val.AddColumn("addr");
			val.AddColumn("owner");
			val.AddColumn("violation");
			val.AddColumn("kicks");
			val.AddColumn("entityId");
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					try
					{
						if (!current.IsValid())
						{
							continue;
						}
						string userIDString = current.UserIDString;
						if (current.net.connection == null)
						{
							val.AddRow(new string[2] { userIDString, "NO CONNECTION" });
							continue;
						}
						string text2 = current.net.connection.ownerid.ToString();
						string text3 = StringExtensions.QuoteSafe(current.displayName);
						string text4 = Net.sv.GetAveragePing(current.net.connection).ToString();
						string text5 = current.net.connection.ipaddress;
						string text6 = current.net.ID.Value.ToString();
						string text7 = current.violationLevel.ToString("0.0");
						string text8 = current.GetAntiHackKicks().ToString();
						if (!arg.IsAdmin && !arg.IsRcon)
						{
							text5 = "xx.xxx.xx.xxx";
						}
						string text9 = current.net.connection.GetSecondsConnected() + "s";
						if (@string.Length <= 0 || StringEx.Contains(text3, @string, CompareOptions.IgnoreCase) || userIDString.Contains(@string) || text2.Contains(@string) || text5.Contains(@string))
						{
							val.AddRow(new string[9]
							{
								userIDString,
								text3,
								text4,
								text9,
								text5,
								(text2 == userIDString) ? string.Empty : text2,
								text7,
								text8,
								text6
							});
						}
					}
					catch (Exception ex)
					{
						val.AddRow(new string[2]
						{
							current.UserIDString,
							StringExtensions.QuoteSafe(ex.Message)
						});
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			if (flag)
			{
				arg.ReplyWith(val.ToJson(true));
			}
			else
			{
				arg.ReplyWith(text + ((object)val).ToString());
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Print out stats of currently connected clients")]
	public static void stats(Arg arg)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("time");
			val.AddColumn("kills");
			val.AddColumn("deaths");
			val.AddColumn("suicides");
			val.AddColumn("player");
			val.AddColumn("building");
			val.AddColumn("entity");
			ulong uInt = arg.GetUInt64(0, 0uL);
			if (uInt == 0L)
			{
				string @string = arg.GetString(0, "");
				Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						BasePlayer current = enumerator.Current;
						try
						{
							if (current.IsValid())
							{
								string text = StringExtensions.QuoteSafe(current.displayName);
								if (@string.Length <= 0 || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
								{
									addRow(current.userID, text, val);
								}
							}
						}
						catch (Exception ex)
						{
							val.AddRow(new string[2]
							{
								current.UserIDString,
								StringExtensions.QuoteSafe(ex.Message)
							});
						}
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
			else
			{
				string name2 = "N/A";
				BasePlayer basePlayer = BasePlayer.FindByID(uInt);
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					name2 = StringExtensions.QuoteSafe(basePlayer.displayName);
				}
				addRow(uInt, name2, val);
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static void addRow(ulong id, string name, TextTable table)
		{
			ServerStatistics.Storage storage = ServerStatistics.Get(id);
			string text2 = TimeSpan.FromSeconds(storage.Get("time")).ToShortString();
			string text3 = storage.Get("kill_player").ToString();
			string text4 = (storage.Get("deaths") - storage.Get("death_suicide")).ToString();
			string text5 = storage.Get("death_suicide").ToString();
			string text6 = storage.Get("hit_player_direct_los").ToString();
			string text7 = storage.Get("hit_player_indirect_los").ToString();
			string text8 = storage.Get("hit_building_direct_los").ToString();
			string text9 = storage.Get("hit_building_indirect_los").ToString();
			string text10 = storage.Get("hit_entity_direct_los").ToString();
			string text11 = storage.Get("hit_entity_indirect_los").ToString();
			table.AddRow(new string[9]
			{
				id.ToString(),
				name,
				text2,
				text3,
				text4,
				text5,
				text6 + " / " + text7,
				text8 + " / " + text9,
				text10 + " / " + text11
			});
		}
	}

	[ServerVar(Help = "upgrade_radius 'grade' 'radius'")]
	public static void upgrade_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'upgrade_radius {grade} {radius}'");
		}
		else
		{
			SkinRadiusInternal(arg, changeAnyGrade: true);
		}
	}

	[ServerVar(Help = "<grade>")]
	public static void upgrade_looking(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'upgrade_looking {grade}'");
		}
		else
		{
			SkinRaycastInternal(arg, changeAnyGrade: true);
		}
	}

	[ServerVar(Help = "skin_radius 'skin' 'radius'")]
	public static void skin_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'skin_radius {skin} {radius}'");
		}
		else
		{
			SkinRadiusInternal(arg, changeAnyGrade: false);
		}
	}

	[ServerVar(Help = "<skin>")]
	public static void skin_looking(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'skin_looking <skin>'");
		}
		else
		{
			SkinRaycastInternal(arg, changeAnyGrade: false);
		}
	}

	[ServerVar(Help = "<name/id> <radius> | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random")]
	public static void add_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'add_wallpaper_radius {skin} {radius}' | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random");
		}
		else
		{
			wallpaper_radius_internal(arg, addIfMissing: true);
		}
	}

	[ServerVar(Help = "<name/id> <radius> | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random")]
	public static void change_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'change_wallpaper_radius {skin} {radius}' | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random");
		}
		else
		{
			wallpaper_radius_internal(arg, addIfMissing: false);
		}
	}

	[ServerVar(Help = "clear_wallpaper_radius <radius>")]
	public static void clear_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'clear_wallpaper_radius {radius}'");
			return;
		}
		RunInRadius(arg.GetFloat(0, 0f), arg.Player(), delegate(BuildingBlock block)
		{
			if (block.HasWallpaper())
			{
				block.RemoveWallpaper(0);
				block.RemoveWallpaper(1);
			}
		});
	}

	public static BuildingGrade FindBuildingSkin(string name, out string error)
	{
		BuildingGrade buildingGrade = null;
		error = null;
		IEnumerable<BuildingGrade> source = from x in PrefabAttribute.server.FindAll<ConstructionGrade>(2194854973u)
			select x.gradeBase;
		switch (name)
		{
		case "twig":
		case "0":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "twigs");
			break;
		case "wood":
		case "1":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "wood");
			break;
		case "stone":
		case "2":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "stone");
			break;
		case "metal":
		case "sheetmetal":
		case "3":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "metal");
			break;
		case "hqm":
		case "armored":
		case "armoured":
		case "4":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "toptier");
			break;
		case "adobe":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "adobe");
			break;
		case "shipping":
		case "shippingcontainer":
		case "container":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "shipping_container");
			break;
		case "brutal":
		case "brutalist":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "brutalist");
			break;
		case "brick":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "brick");
			break;
		case "jungle":
		case "jungleruin":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "jungle");
			break;
		case "frontier":
		case "legacy":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "frontier");
			break;
		case "gingerbread":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "gingerbread");
			break;
		case "space":
		case "spacestation":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "space_station");
			break;
		default:
			error = "Valid skins are:\ntwig\nwood | frontier | gingerbread\nstone | adobe | brick | brutalist | jungle\nmetal | shipping\nhqm | space";
			return null;
		}
		if ((Object)(object)buildingGrade == (Object)null)
		{
			error = "Unable to find skin object for '" + name + "'";
		}
		return buildingGrade;
	}

	private static IEnumerable<BuildingBlock> SearchRadius(Vector3 position, float radius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BuildingBlock> list = new List<BuildingBlock>();
		Vis.Entities(position, radius, list, 2097152, (QueryTriggerInteraction)2);
		return list;
	}

	private static IEnumerable<BuildingBlock> SearchLookingAt(Vector3 position, Vector3 direction, float maxDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, new Ray(position, direction), 0f, maxDistance, 10485760, (QueryTriggerInteraction)1) as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return Array.Empty<BuildingBlock>();
		}
		return (IEnumerable<BuildingBlock>)(buildingBlock.GetBuilding()?.buildingBlocks);
	}

	private static void SkinRadiusInternal(Arg arg, bool changeAnyGrade)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		IEnumerable<BuildingBlock> blocks = SearchRadius(((Component)arg.Player()).transform.position, arg.GetFloat(1, 0f));
		ApplySkinInternal(arg, changeAnyGrade, blocks);
	}

	private static void SkinRaycastInternal(Arg arg, bool changeAnyGrade)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		IEnumerable<BuildingBlock> blocks = SearchLookingAt(basePlayer.eyes.position, basePlayer.eyes.BodyForward(), 100f);
		ApplySkinInternal(arg, changeAnyGrade, blocks);
	}

	private static void ApplySkinInternal(Arg arg, bool changeAnyGrade, IEnumerable<BuildingBlock> blocks)
	{
		if ((Object)(object)arg.Player() == (Object)null)
		{
			arg.ReplyWith("This must be called from the client");
			return;
		}
		arg.GetFloat(1, 0f);
		string @string = arg.GetString(0, "");
		string error;
		BuildingGrade buildingGrade = FindBuildingSkin(@string, out error);
		if ((Object)(object)buildingGrade == (Object)null)
		{
			arg.ReplyWith(error);
			return;
		}
		if (!buildingGrade.enabledInStandalone)
		{
			arg.ReplyWith("Skin " + @string + " is not enabled in standalone yet");
			return;
		}
		if (blocks == null || blocks.Count() == 0)
		{
			arg.ReplyWith("No building blocks found");
			return;
		}
		foreach (BuildingBlock block in blocks)
		{
			if (block.grade == buildingGrade.type || changeAnyGrade)
			{
				block.ChangeGradeAndSkin(buildingGrade.type, buildingGrade.skin);
			}
		}
	}

	private static void wallpaper_radius_internal(Arg arg, bool addIfMissing)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("This must be called from the client");
			return;
		}
		float @float = arg.GetFloat(1, 0f);
		string @string = arg.GetString(0, "");
		int skinIdParsed = -1;
		if (!int.TryParse(@string, out skinIdParsed))
		{
			skinIdParsed = -1;
		}
		bool flag = false;
		string foundSkinName = "";
		foreach (ItemSkinDirectory.Skin item in WallpaperSettings.WallpaperItemDef.skins.Concat(WallpaperSettings.FlooringItemDef.skins).Concat(WallpaperSettings.CeilingItemDef.skins))
		{
			if (skinIdParsed != -1 && item.id == skinIdParsed)
			{
				flag = true;
				foundSkinName = item.invItem.displayName.english.Trim();
				break;
			}
			if (skinIdParsed == -1 && (item.invItem.displayName.english.Contains(@string, StringComparison.InvariantCultureIgnoreCase) || ((Object)item.invItem).name.Contains(@string, StringComparison.InvariantCultureIgnoreCase)))
			{
				flag = true;
				foundSkinName = item.invItem.displayName.english.Trim();
				skinIdParsed = item.id;
				break;
			}
		}
		if (skinIdParsed == 0)
		{
			flag = true;
		}
		if (!flag && skinIdParsed != -1)
		{
			arg.ReplyWith("Invalid skin");
			return;
		}
		RunInRadius(@float, basePlayer, delegate(BuildingBlock block)
		{
			bool flag2 = block.HasWallpaper();
			bool flag3 = flag2;
			if (addIfMissing && !flag2)
			{
				flag3 = WallpaperPlanner.Settings.CanUseWallpaper(block);
			}
			if (block.HasWallpaper() || flag3)
			{
				if (skinIdParsed == -1)
				{
					arg.ReplyWith("Applying random wallpaper");
					for (int i = 0; i < 2; i++)
					{
						ItemDefinition wallpaperItem = WallpaperPlanner.Settings.GetWallpaperItem(block, i);
						if ((Object)(object)wallpaperItem != (Object)null)
						{
							int id = wallpaperItem.skins.GetRandom().id;
							block.SetWallpaper((ulong)id, i);
						}
					}
				}
				else if (skinIdParsed == 0)
				{
					arg.ReplyWith("Applying default wallpaper");
					block.SetWallpaper(0uL);
					block.SetWallpaper(0uL, 1);
				}
				else
				{
					arg.ReplyWith("Applying '" + foundSkinName + "' wallpaper to compatible blocks");
					for (int j = 0; j < 2; j++)
					{
						ItemDefinition wallpaperItem2 = WallpaperPlanner.Settings.GetWallpaperItem(block, j);
						if ((Object)(object)wallpaperItem2 != (Object)null && wallpaperItem2.skins.Any((ItemSkinDirectory.Skin x) => x.id == skinIdParsed))
						{
							block.SetWallpaper((ulong)skinIdParsed, j);
						}
					}
				}
				block.CheckWallpaper();
			}
		});
	}

	[ServerVar(Help = "Lists all wallpaper skins")]
	public static void print_wallpaper_skins(Arg arg)
	{
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[3] { "Id", "Type", "Name" });
			ItemSkinDirectory.Skin[] skins = WallpaperSettings.WallpaperItemDef.skins;
			for (int i = 0; i < skins.Length; i++)
			{
				ItemSkinDirectory.Skin skin = skins[i];
				string[] array = new string[3];
				int id = skin.id;
				array[0] = id.ToString();
				array[1] = "Wall";
				array[2] = skin.invItem.displayName.english.Trim();
				val.AddRow(array);
			}
			skins = WallpaperSettings.FlooringItemDef.skins;
			for (int i = 0; i < skins.Length; i++)
			{
				ItemSkinDirectory.Skin skin2 = skins[i];
				string[] array2 = new string[3];
				int id = skin2.id;
				array2[0] = id.ToString();
				array2[1] = "Floor";
				array2[2] = skin2.invItem.displayName.english.Trim();
				val.AddRow(array2);
			}
			skins = WallpaperSettings.CeilingItemDef.skins;
			for (int i = 0; i < skins.Length; i++)
			{
				ItemSkinDirectory.Skin skin3 = skins[i];
				string[] array3 = new string[3];
				int id = skin3.id;
				array3[0] = id.ToString();
				array3[1] = "Ceiling";
				array3[2] = skin3.invItem.displayName.english.Trim();
				val.AddRow(array3);
			}
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "<gene string> - Applies the given genes (e.g. \"YYYGGG\") to the clone/seed in your hands")]
	public static void applygenes(Arg arg)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Expected O, but got Unknown
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be called from a player");
			return;
		}
		Item activeItem = basePlayer.GetActiveItem();
		ItemModDeployable itemModDeployable = default(ItemModDeployable);
		if (activeItem == null || !((Component)activeItem.info).TryGetComponent<ItemModDeployable>(ref itemModDeployable) || (Object)(object)itemModDeployable.entityPrefab.Get().GetComponent<GrowableEntity>() == (Object)null)
		{
			arg.ReplyWith("Not holding a growable item");
			return;
		}
		string text = arg.GetString(0, "YYYGGG").ToUpper();
		if (text.Length != 6 || text.Any((char x) => !"XGHWY".Contains(x)))
		{
			arg.ReplyWith("Invalid gene string");
			return;
		}
		if (activeItem.instanceData == null)
		{
			activeItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = GrowableGeneEncoding.EncodeGeneStringToInt(text)
			};
		}
		else
		{
			activeItem.instanceData.dataInt = GrowableGeneEncoding.EncodeGeneStringToInt(text);
		}
		activeItem.MarkDirty();
		arg.ReplyWith("Applied genes to the held item");
	}

	[ServerVar(Help = "Kills all bee swarms")]
	public static void killbees(Arg arg)
	{
		int num = 0;
		BeeSwarmMaster[] array = BaseEntity.Util.FindAll<BeeSwarmMaster>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].AdminKill();
			num++;
		}
		BeeSwarmAI[] array2 = BaseEntity.Util.FindAll<BeeSwarmAI>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].AdminKill();
			num++;
		}
		arg.ReplyWith($"Killed {num} bee swarms");
	}

	[ServerVar]
	public static void killplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
		}
	}

	[ServerVar]
	public static void killallplayers(Arg arg)
	{
		BasePlayer[] array = BaseEntity.Util.FindAll<BasePlayer>();
		int num = 0;
		BasePlayer[] array2 = array;
		foreach (BasePlayer basePlayer in array2)
		{
			if (!basePlayer.IsNpc)
			{
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
				num++;
			}
		}
		arg.ReplyWith($"Killed {num} players");
	}

	[ServerVar]
	public static void injureplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			Global.InjurePlayer(basePlayer);
		}
	}

	[ServerVar]
	public static void recoverplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			Global.RecoverPlayer(basePlayer);
		}
	}

	[ServerVar]
	public static void kick(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		string @string = arg.GetString(1, "no reason given");
		arg.ReplyWith("Kicked: " + player.displayName);
		Chat.Broadcast("Kicking " + player.displayName + " (" + @string + ")", "SERVER", "#eee", 0uL);
		player.Kick("Kicked: " + arg.GetString(1, "No Reason Given"), reserveSlot: false);
	}

	[ServerVar]
	public static void skick(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		string @string = arg.GetString(1, "no reason given");
		arg.ReplyWith("Kicked: " + player.displayName);
		Chat.ChatEntry ce = default(Chat.ChatEntry);
		ce.Channel = Chat.ChatChannel.Server;
		ce.Message = "(SILENT) Kicking " + player.displayName + " (" + @string + ")";
		ce.UserId = "0";
		ce.Username = "SERVER";
		ce.Color = "#eee";
		ce.Time = Epoch.Current;
		Chat.Record(ce);
		player.Kick("Kicked: " + arg.GetString(1, "No Reason Given"), reserveSlot: false);
	}

	[ServerVar]
	public static void kickall(Arg arg)
	{
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Kicked: " + arg.GetString(0, "No Reason Given"));
		}
	}

	[ServerVar(Help = "ban <player> <reason> [optional duration]")]
	public static void ban(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(player.userID);
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {player.userID.Get()} is already banned");
			return;
		}
		string @string = arg.GetString(1, "No Reason Given");
		if (TryGetBanExpiry(arg, 2, out var expiry, out var durationSuffix))
		{
			ServerUsers.Set(player.userID, ServerUsers.UserGroup.Banned, player.displayName, @string, expiry);
			string text = "";
			if (player.IsConnected && player.net.connection.ownerid != 0L && player.net.connection.ownerid != player.net.connection.userid)
			{
				text += $" and also banned ownerid {player.net.connection.ownerid}";
				ServerUsers.Set(player.net.connection.ownerid, ServerUsers.UserGroup.Banned, player.displayName, arg.GetString(1, $"Family share owner of {player.net.connection.userid}"), -1L);
			}
			ServerUsers.Save();
			arg.ReplyWith($"Kickbanned User{durationSuffix}: {player.userID.Get()} - {player.displayName}{text}");
			Chat.Broadcast("Kickbanning " + player.displayName + durationSuffix + " (" + @string + ")", "SERVER", "#eee", 0uL);
			Net.sv.Kick(player.net.connection, "Banned" + durationSuffix + ": " + @string, false);
		}
	}

	[ServerVar]
	public static void moderatorid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			arg.ReplyWith("User " + uInt + " is already a Moderator");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.Moderator, @string, string2, -1L);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: true);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Added moderator " + @string + ", steamid " + uInt);
	}

	[ServerVar]
	public static void ownerid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		if (arg.Connection != null && arg.Connection.authLevel < 2)
		{
			arg.ReplyWith("Moderators cannot run ownerid");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			arg.ReplyWith("User " + uInt + " is already an Owner");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.Owner, @string, string2, -1L);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: true);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Added owner " + @string + ", steamid " + uInt);
	}

	[ServerVar]
	public static void removemoderator(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Moderator)
		{
			arg.ReplyWith("User " + uInt + " isn't a moderator");
			return;
		}
		ServerUsers.Remove(uInt);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: false);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Removed Moderator: " + uInt);
	}

	[ServerVar]
	public static void removeowner(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Owner)
		{
			arg.ReplyWith("User " + uInt + " isn't an owner");
			return;
		}
		ServerUsers.Remove(uInt);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: false);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Removed Owner: " + uInt);
	}

	[ServerVar(Help = "banid <steamid> <username> <reason> [optional duration]")]
	public static void banid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string text = arg.GetString(1, "unnamed");
		string @string = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith("User " + uInt + " is already banned");
		}
		else
		{
			if (!TryGetBanExpiry(arg, 3, out var expiry, out var durationSuffix))
			{
				return;
			}
			string text2 = "";
			BasePlayer basePlayer = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
			{
				text = basePlayer.displayName;
				if (basePlayer.IsConnected && basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
				{
					text2 += $" and also banned ownerid {basePlayer.net.connection.ownerid}";
					ServerUsers.Set(basePlayer.net.connection.ownerid, ServerUsers.UserGroup.Banned, basePlayer.displayName, arg.GetString(1, $"Family share owner of {basePlayer.net.connection.userid}"), expiry);
				}
				Chat.Broadcast("Kickbanning " + basePlayer.displayName + durationSuffix + " (" + @string + ")", "SERVER", "#eee", 0uL);
				Net.sv.Kick(basePlayer.net.connection, "Banned" + durationSuffix + ": " + @string, false);
			}
			ServerUsers.Set(uInt, ServerUsers.UserGroup.Banned, text, @string, expiry);
			arg.ReplyWith($"Banned User{durationSuffix}: {uInt} - \"{text}\" for \"{@string}\"{text2}");
		}
	}

	private static bool TryGetBanExpiry(Arg arg, int n, out long expiry, out string durationSuffix)
	{
		expiry = arg.GetTimestamp(n, -1L);
		durationSuffix = null;
		int current = Epoch.Current;
		if (expiry > 0 && expiry <= current)
		{
			arg.ReplyWith("Expiry time is in the past");
			return false;
		}
		durationSuffix = ((expiry > 0) ? (" for " + NumberExtensions.FormatSecondsLong(expiry - current)) : "");
		return true;
	}

	[ServerVar]
	public static void unban(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith($"This doesn't appear to be a 64bit steamid: {uInt}");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {uInt} isn't banned");
			return;
		}
		ServerUsers.Remove(uInt);
		arg.ReplyWith("Unbanned User: " + uInt);
	}

	[ServerVar]
	public static void skipqueue(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
		}
		else
		{
			SingletonComponent<ServerMgr>.Instance.connectionQueue.SkipQueue(uInt);
		}
	}

	[ServerVar(Help = "Adds skip queue permissions to a SteamID")]
	public static void skipqueueid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && (user.group == ServerUsers.UserGroup.Owner || user.group == ServerUsers.UserGroup.Moderator || user.group == ServerUsers.UserGroup.SkipQueue))
		{
			arg.ReplyWith($"User {uInt} will already skip the queue ({user.group})");
			return;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {uInt} is banned");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.SkipQueue, @string, string2, -1L);
		arg.ReplyWith($"Added skip queue permission for {@string} ({uInt})");
	}

	[ServerVar(Help = "Removes skip queue permission from a SteamID")]
	public static void removeskipqueue(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && (user.group == ServerUsers.UserGroup.Owner || user.group == ServerUsers.UserGroup.Moderator))
		{
			arg.ReplyWith($"User is a {user.group}, cannot remove skip queue permission with this command");
			return;
		}
		if (user == null || user.group != ServerUsers.UserGroup.SkipQueue)
		{
			arg.ReplyWith("User does not have skip queue permission");
			return;
		}
		ServerUsers.Remove(uInt);
		arg.ReplyWith("Removed skip queue permission: " + uInt);
	}

	[ServerVar(Help = "Print out currently connected clients etc")]
	public static void players(Arg arg)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.ResizeColumns(5);
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("ping");
			val.AddColumn("updt");
			val.AddColumn("dist");
			val.AddColumn("enId");
			val.ResizeRows(BasePlayer.activePlayerList.Count);
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					string userIDString = current.UserIDString;
					val.AddValue(userIDString);
					string text = current.displayName;
					if (text.Length >= 14)
					{
						text = text.Substring(0, 14) + "..";
					}
					val.AddValue(text);
					int averagePing = Net.sv.GetAveragePing(current.net.connection);
					val.AddValue(averagePing);
					int queuedUpdateCount = current.GetQueuedUpdateCount(BasePlayer.NetworkQueue.Update);
					val.AddValue(queuedUpdateCount);
					int queuedUpdateCount2 = current.GetQueuedUpdateCount(BasePlayer.NetworkQueue.UpdateDistance);
					val.AddValue(queuedUpdateCount2);
					ulong value = current.net.ID.Value;
					val.AddValue(value);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			arg.ReplyWith(flag ? val.ToJson(false) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Sends a message in chat")]
	public static void say(Arg arg)
	{
		Chat.Broadcast(arg.FullString, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "Show user info for players on server.")]
	public static void users(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				text = text + current.userID.Get() + ":\"" + current.displayName + "\"\n";
				num++;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		text = text + num + "users\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server.")]
	public static void sleepingusers(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				text += $"{current.userID.Get()}:{current.displayName}\n";
				num++;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		text += $"{num} sleeping users\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for sleeping players on server in range of the player.")]
	public static void sleepingusersinrange(Arg arg)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer fromPlayer = arg.Player();
		if ((Object)(object)fromPlayer == (Object)null)
		{
			return;
		}
		if (fromPlayer.IsSpectating() && (Object)(object)fromPlayer.SpectatingTarget != (Object)null)
		{
			fromPlayer = fromPlayer.SpectatingTarget;
		}
		float range = arg.GetFloat(0, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)fromPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)fromPlayer) < basePlayer.Distance2D((BaseEntity)fromPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)fromPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} sleeping users within {range}m\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server in range of the player.")]
	public static void usersinrange(Arg arg)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer fromPlayer = arg.Player();
		if ((Object)(object)fromPlayer == (Object)null)
		{
			return;
		}
		if (fromPlayer.IsSpectating() && (Object)(object)fromPlayer.SpectatingTarget != (Object)null)
		{
			fromPlayer = fromPlayer.SpectatingTarget;
		}
		float range = arg.GetFloat(0, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)fromPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)fromPlayer) < basePlayer.Distance2D((BaseEntity)fromPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)fromPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} users within {range}m\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server in range of the supplied player (eg. Jim 50)")]
	public static void usersinrangeofplayer(Arg arg)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer targetPlayer = arg.GetPlayerOrSleeper(0);
		if ((Object)(object)targetPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(1, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)targetPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)targetPlayer) < basePlayer.Distance2D((BaseEntity)targetPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)targetPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} users within {range}m of {targetPlayer.displayName}\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "List of banned users (sourceds compat)")]
	public static void banlist(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListString());
	}

	[ServerVar(Help = "List of banned users - shows reasons and usernames")]
	public static void banlistex(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListStringEx());
	}

	[ServerVar(Help = "List of banned users, by ID (sourceds compat)")]
	public static void listid(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListString(bHeader: true));
	}

	[ServerVar]
	public static void mute(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		long timestamp = arg.GetTimestamp(1, 0L);
		if (timestamp > 0)
		{
			playerOrSleeper.State.chatMuteExpiryTimestamp = timestamp;
			string text = NumberExtensions.FormatSecondsLong(timestamp - DateTimeOffset.UtcNow.ToUnixTimeSeconds());
			playerOrSleeper.ChatMessage("You have been muted for " + text);
		}
		else
		{
			playerOrSleeper.ChatMessage("You have been permanently muted");
		}
		playerOrSleeper.State.chatMuted = true;
		playerOrSleeper.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, b: true);
	}

	[ServerVar]
	public static void unmute(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		playerOrSleeper.State.chatMuted = false;
		playerOrSleeper.State.chatMuteExpiryTimestamp = 0.0;
		playerOrSleeper.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, b: false);
		playerOrSleeper.ChatMessage("You have been unmuted");
	}

	[ServerVar(Help = "Print a list of currently muted players")]
	public static void mutelist(Arg arg)
	{
		var enumerable = from x in BasePlayer.allPlayerList
			where x.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute)
			select new
			{
				SteamId = x.UserIDString,
				Name = x.displayName
			};
		arg.ReplyWith((object)enumerable);
	}

	[ServerVar]
	public static void clientperf(Arg arg)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "legacy");
		int @int = arg.GetInt(1, Random.Range(int.MinValue, int.MaxValue));
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				current.ClientRPC(RpcTarget.Player("GetPerformanceReport", current), @string, @int);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Get information about all the cars in the world")]
	public static void carstats(Arg arg)
	{
		HashSet<ModularCar> allCarsList = ModularCar.allCarsList;
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("id");
			val.AddColumn("sockets");
			val.AddColumn("modules");
			val.AddColumn("complete");
			val.AddColumn("engine");
			val.AddColumn("health");
			val.AddColumn("location");
			int count = allCarsList.Count;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			foreach (ModularCar item in allCarsList)
			{
				string text = ((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString();
				string text2 = item.TotalSockets.ToString();
				string text3 = item.NumAttachedModules.ToString();
				string text4;
				if (item.IsComplete())
				{
					text4 = "Complete";
					num++;
				}
				else
				{
					text4 = "Partial";
				}
				string text5;
				if (item.HasAnyWorkingEngines())
				{
					text5 = "Working";
					num2++;
				}
				else
				{
					text5 = "Broken";
				}
				string text6 = ((item.TotalMaxHealth() != 0f) ? $"{item.TotalHealth() / item.TotalMaxHealth():0%}" : "0");
				string text7;
				if (item.IsOutside())
				{
					text7 = "Outside";
				}
				else
				{
					text7 = "Inside";
					num3++;
				}
				val.AddRow(new string[7] { text, text2, text3, text4, text5, text6, text7 });
			}
			string text8 = "";
			text8 = ((count != 1) ? (text8 + $"\nThe world contains {count} modular cars.") : (text8 + "\nThe world contains 1 modular car."));
			text8 = ((num != 1) ? (text8 + $"\n{num} ({(float)num / (float)count:0%}) are in a completed state.") : (text8 + $"\n1 ({1f / (float)count:0%}) is in a completed state."));
			text8 = ((num2 != 1) ? (text8 + $"\n{num2} ({(float)num2 / (float)count:0%}) are driveable.") : (text8 + $"\n1 ({1f / (float)count:0%}) is driveable."));
			arg.ReplyWith(string.Concat(str1: (num3 != 1) ? (text8 + $"\n{num3} ({(float)num3 / (float)count:0%}) are sheltered indoors.") : (text8 + $"\n1 ({1f / (float)count:0%}) is sheltered indoors."), str0: ((object)val).ToString()));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static string teaminfo(Arg arg)
	{
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			return "Player not found";
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(num);
		if (playerTeam == null)
		{
			return "Player is not in a team";
		}
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.ResizeColumns(4);
			val.AddColumn("steamID");
			val.AddColumn("username");
			val.AddColumn("online");
			val.AddColumn("leader");
			val.ResizeRows(playerTeam.members.Count);
			foreach (ulong memberId in playerTeam.members)
			{
				bool flag2 = ((IEnumerable<Connection>)Net.sv.connections).FirstOrDefault((Func<Connection, bool>)((Connection c) => c.connected && c.userid == memberId)) != null;
				val.AddValue(memberId);
				val.AddValue(GetPlayerName(memberId));
				val.AddValue(flag2 ? "x" : "");
				val.AddValue((memberId == playerTeam.teamLeader) ? "x" : "");
			}
			return flag ? val.ToJson(true) : $"ID: {playerTeam.teamID}\n\n{val}";
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void authradius(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'authradius {radius} [user]'");
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		list.Add(arg.GetPlayer(1) ?? arg.Player());
		SetAuthInRadius(list[0], list, @float, auth: true);
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void authradius_multi(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'authradius {radius} [user, user, ...]'");
		}
		else
		{
			SetAuthInRadius(arg.Player(), arg.GetPlayerArgs(1), @float, auth: true);
		}
	}

	[ServerVar]
	public static void authradius_radius(Arg arg)
	{
		run_authradius_radius(arg, authFlag: true);
	}

	[ServerVar]
	public static void deauthradius_radius(Arg arg)
	{
		run_authradius_radius(arg, authFlag: false);
	}

	private static void run_authradius_radius(Arg arg, bool authFlag)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, -1f);
		float float2 = arg.GetFloat(1, -1f);
		if (@float < 0f || float2 < 0f)
		{
			arg.ReplyWith("Format is 'authradius_radius {playerRadius, authRadius }'");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer2 = list[num];
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				list.RemoveAt(num);
			}
			else if (basePlayer2.isClient || Vector3.Distance(((Component)basePlayer2).transform.position, ((Component)basePlayer).transform.position) > @float)
			{
				list.Remove(basePlayer2);
			}
		}
		SetAuthInRadius(basePlayer, list, float2, authFlag);
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void deauthradius(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'deauthradius {radius} [user]'");
			return;
		}
		List<BasePlayer> list = new List<BasePlayer>();
		list.Add(arg.GetPlayer(1) ?? arg.Player());
		SetAuthInRadius(list[0], list, @float, auth: false);
	}

	[ServerVar]
	public static void deauthradius_multi(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'deauthradius {radius} [user, user, ...]'");
		}
		else
		{
			SetAuthInRadius(arg.Player(), arg.GetPlayerArgs(1), @float, auth: false);
		}
	}

	private static void SetAuthInRadius(BasePlayer radiusTargetPlayer, List<BasePlayer> players, float radius, bool auth)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (players == null)
		{
			return;
		}
		if (players.Count == 0)
		{
			players.Add(radiusTargetPlayer);
		}
		List<BaseEntity> list = new List<BaseEntity>();
		Vis.Entities(((Component)radiusTargetPlayer).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BaseEntity item in list)
		{
			if (!item.isServer)
			{
				continue;
			}
			bool flag = true;
			foreach (BasePlayer player in players)
			{
				bool flag2 = SetUserAuthorized(item, player.userID, auth);
				if (!flag2)
				{
					flag2 = SetUserAuthorized(item.GetSlot(BaseEntity.Slot.Lock), player.userID, auth);
				}
				if (flag)
				{
					num += (flag2 ? 1 : 0);
					flag = false;
				}
			}
		}
		Debug.Log((object)("Set auth: " + auth + " on " + players.Count + " players, for " + num + " entities."));
	}

	private static bool SetUserAuthorized(BaseEntity entity, ulong userId, bool state)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (entity is CodeLock codeLock)
		{
			if (state)
			{
				codeLock.whitelistPlayers.Add(userId);
			}
			else
			{
				codeLock.whitelistPlayers.Remove(userId);
				codeLock.guestPlayers.Remove(userId);
			}
			codeLock.SendNetworkUpdate();
		}
		else if (entity is AutoTurret autoTurret)
		{
			if (state)
			{
				autoTurret.authorizedPlayers.Add(userId);
			}
			else
			{
				autoTurret.authorizedPlayers.Remove(userId);
			}
			autoTurret.SendNetworkUpdate();
		}
		else if (entity is BuildingPrivlidge buildingPrivlidge)
		{
			if (state)
			{
				buildingPrivlidge.authorizedPlayers.Add(userId);
			}
			else
			{
				buildingPrivlidge.authorizedPlayers.Remove(userId);
			}
			if (entity.GetSlot(BaseEntity.Slot.Lock).IsValid())
			{
				SetUserAuthorized(entity.GetSlot(BaseEntity.Slot.Lock), userId, state);
			}
			buildingPrivlidge.SendNetworkUpdate();
		}
		else if (entity is Tugboat tugboat)
		{
			VehiclePrivilege componentInChildren = ((Component)tugboat).GetComponentInChildren<VehiclePrivilege>();
			if ((Object)(object)componentInChildren != (Object)null)
			{
				if (state)
				{
					componentInChildren.authorizedPlayers.Add(userId);
				}
				else
				{
					componentInChildren.authorizedPlayers.Remove(userId);
				}
				componentInChildren.SendNetworkUpdate();
			}
		}
		else if (entity is PlayerBoat playerBoat)
		{
			PlayerBoatPrivilege privilege = playerBoat.GetSteeringWheel().Privilege;
			if ((Object)(object)privilege != (Object)null)
			{
				if (state)
				{
					privilege.authorizedPlayers.Add(userId);
				}
				else
				{
					privilege.authorizedPlayers.Remove(userId);
				}
				privilege.SendNetworkUpdate();
			}
		}
		else
		{
			if (!(entity is ModularCar modularCar))
			{
				return false;
			}
			if (state)
			{
				modularCar.CarLock.TryAddPlayer(userId);
			}
			else
			{
				modularCar.CarLock.TryRemovePlayer(userId);
			}
			modularCar.SendNetworkUpdate();
		}
		return true;
	}

	[ServerVar]
	public static void entid(Arg arg)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0700: Unknown result type (might be due to invalid IL or missing references)
		//IL_0705: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0723: Unknown result type (might be due to invalid IL or missing references)
		//IL_0728: Unknown result type (might be due to invalid IL or missing references)
		//IL_072a: Unknown result type (might be due to invalid IL or missing references)
		//IL_072c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0758: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(arg.GetEntityID(1)) as BaseEntity;
		if ((Object)(object)baseEntity == (Object)null || baseEntity is BasePlayer || baseEntity is PointEntity)
		{
			return;
		}
		string @string = arg.GetString(0, "");
		if ((Object)(object)arg.Player() != (Object)null)
		{
			Debug.Log((object)("[ENTCMD] " + arg.Player().displayName + "/" + arg.Player().userID.Get() + " used *" + @string + "* on ent: " + ((Object)baseEntity).name));
		}
		switch (@string)
		{
		case "kill":
			baseEntity.AdminKill();
			break;
		case "lock":
			baseEntity.SetFlag(BaseEntity.Flags.Locked, b: true);
			break;
		case "unlock":
			baseEntity.SetFlag(BaseEntity.Flags.Locked, b: false);
			break;
		case "debug":
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, b: true);
			break;
		case "undebug":
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, b: false);
			break;
		case "who":
			arg.ReplyWith(baseEntity.Admin_Who());
			break;
		case "auth":
			arg.ReplyWith(AuthList(baseEntity));
			break;
		case "upgrade":
			arg.ReplyWith(ChangeGrade(baseEntity, arg.GetInt(2, 1), 0, BuildingGrade.Enum.None, 0uL, arg.GetFloat(3, 0f)));
			break;
		case "downgrade":
			arg.ReplyWith(ChangeGrade(baseEntity, 0, arg.GetInt(2, 1), BuildingGrade.Enum.None, 0uL, arg.GetFloat(3, 0f)));
			break;
		case "setgrade":
		{
			string error;
			BuildingGrade buildingGrade = FindBuildingSkin(arg.GetString(2, ""), out error);
			arg.ReplyWith(ChangeGrade(baseEntity, 0, 0, buildingGrade.type, buildingGrade.skin, arg.GetFloat(3, 0f)));
			break;
		}
		case "repair":
			RunInRadius(arg.GetFloat(2, 0f), baseEntity, delegate(BaseCombatEntity entity)
			{
				if (entity.repair.enabled)
				{
					entity.SetHealth(entity.MaxHealth());
				}
			});
			break;
		case "maxhp":
		{
			if (!(baseEntity is BaseCombatEntity baseCombatEntity))
			{
				arg.ReplyWith("Entity doesn't support max health!");
				break;
			}
			float @float = arg.GetFloat(2, 0f);
			baseCombatEntity.OverrideMaxHealth(@float);
			if (@float <= 0f)
			{
				arg.ReplyWith($"Removed max health override from {baseEntity}");
			}
			else
			{
				arg.ReplyWith($"Set max health to {@float}");
			}
			break;
		}
		case "dronetax":
		{
			List<MarketTerminal> list = new List<MarketTerminal>();
			if (baseEntity is Marketplace marketplace)
			{
				list.AddRange(from x in marketplace.terminalEntities
					select x.Get(serverside: true) into x
					where (Object)(object)x != (Object)null
					select x);
			}
			else
			{
				if (!(baseEntity is MarketTerminal item))
				{
					arg.ReplyWith("Entity is not a market terminal!");
					break;
				}
				list.Add(item);
			}
			{
				foreach (MarketTerminal item2 in list)
				{
					string string2 = arg.GetString(2, "");
					if (int.TryParse(string2, out var result) && result > 0)
					{
						item2.deliveryFeeAmount = result;
						item2.SendNetworkUpdate();
						arg.ReplyWith($"Set drone tax to '{result}'");
						continue;
					}
					ItemDefinition itemDefinition = ItemManager.FindDefinitionByPartialName(string2);
					if ((Object)(object)itemDefinition != (Object)null)
					{
						item2.deliveryFeeCurrency = itemDefinition;
						item2.SendNetworkUpdate();
						arg.ReplyWith("Set drone tax item to '" + itemDefinition.shortname + "'");
					}
					else
					{
						arg.ReplyWith("'" + string2 + "' is not a tax amount or valid item!");
					}
				}
				break;
			}
		}
		case "image":
		{
			if (!(baseEntity is ISignage signage))
			{
				arg.ReplyWith("Entity is not a sign");
				break;
			}
			uint[] textureCRCs = signage.GetTextureCRCs();
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"{textureCRCs.Length} Image CRCs");
			uint[] array = textureCRCs;
			foreach (uint num in array)
			{
				stringBuilder.AppendLine(num.ToString());
			}
			arg.ReplyWith(stringBuilder.ToString());
			break;
		}
		case "scale":
		{
			string string3 = arg.GetString(2, "");
			if (string.IsNullOrEmpty(string3))
			{
				arg.ReplyWith($"Scale: {((Component)baseEntity).transform.localScale}");
				break;
			}
			if (string3 == "default")
			{
				baseEntity.networkEntityScale = false;
				((Component)baseEntity).transform.localScale = Vector3.one;
				baseEntity.SendNetworkUpdate();
				arg.ReplyWith("Reset scale");
				break;
			}
			Vector3 val = Vector3.one;
			if (float.TryParse(string3, out var result2))
			{
				((Vector3)(ref val))..ctor(result2, result2, result2);
			}
			else
			{
				val = Vector3Ex.Parse(string3);
				if (val == Vector3.zero)
				{
					arg.ReplyWith(string3 + " is not a valid scale");
					break;
				}
			}
			baseEntity.networkEntityScale = true;
			((Component)baseEntity).transform.localScale = val;
			baseEntity.SendNetworkUpdate();
			arg.ReplyWith($"Set scale to {((Component)baseEntity).transform.localScale}");
			break;
		}
		case "settime":
		{
			int @int = arg.GetInt(2, -1);
			if (@int == -1)
			{
				arg.ReplyWith("Time not provided");
			}
			else if (baseEntity is WipeLaptopEntity wipeLaptopEntity)
			{
				wipeLaptopEntity.SetTimeLeft(@int);
				arg.ReplyWith($"Set time left to {@int}");
			}
			else
			{
				arg.ReplyWith("Not looking at a laptop");
			}
			break;
		}
		default:
			arg.ReplyWith("Unknown command");
			break;
		}
	}

	private static string AuthList(BaseEntity ent)
	{
		List<ulong> list;
		if (!(ent is BuildingPrivlidge buildingPrivlidge))
		{
			if (!(ent is AutoTurret autoTurret))
			{
				if (ent is CodeLock codeLock)
				{
					return CodeLockAuthList(codeLock);
				}
				if (!(ent is KeyLock keyLock))
				{
					if (!(ent is LegacyShelter legacyShelter))
					{
						if (ent is BaseVehicleModule vehicleModule)
						{
							return CodeLockAuthList(vehicleModule);
						}
						if (!(ent is Tugboat tugboat))
						{
							if (!(ent is SteeringWheel steeringWheel))
							{
								return "Entity has no auth list";
							}
							list = new List<ulong>();
							PlayerBoatPrivilege componentInChildren = ((Component)steeringWheel).GetComponentInChildren<PlayerBoatPrivilege>();
							if ((Object)(object)componentInChildren != (Object)null)
							{
								foreach (ulong authorizedPlayer in componentInChildren.authorizedPlayers)
								{
									list.Add(authorizedPlayer);
								}
							}
						}
						else
						{
							list = new List<ulong>();
							VehiclePrivilege componentInChildren2 = ((Component)tugboat).GetComponentInChildren<VehiclePrivilege>();
							if ((Object)(object)componentInChildren2 != (Object)null)
							{
								foreach (ulong authorizedPlayer2 in componentInChildren2.authorizedPlayers)
								{
									list.Add(authorizedPlayer2);
								}
							}
						}
					}
					else
					{
						list = new List<ulong> { legacyShelter.OwnerID };
					}
				}
				else
				{
					list = new List<ulong> { keyLock.OwnerID };
				}
			}
			else
			{
				list = new List<ulong>();
				foreach (ulong authorizedPlayer3 in autoTurret.authorizedPlayers)
				{
					list.Add(authorizedPlayer3);
				}
			}
		}
		else
		{
			list = new List<ulong>();
			foreach (ulong authorizedPlayer4 in buildingPrivlidge.authorizedPlayers)
			{
				list.Add(authorizedPlayer4);
			}
		}
		if (list == null || list.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("steamID");
			val.AddColumn("username");
			foreach (ulong item in list)
			{
				val.AddRow(new string[2]
				{
					item.ToString(),
					GetPlayerName(item)
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static string CodeLockAuthList(CodeLock codeLock)
	{
		if (codeLock.whitelistPlayers.Count == 0 && codeLock.guestPlayers.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("steamID");
			val.AddColumn("username");
			val.AddColumn("isGuest");
			foreach (ulong whitelistPlayer in codeLock.whitelistPlayers)
			{
				val.AddRow(new string[3]
				{
					whitelistPlayer.ToString(),
					GetPlayerName(whitelistPlayer),
					""
				});
			}
			foreach (ulong guestPlayer in codeLock.guestPlayers)
			{
				val.AddRow(new string[3]
				{
					guestPlayer.ToString(),
					GetPlayerName(guestPlayer),
					"x"
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static string CodeLockAuthList(BaseVehicleModule vehicleModule)
	{
		if (!vehicleModule.IsOnAVehicle)
		{
			return "Nobody is authed to this entity";
		}
		ModularCar modularCar = vehicleModule.Vehicle as ModularCar;
		if ((Object)(object)modularCar == (Object)null || !modularCar.IsLockable || modularCar.CarLock.WhitelistPlayers.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("steamID");
			val.AddColumn("username");
			foreach (ulong whitelistPlayer in modularCar.CarLock.WhitelistPlayers)
			{
				val.AddRow(new string[2]
				{
					whitelistPlayer.ToString(),
					GetPlayerName(whitelistPlayer)
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static string GetPlayerName(ulong steamId)
	{
		BasePlayer basePlayer = BasePlayer.allPlayerList.FirstOrDefault((BasePlayer p) => (ulong)p.userID == steamId);
		string text;
		if (!((Object)(object)basePlayer != (Object)null))
		{
			text = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(steamId);
			if (text == null)
			{
				return "[unknown]";
			}
		}
		else
		{
			text = basePlayer.displayName;
		}
		return text;
	}

	public static string ChangeGrade(BaseEntity entity, int increaseBy = 0, int decreaseBy = 0, BuildingGrade.Enum targetGrade = BuildingGrade.Enum.None, ulong skin = 0uL, float radius = 0f)
	{
		if ((Object)(object)(entity as BuildingBlock) == (Object)null)
		{
			return $"'{entity}' is not a building block";
		}
		RunInRadius(radius, entity, delegate(BuildingBlock block)
		{
			BuildingGrade.Enum grade = block.grade;
			if (targetGrade > BuildingGrade.Enum.None && targetGrade < BuildingGrade.Enum.Count)
			{
				grade = targetGrade;
			}
			else
			{
				grade = (BuildingGrade.Enum)Mathf.Min((int)(grade + increaseBy), 4);
				grade = (BuildingGrade.Enum)Mathf.Max((int)(grade - decreaseBy), 0);
			}
			if (grade != block.grade)
			{
				block.ChangeGradeAndSkin(targetGrade, skin);
			}
		});
		int count = Pool.Get<List<BuildingBlock>>().Count;
		return $"Upgraded/downgraded '{count}' building block(s)";
	}

	private static bool RunInRadius<T>(float radius, BaseEntity initial, Action<T> callback, Func<T, bool> filter = null, int layerMask = 2097152) where T : BaseEntity
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		List<T> list = Pool.Get<List<T>>();
		radius = Mathf.Clamp(radius, 0f, 200f);
		if (radius > 0f)
		{
			Vis.Entities(((Component)initial).transform.position, radius, list, layerMask, (QueryTriggerInteraction)2);
		}
		else if (initial is T item)
		{
			list.Add(item);
		}
		foreach (T item2 in list)
		{
			try
			{
				callback(item2);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Exception while running callback in radius: {arg}");
				Pool.FreeUnmanaged<T>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<T>(ref list);
		return true;
	}

	[ServerVar(Help = "Get a list of players")]
	public static PlayerInfo[] playerlist()
	{
		return ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Select(delegate(BasePlayer x)
		{
			PlayerInfo result = default(PlayerInfo);
			result.SteamID = x.UserIDString;
			result.OwnerSteamID = x.OwnerID.ToString();
			result.DisplayName = x.displayName;
			result.Ping = Net.sv.GetAveragePing(x.net.connection);
			result.Address = x.net.connection.ipaddress;
			result.EntityId = x.net.ID.Value;
			result.ConnectedSeconds = (int)x.net.connection.GetSecondsConnected();
			result.ViolationLevel = x.violationLevel;
			result.Health = x.Health();
			return result;
		}).ToArray();
	}

	[ServerVar(Help = "Get a list of player's IDs")]
	public static PlayerIDInfo[] playerlistids()
	{
		return ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Select(delegate(BasePlayer x)
		{
			PlayerIDInfo result = default(PlayerIDInfo);
			result.SteamID = x.UserIDString;
			result.OwnerSteamID = x.OwnerID.ToString();
			result.DisplayName = x.displayName;
			result.Address = x.net.connection.ipaddress;
			result.EntityId = x.net.ID.Value;
			return result;
		}).ToArray();
	}

	[ServerVar(Help = "List of banned users")]
	public static ServerUsers.User[] Bans()
	{
		return ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToArray();
	}

	[ServerVar(Help = "Get a list of information about the server")]
	public static ServerInfoOutput ServerInfo()
	{
		ServerInfoOutput result = default(ServerInfoOutput);
		result.Hostname = ConVar.Server.hostname;
		result.MaxPlayers = ConVar.Server.maxplayers;
		result.Players = BasePlayer.activePlayerList.Count;
		result.Queued = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		result.Joining = SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining;
		result.ReservedSlots = SingletonComponent<ServerMgr>.Instance.connectionQueue.ReservedCount;
		result.EntityCount = BaseNetworkable.serverEntities.Count;
		result.GameTime = (((Object)(object)TOD_Sky.Instance != (Object)null) ? TOD_Sky.Instance.Cycle.DateTime.ToString() : DateTime.UtcNow.ToString());
		result.Uptime = (int)Time.realtimeSinceStartup;
		result.Map = ConVar.Server.level;
		result.Framerate = Performance.report.frameRate;
		result.Memory = (int)Performance.report.memoryAllocations;
		result.MemoryUsageSystem = (int)Performance.report.memoryUsageSystem;
		result.Collections = (int)Performance.report.memoryCollections;
		result.NetworkIn = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)3) : 0);
		result.NetworkOut = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)1) : 0);
		result.Restarting = SingletonComponent<ServerMgr>.Instance.Restarting;
		result.SaveCreatedTime = SaveRestore.SaveCreatedTime.ToString();
		result.Version = 2621;
		result.Protocol = Protocol.printable;
		return result;
	}

	[ServerVar(Help = "Get information about this build")]
	public static BuildInfo BuildInfo()
	{
		return BuildInfo.Current;
	}

	[ServerVar]
	public static void AdminUI_FullRefresh(Arg arg)
	{
		AdminUI_RequestPlayerList(arg);
		AdminUI_RequestServerInfo(arg);
		AdminUI_RequestServerConvars(arg);
		AdminUI_RequestUGCList(arg);
	}

	[ServerVar]
	public static void AdminUI_RequestPlayerList(Arg arg)
	{
		if (allowAdminUI)
		{
			ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceivePlayerList", JsonConvert.SerializeObject((object)playerlist()));
		}
	}

	[ServerVar]
	public static void AdminUI_RequestServerInfo(Arg arg)
	{
		if (allowAdminUI)
		{
			ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveServerInfo", JsonConvert.SerializeObject((object)ServerInfo()));
		}
	}

	[ServerVar]
	public static void AdminUI_RequestServerConvars(Arg arg)
	{
		if (!allowAdminUI)
		{
			return;
		}
		List<ServerConvarInfo> list = Pool.Get<List<ServerConvarInfo>>();
		Command[] all = Index.All;
		foreach (Command val in all)
		{
			if (val.Server && val.Variable && val.ServerAdmin && val.ShowInAdminUI && !val.RconOnly)
			{
				list.Add(new ServerConvarInfo
				{
					FullName = val.FullName,
					Value = val.GetOveride?.Invoke(),
					Help = val.Description
				});
			}
		}
		ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveCommands", JsonConvert.SerializeObject((object)list));
		Pool.FreeUnmanaged<ServerConvarInfo>(ref list);
	}

	[ServerVar]
	public static void AdminUI_RequestUGCList(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!allowAdminUI)
		{
			return;
		}
		List<ServerUGCInfo> list = Pool.Get<List<ServerUGCInfo>>();
		uint[] array = null;
		ulong[] array2 = null;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current.IsUnityNull())
				{
					continue;
				}
				array = null;
				array2 = null;
				UGCType uGCType = UGCType.ImageJpg;
				string text = string.Empty;
				if (((Component)current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
				{
					if ((Object)(object)iUGCBrowserEntity.UgcEntity == (Object)null)
					{
						continue;
					}
					array = iUGCBrowserEntity.GetContentCRCs;
					array2 = iUGCBrowserEntity.EditingHistory.ToArray();
					uGCType = iUGCBrowserEntity.ContentType;
					text = iUGCBrowserEntity.ContentString;
				}
				bool flag = false;
				if (array != null)
				{
					uint[] array3 = array;
					for (int i = 0; i < array3.Length; i++)
					{
						if (array3[i] != 0)
						{
							flag = true;
							break;
						}
					}
				}
				if (uGCType == UGCType.PatternBoomer)
				{
					flag = true;
					PatternFirework patternFirework = iUGCBrowserEntity as PatternFirework;
					if ((Object)(object)patternFirework != (Object)null && patternFirework.Design == null)
					{
						flag = false;
					}
				}
				if (uGCType == UGCType.VendingMachine && !string.IsNullOrEmpty(text))
				{
					flag = true;
				}
				if (flag)
				{
					list.Add(new ServerUGCInfo
					{
						entityId = current.net.ID.Value,
						crcs = array,
						contentType = uGCType,
						entityPrefabID = current.prefabID,
						shortPrefabName = current.ShortPrefabName,
						playerIds = array2,
						contentString = text
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveUGCList", JsonConvert.SerializeObject((object)list));
		Pool.FreeUnmanaged<ServerUGCInfo>(ref list);
	}

	[ServerVar]
	public static void AdminUI_RequestUGCContent(Arg arg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (allowAdminUI && !((Object)(object)arg.Player() == (Object)null))
		{
			uint uInt = arg.GetUInt(0, 0u);
			NetworkableId entityID = arg.GetEntityID(1);
			FileStorage.Type @int = (FileStorage.Type)arg.GetInt(2, 0);
			uint uInt2 = arg.GetUInt(3, 0u);
			byte[] array = FileStorage.server.Get(uInt, @int, entityID, uInt2);
			if (array != null)
			{
				SendInfo val = default(SendInfo);
				((SendInfo)(ref val))..ctor(arg.Connection);
				val.channel = 2;
				val.method = (SendMethod)0;
				SendInfo sendInfo = val;
				arg.Player().ClientRPC(RpcTarget.SendInfo("AdminReceivedUGC", sendInfo), uInt, (uint)array.Length, array, uInt2, (byte)@int);
			}
		}
	}

	[ServerVar]
	public static void AdminUI_DeleteUGCContent(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!allowAdminUI)
		{
			return;
		}
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			FileStorage.server.RemoveAllByEntity(entityID);
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			if (((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
			{
				iUGCBrowserEntity.ClearContent();
			}
		}
	}

	[ServerVar]
	public static void AdminUI_RequestFireworkPattern(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (allowAdminUI)
		{
			NetworkableId entityID = arg.GetEntityID(0);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
			if ((Object)(object)baseNetworkable != (Object)null && baseNetworkable is PatternFirework { Design: not null } patternFirework)
			{
				SendInfo val = default(SendInfo);
				((SendInfo)(ref val))..ctor(arg.Connection);
				val.channel = 2;
				val.method = (SendMethod)0;
				SendInfo sendInfo = val;
				arg.Player().ClientRPC(RpcTarget.SendInfo("AdminReceivedPatternFirework", sendInfo), entityID, ProtoStreamExtensions.ToProtoBytes((IProto)(object)patternFirework.Design));
			}
		}
	}

	[ServerVar]
	public static void clearugcentity(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
		if ((Object)(object)baseNetworkable != (Object)null && ((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
		{
			iUGCBrowserEntity.ClearContent();
			arg.ReplyWith($"Cleared content on {baseNetworkable.ShortPrefabName}/{entityID}");
		}
		else
		{
			arg.ReplyWith($"Could not find UGC entity with id {entityID}");
		}
	}

	[ServerVar]
	public static void clearugcentitiesinrange(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		float @float = arg.GetFloat(1, 0f);
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (((Component)current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && Vector3.Distance(((Component)current).transform.position, vector) <= @float)
				{
					iUGCBrowserEntity.ClearContent();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num} UGC entities within {@float}m of {vector}");
	}

	[ServerVar]
	public static void clearVendingMachineNamesContaining(Arg arg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				if (((Component)enumerator.Current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && iUGCBrowserEntity.ContentType == UGCType.VendingMachine && StringEx.Contains(iUGCBrowserEntity.ContentString, @string, CompareOptions.IgnoreCase | CompareOptions.IgnoreSymbols))
				{
					iUGCBrowserEntity.ClearContent();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num} vending machines containing {@string}");
	}

	[ServerVar]
	public static void clearUGCByPlayer(Arg arg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong num = (((Object)(object)playerOrSleeper == (Object)null) ? arg.GetULong(0, 0uL) : playerOrSleeper.userID.Get());
		int num2 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				if (((Component)enumerator.Current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && iUGCBrowserEntity.EditingHistory.Contains(num))
				{
					iUGCBrowserEntity.ClearContent();
					num2++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num2} UGC entities modified by {(((Object)(object)playerOrSleeper != (Object)null) ? playerOrSleeper.displayName : ((object)num))}");
	}

	[ServerVar]
	public static void getugcinfo(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
		if ((Object)(object)baseNetworkable != (Object)null && ((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && (Object)(object)iUGCBrowserEntity.UgcEntity != (Object)null)
		{
			ServerUGCInfo serverUGCInfo = new ServerUGCInfo(iUGCBrowserEntity);
			arg.ReplyWith(JsonConvert.SerializeObject((object)serverUGCInfo));
		}
		else
		{
			arg.ReplyWith($"Invalid entity id: {entityID}");
		}
	}

	[ServerVar(Help = "Returns all entities that the provided player is authed to (TC's, locks, etc), supports --json")]
	public static void authcount(Arg arg)
	{
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			arg.ReplyWith("Please provide a valid player, unable to find '" + arg.GetString(0, "") + "'");
			return;
		}
		string playerName = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(num);
		string text = arg.GetString(1, "");
		if (text == "--json")
		{
			text = string.Empty;
		}
		List<EntityAssociation> list = Pool.Get<List<EntityAssociation>>();
		FindEntityAssociationsForPlayer(num, useOwnerId: false, useAuth: true, text, list);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[4] { "Prefab name", "Position", "ID", "Type" });
			foreach (EntityAssociation item in list)
			{
				string[] obj = new string[4]
				{
					item.TargetEntity.ShortPrefabName,
					null,
					null,
					null
				};
				Vector3 position = ((Component)item.TargetEntity).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = ((object)(NetworkableId)(ref item.TargetEntity.net.ID)/*cast due to .constrained prefix*/).ToString();
				obj[3] = item.AssociationType.ToString();
				val.AddRow(obj);
			}
			Pool.FreeUnmanaged<EntityAssociation>(ref list);
			if (flag)
			{
				arg.ReplyWith(val.ToJson(true));
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Found entities " + playerName + " is authed to");
			stringBuilder.AppendLine(((object)val).ToString());
			arg.ReplyWith(stringBuilder.ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Returns all entities that the provided player has placed, supports --json")]
	public static void entcount(Arg arg)
	{
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			arg.ReplyWith("Please provide a valid player, unable to find '" + arg.GetString(0, "") + "'");
			return;
		}
		string playerName = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(num);
		string text = arg.GetString(1, "");
		if (text == "--json")
		{
			text = string.Empty;
		}
		List<EntityAssociation> list = Pool.Get<List<EntityAssociation>>();
		FindEntityAssociationsForPlayer(num, useOwnerId: true, useAuth: false, text, list);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[3] { "Prefab name", "Position", "ID" });
			foreach (EntityAssociation item in list)
			{
				string[] obj = new string[3]
				{
					item.TargetEntity.ShortPrefabName,
					null,
					null
				};
				Vector3 position = ((Component)item.TargetEntity).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = ((object)(NetworkableId)(ref item.TargetEntity.net.ID)/*cast due to .constrained prefix*/).ToString();
				val.AddRow(obj);
			}
			Pool.FreeUnmanaged<EntityAssociation>(ref list);
			if (flag)
			{
				arg.ReplyWith(val.ToJson(true));
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Found entities associated with " + playerName);
			stringBuilder.AppendLine(((object)val).ToString());
			arg.ReplyWith(stringBuilder.ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void FindEntityAssociationsForPlayer(ulong steamId, bool useOwnerId, bool useAuth, string filter, List<EntityAssociation> results)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		results.Clear();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				EntityAssociationType entityAssociationType = EntityAssociationType.Owner;
				if (!(current is BaseEntity baseEntity))
				{
					continue;
				}
				bool flag = false;
				if (useOwnerId && baseEntity.OwnerID == steamId)
				{
					flag = true;
				}
				if (useAuth && !flag)
				{
					if (!flag && baseEntity is BuildingPrivlidge buildingPrivlidge && buildingPrivlidge.IsAuthed(steamId))
					{
						flag = true;
					}
					if (!flag && baseEntity is SimplePrivilege simplePrivilege && simplePrivilege.IsAuthed(steamId))
					{
						flag = true;
					}
					if (!flag && baseEntity is KeyLock keyLock && keyLock.OwnerID == steamId)
					{
						flag = true;
					}
					else if (baseEntity is CodeLock codeLock)
					{
						if (codeLock.whitelistPlayers.Contains(steamId))
						{
							flag = true;
						}
						else if (codeLock.guestPlayers.Contains(steamId))
						{
							flag = true;
							entityAssociationType = EntityAssociationType.LockGuest;
						}
					}
					if (!flag && baseEntity is ModularCar { IsLockable: not false } modularCar && modularCar.CarLock.HasLockPermission(steamId))
					{
						flag = true;
					}
					if (!flag && baseEntity is AutoTurret autoTurret && autoTurret.IsAuthed(steamId))
					{
						flag = true;
					}
					if (flag && entityAssociationType == EntityAssociationType.Owner)
					{
						entityAssociationType = EntityAssociationType.Auth;
					}
				}
				if (flag && !string.IsNullOrEmpty(filter) && !StringEx.Contains(current.ShortPrefabName, filter, CompareOptions.IgnoreCase))
				{
					flag = false;
				}
				if (flag)
				{
					results.Add(new EntityAssociation
					{
						TargetEntity = baseEntity,
						AssociationType = entityAssociationType
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


private enum ChangeGradeMode
{
	Upgrade,
	Downgrade
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct PlayerInfo
{
	public string SteamID;

	public string OwnerSteamID;

	public string DisplayName;

	public int Ping;

	public string Address;

	public ulong EntityId;

	public int ConnectedSeconds;

	public float ViolationLevel;

	public float CurrentLevel;

	public float UnspentXp;

	public float Health;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct PlayerIDInfo
{
	public string SteamID;

	public string OwnerSteamID;

	public string DisplayName;

	public string Address;

	public ulong EntityId;
}


using UnityEngine.Scripting;

[JsonModel]
[Preserve]
public struct ServerInfoOutput
{
	public string Hostname;

	public int MaxPlayers;

	public int Players;

	public int Queued;

	public int Joining;

	public int ReservedSlots;

	public int EntityCount;

	public string GameTime;

	public int Uptime;

	public string Map;

	public float Framerate;

	public int Memory;

	public int MemoryUsageSystem;

	public int Collections;

	public int NetworkIn;

	public int NetworkOut;

	public bool Restarting;

	public string SaveCreatedTime;

	public int Version;

	public string Protocol;
}


using UnityEngine.Scripting;

[JsonModel]
[Preserve]
public struct ServerConvarInfo
{
	public string FullName;

	public string Value;

	public string Help;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct ServerUGCInfo
{
	public ulong entityId;

	public uint[] crcs;

	public UGCType contentType;

	public uint entityPrefabID;

	public string shortPrefabName;

	public ulong[] playerIds;

	public string contentString;

	public ServerUGCInfo(IUGCBrowserEntity fromEntity)
	{
		entityId = fromEntity.UgcEntity.net.ID.Value;
		crcs = fromEntity.GetContentCRCs;
		contentType = fromEntity.ContentType;
		entityPrefabID = fromEntity.UgcEntity.prefabID;
		shortPrefabName = fromEntity.UgcEntity.ShortPrefabName;
		playerIds = fromEntity.EditingHistory.ToArray();
		contentString = fromEntity.ContentString;
	}
}


private struct EntityAssociation
{
	public BaseEntity TargetEntity;

	public EntityAssociationType AssociationType;
}


private enum EntityAssociationType
{
	Owner,
	Auth,
	LockGuest
}


[Factory("antihack")]
public class AntiHack : ConsoleSystem
{
	[Help("collider margin when checking for noclipping on dismount")]
	[ReplicatedVar(Default = "0.22")]
	public static float noclip_margin_dismount = 0.22f;

	[ReplicatedVar(Default = "0.01")]
	[Help("collider backtracking when checking for noclipping")]
	public static float noclip_backtracking = 0.01f;

	[ServerVar]
	[Help("report violations to the anti cheat backend")]
	public static bool reporting = false;

	[ServerVar]
	[Help("are admins allowed to use their admin cheat")]
	public static bool admincheat = true;

	[ServerVar]
	[Help("use antihack to verify object placement by players")]
	public static bool objectplacement = true;

	[ServerVar]
	[Help("use antihack to verify model state sent by players")]
	public static bool modelstate = true;

	[ServerVar]
	[Help("whether or not to force the position on the client")]
	public static bool forceposition = true;

	[Help("0 == allow RPCs from stalled players, 1 == ignore RPCs from currently stalled players, 2 == ignore RPCs from recently stalled players")]
	[ServerVar]
	public static int rpcstallmode = 1;

	[Help("time in seconds before player is no longer treated as wasStalled")]
	[ServerVar]
	public static float rpcstallfade = 2.5f;

	[ServerVar]
	[Help("time in seconds we can receive no ticks for before player is considered stalling")]
	public static float rpcstallthreshold = 0.8f;

	[ServerVar]
	[Help("0 == users, 1 == admins, 2 == developers")]
	public static int userlevel = 2;

	[ServerVar]
	[Help("0 == no enforcement, 1 == kick, 2 == ban (DISABLED)")]
	public static int enforcementlevel = 1;

	[Help("max allowed client desync, lower value = more false positives")]
	[ServerVar]
	public static float maxdesync = 0.8f;

	[Help("max allowed client tick interval delta time, lower value = more false positives")]
	[ServerVar]
	public static float maxdeltatime = 1f;

	[Help("for how many seconds to keep a tick history to use for distance checks")]
	[ServerVar]
	public static float tickhistorytime = 0.5f;

	[ServerVar]
	[Help("how much forgiveness to add when checking the distance from the player tick history")]
	public static float tickhistoryforgiveness = 0.1f;

	[ServerVar]
	[Help("the rate at which violation values go back down")]
	public static float relaxationrate = 0.1f;

	[ServerVar]
	[Help("the time before violation values go back down")]
	public static float relaxationpause = 10f;

	[Help("violation value above this results in enforcement")]
	[ServerVar]
	public static float maxviolation = 100f;

	[Help("0 == disabled, 1 == enabled")]
	[ServerVar]
	public static int terrain_protection = 1;

	[ServerVar]
	[Help("how many slices to subdivide players into for the terrain check")]
	public static int terrain_timeslice = 64;

	[ServerVar]
	[Help("how far to penetrate the terrain before violating")]
	public static float terrain_padding = 0.3f;

	[ServerVar]
	[Help("violation penalty to hand out when terrain is detected")]
	public static float terrain_penalty = 100f;

	[ServerVar]
	[Help("whether or not to kill the player when terrain is detected")]
	public static bool terrain_kill = true;

	[ServerVar]
	[Help("whether or not to check for player inside geometry like rocks as well as base terrain")]
	public static bool terrain_check_geometry = false;

	[ServerVar]
	[Help("0 == disabled, 1 == ray, 2 == sphere, 3 == curve")]
	public static int noclip_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when noclip is detected")]
	public static bool noclip_reject = true;

	[ServerVar]
	[Help("violation penalty to hand out when noclip is detected")]
	public static float noclip_penalty = 0f;

	[ServerVar]
	[Help("collider margin when checking for noclipping")]
	public static float noclip_margin = 0.09f;

	[ServerVar]
	[Help("movement curve step size, lower value = less false positives")]
	public static float noclip_stepsize = 0.1f;

	[ServerVar]
	[Help("movement curve max steps, lower value = more false positives")]
	public static int noclip_maxsteps = 15;

	[Help("0 == disabled, 1 == simple, 2 == advanced, 3 == vertical swim protection")]
	[ServerVar]
	public static int speedhack_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when speedhack is detected")]
	public static bool speedhack_reject = true;

	[ServerVar]
	[Help("violation penalty to hand out when speedhack is detected")]
	public static float speedhack_penalty = 0f;

	[ServerVar]
	[Help("speed threshold to assume speedhacking, lower value = more false positives")]
	public static float speedhack_forgiveness = 2f;

	[ServerVar]
	[Help("speed threshold to assume speedhacking, lower value = more false positives")]
	public static float speedhack_forgiveness_inertia = 10f;

	[ServerVar]
	[Help("speed forgiveness when moving down slopes, lower value = more false positives")]
	public static float speedhack_slopespeed = 10f;

	[ServerVar]
	[Help("0 == disabled, 1 == client, 2 == capsule, 3 == curve")]
	public static int flyhack_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when flyhack is detected")]
	public static bool flyhack_reject = true;

	[ServerVar]
	[Help("violation penalty to hand out when flyhack is detected")]
	public static float flyhack_penalty = 100f;

	[ServerVar]
	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	public static float flyhack_forgiveness_vertical = 1f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_vertical_inertia = 7f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_horizontal = 1.5f;

	[ServerVar]
	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	public static float flyhack_forgiveness_horizontal_inertia = 10f;

	[ServerVar]
	[Help("collider downwards extrusion when checking for flyhacking")]
	public static float flyhack_extrusion = 2f;

	[ServerVar]
	[Help("collider margin when checking for flyhacking")]
	public static float flyhack_margin = 0.1f;

	[ServerVar]
	[Help("movement curve step size, lower value = less false positives")]
	public static float flyhack_stepsize = 0.1f;

	[Help("movement curve max steps, lower value = more false positives")]
	[ServerVar]
	public static int flyhack_maxsteps = 15;

	[ServerVar]
	[Help("Optimizes checks by using cached water info. Originally off")]
	public static bool flyhack_usecachedstate = true;

	[ServerVar]
	[Help("serverside fall damage, requires flyhack_protection >= 2 for proper functionality")]
	public static bool serverside_fall_damage = false;

	[ServerVar]
	[Help("0 == disabled, 1 == speed, 2 == speed + entity, 3 == speed + entity + LOS, 4 == speed + entity + LOS + trajectory, 5 == speed + entity + LOS + trajectory + update, 6 == speed + entity + LOS + trajectory + tickhistory")]
	public static int projectile_protection = 6;

	[Help("violation penalty to hand out when projectile hack is detected")]
	[ServerVar]
	public static float projectile_penalty = 0f;

	[Help("projectile speed forgiveness in percent, lower value = more false positives")]
	[ServerVar]
	public static float projectile_forgiveness = 0.5f;

	[Help("projectile server frames to include in delay, lower value = more false positives")]
	[ServerVar]
	public static float projectile_serverframes = 2f;

	[ServerVar]
	[Help("projectile client frames to include in delay, lower value = more false positives")]
	public static float projectile_clientframes = 2f;

	[ServerVar]
	[Help("projectile trajectory forgiveness, lower value = more false positives")]
	public static float projectile_trajectory = 2f;

	[Help("projectile trajectory forgiveness for projectile updates, lower value = more false positives")]
	[ServerVar]
	public static float projectile_trajectory_update = 0.02f;

	[Help("projectile penetration angle change, lower value = more false positives")]
	[ServerVar]
	public static float projectile_anglechange = 60f;

	[Help("projectile penetration velocity change, lower value = more false positives")]
	[ServerVar]
	public static float projectile_velocitychange = 1.1f;

	[ServerVar]
	[Help("projectile desync forgiveness, lower value = more false positives")]
	public static float projectile_desync = 1f;

	[ServerVar]
	[Help("projectile backtracking when checking for LOS")]
	public static float projectile_backtracking = 0.01f;

	[Help("line of sight directional forgiveness when checking eye or center position")]
	[ServerVar]
	public static float projectile_losforgiveness = 0.2f;

	[Help("how often a projectile is allowed to penetrate something before its damage is ignored")]
	[ServerVar]
	public static int projectile_damagedepth = 2;

	[ServerVar]
	[Help("how often a projectile is allowed to penetrate something before its impact spawn is ignored")]
	public static int projectile_impactspawndepth = 1;

	[ServerVar]
	[Help("whether or not to include terrain in the projectile LOS checks")]
	public static bool projectile_terraincheck = true;

	[ServerVar]
	[Help("whether or not to include vehicles in the projectile LOS checks")]
	public static bool projectile_vehiclecheck = true;

	[ServerVar]
	[Help("whether or not to compensate for the client / server vehicle position offset")]
	public static bool projectile_positionoffset = true;

	[Help("minimum distance before we verify client projectile distance mismatch, lower value = more false positives")]
	[ServerVar]
	public static float projectile_distance_forgiveness_minimum = 25f;

	[ServerVar]
	[Help("maximum number of projectile updates to allow before rejecting damage")]
	public static int projectile_update_limit = 4;

	[Help("0 == disabled, 1 == initiator, 2 == initiator + target, 3 == initiator + target + LOS, 4 == initiator + target + LOS + tickhistory")]
	[ServerVar]
	public static int melee_protection = 4;

	[Help("violation penalty to hand out when melee hack is detected")]
	[ServerVar]
	public static float melee_penalty = 0f;

	[ServerVar]
	[Help("melee distance forgiveness in percent, lower value = more false positives")]
	public static float melee_forgiveness = 0.5f;

	[ServerVar]
	[Help("melee server frames to include in delay, lower value = more false positives")]
	public static float melee_serverframes = 2f;

	[Help("melee client frames to include in delay, lower value = more false positives")]
	[ServerVar]
	public static float melee_clientframes = 2f;

	[ServerVar]
	[Help("melee backtracking when checking for LOS")]
	public static float melee_backtracking = 0.01f;

	[Help("line of sight directional forgiveness when checking eye or center position")]
	[ServerVar]
	public static float melee_losforgiveness = 0.2f;

	[Help("whether or not to include terrain in the melee LOS checks")]
	[ServerVar]
	public static bool melee_terraincheck = true;

	[Help("whether or not to include vehicles in the melee LOS checks")]
	[ServerVar]
	public static bool melee_vehiclecheck = true;

	[ServerVar]
	[Help("0 == disabled, 1 == distance, 2 == distance + LOS, 3 = distance + LOS + altitude, 4 = distance + LOS + altitude + noclip, 5 = distance + LOS + altitude + noclip + history")]
	public static int eye_protection = 4;

	[ServerVar]
	[Help("violation penalty to hand out when eye hack is detected")]
	public static float eye_penalty = 0f;

	[Help("eye distance forgiveness, lower value = more false positives")]
	[ServerVar]
	public static float eye_forgiveness = 0.4f;

	[Help("eye distance forgiveness for parented or mounted players, lower value = more false positives")]
	[ServerVar]
	public static float eye_distance_parented_mounted_forgiveness = 2f;

	[ServerVar]
	[Help("eye server frames to include in delay, lower value = more false positives")]
	public static float eye_serverframes = 2f;

	[ServerVar]
	[Help("eye client frames to include in delay, lower value = more false positives")]
	public static float eye_clientframes = 2f;

	[ServerVar]
	[Help("whether or not to include terrain in the eye LOS checks")]
	public static bool eye_terraincheck = true;

	[Help("whether or not to include vehicles in the eye LOS checks")]
	[ServerVar]
	public static bool eye_vehiclecheck = true;

	[Help("distance at which to start testing eye noclipping")]
	[ServerVar]
	public static float eye_noclip_cutoff = 0.06f;

	[ServerVar]
	[Help("collider margin when checking for noclipping")]
	public static float eye_noclip_margin = 0.25f;

	[ServerVar]
	[Help("collider backtracking when checking for noclipping")]
	public static float eye_noclip_backtracking = 0.01f;

	[Help("line of sight sphere cast radius, 0 == raycast")]
	[ServerVar]
	public static float eye_losradius = 0.158f;

	[Help("violation penalty to hand out when eye history mismatch is detected")]
	[ServerVar]
	public static float eye_history_penalty = 100f;

	[Help("how much forgiveness to add when checking the distance between player tick history and player eye history")]
	[ServerVar]
	public static float eye_history_forgiveness = 0.1f;

	[Help("maximum distance an impact effect can be from the entities bounds")]
	[ServerVar]
	public static float impact_effect_distance_forgiveness = 0.45f;

	[ServerVar]
	[Help("line of sight sphere cast radius, 0 == raycast")]
	public static float build_losradius = 0.01f;

	[Help("line of sight sphere cast radius, 0 == raycast")]
	[ServerVar]
	public static float build_losradius_sleepingbag = 0.3f;

	[ServerVar]
	[Help("whether or not to include terrain in the build LOS checks")]
	public static bool build_terraincheck = true;

	[ServerVar]
	[Help("whether or not to include vehicles in the build LOS checks")]
	public static bool build_vehiclecheck = true;

	[ServerVar]
	[Help("whether or not to check for building being done on the wrong side of something (e.g. inside rocks). 0 = Disabled, 1 = Info only, 2 = Enabled")]
	public static int build_inside_check = 2;

	[ServerVar]
	[Help("the maximum distance we check for for inside mesh")]
	public static float mesh_inside_check_distance = 50f;

	[ServerVar]
	[Help("use the older, simpler is inside check. has several loopholes that aren't properly catered to")]
	public static bool use_legacy_mesh_inside_check = true;

	[Help("whether or not to ensure players are always networked to server administrators")]
	[ServerVar]
	public static bool server_occlusion_admin_bypass = false;

	[ServerVar]
	[Help("number of blocked grids permitted before line-of-sight fails")]
	public static int server_occlusion_blocked_grid_threshold = 0;

	[ServerVar]
	[Help("number of neighbour checks permitted before line-of-sight fails")]
	public static int server_occlusion_neighbour_threshold = 2;

	[ServerVar]
	[Help("whether to use server occlusion caching")]
	public static bool server_occlusion_caching = true;

	[ServerVar]
	[Help("whether to save sub grid for map to a file on first time init, faster subsequent server launching")]
	public static bool server_occlusion_save_grid = true;

	[Help("whether to use neighbour threshold limitations")]
	[ServerVar]
	public static bool server_occlusion_use_neighbour_thresholds = false;

	[ServerVar]
	[Help("whether or not to skip the line-of-sight process, this will effectively disable server occlusion")]
	public static bool server_occlusion_disable_los = false;

	[ServerVar]
	[Help("whether or not to skip the line-of-sight process for sleepers")]
	public static bool server_occlusion_disable_sleeper_los = false;

	[ServerVar]
	[Help("How far a player is allowed to move in a single tick")]
	public static float tick_max_distance = 1.1f;

	[ServerVar]
	[Help("How far a player is allowed to move in a single tick when falling")]
	public static float tick_max_distance_falling = 4f;

	[ServerVar]
	[Help("How far a player is allowed to move in a single tick when parented")]
	public static float tick_max_distance_parented = 3f;

	[ServerVar]
	[Help("Whether or not to enable additional tick validation measures")]
	public static bool tick_buffer_preventions = true;

	[Help("How many seconds worth of ticks can be sent before server tick finalizing before we revert to noclip_protection 2")]
	[ServerVar]
	public static float tick_buffer_noclip_threshold = 2f;

	[ServerVar]
	[Help("How many seconds worth of ticks can be sent before server tick finalizing before we reject movement")]
	public static float tick_buffer_reject_threshold = 3f;

	[ServerVar]
	[Help("How long it should take for a server to process a frame before we decide to skip additional tick validation measures")]
	public static float tick_buffer_server_lag_threshold = 0.3f;

	[ServerVar]
	[Help("How far a player is allowed to move in forgiveness scenarios")]
	public static float tick_distance_forgiveness = 5f;

	[ServerVar(Help = "Should explosives parented to vehicles damage deployables")]
	public static bool explosive_vehicle_parent_damage_deployables = false;

	[ServerVar]
	[Help("How long, in seconds, can the clients progress timer deviate from the servers")]
	public static float rpc_timer_forgiveness = 1f;

	[ServerVar]
	[Help("0 == silent, 1 == print max violation, 2 == print nonzero violation, 3 == print any violation except noclip, 4 == print any violation")]
	public static int debuglevel = 1;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch.Extend;
using Steamworks;
using UnityEngine;

[Factory("app")]
public class App : ConsoleSystem
{
	[ServerVar]
	public static string listenip = "";

	[ServerVar]
	public static int port;

	[ServerVar]
	public static string publicip = "";

	[ServerVar(Help = "Disables updating entirely - emergency use only")]
	public static bool update = true;

	[ServerVar(Help = "Enables sending push notifications")]
	public static bool notifications = true;

	[ServerVar(Help = "Max number of queued messages - set to 0 to disable message processing")]
	public static int queuelimit = 100;

	[ReplicatedVar(Default = "")]
	public static string serverid = "";

	[ServerVar(Help = "Cooldown time before alarms can send another notification (in seconds)")]
	public static float alarmcooldown = 30f;

	[ServerVar]
	public static int maxconnections = 500;

	[ServerVar]
	public static int maxconnectionsperip = 5;

	[ServerVar]
	public static int maxmessagesize = 1048576;

	[ServerUserVar]
	public static async void pair(Arg arg)
	{
		try
		{
			BasePlayer basePlayer = arg.Player();
			if (!((Object)(object)basePlayer == (Object)null))
			{
				Dictionary<string, string> dictionary = Util.TryGetPlayerPairingData(basePlayer);
				if (dictionary == null)
				{
					arg.ReplyWith("This server is not configured to allow Rust+ connections.");
					return;
				}
				NotificationSendResult notificationSendResult = await Util.SendPairNotification("server", basePlayer, StringExtensions.Truncate(ConVar.Server.hostname, 128, (string)null), "Tap to pair with this server.", dictionary);
				arg.ReplyWith((notificationSendResult == NotificationSendResult.Sent) ? "Sent pairing notification." : notificationSendResult.ToErrorMessage().english);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	[ServerUserVar]
	public static void regeneratetoken(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			SingletonComponent<ServerMgr>.Instance.persistance.RegenerateAppToken(basePlayer.userID);
			arg.ReplyWith("Regenerated Rust+ token");
		}
	}

	[ServerVar]
	public static void info(Arg arg)
	{
		if (!CompanionServer.Server.IsEnabled)
		{
			arg.ReplyWith("Companion server is not enabled");
			return;
		}
		Listener listener = CompanionServer.Server.Listener;
		arg.ReplyWith(string.Format("Server ID: {0}\nListening on: {1}:{2}\nApp connects to: {3}:{4}", serverid, listener.Address, listener.Port, GetPublicIP() ?? "null", port));
	}

	[ServerVar(Help = "Retry initializing the Rust+ companion server if it previously failed")]
	public static void retry_initialize(Arg arg)
	{
		if (CompanionServer.Server.IsEnabled)
		{
			arg.ReplyWith("Companion server is already initialized!");
			return;
		}
		if (port < 0)
		{
			arg.ReplyWith("Companion server port is invalid, cannot initialize companion server");
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.rustPlus)
		{
			arg.ReplyWith("Companion server is disabled by gamemode, cannot initialize companion server");
			return;
		}
		arg.ReplyWith("Trying to initialize companion server...");
		CompanionServer.Server.Initialize();
	}

	[ServerVar]
	public static void resetlimiter(Arg arg)
	{
		CompanionServer.Server.Listener?.Limiter?.Clear();
	}

	[ServerVar]
	public static void connections(Arg arg)
	{
		string text = CompanionServer.Server.Listener?.Limiter?.ToString() ?? "Not available";
		arg.ReplyWith(text);
	}

	[ServerVar]
	public static void appban(Arg arg)
	{
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			arg.ReplyWith("Usage: app.appban <steamID64>");
			return;
		}
		string text = (SingletonComponent<ServerMgr>.Instance.persistance.SetAppTokenLocked(uLong, locked: true) ? $"Banned {uLong} from using the companion app" : $"{uLong} is already banned from using the companion app");
		arg.ReplyWith(text);
	}

	[ServerVar]
	public static void appunban(Arg arg)
	{
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			arg.ReplyWith("Usage: app.appunban <steamID64>");
			return;
		}
		string text = (SingletonComponent<ServerMgr>.Instance.persistance.SetAppTokenLocked(uLong, locked: false) ? $"Unbanned {uLong}, they can use the companion app again" : $"{uLong} is not banned from using the companion app");
		arg.ReplyWith(text);
	}

	public static IPAddress GetListenIP()
	{
		if (!string.IsNullOrWhiteSpace(listenip))
		{
			if (!IPAddress.TryParse(listenip, out IPAddress address) || address.AddressFamily != AddressFamily.InterNetwork)
			{
				Debug.LogError((object)("Invalid app.listenip: " + listenip));
				return IPAddress.Any;
			}
			return address;
		}
		return IPAddress.Any;
	}

	public static async ValueTask<string> GetPublicIPAsync()
	{
		Stopwatch timer = null;
		string publicIP;
		while (true)
		{
			bool num = timer != null && timer.Elapsed.TotalMinutes > 5.0;
			publicIP = GetPublicIP();
			if (num || (!string.IsNullOrWhiteSpace(publicIP) && publicIP != "0.0.0.0"))
			{
				break;
			}
			if (timer == null)
			{
				timer = Stopwatch.StartNew();
			}
			await Task.Delay(10000);
		}
		return publicIP;
	}

	public static string GetPublicIP()
	{
		if (!string.IsNullOrWhiteSpace(publicip) && IPAddress.TryParse(publicip, out IPAddress address) && address.AddressFamily == AddressFamily.InterNetwork)
		{
			return publicip;
		}
		if (!SteamServer.IsValid)
		{
			return null;
		}
		return SteamServer.PublicIp.ToString();
	}
}


using UnityEngine;

[Factory("audio")]
public class Audio : ConsoleSystem
{
	[ClientVar(Help = "Volume", Saved = true)]
	public static float master = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float musicvolume = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float musicvolumemenu = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float game = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float ui = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float voices = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float instruments = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float voiceProps = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float eventAudio = 1f;

	[ClientVar(Help = "Ambience System")]
	public static bool ambience = true;

	[ClientVar(Help = "Max ms per frame to spend updating sounds")]
	public static float framebudget = 0.3f;

	[ClientVar]
	public static float minupdatefraction = 0.1f;

	[ClientVar(Help = "Use more advanced sound occlusion", Saved = true)]
	public static bool advancedocclusion = false;

	[ClientVar(Help = "Use higher quality sound fades on some sounds")]
	public static bool hqsoundfade = false;

	[ClientVar(Saved = false)]
	public static bool debugVoiceLimiting = false;

	[ClientVar]
	public static bool enableSoundPooling = false;

	[ClientVar(Help = "Volume", Saved = true)]
	public static int speakers
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)AudioSettings.speakerMode;
		}
		set
		{
			value = Mathf.Clamp(value, 2, 7);
		}
	}

	[ClientVar]
	public static void printSounds(Arg arg)
	{
	}

	[ClientVar(ClientAdmin = true, Help = "print active engine sound info")]
	public static void printEngineSounds(Arg arg)
	{
	}
}


[Factory("batching")]
public class Batching : ConsoleSystem
{
	[ClientVar(ClientAdmin = true)]
	public static bool enabled = true;

	[ClientVar(ClientAdmin = true)]
	public static bool renderer_threading = true;

	[ClientVar(ClientAdmin = true)]
	public static int renderer_capacity = 30000;

	[ClientVar(ClientAdmin = true)]
	public static int renderer_vertices = 1000;

	[ClientVar(ClientAdmin = true)]
	public static int renderer_submeshes = 1;

	[ClientVar]
	public static bool batch_industrial_pipes = false;

	[ClientVar]
	[ServerVar]
	public static int verbose = 0;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[Factory("bot")]
public class Bot : ConsoleSystem
{
	[ServerVar(ShowInAdminUI = false)]
	public static string sv_exec_command(Arg args)
	{
		if (TryGetBotServer(args, out var bot, out var error))
		{
			return error;
		}
		string @string = args.GetString(1, "");
		if (string.IsNullOrEmpty(@string))
		{
			return "No command provided";
		}
		bot.Command(@string);
		return string.Empty;
	}

	[ServerVar(ShowInAdminUI = false)]
	public static string sv_exec_command_sphere(Arg args)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(1, "");
		if (string.IsNullOrEmpty(@string))
		{
			return "invalid command";
		}
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return "no player context";
		}
		PooledList<BasePlayer> val = Pool.Get<PooledList<BasePlayer>>();
		try
		{
			Vis.Entities(((Component)basePlayer).transform.position, args.GetFloat(0, 50f), (List<BasePlayer>)(object)val, -1, (QueryTriggerInteraction)2);
			int num = 0;
			foreach (BasePlayer item in (List<BasePlayer>)(object)val)
			{
				if (item.IsBot && item.isServer && !item.IsNpc)
				{
					item.Command(@string);
					num++;
				}
			}
			return $"Executed command on {num} bots.";
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(ShowInAdminUI = false)]
	public static string sv_exec_command_all(Arg args)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			return "invalid command";
		}
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.IsBot && current.isServer && !current.IsNpc)
				{
					num++;
					current.Command(@string);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return $"Executed command on {num} bots.";
	}

	[ServerVar(ShowInAdminUI = false)]
	public static string crouch_server(Arg args)
	{
		if (TryGetBotServer(args, out var bot, out var error))
		{
			return error;
		}
		bot.modelState.ducked = args.GetBool(0, true);
		bot.SendNetworkUpdate();
		return "Crouched " + bot.displayName + ".";
	}

	private static bool TryGetBotServer(Arg args, out BasePlayer bot, out string error)
	{
		ulong uLong = args.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			bot = null;
			error = "No user id";
			return true;
		}
		bot = BasePlayer.FindBot(uLong);
		if ((Object)(object)bot == (Object)null || bot.IsNpc)
		{
			error = $"No bot found with id{uLong}";
			return true;
		}
		error = string.Empty;
		return false;
	}
}


using UnityEngine;

[Factory("bradley")]
public class Bradley : ConsoleSystem
{
	[ServerVar]
	public static float respawnDelayMinutes = 60f;

	[ServerVar]
	public static float respawnDelayVariance = 1f;

	[ServerVar]
	public static bool enabled = true;

	[ServerVar]
	public static void quickrespawn(Arg arg)
	{
		if (!Object.op_Implicit((Object)(object)arg.Player()))
		{
			return;
		}
		BradleySpawner singleton = BradleySpawner.singleton;
		if ((Object)(object)singleton == (Object)null)
		{
			Debug.LogWarning((object)"No Spawner");
			return;
		}
		if (Object.op_Implicit((Object)(object)singleton.spawned))
		{
			singleton.spawned.Kill();
		}
		singleton.spawned = null;
		singleton.DoRespawn();
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using CircularBuffer;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;

[Factory("chat")]
public class Chat : ConsoleSystem
{
	public enum ChatChannel
	{
		Global = 0,
		Team = 1,
		Server = 2,
		Cards = 3,
		Local = 4,
		Clan = 5,
		ExternalDM = 6,
		MaxValue = 6
	}

	public struct ChatEntry
	{
		public ChatChannel Channel { get; set; }

		public string Message { get; set; }

		public string UserId { get; set; }

		public string Username { get; set; }

		public string Color { get; set; }

		public int Time { get; set; }
	}

	[ServerVar]
	public static float localChatRange = 100f;

	[ReplicatedVar]
	public static bool globalchat = true;

	[ReplicatedVar]
	public static bool localchat = false;

	private const float textVolumeBoost = 0.2f;

	[ReplicatedVar]
	public static bool hideChatInTutorial = true;

	[ServerVar]
	[ClientVar]
	public static bool enabled = true;

	[ServerVar(Help = "Number of messages to keep in memory for chat history")]
	public static int historysize = 1000;

	public static CircularBuffer<ChatEntry> History = new CircularBuffer<ChatEntry>(historysize);

	[ServerVar]
	public static bool serverlog = true;

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", (object)message, (object)username, (object)color, (object)userid) == null)
		{
			string text = StringEx.EscapeRichText(username, false);
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=" + color + ">" + text + "</color> " + message);
			ChatEntry ce = default(ChatEntry);
			ce.Channel = ChatChannel.Server;
			ce.Message = message;
			ce.UserId = userid.ToString();
			ce.Username = username;
			ce.Color = color;
			ce.Time = Epoch.Current;
			Record(ce);
		}
	}

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (globalchat)
		{
			sayImpl(ChatChannel.Global, arg);
		}
	}

	[ServerUserVar]
	public static void localsay(Arg arg)
	{
		if (localchat)
		{
			sayImpl(ChatChannel.Local, arg);
		}
	}

	[ServerUserVar]
	public static void teamsay(Arg arg)
	{
		sayImpl(ChatChannel.Team, arg);
	}

	[ServerUserVar]
	public static void cardgamesay(Arg arg)
	{
		sayImpl(ChatChannel.Cards, arg);
	}

	[ServerUserVar]
	public static void clansay(Arg arg)
	{
		sayImpl(ChatChannel.Clan, arg);
	}

	private static void sayImpl(ChatChannel targetChannel, Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer player = arg.Player();
		if (!Object.op_Implicit((Object)(object)player) || (hideChatInTutorial && player.IsInTutorial) || player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!player.IsAdmin && !player.IsDeveloper)
		{
			if (player.NextChatTime == 0f)
			{
				player.NextChatTime = Time.realtimeSinceStartup - 30f;
			}
			if (player.NextChatTime > Time.realtimeSinceStartup)
			{
				player.NextChatTime += 2f;
				float num = player.NextChatTime - Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(player.net.connection, "chat.add", 2, 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					player.Kick("Chatting too fast");
				}
				return;
			}
		}
		string @string = arg.GetString(0, "text");
		ValueTask<bool> valueTask = sayAs(targetChannel, player.userID, player.displayName, @string, player);
		Analytics.Azure.OnChatMessage(player, @string, (int)targetChannel);
		player.NextChatTime = Time.realtimeSinceStartup + 1.5f;
		if (valueTask.IsCompletedSuccessfully)
		{
			if (!valueTask.Result)
			{
				player.NextChatTime = Time.realtimeSinceStartup;
			}
			return;
		}
		Task<bool> task = valueTask.AsTask();
		task.GetAwaiter().OnCompleted(delegate
		{
			try
			{
				if (!task.Result)
				{
					player.NextChatTime = Time.realtimeSinceStartup;
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex);
			}
		});
	}

	internal static string GetNameColor(ulong userId, BasePlayer player = null)
	{
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = (((Object)(object)player != (Object)null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string result = "#5af";
		if (flag)
		{
			result = "#af5";
		}
		if (num)
		{
			result = "#fa5";
		}
		return result;
	}

	internal static async ValueTask<bool> sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!Object.op_Implicit((Object)(object)player))
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if ((Object)(object)player != (Object)null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		if ((ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string strChatText = message.Replace("\n", "").Replace("\r", "").Trim();
		if (strChatText.Length > 128)
		{
			strChatText = strChatText.Substring(0, 128);
		}
		if (strChatText.Length <= 0)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnPlayerChat", (object)userId, (object)username, (object)strChatText, (object)targetChannel, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (strChatText.StartsWith("/") || strChatText.StartsWith("\\"))
		{
			return false;
		}
		strChatText = StringEx.EscapeRichText(strChatText, false);
		if (ConVar.Server.emojiOwnershipCheck && strChatText.Contains(":") && (Object)(object)player != (Object)null)
		{
			List<(TmProEmojiRedirector.EmojiSub, int)> list = Pool.Get<List<(TmProEmojiRedirector.EmojiSub, int)>>();
			TmProEmojiRedirector.FindEmojiSubstitutions(strChatText, RustEmojiLibrary.Instance, list, richText: false, isServer: true);
			foreach (var item in list)
			{
				if (!item.Item1.targetEmojiResult.CanBeUsedBy(player, player.userID))
				{
					strChatText = strChatText.Replace(":" + item.Item1.targetEmoji + ":", string.Empty);
				}
			}
			Pool.FreeUnmanaged<(TmProEmojiRedirector.EmojiSub, int)>(ref list);
			if (strChatText.Length <= 0)
			{
				return false;
			}
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured("[" + targetChannel.ToString() + "] " + username + " : " + strChatText, ConsoleColor.Green);
		}
		string strName = StringEx.EscapeRichText(username, false);
		string nameColor = GetNameColor(userId, player);
		ChatEntry ce = default(ChatEntry);
		ce.Channel = targetChannel;
		ce.Message = strChatText;
		ce.UserId = (((Object)(object)player != (Object)null) ? player.UserIDString : userId.ToString());
		ce.Username = username;
		ce.Color = nameColor;
		ce.Time = Epoch.Current;
		Record(ce);
		switch (targetChannel)
		{
		case ChatChannel.Cards:
		{
			if ((Object)(object)player == (Object)null)
			{
				return false;
			}
			if (!player.isMounted)
			{
				return false;
			}
			BaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;
			if ((Object)(object)baseCardGameEntity == (Object)null || !(baseCardGameEntity.GameController?.IsAtTable(player) ?? false))
			{
				return false;
			}
			List<Connection> list2 = Pool.Get<List<Connection>>();
			baseCardGameEntity.GameController?.GetConnectionsInGame(list2);
			if (list2.Count > 0)
			{
				ConsoleNetwork.SendClientCommand(list2, "chat.add2", 3, userId, strChatText, strName, nameColor, 1f);
			}
			Pool.FreeUnmanaged<Connection>(ref list2);
			return true;
		}
		case ChatChannel.Global:
			ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, strChatText, strName, nameColor, 1f);
			return true;
		case ChatChannel.Local:
		{
			if (!((Object)(object)player != (Object)null))
			{
				break;
			}
			float num = localChatRange * localChatRange;
			Enumerator<BasePlayer> enumerator2 = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BasePlayer current2 = enumerator2.Current;
					Vector3 val3 = ((Component)current2).transform.position - ((Component)player).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (!(sqrMagnitude > num))
					{
						ConsoleNetwork.SendClientCommand(current2.net.connection, "chat.add2", 4, userId, strChatText, strName, nameColor, Mathf.Clamp01(sqrMagnitude / num + 0.2f));
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			return true;
		}
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, strChatText, strName, nameColor, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, strName, strChatText, nameColor);
			return true;
		}
		case ChatChannel.Clan:
		{
			ClanManager serverInstance = ClanManager.ServerInstance;
			if ((Object)(object)serverInstance == (Object)null)
			{
				return false;
			}
			if ((Object)(object)player != (Object)null && player.clanId == 0L)
			{
				return false;
			}
			try
			{
				ClanValueResult<IClan> val = ((!((Object)(object)player != (Object)null) || player.clanId == 0L) ? (await serverInstance.Backend.GetByMember(userId)) : (await serverInstance.Backend.Get(player.clanId)));
				ClanValueResult<IClan> val2 = val;
				if (!val2.IsSuccess)
				{
					return false;
				}
				if ((int)(await val2.Value.SendChatMessage(strName, strChatText, userId)) != 1)
				{
					return false;
				}
				return true;
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex);
				return false;
			}
		}
		}
		return false;
	}

	[ServerVar]
	[Help("Return the last x lines of the console. Default is 200")]
	public static IEnumerable<ChatEntry> tail(Arg arg)
	{
		int @int = arg.GetInt(0, 200);
		int num = History.Size - @int;
		if (num < 0)
		{
			num = 0;
		}
		return ((IEnumerable<ChatEntry>)History).Skip(num);
	}

	[ServerVar]
	[Help("Search the console for a particular string")]
	public static IEnumerable<ChatEntry> search(Arg arg)
	{
		string search = arg.GetString(0, (string)null);
		if (search == null)
		{
			return Enumerable.Empty<ChatEntry>();
		}
		return ((IEnumerable<ChatEntry>)History).Where((ChatEntry x) => x.Message.Length < 4096 && StringEx.Contains(x.Message, search, CompareOptions.IgnoreCase));
	}

	public static void Record(ChatEntry ce)
	{
		int num = Mathf.Max(historysize, 10);
		if (History.Capacity != num)
		{
			CircularBuffer<ChatEntry> val = new CircularBuffer<ChatEntry>(num);
			foreach (ChatEntry item in History)
			{
				val.PushBack(item);
			}
			History = val;
		}
		History.PushBack(ce);
		RCon.Broadcast(RCon.LogType.Chat, ce);
	}
}


public enum ChatChannel
{
	Global = 0,
	Team = 1,
	Server = 2,
	Cards = 3,
	Local = 4,
	Clan = 5,
	ExternalDM = 6,
	MaxValue = 6
}


public struct ChatEntry
{
	public ChatChannel Channel { get; set; }

	public string Message { get; set; }

	public string UserId { get; set; }

	public string Username { get; set; }

	public string Color { get; set; }

	public int Time { get; set; }
}


using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

[Factory("clan")]
public class Clan : ConsoleSystem
{
	[ReplicatedVar(Help = "If enabled then players will need to be near a Clan Table to make changes to clans", Default = "true")]
	public static bool editsRequireClanTable = true;

	[ServerVar(Help = "Enables the clan system if set to true (must be set at boot, requires restart)")]
	public static bool enabled = false;

	[ServerVar(Help = "Maximum number of members each clan can have (local backend only!)")]
	public static int maxMemberCount = 100;

	[ServerVar(Help = "How much score players earn for killing a player in another clan")]
	public static int scoreForKillingPlayerInOtherClan = 10;

	[ServerVar(Help = "How much score players earn for being killed by a player in another clan (this value should be negative)")]
	public static int scoreForKilledByPlayerInOtherClan = -10;

	[ServerVar(Help = "How much score players earn for killing unarmed players (this value should be negative)")]
	public static int scoreForKillingUnarmedPlayer = -10;

	[ServerVar(Help = "How much score players earn for destroying other player's tool cupboards")]
	public static int scoreForDestroyingToolCupboards = 10;

	[ServerVar(Help = "How much score players earn for hacking crates")]
	public static int scoreForHackingCrates = 5;

	[ServerVar(Help = "How much score players earn for opening hacked crates")]
	public static int scoreForOpeningHackedCrates = 5;

	[ServerVar(Help = "How much score players earn for destroying bradley")]
	public static int scoreForDestroyingBradley = 10;

	[ServerVar(Help = "How much score players earn for running the excavator")]
	public static int scoreForRunningExcavator = 10;

	[ServerVar(Help = "How much score players earn for reaching cargo ship")]
	public static int scoreForReachingCargoShip = 10;

	[ServerVar(Help = "How much score players earn for looting an elite crate")]
	public static int scoreForLootingEliteCrate = 10;

	[ServerVar(Help = "Prints info about a clan given its ID")]
	public static void Info(Arg arg)
	{
		if ((Object)(object)ClanManager.ServerInstance == (Object)null)
		{
			arg.ReplyWith("ClanManager is null!");
			return;
		}
		long clanId = arg.GetLong(0, 0L);
		if (clanId == 0L)
		{
			BasePlayer basePlayer = arg.Player();
			if ((Object)(object)basePlayer == (Object)null)
			{
				arg.ReplyWith("Usage: clan.info <clanID>");
			}
			else
			{
				SendClanInfoPlayer(basePlayer);
			}
		}
		else
		{
			SendClanInfoConsole(clanId);
		}
		static string FormatClan(IClan clan)
		{
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"Clan ID: {clan.ClanId}");
			stringBuilder.AppendLine("Name: " + clan.Name);
			stringBuilder.AppendLine("MoTD: " + clan.Motd);
			stringBuilder.AppendLine("Members:");
			TextTable val3 = Pool.Get<TextTable>();
			try
			{
				val3.AddColumns(new string[4] { "steamID", "username", "online", "role" });
				foreach (ClanMember member in clan.Members)
				{
					ClanRole? val4 = List.TryFindWith<ClanRole, int>((IReadOnlyCollection<ClanRole>)clan.Roles, (Func<ClanRole, int>)((ClanRole r) => r.RoleId), member.RoleId, (IEqualityComparer<int>)null);
					string text = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member.SteamId) ?? "[unknown]";
					bool flag = (NexusServer.Started ? NexusServer.IsOnline(member.SteamId) : ServerPlayers.IsOnline(member.SteamId));
					string[] array = new string[4];
					ulong steamId = member.SteamId;
					array[0] = steamId.ToString();
					array[1] = text;
					array[2] = (flag ? "x" : "");
					array[3] = val4?.Name ?? "[null]";
					val3.AddRow(array);
				}
				stringBuilder.Append(val3);
				return stringBuilder.ToString();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		static async void SendClanInfoConsole(long id)
		{
			try
			{
				IClan val5 = await GetClanByID(id);
				if (val5 != null)
				{
					Debug.Log((object)FormatClan(val5));
				}
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
		}
		async void SendClanInfoPlayer(BasePlayer player)
		{
			_ = 1;
			try
			{
				IClan val = ((clanId != 0L) ? (await GetClanByID(clanId)) : (await GetPlayerClan(player)));
				IClan val2 = val;
				if (val2 != null)
				{
					string msg = FormatClan(val2);
					player.ConsoleMessage(msg);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				player.ConsoleMessage(ex.ToString());
			}
		}
	}

	private static async ValueTask<IClan> GetPlayerClan(BasePlayer player)
	{
		ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.GetByMember((ulong)player.userID);
		if (!val.IsSuccess)
		{
			string msg = (((int)val.Result == 3) ? "You're not in a clan!" : "Failed to find your clan!");
			player.ConsoleMessage(msg);
			return null;
		}
		return val.Value;
	}

	private static async ValueTask<IClan> GetClanByID(long clanId, BasePlayer player = null)
	{
		ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.Get(clanId);
		if (!val.IsSuccess)
		{
			string text = (((int)val.Result == 4) ? $"Clan with ID {clanId} was not found!" : $"Failed to get the clan with ID {clanId} ({val.Result})!");
			if ((Object)(object)player != (Object)null)
			{
				player.ConsoleMessage(text);
			}
			else
			{
				Debug.Log((object)text);
			}
			return null;
		}
		return val.Value;
	}

	public static int GetScoreForEvent(ClanScoreEventType eventType)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected I4, but got Unknown
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		return (eventType - -1) switch
		{
			1 => 1, 
			2 => scoreForKillingPlayerInOtherClan, 
			3 => scoreForKilledByPlayerInOtherClan, 
			4 => scoreForKillingUnarmedPlayer, 
			5 => scoreForDestroyingToolCupboards, 
			6 => scoreForHackingCrates, 
			7 => scoreForOpeningHackedCrates, 
			8 => scoreForDestroyingBradley, 
			9 => scoreForRunningExcavator, 
			10 => scoreForReachingCargoShip, 
			11 => scoreForLootingEliteCrate, 
			0 => 0, 
			_ => Unknown(eventType), 
		};
		static int Unknown(ClanScoreEventType type)
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			Debug.LogError((object)$"Unhandled score event type: {type}");
			return 0;
		}
	}
}


[Factory("client")]
public class Client : ConsoleSystem
{
}


using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using UnityEngine;

[Factory("console")]
public class Console : ConsoleSystem
{
	[Help("Return the last x lines of the console. Default is 200")]
	[ServerVar]
	public static IEnumerable<Output.Entry> tail(Arg arg)
	{
		int @int = arg.GetInt(0, 200);
		int num = Output.HistoryOutput.Count - @int;
		if (num < 0)
		{
			num = 0;
		}
		return Output.HistoryOutput.Skip(num);
	}

	[Help("Search the console for a particular string")]
	[ServerVar]
	public static IEnumerable<Output.Entry> search(Arg arg)
	{
		string search = arg.GetString(0, (string)null);
		if (search == null)
		{
			return Enumerable.Empty<Output.Entry>();
		}
		return Output.HistoryOutput.Where((Output.Entry x) => x.Message.Length < 4096 && StringEx.Contains(x.Message, search, CompareOptions.IgnoreCase));
	}
}


[Factory("construct")]
public class Construct : ConsoleSystem
{
	[Help("How many minutes before a placed frame gets destroyed")]
	[ServerVar]
	public static float frameminutes = 30f;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Factory("copypaste")]
public class CopyPaste : ConsoleSystem
{
	private class EntityWrapper
	{
		public BaseEntity Entity;

		public Entity Protobuf;

		public Vector3 Position;

		public Quaternion Rotation;

		public bool HasParent;
	}

	public class PasteOptions
	{
		public const string Argument_NPCs = "--npcs";

		public const string Argument_Resources = "--resources";

		public const string Argument_Vehicles = "--vehicles";

		public const string Argument_Deployables = "--deployables";

		public const string Argument_FoundationsOnly = "--foundations-only";

		public const string Argument_BuildingBlocksOnly = "--building-only";

		public const string Argument_SnapToTerrain = "--autosnap-terrain";

		public const string Argument_SnapToZeroHeight = "--autosnap-zero";

		public const string Argument_PastePlayers = "--players";

		public bool Resources;

		public bool NPCs;

		public bool Vehicles;

		public bool Deployables;

		public bool FoundationsOnly;

		public bool BuildingBlocksOnly;

		public bool SnapToTerrain;

		public bool SnapToZero;

		public bool Players;

		public Vector3 Origin;

		public Quaternion PlayerRotation;

		public Vector3 HeightOffset;

		public PasteOptions(Arg arg)
		{
			Resources = arg.HasArg("--resources", true);
			NPCs = arg.HasArg("--npcs", true);
			Vehicles = arg.HasArg("--vehicles", true);
			Deployables = arg.HasArg("--deployables", true);
			FoundationsOnly = arg.HasArg("--foundations-only", true);
			BuildingBlocksOnly = arg.HasArg("--building-only", true);
			SnapToTerrain = arg.HasArg("--autosnap-terrain", true);
			SnapToZero = arg.HasArg("--autosnap-zero", true);
			Players = arg.HasArg("--players", true);
		}

		public PasteOptions(PasteRequest request)
		{
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			Resources = request.resources;
			NPCs = request.npcs;
			Vehicles = request.vehicles;
			Deployables = request.deployables;
			FoundationsOnly = request.foundationsOnly;
			BuildingBlocksOnly = request.buildingBlocksOnly;
			SnapToTerrain = request.snapToTerrain;
			SnapToZero = request.snapToZero;
			Players = request.players;
			Origin = request.origin;
			PlayerRotation = Quaternion.Euler(request.playerRotation);
			HeightOffset = request.heightOffset;
		}

		public PasteOptions()
		{
		}
	}

	private const string ClipboardFileName = "clipboard";

	private const string OverwriteFlag = "--overwrite";

	private static CopyPasteHistoryManager playerHistory = new CopyPasteHistoryManager();

	private static void PrintPasteNames(StringBuilder builder, string directory)
	{
		if (!Directory.Exists(directory))
		{
			builder.AppendLine("No pastes found");
			return;
		}
		string[] files = Directory.GetFiles(directory, "*.data");
		builder.AppendLine($"Found {files.Length} pastes");
		foreach (string item in files.OrderBy((string x) => x))
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(item);
			builder.AppendLine(fileNameWithoutExtension);
		}
	}

	private static void CopyEntities(BasePlayer player, List<BaseEntity> entities, string name, Vector3 originPos, Quaternion originRot)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OrderEntitiesForSave(entities);
		CopyPasteEntityInfo val = Pool.Get<CopyPasteEntityInfo>();
		try
		{
			val.entities = Pool.Get<List<Entity>>();
			Transform transform = new GameObject("Align").transform;
			transform.position = originPos;
			transform.rotation = originRot;
			foreach (BaseEntity entity in entities)
			{
				if (!entity.isClient && entity.enableSaving)
				{
					BaseEntity baseEntity = entity.parentEntity.Get(serverside: true);
					if ((Object)(object)baseEntity != (Object)null && (!entities.Contains(baseEntity) || !baseEntity.enableSaving))
					{
						Debug.LogWarning((object)("Skipping " + entity.ShortPrefabName + " as it is parented to an entity not included in the copy (it would become orphaned)"));
					}
					else
					{
						SaveEntity(entity, val, baseEntity, transform);
					}
				}
			}
			Object.Destroy((Object)(object)((Component)transform).gameObject);
			CopyPasteEntity.ServerInstance?.ClientRPC(RpcTarget.Player("RecievePaste", player), name, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static List<EntityWrapper> PrepareEntityProtos(CopyPasteEntityInfo toLoad, PasteOptions options, bool assignNewUids)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		toLoad = toLoad.Copy();
		HashSet<NetworkableId> hashSet = new HashSet<NetworkableId>();
		for (int i = 0; i < toLoad.entities.Count; i++)
		{
			Entity val = toLoad.entities[i];
			if (!hashSet.Add(val.baseNetworkable.uid))
			{
				GameObject obj = GameManager.server.FindPrefab(val.baseNetworkable.prefabID);
				BaseEntity baseEntity = ((obj != null) ? obj.GetComponent<BaseEntity>() : null);
				Debug.LogWarning((object)string.Format("Skipping entity [{0}/{1}]: duplicate entity in paste, please re-save", val.baseNetworkable.uid, ((Object)(object)baseEntity == (Object)null) ? "unknown" : baseEntity.ShortPrefabName));
				toLoad.entities.RemoveAt(i);
				i--;
			}
		}
		Transform transform = new GameObject("Align").transform;
		transform.position = options.Origin;
		transform.rotation = options.PlayerRotation;
		List<EntityWrapper> list = new List<EntityWrapper>();
		Dictionary<ulong, ulong> remapping = new Dictionary<ulong, ulong>();
		Dictionary<uint, uint> dictionary = new Dictionary<uint, uint>();
		if (assignNewUids)
		{
			remapping = new Dictionary<ulong, ulong>();
		}
		foreach (Entity entity in toLoad.entities)
		{
			if (assignNewUids)
			{
				entity.InspectUids((UidInspector<ulong>)UpdateWithNewUid);
			}
			EntityWrapper item = new EntityWrapper
			{
				Protobuf = entity,
				HasParent = (entity.parent != null && entity.parent.uid != default(NetworkableId))
			};
			list.Add(item);
			if (entity.decayEntity != null)
			{
				if (!dictionary.TryGetValue(entity.decayEntity.buildingID, out var value))
				{
					value = BuildingManager.server.NewBuildingID();
					dictionary.Add(entity.decayEntity.buildingID, value);
				}
				entity.decayEntity.buildingID = value;
			}
		}
		foreach (EntityWrapper item2 in list)
		{
			item2.Position = item2.Protobuf.baseEntity.pos;
			item2.Rotation = Quaternion.Euler(item2.Protobuf.baseEntity.rot);
			if (!item2.HasParent)
			{
				item2.Protobuf.baseEntity.pos = transform.TransformPoint(item2.Protobuf.baseEntity.pos);
				BaseEntity baseEntity2 = item2.Protobuf.baseEntity;
				Quaternion val2 = transform.rotation * Quaternion.Euler(item2.Protobuf.baseEntity.rot);
				baseEntity2.rot = ((Quaternion)(ref val2)).eulerAngles;
			}
		}
		if (Application.isPlaying)
		{
			Object.Destroy((Object)(object)((Component)transform).gameObject);
		}
		else
		{
			Object.DestroyImmediate((Object)(object)((Component)transform).gameObject);
		}
		return list;
		void UpdateWithNewUid(UidType type, ref ulong prevUid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			if ((int)type == 3)
			{
				prevUid = 0uL;
			}
			else if (prevUid != 0L && remapping != null)
			{
				if (!remapping.TryGetValue(prevUid, out var value2))
				{
					value2 = Net.sv.TakeUID();
					remapping.Add(prevUid, value2);
				}
				prevUid = value2;
			}
		}
	}

	private static void ApplyAutoSnap(List<BaseEntity> entities, PasteOptions options)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		float num2 = float.MinValue;
		foreach (BaseEntity entity in entities)
		{
			Vector3 position = ((Component)entity).transform.position;
			if (((Object)(object)entity.parentEntity.Get(serverside: true) == (Object)null && entity.ShortPrefabName == "foundation") || entity.ShortPrefabName == "foundation.triangle" || entity is PlayerBoat)
			{
				float num3 = ((!Application.isPlaying) ? 0f : TerrainMeta.HeightMap.GetHeight(position));
				RaycastHit hitInfo;
				if (options.SnapToZero)
				{
					num3 = 0f;
				}
				else if (GamePhysics.Trace(new Ray(new Vector3(position.x, num3, position.z) + new Vector3(0f, 100f, 0f), Vector3.down), 0f, out hitInfo, 100f, 8454160, (QueryTriggerInteraction)0))
				{
					num3 = ((RaycastHit)(ref hitInfo)).point.y;
				}
				if (position.y > num3)
				{
					num = Mathf.Min(num, position.y - num3);
				}
				if (num3 > position.y)
				{
					num2 = Mathf.Max(num2, num3 - position.y);
				}
			}
		}
		if ((!options.SnapToTerrain && !options.SnapToZero) || (num == float.MaxValue && num2 == float.MinValue))
		{
			num2 = 0f;
			num = 0f;
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0f, (num < num2 || num2 == float.MinValue) ? (num * -1f) : num2, 0f);
		val += options.HeightOffset;
		if (!(val != Vector3.zero))
		{
			return;
		}
		foreach (BaseEntity entity2 in entities)
		{
			if ((Object)(object)entity2.parentEntity.Get(serverside: true) == (Object)null)
			{
				Transform transform = ((Component)entity2).transform;
				transform.position += val;
			}
			if (!(entity2 is IOEntity iOEntity))
			{
				continue;
			}
			if (iOEntity.inputs != null)
			{
				IOEntity.IOSlot[] inputs = iOEntity.inputs;
				foreach (IOEntity.IOSlot obj in inputs)
				{
					obj.originPosition += val;
				}
			}
			if (iOEntity.outputs != null)
			{
				IOEntity.IOSlot[] inputs = iOEntity.outputs;
				foreach (IOEntity.IOSlot obj2 in inputs)
				{
					obj2.originPosition += val;
				}
			}
		}
	}

	public static List<BaseEntity> PasteEntitiesInternal(CopyPasteEntityInfo toLoad, PasteOptions options)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		List<EntityWrapper> list = PrepareEntityProtos(toLoad, options, assignNewUids: true);
		List<BaseEntity> list2 = new List<BaseEntity>();
		foreach (EntityWrapper item in list)
		{
			if (CanPrefabBePasted(item.Protobuf.baseNetworkable.prefabID, options))
			{
				item.Entity = GameManager.server.CreateEntity(StringPool.Get(item.Protobuf.baseNetworkable.prefabID), item.Protobuf.baseEntity.pos, Quaternion.Euler(item.Protobuf.baseEntity.rot));
				if (item.Protobuf.basePlayer != null && item.Protobuf.basePlayer.userid > 10000000)
				{
					ulong userid = 10000000uL + (ulong)Random.Range(1, int.MaxValue);
					item.Protobuf.basePlayer.userid = userid;
				}
				item.Entity.InitLoad(item.Protobuf.baseNetworkable.uid);
				item.Entity.PreServerLoad();
				list2.Add(item.Entity);
			}
		}
		list.RemoveAll((EntityWrapper x) => (Object)(object)x.Entity == (Object)null);
		for (int i = 0; i < list.Count; i++)
		{
			EntityWrapper entityWrapper = list[i];
			BaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);
			info.fromDisk = true;
			info.fromCopy = true;
			info.msg = entityWrapper.Protobuf;
			try
			{
				entityWrapper.Entity.Spawn();
				bool flag = false;
				if (!flag && entityWrapper.Protobuf.parent != null && entityWrapper.Protobuf.parent.uid != default(NetworkableId))
				{
					BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityWrapper.Protobuf.parent.uid) as BaseEntity;
					if ((Object)(object)baseEntity == (Object)null || baseEntity.net == null)
					{
						flag = true;
					}
				}
				if (flag)
				{
					entityWrapper.Entity.Kill();
					list.RemoveAt(i);
					i--;
				}
				else
				{
					entityWrapper.Entity.Load(info);
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Failed to spawn entity '" + entityWrapper.Entity?.PrefabName + "' while pasting"));
				Debug.LogException(ex);
				try
				{
					entityWrapper.Entity.Kill();
				}
				catch
				{
				}
			}
		}
		ApplyAutoSnap(list2, options);
		foreach (EntityWrapper item2 in list)
		{
			item2.Entity.PostServerLoad();
			item2.Entity.UpdateNetworkGroup();
		}
		foreach (EntityWrapper item3 in list)
		{
			item3.Entity.RefreshEntityLinks();
		}
		foreach (EntityWrapper item4 in list)
		{
			if (item4.Entity is BuildingBlock buildingBlock)
			{
				buildingBlock.UpdateSkin(force: true);
			}
		}
		return (from x in list
			select x.Entity into x
			where (Object)(object)x != (Object)null
			select x).ToList();
	}

	public static List<BaseEntity> PasteEntitiesEditMode(CopyPasteEntityInfo toLoad, PasteOptions options)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		List<EntityWrapper> list = PrepareEntityProtos(toLoad, options, assignNewUids: false);
		List<BaseEntity> list2 = new List<BaseEntity>();
		foreach (EntityWrapper item in list)
		{
			if (CanPrefabBePasted(item.Protobuf.baseNetworkable.prefabID, options))
			{
				string strPrefab = StringPool.Get(item.Protobuf.baseNetworkable.prefabID);
				item.Entity = GameManager.server.CreateEntity(strPrefab, item.Protobuf.baseEntity.pos, Quaternion.Euler(item.Protobuf.baseEntity.rot));
				if ((Object)(object)item.Entity != (Object)null)
				{
					list2.Add(item.Entity);
				}
			}
		}
		list.RemoveAll((EntityWrapper x) => (Object)(object)x.Entity == (Object)null);
		ApplyAutoSnap(list2, options);
		foreach (BaseEntity item2 in list2)
		{
			item2.RefreshEntityLinks();
		}
		return list2;
	}

	public static CopyPasteEntityInfo LoadFileFromBundles(string fullPath)
	{
		CopyPasteDataAsset copyPasteDataAsset = FileSystem.Load<CopyPasteDataAsset>(fullPath, true);
		if (copyPasteDataAsset == null)
		{
			Debug.LogWarning((object)("Missing file: " + fullPath));
			return null;
		}
		return CopyPasteEntityInfo.Deserialize(copyPasteDataAsset.GetData());
	}

	private static void SaveEntity(BaseEntity baseEntity, CopyPasteEntityInfo toSave, BaseEntity parent, Transform alignObject)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		BaseNetworkable.SaveInfo info = default(BaseNetworkable.SaveInfo);
		info.forDisk = true;
		info.msg = Pool.Get<Entity>();
		baseEntity.Save(info);
		if ((Object)(object)parent == (Object)null)
		{
			info.msg.baseEntity.pos = alignObject.InverseTransformPoint(info.msg.baseEntity.pos);
			_ = alignObject.rotation * ((Component)baseEntity).transform.rotation;
			BaseEntity baseEntity2 = info.msg.baseEntity;
			Quaternion val = Quaternion.Inverse(((Component)alignObject).transform.rotation) * ((Component)baseEntity).transform.rotation;
			baseEntity2.rot = ((Quaternion)(ref val)).eulerAngles;
		}
		toSave.entities.Add(info.msg);
	}

	private static void GetEntitiesLookingAt(Vector3 originPoint, Vector3 direction, List<BaseEntity> entityList)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		entityList.Clear();
		BuildingBlock buildingBlock = GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, new Ray(originPoint, direction), 0f, 100f, 136315136, (QueryTriggerInteraction)0) as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return;
		}
		ListHashSet<DecayEntity> val = buildingBlock.GetBuilding()?.decayEntities;
		if (val != null)
		{
			BaseEntity rootParentEntity = buildingBlock.GetRootParentEntity();
			if (rootParentEntity is PlayerBoat)
			{
				entityList.Add(rootParentEntity);
			}
			else
			{
				entityList.AddRange((IEnumerable<BaseEntity>)val);
			}
		}
	}

	private static void GetEntitiesInRadius(Vector3 originPoint, float radius, List<BaseEntity> entityList)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (radius <= 0f)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(originPoint, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient)
			{
				entityList.Add(item);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static void GetEntitiesInBounds(Bounds bounds, List<BaseEntity> entityList)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		OBB bounds2 = new OBB(bounds);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(bounds2, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient)
			{
				entityList.Add(item);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static bool CanPrefabBePasted(uint prefabId, PasteOptions options)
	{
		GameObject val = GameManager.server.FindPrefab(prefabId);
		if ((Object)(object)val == (Object)null)
		{
			return false;
		}
		BaseEntity component = val.GetComponent<BaseEntity>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		if (options.FoundationsOnly && component.ShortPrefabName != "foundation" && component.ShortPrefabName != "foundation.triangle")
		{
			return false;
		}
		if (options.BuildingBlocksOnly && !(component is BuildingBlock))
		{
			return false;
		}
		if (component is DecayEntity && !(component is BuildingBlock) && !options.Deployables)
		{
			return false;
		}
		if (component is BasePlayer { IsNpc: false } && !options.Players)
		{
			return false;
		}
		if (component is PointEntity || component is RelationshipManager)
		{
			return false;
		}
		if ((component is ResourceEntity || component is BushEntity) && !options.Resources)
		{
			return false;
		}
		if ((component is BaseNpc || component is RidableHorse) && !options.NPCs)
		{
			return false;
		}
		if (component is BaseVehicle && !(component is RidableHorse) && !options.Vehicles)
		{
			return false;
		}
		return true;
	}

	private static void OrderEntitiesForSave(List<BaseEntity> entities)
	{
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		list.AddRange(entities);
		entities.Clear();
		HashSet<BaseEntity> hash = new HashSet<BaseEntity>();
		foreach (BaseEntity item in list.OrderBy((BaseEntity x) => x.net.ID.Value))
		{
			AddRecursive(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		void AddRecursive(BaseEntity current)
		{
			if (hash.Add(current))
			{
				entities.Add(current);
				if (current.children != null)
				{
					foreach (BaseEntity child in current.children)
					{
						AddRecursive(child);
					}
				}
			}
		}
	}

	[ServerVar(Name = "copybox_sv")]
	public static void copybox_sv(Arg args)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Missing args: copybox_sv <name> <center> <size> <rotation>");
			return;
		}
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		Vector3 vector2 = args.GetVector3(2, default(Vector3));
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		Bounds bounds = new Bounds(vector, vector2);
		List<BaseEntity> list = Pool.GetList<BaseEntity>();
		GetEntitiesInBounds(bounds, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeList<BaseEntity>(ref list);
	}

	public static void copyboat_sv(Arg args)
	{
	}

	public static List<BaseEntity> PasteEntities(CopyPasteEntityInfo data, PasteOptions options, ulong steamId)
	{
		List<BaseEntity> list;
		try
		{
			Application.isLoadingSave = true;
			Application.isLoading = true;
			list = PasteEntitiesInternal(data, options);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return new List<BaseEntity>();
		}
		finally
		{
			Application.isLoadingSave = false;
			Application.isLoading = false;
		}
		foreach (BaseEntity item in list)
		{
			if (!((Object)(object)item == (Object)null) && item is StabilityEntity stabilityEntity)
			{
				stabilityEntity.UpdateStability();
			}
		}
		playerHistory.AddToHistory(steamId, list);
		return list;
	}

	[ServerVar]
	public static void undopaste_sv(Arg args)
	{
		ulong steamId = args.Player()?.userID ?? ((EncryptedValue<ulong>)0uL);
		PasteResult pasteResult = playerHistory.Undo(steamId);
		if (pasteResult == null)
		{
			args.ReplyWith("History empty");
			return;
		}
		foreach (BaseEntity entity in pasteResult.Entities)
		{
			entity.Kill();
		}
	}

	[ServerVar]
	public static void copyradius_sv(Arg args)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		float @float = args.GetFloat(2, 0f);
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		if (@float <= 0f)
		{
			args.ReplyWith("Invalid radius: must be greater than zero");
			return;
		}
		GetEntitiesInRadius(vector, @float, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	[ServerVar]
	public static void copybuilding_sv(Arg args)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		Vector3 vector2 = args.GetVector3(2, default(Vector3));
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		GetEntitiesLookingAt(vector, vector2, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	[ServerVar]
	public static void printselection_sv(Arg args)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 vector = args.GetVector3(0, default(Vector3));
		Vector3 vector2 = args.GetVector3(1, default(Vector3));
		args.GetVector3(2, default(Vector3));
		GetEntitiesInBounds(new Bounds(vector, vector2), list);
		StringBuilder stringBuilder = new StringBuilder();
		if (list.Count == 0)
		{
			stringBuilder.AppendLine("Empty");
		}
		else
		{
			foreach (BaseEntity item in list)
			{
				if (!item.isClient)
				{
					stringBuilder.AppendLine(((Object)item).name);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		args.ReplyWith(stringBuilder.ToString());
	}

	private static string GetLegacyServerDirectory()
	{
		return ConVar.Server.GetServerFolder("copypaste");
	}

	private static string GetLegacyServerPath(string name)
	{
		return GetLegacyServerDirectory() + "/" + name + ".data";
	}

	[ServerVar]
	public static void download_paste(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Missing args: download_paste <name>");
			return;
		}
		string @string = arg.GetString(0, "");
		string legacyServerPath = GetLegacyServerPath(arg.GetString(0, ""));
		if (!File.Exists(legacyServerPath))
		{
			arg.ReplyWith("Paste '" + @string + "' not found");
			return;
		}
		CopyPasteEntityInfo val = CopyPasteEntityInfo.Deserialize(File.ReadAllBytes(legacyServerPath));
		try
		{
			CopyPasteEntity.ServerInstance.ClientRPC(RpcTarget.Player("RecievePaste", arg.Connection), @string, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void list_pastes_sv(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		PrintPasteNames(stringBuilder, GetLegacyServerDirectory());
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void killbox_sv(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = args.GetVector3(0, default(Vector3));
		Vector3 vector2 = args.GetVector3(1, default(Vector3));
		PasteOptions options = new PasteOptions(args);
		Bounds bounds = new Bounds(vector, vector2);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		GetEntitiesInBounds(bounds, list);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient && CanPrefabBePasted(item.prefabID, options) && (!(item is BasePlayer entity) || entity.IsNpcPlayer()))
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static Quaternion GetPlayerRotation(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ply.eyes.BodyForward();
		val.y = 0f;
		return Quaternion.LookRotation(val, Vector3.up);
	}
}


using ProtoBuf;
using UnityEngine;

private class EntityWrapper
{
	public BaseEntity Entity;

	public Entity Protobuf;

	public Vector3 Position;

	public Quaternion Rotation;

	public bool HasParent;
}


using ProtoBuf;
using UnityEngine;

public class PasteOptions
{
	public const string Argument_NPCs = "--npcs";

	public const string Argument_Resources = "--resources";

	public const string Argument_Vehicles = "--vehicles";

	public const string Argument_Deployables = "--deployables";

	public const string Argument_FoundationsOnly = "--foundations-only";

	public const string Argument_BuildingBlocksOnly = "--building-only";

	public const string Argument_SnapToTerrain = "--autosnap-terrain";

	public const string Argument_SnapToZeroHeight = "--autosnap-zero";

	public const string Argument_PastePlayers = "--players";

	public bool Resources;

	public bool NPCs;

	public bool Vehicles;

	public bool Deployables;

	public bool FoundationsOnly;

	public bool BuildingBlocksOnly;

	public bool SnapToTerrain;

	public bool SnapToZero;

	public bool Players;

	public Vector3 Origin;

	public Quaternion PlayerRotation;

	public Vector3 HeightOffset;

	public PasteOptions(Arg arg)
	{
		Resources = arg.HasArg("--resources", true);
		NPCs = arg.HasArg("--npcs", true);
		Vehicles = arg.HasArg("--vehicles", true);
		Deployables = arg.HasArg("--deployables", true);
		FoundationsOnly = arg.HasArg("--foundations-only", true);
		BuildingBlocksOnly = arg.HasArg("--building-only", true);
		SnapToTerrain = arg.HasArg("--autosnap-terrain", true);
		SnapToZero = arg.HasArg("--autosnap-zero", true);
		Players = arg.HasArg("--players", true);
	}

	public PasteOptions(PasteRequest request)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		Resources = request.resources;
		NPCs = request.npcs;
		Vehicles = request.vehicles;
		Deployables = request.deployables;
		FoundationsOnly = request.foundationsOnly;
		BuildingBlocksOnly = request.buildingBlocksOnly;
		SnapToTerrain = request.snapToTerrain;
		SnapToZero = request.snapToZero;
		Players = request.players;
		Origin = request.origin;
		PlayerRotation = Quaternion.Euler(request.playerRotation);
		HeightOffset = request.heightOffset;
	}

	public PasteOptions()
	{
	}
}


using System.Collections.Generic;

public class PasteResult
{
	public List<BaseEntity> Entities;

	public PasteResult(List<BaseEntity> entities)
	{
		Entities = entities;
	}
}


using System.Collections.Generic;
using System.Linq;
using ConVar;

public class CopyPasteHistoryManager
{
	public class PlayerHistory
	{
		public ulong SteamId;

		public List<PasteResult> History = new List<PasteResult>();

		public int CurrentIndex = -1;

		public PlayerHistory(ulong steamId)
		{
			SteamId = steamId;
		}
	}

	private List<PlayerHistory> playerHistory = new List<PlayerHistory>();

	public PlayerHistory GetOrCreateHistory(ulong steamId)
	{
		PlayerHistory playerHistory = this.playerHistory.FirstOrDefault((PlayerHistory x) => x.SteamId == steamId);
		if (playerHistory == null)
		{
			playerHistory = new PlayerHistory(steamId);
			this.playerHistory.Add(playerHistory);
		}
		return playerHistory;
	}

	public void AddToHistory(ulong steamId, List<BaseEntity> entities)
	{
		PlayerHistory orCreateHistory = GetOrCreateHistory(steamId);
		int num = orCreateHistory.History.Count - orCreateHistory.CurrentIndex - 1;
		if (num > 0)
		{
			orCreateHistory.History.RemoveRange(orCreateHistory.CurrentIndex + 1, num);
		}
		orCreateHistory.History.Add(new PasteResult(entities));
		orCreateHistory.CurrentIndex = orCreateHistory.History.Count - 1;
	}

	public PasteResult Undo(ulong steamId)
	{
		PlayerHistory orCreateHistory = GetOrCreateHistory(steamId);
		if (orCreateHistory.CurrentIndex < 0)
		{
			return null;
		}
		orCreateHistory.CurrentIndex--;
		return orCreateHistory.History[orCreateHistory.CurrentIndex + 1];
	}
}


using System.Collections.Generic;

public class PlayerHistory
{
	public ulong SteamId;

	public List<PasteResult> History = new List<PasteResult>();

	public int CurrentIndex = -1;

	public PlayerHistory(ulong steamId)
	{
		SteamId = steamId;
	}
}


using UnityEngine;

[Factory("craft")]
public class Craft : ConsoleSystem
{
	[ServerVar]
	public static bool instant;

	[ServerUserVar]
	public static void add(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || basePlayer.IsDead())
		{
			return;
		}
		int @int = args.GetInt(0, 0);
		int int2 = args.GetInt(1, 1);
		int num = (int)args.GetUInt64(2, 0uL);
		bool @bool = args.GetBool(3, false);
		if (int2 < 1)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(@int);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			args.ReplyWith("Item not found");
			return;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
		if (!Object.op_Implicit((Object)(object)itemBlueprint))
		{
			args.ReplyWith("Blueprint not found");
			return;
		}
		if (!itemBlueprint.userCraftable)
		{
			args.ReplyWith("Item is not craftable");
			return;
		}
		if (!basePlayer.blueprints.CanCraft(@int, num, basePlayer.userID))
		{
			num = 0;
			if (!basePlayer.blueprints.CanCraft(@int, num, basePlayer.userID))
			{
				args.ReplyWith("You can't craft this item");
				return;
			}
			args.ReplyWith("You don't have permission to use this skin, so crafting unskinned");
		}
		int num2 = int2;
		int num3 = int2;
		if (@bool)
		{
			num2 = Mathf.Min(int2, 5);
			num3 = 1;
		}
		for (int num4 = num2; num4 >= num3; num4--)
		{
			if (basePlayer.inventory.crafting.CraftItem(itemBlueprint, basePlayer, null, num4, num))
			{
				return;
			}
		}
		args.ReplyWith("Couldn't craft!");
	}

	[ServerUserVar]
	public static void canceltask(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			if (!basePlayer.inventory.crafting.CancelTask(@int))
			{
				args.ReplyWith("Couldn't cancel task!");
			}
		}
	}

	[ServerUserVar]
	public static void cancel(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			basePlayer.inventory.crafting.CancelBlueprint(@int);
		}
	}

	[ServerUserVar]
	public static void fasttracktask(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			if (!basePlayer.inventory.crafting.FastTrackTask(@int))
			{
				args.ReplyWith("Couldn't fast track task!");
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class Creative : ConsoleSystem
{
	[ReplicatedVar(Help = "Apply creative mode to the entire server", Saved = true)]
	public static bool allUsers;

	[ServerVar(Saved = true)]
	public static bool alwaysOnEnabled;

	[ReplicatedVar(Help = "Bypass the 30s repair cooldown when repairing objects", Saved = true)]
	public static bool freeRepair;

	[ReplicatedVar(Help = "Build blocks for free", Saved = true)]
	public static bool freeBuild;

	[ReplicatedVar(Help = "Bypasses all placement checks", Saved = true)]
	public static bool freePlacement;

	[ReplicatedVar(Help = "Bypasses bypassHoldToPlaceDuration when deploying items", Saved = true)]
	public static bool bypassHoldToPlaceDuration;

	[ReplicatedVar(Help = "Bypasses limits on IO length and points", Saved = true)]
	public static bool unlimitedIo;

	[ServerVar]
	public static void toggleCreativeModeUser(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		bool @bool = arg.GetBool(1, false);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Invalid player provided " + arg.GetString(0, ""));
			return;
		}
		player.SetPlayerFlag(BasePlayer.PlayerFlags.CreativeMode, @bool);
		arg.ReplyWith($"{player.displayName} creative mode: {@bool}");
	}

	[ServerVar]
	public static void toggleAlwaysOnAll(Arg arg)
	{
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInCreativeMode)
		{
			return;
		}
		bool @bool = arg.GetBool(0, false);
		BaseCombatEntity[] array = BaseEntity.Util.FindAll<BaseCombatEntity>();
		foreach (BaseCombatEntity baseCombatEntity in array)
		{
			if (!baseCombatEntity.isClient && baseCombatEntity is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
	}

	[ServerUserVar(ServerAdmin = true)]
	public static void toggleAlwaysOnRadius(Arg arg)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInCreativeMode)
		{
			return;
		}
		bool @bool = arg.GetBool(0, false);
		float radius = Mathf.Clamp(arg.GetFloat(1, 0f), 0f, 100f);
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		Vis.Entities(((Component)basePlayer).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseCombatEntity item in list)
		{
			if (!item.isClient && item is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
	}

	[ServerUserVar(ServerAdmin = true)]
	public static void toggleAlwaysOn(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsInCreativeMode)
		{
			bool @bool = arg.GetBool(0, false);
			RaycastHit hit = default(RaycastHit);
			if (Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1) && hit.GetEntity() is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
	}
}


[Factory("culling")]
public class Culling : ConsoleSystem
{
}


using System.IO;
using UnityEngine;

[Factory("data")]
public class Data : ConsoleSystem
{
	[ServerVar]
	[ClientVar]
	public static void export(Arg args)
	{
		string @string = args.GetString(0, "none");
		string text = Path.Combine(Application.persistentDataPath, @string + ".raw");
		switch (@string)
		{
		case "splatmap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap))
			{
				RawWriter.Write(TerrainMeta.SplatMap.ToEnumerable(), text);
			}
			break;
		case "heightmap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				RawWriter.Write(TerrainMeta.HeightMap.ToEnumerable(), text);
			}
			break;
		case "biomemap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
			{
				RawWriter.Write(TerrainMeta.BiomeMap.ToEnumerable(), text);
			}
			break;
		case "topologymap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
			{
				RawWriter.Write(TerrainMeta.TopologyMap.ToEnumerable(), text);
			}
			break;
		case "alphamap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap))
			{
				RawWriter.Write(TerrainMeta.AlphaMap.ToEnumerable(), text);
			}
			break;
		case "watermap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap))
			{
				RawWriter.Write(TerrainMeta.WaterMap.ToEnumerable(), text);
			}
			break;
		default:
			args.ReplyWith("Unknown export source: " + @string);
			return;
		}
		args.ReplyWith("Export written to " + text);
	}
}


using System.Linq;
using UnityEngine;

public class DDraw
{
	[ServerVar]
	public static void ddrawother(Arg arg)
	{
		arg.GetULong(0, 0uL);
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null || !player.IsConnected)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		if (arg.Args.Length < 2)
		{
			arg.ReplyWith("Usage: ddrawother <player> <ddraw.text arguments>");
			return;
		}
		string command = ConsoleSystem.BuildCommand("ddraw.text", new object[1] { arg.Args.Skip(1) });
		player.SendConsoleCommand(command);
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Unity;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using UnityEngine;

[ResetStaticFields]
[Factory("debug")]
public class Debugging : ConsoleSystem
{
	private const string NO_RECOVER_ARG = "--no-recover";

	[ClientVar]
	[ServerVar]
	public static bool checktriggers = false;

	[ServerVar]
	public static bool checkparentingtriggers = true;

	[ClientVar(Saved = false, Help = "Shows some debug info for dismount attempts.")]
	[ServerVar]
	public static bool DebugDismounts = false;

	[ServerVar(Help = "Shows debug info for what objects are causing clipping checks to fail.")]
	public static bool DebugClippingChecks = false;

	[ServerVar(Help = "Do not damage any items")]
	public static bool disablecondition = false;

	[ServerVar]
	public static int tutorial_start_cooldown = 60;

	[ServerVar]
	public static bool printMissionSpeakInfo = false;

	[ServerVar]
	public static float puzzleResetTimeMultiplier = 1f;

	[ServerVar(Help = "Whether to parent players immediately on spawning to a boat if the bag is on a boat")]
	public static bool bag_respawn_parenting = true;

	[ServerVar]
	public static bool disableLootNavObstaclesInDeepSea = true;

	[ClientVar]
	[ServerVar]
	public static bool callbacks = false;

	[ServerVar]
	[ClientVar]
	public static bool log
	{
		get
		{
			return Debug.unityLogger.logEnabled;
		}
		set
		{
			if (!value)
			{
				Debug.Log((object)"Logging disabled");
			}
			Debug.unityLogger.logEnabled = value;
			if (value)
			{
				Debug.Log((object)"Logging enabled");
			}
		}
	}

	[ClientVar(ClientAdmin = true)]
	[ServerVar]
	public static void renderinfo(Arg arg)
	{
		RenderInfo.GenerateReport();
	}

	[ServerVar]
	public static void enable_player_movement(Arg arg)
	{
		if (arg.IsAdmin)
		{
			bool @bool = arg.GetBool(0, true);
			BasePlayer basePlayer = arg.Player();
			if ((Object)(object)basePlayer == (Object)null)
			{
				arg.ReplyWith("Must be called from client with player model");
				return;
			}
			basePlayer.ClientRPC(RpcTarget.Player("TogglePlayerMovement", basePlayer), @bool);
			arg.ReplyWith((@bool ? "enabled" : "disabled") + " player movement");
		}
	}

	[ServerVar]
	public static void console_spam(Arg arg)
	{
		int num = Mathf.Clamp(arg.GetInt(0, 100), 1, 100000);
		int @int = arg.GetInt(1, 50);
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		for (int i = 0; i < num; i++)
		{
			Debug.Log((object)new string((char)(97 + i % 26), @int));
		}
		stopwatch.Stop();
		Debug.Log((object)$"Took {stopwatch.ElapsedMilliseconds}ms to log {num} lines");
	}

	[ServerVar]
	public static void console_print_color(Arg arg)
	{
		string @string = arg.GetString(0, "This is a test colored message");
		int @int = arg.GetInt(1, 2);
		ServerConsole.PrintColoured(@string, (ConsoleColor)@int);
	}

	[ServerVar]
	[ClientVar]
	public static void stall(Arg arg)
	{
		float num = Mathf.Clamp(arg.GetFloat(0, 0f), 0f, 1f);
		arg.ReplyWith("Stalling for " + num + " seconds...");
		Thread.Sleep(Mathf.RoundToInt(num * 1000f));
	}

	[ServerVar(Help = "Repair all items in inventory")]
	public static void repair_inventory(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		basePlayer.inventory.GetAllItems(list);
		foreach (Item item in list)
		{
			if (item != null)
			{
				item.maxCondition = item.info.condition.max;
				item.condition = item.maxCondition;
				item.MarkDirty();
			}
			if (item.contents == null)
			{
				continue;
			}
			foreach (Item item2 in item.contents.itemList)
			{
				item2.maxCondition = item2.info.condition.max;
				item2.condition = item2.maxCondition;
				item2.MarkDirty();
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	[ServerVar]
	public static void spawnParachuteTester(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, 50f);
		BasePlayer basePlayer = arg.Player();
		BasePlayer basePlayer2 = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", ((Component)basePlayer).transform.position + Vector3.up * @float, Quaternion.LookRotation(basePlayer.eyes.BodyForward())) as BasePlayer;
		basePlayer2.Spawn();
		basePlayer2.eyes.rotation = basePlayer.eyes.rotation;
		basePlayer2.SendNetworkUpdate();
		Inventory.copyTo(basePlayer, basePlayer2);
		if (!basePlayer2.HasValidParachuteEquipped())
		{
			basePlayer2.inventory.containerWear.GiveItem(ItemManager.CreateByName("parachute", 1, 0uL));
		}
		basePlayer2.RequestParachuteDeploy();
	}

	[ServerVar]
	public static string testTutorialCinematic(Arg arg)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInTutorial)
		{
			return "Requires a player";
		}
		TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland == (Object)null)
		{
			return "Invalid island";
		}
		Transform val = TransformEx.FindChildRecursive(((Component)currentTutorialIsland).transform, "KayakMissionPoint");
		if ((Object)(object)val == (Object)null)
		{
			return "Can't find KayakMissionPoint on island";
		}
		Kayak obj = GameManager.server.CreateEntity("assets/content/vehicles/boats/kayak/kayak.prefab", val.position, val.rotation) as Kayak;
		obj.Spawn();
		obj.WantsMount(basePlayer);
		currentTutorialIsland.StartEndingCinematic(basePlayer);
		return "Playing cinematic";
	}

	[ServerVar(Help = "If a player ends up stuck on a tutorial for any reason this will clear the island and reset the player (will also kill player)")]
	public static void clearTutorialForPlayer(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Please provide a player");
		}
		else if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.Return();
			}
			player.ClearTutorial();
			player.Hurt(99999f);
			player.ClearTutorial_PostDeath();
		}
	}

	[ServerVar(Help = "<shortname> (optional: <radius>) - Delete entities with the given short prefab name")]
	public static void deleteEntitiesByShortname(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		string text = arg.GetString(0, "").ToLower();
		float @float = arg.GetFloat(1, 0f);
		BasePlayer basePlayer = arg.Player();
		PooledList<BaseNetworkable> val = Pool.Get<PooledList<BaseNetworkable>>();
		try
		{
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BaseNetworkable current = enumerator.Current;
					if (current.ShortPrefabName == text && (@float == 0f || ((Object)(object)basePlayer != (Object)null && basePlayer.Distance(current as BaseEntity) <= @float)))
					{
						((List<BaseNetworkable>)(object)val).Add(current);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			if (((ICollection<BaseNetworkable>)val).IsEmpty())
			{
				arg.ReplyWith("Did not find any " + text);
				return;
			}
			arg.ReplyWith($"Deleting {((List<BaseNetworkable>)(object)val).Count} {text}");
			foreach (BaseNetworkable item in (List<BaseNetworkable>)(object)val)
			{
				item.Kill();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Delete entities by id. Supports multiple arguments")]
	public static void deleteEntityById(Arg arg)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < arg.Args.Length; i++)
		{
			NetworkableId entityID = arg.GetEntityID(i);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
			if ((Object)(object)baseNetworkable != (Object)null)
			{
				stringBuilder.AppendLine($"Deleting {baseNetworkable}");
				baseNetworkable.Kill();
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void printgroups(Arg arg)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Server");
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				Debug.Log((object)string.Format("{0}:{1}{2}", current.PrefabName, current.net.group.ID, current.net.group.restricted ? "/Restricted" : string.Empty));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Takes you in and out of your current network group, causing you to delete and then download all entities in your PVS again")]
	public static void flushgroup(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.net.SwitchGroup(BaseNetworkable.LimboNetworkGroup);
			basePlayer.UpdateNetworkGroup();
		}
	}

	[ServerVar(Help = "Break the current held object")]
	public static void breakheld(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		activeItem?.LoseCondition(activeItem.condition * 2f);
	}

	[ServerVar(Help = "Breaks the currently held shield")]
	public static void breakshield(Arg arg)
	{
		if (arg.Player().GetActiveShield(out var foundShield) && foundShield.GetItem() != null)
		{
			foundShield.GetItem().LoseCondition(999f);
		}
	}

	[ServerVar(Help = "Almost break the current held object")]
	public static void breakheld_almost(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		if (activeItem != null && activeItem.hasCondition)
		{
			activeItem.condition = 1f;
		}
	}

	[ServerVar(Help = "Reset all puzzles. Optionally provide a number to only reset puzzles within a radius.")]
	public static void puzzlereset(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		Enumerator<PuzzleReset> enumerator = PuzzleReset.AllResets.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				PuzzleReset current = enumerator.Current;
				BasePlayer basePlayer = arg.Player();
				if ((Object)(object)basePlayer != (Object)null)
				{
					string[] args = arg.Args;
					if (args != null && args.Length != 0)
					{
						int @int = arg.GetInt(0, int.MaxValue);
						if (Vector3.Distance(((Component)current).transform.position, ((Component)basePlayer).transform.position) > (float)@int)
						{
							continue;
						}
					}
				}
				stringBuilder.AppendLine($"Resetting puzzle at: {((Component)current).transform.position}");
				current.DoReset();
				current.ResetTimer();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(EditorOnly = true, Help = "respawn all puzzles from their prefabs")]
	public static void puzzleprefabrespawn(Arg arg)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		foreach (BaseNetworkable item in BaseNetworkable.serverEntities.Where((BaseNetworkable x) => x is IOEntity && PrefabAttribute.server.Find<Construction>(x.prefabID) == null).ToList())
		{
			item.Kill();
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			GameObject val = GameManager.server.FindPrefab(((Object)((Component)monument).gameObject).name);
			if ((Object)(object)val == (Object)null)
			{
				continue;
			}
			Dictionary<IOEntity, IOEntity> dictionary = new Dictionary<IOEntity, IOEntity>();
			IOEntity[] componentsInChildren = val.GetComponentsInChildren<IOEntity>(true);
			foreach (IOEntity iOEntity in componentsInChildren)
			{
				Quaternion rot = ((Component)monument).transform.rotation * ((Component)iOEntity).transform.rotation;
				Vector3 pos = ((Component)monument).transform.TransformPoint(((Component)iOEntity).transform.position);
				BaseEntity newEntity = GameManager.server.CreateEntity(iOEntity.PrefabName, pos, rot);
				IOEntity iOEntity2 = newEntity as IOEntity;
				if (!((Object)(object)iOEntity2 != (Object)null))
				{
					continue;
				}
				dictionary.Add(iOEntity, iOEntity2);
				DoorManipulator doorManipulator = newEntity as DoorManipulator;
				if ((Object)(object)doorManipulator != (Object)null)
				{
					List<Door> list = Pool.Get<List<Door>>();
					Vis.Entities(((Component)newEntity).transform.position, 10f, list, -1, (QueryTriggerInteraction)2);
					Door door = list.OrderBy((Door x) => x.Distance(((Component)newEntity).transform.position)).FirstOrDefault();
					if ((Object)(object)door != (Object)null)
					{
						doorManipulator.targetDoor = door;
					}
					Pool.FreeUnmanaged<Door>(ref list);
				}
				CardReader cardReader = newEntity as CardReader;
				if ((Object)(object)cardReader != (Object)null)
				{
					CardReader cardReader2 = iOEntity as CardReader;
					if ((Object)(object)cardReader2 != (Object)null)
					{
						cardReader.accessLevel = cardReader2.accessLevel;
						cardReader.accessDuration = cardReader2.accessDuration;
					}
				}
				TimerSwitch timerSwitch = newEntity as TimerSwitch;
				if ((Object)(object)timerSwitch != (Object)null)
				{
					TimerSwitch timerSwitch2 = iOEntity as TimerSwitch;
					if ((Object)(object)timerSwitch2 != (Object)null)
					{
						timerSwitch.timerLength = timerSwitch2.timerLength;
					}
				}
			}
			foreach (KeyValuePair<IOEntity, IOEntity> item2 in dictionary)
			{
				IOEntity key = item2.Key;
				IOEntity value = item2.Value;
				for (int j = 0; j < key.outputs.Length; j++)
				{
					if (!((Object)(object)key.outputs[j].connectedTo.ioEnt == (Object)null))
					{
						value.outputs[j].connectedTo.ioEnt = dictionary[key.outputs[j].connectedTo.ioEnt];
						value.outputs[j].connectedToSlot = key.outputs[j].connectedToSlot;
					}
				}
			}
			foreach (IOEntity value2 in dictionary.Values)
			{
				value2.Spawn();
			}
		}
	}

	[ServerVar(Help = "Break all the items in your inventory whose name match the passed string")]
	public static void breakitem(Arg arg)
	{
		string @string = arg.GetString(0, "");
		foreach (Item item in arg.Player().inventory.containerMain.itemList)
		{
			if (StringEx.Contains(item.info.shortname, @string, CompareOptions.IgnoreCase) && item.hasCondition)
			{
				item.LoseCondition(item.condition * 2f);
			}
		}
	}

	[ServerVar(ClientAdmin = true, Help = "Refills the vital of a target player. eg. debug.refillsvital jim - leave blank to target yourself, can take multiple players at once. Will revive players if they are injured. To disable this, pass in --no-recover as the first argument.")]
	public static void refillvitals(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int num = 0;
		bool shouldPlayerRecover = true;
		if (arg.GetString(0, "") == "--no-recover")
		{
			shouldPlayerRecover = false;
			num++;
		}
		arg.TryRemoveKeyBindEventArgs();
		if (arg.Args == null || num >= arg.Args.Length)
		{
			RefillPlayerVitals(basePlayer, shouldPlayerRecover);
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = num; i < arg.Args.Length; i++)
		{
			string @string = arg.GetString(i, "");
			BasePlayer basePlayer2 = ((!(@string == basePlayer.displayName)) ? (string.IsNullOrEmpty(@string) ? null : arg.GetPlayerOrSleeperOrBot(i)) : basePlayer);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				stringBuilder.AppendLine("Could not find player '" + @string + "'");
				continue;
			}
			RefillPlayerVitals(basePlayer2, shouldPlayerRecover);
			stringBuilder.AppendLine("Refilled '" + @string + "' vitals");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(ClientAdmin = true, Help = "Refills the vitals of all active players on the server. Will revive players if they are injured. To disable this, pass in --no-recover as the first argument.")]
	public static void refillvitalsall(Arg arg)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		bool shouldPlayerRecover = arg.GetString(0, "") != "--no-recover";
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					RefillPlayerVitals(current, shouldPlayerRecover);
					stringBuilder.AppendLine("Refilled player '" + current.displayName + "' vitals");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (!((Object)(object)current2 == (Object)null))
				{
					RefillPlayerVitals(current2, shouldPlayerRecover);
					stringBuilder.AppendLine("Refilled bot '" + current2.displayName + "' vitals");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void RefillPlayerVitals(BasePlayer player, bool shouldPlayerRecover)
	{
		if (shouldPlayerRecover && player.IsWounded())
		{
			player.StopWounded();
		}
		AdjustHealth(player, 1000f);
		AdjustCalories(player, 1000f);
		AdjustHydration(player, 1000f);
		AdjustRadiation(player, -10000f);
		AdjustBleeding(player, -10000f);
	}

	[ServerVar(Help = "To disable revival if player is downed, pass in --no-recover as the first argument.")]
	public static void heal(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		bool flag = true;
		int num = 0;
		if (arg.GetString(0, "") == "--no-recover")
		{
			flag = false;
			num++;
		}
		if (flag && basePlayer.IsWounded())
		{
			basePlayer.StopWounded();
		}
		AdjustHealth(basePlayer, arg.GetInt(num, 1));
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		int @int = arg.GetInt(0, 1);
		string @string = arg.GetString(1, string.Empty);
		HitInfo hitInfo = new HitInfo(basePlayer, basePlayer, DamageType.Bullet, @int);
		if (!string.IsNullOrEmpty(@string))
		{
			hitInfo.HitBone = StringPool.Get(@string);
		}
		basePlayer.OnAttacked(hitInfo);
	}

	[ServerVar]
	public static void eat(Arg arg)
	{
		AdjustCalories(arg.Player(), arg.GetInt(0, 1), arg.GetInt(1, 1));
	}

	[ServerVar]
	public static void drink(Arg arg)
	{
		AdjustHydration(arg.Player(), arg.GetInt(0, 1), arg.GetInt(1, 1));
	}

	[ServerVar]
	public static void sethealth(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.SetHealth(@int);
		}
	}

	[ServerVar]
	public static void setmaxhealth(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if ((Object)(object)usePlayer == (Object)null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		usePlayer.OverrideMaxHealth(@int);
		if (@int <= 0)
		{
			arg.ReplyWith("Reset max health");
		}
		else
		{
			arg.ReplyWith($"Set max health to {@int}");
		}
	}

	[ServerVar]
	public static void setdamage(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			float damageAmount = usePlayer.health - (float)@int;
			HitInfo info = new HitInfo(basePlayer, basePlayer, DamageType.Bullet, damageAmount);
			usePlayer.OnAttacked(info);
		}
	}

	[ServerVar]
	public static void setfood(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Calories);
	}

	[ServerVar]
	public static void setwater(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Hydration);
	}

	[ServerVar]
	public static void setradiation(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Radiation);
	}

	private static void AdjustHealth(BasePlayer player, float amount, string bone = null)
	{
		player.health += amount;
	}

	private static void AdjustCalories(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.ApplyChange(MetabolismAttribute.Type.Calories, amount, time);
	}

	private static void AdjustHydration(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.ApplyChange(MetabolismAttribute.Type.Hydration, amount, time);
	}

	private static void AdjustRadiation(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.SetAttribute(MetabolismAttribute.Type.Radiation, amount);
	}

	private static void AdjustBleeding(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.SetAttribute(MetabolismAttribute.Type.Bleeding, amount);
	}

	private static void setattribute(Arg arg, MetabolismAttribute.Type type)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.metabolism.SetAttribute(type, @int);
		}
	}

	private static BasePlayer GetUsePlayer(Arg arg, int playerArgument)
	{
		BasePlayer basePlayer = null;
		if (arg.HasArgs(playerArgument + 1))
		{
			BasePlayer player = arg.GetPlayer(playerArgument);
			if (!Object.op_Implicit((Object)(object)player))
			{
				return null;
			}
			return player;
		}
		return arg.Player();
	}

	[ServerVar]
	public static void ResetSleepingBagTimers(Arg arg)
	{
		SleepingBag.ResetTimersForPlayer(arg.Player());
	}

	[ServerVar(Help = "Deducts the given number of hours from all spoilable food on the server")]
	public static void FoodSpoilingDeductTimeHours(Arg arg)
	{
		ItemModFoodSpoiling.DeductTimeFromAll(TimeSpan.FromHours(arg.GetFloat(0, 0f)));
	}

	[ServerVar(Help = "Spoils all food on the server")]
	public static void FoodSpoilingSpoilAll()
	{
		ItemModFoodSpoiling.DeductTimeFromAll(TimeSpan.MaxValue);
	}

	[ServerVar(Help = "Applies the given number of hours to all food in the players inventory")]
	public static void FoodSpoilingInventoryHours(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		PooledList<Item> spoilList = Pool.Get<PooledList<Item>>();
		try
		{
			FindSpoilableItems(basePlayer.inventory.containerMain.itemList);
			FindSpoilableItems(basePlayer.inventory.containerBelt.itemList);
			foreach (Item item in (List<Item>)(object)spoilList)
			{
				ItemModFoodSpoiling.FoodSpoilingWorkQueue.DeductTimeFromFoodItem(item, (float)@int * 60f * 60f, setDirty: true);
			}
		}
		finally
		{
			if (spoilList != null)
			{
				((IDisposable)spoilList).Dispose();
			}
		}
		void FindSpoilableItems(List<Item> items)
		{
			ItemModFoodSpoiling itemModFoodSpoiling = default(ItemModFoodSpoiling);
			foreach (Item item2 in items)
			{
				if (((Component)item2.info).TryGetComponent<ItemModFoodSpoiling>(ref itemModFoodSpoiling))
				{
					((List<Item>)(object)spoilList).Add(item2);
				}
			}
		}
	}

	[ServerVar]
	public static void ForceChickensSpawnEgg(Arg arg)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, 50f);
		if ((Object)(object)arg.Player() == (Object)null)
		{
			return;
		}
		PooledList<Chicken> val = Pool.Get<PooledList<Chicken>>();
		try
		{
			Vis.Entities(((Component)arg.Player()).transform.position, @float, (List<Chicken>)(object)val, 2048, (QueryTriggerInteraction)2);
			foreach (Chicken item in (List<Chicken>)(object)val)
			{
				if (item.isServer)
				{
					item.SpawnEgg();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void dropWorldItems(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(arg.GetString(1, ""));
		Ray val = basePlayer.eyes.HeadRay();
		Vector3 val2 = ((Ray)(ref val)).GetPoint(1f);
		if (!((Object)(object)itemDefinition == (Object)null))
		{
			for (int i = 0; i < @int; i++)
			{
				ItemManager.Create(itemDefinition, 1, 0uL).Drop(val2, Vector3.zero, Quaternion.identity);
				val2 += Vector3.up * 0.3f;
			}
		}
	}

	[ServerVar(Help = "Spawns one of every deployable in a grid")]
	public static void spawn_all_deployables(Arg arg)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper))
		{
			arg.ReplyWith("Must be called by admin player");
			return;
		}
		arg.ReplyWith("Spawning all deployables");
		bool stability = ConVar.Server.stability;
		ConVar.Server.stability = false;
		try
		{
			Vector3 position = ((Component)basePlayer).transform.position;
			List<ItemModDeployable> list = (from x in ItemManager.itemList
				select ((Component)x).GetComponent<ItemModDeployable>() into x
				where (Object)(object)x != (Object)null
				select x).ToList();
			int num = 12;
			float num2 = Mathf.Ceil(Mathf.Sqrt((float)list.Count));
			float num3 = num2 * (float)num / 2f;
			Vector3 pos = default(Vector3);
			for (int i = 0; i < list.Count; i++)
			{
				((Vector3)(ref pos))..ctor(position.x - num3 + (float)num * ((float)i % num2), position.y, position.z - num3 + (float)num * Mathf.Floor((float)i / num2));
				GameManager.server.CreateEntity(list[i].entityPrefab.resourcePath, pos)?.Spawn();
			}
		}
		finally
		{
			ConVar.Server.stability = stability;
		}
	}

	[ServerVar]
	public static void removeOverlappingStaticSpawnPoints(Arg arg)
	{
		PooledList<StaticRespawnArea> val = Pool.Get<PooledList<StaticRespawnArea>>();
		try
		{
			foreach (StaticRespawnArea staticRespawnArea2 in StaticRespawnArea.staticRespawnAreas)
			{
				((List<StaticRespawnArea>)(object)val).Add(staticRespawnArea2);
			}
			int num = 0;
			for (int i = 0; i < ((List<StaticRespawnArea>)(object)val).Count; i++)
			{
				StaticRespawnArea staticRespawnArea = ((List<StaticRespawnArea>)(object)val)[i];
				bool flag = false;
				foreach (StaticRespawnArea item in (List<StaticRespawnArea>)(object)val)
				{
					if ((Object)(object)item != (Object)(object)staticRespawnArea && item.Distance((BaseEntity)staticRespawnArea) < 1f)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					((List<StaticRespawnArea>)(object)val).RemoveAt(i);
					i--;
					num++;
					staticRespawnArea.Kill();
				}
			}
			arg.ReplyWith($"Destroyed {num} overlapping static spawn points");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void setUnloadableCarFillPercent(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)basePlayer).transform.position;
		PooledList<TrainCarUnloadable> val = Pool.Get<PooledList<TrainCarUnloadable>>();
		try
		{
			Vis.Entities(position, 3f, (List<TrainCarUnloadable>)(object)val, 8192, (QueryTriggerInteraction)2);
			float num = Mathf.Clamp01(arg.GetFloat(0, 0f));
			foreach (TrainCarUnloadable item in (List<TrainCarUnloadable>)(object)val)
			{
				if (!item.isServer)
				{
					continue;
				}
				foreach (Item item2 in item.GetStorageContainer().inventory.itemList)
				{
					item2.amount = Mathf.Max(Mathf.RoundToInt(num), 1);
				}
				item.SetLootPercentage(num);
				item.SetVisualOreLevel(num);
				item.SendNetworkUpdate();
				arg.ReplyWith($"Set ore level to {num} on {item.PrefabName}");
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "fillmounts <radius> - Spawns and mounts a player on every mount point in radius")]
	public static void fillmounts(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)basePlayer).transform.position;
		int num = Mathf.Clamp(arg.GetInt(0, 0), 0, 100);
		int layerMask = 1218519297;
		PooledList<BaseMountable> val = Pool.Get<PooledList<BaseMountable>>();
		try
		{
			Vis.Entities(position, num, (List<BaseMountable>)(object)val, layerMask, (QueryTriggerInteraction)2);
			foreach (BaseMountable item in (List<BaseMountable>)(object)val)
			{
				if (!item.isServer)
				{
					continue;
				}
				if (item is BaseVehicle { allMountPoints: var allMountPoints })
				{
					foreach (BaseVehicle.MountPointInfo item2 in allMountPoints)
					{
						if (item2 != null && (Object)(object)item2.mountable != (Object)null && !item2.mountable.AnyMounted())
						{
							SpawnAndMountPlayer(item2.mountable, arg);
						}
					}
				}
				else if (!item.AnyMounted())
				{
					SpawnAndMountPlayer(item, arg);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void SpawnAndMountPlayer(BaseMountable mountable, Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab") as BasePlayer;
		basePlayer.Spawn();
		mountable.AttemptMount(basePlayer, doMountChecks: false);
		if (!basePlayer.isMounted)
		{
			arg.ReplyWith("Failed to mount: " + mountable.ShortPrefabName);
			basePlayer.Kill();
		}
	}

	[ServerVar(Help = "Spawn lots of IO entities to lag the server")]
	public static void bench_io(Arg arg)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		int @int = arg.GetInt(0, 50);
		string name = arg.GetString(1, "water_catcher_small");
		List<IOEntity> list = new List<IOEntity>();
		WaterCatcher waterCatcher = null;
		Vector3 position = ((Component)arg.Player()).transform.position;
		string[] array = (from x in GameManifest.Current.entities
			where StringEx.Contains(Path.GetFileNameWithoutExtension(x), name, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (array.Length == 0)
		{
			arg.ReplyWith("Couldn't find io prefab \"" + array[0] + "\"");
			return;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(Path.GetFileNameWithoutExtension(x), name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				Debug.Log((object)$"{arg} failed to find io entity \"{name}\"");
				arg.ReplyWith("Unknown entity - could be:\n\n" + string.Join("\n", array.Select(Path.GetFileNameWithoutExtension).ToArray()));
				return;
			}
			array[0] = text;
		}
		for (int i = 0; i < @int; i++)
		{
			Vector3 pos = position + new Vector3((float)(i * 5), 0f, 0f);
			Quaternion identity = Quaternion.identity;
			BaseEntity baseEntity = GameManager.server.CreateEntity(array[0], pos, identity);
			if (!Object.op_Implicit((Object)(object)baseEntity))
			{
				continue;
			}
			baseEntity.Spawn();
			WaterCatcher component = ((Component)baseEntity).GetComponent<WaterCatcher>();
			if (Object.op_Implicit((Object)(object)component))
			{
				list.Add(component);
				if ((Object)(object)waterCatcher != (Object)null)
				{
					Connect(waterCatcher, component);
				}
				if (i == @int - 1)
				{
					Connect(component, list.First());
				}
				waterCatcher = component;
			}
		}
		static void Connect(IOEntity InputIOEnt, IOEntity OutputIOEnt)
		{
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			int num2 = 0;
			WireTool.WireColour wireColour = WireTool.WireColour.Gray;
			IOEntity.IOSlot iOSlot = InputIOEnt.inputs[num];
			IOEntity.IOSlot obj = OutputIOEnt.outputs[num2];
			iOSlot.connectedTo.Set(OutputIOEnt);
			iOSlot.connectedToSlot = num2;
			iOSlot.wireColour = wireColour;
			iOSlot.connectedTo.Init();
			obj.connectedTo.Set(InputIOEnt);
			obj.connectedToSlot = num;
			obj.wireColour = wireColour;
			obj.connectedTo.Init();
			obj.linePoints = (Vector3[])(object)new Vector3[2]
			{
				Vector3.zero,
				((Component)OutputIOEnt).transform.InverseTransformPoint(((Component)InputIOEnt).transform.TransformPoint(iOSlot.handlePosition))
			};
			OutputIOEnt.MarkDirtyForceUpdateOutputs();
			OutputIOEnt.SendNetworkUpdate();
			InputIOEnt.SendNetworkUpdate();
			OutputIOEnt.SendChangedToRoot(forceUpdate: true);
		}
	}

	[ServerVar]
	[Help("Arg0: mission stage (int), Arg1: block objective resetting (bool, default false)")]
	public static void completeMissionStage(Arg arg)
	{
		int @int = arg.GetInt(0, -1);
		bool @bool = arg.GetBool(1, false);
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.TryGetActiveMissionInstance(out var instance))
		{
			return;
		}
		for (int i = 0; i < instance.objectiveStatuses.Count; i++)
		{
			BaseMission.MissionInstance.ObjectiveStatus objectiveStatus = instance.objectiveStatuses[i];
			if (!objectiveStatus.completed && (i == @int || (@int == -1 && !objectiveStatus.completed)))
			{
				MissionObjective missionObjective = instance.GetMission().objectives[i].Get();
				missionObjective.ServerObjectiveStarted(basePlayer, i, instance);
				missionObjective.CompleteObjective(i, instance, basePlayer);
				if (@bool)
				{
					objectiveStatus.blockReset = true;
				}
				break;
			}
		}
	}

	[ServerVar]
	public static void completeMission(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer != (Object)null) || !basePlayer.TryGetActiveMissionInstance(out var instance))
		{
			return;
		}
		for (int i = 0; i < instance.objectiveStatuses.Count; i++)
		{
			if (!instance.objectiveStatuses[i].completed)
			{
				instance.GetMission().objectives[i].objective.CompleteObjective(i, instance, basePlayer);
			}
		}
	}

	[ServerVar(Help = "Prints out the topologies at your position")]
	public static void print_topologies(Arg arg)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Expected I4, but got Unknown
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		StringBuilder stringBuilder = Pool.Get<StringBuilder>();
		int topology = TerrainMeta.TopologyMap.GetTopology(((Component)basePlayer).transform.position);
		foreach (Enum value in Enum.GetValues(typeof(Enum)))
		{
			Enum val = value;
			int num = (int)val;
			if ((topology & num) == num)
			{
				stringBuilder.AppendLine(((object)(Enum)(ref val)/*cast due to .constrained prefix*/).ToString());
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
		Pool.FreeUnmanaged(ref stringBuilder);
	}

	[ServerUserVar]
	public static void startTutorial(Arg arg)
	{
		if (!ConVar.Server.tutorialEnabled)
		{
			arg.ReplyWith("Tutorial is not enabled on this server");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsInTutorial)
		{
			basePlayer.StartTutorial(triggerAnalytics: false);
		}
	}

	[ServerVar]
	public static void completeTutorial(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: false, triggerAnalytics: false);
			}
		}
	}

	[ServerUserVar(ServerAdmin = false)]
	public static void quitTutorial(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: true, triggerAnalytics: true);
			}
		}
	}

	[ServerVar]
	public static void tutorialStatus(Arg arg)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		ListHashSet<TutorialIsland> tutorialList = TutorialIsland.GetTutorialList(isServer: true);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[5] { "Index", "ID", "Player Name", "Duration", "IsConnected" });
			int num = 0;
			Enumerator<TutorialIsland> enumerator = tutorialList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					TutorialIsland current = enumerator.Current;
					BasePlayer basePlayer = current.ForPlayer.Get(serverside: true);
					val.AddRow(new string[5]
					{
						num++.ToString(),
						(current.net.group.ID - 1).ToString(),
						((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : "NULL",
						current.TutorialDuration.ToShortString(),
						((Object)(object)basePlayer != (Object)null) ? basePlayer.IsConnected.ToString() : "NULL"
					});
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"Tutorial islands in use: {num}/{TutorialIsland.MaxTutorialIslandCount}");
			stringBuilder.AppendLine(((object)val).ToString());
			arg.ReplyWith(stringBuilder.ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Make admin invisible")]
	public static void invis(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		bool @bool = arg.GetBool(0, !basePlayer.isInvisible);
		if (@bool && !basePlayer.isInvisible)
		{
			if (Interface.CallHook("OnPlayerVanish", (object)basePlayer) != null)
			{
				return;
			}
			foreach (Connection subscriber in basePlayer.net.group.subscribers)
			{
				BasePlayer basePlayer2 = subscriber.player as BasePlayer;
				if (subscriber != basePlayer.net.connection && basePlayer.ShouldNetworkTo(basePlayer2) && !basePlayer2.IsSpectating())
				{
					basePlayer.DestroyOnClient(subscriber);
				}
			}
			if (ServerOcclusion.OcclusionEnabled && BasePlayer.UseOcclusionV2)
			{
				basePlayer.OcclusionMakeSubscribersForget();
			}
			basePlayer.isInvisible = true;
			BasePlayer.invisPlayers.Add(basePlayer);
			basePlayer.DisablePlayerCollider();
			SimpleAIMemory.AddIgnorePlayer(basePlayer);
			BaseEntity.Query.Server.RemovePlayer(basePlayer);
			Interface.CallHook("OnPlayerVanished", (object)basePlayer);
		}
		else if (!@bool && basePlayer.isInvisible)
		{
			if (Interface.CallHook("OnPlayerUnvanish", (object)basePlayer) != null)
			{
				return;
			}
			basePlayer.isInvisible = false;
			BasePlayer.invisPlayers.Remove(basePlayer);
			basePlayer.EnablePlayerCollider();
			if (!ServerOcclusion.OcclusionEnabled || !BasePlayer.UseOcclusionV2)
			{
				foreach (Connection subscriber2 in basePlayer.net.group.subscribers)
				{
					BasePlayer player = subscriber2.player as BasePlayer;
					if (basePlayer.ShouldNetworkTo(player))
					{
						basePlayer.SendAsSnapshotWithChildren(player);
					}
				}
			}
			SimpleAIMemory.RemoveIgnorePlayer(basePlayer);
			BaseEntity.Query.Server.RemovePlayer(basePlayer);
			BaseEntity.Query.Server.AddPlayer(basePlayer);
			Interface.CallHook("OnPlayerUnvanished", (object)basePlayer);
		}
		arg.ReplyWith("Invis: " + basePlayer.isInvisible);
		basePlayer.Command("debug.setinvis_ui", basePlayer.isInvisible);
	}

	[ServerVar]
	public static void clearPlayerModifiers(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			int count = basePlayer.modifiers.All.Count;
			basePlayer.modifiers.RemoveAll();
			arg.ReplyWith($"Removed {count} modifiers");
		}
	}

	[ServerVar]
	public static void applyBuildingBlockRandomisation(Arg arg)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		int @int = arg.GetInt(0, 0);
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0f, out var hitInfo, 3f, 2097408, (QueryTriggerInteraction)0) && hitInfo.GetEntity() is SimpleBuildingBlock simpleBuildingBlock)
		{
			simpleBuildingBlock.SetVariant(@int);
		}
	}

	[ServerVar]
	public static void vineSwingingReport(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is VineSwingingTree)
				{
					num++;
				}
				if (current is VineMountable vineMountable)
				{
					num2++;
					num3 += vineMountable.DestinationCount;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Entity", "Count" });
			val.AddRow(new string[2]
			{
				"VineTrees",
				num.ToString()
			});
			val.AddRow(new string[2]
			{
				"VineMountables",
				num2.ToString()
			});
			val.AddRow(new string[2]
			{
				"VineMountableDirections",
				((float)num3 / (float)num2).ToString()
			});
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void vineSwingingHighlight(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is VineMountable vineMountable)
				{
					vineMountable.Highlight(arg.Player());
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void respawnVineTreesInRadius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			GamePhysics.OverlapSphere(((Component)basePlayer).transform.position, @float, (List<Collider>)(object)val, 1073741824, (QueryTriggerInteraction)1);
			int num = 0;
			int num2 = 0;
			PooledList<VineSwingingTreeStump> val2 = Pool.Get<PooledList<VineSwingingTreeStump>>();
			try
			{
				foreach (Collider item in (List<Collider>)(object)val)
				{
					VineSwingingTreeStump vineSwingingTreeStump = item.ToBaseEntity() as VineSwingingTreeStump;
					if ((Object)(object)vineSwingingTreeStump != (Object)null && vineSwingingTreeStump.isServer && !((List<VineSwingingTreeStump>)(object)val2).Contains(vineSwingingTreeStump))
					{
						((List<VineSwingingTreeStump>)(object)val2).Add(vineSwingingTreeStump);
						if (vineSwingingTreeStump.RespawnTree())
						{
							num++;
						}
						else
						{
							num2++;
						}
					}
				}
				arg.ReplyWith($"Respawned {num} trees in {@float}m, {num2} were blocked by players");
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void conveyorStrictModeReport(Arg arg)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		IndustrialConveyor[] array = BaseEntity.Util.FindAll<IndustrialConveyor>();
		foreach (IndustrialConveyor industrialConveyor in array)
		{
			if (industrialConveyor.strictMode)
			{
				stringBuilder.AppendLine($"{((Component)industrialConveyor).transform.position}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void test_custom_vitals(Arg arg)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Expected O, but got Unknown
		int num = Mathf.Clamp(arg.GetInt(0, 1), 0, 100);
		int @int = arg.GetInt(1, 60);
		string @string = arg.GetString(2, "ss");
		CustomVitals val = new CustomVitals
		{
			vitals = new List<CustomVitalInfo>()
		};
		for (int i = 0; i < num; i++)
		{
			val.vitals.Add(new CustomVitalInfo
			{
				active = true,
				backgroundColor = Color.red,
				iconColor = Color.green,
				leftTextColor = Color.blue,
				rightTextColor = Color.yellow,
				leftText = "Left",
				rightText = "Right {timeleft:" + @string + "}",
				timeLeft = @int
			});
		}
		CommunityEntity.ServerInstance.SendCustomVitals(arg.Player(), val);
	}

	[ServerVar(Help = "0 = can't throw, 1 = can throw & melee, 2 = only throwable")]
	public static void setthrowable(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("This can only be ran by players");
			return;
		}
		BaseMelee baseMelee = basePlayer.GetHeldEntity() as BaseMelee;
		if ((Object)(object)baseMelee == (Object)null)
		{
			arg.ReplyWith("You must be holding a melee weapon");
			return;
		}
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'setthrowable {0-2}");
			return;
		}
		int @int = arg.GetInt(0, 0);
		switch (@int)
		{
		case 0:
			baseMelee.canThrowAsProjectile = false;
			baseMelee.onlyThrowAsProjectile = false;
			break;
		case 1:
			baseMelee.canThrowAsProjectile = true;
			baseMelee.onlyThrowAsProjectile = false;
			break;
		case 2:
			baseMelee.canThrowAsProjectile = true;
			baseMelee.onlyThrowAsProjectile = true;
			break;
		default:
			arg.ReplyWith($"Invalid throwable value {@int}, must be 0 (not throwable), 1 (throwable) or 2 (only throwable)");
			return;
		}
		baseMelee.SendNetworkUpdate();
		arg.ReplyWith($"Set canThrowAsProjectile to {@int} on {baseMelee.ShortPrefabName}");
	}

	[ServerVar]
	public static void applyPuzzleResetTime(Arg arg)
	{
		float @float = arg.GetFloat(0, 0f);
		PuzzleReset[] array = Object.FindObjectsByType<PuzzleReset>((FindObjectsSortMode)0);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].DebugApplyPuzzleResetTime(@float);
		}
	}

	[ServerVar]
	public static void puzzleResetInfo(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer bp = arg.Player();
		Enumerator<PuzzleReset> enumerator = PuzzleReset.AllResets.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				PuzzleReset current = enumerator.Current;
				if (!current.IsPlayerInRange(bp))
				{
					continue;
				}
				List<string> list = new List<string>();
				current.GetDebugInfo(list);
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.AppendLine(((Component)current).transform.GetRecursiveName());
				foreach (string item in list)
				{
					stringBuilder.AppendLine(item);
				}
				arg.ReplyWith(stringBuilder.ToString());
				return;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith("Player is not inside any PuzzleResets");
	}

	[ServerVar]
	public static void spawnOvenStressTest(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)arg.Player()).transform.position;
		for (int i = 0; i < 100; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				Vector3 pos = position + new Vector3((float)i * 1f, 0f, (float)j * 1f);
				BaseOven baseOven = GameManager.server.CreateEntity("Assets/Prefabs/Deployable/Furnace/furnace.prefab", pos, Quaternion.identity) as BaseOven;
				baseOven.Spawn();
				ItemManager.CreateByName("wood", 1000, 0uL).MoveToContainer(baseOven.inventory, 0);
				ItemManager.CreateByName("metal.ore", 1000, 0uL).MoveToContainer(baseOven.inventory, baseOven.fuelSlots);
				baseOven.StartCooking();
			}
		}
	}

	[ClientVar(ClientAdmin = true)]
	[ServerVar]
	public static void printqueues(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[4] { "Name", "Processed", "Size", "Execution Time" });
			foreach (ObjectWorkQueue item in ObjectWorkQueue.All.OrderBy((ObjectWorkQueue x) => x.Name))
			{
				string text = ((item.TotalExecutionTime.TotalMilliseconds < 1000.0) ? $"{Math.Floor(item.TotalExecutionTime.TotalMilliseconds)}ms" : $"{Math.Round(item.TotalExecutionTime.TotalSeconds, 2)}s");
				val.AddRow(new string[4]
				{
					item.Name,
					item.TotalProcessedCount.ToString(),
					item.QueueLength.ToString(),
					text
				});
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


[Factory("decay")]
public class Decay : ConsoleSystem
{
	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static bool upgrade_wood_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to stone")]
	public static bool upgrade_stone_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to metal")]
	public static bool upgrade_metal_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to hqm")]
	public static bool upgrade_hqm_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static float build_twig_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static float upgrade_wood_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to stone")]
	public static float upgrade_stone_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to metal")]
	public static float upgrade_metal_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to hqm")]
	public static float upgrade_hqm_cost_multiplier = 1f;

	[ServerVar(Help = "Maximum distance to test to see if a structure is outside, higher values are slower but accurate for huge buildings")]
	public static float outside_test_range = 50f;

	[ServerVar]
	public static float tick = 600f;

	[ServerVar]
	public static float scale = 1f;

	[ServerVar]
	public static bool debug = false;

	[ServerVar(Help = "Is upkeep enabled")]
	public static bool upkeep = true;

	[ServerVar(Help = "How many minutes does the upkeep cost last? default : 1440 (24 hours)")]
	public static float upkeep_period_minutes = 1440f;

	[ServerVar(Help = "How many minutes can the upkeep cost last after the cupboard was destroyed? default : 1440 (24 hours)")]
	public static float upkeep_grief_protection = 1440f;

	[ServerVar(Help = "Scale at which objects heal when upkeep conditions are met, default of 1 is same rate at which they decay")]
	public static float upkeep_heal_scale = 1f;

	[ServerVar(Help = "Scale at which objects decay when they are inside, default of 0.1")]
	public static float upkeep_inside_decay_scale = 0.1f;

	[ServerVar(Help = "When set to a value above 0 everything will decay with this delay")]
	public static float delay_override = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_twig = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_wood = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_stone = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_metal = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_toptier = 0f;

	[ServerVar(Help = "When set to a value above 0 everything will decay with this duration")]
	public static float duration_override = 0f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_twig = 1f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_wood = 3f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_stone = 5f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_metal = 8f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_toptier = 12f;

	public const int UpkeepBracketCount = 4;

	[ServerVar(Help = "Number of blocks in the 1st upkeep bracket")]
	public static int bracket_0_blockcount = 15;

	[ServerVar(Help = "Blocks in the 1st upkeep bracket will cost this value per day to maintain")]
	public static float bracket_0_costfraction = 0.1f;

	[ServerVar(Help = "Number of blocks in the 2nd upkeep bracket")]
	public static int bracket_1_blockcount = 50;

	[ServerVar(Help = "Blocks in the 2nd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_1_costfraction = 0.15f;

	[ServerVar(Help = "The number of blocks in the 3rd upkeep bracket")]
	public static int bracket_2_blockcount = 125;

	[ServerVar(Help = "Blocks in the 3rd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_2_costfraction = 0.2f;

	[ServerVar(Help = "Blocks in the 4th upkeep bracket will cost this value per day to maintain")]
	public static float bracket_3_costfraction = 0.333f;

	[ServerVar(Help = "Should doors have their own upkeep brackets separate from building blocks")]
	public static bool use_door_upkeep_brackets = false;

	[ServerVar(Help = "Number of doors in the 1st upkeep bracket")]
	public static int bracket_0_doorcount = 15;

	[ServerVar(Help = "Doors in the 1st upkeep bracket will cost this value per day to maintain")]
	public static float bracket_0_doorfraction = 0.1f;

	[ServerVar(Help = "Number of doors in the 2nd upkeep bracket")]
	public static int bracket_1_doorcount = 50;

	[ServerVar(Help = "Doors in the 2nd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_1_doorfraction = 0.15f;

	[ServerVar(Help = "The number of doors in the 3rd upkeep bracket")]
	public static int bracket_2_doorcount = 125;

	[ServerVar(Help = "Doors in the 3rd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_2_doorfraction = 0.2f;

	[ServerVar(Help = "Doors in the 4th upkeep bracket will cost this value per day to maintain")]
	public static float bracket_3_doorfraction = 0.333f;

	public static float GetCostMultiplier(BuildingGrade.Enum grade)
	{
		return grade switch
		{
			BuildingGrade.Enum.Twigs => build_twig_cost_multiplier, 
			BuildingGrade.Enum.Wood => upgrade_wood_cost_multiplier, 
			BuildingGrade.Enum.Stone => upgrade_stone_cost_multiplier, 
			BuildingGrade.Enum.Metal => upgrade_metal_cost_multiplier, 
			BuildingGrade.Enum.TopTier => upgrade_hqm_cost_multiplier, 
			_ => 1f, 
		};
	}

	public static bool CanUpgradeToGrade(BuildingGrade.Enum grade)
	{
		return grade switch
		{
			BuildingGrade.Enum.Twigs => true, 
			BuildingGrade.Enum.Wood => upgrade_wood_enabled, 
			BuildingGrade.Enum.Stone => upgrade_stone_enabled, 
			BuildingGrade.Enum.Metal => upgrade_metal_enabled, 
			BuildingGrade.Enum.TopTier => upgrade_hqm_enabled, 
			_ => true, 
		};
	}
}


[Factory("decor")]
public class Decor : ConsoleSystem
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using UnityEngine;

public class DeepSea : ConsoleSystem
{
	[ClientVar]
	public static float mainisland_billboard_scale = 1f;

	[ClientVar]
	public static float islands_billboard_scale = 1f;

	[ReplicatedVar]
	public static bool block_building = true;

	[ServerVar]
	public static bool debug_portal_spawnattempts = false;

	[ServerVar]
	public static bool portals_use_whitelist = true;

	[ServerVar]
	public static float island_portal_terrain_distance = 750f;

	private static bool _enabled = true;

	[ServerVar]
	public static bool logs = false;

	[ServerVar]
	public static bool boat_drift_deep_sea = false;

	[ServerVar]
	public static int floatingcity_count = 1;

	[ServerVar]
	public static float floatingcity_radius = 500f;

	[ServerVar]
	public static float floatingcity_edgeMargin = 1500f;

	[ServerVar]
	public static float floatingcity_minDist = 1500f;

	[ServerVar]
	public static int island_count = 6;

	[ServerVar]
	public static float island_radius = 300f;

	[ServerVar]
	public static float island_edgeMargin = 750f;

	[ServerVar]
	public static float island_minDist = 600f;

	[ServerVar]
	public static int ghostship_count = 4;

	[ServerVar]
	public static float ghostship_radius = 80f;

	[ServerVar]
	public static float ghostship_edgeMargin = 450f;

	[ServerVar]
	public static float ghostship_minDist = 400f;

	[ServerVar]
	public static int rhib_count = 4;

	[ServerVar]
	public static float rhib_radius = 10f;

	[ServerVar]
	public static float rhib_edgeMargin = 1150f;

	[ServerVar]
	public static float rhib_minDist = 300f;

	[ServerVar]
	public static int hackablecrate_count = 1;

	[ReplicatedVar(Help = "0 Map-based, 1 North, 2 East, 3 South, 4 West ")]
	public static int forceEntrancePortalDirection = 0;

	[ReplicatedVar(Help = "Duration in seconds of the deep sea wipe")]
	public static float wipeDuration = 10800f;

	[ReplicatedVar(Help = "Seconds before a deep sea re-opens after closing")]
	public static float wipeCooldown = 5400f;

	[ReplicatedVar(Help = "Duration in seconds of the final wipe phase, bad weather kicking in etc")]
	public static float wipeEndPhaseDuration = 1800f;

	[ReplicatedVar(Help = "Seconds before radiation starts to ramp in before the deep sea wipe")]
	public static float wipeRadiationPhaseDuration = 300f;

	[ServerVar(Help = "Toggles the deep sea. Needs a server restart to take effect. Any saved deep sea entities will be destroyed at the next startup")]
	public static bool enabled
	{
		get
		{
			return _enabled;
		}
		set
		{
			_enabled = value;
		}
	}

	[ServerVar]
	public static void enterdeepsea(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active, run deepsea.createdeepsea first");
			return;
		}
		BasePlayer player = arg.Player();
		PointEntity<DeepSeaManager>.ServerInstance.MoveToDeepSea(GetEntityToTeleport(player));
	}

	[ServerVar]
	public static void leavedeepsea(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active, run deepsea.createdeepsea first");
			return;
		}
		BaseEntity entityToTeleport = GetEntityToTeleport(arg.Player());
		if (entityToTeleport is BasePlayer && entityToTeleport.HasParent())
		{
			entityToTeleport.SetParent(null, worldPositionStays: true);
		}
		PointEntity<DeepSeaManager>.ServerInstance.MoveToMainIsland(entityToTeleport);
	}

	[ServerVar]
	public static void createdeepsea(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Can't create deep sea, its disabled. Run deepsea.enabled true first");
			return;
		}
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null)
		{
			arg.ReplyWith("Killing existing deep sea manager");
			PointEntity<DeepSeaManager>.ServerInstance.Kill();
		}
		SingletonComponent<ServerMgr>.Instance.CreateDeepSea();
		arg.ReplyWith("Deep sea manager entity created");
	}

	[ServerVar]
	public static void testportalspawnlocation(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active, run deepsea.createdeepsea first");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		Vector3 position = ((Component)basePlayer).transform.position;
		float @float = arg.GetFloat(0, 25f);
		float float2 = arg.GetFloat(1, 10f);
		bool flag = PointEntity<DeepSeaManager>.ServerInstance.IsValidPortalSpawnLocation(((Component)basePlayer).transform.position, @float, basePlayer);
		basePlayer.SendConsoleCommand(DDrawCommand.Sphere(position, float2, flag ? Color.green : Color.red, @float, distanceFade: false));
	}

	private static BaseEntity GetEntityToTeleport(BasePlayer player)
	{
		if (player.isMounted)
		{
			BaseVehicle mountedVehicle = player.GetMountedVehicle();
			if ((Object)(object)mountedVehicle != (Object)null)
			{
				return mountedVehicle;
			}
		}
		BaseEntity parentEntity = player.GetParentEntity();
		if ((Object)(object)parentEntity != (Object)null)
		{
			if (parentEntity is BaseVehicle)
			{
				return parentEntity;
			}
			if (parentEntity is SmallRamp || parentEntity is Plank || parentEntity is BaseLadder)
			{
				PlayerBoat playerBoat = parentEntity.GetParentEntity() as PlayerBoat;
				if ((Object)(object)playerBoat != (Object)null)
				{
					return playerBoat;
				}
			}
		}
		return player;
	}

	[ServerVar]
	public static void spawnislandhere(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = Vector3Ex.WithY(((Component)arg.Player()).transform.position, 0f);
		GameObjectRef random = PointEntity<DeepSeaManager>.ServerInstance.islandRefs.GetRandom();
		PointEntity<DeepSeaManager>.ServerInstance.SpawnEntityAt(random.resourcePath, position, Quaternion.identity);
	}

	[ServerVar]
	public static void spawnghostshiphere(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = Vector3Ex.WithY(((Component)arg.Player()).transform.position, 0f);
		GameObjectRef random = PointEntity<DeepSeaManager>.ServerInstance.ghostShipRefs.GetRandom();
		PointEntity<DeepSeaManager>.ServerInstance.SpawnEntityAt(random.resourcePath, position, Quaternion.identity);
	}

	[ServerVar]
	public static void spawnfloatingcityhere(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = Vector3Ex.WithY(((Component)arg.Player()).transform.position, 0f);
		GameObjectRef random = PointEntity<DeepSeaManager>.ServerInstance.floatingCityRefs.GetRandom();
		PointEntity<DeepSeaManager>.ServerInstance.SpawnEntityAt(random.resourcePath, position, Quaternion.identity);
	}

	[ServerVar]
	public static void spawnrhibgrouphere(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.WithY(((Component)arg.Player()).transform.position, 0f);
		Vector3 val2 = new Vector3(val.x, 0f, val.y);
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null)
		{
			val2 = ((Bounds)(ref DeepSeaManager.DeepSeaBounds)).center - new Vector3(val.x, 0f, val.y);
			normalized = ((Vector3)(ref val2)).normalized;
		}
		Quaternion rot = Quaternion.LookRotation(normalized);
		BoatAI.SpawnBoatGroup(new Vector2(val.x, val.z), rot, null, registerWithDeepSea: true);
	}

	[ServerVar]
	public static void close(Arg arg)
	{
		DeepSeaManager serverInstance = PointEntity<DeepSeaManager>.ServerInstance;
		if ((Object)(object)serverInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active");
		}
		else if ((Object)(object)serverInstance != (Object)null)
		{
			if (serverInstance.IsBusy())
			{
				arg.ReplyWith("Deep sea is busy (opening or closing)");
				return;
			}
			if (!serverInstance.IsOpen())
			{
				arg.ReplyWith("Deep sea already closed");
				return;
			}
			serverInstance.CloseDeepSea();
			arg.ReplyWith("Closing deep sea...");
		}
	}

	[ServerVar]
	public static void open(Arg arg)
	{
		DeepSeaManager serverInstance = PointEntity<DeepSeaManager>.ServerInstance;
		if ((Object)(object)serverInstance != (Object)null)
		{
			if (serverInstance.IsBusy())
			{
				arg.ReplyWith("Deep sea is busy (opening or closing)");
				return;
			}
			if (serverInstance.IsOpen())
			{
				arg.ReplyWith("Deep sea already opened");
				return;
			}
			serverInstance.OpenDeepSea();
			arg.ReplyWith("Opening deep sea...");
		}
	}

	[ServerVar]
	public static void printState(Arg arg)
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		DeepSeaManager serverInstance = PointEntity<DeepSeaManager>.ServerInstance;
		if ((Object)(object)serverInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active, run deepsea.createdeepsea first");
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Open: {serverInstance.IsOpen()}");
		stringBuilder.AppendLine($"Busy: {serverInstance.IsBusy()}");
		stringBuilder.AppendLine($"TimeToNextOpening: {serverInstance.TimeToNextOpening}");
		stringBuilder.AppendLine($"TimeToWipe: {serverInstance.TimeToWipe}");
		stringBuilder.AppendLine($"Portal Direction: {serverInstance.EntrancePortalDirection}");
		stringBuilder.AppendLine($"Radiations: {serverInstance.GetWipeRadiationAmount()}");
		stringBuilder.AppendLine("Portals:");
		foreach (DeepSeaPortal serverPortal in DeepSeaManager.ServerPortals)
		{
			stringBuilder.AppendLine($"    {serverPortal.PortalMode} {((Object)serverPortal).name} {((Component)serverPortal).transform.position}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void settimetowipe(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null)
		{
			float @float = arg.GetFloat(0, 0f);
			PointEntity<DeepSeaManager>.ServerInstance.SetTimeToWipe(@float);
			arg.ReplyWith($"Time to wipe set to {@float} seconds");
		}
	}

	[ServerVar]
	public static void settimetonextopening(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null)
		{
			float @float = arg.GetFloat(0, 0f);
			PointEntity<DeepSeaManager>.ServerInstance.SetTimeToNextOpening(@float);
			arg.ReplyWith($"Time to next opening set to {@float} seconds");
		}
	}

	[ServerVar]
	public static void printtimetowipe(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance != (Object)null)
		{
			arg.ReplyWith((object)PointEntity<DeepSeaManager>.ServerInstance.GetTimeToWipe());
		}
	}

	[ServerVar]
	public static void printentitycount(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active");
			return;
		}
		HashSet<BaseEntity> hashSet = Pool.Get<HashSet<BaseEntity>>();
		PointEntity<DeepSeaManager>.ServerInstance.GetAllDeepSeaEntities(hashSet, skipParented: false);
		int count = hashSet.Count;
		int num = hashSet.OfType<BasePlayer>().Count((BasePlayer p) => !p.IsNpc);
		int num2 = hashSet.Count((BaseEntity e) => e.IsNpc);
		int num3 = hashSet.Count((BaseEntity x) => x is BaseVehicle);
		int num4 = hashSet.Count((BaseEntity x) => x is TreeEntity);
		int num5 = hashSet.Count((BaseEntity x) => x is MetalDetectorSource);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Category", "Count" });
			val.AddRow(new string[2]
			{
				"Total Entities",
				count.ToString()
			});
			val.AddRow(new string[2]
			{
				"Islands",
				DeepSeaManager.ServerIslands.Count.ToString()
			});
			val.AddRow(new string[2]
			{
				"Ghost Ships",
				DeepSeaManager.ServerGhostShips.Count.ToString()
			});
			val.AddRow(new string[2]
			{
				"Floating Cities",
				DeepSeaManager.ServerFloatingCities.Count.ToString()
			});
			val.AddRow(new string[2]
			{
				"Trees",
				num4.ToString()
			});
			val.AddRow(new string[2]
			{
				"Players",
				num.ToString()
			});
			val.AddRow(new string[2]
			{
				"Metal Detector Sources",
				num5.ToString()
			});
			IOrderedEnumerable<IGrouping<string, BaseEntity>> orderedEnumerable = from x in hashSet
				where x is BaseVehicle
				group x by (!string.IsNullOrEmpty(x.ShortPrefabName)) ? x.ShortPrefabName : "unknown" into g
				orderby g.Count() descending
				select g;
			val.AddRow(new string[2]
			{
				"Vehicles",
				num3.ToString()
			});
			foreach (IGrouping<string, BaseEntity> item in orderedEnumerable)
			{
				val.AddRow(new string[2]
				{
					"  " + item.Key,
					item.Count().ToString()
				});
			}
			IOrderedEnumerable<IGrouping<string, BaseEntity>> orderedEnumerable2 = from x in hashSet
				where x.IsNpc
				group x by (!string.IsNullOrEmpty(x.ShortPrefabName)) ? x.ShortPrefabName : "unknown" into g
				orderby g.Count() descending
				select g;
			val.AddRow(new string[2]
			{
				"NPC",
				num2.ToString()
			});
			foreach (IGrouping<string, BaseEntity> item2 in orderedEnumerable2)
			{
				val.AddRow(new string[2]
				{
					"  " + item2.Key,
					item2.Count().ToString()
				});
			}
			arg.ReplyWith(((object)val).ToString());
			Pool.FreeUnmanaged<BaseEntity>(ref hashSet);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void printloot(Arg arg)
	{
		if ((Object)(object)PointEntity<DeepSeaManager>.ServerInstance == (Object)null)
		{
			arg.ReplyWith("Deep sea not active");
			return;
		}
		HashSet<BaseEntity> hashSet = Pool.Get<HashSet<BaseEntity>>();
		PointEntity<DeepSeaManager>.ServerInstance.GetAllDeepSeaEntities(hashSet, skipParented: false);
		int num = hashSet.Count((BaseEntity x) => x is LootContainer);
		int num2 = hashSet.Count((BaseEntity x) => x is TreeEntity);
		int num3 = hashSet.Count((BaseEntity x) => x is OreResourceEntity);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Category", "Count" });
			IOrderedEnumerable<IGrouping<string, BaseEntity>> orderedEnumerable = from x in hashSet
				where x is LootContainer
				group x by (!string.IsNullOrEmpty(x.ShortPrefabName)) ? x.ShortPrefabName : "unknown" into g
				orderby g.Count() descending
				select g;
			val.AddRow(new string[2]
			{
				"Loot Containers",
				num.ToString()
			});
			foreach (IGrouping<string, BaseEntity> item in orderedEnumerable)
			{
				val.AddRow(new string[2]
				{
					"  " + item.Key,
					item.Count().ToString()
				});
			}
			val.AddRow(new string[2]
			{
				"Trees",
				num2.ToString()
			});
			val.AddRow(new string[2]
			{
				"Ores",
				num3.ToString()
			});
			arg.ReplyWith(((object)val).ToString());
			Pool.FreeUnmanaged<BaseEntity>(ref hashSet);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System.IO;
using Network;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

[Factory("demo")]
public class Demo : ConsoleSystem
{
	public class Header : DemoHeader, IDemoHeader
	{
		long IDemoHeader.Length
		{
			get
			{
				return base.length;
			}
			set
			{
				base.length = value;
			}
		}

		public void Write(BinaryWriter writer)
		{
			byte[] array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)this);
			writer.Write("RUST DEMO FORMAT");
			writer.Write(array.Length);
			writer.Write(array);
			writer.Write('\0');
		}
	}

	public static uint Version = 3u;

	[ServerVar]
	public static float splitseconds = 3600f;

	[ServerVar]
	public static float splitmegabytes = 200f;

	[ServerVar(Saved = true)]
	public static string recordlist = "";

	private static int _recordListModeValue = 0;

	[ServerVar(Name = "upload_demos", Saved = true)]
	public static bool UploadDemos
	{
		get
		{
			return DemoConVars.UploadDemos;
		}
		set
		{
			DemoConVars.UploadDemos = value;
		}
	}

	[ServerVar(Name = "upload_url", Saved = true)]
	public static string UploadUrl
	{
		get
		{
			return DemoConVars.UploadEndpoint;
		}
		set
		{
			DemoConVars.UploadEndpoint = value;
		}
	}

	[ServerVar(Name = "full_server_demo", Saved = true)]
	public static bool ServerDemosEnabled
	{
		get
		{
			return DemoConVars.ServerDemosEnabled;
		}
		set
		{
			DemoConVars.EnableServerDemos(value);
		}
	}

	[ServerVar(Name = "server_flush_seconds", Saved = true)]
	public static int ServerDemoFlushInterval
	{
		get
		{
			return DemoConVars.ServerDemoFlushIntervalSeconds;
		}
		set
		{
			DemoConVars.ServerDemoFlushIntervalSeconds = Mathf.Clamp(value, 60, 1800);
		}
	}

	[ServerVar(Name = "upload_bandwidth_limit_ratio")]
	public static float UploadBandwidthLimitRatio
	{
		get
		{
			return DemoConVars.BandwidthLimitRatio;
		}
		set
		{
			DemoConVars.BandwidthLimitRatio = value;
		}
	}

	[ServerVar(Name = "server_demo_directory", Help = "Directory to save full server demos")]
	public static string ServerDemoDirectory
	{
		get
		{
			return DemoConVars.ServerDemoDirectory;
		}
		set
		{
			DemoConVars.ServerDemoDirectory = value;
		}
	}

	[ServerVar(Name = "delete_after_upload", Saved = true, Help = "Should the full server demos be deleted after they are uploaded")]
	public static bool DeleteDemoAfterUpload
	{
		get
		{
			return DemoConVars.DeleteDemoAfterUpload;
		}
		set
		{
			DemoConVars.DeleteDemoAfterUpload = value;
		}
	}

	[ServerVar(Name = "zip_demos", Saved = true, Help = "Should we be zipping the demos before we upload them")]
	public static bool ZipServerDemos
	{
		get
		{
			return DemoConVars.ZipServerDemos;
		}
		set
		{
			DemoConVars.ZipServerDemos = value;
		}
	}

	[ServerVar(Name = "server_demo_disk_space_gb", Saved = true, Help = "How much disk space full server demos can take before we start to delete them")]
	public static int MaxDemoDiskSpaceGB
	{
		get
		{
			return DemoConVars.MaxDemoDiskSpaceGB;
		}
		set
		{
			DemoConVars.MaxDemoDiskSpaceGB = Mathf.Max(value, 0);
		}
	}

	[ServerVar(Name = "server_demo_cleanup_interval", Saved = true, Help = "How many minutes between cleaning up demos from the disk")]
	public static int DemoDiskCleanupIntervalMinutes
	{
		get
		{
			return DemoConVars.DiskCleanupIntervalMinutes;
		}
		set
		{
			DemoConVars.DiskCleanupIntervalMinutes = Mathf.Max(value, 1);
		}
	}

	[ServerVar(Name = "max_upload_concurrency", Help = "Max parallel requests when uploading demos")]
	public static int DemoUploadConcurrency
	{
		get
		{
			return DemoConVars.MaxUploadConcurrency;
		}
		set
		{
			DemoConVars.MaxUploadConcurrency = Mathf.Max(value, 1);
		}
	}

	[ServerVar(Saved = true, Help = "Controls the behavior of recordlist, 0=whitelist, 1=blacklist")]
	public static int recordlistmode
	{
		get
		{
			return _recordListModeValue;
		}
		set
		{
			_recordListModeValue = Mathf.Clamp(value, 0, 1);
		}
	}

	[ServerVar]
	public static string record(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			return "Player not found";
		}
		if (playerOrSleeper.net.connection.IsRecording)
		{
			return "Player already recording a demo";
		}
		playerOrSleeper.StartDemoRecording();
		return null;
	}

	[ServerVar]
	public static string stop(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			return "Player not found";
		}
		if (!playerOrSleeper.net.connection.IsRecording)
		{
			return "Player not recording a demo";
		}
		playerOrSleeper.StopDemoRecording();
		return null;
	}
}


using System.IO;
using Network;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Header : DemoHeader, IDemoHeader
{
	long IDemoHeader.Length
	{
		get
		{
			return base.length;
		}
		set
		{
			base.length = value;
		}
	}

	public void Write(BinaryWriter writer)
	{
		byte[] array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)this);
		writer.Write("RUST DEMO FORMAT");
		writer.Write(array.Length);
		writer.Write(array);
		writer.Write('\0');
	}
}


[Factory("editor")]
public class Editor : ConsoleSystem
{
}


[Factory("effects")]
public class Effects : ConsoleSystem
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using ConVar;
using Facepunch;
using UnityEngine;

[Factory("entity")]
public class Entity : ConsoleSystem
{
	private struct EntityInfo
	{
		public BaseNetworkable entity;

		public NetworkableId entityID;

		public uint groupID;

		public NetworkableId parentID;

		public string status;

		public EntityInfo(BaseNetworkable src)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			entity = src;
			BaseEntity baseEntity = entity as BaseEntity;
			BaseEntity baseEntity2 = (((Object)(object)baseEntity != (Object)null) ? baseEntity.GetParentEntity() : null);
			NetworkableId val;
			NetworkableId val2;
			if (!((Object)(object)entity != (Object)null) || entity.net == null)
			{
				val = default(NetworkableId);
				val2 = val;
			}
			else
			{
				val2 = entity.net.ID;
			}
			entityID = val2;
			groupID = (((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null) ? entity.net.group.ID : 0u);
			NetworkableId val3;
			if (!((Object)(object)baseEntity != (Object)null))
			{
				val = default(NetworkableId);
				val3 = val;
			}
			else
			{
				val3 = baseEntity.parentEntity.uid;
			}
			parentID = val3;
			if ((Object)(object)baseEntity != (Object)null)
			{
				val = baseEntity.parentEntity.uid;
				if (((NetworkableId)(ref val)).IsValid)
				{
					if ((Object)(object)baseEntity2 == (Object)null)
					{
						status = "orphan";
					}
					else
					{
						status = "child";
					}
					return;
				}
			}
			status = string.Empty;
		}
	}

	public struct EntitySpawnRequest
	{
		public string PrefabName;

		public string Error;

		public bool Valid => string.IsNullOrEmpty(Error);
	}

	private static void GetEntityTable(TextTable table, Func<EntityInfo, bool> filter)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		table.AddColumn("realm");
		table.AddColumn("entity");
		table.AddColumn("group");
		table.AddColumn("parent");
		table.AddColumn("name");
		table.AddColumn("position");
		table.AddColumn("local");
		table.AddColumn("rotation");
		table.AddColumn("local");
		table.AddColumn("status");
		table.AddColumn("invokes");
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					EntityInfo arg = new EntityInfo(current);
					if (filter(arg))
					{
						string[] obj = new string[11]
						{
							"sv",
							arg.entityID.Value.ToString(),
							arg.groupID.ToString(),
							arg.parentID.Value.ToString(),
							arg.entity.ShortPrefabName,
							null,
							null,
							null,
							null,
							null,
							null
						};
						Vector3 val = ((Component)arg.entity).transform.position;
						obj[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						val = ((Component)arg.entity).transform.localPosition;
						obj[6] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						Quaternion val2 = ((Component)arg.entity).transform.rotation;
						val = ((Quaternion)(ref val2)).eulerAngles;
						obj[7] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						val2 = ((Component)arg.entity).transform.localRotation;
						val = ((Quaternion)(ref val2)).eulerAngles;
						obj[8] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj[9] = arg.status;
						obj[10] = arg.entity.InvokeString();
						table.AddRow(obj);
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_entity(Arg args)
	{
		string filter = args.GetString(0, "");
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => string.IsNullOrEmpty(filter) || info.entity.PrefabName.Contains(filter));
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_id(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId filter = args.GetEntityID(0);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.entityID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_group(Arg args)
	{
		uint filter = args.GetUInt(0, 0u);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.groupID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_parent(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId filter = args.GetEntityID(0);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.parentID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_status(Arg args)
	{
		string filter = args.GetString(0, "");
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => string.IsNullOrEmpty(filter) || info.status.Contains(filter));
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_radius(Arg args)
	{
		BasePlayer player = args.Player();
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		uint filter = args.GetUInt(0, 10u);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => Vector3.Distance(((Component)info.entity).transform.position, ((Component)player).transform.position) <= (float)filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_self(Arg args)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null)
		{
			return;
		}
		NetworkableId filter = basePlayer.net.ID;
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.entityID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void debug_toggle(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId def = default(NetworkableId);
		NetworkableId entityID = args.GetEntityID(0, def);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, !baseEntity.IsDebugging());
			if (baseEntity.IsDebugging())
			{
				baseEntity.OnDebugStart();
			}
			def = baseEntity.net.ID;
			args.ReplyWith("Debugging for " + ((object)(NetworkableId)(ref def)/*cast due to .constrained prefix*/).ToString() + " " + (baseEntity.IsDebugging() ? "enabled" : "disabled"));
		}
	}

	[ServerVar]
	public static void nudge(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = args.GetEntityID(0);
		if (((NetworkableId)(ref entityID)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
			if (!((Object)(object)baseEntity == (Object)null))
			{
				((Component)baseEntity).BroadcastMessage("DebugNudge", (SendMessageOptions)1);
			}
		}
	}

	public static EntitySpawnRequest GetSpawnEntityFromName(string name)
	{
		EntitySpawnRequest result;
		if (string.IsNullOrEmpty(name))
		{
			result = default(EntitySpawnRequest);
			result.Error = "No entity name provided";
			return result;
		}
		string[] array = (from x in GameManifest.Current.entities
			where StringEx.Contains(Path.GetFileNameWithoutExtension(x), name, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (array.Length == 0)
		{
			result = default(EntitySpawnRequest);
			result.Error = "Entity type not found";
			return result;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(Path.GetFileNameWithoutExtension(x), name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				result = default(EntitySpawnRequest);
				result.Error = "Unknown entity - could be:\n\n" + string.Join("\n", array.Select(Path.GetFileNameWithoutExtension).ToArray());
				return result;
			}
			array[0] = text;
		}
		result = default(EntitySpawnRequest);
		result.PrefabName = array[0];
		return result;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawn(string name, Vector3 pos, Vector3 dir, int forceUp = 1)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer arg = ConsoleSystem.CurrentArgs.Player();
		EntitySpawnRequest spawnEntityFromName = GetSpawnEntityFromName(name);
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		bool flag = forceUp == 1;
		BaseEntity baseEntity = GameManager.server.CreateEntity(spawnEntityFromName.PrefabName, pos, flag ? Quaternion.LookRotation(dir, Vector3.up) : Quaternion.Euler(dir));
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.Log((object)$"{arg} failed to spawn \"{spawnEntityFromName.PrefabName}\" (tried to spawn \"{name}\")");
			return "Couldn't spawn " + name;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (flag)
			{
				Quaternion val = Quaternion.LookRotation(dir, Vector3.up);
				basePlayer.OverrideViewAngles(((Quaternion)(ref val)).eulerAngles);
			}
			else
			{
				basePlayer.OverrideViewAngles(dir);
			}
		}
		baseEntity.Spawn();
		EntityParentSettings entityParentSettings = default(EntityParentSettings);
		if (((Component)baseEntity).TryGetComponent<EntityParentSettings>(ref entityParentSettings))
		{
			entityParentSettings.TryDetachChildren(baseEntity);
		}
		baseEntity.UpdateNetworkGroup();
		Debug.Log((object)$"{arg} spawned \"{baseEntity}\" at {pos}");
		string? obj = ((object)baseEntity)?.ToString();
		Vector3 val2 = pos;
		return "spawned " + obj + " at " + ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
	}

	[ServerVar(Name = "spawnitem")]
	public static string svspawnitem(string name, Vector3 pos)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ConsoleSystem.CurrentArgs.Player();
		if (string.IsNullOrEmpty(name))
		{
			return "No entity name provided";
		}
		string[] array = (from x in ItemManager.itemList
			select x.shortname into x
			where StringEx.Contains(x, name, CompareOptions.IgnoreCase)
			select x).ToArray();
		if (array.Length == 0)
		{
			return "Entity type not found";
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(x, name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				Debug.Log((object)$"{basePlayer} failed to spawn \"{name}\"");
				return "Unknown entity - could be:\n\n" + string.Join("\n", array);
			}
			array[0] = text;
		}
		Item item = ItemManager.CreateByName(array[0], 1, 0uL);
		if (item == null)
		{
			Debug.Log((object)$"{basePlayer} failed to spawn \"{array[0]}\" (tried to spawnitem \"{name}\")");
			return "Couldn't spawn " + name;
		}
		item?.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		BaseEntity arg = item.CreateWorldObject(pos);
		Debug.Log((object)$"{basePlayer} spawned \"{arg}\" at {pos} (via spawnitem)");
		string obj = item?.ToString();
		Vector3 val = pos;
		return "spawned " + obj + " at " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
	}

	[ServerVar(Name = "spawngrid")]
	public static string svspawngrid(string name, int width = 5, int height = 5, int spacing = 5)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ConsoleSystem.CurrentArgs.Player();
		EntitySpawnRequest spawnEntityFromName = GetSpawnEntityFromName(name);
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		Quaternion rotation = ((Component)basePlayer).transform.rotation;
		((Quaternion)(ref rotation)).eulerAngles = new Vector3(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		Matrix4x4 val = Matrix4x4.TRS(((Component)basePlayer).transform.position, ((Component)basePlayer).transform.rotation, Vector3.one);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Vector3 pos = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3((float)(i * spacing), 0f, (float)(j * spacing)));
				BaseEntity baseEntity = GameManager.server.CreateEntity(spawnEntityFromName.PrefabName, pos, rotation);
				if ((Object)(object)baseEntity == (Object)null)
				{
					Debug.Log((object)$"{basePlayer} failed to spawn \"{spawnEntityFromName.PrefabName}\" (tried to spawn \"{name}\")");
					return "Couldn't spawn " + name;
				}
				baseEntity.Spawn();
			}
		}
		Debug.Log((object)($"{basePlayer} spawned ({width * height}) " + spawnEntityFromName.PrefabName));
		return $"spawned ({width * height}) " + spawnEntityFromName.PrefabName;
	}

	[ServerVar]
	public static void spawnlootfrom(Arg args)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		string @string = args.GetString(0, string.Empty);
		int @int = args.GetInt(1, 1);
		Vector3 vector = args.GetVector3(1, Object.op_Implicit((Object)(object)basePlayer) ? basePlayer.CenterPoint() : Vector3.zero);
		if (string.IsNullOrEmpty(@string))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(@string, vector);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.Spawn();
		basePlayer.ChatMessage("Contents of " + @string + " spawned " + @int + " times");
		LootContainer component = ((Component)baseEntity).GetComponent<LootContainer>();
		if ((Object)(object)component != (Object)null)
		{
			for (int i = 0; i < @int * component.maxDefinitionsToSpawn; i++)
			{
				component.lootDefinition.SpawnIntoContainer(basePlayer.inventory.containerMain);
			}
		}
		baseEntity.Kill();
	}

	public static int DeleteBy(ulong id)
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		list.Add(id);
		int result = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		return result;
	}

	[ServerVar(Help = "Destroy all entities created by provided users (separate users by space)")]
	public static int DeleteBy(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			return 0;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		string[] args = arg.Args;
		for (int i = 0; i < args.Length; i++)
		{
			if (ulong.TryParse(args[i], out var result))
			{
				list.Add(result);
			}
		}
		int result2 = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		return result2;
	}

	private static int DeleteBy(List<ulong> ids)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseEntity baseEntity = (BaseEntity)enumerator.Current;
				if ((Object)(object)baseEntity == (Object)null)
				{
					continue;
				}
				bool flag = false;
				foreach (ulong id in ids)
				{
					if (baseEntity.OwnerID == id)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					((FacepunchBehaviour)baseEntity).Invoke((Action)baseEntity.KillMessage, (float)num * 0.2f);
					num++;
				}
			}
			return num;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Destroy all entities created by users in the provided text block (can use with copied results from ent auth)")]
	public static void DeleteByTextBlock(Arg arg)
	{
		if (arg.Args.Length != 1)
		{
			arg.ReplyWith("Invalid arguments, provide a text block surrounded by \" and listing player id's at the start of each line");
			return;
		}
		MatchCollection matchCollection = Regex.Matches(arg.GetString(0, ""), "^\\b\\d{17}", RegexOptions.Multiline);
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (Match item in matchCollection)
		{
			if (ulong.TryParse(item.Value, out var result))
			{
				list.Add(result);
			}
		}
		int num = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		arg.ReplyWith($"Destroyed {num} entities");
	}

	[ServerVar]
	public static void set_battery_charge(Arg arg)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Usage: set_battery_charge <charge>");
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		ElectricBattery electricBattery = GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, basePlayer.eyes.HeadRay(), 0f, 5f, -5, (QueryTriggerInteraction)0) as ElectricBattery;
		if ((Object)(object)electricBattery == (Object)null)
		{
			arg.ReplyWith("Not looking at battery");
			return;
		}
		electricBattery.SetCharge(@float);
		arg.ReplyWith($"Set battery charge to {@float}");
	}

	[ServerVar(EditorOnly = true)]
	public static void test_pooling(Arg args)
	{
	}
}


using UnityEngine;

private struct EntityInfo
{
	public BaseNetworkable entity;

	public NetworkableId entityID;

	public uint groupID;

	public NetworkableId parentID;

	public string status;

	public EntityInfo(BaseNetworkable src)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		entity = src;
		BaseEntity baseEntity = entity as BaseEntity;
		BaseEntity baseEntity2 = (((Object)(object)baseEntity != (Object)null) ? baseEntity.GetParentEntity() : null);
		NetworkableId val;
		NetworkableId val2;
		if (!((Object)(object)entity != (Object)null) || entity.net == null)
		{
			val = default(NetworkableId);
			val2 = val;
		}
		else
		{
			val2 = entity.net.ID;
		}
		entityID = val2;
		groupID = (((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null) ? entity.net.group.ID : 0u);
		NetworkableId val3;
		if (!((Object)(object)baseEntity != (Object)null))
		{
			val = default(NetworkableId);
			val3 = val;
		}
		else
		{
			val3 = baseEntity.parentEntity.uid;
		}
		parentID = val3;
		if ((Object)(object)baseEntity != (Object)null)
		{
			val = baseEntity.parentEntity.uid;
			if (((NetworkableId)(ref val)).IsValid)
			{
				if ((Object)(object)baseEntity2 == (Object)null)
				{
					status = "orphan";
				}
				else
				{
					status = "child";
				}
				return;
			}
		}
		status = string.Empty;
	}
}


public struct EntitySpawnRequest
{
	public string PrefabName;

	public string Error;

	public bool Valid => string.IsNullOrEmpty(Error);
}


using System;
using UnityEngine;

[Factory("env")]
public class Env : ConsoleSystem
{
	[ClientVar(Default = "1")]
	public static bool nightlight_enabled = true;

	[ReplicatedVar(Default = "0")]
	public static bool redMoon = false;

	[ClientVar(Default = "0", Help = "Toggles nightlight screen effect when using debug camera")]
	public static bool nightlight_debugcamera_enabled = true;

	private static float nightlight_distance_internal = 7f;

	private static float nightlight_fadefraction_internal = 0.65f;

	private static float nightlight_brightness_internal = 0.022f;

	[ServerVar]
	public static bool progresstime
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return false;
			}
			return TOD_Sky.Instance.Components.Time.ProgressTime;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Components.Time.ProgressTime = value;
			}
		}
	}

	[ServerVar(ShowInAdminUI = true)]
	public static float time
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0f;
			}
			return TOD_Sky.Instance.Cycle.Hour;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Hour = value;
			}
		}
	}

	[ServerVar]
	public static int day
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Day;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Day = value;
			}
		}
	}

	[ServerVar]
	public static int month
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Month;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Month = value;
			}
		}
	}

	[ServerVar]
	public static int year
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Year;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Year = value;
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float oceanlevel
	{
		get
		{
			return WaterSystem.OceanLevel;
		}
		set
		{
			WaterSystem.OceanLevel = value;
		}
	}

	[ReplicatedVar(Default = "7")]
	public static float nightlight_distance
	{
		get
		{
			return nightlight_distance_internal;
		}
		set
		{
			value = Mathf.Clamp(value, 0f, 25f);
			nightlight_distance_internal = value;
		}
	}

	[ReplicatedVar(Default = "0.65")]
	public static float nightlight_fadefraction
	{
		get
		{
			return nightlight_fadefraction_internal;
		}
		set
		{
			nightlight_fadefraction_internal = value;
		}
	}

	[ReplicatedVar(Default = "0.022")]
	public static float nightlight_brightness
	{
		get
		{
			return nightlight_brightness_internal;
		}
		set
		{
			value = Mathf.Clamp(value, 0f, 0.2f);
			nightlight_brightness_internal = value;
		}
	}

	[ServerVar]
	public static void addtime(Arg arg)
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			DateTime dateTime = TOD_Sky.Instance.Cycle.DateTime.AddTicks(arg.GetTicks(0, 0L));
			TOD_Sky.Instance.Cycle.DateTime = dateTime;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

[Factory("events")]
public class Events : ConsoleSystem
{
	public class PendingEventChange
	{
		public string Id;

		public float? MinHours;

		public float? MaxHours;

		public bool? Enabled;

		public bool Invalid;

		public PendingEventChange(string id)
		{
			Id = id;
		}
	}

	private const string BradleyEventId = "bradley";

	private static List<PendingEventChange> TargetChanges = new List<PendingEventChange>();

	private static PendingEventChange GetPendingChanges(string id, bool create)
	{
		PendingEventChange pendingEventChange = TargetChanges.FirstOrDefault((PendingEventChange c) => c.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
		if (pendingEventChange == null && create)
		{
			pendingEventChange = new PendingEventChange(id);
			TargetChanges.Add(pendingEventChange);
		}
		return pendingEventChange;
	}

	private static void ApplyAllChanges()
	{
		foreach (PendingEventChange targetChange in TargetChanges)
		{
			UpdateServerEvent(targetChange);
		}
		TargetChanges.RemoveAll((PendingEventChange c) => c.Invalid);
	}

	public static void UpdateServerEvent(PendingEventChange targetState)
	{
		if (targetState.Id == "bradley")
		{
			Bradley.enabled = targetState.Enabled ?? Bradley.enabled;
			Bradley.respawnDelayMinutes = targetState.MinHours ?? targetState.MaxHours ?? Bradley.respawnDelayMinutes;
		}
		else if (HasAnyEvents())
		{
			EventSchedule eventSchedule = FindEventById(targetState.Id);
			if ((Object)(object)eventSchedule == (Object)null)
			{
				Debug.LogWarning((object)("Unknown event '" + targetState.Id + "' when applying settings to server events"));
				targetState.Invalid = true;
			}
			else
			{
				UpdateScheduleFromConVars(eventSchedule);
			}
		}
	}

	public static void UpdateScheduleFromConVars(EventSchedule schedule)
	{
		PendingEventChange pendingChanges = GetPendingChanges(schedule.Key, create: false);
		if (pendingChanges != null)
		{
			((Behaviour)schedule).enabled = pendingChanges.Enabled ?? ((Behaviour)schedule).enabled;
			schedule.minimumHoursBetween = pendingChanges.MinHours ?? schedule.minimumHoursBetween;
			schedule.maxmumHoursBetween = pendingChanges.MaxHours ?? schedule.maxmumHoursBetween;
		}
	}

	[ServerVar]
	public static void print_server_events(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (EventSchedule allEvent in EventSchedule.allEvents)
		{
			if (string.IsNullOrEmpty(allEvent.Key))
			{
				stringBuilder.AppendLine("WARNING: Missing event key for prefab '" + ((Object)((Component)allEvent).gameObject).name + "'");
				continue;
			}
			stringBuilder.AppendLine(allEvent.Key ?? "");
			stringBuilder.AppendLine($"  - enabled: {((Behaviour)allEvent).enabled}");
			stringBuilder.AppendLine($"  - min hours: {allEvent.minimumHoursBetween}");
			stringBuilder.AppendLine($"  - max hours: {allEvent.maxmumHoursBetween}");
			stringBuilder.AppendLine();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void set_event_enabled(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_enabled <event_name> <true|false>");
			return;
		}
		string @string = arg.GetString(0, "");
		bool @bool = arg.GetBool(1, false);
		GetPendingChanges(@string, create: true).Enabled = @bool;
		ApplyAllChanges();
		arg.ReplyWith((@bool ? "Enabled" : "Disabled") + " event '" + @string + "'");
	}

	[ServerVar]
	public static void set_event_min_delay(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_max_delay <event_name> <float>");
			return;
		}
		string @string = arg.GetString(0, "");
		float @float = arg.GetFloat(1, 0f);
		GetPendingChanges(@string, create: true).MinHours = @float;
		ApplyAllChanges();
		arg.ReplyWith($"Set minimum delay for '{@string}' to {@float} in-game hours");
	}

	[ServerVar]
	public static void set_event_max_delay(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_max_delay <event_name> <float>");
			return;
		}
		string @string = arg.GetString(0, "");
		float @float = arg.GetFloat(1, 0f);
		GetPendingChanges(@string, create: true).MaxHours = @float;
		ApplyAllChanges();
		arg.ReplyWith($"Set maximum delay for '{@string}' to {@float} in-game hours");
	}

	private static bool HasAnyEvents()
	{
		return EventSchedule.allEvents.Count > 0;
	}

	private static EventSchedule FindEventById(string key)
	{
		return EventSchedule.allEvents.FirstOrDefault((EventSchedule e) => e.Key.Equals(key, StringComparison.OrdinalIgnoreCase));
	}
}


public class PendingEventChange
{
	public string Id;

	public float? MinHours;

	public float? MaxHours;

	public bool? Enabled;

	public bool Invalid;

	public PendingEventChange(string id)
	{
		Id = id;
	}
}


[Factory("file")]
public class FileConVar : ConsoleSystem
{
	[ClientVar]
	public static bool debug
	{
		get
		{
			return FileSystem.LogDebug;
		}
		set
		{
			FileSystem.LogDebug = value;
		}
	}

	[ClientVar]
	public static bool time
	{
		get
		{
			return FileSystem.LogTime;
		}
		set
		{
			FileSystem.LogTime = value;
		}
	}
}


using UnityEngine;

[Factory("fps")]
public class FPS : ConsoleSystem
{
	private static int _limit = 240;

	private static int m_graph;

	[ClientVar(Saved = true)]
	[ServerVar(Saved = true)]
	public static int limit
	{
		get
		{
			if (_limit == -1)
			{
				_limit = Application.targetFrameRate;
			}
			return _limit;
		}
		set
		{
			_limit = value;
			Application.targetFrameRate = _limit;
		}
	}

	[ClientVar]
	public static int graph
	{
		get
		{
			return m_graph;
		}
		set
		{
			m_graph = value;
			if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
			{
				FPSGraph component = ((Component)MainCamera.mainCamera).GetComponent<FPSGraph>();
				if (Object.op_Implicit((Object)(object)component))
				{
					component.Refresh();
				}
			}
		}
	}
}


using UnityEngine;

[Factory("gamemode")]
public class gamemode : ConsoleSystem
{
	[ServerUserVar]
	public static void setteam(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			int @int = arg.GetInt(0, 0);
			if (@int >= 0 && @int < activeGameMode.GetNumTeams())
			{
				activeGameMode.ResetPlayerScores(basePlayer);
				activeGameMode.SetPlayerTeam(basePlayer, @int);
				basePlayer.Respawn();
			}
		}
	}

	[ServerVar]
	public static void set(Arg arg)
	{
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			Debug.Log((object)"Invalid gamemode");
		}
		BaseGameMode baseGameMode = null;
		GameObjectRef gameObjectRef = null;
		GameModeManifest gameModeManifest = GameModeManifest.Get();
		Debug.Log((object)("total gamemodes : " + gameModeManifest.gameModePrefabs.Count));
		foreach (GameObjectRef gameModePrefab in gameModeManifest.gameModePrefabs)
		{
			BaseGameMode component = gameModePrefab.Get().GetComponent<BaseGameMode>();
			if (component.shortname == @string)
			{
				baseGameMode = component;
				gameObjectRef = gameModePrefab;
				Debug.Log((object)("Found :" + component.shortname + " prefab name is :" + component.PrefabName + ": rpath is " + gameModePrefab.resourcePath + ":"));
				break;
			}
			Debug.Log((object)("search name " + @string + "searched against : " + component.shortname));
		}
		if ((Object)(object)baseGameMode == (Object)null)
		{
			Debug.Log((object)("Unknown gamemode : " + @string));
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			if (baseGameMode.shortname == activeGameMode.shortname)
			{
				Debug.Log((object)"Same gamemode, resetting");
			}
			if (activeGameMode.permanent)
			{
				Debug.LogError((object)"This game mode is permanent, you must reset the server to switch game modes.");
				return;
			}
			activeGameMode.ShutdownGame();
			activeGameMode.Kill();
			BaseGameMode.SetActiveGameMode(null, serverside: true);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(gameObjectRef.resourcePath, Vector3.zero, Quaternion.identity);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			Debug.Log((object)("Spawning new game mode : " + baseGameMode.shortname));
			baseEntity.Spawn();
		}
		else
		{
			Debug.Log((object)("Failed to create new game mode :" + baseGameMode.PrefabName));
		}
	}
}


using Rust;
using UnityEngine;
using UnityEngine.Scripting;

[Factory("gc")]
public class GC : ConsoleSystem
{
	[ClientVar]
	public static bool buffer_enabled = true;

	[ClientVar]
	public static int debuglevel = 1;

	[ClientVar(Saved = true)]
	public static int buffer = GC.gcDefaultValue;

	public static int safeBuffer
	{
		get
		{
			return GC.GetSafeGCValue(buffer);
		}
		set
		{
			buffer = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool incremental_enabled
	{
		get
		{
			return GarbageCollector.isIncremental;
		}
		set
		{
			Debug.LogWarning((object)"Cannot set gc.incremental as it is read only");
		}
	}

	[ServerVar]
	[ClientVar]
	public static int incremental_milliseconds
	{
		get
		{
			return (int)(GarbageCollector.incrementalTimeSliceNanoseconds / 1000000);
		}
		set
		{
			GarbageCollector.incrementalTimeSliceNanoseconds = 1000000uL * (ulong)Mathf.Max(value, 0);
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool enabled
	{
		get
		{
			return GC.Enabled;
		}
		set
		{
			Debug.LogWarning((object)"Cannot set gc.enabled as it is read only");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void collect()
	{
		GC.Collect();
	}

	[ClientVar]
	[ServerVar]
	public static void unload()
	{
		Resources.UnloadUnusedAssets();
	}

	[ClientVar]
	[ServerVar]
	public static void alloc(Arg args)
	{
		byte[] array = new byte[args.GetInt(0, 1048576)];
		args.ReplyWith("Allocated " + array.Length + " bytes");
	}
}


